           }
            }
            break;
        }

        case WM_ENTERMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = TRUE;
            break;
        }

        case WM_EXITMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = FALSE;
            break;
        }

        case WM_COMMAND:
        {
            VIEWFrameCommand(pasHost, wParam, lParam);
            break;
        }

        case WM_INITMENU:
        {
            if ((HMENU)wParam == pasHost->m_pView->m_viewMenuBar)
            {
                VIEWFrameInitMenuBar(pasHost);
            }
            break;
        }

        case WM_MENUSELECT:
        {
            VIEWFrameOnMenuSelect(pasHost, wParam, lParam);
            break;
        }

        case WM_PALETTECHANGED:
            //
            // The system palette has changed - repaint the window.
            //
            VIEW_InvalidateRgn(pasHost, NULL);

            //
            // The system palette has changed.  If we are not the
            // window that triggered this message then realize our
            // palette now to set up our new palette mapping.
            //
            if ((HWND)wParam == hwnd)
            {
                //
                // If this window caused the change return without
                // realizing our logical palette or we could end up in
                // an infinite loop.
                //
                break;
            }
            TRACE_OUT(("Palette changed - fall through to realize palette (%x)",
                                                           hwnd));

            //
            // Do not break here but FALL THROUGH to the code which
            // realizes the remote palette into this window.  This allows
            // the window to grab some color entries for itself in the new
            // system palette.
            //

        case WM_QUERYNEWPALETTE:
            rc = FALSE;

            if (message == WM_QUERYNEWPALETTE)
            {
                TRACE_OUT(( "WM_QUERYNEWPALETTE hwnd(%x)", hwnd));
            }

            if (g_usrPalettized)
            {
                HDC         hdc;
                HPALETTE    hPalOld;
                UINT        cChangedEntries;

                //
                // Realize this window's palette, and force a repaint
                // if necessary.
                //
                hdc = GetDC(hwnd);
                hPalOld = SelectPalette(hdc, pasHost->pmPalette, FALSE);
                cChangedEntries = RealizePalette(hdc);
                SelectPalette(hdc, hPalOld, FALSE);
                ReleaseDC(hwnd, hdc);

                rc = (cChangedEntries > 0);
                if (rc)
                {
                    // Have to repaint this window
                    VIEW_InvalidateRgn(pasHost, NULL);
                }
            }
            break;

        case WM_GETMINMAXINFO:
        {
            RECT rc;
            LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;
            int cx,cy;

            if (!pasHost)
            {
                // We're not created yet; bail.
                break;
            }

            //
            // Calculate the ideal maximized size for this window
            //
            VIEWFrameGetSize(pasHost, &rc);

            //
            // If it's bigger than the local screen, clip it.
            //
            cx = min(rc.right - rc.left, m_pasLocal->cpcCaps.screen.capsScreenWidth);
            cy = min(rc.bottom - rc.top, m_pasLocal->cpcCaps.screen.capsScreenHeight);

            lpmmi->ptMaxSize.x = cx;
            lpmmi->ptMaxSize.y = cy;

            lpmmi->ptMaxTrackSize.x = cx;
            lpmmi->ptMaxTrackSize.y = cy;

            //
            // Make sure that we don't size this window too narrow.  Keep
            // space for borders and one window bar button + scroll ctl.
            //
            lpmmi->ptMinTrackSize.x = 2*::GetSystemMetrics(SM_CXSIZEFRAME) +
                (m_viewItemCX + m_viewEdgeCX) + m_viewItemScrollCX;

            //
            // And prevent sizing too short.  Keep space for borders, menu
            // bar, status bar, and window bar
            //
            lpmmi->ptMinTrackSize.y = 2*::GetSystemMetrics(SM_CYSIZEFRAME) +
                ::GetSystemMetrics(SM_CYCAPTION) + ::GetSystemMetrics(SM_CYMENU);

            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                lpmmi->ptMinTrackSize.y += m_viewStatusBarCY + m_viewEdgeCY;
            }
            break;
        }

        case WM_SIZE:
        {
            if (wParam != SIZE_MINIMIZED)
            {
                VIEWFrameResize(pasHost);
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;

    }

    DebugExitDWORD(ASShare::VIEW_FrameWindowProc, rc);
    return(rc);
}



//
// VIEWFrameCreate()
//
BOOL ASShare::VIEWFrameCreate(ASPerson * pasPerson)
{
    RECT    rect;
    BOOL    rc = FALSE;

    DebugEntry(VIEWFrameCreate);

    ValidateView(pasPerson);

    //
    // Creates the children which lie in the frame's client:
    //      * the toolbar hugs the top
    //      * the statusbar hugs the bottom
    //      * the tray hugs the left underneath the toolbar and above the
    //          statusbar
    //      * the view fills in what's left
    //

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Create the statusbar (hugs bottom)
    //
    pasPerson->m_pView->m_viewStatusBar = ::CreateWindowEx(0, STATUSCLASSNAME,
        NULL, WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE |
        SBARS_SIZEGRIP,
        rect.left, rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
        m_viewStatusBarCY, pasPerson->m_pView->m_viewFrame, NULL, g_asInstance,
        NULL);
    if (!pasPerson->m_pView->m_viewStatusBar)
    {
        ERROR_OUT(("Couldn't create statusbar for frame of person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;


    //
    // Create the view (takes up rest of client)
    //
    if (!CreateWindowEx(WS_EX_CLIENTEDGE,
            VIEW_CLIENT_CLASS_NAME, NULL,
            WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VISIBLE | WS_CHILD |
                WS_VSCROLL | WS_HSCROLL,
            rect.left, rect.top,
            rect.right - rect.left, rect.bottom - rect.top,
            pasPerson->m_pView->m_viewFrame,
            NULL, g_asInstance, pasPerson))
    {
        ERROR_OUT(("VIEWFrameCreate: Failed to create view"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEWFrameCreate, rc);
    return(rc);
}



//
// VIEWFrameResize()
// Repositions the child windows when the frame is resized.
//
void ASShare::VIEWFrameResize(ASPerson * pasPerson)
{
    RECT    rect;

    DebugEntry(ASShare::VIEWFrameResize);

    ValidateView(pasPerson);

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Move the statusbar
    //
    if ((pasPerson->m_pView->m_viewStatusBar != NULL) &&
        (pasPerson->m_pView->m_viewStatusBarOn))
    {
        MoveWindow(pasPerson->m_pView->m_viewStatusBar, rect.left,
            rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
            m_viewStatusBarCY, TRUE);
        rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;
    }

    //
    // Move the view
    //
    MoveWindow(pasPerson->m_pView->m_viewClient, rect.left, rect.top,
        rect.right - rect.left, rect.bottom - rect.top, TRUE);

    DebugExitVOID(ASShare::VIEWFrameResize);
}



//
// VIEWFrameResizeChanged()
//
// Called when the widgets of the frame (the status bar, the window bar, etc.)
// come or go.  We may need to shrink the window, if the view is going
// to end up being bigger than the host's desktop.
//
void ASShare::VIEWFrameResizeChanged(ASPerson * pasHost)
{
    RECT            rcView;

    DebugEntry(ASShare::VIEWFrameResizeChanged);

    // Get current view size
    GetClientRect(pasHost->m_pView->m_viewClient, &rcView);

    //
    // The view area can't be bigger than the remote's desktop area
    //
    if ((rcView.bottom - rcView.top)  >= pasHost->viewExtent.y)
    {
        RECT            rcWindowCur;
        RECT            rcWindowMax;

        // Get current frame size
        GetWindowRect(pasHost->m_pView->m_viewFrame, &rcWindowCur);

        // Get maximum frame size
        VIEWFrameGetSize(pasHost, &rcWindowMax);

        // Resize vertically to just hold everything
        SetWindowPos(pasHost->m_pView->m_viewFrame, NULL, 0, 0,
            rcWindowCur.right - rcWindowCur.left,
            rcWindowMax.bottom - rcWindowMax.top,
            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }
    else
    {
        // We can stay the same size, and just shuffle the pieces around
        VIEWFrameResize(pasHost);
    }

    DebugExitVOID(ASShare::VIEWFrameResizeChanged);
}



//
// VIEWFrameCommand()
//
// Handles commands from menus/accelerators for frame views
//
void ASShare::VIEWFrameCommand
(
    ASPerson*   pasHost,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    UINT            cmd;
    MENUITEMINFO    mi;

    DebugEntry(ASShare::VIEWFrameCommand);

    ValidateView(pasHost);

    cmd = GET_WM_COMMAND_ID(wParam, lParam);
    switch (cmd)
    {
        case CMD_TAKECONTROL:
        {
            CA_TakeControl(pasHost);
            break;
        }

        case CMD_CANCELCONTROL:
        {
            CA_CancelTakeControl(pasHost, TRUE);
            break;
        }

        case CMD_RELEASECONTROL:
        {
            CA_ReleaseControl(pasHost, TRUE);
            break;
        }

        case CMD_CTRLALTDEL:
        {
            AWC_SendMsg(pasHost->mcsID, AWC_MSG_SAS, 0, 0);
            break;
        }

        case CMD_VIEWSTATUSBAR:
        {
            ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));

            // Toggle show/hide of status bar, then resize
            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                pasHost->m_pView->m_viewStatusBarOn = FALSE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_HIDE);
            }
            else
            {
                pasHost->m_pView->m_viewStatusBarOn = TRUE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_SHOW);
            }

            VIEWFrameResizeChanged(pasHost);
            break;
        }

        case CMD_VIEWFULLSCREEN:
        {
            VIEWFrameFullScreen(pasHost, (pasHost->m_pView->m_viewFullScreen == 0));
            break;
        }

        case CMD_HELPTOPICS:
        {
            VIEWFrameHelp(pasHost);
            break;
        }

        case CMD_HELPABOUT:
        {
            VIEWFrameAbout(pasHost);
            break;
        }

        default:
        {
            if ((cmd >= CMD_FORWARDCONTROLSTART) && (cmd < CMD_FORWARDCONTROLMAX))
            {
                if ((pasHost->m_caControlledBy == m_pasLocal))
                {
                    //
                    // This is a request to pass control.  Get the item data,
                    // the remote's MCS ID, then look to see if this person is
                    // still in the share.  If so, pass control to them.
                    //
                    ZeroMemory(&mi, sizeof(mi));
                    mi.cbSize   = sizeof(mi);
                    mi.fMask    = MIIM_DATA;
                    GetMenuItemInfo(GetSubMenu(GetSubMenu(pasHost->m_pView->m_viewMenuBar,
                        IDSM_CONTROL), POS_FORWARDCONTROLCMD), cmd, FALSE, &mi);
                    if (!mi.dwItemData)
                    {
                        ERROR_OUT(("No item data for command %d", cmd));
                    }
                    else
                    {
                        ASPerson * pasT;

                        if (SC_ValidateNetID((MCSID)mi.dwItemData, &pasT))
                        {
                            CA_PassControl(pasHost, pasT);
                        }
                    }
                }
            }
            else
            {
                ERROR_OUT(("Unrecognized WM_COMMAND id"));
            }
            break;
        }
    }

    DebugExitVOID(ASShare::VIEWFrameCommand);
}



//
// ASShare::VIEWFrameInitMenuBar()
//
void ASShare::VIEWFrameInitMenuBar(ASPerson*   pasHost)
{
    HMENU       hMenu;
    HMENU       hSubMenu;
    int         iItem;
    MENUITEMINFO    mi;
    UINT        cmd;
    UINT        ids;
    UINT        flags;
    char        szItem[256];

    DebugEntry(ASShare::VIEWFrameInitMenu);

    ValidateView(pasHost);
    hMenu = pasHost->m_pView->m_viewMenuBar;
    ASSERT(hMenu);

    //
    // CONTROL MENU
    //

    cmd = CMD_TAKECONTROL;
    ids = IDS_CMD_TAKECONTROL;
    flags = MF_ENABLED;

    if (pasHost->m_caControlledBy == m_pasLocal)
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_RELEASECONTROL;
        ids = IDS_CMD_RELEASECONTROL;

        //
        // If the remote is unattended and we're in control, no releasing.
        //
        if (pasHost->cpcCaps.general.typeFlags & AS_UNATTENDED)
            flags = MF_GRAYED;
    }
    else if ((m_caWaitingForReplyFrom == pasHost) &&
             (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL))
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_CANCELCONTROL;
        ids = IDS_CMD_CANCELCONTROL;
    }
    else if (!pasHost->m_caAllowControl || pasHost->m_caControlledBy)
    {
        //
        // Host isn't allowing control, or somebody else is in control right
        // now.
        //
        flags = MF_GRAYED;
    }
    flags |= MF_STRING | MF_BYPOSITION;

    ::LoadString(g_asInstance, ids, szItem, sizeof(szItem));

    hSubMenu = GetSubMenu(hMenu, IDSM_CONTROL);
    ModifyMenu(hSubMenu, POS_CONTROLCMD, flags, cmd, szItem);

    //
    // If we're in control, and there's another 3.0 dude in the conference,
    // enable PassControl and build the popup.
    //
    EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_GRAYED | MF_BYPOSITION);
    if (pasHost->m_caControlledBy == m_pasLocal)
    {
        ASPerson *  pasT;
        HMENU       hPassMenu;

        hPassMenu = GetSubMenu(hSubMenu, POS_FORWARDCONTROLCMD);
        ASSERT(IsMenu(hPassMenu));

        //
        // Delete existing items.
        //
        iItem = GetMenuItemCount(hPassMenu);
        while (iItem > 0)
        {
            iItem--;
            DeleteMenu(hPassMenu, iItem, MF_BYPOSITION);
        }

        //
        // Add items for the other 3.0 nodes besides us & the host.
        //
        iItem = CMD_FORWARDCONTROLSTART;
        pasT = m_pasLocal->pasNext;
        while (pasT != NULL)
        {
            if (pasT != pasHost)
            {
                //
                // This dude is a candidate.  We must store the MCS IDs since the
                // any person could go away while we're in menu mode.
                //
                ZeroMemory(&mi, sizeof(mi));
                mi.cbSize       = sizeof(mi);
                mi.fMask        = MIIM_ID | MIIM_STATE | MIIM_TYPE | MIIM_DATA;
                mi.fType        = MFT_STRING;
                mi.fState       = MFS_ENABLED;
                mi.wID          = iItem;
                mi.dwItemData   = pasT->mcsID;
                mi.dwTypeData   = pasT->scName;
                mi.cch          = lstrlen(pasT->scName);

                //
                // Append this to the menu
                //
                InsertMenuItem(hPassMenu, -1, TRUE, &mi);

                iItem++;
            }

            pasT = pasT->pasNext;
        }

        //
        // Enable the Pass Control submenu if there's somebody on the
        // menu.
        //
        if (iItem != CMD_FORWARDCONTROLSTART)
        {
            EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_ENABLED | MF_BYPOSITION);
        }
    }



    //
    // VIEW MENU
    //

    // Status bar
    ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));
    if (pasHost->m_pView->m_viewStatusBarOn)
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_CHECKED | MF_BYCOMMAND);
    }
    else
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }

    DebugExitVOID(ASShare::VIEWFrameInitMenu);
}




//
// VIEWFrameOnMenuSelect()
//
void ASShare::VIEWFrameOnMenuSelect
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HMENU           hMenu;
    int             uItem;
    UINT            flags;
    UINT            idsStatus = IDS_STATUS_NONE;

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);

    //
    // Extract the params out (menuselect is messy)
    //
    hMenu   = (HMENU)lParam;
    uItem   = (int)LOWORD(wParam);
    if ((short)HIWORD(wParam) == -1)
    {
        flags = 0xFFFFFFFF;
    }
    else
    {
        flags = HIWORD(wParam);
    }

    if ((LOWORD(flags) == 0xFFFF) && !hMenu)
    {
        // Menu mode is ending.  Put back original status.
        idsStatus = pasHost->m_pView->m_viewStatus;
        DC_QUIT;
    }

    if (!(flags & MF_POPUP))
    {
        if (flags & MF_SEPARATOR)
        {
            // No status
        }
        else if (flags & MF_SYSMENU)
        {
            // No status
        }
        else if ((uItem >= CMD_APPSTART) && (uItem < CMD_APPMAX))
        {
            // One of an unbounded set of items in the Window popup
            idsStatus = IDS_STATUS_CMDS_APP;
        }
        else if ((uItem >= CMD_FORWARDCONTROLSTART) && (uItem < CMD_FORWARDCONTROLMAX))
        {
            // One of an unbounded set of items in the Forward Control popup
            idsStatus = IDS_STATUS_CMDS_FORWARD;
        }
        else
        {
            // A normal command, just add offset to CMD id
            idsStatus = uItem + IDS_STATUS_CMD_START;
        }
    }
    else
    {
        // This is a popup menu
        if (hMenu == pasHost->m_pView->m_viewMenuBar)
        {
            // It's a popup from the top level menu bar.  uItem is the index
            switch (uItem)
            {
                case IDSM_CONTROL:
                    idsStatus = IDS_STATUS_MENU_CONTROL;
                    break;

                case IDSM_VIEW:
                    idsStatus = IDS_STATUS_MENU_VIEW;
                    break;

                case IDSM_WINDOW:
                    idsStatus = IDS_STATUS_MENU_WINDOW;
                    break;

                case IDSM_HELP:
                    idsStatus = IDS_STATUS_MENU_HELP;
                    break;

                default:
                    ERROR_OUT(("AS: Unknown submenu index %d of frame", uItem));
                    break;
            }
        }
        else if (hMenu == GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL))
        {
            // This is a popup off the Control menu.  The only one we have is Forward
            idsStatus = IDS_STATUS_MENU_FORWARDCONTROL;
        }
        else if (flags & MF_SYSMENU)
        {
            // System menu
        }
    }

DC_EXIT_POINT:
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);
}


//
// VIEWFrameHelp()
//
void ASShare::VIEWFrameHelp(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameHelp);

    DebugExitVOID(ASShare::VIEWFrameHelp);
}



//
// VIEWFrameAbout()
//
void ASShare::VIEWFrameAbout(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameAbout);

    //
    // We make use of the standard centered-disabled-goes-away properly
    // VIEW_Message() stuff.
    //
    VIEW_Message(pasHost, IDS_ABOUT);

    DebugExitVOID(ASShare::VIEWFrameAbout);
}




//
// VIEWFrameGetSize()
// This returns back a rectangle for the ideal size of the frame.  It will
// fit the view, menu, tools, tray, status, etc.
//
void ASShare::VIEWFrameGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWFrameGetSize);

    ValidateView(pasPerson);

    VIEWClientGetSize(pasPerson, lprc);

    //
    // Add in space for statusbar if it's on, etc.
    //
    if (pasPerson->m_pView->m_viewStatusBarOn)
    {
        lprc->bottom += m_viewStatusBarCY + m_viewEdgeCY;
    }

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        //
        // Adjust for frame styles including menu bar.
        //
        AdjustWindowRectEx(lprc, WS_OVERLAPPEDWINDOW, TRUE, WS_EX_WINDOWEDGE);
    }

    DebugExitVOID(ASShare::VIEWFrameGetSize);
}




//
// VIEWFrameFullScreen()
//
// This puts into or out of screen mode.  We remove all the frame goop
// including scrollbars, so that the view area is identical to the screen.
//
void ASShare::VIEWFrameFullScreen(ASPerson * pasPerson, BOOL fFull)
{
    LONG    lStyle;
    RECT    rcNew;

    DebugEntry(ASShare::VIEWFrameFullScreen);

    //
    // Turn redraw OFF
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, FALSE, 0);

    if (fFull)
    {
        //
        // We're going into full screen mode.
        //

        ASSERT(!pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = TRUE;

        //
        // Save old window rect
        //
        ::GetWindowRect(pasPerson->m_pView->m_viewFrame,
            &pasPerson->m_pView->m_viewSavedWindowRect);

        //
        // Save old scroll pos and set to the origin.  Do this BEFORE
        // clearing style bits.
        //
        pasPerson->m_pView->m_viewSavedPos = pasPerson->m_pView->m_viewPos;
        VIEWClientScroll(pasPerson, 0, 0);

        //
        // Save current status bar state before turning it off temporarily.
        //
        if (pasPerson->m_pView->m_viewStatusBarOn)
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = TRUE;
            pasPerson->m_pView->m_viewStatusBarOn = FALSE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_HIDE);
        }
        else
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = FALSE;
        }

        //
        // Remove all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle &= ~WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_CAPTION | WS_THICKFRAME);
        lStyle |= WS_POPUP;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle &= ~WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle &= ~(WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Remove the menu bar
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, NULL);

        //
        // Set up to size window the size of the screen.
        //
        rcNew.left      = 0;
        rcNew.top       = 0;
        rcNew.right     = m_pasLocal->cpcCaps.screen.capsScreenWidth;
        rcNew.bottom    = m_pasLocal->cpcCaps.screen.capsScreenHeight;

        //
        // Create the moveable escape-out button in the lower right corner.
        //
        ::CreateWindowEx(0, VIEW_FULLEXIT_CLASS_NAME, NULL,
            WS_CHILD | WS_VISIBLE,
            rcNew.right - m_viewFullScreenCX - 2*m_viewEdgeCX,
            rcNew.top +  2*m_viewEdgeCY,
            m_viewFullScreenCX, m_viewFullScreenCY,
            pasPerson->m_pView->m_viewClient,
            (HMENU)0,
            g_asInstance,
            pasPerson);
    }
    else
    {
        //
        // We're coming out of full screen mode.
        //

        //
        // Destroy the escape-out button
        //
        ::DestroyWindow(::GetDlgItem(pasPerson->m_pView->m_viewClient, 0));

        //
        // Put back the menu bar.  Do this BEFORE clearing the full screen bit
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, pasPerson->m_pView->m_viewMenuBar);

        ASSERT(pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = FALSE;


        //
        // Put back old status bar state.
        //
        if (pasPerson->m_pView->m_viewSavedStatusBarOn)
        {
            pasPerson->m_pView->m_viewStatusBarOn = TRUE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_SHOW);
        }

        //
        // Add back all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle |= WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_POPUP);
        lStyle |= (WS_CAPTION | WS_THICKFRAME);
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle |= WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle |= (WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Put back old scroll pos AFTER style bits restore.
        //
        VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewSavedPos.x,
            pasPerson->m_pView->m_viewSavedPos.y);

        //
        // Restore the window back to where it started.
        //
        rcNew = pasPerson->m_pView->m_viewSavedWindowRect;
    }

    //
    // Resize, reframe, and repaint from scratch.
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, TRUE, 0);

    ::SetWindowPos(pasPerson->m_pView->m_viewFrame, NULL, rcNew.left,
        rcNew.top, rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
        SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOCOPYBITS);

    DebugExitVOID(ASShare::VIEWFrameFullScreen);
}



//
// VIEWClientGetSize()
// This returns back a rectangle for the ideal size of the view part of the
// frame client.  It will fit the extent of what we're viewing on the remote
// plus scrollbars.
//
void ASShare::VIEWClientGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWClientGetSize);

    ValidateView(pasPerson);

    lprc->left  = 0;
    lprc->top   = 0;
    lprc->right = pasPerson->viewExtent.x;
    lprc->bottom = pasPerson->viewExtent.y;

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        AdjustWindowRectEx(lprc, WS_CHILD, FALSE, WS_EX_CLIENTEDGE);

        lprc->right += GetSystemMetrics(SM_CXVSCROLL);
        lprc->bottom += GetSystemMetrics(SM_CYHSCROLL);
    }

    DebugExitVOID(ASShare::VIEWClientGetSize);
}


//
// VIEWClientWindowProc()
// Handles messages for the view window, a child in the client of the frame
// which displays the contents of the remote host's shared apps.
//
LRESULT CALLBACK VIEWClientWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_ViewWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_ViewWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    RECT        rcl;
    POINT       mousePos;
    SCROLLINFO  si;
    ASPerson *  pasPerson;

    DebugEntry(ASShare::VIEW_ViewWindowProc);

    pasPerson = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasPerson)
    {
        ValidateView(pasPerson);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasPerson = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasPerson);

            pasPerson->m_pView->m_viewClient = hwnd;
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasPerson != NULL)
            {
                pasPerson->m_pView->m_viewClient = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_ERASEBKGND:
        {
            //
            // BOGUS LAURABU:  Paint on erase then validate for faster
            // response.

            //
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWClientPaint(pasPerson);
            break;
        }

        case WM_SETFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = TRUE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_KILLFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = FALSE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        {
            VIEWClientMouseDown(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        {
            VIEWClientMouseUp(pasPerson, message, wParam, lParam, TRUE);
            break;
        }

        case WM_MOUSEMOVE:
        {
            VIEWClientMouseMove(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_MOUSEWHEEL:
        {
            //
            // We've handled it no matter what, don't pass it up the chain.
            //
            rc = TRUE;

            //
            // If we're not controlling this dude, try to use the mousewheel
            // to scroll.
            //
            if ((pasPerson->m_caControlledBy != m_pasLocal))
            {
                VIEWClientMouseWheel(pasPerson, wParam, lParam);
                break;
            }

            //
            // FALL THROUGH
            // Otherwise, we send the MOUSEWHEEL message to the host.
            //
        }

        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        {
            VIEWClientMouseMsg(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_TIMER:
        {
            if (wParam == IDT_AUTOSCROLL)
            {
                VIEWClientAutoScroll(pasPerson);
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // Check if capture got stolen away from us, if we think the
            // buttons are down fake a button up.
            //
            if (pasPerson->m_pView->m_viewMouseFlags != 0)
            {
                VIEWClientCaptureStolen(pasPerson);
            }
            break;
        }

        case WM_KEYDOWN:
        {
            WPARAM  wScrollNotify;
            UINT    uMsg;

            if ((pasPerson->m_caControlledBy == m_pasLocal))
            {
                goto KeyInput;
            }

            if (pasPerson->m_pView->m_viewFullScreen)
            {
                if (wParam == VK_ESCAPE)
                {
                    //
                    // Kick out of full screen mode.
                    //
                    VIEWFrameFullScreen(pasPerson, FALSE);
                }

                goto DefWndProc;
            }

            //
            // UP, DOWN, LEFT, and RIGHT are unambiguous about which
            // scrollbar is intended.
            //
            // For the others, unmodified is vertical and SHIFT is
            // horizontal.
            //
            if (::GetKeyState(VK_SHIFT) < 0)
            {
                uMsg = WM_HSCROLL;
            }
            else
            {
                uMsg = WM_VSCROLL;
            }

            switch (wParam)
            {
                //
                // These aren't ambiguous, we know which scrollbar is meant
                // by the direction.
                //
                case VK_UP:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_DOWN:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_LEFT:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_HSCROLL;
                    break;

                case VK_RIGHT:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_HSCROLL;
                    break;

                //
                // These are ambiguous, hence the SHIFT key as a
                // modifier.
                //
                case VK_PRIOR:
                    wScrollNotify = SB_PAGEUP;
                    break;

                case VK_NEXT:
                    wScrollNotify = SB_PAGEDOWN;
                    break;

                case VK_HOME:
                    wScrollNotify = SB_TOP;
                    break;

                case VK_END:
                    wScrollNotify = SB_BOTTOM;
                    break;

                default:
                    goto DefWndProc;
                    break;
            }

            SendMessage(hwnd, uMsg, MAKELONG(wScrollNotify, 0), 0L);
            break;
        }

        case WM_SYSKEYDOWN:
        {
            if ((pasPerson->m_caControlledBy == m_pasLocal))
            {
                goto KeyInput;
            }

            //
            // ALT-ENTER toggles full screen state, if it's available
            //
            if ((wParam == VK_RETURN) &&
                !(::GetMenuState(pasPerson->m_pView->m_viewMenuBar,
                CMD_VIEWFULLSCREEN, MF_BYCOMMAND) & MF_DISABLED))
            {
                VIEWFrameFullScreen(pasPerson,
                    (pasPerson->m_pView->m_viewFullScreen == 0));
            }
            goto DefWndProc;
            break;
        }


        case WM_KEYUP:
        case WM_SYSKEYUP:
        {
            //
            // If we're controlling this node, pass it along.  Otherwise,
            // call DefWindowProc() so key accels like Alt+Space for system
            // menu will kick in.
            //
            if ((pasPerson->m_caControlledBy == m_pasLocal))
            {
KeyInput:
                IM_OutgoingKeyboardInput(pasPerson, (UINT)wParam, (UINT)lParam);
            }
            else
            {
                goto DefWndProc;
            }
            break;
        }

        case WM_SETCURSOR:
        {
            if ((LOWORD(lParam) == HTCLIENT) && ((HWND)wParam == hwnd))
            {
                HCURSOR hCursor;
                POINT   cursorPoint;

                if ((pasPerson->m_caControlledBy == m_pasLocal))
                {
                    hCursor = m_cmArrowCursor;

                    //
                    // Only set the remote cursor if we're over shared space.
                    //
                    if (pasPerson->m_pView->m_viewFocus)
                    {
                        GetCursorPos(&cursorPoint);
                        ScreenToClient(hwnd, &cursorPoint);

                        if (VIEW_IsPointShared(pasPerson, cursorPoint))
                        {
                            hCursor = pasPerson->cmhRemoteCursor;
                        }
                    }
                }
                else
                {
                    // NoDrop
                    hCursor = m_viewNotInControl;
                }

                SetCursor(hCursor);

                rc = TRUE;
            }
            else
            {
                // Let defwindowproc handle it
                goto DefWndProc;
            }
            break;
        }

        case WM_SIZE:
        {
            //
            // If we're in full screen mode, there are no scrollbars.
            //
            if (!pasPerson->m_pView->m_viewFullScreen)
            {
                int xNewPos;
                int yNewPos;

                xNewPos = pasPerson->m_pView->m_viewPos.x;
                yNewPos = pasPerson->m_pView->m_viewPos.y;

                GetClientRect(hwnd, &rcl);
                pasPerson->m_pView->m_viewPage.x = rcl.right - rcl.left;
                pasPerson->m_pView->m_viewPage.y = rcl.bottom - rcl.top;
                TRACE_OUT(("WM_SIZE: Set page size (%04d, %04d)",
                    pasPerson->m_pView->m_viewPage.x, pasPerson->m_pView->m_viewPage.y));

                //
                // Scroll window if necessary.
                //
                si.cbSize = sizeof(SCROLLINFO);
                si.fMask = SIF_PAGE|SIF_DISABLENOSCROLL;

                // Set new HORIZONTAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.x;
                SetScrollInfo(hwnd, SB_HORZ, &si, TRUE );

                // Set new VERTICAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.y;
                SetScrollInfo(hwnd, SB_VERT, &si, TRUE );

                //
                // This will make sure the scroll pos is pinned properly
                //
                VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
            }
            break;
        }

        case WM_HSCROLL:
        {
            int xNewPos;    // new position

            switch (GET_WM_HSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_PAGEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_LINEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_LINEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_TOP:
                    xNewPos = 0;
                    break;
                case SB_BOTTOM:
                    xNewPos = pasPerson->viewExtent.x;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    xNewPos = GET_WM_HSCROLL_POS(wParam, lParam);
                    break;

                default:
                    xNewPos = pasPerson->m_pView->m_viewPos.x;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, xNewPos, pasPerson->m_pView->m_viewPos.y);
            break;
        }

        case WM_VSCROLL:
        {
            int yNewPos;    // new position

            switch (GET_WM_VSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_PAGEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_LINEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_LINEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_TOP:
                    yNewPos = 0;
                    break;
                case SB_BOTTOM:
                    yNewPos = pasPerson->viewExtent.y;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    yNewPos = GET_WM_VSCROLL_POS(wParam, lParam);
                    break;

                default:
                    yNewPos = pasPerson->m_pView->m_viewPos.y;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, yNewPos);
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(ASShare::VIEW_ViewWindowProc, rc);
    return(rc);
}




//
// VIEWClientPaint()
//
// This paints the client area of the view frame.  We paint
//      (1) The obscured area, in the obscured pattern
//          * parts of shared regions that are covered up
//          * parts of shared regions that are offscreen/off the VD
//      (2) The shared area, from the bitmap
//      (3) The deadspace, in COLOR_APPWORKSPACE
//
void  ASShare::VIEWClientPaint(ASPerson * pasPerson)
{
    PAINTSTRUCT     ps;
    HDC             hdcView;
    HPALETTE        hOldPal;
    HPALETTE        hOldPal2;
    RECT            rcT;

    DebugEntry(ASShare::VIEWClientPaint);

    ValidateView(pasPerson);

    hdcView = BeginPaint(pasPerson->m_pView->m_viewClient, &ps);
    if (hdcView == NULL)
    {
        WARNING_OUT(( "Failed to get hdc for frame window %08X", pasPerson->m_pView->m_viewClient));
        DC_QUIT;
    }

    if (IsRectEmpty(&ps.rcPaint))
    {
        TRACE_OUT(("Nothing to paint but got WM_PAINT message"));
        DC_QUIT;
    }

    TRACE_OUT(("VIEWClientPaint: Painting total client area {%04d, %04d, %04d, %04d}",
        ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom));


    //
    // In desktop sharing, viewSharedRgn is NULL
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        POINT           ptOrigin;
        HBRUSH          hbrT;

        //
        // First, create paint area region
        //
        SetRectRgn(pasPerson->m_pView->m_viewPaintRgn, ps.rcPaint.left, ps.rcPaint.top,
            ps.rcPaint.right, ps.rcPaint.bottom);

        //
        // Second, compute the VD area not currently on screen.  Do this
        // in CLIENT coords.
        //
        SetRectRgn(pasPerson->m_pView->m_viewExtentRgn,
            -pasPerson->m_pView->m_viewPos.x,
            -pasPerson->m_pView->m_viewPos.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->viewExtent.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->viewExtent.y);

        SetRectRgn(pasPerson->m_pView->m_viewScreenRgn,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x + pasPerson->cpcCaps.screen.capsScreenWidth,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y + pasPerson->cpcCaps.screen.capsScreenHeight);

        SubtractRgn(pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewScreenRgn);

        //
        // pasPerson->m_pView->m_viewExtentRgn is now the offscreen parts of the VD, and therefore
        // any shared areas lying in them should be treated as obscured.
        //

        //
        // Now, compute the real obscured area.  It's the covered up bits
        // plus open parts of shared stuff not currently on screen.
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewSharedRgn);
        UnionRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewObscuredRgn);

        // Calc what part of the obscured region to actually paint
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);
        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting obscured client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));

            //
            // Remove this area so we have what's left to paint.
            //
            SubtractRgn(pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewScratchRgn);

            //
            // We do NOT want to use FillRgn; it ignores the brush origin.
            // So we select this in as the clip region and PatBlt instead.
            //
            SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);

#ifdef _DEBUG
            //
            // NOTE:  Do NOT move this--we're using ptOrigin for scratch.
            //
            GetDCOrgEx(hdcView, &ptOrigin);
            TRACE_OUT(("VIEWClientPaint:    Setting brush origin to {%04d, %04d}, screen {%04d, %04d}",
                -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y,
                ptOrigin.x - pasPerson->m_pView->m_viewPos.x,
                ptOrigin.y - pasPerson->m_pView->m_viewPos.y));
#endif

            //
            // Align the brush with where the view's real origin would be, in
            // client coords.  We do that by accounting for being scrolled over.
            //
            SetBrushOrgEx(hdcView, -pasPerson->m_pView->m_viewPos.x,
                -pasPerson->m_pView->m_viewPos.y, &ptOrigin);
            UnrealizeObject(m_viewObscuredBrush);
            hbrT = SelectBrush(hdcView, m_viewObscuredBrush);

            PatBlt(hdcView,
                rcT.left, rcT.top,
                rcT.right - rcT.left,
                rcT.bottom - rcT.top,
                PATCOPY);

            SelectBrush(hdcView, hbrT);
            SetBrushOrgEx(hdcView, ptOrigin.x, ptOrigin.y, NULL);

            SelectClipRgn(hdcView, NULL);
        }

        //
        // Paint the deadspace area, set up clipping for app sharing.
        // This also works for desktop sharing, where there are no obscured or
        // shared regions, the whole area paints.
        //

        //
        // The deadspace is whatever's left over in the paint region
        // (already subtracted the obscured region) after subtracting the
        // shared area
        //
        SubtractRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewSharedRgn);

        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting dead client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
            FillRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn, GetSysColorBrush(COLOR_APPWORKSPACE));
        }

        //
        // Compute what part of the shared area needs painting (the part
        // that lies on the remote screen actually).
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewSharedRgn, pasPerson->m_pView->m_viewScreenRgn);
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);

        // Now select in the piece of what we're painting as the clip region
        SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);
    }

    //
    // Blt the shared region
    //
    if (GetClipBox(hdcView, &rcT) > NULLREGION)
    {
        TRACE_OUT(("VIEWClientPaint:    Painting shared client area {%04x, %04x, %04x, %04x}",
            rcT.left, rcT.top, rcT.right, rcT.bottom));

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            //
            // Select and realize the current remote palette into the
            // screen and shadow bitmap DCs.
            //
            hOldPal = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_usrDC);

            hOldPal2 = SelectPalette( hdcView, pasPerson->pmPalette, FALSE);
            RealizePalette(hdcView);
        }

        //
        // The host bitmap is in screen coords, not VD coords, so
        // adjust for being scrolled over...
        //
        BitBlt(hdcView,
            rcT.left, rcT.top, rcT.right - rcT.left, rcT.bottom - rcT.top,
            pasPerson->m_pView->m_usrDC,
            rcT.left + pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_dsScreenOrigin.x,
            rcT.top + pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_dsScreenOrigin.y,
            SRCCOPY);

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            SelectPalette(pasPerson->m_pView->m_usrDC, hOldPal, FALSE);
            SelectPalette(hdcView, hOldPal2, FALSE);
        }
    }

    //
    // Deselect the clip region, or we won't be able to draw shadow cursors
    // that lie outside the shared area.
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        SelectClipRgn(hdcView, NULL);
    }

    //
    // Draw the shadow cursor.
    //
    CM_DrawShadowCursor(pasPerson, hdcView);

DC_EXIT_POINT:

    if (hdcView != NULL)
        EndPaint(pasPerson->m_pView->m_viewClient, &ps);

    DebugExitVOID(ASShare::VIEWClientPaint);
}



//
// VIEWClientScroll()
//
// This is the common place where the scroll position is altered.  If
// necessary the contents are scrolled over, the regions (always in client
// coords) are adjusted, and new info about our origin is sent to remotes.
//
// We first make sure the scroll position is pinned properly within the
// range.
//
// The return value is whether scrolling happened or not.
//
BOOL ASShare::VIEWClientScroll
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         dx;
    int         dy;

    DebugEntry(ASShare::VIEWClientScroll);

    //
    // First, pin the requested new position within the range
    //
    //
    // Pin x pos
    //
    if (xNew < 0)
        xNew = 0;

    if (xNew + pasPerson->m_pView->m_viewPage.x > pasPerson->viewExtent.x)
        xNew = pasPerson->viewExtent.x - pasPerson->m_pView->m_viewPage.x;

    //
    // Pin y pos
    //
    if (yNew < 0)
        yNew = 0;

    if (yNew + pasPerson->m_pView->m_viewPage.y > pasPerson->viewExtent.y)
        yNew = pasPerson->viewExtent.y - pasPerson->m_pView->m_viewPage.y;

    //
    // How much are we going to scroll by?
    //
    dx = pasPerson->m_pView->m_viewPos.x - xNew;
    dy = pasPerson->m_pView->m_viewPos.y - yNew;

    // Updates
    if (dx || dy)
    {
        //
        // Adjust regions
        //
        if (pasPerson->m_pView->m_viewObscuredRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewObscuredRgn, dx, dy);

        if (pasPerson->m_pView->m_viewSharedRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewSharedRgn, dx, dy);

        pasPerson->m_pView->m_viewPos.x = xNew;
        pasPerson->m_pView->m_viewPos.y = yNew;

        ScrollWindowEx(pasPerson->m_pView->m_viewClient,
                    dx,
                    dy,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    SW_SCROLLCHILDREN | SW_INVALIDATE);

        if (dx)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_HORZ, xNew, TRUE);
        }

        if (dy)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_VERT, yNew, TRUE);
        }
    }

    DebugExitBOOL(ASShare::VIEWClientScroll, (dx || dy));
    return(dx || dy);
}


//
// VIEWClientMouseDown()
//
void ASShare::VIEWClientMouseDown
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    DebugEntry(ASShare::VIEWClientMouseDown);

    ValidateView(pasPerson);

    //
    // On the first button down, set capture so all mouse messages come
    // to us until capture is released or stolen.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        //
        // If this is RBUTTONDOWN, track the Collaborate pop up...
        //
        ASSERT(!pasPerson->m_pView->m_viewMouseOutside);
        SetCapture(pasPerson->m_pView->m_viewClient);
    }

    //
    // Remember what button is down.
    //
    switch (message)
    {
        case WM_LBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_LBUTTON;
            break;

        case WM_RBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_RBUTTON;
            break;

        case WM_MBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_MBUTTON;
            break;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseDown);
}


//
// VIEWClientMouseUp()
//
void ASShare::VIEWClientMouseUp
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL            fReleaseCapture
)
{
    DebugEntry(ASShare::VIEWClientMouseUp);

    switch (message)
    {
        case WM_LBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_LBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_RBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_RBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_MBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_MBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;
    }

    //
    // Should we release capture?
    // We don't just want to release capture on a button up.  The user may
    // press one button down then another; we don't want to release capture
    // until all buttons are up.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        if (pasPerson->m_pView->m_viewMouseOutside)
        {
            pasPerson->m_pView->m_viewMouseOutside = FALSE;
            KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
        }

        if (fReleaseCapture)
            ReleaseCapture();
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseUp);
}



//
// VIEWClientCaptureStolen()
// Called when capture gets stolen away from us, like by Alt-Tab.
//
void ASShare::VIEWClientCaptureStolen(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEWClientCaptureStolen);

    //
    // We need to fake a button up for each button we think is down.
    // Use the current cursor pos.
    //
    if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_MBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_RBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_LBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    DebugExitVOID(ASShare::VIEWClientCaptureStolen);
}


//
// VIEWClientMouseMove()
//
void ASShare::VIEWClientMouseMove
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    RECT            rcClient;

    DebugEntry(ASShare::VIEWClientMouseMove);

    if (!pasPerson->m_pView->m_viewFocus)
    {
        // Ignore mouse moves over windows that don't have the focus
        DC_QUIT;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    //
    // If any button is down, check whether we should kick in
    // autoscroll detection.
    //
    if (pasPerson->m_pView->m_viewMouseFlags)
    {
        // Is the mouse inside or outside the client for the first time?
        if (PtInRect(&rcClient, pasPerson->m_pView->m_viewMouse))
        {
            //
            // Was the mouse outside the client before?  If so, kill our
            // autoscroll timer, we're not dragging outside.
            //
            if (pasPerson->m_pView->m_viewMouseOutside)
            {
                pasPerson->m_pView->m_viewMouseOutside = FALSE;
                KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
            }
        }
        else
        {
            //
            // Is the first time the mouse is outside the client?  If so,
            // set our autoscroll timer to the default value.  When it goes
            // off, the autoscroll code will scroll by some multiple of
            // how far away the mouse is from the client.
            //
            if (!pasPerson->m_pView->m_viewMouseOutside)
            {
                //
                // The Windows scrollbar code uses 1/8 of the double-click
                // time, so we do also.
                //
                pasPerson->m_pView->m_viewMouseOutside = TRUE;
                SetTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL,
                    GetDoubleClickTime() / 8, NULL);
            }

            //
            // LAURABU BOGUS!
            // When IM_Periodic goop is gone for controlling, do NOT
            // pass along mouse outside messages.  Only the autoscroll
            // timer will fake a mouse move in this case.  Either that,
            // or clip the position to the nearest client area equivalent.
            //
        }
    }

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseMove);
}



//
// VIEWClientMouseMsg()
//
void ASShare::VIEWClientMouseMsg
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    POINT           mousePos;

    DebugEntry(ASShare::VIEWClientMouseMsg);

    //
    // Extract the mouse position from <lParam> and package it
    // in a POINT structure.  These coordinates are relative to our
    // client area.  So convert to remote's desktop by adjusting for
    // scroll position.
    //
    // Be careful when converting the LOWORD and HIWORD values
    // because the positions are signed values.
    //
    mousePos.x = GET_X_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.x;
    mousePos.y = GET_Y_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.y;

    //
    // These coords represent the SCREEN coords on the host.
    //
    if (pasPerson->m_caControlledBy == m_pasLocal)
    {
        IM_OutgoingMouseInput(pasPerson, &mousePos, message, (UINT)wParam);
    }
    else if (pasPerson->m_caAllowControl && !pasPerson->m_caControlledBy &&
        (message == WM_LBUTTONDBLCLK))
    {
        //
        // If we're already waiting for control of this person, don't bother
        // trying to take control again.
        //
        if ((m_caWaitingForReplyFrom != pasPerson) &&
            (m_caWaitingForReplyMsg  != CA_REPLY_REQUEST_TAKECONTROL))
        {
            CA_TakeControl(pasPerson);
        }
    }

    DebugExitVOID(ASShare::VIEWClientMouse);
}


//
// VIEWClientMouseWheel()
//
// Unbelievably complicated, messy, nonsensical Intellimouse wheel handling
// to scroll the client.  Since the Intellimouse makes no distinction for
// which direction to scroll in, we basically have to guess.  We don't want
// to be unpredictable and decide which direction to scroll based on how
// much is visible in each dimenion.
//
// So instead, we assume horizontal.  If the horizontal scrollbar is disabled,
// then we try vertical.  If that's disabled, we do nothing.
//
// We do NOT handle zoom and datazoom flavors.
//
// Note that this code comes from the listbox/sample source.
//
void ASShare::VIEWClientMouseWheel
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    int             cDetants;

    DebugEntry(ASShare::VIEWClientMouseWheel);

    //
    // The LOWORD of wParam has key state information.
    // The HIWORD of wParam is the number of mouse wheel clicks.
    //

    //
    // We don't do zoom/datazoom
    //
    if (wParam & (MK_SHIFT | MK_CONTROL))
    {
        DC_QUIT;
    }

    pasHost->m_pView->m_viewMouseWheelDelta -= (int)(short)HIWORD(wParam);
    cDetants = pasHost->m_pView->m_viewMouseWheelDelta / WHEEL_DELTA;

    if (cDetants && (m_viewMouseWheelScrollLines > 0))
    {
        POINT           ptPos;

        pasHost->m_pView->m_viewMouseWheelDelta %= WHEEL_DELTA;

        //
        // The basic idea is that we scroll some number of lines, the
        // number being cDetants.
        //
        ptPos = pasHost->m_pView->m_viewPos;

        //
        // To be consistent with other apps, and with our keyboard
        // accelerators, try the vertical direction first.
        //
        if (pasHost->m_pView->m_viewPage.y < pasHost->viewExtent.y)
        {
            ptPos.y += cDetants * pasHost->m_pView->m_viewLnSize.y;
        }
        else if (pasHost->m_pView->m_viewPage.x < pasHost->viewExtent.x)
        {
            ptPos.x += cDetants * pasHost->m_pView->m_viewLnSize.x;
        }
        else
        {
            // Nothing to scroll, the whole view fits in the client area.
        }

        VIEWClientScroll(pasHost, ptPos.x, ptPos.y);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseWheel);
}


//
// VIEWClientAutoScroll()
//
void ASShare::VIEWClientAutoScroll(ASPerson * pasPerson)
{
    int     dx;
    int     dy;
    RECT    rcClient;

    DebugEntry(ASShare::VIEWClientAutoScroll);

    ValidateView(pasPerson);
    ASSERT(pasPerson->m_pView->m_viewMouseOutside);

    //
    // Do scrolling.  The amount is dependent on how far outside the
    // client area we are.
    //
    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    // Horizontal scrolling?
    if (pasPerson->m_pView->m_viewMouse.x < rcClient.left)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.left;
    }
    else if (pasPerson->m_pView->m_viewMouse.x >= rcClient.right)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.right + 1;
    }
    else
    {
        dx = 0;
    }


    // Vertical scrolling?
    if (pasPerson->m_pView->m_viewMouse.y < rcClient.top)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.top;
    }
    else if (pasPerson->m_pView->m_viewMouse.y >= rcClient.bottom)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.bottom + 1;
    }
    else
    {
        dy = 0;
    }

    // For every 32 pixel blocks outside the client, scroll one line amount
    if (dx)
        dx = MulDiv(pasPerson->m_pView->m_viewLnSize.x, dx, 32);
    if (dy)
        dy = MulDiv(pasPerson->m_pView->m_viewLnSize.y, dy, 32);

    // Do scrolling.
    if (VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x + dx,
            pasPerson->m_pView->m_viewPos.y + dy))
    {
        //
        // The scroll position actually changed.  So fake a mouse move
        // to the current location so that the remote's
        // cursor will be in the same spot as ours.  If our scroll pos has
        // changed, we're mapping to a different place on the remote.
        //
        VIEWClientMouseMsg(pasPerson, WM_MOUSEMOVE, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y));
    }

    DebugExitVOID(ASShare::VIEWClientAutoScroll);
}



//
// VIEW_SyncCursorPos()
//
// This is called when we see a CM_SYNC pos packet broadcasted from a
// host.  It means that we should sync our cursor to the corresponding
// position in our view.  This happens when the cursor is moved by
// an app, constrained by clipping, or we're too out of whack because it's
// taking too long.
//
// This will only do something if the frame is active and our cursor is
// currently over the client area.  If we need to, we will scroll the
// client over to make the corresponding point visible.
//
void ASShare::VIEW_SyncCursorPos
(
    ASPerson *      pasHost,
    int             xRemote,
    int             yRemote
)
{
    POINT           ptCursor;
    RECT            rcClient;
    int             xNewPos;
    int             yNewPos;
    int             xMargin;
    int             yMargin;

    DebugEntry(ASShare::VIEW_SyncCursorPos);

    ValidateView(pasHost);
    if (!pasHost->m_pView->m_viewFocus)
    {
        // The frame isn't active, do nothing
        DC_QUIT;
    }

    //
    // Is our mouse currently over the client area?
    //
    GetCursorPos(&ptCursor);
    ScreenToClient(pasHost->m_pView->m_viewClient, &ptCursor);
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);

    if (!PtInRect(&rcClient, ptCursor))
    {
        // No sense in snapping cursor
        DC_QUIT;
    }

    //
    // Is the remote point in range of our view?  If not, we must scroll it.
    //

    // The margin is the page size if there's room, nothing if not
    xMargin = pasHost->m_pView->m_viewPgSize.x;
    if (xMargin >= rcClient.right - rcClient.left)
        xMargin = 0;

    xNewPos = pasHost->m_pView->m_viewPos.x;
    if ((xRemote < pasHost->m_pView->m_viewPos.x) ||
        (xRemote >= pasHost->m_pView->m_viewPos.x + (rcClient.right - rcClient.left)))
    {
        //
        // Scroll over more than just enough to pin the point on the left
        // side.
        //
        xNewPos = xRemote - xMargin;
    }

    yMargin = pasHost->m_pView->m_viewPgSize.y;
    if (yMargin >= rcClient.bottom - rcClient.top)
        yMargin = 0;

    yNewPos = pasHost->m_pView->m_viewPos.y;
    if ((yRemote < pasHost->m_pView->m_viewPos.y) ||
        (yRemote >= yNewPos + (rcClient.bottom - rcClient.top)))
    {
        //
        // Scroll over more than just enough to pin the point on the top
        // side.
        //
        yNewPos = yRemote - yMargin;
    }

    VIEWClientScroll(pasHost, xNewPos, yNewPos);

    ptCursor.x = xRemote - pasHost->m_pView->m_viewPos.x;
    ptCursor.y = yRemote - pasHost->m_pView->m_viewPos.y;
    ClientToScreen(pasHost->m_pView->m_viewClient, &ptCursor);

    SetCursorPos(ptCursor.x, ptCursor.y);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_SyncCursorPos);
}





//
// VIEWFullScreenExitProc()
//
// Window handler for full screen exit button.
//
LRESULT CALLBACK VIEWFullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FullScreenExitProc(hwnd, message, wParam, lParam));
}



//
// VIEW_FullScreenExitProc()
//
LRESULT ASShare::VIEW_FullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FullScreenExitProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            //
            // Make sure tracking is stopped.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            break;
        }

        case WM_ERASEBKGND:
        {
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWFullScreenExitPaint(pasHost, hwnd);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            //
            // Start tracking to move or click button.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = TRUE;
            pasHost->m_pView->m_viewFullScreenExitMove = FALSE;

            // Original click, relative to our client
            pasHost->m_pView->m_viewFullScreenExitStart.x =
                GET_X_LPARAM(lParam);
            pasHost->m_pView->m_viewFullScreenExitStart.y =
                GET_Y_LPARAM(lParam);

            // Set capture, and wait for moves/button up
            SetCapture(hwnd);
            break;
        }

        case WM_MOUSEMOVE:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                POINT   ptMove;

                ptMove.x = GET_X_LPARAM(lParam);
                ptMove.y = GET_Y_LPARAM(lParam);

                //
                // If we're not in move mode, see if this has pushed us over
                // the tolerance.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    if ((abs(ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x) >
                            GetSystemMetrics(SM_CXDRAG))    ||
                        (abs(ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y) >
                            GetSystemMetrics(SM_CYDRAG)))
                    {
                        //
                        // User has moved out of tolerance zone, must be
                        // dragging to move the button out of the way.
                        //
                        pasHost->m_pView->m_viewFullScreenExitMove = TRUE;
                    }
                }

                if (pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    RECT    rcWindow;

                    //
                    // Move the button so that the cursor is over the
                    // same point as originally clicked on.
                    //

                    // Get our current position, in parent coordsinates.
                    GetWindowRect(hwnd, &rcWindow);
                    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rcWindow, 2);

                    // Offset it by the amount of the move.
                    OffsetRect(&rcWindow,
                        ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x,
                        ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y);
                    SetWindowPos(hwnd, NULL, rcWindow.left, rcWindow.top, 0, 0,
                        SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
                }
            }
            break;
        }

        case WM_LBUTTONUP:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                //
                // This will send us CAPTURECHANGED, causing us to clear
                // the ExitTrack flag.
                //
                ReleaseCapture();

                //
                // If we never transitioned into move mode, then this was
                // a click on the button.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    //
                    // This was a click, send a command.
                    //
                    PostMessage(pasHost->m_pView->m_viewFrame, WM_COMMAND, CMD_VIEWFULLSCREEN, 0);
                }
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // If we're tracking, something happened, so cancel out.
            //
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(VIEW_FullScreenExitProc, rc);
    return(rc);

}



//
// VIEWFullScreenExitPaint()
//
// Paints the full screen button.
//
void ASShare::VIEWFullScreenExitPaint
(
    ASPerson *  pasHost,
    HWND        hwnd
)
{
    RECT        rc;
    PAINTSTRUCT ps;
    char        szRestore[256];
    HFONT       hfnOld;
    COLORREF    txtColor;
    COLORREF    bkColor;

    DebugEntry(ASShare::VIEWFullScreenExitPaint);

    BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rc);
    DrawFrameControl(ps.hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH |
        DFCS_ADJUSTRECT);

    // Margin adjustments...
    InflateRect(&rc, -m_viewEdgeCX, -m_viewEdgeCY);

    DrawIconEx(ps.hdc, rc.left,
        (rc.top + rc.bottom - GetSystemMetrics(SM_CYSMICON)) / 2,
        m_viewFullScreenExitIcon,
        GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),
        0, NULL, DI_NORMAL);
    rc.left += GetSystemMetrics(SM_CXSMICON) + m_viewEdgeCX;

    hfnOld = SelectFont(ps.hdc, GetStockObject(DEFAULT_GUI_FONT));
    txtColor = SetTextColor(ps.hdc, GetSysColor(COLOR_BTNTEXT));
    bkColor = SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE));

    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));
    DrawText(ps.hdc, szRestore, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
        DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE);

    SetBkColor(ps.hdc, bkColor);
    SetTextColor(ps.hdc, txtColor);
    SelectFont(ps.hdc, hfnOld);
    EndPaint(hwnd, &ps);

    DebugExitVOID(ASShare::VIEWFullScreenExitPaint);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\makefile.inc ===
!include $(ROOT)\as\common.inc

$(O)\asthkls.asm: ..\thk\asthkls.thk
     $(DEVROOT)\bin16\thunk -t thk -o $@ ..\thk\asthkls.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\im.cpp ===
#include "precomp.h"


//
// IM.C
// Backport Input Manager
//
// Copyright(c) Microsoft 1997-
//

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_INPUT


//
// OSI_InstallControlledHooks()
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable)
{
    ASSERT(g_hInstAs16);
    return(OSIInstallControlledHooks16(fEnable));
}


//
// OSI_InjectMouseEvent()
//
void WINAPI OSI_InjectMouseEvent
(   
    DWORD       flags,
    LONG        x,
    LONG        y,
    DWORD       mouseData,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    OSIInjectMouseEvent16(flags, x, y, mouseData, dwExtraInfo);

    TRACE_OUT(("After MOUSE inject"));
}



//
// OSI_InjectKeyboardEvent()
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD       flags,
    WORD        vkCode,
    WORD        scanCode,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    OSIInjectKeyboardEvent16(flags, vkCode, scanCode, dwExtraInfo);

    TRACE_OUT(("After KEY inject"));
}

//
// OSI_InjectCtrlAltDel()
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
	// BUGBUG do we want to support ctl-alt-del injection on Win9x?
	ERROR_OUT(("Attempt to inject Ctrl+Alt+Del"));
}


//
// OSI_DesktopSwitch()
//
void WINAPI OSI_DesktopSwitch(UINT from, UINT to)
{
    // Nothing to do, should never happen.
    ERROR_OUT(("Can't desktop switch on Win95"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\globalnt.cpp ===
#include "precomp.h"


//
// This file generates the storage for our NT specific global variables
//

#include <datainit.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\osi.cpp ===
#include "precomp.h"


//
// OSI.C
// OS Isolation Layer, Win95 version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>

#include <osi.h>

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_CORE


//
// OSI_Load()
// This handles our process attach code.  It establishes thunks to the
// 16-bit Win95 library.  WE CAN ONLY DO THIS ONCE.  It is imperative
// that a flat-thunk pair come/go together, since the 32-bit piece hangs
// on to a shared memory section that is the thunk table in the 16-bit piece.
//
void OSI_Load(void)
{
    DebugEntry(OSI_Load);

    ASSERT(!g_hInstAs16);

    g_asWin95 = TRUE;

    //
    // Establish the thunks with AS16
    //
    if (FT_thkConnectToFlatThkPeer(TEXT("rdas16.dll"), TEXT("rdas32.dll")))
    {
        OSILoad16(&g_hInstAs16);
        ASSERT(g_hInstAs16);
    }
    else
    {
        ERROR_OUT(("Couldn't load nmaswin.dll"));

        //
        // Note, even on load failure, we will continue.  We just don't let
        // you do app sharing stuff.
        //
    }

    DebugExitVOID(OSI_Load);
}


//
// OSI_Unload()
// This handles our process detach code.  It frees the 16-bit library that
// we are pared with.
//
void OSI_Unload(void)
{

    DebugEntry(OSI_Unload);

    if (g_hInstAs16)
    {
        //
        // See comment for OSI_Term().  On catastropic failure, we may
        // call this BEFORE OSI_Term.  So null out variables it uses.
        //
        g_osiInitialized = FALSE;

        //
        // Free 16-bit library so loads + frees are paired.  Note that 16-bit
        // cleanup occurs when the library is freed.
        //
        FreeLibrary16(g_hInstAs16);
        g_hInstAs16 = 0;


    }

    DebugExitVOID(OSI_Unload);
}



//
// OSI_Init
// This initializes our display driver/hook dll communication code.
//
// We load our 16-bit library and establish thunks to it.
//
void OSI_Init(void)
{
    DebugEntry(OSI_Init);

    if (!g_hInstAs16)
    {
        WARNING_OUT(("No app sharing at all since library not present"));
        DC_QUIT;
    }

    //
    // We are quasi initialized.
    //
    g_osiInitialized = TRUE;

    ASSERT(g_asMainWindow);

    //
    // Call into 16-bit code to do any initialization necessary
    //

    g_asCanHost = OSIInit16(DCS_MAKE_VERSION(), g_asMainWindow, 
        (LPDWORD)&g_asSharedMemory, (LPDWORD)g_poaData,
        (LPDWORD)&g_lpimSharedData, (LPDWORD)&g_sbcEnabled, (LPDWORD)g_asbcShuntBuffers,
        g_asbcBitMasks);

    if (g_asCanHost)
    {
        ASSERT(g_asSharedMemory);
        ASSERT(g_poaData[0]);
        ASSERT(g_poaData[1]);
        ASSERT(g_lpimSharedData);

        if (g_sbcEnabled)
        {
            ASSERT(g_asbcShuntBuffers[0]);
        }
    }
    else
    {
        ASSERT(!g_asSharedMemory);
        ASSERT(!g_poaData[0]);
        ASSERT(!g_poaData[1]);
        ASSERT(!g_sbcEnabled);
        ASSERT(!g_asbcShuntBuffers[0]);
    }

DC_EXIT_POINT:
    DebugExitVOID(OSI_Init);
}



//
// OSI_Term()
// This cleans up our resources, closes the driver, etc.
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    if (g_osiInitialized)
    {
        g_osiInitialized = FALSE;

        //
        // In Ctl+Alt+Del, the process detach of mnmcpi32.dll may happen
        // first, followed by the process detach of mnmcrsp_.dll.  The latter
        // will call DCS_Term, which will call OSI_Term().  We don't want to
        // blow up.  So OSI_Unload nulls out these variables also.
        //
        ASSERT(g_hInstAs16);

        OSITerm16(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;
    g_asCanHost = FALSE;
    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}



//
// OSI_FunctionRequest()
//
// This is a generic way of communicating with the graphics part of
// hosting.  On NT, it's a real display driver, and this uses ExtEscape.
// On Win95, it's a 16-bit dll, and this uses a thunk.
//
BOOL  OSI_FunctionRequest
(
    DWORD   escapeFn,
    LPOSI_ESCAPE_HEADER  pRequest,
    DWORD   requestLen
)
{
    BOOL    rc;

    DebugEntry(OSI_FunctionRequest);

    ASSERT(g_osiInitialized);
    ASSERT(g_hInstAs16);

    //
    // NOTE:  In Win95, since we use a direct thunk to communicate
    // with our driver, we don't really need to
    //      (1) Fill in an identifier (AS16 knows it's us)
    //      (2) Fill in the escape fn field
    //      (3) Fill in the version stamp (the thunk fixups will fail
    //          if pieces are mismatched)
    //
    // However, we keep the identifer field around.  If/when we support
    // multiple AS clients at the same time, we will want to know
    // who the caller was.
    //

    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    rc = OSIFunctionRequest16(escapeFn, pRequest, requestLen);

    DebugExitBOOL(OSI_FunctionRequest, rc);
    return(rc);
}



void OSI_RepaintDesktop(void)
{
}

void OSI_SetGUIEffects(BOOL fOn)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\makefile.inc ===
!include $(ROOT)\as\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\globalnt.h ===
//
// GLOBALNT.H
// Global variables specific to NT
//

DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_NT_DATA,       g_imNTData );

DC_DATA_VAL(char,           g_osiDriverName[CCHDEVICENAME], "");
DC_DATA_VAL(char,           s_osiDisplayName[8], "DISPLAY");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <globalnt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\im.cpp ===
#include "precomp.h"

//
// IM.CPP
// Input Manager, NT specific code
//

#define MLZ_FILE_ZONE  ZONE_INPUT



//
// OSI_InstallControlledHooks()
//
// Installs/removes input hooks for control
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable)
{
    BOOL    rc = FALSE;

    DebugEntry(OSI_InstallControlledHooks);

    if (fEnable)
    {
        //
        // Create the service thread, it will install the hooks.
        //
        ASSERT(!g_imNTData.imLowLevelInputThread);

        if (!DCS_StartThread(IMLowLevelInputProcessor))
        {
            ERROR_OUT(( "Failed to create LL IM thread"));
            DC_QUIT;
        }
    }
    else
    {
        if (g_imNTData.imLowLevelInputThread != 0)
        {
            PostThreadMessage( g_imNTData.imLowLevelInputThread, WM_QUIT, 0, 0);
            g_imNTData.imLowLevelInputThread = 0;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_InstallControlledHooks, rc);
    return(rc);
}



// Name:      IMLowLevelInputProcessor
//
// Purpose:   Main function for the low-level input handler thread.
//
// Returns:   wParam of the WM_QUIT message.
//
// Params:    syncObject - sync object that allows this thread to signal
//            the creating thread via COM_SignalThreadStarted.
//
// Operation: This function is the start point for the low-level input
//            handler thread.
//
//            We raise the priority of this thread to:
//            (a) ensure that we avoid hitting the low-level callback
//            timeout - which would cause us to miss events.
//            (b) minimize visible mouse movement lag on the screen.
//
//            The thread installs the low-level hooks and enters a
//            GetMessage/DispatchMessage loop which handles the low-level
//            callbacks.
//
//            The Share Core sends the thread a WM_QUIT message to
//            terminate it, which causes it to exit the message loop and
//            removes the low-level hooks before it terminates.
//
DWORD WINAPI IMLowLevelInputProcessor(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;

    DebugEntry(IMLowLevelInputProcessor);

    TRACE_OUT(( "Thread started..."));

    //
    // Give ourseleves the highest possible priority (within our process
    // priority class) to ensure that the low-level events are serviced as
    // soon as possible.
    //
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    g_imNTData.imLowLevelInputThread = GetCurrentThreadId();

    //
    // Install low-level input hooks.
    //
    g_imNTData.imhLowLevelMouseHook = SetWindowsHookEx(
                                     WH_MOUSE_LL,
                                     IMLowLevelMouseProc,
                                     g_asInstance,
                                     0 );

    g_imNTData.imhLowLevelKeyboardHook = SetWindowsHookEx(
                                     WH_KEYBOARD_LL,
                                     IMLowLevelKeyboardProc,
                                     g_asInstance,
                                     0 );

    //
    // We're done with our init code, for better or for worse.  Let the
    // calling thread continue.
    //
    SetEvent((HANDLE)hEventWait);

    if ( (g_imNTData.imhLowLevelMouseHook == NULL) ||
         (g_imNTData.imhLowLevelKeyboardHook == NULL) )
    {
        ERROR_OUT(( "SetWindowsHookEx failed: hMouse(%u) hKeyboard(%u)",
            g_imNTData.imhLowLevelMouseHook, g_imNTData.imhLowLevelKeyboardHook ));
        DC_QUIT;
    }

    //
    // Do our message loop to get events
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    //
    // Remove hooks
    //

    if (g_imNTData.imhLowLevelMouseHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelMouseHook);
        g_imNTData.imhLowLevelMouseHook = NULL;
    }

    if (g_imNTData.imhLowLevelKeyboardHook != NULL)
    {
        UnhookWindowsHookEx(g_imNTData.imhLowLevelKeyboardHook);
        g_imNTData.imhLowLevelKeyboardHook = NULL;
    }

DC_EXIT_POINT:
    DebugExitDWORD(IMLowLevelInputProcessor, rc);
    return(rc);
}



//
// Name:      IMOtherDesktopProc()
//
// This allows us to inject (but not block) input into other desktops
// besides default, where the user's desktop resides.  Specifically, the
// winlogon desktop and/or the screensaver desktop.
//
// This is trickier than it might seem, because the winlogon desktop is
// always around, but the screen saver one is transitory.
//
// The periodic SWL_ code, called when hosting, checks for the current
// desktop and if it's switched posts us a message so we can change our
// desktop and our hooks.
//
DWORD WINAPI IMOtherDesktopProc(LPVOID hEventWait)
{
    MSG             msg;
    UINT            rc = 0;
    HDESK           hDesktop;
    GUIEFFECTS      effects;

    DebugEntry(IMOtherDesktopProc);

    TRACE_OUT(("Other desktop thread started..."));

    g_imNTData.imOtherDesktopThread = GetCurrentThreadId();

    //
    // Start out attached to the WinLogon desktop because it's always
    // around.
    //

    // Set our desktop to the winlogon desktop
    hDesktop = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0,
                        FALSE,
                        DESKTOP_JOURNALPLAYBACK);

    if ( !hDesktop )
    {
        WARNING_OUT(("OpenDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }
    else if (!SetThreadDesktop (hDesktop))
    {
        WARNING_OUT(("SetThreadDesktop failed: %ld", GetLastError()));
        DC_QUIT;
    }

    //
    // Attempt to load the driver dynamically on this thread also.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

    // Let the calling thread continue.
    SetEvent((HANDLE)hEventWait);

    ZeroMemory(&effects, sizeof(effects));

    while (GetMessage(&msg, NULL, 0, 0))
    {
        switch(msg.message)
        {
            case OSI_WM_MOUSEINJECT:
                mouse_event(
                                LOWORD(msg.wParam), // flags
                                HIWORD(msg.lParam), // x
                                LOWORD(msg.lParam), // y
                                HIWORD(msg.wParam), // mouseData
                                0);                 // dwExtraInfo
                break;

            case OSI_WM_KEYBDINJECT:
                keybd_event(
                                (BYTE)(LOWORD(msg.lParam)), // vkCode
                                (BYTE)(HIWORD(msg.lParam)), // scanCode
                                (DWORD)msg.wParam,          // flags
                                0);                         // dwExtraInfo
                break;

            case OSI_WM_DESKTOPREPAINT:
                USR_RepaintWindow(NULL);
                break;

            case OSI_WM_INJECTSAS:
            {
                HWND hwndSAS;

                if ( hwndSAS = FindWindow("SAS window class",NULL))
                {
                    PostMessage(hwndSAS,WM_HOTKEY,0,
                        MAKELONG(0x8000|MOD_ALT|MOD_CONTROL,VK_DELETE));
                }
                else
                {
                    WARNING_OUT(("SAS window not found, on screensaver desktop"));
                }
                break;
            }

            case OSI_WM_DESKTOPSWITCH:
            {
                HDESK   hDesktopNew;

                TRACE_OUT(("OSI_WM_DESKTOPSWITCH:  switching desktop from %d to %d",
                    msg.wParam, msg.lParam));

                if (msg.lParam == DESKTOP_SCREENSAVER)
                {
                    // We're switching TO the screensaver, attach to it.
                    TRACE_OUT(("Switching TO screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_SCREENSAVER,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else if (msg.wParam == DESKTOP_SCREENSAVER)
                {
                    //
                    // We're switching FROM the screensaver, reattach to
                    // winlogon
                    //
                    TRACE_OUT(("Switching FROM screensaver"));
                    hDesktopNew = OpenDesktop(NAME_DESKTOP_WINLOGON,
                        0, FALSE, DESKTOP_JOURNALPLAYBACK);
                }
                else
                {
                    hDesktopNew = NULL;
                }

                if (hDesktopNew != NULL)
                {
                    if (!SetThreadDesktop(hDesktopNew))
                    {
                        WARNING_OUT(("SetThreadDesktop to 0x%08x, type %d failed",
                            hDesktopNew, msg.lParam));
                    }
                    else
                    {
                        CloseHandle(hDesktop);
                        hDesktop = hDesktopNew;
                    }
                }
                break;
            }

            case OSI_WM_SETGUIEFFECTS:
            {
                HET_SetGUIEffects((msg.wParam != 0), &effects);
                break;
            }
        }
    }

DC_EXIT_POINT:

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    if (hDesktop)
    {
        CloseHandle(hDesktop);
    }

    g_imNTData.imOtherDesktopThread = 0;

    DebugExitDWORD(IMOtherDesktopProc, rc);
    return(rc);
}


//
// IMLowLevelMouseProc()
// NT callback for low-level mouse events.  
//
// It is installed and called on a secondary thread with high priority to
// service the APC call outs.  It follows the windows hook conventions for
// parameters and return values--zero to accept the event, non-zero to 
// discard.
//
// 
LRESULT CALLBACK IMLowLevelMouseProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PMSLLHOOKSTRUCT     pMouseEvent;

    DebugEntry(IMLowLevelMouseProc);

    pMouseEvent = (PMSLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an event that is happening or it's one we 
    // injected ourself, pass it through and no need for processing.
    //
    if ((nCode != HC_ACTION) || (pMouseEvent->flags & LLMHF_INJECTED))
    {
        DC_QUIT;
    }

    //
    // This is a local user event.  If controlled, throw it away.  Unless
    // it's a click, in that case post a REVOKECONTROL message.
    //
    if (g_imSharedData.imControlled)
    {
        //
        // If this is a button click, take control back
        //
        if ((wParam == WM_LBUTTONDOWN) ||
            (wParam == WM_RBUTTONDOWN) ||
            (wParam == WM_MBUTTONDOWN))
        {
            //
            // Don't take control back if this is unattended.
            //
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        // Swallow event.
        rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook (if there is one) if we are 
    // discarding the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelMouseHook, nCode,
            wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelMouseProc, rc);
    return(rc);
}


// Name:      IMLowLevelKeyboardProc
//
// Purpose:   Windows callback function for low-level keyboard events.
//
// Returns:   0 if event is to be passed on to USER.
//            1 if event is to be discarded.
//
// Params:    Low-level callback params (see Windows documentation).
//
// Operation: Determines whether to allow the given event into USER.
//
//            We always pass on injected events.
//            The Control Arbitrator determines whether local events are
//            passed on.
//
LRESULT CALLBACK IMLowLevelKeyboardProc
(
    int       nCode,
    WPARAM    wParam,
    LPARAM    lParam
)
{
    LRESULT             rc = 0;
    PKBDLLHOOKSTRUCT    pKbdEvent;

    DebugEntry(IMLowLevelKeyboardProc);

    pKbdEvent = (PKBDLLHOOKSTRUCT)lParam;

    //
    // If this isn't for an action or it's an event we ourself originated,
    // let it through, and do no processing.
    //
    if ((nCode != HC_ACTION) || (pKbdEvent->flags & LLKHF_INJECTED))
    {
        DC_QUIT;
    }

    if (g_imSharedData.imControlled)
    {
        if (!(pKbdEvent->flags & LLKHF_UP))
        {
            //
            // This is a key down.  Take control back, and kill control
            // allowability if it's the ESC key.
            //
            if ((pKbdEvent->vkCode & 0x00FF) == VK_ESCAPE)
            {
                // ESC key always disallows control, even in unattended mode
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        // LAURABU:  How do we fix this in new model?  Post a toggle-key
        // message and undo it (fake press)?
        //
        if (!IM_KEY_IS_TOGGLE(pKbdEvent->vkCode & 0x00FF))
            rc = 1;
    }

DC_EXIT_POINT:
    //
    // Don't pass on to the next hook if we are swallowing the event.
    //
    if (!rc)
    {
        rc = CallNextHookEx(g_imNTData.imhLowLevelKeyboardHook,
            nCode, wParam, lParam);
    }

    DebugExitDWORD(IMLowLevelKeyboardProc, rc);
    return(rc);
}



//
// IMInjectMouseEvent()
// NT-specific version to inject mouse events into the local system
//
void WINAPI OSI_InjectMouseEvent
(
    DWORD   flags,
    LONG    x,
    LONG    y,
    DWORD   mouseData,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    mouse_event(flags, (DWORD)x, (DWORD)y, mouseData, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        // Stuff these dword parameters through WORDS
        // need to make sure we don't clip anything
        ASSERT(!(flags & 0xffff0000));
        //ASSERT(!(mouseData & 0xffff0000)); BUGBUG possible loss
        ASSERT(!(x & 0xffff0000));
        ASSERT(!(y & 0xffff0000));

        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_MOUSEINJECT,
            MAKEWPARAM((WORD)flags,(WORD)mouseData),
            MAKELPARAM((WORD)y, (WORD)x ));
    }

    TRACE_OUT(("After MOUSE inject"));
}


//
// OSI_InjectSAS()
// NT-specific version to inject ctrl+alt+del into the local system
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_INJECTSAS,
            0,
            0 );
    }
    else
    {
        WARNING_OUT(("Ignoring SAS Injection attempt"));
    }
}


//
// OSI_InjectKeyboardEvent()
// NT-specific version to inject keyboard events into the local system
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD   flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    keybd_event((BYTE)vkCode, (BYTE)scanCode, flags, dwExtraInfo);

    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_KEYBDINJECT,
            (WPARAM)flags,
            MAKELPARAM(vkCode, scanCode));
    }

    TRACE_OUT(("After KEY inject"));
}


//
// OSI_DesktopSwitch()
// NT-specific, called when we think the current desktop has changed.
//
void WINAPI OSI_DesktopSwitch
(
    UINT    desktopFrom,
    UINT    desktopTo
)
{
    DebugEntry(OSI_DesktopSwitch);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(
            g_imNTData.imOtherDesktopThread,
            OSI_WM_DESKTOPSWITCH,
            desktopFrom,
            desktopTo);
    }

    DebugExitVOID(OSI_DesktopSwitch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.nt\osi.cpp ===
#include "precomp.h"
#include <version.h>
#include <ndcgver.h>


#ifndef DM_POSITION
#define DM_POSITION         0x00000020L
#endif

//
// OSI.CPP
// OS Isolation layer, NT version
//
// Copyright(c) Microsoft 1997-
//

#include <version.h>
#include <ndcgver.h>
#include <osi.h>

#define MLZ_FILE_ZONE  ZONE_CORE


//
// NT 5.0 app sharing stuff.
//
typedef BOOL (WINAPI * FN_ENUMDD)(LPVOID, DWORD, LPDISPLAY_DEVICE, DWORD);

//
// SALEM BUGBUG
// This string must be IDENTICAL to that from \ntx.reg, the key which 
// is installed into the registry for the "Device Description" value
//
static TCHAR s_szNmDD[] = "Salem sharing driver";


//
// OSI_Load()
// This handles our process attach.  We figure out if this is NT5 or not
//
void OSI_Load(void)
{
    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);
    ASSERT(osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (osVersion.dwMajorVersion >= 5)
        g_asNT5 = TRUE;
}



//
// OSI_Unload()
// This handles our process detach.  We currently do nothing.
//
void OSI_Unload(void)
{
    return;
}



//
// OSI_InitDriver50()
//
// Attemps to dynamically load/unload our display driver for NT 5.0.  This is
// called on the main thread, and if under a service, on the winlogon
// thread also.  It will only succeed on the input focus desktop.
//
void  OSI_InitDriver50(BOOL fInit)
{
    DWORD               iEnum;
    DISPLAY_DEVICE      dd;
    DEVMODE             devmode;
    FN_ENUMDD           pfnEnumDD;

    DebugEntry(OSI_InitDriver50);

    ASSERT(g_asNT5);

    pfnEnumDD = (FN_ENUMDD)GetProcAddress(GetModuleHandle("USER32.DLL"),
        "EnumDisplayDevicesA");
    if (pfnEnumDD != NULL)
    {
        ZeroMemory(&dd, sizeof(dd));
        dd.cb = sizeof(dd);

        iEnum = 0;
        while (pfnEnumDD(NULL, iEnum++, &dd, 0))
        {
            if ((dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) &&
                !lstrcmpi((LPCSTR)dd.DeviceString, s_szNmDD))
            {
                LONG    lResult;

                //
                // There may be multiple monitors, drivers, etc.  
                // We have to actually tell the system what bit depth, 
                // format, etc. our driver wants just like if we were 
                // a real driver.  We therefore always ask to get 24bpp 
                // format info, no myriad 16bpp and 32bpp formats to deal
                // with anymore.
                //
                // Also, no more 4bpp not VGA nonsense either--just 8 or 24.
                //

                ZeroMemory(&devmode, sizeof(devmode));
                devmode.dmSize = sizeof(devmode);
                devmode.dmFields = DM_POSITION | DM_BITSPERPEL | DM_PELSWIDTH |
                    DM_PELSHEIGHT;

                if (fInit)
                {
                    //
                    // Fill in fields to get driver attached.
                    //
                    if (g_usrCaptureBPP <= 8)
                        g_usrCaptureBPP = 8;
                    else
                        g_usrCaptureBPP = 24;
                    devmode.dmBitsPerPel = g_usrCaptureBPP;

                    // devmode.dmPosition is (0, 0), this means "primary"
                    devmode.dmPelsWidth = GetSystemMetrics(SM_CXSCREEN);
                    devmode.dmPelsHeight = GetSystemMetrics(SM_CYSCREEN);
                }

                //
                // This simply changes the state in the registry from
                // attached to unattached, without the system actually 
                // reflecting the change.  If/when we have multiple 
                // listings for our shadow driver, move the CDS(NULL, 0)
                // call outside the loop, and get rid of the break.
                //
                lResult = ChangeDisplaySettingsEx((LPCSTR)dd.DeviceName, &devmode,
                        NULL, CDS_UPDATEREGISTRY | CDS_NORESET, NULL);
                if (lResult != DISP_CHANGE_SUCCESSFUL)
                {
                    WARNING_OUT(("ChangeDisplaySettingsEx failed, error %d", lResult));
                }
                else
                {
                    //
                    // This causes Windows to actually go reread the registry and 
                    // update the current display to reflect the attached items, 
                    // positions, sizes, and color depths.
                    //
                    ChangeDisplaySettings(NULL, 0);

#ifdef _DEBUG
                    if (fInit)
                    {
                        HDC hdc;
                            
                        //
                        // Create a temp DC based on this driver and make sure
                        // the settings matched what we asked for.
                        //
                        hdc = CreateDC(NULL, (LPCSTR)dd.DeviceName, NULL, NULL);

                        if (!hdc)
                        {
                            WARNING_OUT(("OSI_Init:  dynamic display driver load failed"));
                        }
                        else
                        {
                            ASSERT(GetDeviceCaps(hdc, HORZRES) == (int)devmode.dmPelsWidth);
                            ASSERT(GetDeviceCaps(hdc, VERTRES) == (int)devmode.dmPelsHeight);
                            ASSERT(GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES) ==
                                (int)g_usrCaptureBPP);

                            DeleteDC(hdc);
                        }
                    }
#endif // _DEBUG

                    //
                    // Tell MNMHOOK_ the name of our driver so it can talk
                    // to it via ExtEscape.
                    //
                    OSI_SetDriverName(fInit ? (LPCSTR)dd.DeviceName : NULL);
                }

                break;
            }
        }
    }

    DebugExitVOID(OSI_InitDriver50);
}


//
// OSI_Init - see osi.h
//
void  OSI_Init(void)
{
    UINT                i;
    OSI_INIT_REQUEST    requestBuffer;

    DebugEntry(OSI_Init);

    //
    // First, setup up pointer to shared data.  This data lives here in NT.
    //
#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    g_lpimSharedData = &g_imSharedData;

    requestBuffer.result = FALSE;
    requestBuffer.pSharedMemory = NULL;
    requestBuffer.poaData[0] = NULL;
    requestBuffer.poaData[1] = NULL;
    requestBuffer.sbcEnabled = FALSE;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_asbcShuntBuffers[i]);
        requestBuffer.psbcTileData[i] = NULL;
    }

    //
    // Do this FIRST.  On NT5, only threads on the desktop with input
    // can succeed at calling ChangeDisplaySettings.  So like other things,
    // we must try to dynamically load/unload our driver on both desks.
    //

    //
    // Create the winlogon desktop event injection helper thread
    // only if we're started as a service.  Note that it will try to
    // load display at start too.
    //
    ASSERT(!g_imNTData.imOtherDesktopThread);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("Starting other desktop thread for SERVICE"));
        if (!DCS_StartThread(IMOtherDesktopProc))
        {
            WARNING_OUT(( "Failed to create other desktop IM thread"));
            DC_QUIT;
        }
    }


    //
    // DO THIS ONLY FOR NT5
    // We are going to enumerate all the entries for our shadow driver
    // (currently only one) and attach each to the actual display.
    //
    if (g_asNT5)
    {
        OSI_InitDriver50(TRUE);
    }

DC_EXIT_POINT:
    g_osiInitialized = OSI_FunctionRequest(OSI_ESC_INIT, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));

    if (!g_osiInitialized)
    {
        WARNING_OUT(("OSI_ESC_INIT: display driver not present"));
    }
    else
    {
        if (requestBuffer.result)
        {
            g_asCanHost = TRUE;

            //
            // Got shared memory pointers; keep them around
            //
            g_asSharedMemory   = (LPSHM_SHARED_MEMORY)requestBuffer.pSharedMemory;
            ASSERT(g_asSharedMemory);

            g_poaData[0]        = (LPOA_SHARED_DATA)requestBuffer.poaData[0];
            ASSERT(g_poaData[0]);

            g_poaData[1]        = (LPOA_SHARED_DATA)requestBuffer.poaData[1];
            ASSERT(g_poaData[1]);

            g_sbcEnabled        = requestBuffer.sbcEnabled;
            if (g_sbcEnabled)
            {
                //
                // Get shunt buffers
                //
                for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
                {
                    g_asbcShuntBuffers[i] = (LPSBC_SHUNT_BUFFER)requestBuffer.psbcTileData[i];
                    ASSERT(g_asbcShuntBuffers[i]);

                    TRACE_OUT(("OSI_Init: sbc shunt buffer %d:  entries %08d, bytes 0x%08x",
                        i, g_asbcShuntBuffers[i]->numEntries, g_asbcShuntBuffers[i]->numBytes));
                }

                for (i = 0; i < 3; i++)
                {
                    g_asbcBitMasks[i] = requestBuffer.aBitmasks[i];
                }
            }
        }
    }

    if (g_asCanHost)
    {
        ASSERT(g_asMainWindow);
    }

    DebugExitVOID(OSI_Init);
}


//
// OSI_Term - see osi.h
//
void  OSI_Term(void)
{
    UINT    i;

    DebugEntry(OSI_Term);

    //
    // This can be called on multiple threads:
    //      * The main DCS thread
    //      * The last thread of the process causing us to get a process
    //              detach.
    // We call it in the latter case also to make sure we cleanup properly.
    //
    ASSERT(GetCurrentThreadId() == g_asMainThreadId);

    //
    // Kill the other desktop thread if it's around.
    //
    if (g_imNTData.imOtherDesktopThread != 0)
    {
        ASSERT(g_asOptions & AS_SERVICE);
        PostThreadMessage(g_imNTData.imOtherDesktopThread, WM_QUIT, 0, 0);
        while (g_imNTData.imOtherDesktopThread)
        {
            WARNING_OUT(("OSI_Term: waiting for other desktop thread to exit"));
            Sleep(1);
        }
    }


    if (g_osiInitialized)
    {
        OSI_TERM_REQUEST    requestBuffer;

        g_osiInitialized = FALSE;

        //
        // We call the term routine only if the driver is actually loaded
        // (as opposed to whether something went wrong when trying to setup
        // for hosting) so that we will cleanup if something went wrong in
        // the middle.
        //
        OSI_FunctionRequest(OSI_ESC_TERM, (LPOSI_ESCAPE_HEADER)&requestBuffer,
            sizeof(requestBuffer));
    }

    //
    // ONLY DO THIS FOR NT5
    // We need to undo all the work we did at init time to attach our 
    // driver(s) to the display, and detach them.  Again, enumerate the
    // registry entries and look for ours.
    //
    //

    if (g_asNT5)
    {
        OSI_InitDriver50(FALSE);
    }

    // Clear our shared memory variables
    for (i = 0; i < 3; i++)
    {
        g_asbcBitMasks[i] = 0;
    }

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        g_asbcShuntBuffers[i] = NULL;
    }
    g_sbcEnabled = FALSE;

    g_asSharedMemory = NULL;
    g_poaData[0] = NULL;
    g_poaData[1] = NULL;

    g_asCanHost = FALSE;

    g_lpimSharedData = NULL;

    DebugExitVOID(OSI_Term);
}




VOID OSI_RepaintDesktop(void)
{
    DebugEntry(OSI_RepaintDesktop);

    // If this does not appear to be a window it may be a window on the
    // winlogon desktop, so we need to get the proxy thread to repaint it
    if ( g_imNTData.imOtherDesktopThread )
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_DESKTOPREPAINT, 0, 0);
    }
    DebugExitVOID(OSI_RepaintDesktop);
}


VOID OSI_SetGUIEffects(BOOL fOff)
{
    DebugEntry(OSI_SetGUIEffects);

    if (g_imNTData.imOtherDesktopThread)
    {
        PostThreadMessage(g_imNTData.imOtherDesktopThread,
                        OSI_WM_SETGUIEFFECTS, fOff, 0);
    }

    DebugExitVOID(OSI_SetGUIEffects);
}




//
// OSI_SetDriverName()
// This saves or clears the driver name so in OSI_FunctionRequest we can
// create a DC to communicate with our display driver.  On NT4.x this is a 
// display DC; on NT5 this is a direct DC to our driver.
//
void OSI_SetDriverName(LPCSTR szDriverName)
{
    DebugEntry(OSI_SetDriverName);

    if (!szDriverName)
    {
        // Clear it
        g_osiDriverName[0] = 0;
    }
    else
    {
        // Set it
        ASSERT(!g_osiDriverName[0]);
        lstrcpy(g_osiDriverName, szDriverName);
    }

    DebugExitVOID(OSI_SetDriverName);
}



//
// OSI_FunctionRequest - see osi.h
//
BOOL OSI_FunctionRequest
(
    DWORD escapeFn,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD requestLen
)
{
    BOOL            rc = FALSE;
    ULONG           iEsc;
    HDC             hdc;    

    DebugEntry(OSI_FunctionRequest);

    if (!g_osiDriverName[0])
    {
        // NT 4.x case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
            s_osiDisplayName));
        hdc = CreateDC(s_osiDisplayName, NULL, NULL, NULL);
    }
    else
    {
        // NT 5 case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
                g_osiDriverName));
        hdc = CreateDC(NULL, g_osiDriverName, NULL, NULL);
    }

    if (!hdc)
    {
        ERROR_OUT(("Failed to create DC to talk to driver '%s'", g_osiDriverName));
        DC_QUIT;
    }

    TRACE_OUT(("OSI_FunctionRequest:  Created %s driver DC %08x",
            g_osiDriverName, hdc));

    //
    // Pass the request on to the display driver.
    //
    pRequest->padding    = 0;
    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    if ((escapeFn >= OSI_HET_WO_ESC_FIRST) && (escapeFn <= OSI_HET_WO_ESC_LAST))
    {
        iEsc = WNDOBJ_SETUP;
    }
    else
    {
        iEsc = OSI_ESC_CODE;
    }

    if (0 >= ExtEscape(hdc, iEsc, requestLen, (LPCSTR)pRequest,
            requestLen, (LPSTR)pRequest))
    {
        WARNING_OUT(("ExtEscape %x code %d failed", iEsc, escapeFn));
    }
    else
    {
        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hdc)
    {
        DeleteDC(hdc);
    }

    DebugExitDWORD(OSI_FunctionRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\ba.c ===
#include "precomp.h"


//
// BA.C
// Bounds Accumulation, disply driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// BA_DDProcessRequest() - see ba.h
//
//
BOOL BA_DDProcessRequest
(
    DWORD                   fnEscape,
    LPOSI_ESCAPE_HEADER     pRequest,
    DWORD                   cbRequest,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD                   cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    if ((cbRequest != sizeof(BA_BOUNDS_INFO)) ||
        (cbResult  != sizeof(BA_BOUNDS_INFO)))
    {
        ERROR_OUT(("BA_DDProcessRequest:  Invalid sizes %d, %d for BA_ESC", cbRequest, cbResult));
        rc = FALSE;
        DC_QUIT;
    }

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pRequest;
            TRACE_OUT(( "Received %d rects from share core",
                         pBoundsInfo->numRects));

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_DDInit);

    BA_ResetBounds();

    DebugExitVOID(BA_DDInit);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    if (*pNumRects = g_baRectsUsed)
    {
        //
        // Return the bounds that have been accumulated.
        //
        TRACE_OUT(( "num rects : %d", g_baRectsUsed));

        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}



//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is INCLUSIVE coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        WARNING_OUT(( "Invalid Add Rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }


    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    memcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    int     bestMergeIncrease;
    int     mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                TRACE_OUT(( "OL_SAME - %d", iExist));
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    TRACE_OUT(( "OL_NONE - %d", iExist));
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_XMAX - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMIN - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_MERGE_YMAX - %d", iExist));
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    TRACE_OUT(( "OL_ENCLOSED - %d", iExist));

                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMIN - %d", iExist));
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_XMAX - %d", iExist));
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMIN - %d", iExist));
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSED_YMAX - %d", iExist));
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    TRACE_OUT(( "OL_ENCLOSES - %d", iExist));

                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMIN - %d", iExist));
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_XMAX - %d", iExist));
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMIN - %d", iExist));
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_PART_ENCLOSES_YMAX - %d", iExist));
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_X - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_Y - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMIN - %d", iExist));

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMIN - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMIN_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    TRACE_OUT(( "OL_SPLIT_XMAX_YMAX - %d", iExist));

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, (%d,%d,%d,%d)", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, (%d,%d,%d,%d)", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // g_back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\com.c ===
#include "precomp.h"


//
// COM.C
// Common functions, simple
//
// Copyright(c) Microsoft 1997-
//



//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
//
// List manipulation routines
//  COM_BasedListNext
//  COM_BasedListPrev
//  COM_BasedListFirst
//  COM_BasedListLast
//
//

void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\cm.c ===
#include "precomp.h"


//
// CM.C
// Cursor Manager, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// CM_DDProcessRequest() - see cm.h
//
//
ULONG CM_DDProcessRequest
(
    SURFOBJ*    pso,
    UINT        cjIn,
    void *      pvIn,
    UINT        cjOut,
    void *      pvOut
)
{
    BOOL                rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(CM_DDProcessRequest);

    if ((cjIn != sizeof(CM_DRV_XFORM_INFO)) ||
        (cjOut != sizeof(CM_DRV_XFORM_INFO)))
    {
        ERROR_OUT(("CM_DDProcessRequest:  Invalid sizes %d, %d for CM_ESC", cjIn, cjOut));
        rc = FALSE;
        DC_QUIT;
    }

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cjIn == sizeof(CM_DRV_XFORM_INFO));
            ASSERT(cjOut == sizeof(CM_DRV_XFORM_INFO));

            ((LPCM_DRV_XFORM_INFO)pvOut)->result =
                     CMDDSetTransform(ppDev, (LPCM_DRV_XFORM_INFO)pvIn);

            rc = TRUE;
            break;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised CM_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(CM_DDProcessRequest, rc);
    return((ULONG)rc);
}



// Name:      CM_DDInit
//
// Purpose:   Allocate a working surface for colour cursors
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev  - surface information
//
BOOL CM_DDInit(LPOSI_PDEV ppDev)
{
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(CM_DDInit);

    ASSERT(!g_cmWorkBitmap);

    //
    // Allocate the work bitmap, at the local device resolution.  Note that
    // we create it "top down" rather than the default of "bottom up" to
    // simplify copying data from the bitmap (we don't have to work out
    // offsets into the data - we can copy from the beginning).
    //
    bitmapSize.cx = CM_MAX_CURSOR_WIDTH;
    bitmapSize.cy = CM_MAX_CURSOR_HEIGHT;
    g_cmWorkBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(bitmapSize.cx, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

    if (!g_cmWorkBitmap)
    {
        ERROR_OUT(( "Failed to create work bitmap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
//
// CM_DDTerm - see cm.h
//
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Destroy the bitmap.  Despite its name, EngDeleteSurface is the
    // correct function to do this.
    //
    if (g_cmWorkBitmap)
    {
        if (!EngDeleteSurface((HSURF)g_cmWorkBitmap))
        {
            ERROR_OUT(( "Failed to delete work bitmap"));
        }
        else
        {
            TRACE_OUT(( "Deleted work bitmap"));
        }

        g_cmWorkBitmap = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}


//
// CM_DDViewing()
//
void CM_DDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(CM_DDViewing);

    if (fViewers)
    {
        //
        // Jiggle the cursor so we get the current image.
        //
        EngSetPointerTag(((LPOSI_PDEV)pso->dhpdev)->hdevEng, NULL, NULL, NULL, 0);
    }

    DebugExitVOID(CM_DDViewing);
}


//
//
// DrvSetPointerShape - see winddi.h
//
//
ULONG  DrvSetPointerShape(SURFOBJ  *pso,
                          SURFOBJ  *psoMask,
                          SURFOBJ  *psoColor,
                          XLATEOBJ *pxlo,
                          LONG      xHot,
                          LONG      yHot,
                          LONG      x,
                          LONG      y,
                          RECTL    *prcl,
                          FLONG     fl)
{
    ULONG                 rc         = SPS_ACCEPT_NOEXCLUDE;
    SURFOBJ *         pWorkSurf  = NULL;
    LPOSI_PDEV             ppDev      = (LPOSI_PDEV)pso->dhpdev;
    BOOL                writingSHM = FALSE;
    LPCM_SHAPE_DATA pCursorShapeData;
    RECTL                 destRectl;
    POINTL                sourcePt;
    int                   ii;
    LONG                  lineLen;
    LPBYTE              srcPtr;
    LPBYTE              dstPtr;
    LPCM_FAST_DATA      lpcmShared;

    DebugEntry(DrvSetPointerShape);

    //
    // Returning SPS_ACCEPT_NOEXCLUDE means we can ignore prcl.
    //

    //
    // Only process the change if we are hosting.  (Hosting implies being
    // initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    //
    // Get access to the shared memory.
    //
    lpcmShared = CM_SHM_START_WRITING;
    writingSHM = TRUE;

    //
    // First of all, let's trace out some useful information.
    //
    TRACE_OUT(( "pso %#hlx psoMask %#hlx psoColor %#hlx pxlo %#hlx",
                  pso, psoMask, psoColor, pxlo));
    TRACE_OUT(( "hot spot (%d, %d) x, y (%d, %d)", xHot, yHot, x, y));
    TRACE_OUT(( "Flags %#hlx", fl));

    //
    // Set up a local pointer to the cursor shape data.
    //

    pCursorShapeData = &lpcmShared->cmCursorShapeData;

    if (psoMask == NULL)
    {
        //
        // This is a transparent cursor.  Send a NULL cursor.  Note that
        // this is not the same as hiding the cursor using DrvMovePointer -
        // as in this case the cursor cannot be unhidden unless
        // DrvSetPointerShape is called again.
        //
        TRACE_OUT(( "Transparent Cursor"));
        CM_SET_NULL_CURSOR(pCursorShapeData);
        g_asSharedMemory->cmCursorHidden = FALSE;
        lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
        DC_QUIT;
    }

    //
    // We've been passed a system cursor.  Fill in the header for our local
    // cursor.  We can get the hot spot position and cursor size and width
    // easily.
    //
    pCursorShapeData->hdr.ptHotSpot.x = xHot;
    pCursorShapeData->hdr.ptHotSpot.y = yHot;

    TRACE_OUT(( "Pointer mask is %#hlx by %#hlx pixels (lDelta: %#hlx)",
             psoMask->sizlBitmap.cx,
             psoMask->sizlBitmap.cy,
             psoMask->lDelta));

    pCursorShapeData->hdr.cx = (WORD)psoMask->sizlBitmap.cx;
    pCursorShapeData->hdr.cy = (WORD)psoMask->sizlBitmap.cy / 2;

    //
    // Check cursor size
    //
    if ((pCursorShapeData->hdr.cx > CM_MAX_CURSOR_WIDTH) ||
        (pCursorShapeData->hdr.cy > CM_MAX_CURSOR_HEIGHT))
    {
        ERROR_OUT(( "Cursor too big! %d %d",
                     psoMask->sizlBitmap.cx, psoMask->sizlBitmap.cy));
        DC_QUIT;
    }

    //
    // lDelta may be negative for an inverted cursor (which is what we get
    // from DC-Share).
    //
    lineLen = abs(psoMask->lDelta);

    //
    // At this point we need to know if we are dealing with a color cursor.
    //
    if (NULL == psoColor)
    {
        TRACE_OUT(( "Monochrome pointer"));

        pCursorShapeData->hdr.cPlanes     = 1;
        pCursorShapeData->hdr.cBitsPerPel = 1;

        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;

        //
        // Copy the 1bpp AND mask and cursor shape (XOR mask) across.
        //
        TRACE_OUT(( "Copying AND mask across from %#hlx (size: %#hlx)",
                 psoMask->pvBits,
                 psoMask->cjBits));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy * 2; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        //
        // Copy black-and-white palette colors
        //
        TRACE_OUT(( "Copy B+W palette"));

        lpcmShared->colorTable[0].peRed   = 0;
        lpcmShared->colorTable[0].peGreen = 0;
        lpcmShared->colorTable[0].peBlue  = 0;
        lpcmShared->colorTable[0].peFlags = 0;

        lpcmShared->colorTable[1].peRed   = 255;
        lpcmShared->colorTable[1].peGreen = 255;
        lpcmShared->colorTable[1].peBlue  = 255;
        lpcmShared->colorTable[1].peFlags = 0;

        //
        // That's all we need to do in this case.
        //
    }
    else
    {
        TRACE_OUT(( "Color pointer - mask of %#hlx by %#hlx (lDelta: %#hlx)",
                 psoColor->sizlBitmap.cx,
                 psoColor->sizlBitmap.cy,
                 psoColor->lDelta));

        //
        // Note: row width used to calculate AND mask size - and is thus
        // for the 1bpp mask.
        //
        pCursorShapeData->hdr.cbRowWidth  = (WORD)lineLen;
        pCursorShapeData->hdr.cPlanes     = 1;

        //
        // Note: data at device bpp.
        //
        TRACE_OUT(( "BPP is %d", pCursorShapeData->hdr.cBitsPerPel));
        pCursorShapeData->hdr.cBitsPerPel = (BYTE)ppDev->cBitsPerPel;

        //
        // Lock the work bitmap to get a surface to pass to EngBitBlt.
        //
        pWorkSurf = EngLockSurface((HSURF)g_cmWorkBitmap);
        if (NULL == pWorkSurf)
        {
            ERROR_OUT(( "Failed to lock work surface"));
            DC_QUIT;
        }
        TRACE_OUT(( "Locked surface"));

        //
        // Perform the Blt to our work bitmap so that we can get the bits
        // at the native bpp.
        //
        destRectl.top    = 0;
        destRectl.left   = 0;
        destRectl.right  = psoColor->sizlBitmap.cx;
        destRectl.bottom = psoColor->sizlBitmap.cy;

        sourcePt.x = 0;
        sourcePt.y = 0;

        if (!EngBitBlt(pWorkSurf,
                       psoColor,
                       NULL,                    // mask surface
                       NULL,                    // clip object
                       pxlo,                    // XLATE object
                       &destRectl,
                       &sourcePt,
                       NULL,                    // mask origin
                       NULL,                    // brush
                       NULL,                    // brush origin
                       0xcccc))                 // SRCCPY
        {
            ERROR_OUT(( "Failed to Blt to work bitmap"));
            DC_QUIT;
        }
        TRACE_OUT(( "Got the bits at native format into the work bitmap"));

        //
        // Now copy the bits we want from this work bitmap into the
        // DCCURSORSHAPE shared memory.
        // First copy the AND bits (but ignore the redundant 1bpp XOR bits)
        //
        TRACE_OUT(( "Copy %d bytes of 1bpp AND mask", psoMask->cjBits/2));

        dstPtr = pCursorShapeData->data;
        srcPtr = (LPBYTE) psoMask->pvScan0;
        for (ii = pCursorShapeData->hdr.cy; ii > 0 ; ii--)
        {
            memcpy(dstPtr, srcPtr, lineLen);
            srcPtr += psoMask->lDelta;
            dstPtr += lineLen;
        }

        TRACE_OUT(( "Copy %d bytes of color", pWorkSurf->cjBits));
        memcpy(&(pCursorShapeData->data[psoMask->cjBits / 2]),
                  pWorkSurf->pvBits,
                  pWorkSurf->cjBits);


        //
        // Now work out the palette and copy into shared memory
        //
        if (pCursorShapeData->hdr.cBitsPerPel > 8)
        {
            //
            // Need the bitmasks.
            //
            TRACE_OUT(( "Copy bitmasks"));
            lpcmShared->bitmasks[0] = ppDev->flRed;
            lpcmShared->bitmasks[1] = ppDev->flGreen;
            lpcmShared->bitmasks[2] = ppDev->flBlue;
        }
        else
        {
            //
            // Need a palette.
            //
            TRACE_OUT(( "Copy %d palette bytes",
                  COLORS_FOR_BPP(ppDev->cBitsPerPel) * sizeof(PALETTEENTRY)));
            memcpy(lpcmShared->colorTable,
                      ppDev->pPal,
                      COLORS_FOR_BPP(ppDev->cBitsPerPel) *
                                                      sizeof(PALETTEENTRY));
        }
    }

    //
    // Set the cursor stamp, and the cursor hidden state.
    //
    lpcmShared->cmCursorStamp = g_cmNextCursorStamp++;
    g_asSharedMemory->cmCursorHidden = FALSE;

DC_EXIT_POINT:

    //
    // Free access to the shared memory if we got it earlier.
    //
    if (writingSHM)
    {
        CM_SHM_STOP_WRITING;
    }

    if (pWorkSurf != NULL)
    {
        //
        // Unlock the work bitmap surface.
        //
        EngUnlockSurface(pWorkSurf);
    }

    DebugExitDWORD(DrvSetPointerShape, rc);
    return(rc);

} // DrvSetPointerShape


//
// DrvMovePointer - see NT DDK documentation.
// We only look at this in order to check for hidden cursors - normal
// pointer moves are ignored.
//
VOID DrvMovePointer(SURFOBJ *pso,
                    LONG     x,
                    LONG     y,
                    RECTL   *prcl)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV) pso->dhpdev;

    DebugEntry(DrvMovePointer);

    //
    // We don't use the exclusion rectangle because we only support
    // hardware Pointers.  If we were doing our own Pointer simulations we
    // would want to update prcl so that the engine would call us to
    // exclude our pointer before drawing to the pixels in prcl.
    //

    //
    // Only process the mouse move if we are hosting.  (Hosting implies
    // being initialized).
    //
    if (!g_oeViewers)
    {
        DC_QUIT;
    }

    if (x == -1)
    {
        if (!g_cmCursorHidden)
        {
            //
            // Pointer is hidden.
            //
            TRACE_OUT(("Hide the cursor"));

            //
            // Set the 'hide cursor' flag.
            //
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        if (g_cmCursorHidden)
        {
            //
            // The pointer is unhidden
            //
            TRACE_OUT(("Show the cursor"));

            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = FALSE;
            CM_SHM_STOP_WRITING;

            //
            // Update our fast-path variable.
            //
            g_cmCursorHidden = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitVOID(DrvMovePointer);
}



// Name:      CMDDSetTransform
//
// Purpose:   Set up a cursor transform
//
// Returns:   TRUE/FALSE
//
// Params:    IN      ppDev - device info
//            IN      pXformInfo - data passed in to DrvEscape
//
BOOL CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo)
{
    BOOL        rc = FALSE;
    LPBYTE      pAND   = pXformInfo->pANDMask;
    SIZEL       bitmapSize;
    HBITMAP     andBitmap;
    SURFOBJ  *  pANDSurf;

    DebugEntry(CMDDSetTransform);

    if (pAND == NULL)
    {
        //
        // Reset the transform
        //
        TRACE_OUT(( "Clear transform"));
        EngSetPointerTag(ppDev->hdevEng, NULL, NULL, NULL, 0);
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Transforms are always monochrome
    //

    //
    // Create a 1bpp bitmap, double-height, with the AND bits followed by
    // the XOR bits.  We are given a top-down DIB, so we need to create
    // a top-down bitmap.
    //
    bitmapSize.cx = pXformInfo->width;
    bitmapSize.cy = pXformInfo->height * 2;

    andBitmap = EngCreateBitmap(bitmapSize, BYTES_IN_BITMAP(bitmapSize.cx, 1, 1),
        BMF_1BPP, BMF_TOPDOWN, NULL);

    pANDSurf = EngLockSurface((HSURF)andBitmap);
    if (pANDSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }

    //
    // Copy the bits
    //
    memcpy(pANDSurf->pvBits, pAND, pANDSurf->cjBits);

    TRACE_OUT(( "Set the tag"));
    EngSetPointerTag(ppDev->hdevEng, pANDSurf, NULL, NULL, 0);

    EngUnlockSurface(pANDSurf);
    EngDeleteSurface((HSURF)andBitmap);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);

} // CMDDSetTransform
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\globals.c ===
//
// GLOBALS.C
// Global variable storage
//
// Copyright(c) Microsoft 1997-
//


#include "precomp.h"


#include <datainit.h>
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\globals.h ===
//
// GLOBALS.H
// Global variable decls
//
// Copyright(c) Microsoft 1997-
//

#include <osi.h>
#include <shm.h>
#include <oa.h>
#include <ba.h>
#include <cm.h>
#include <host.h>
#include <fh.h>
#include <ssi.h>
#include <oe.h>
#include <sbc.h>


//
// Debug stuff
//
#if defined(DEBUG) || defined(INIT_TRACE)
DC_DATA_VAL   ( char,           g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_ARRAY ( char,           g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA_VAL   ( UINT,           g_trcConfig, ZONE_INIT );
#endif // DEBUG or INIT_TRACE



//
// Driver
//




//
// Shared Memory Manager
//
DC_DATA     ( LPSHM_SHARED_MEMORY,      g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,       g_poaData,    2 );

//
// Shared memory.
//
DC_DATA ( UINT,           g_shmSharedMemorySize );
DC_DATA ( LPVOID,         g_shmMappedMemory );      // user mode ptr




//
// Bounds Accumulator
//
DC_DATA ( UINT,           g_baFirstRect );
DC_DATA ( UINT,           g_baLastRect );
DC_DATA ( UINT,           g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);


//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);


//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,   g_baSpoilByNewSDAEnabled,     TRUE);




//
// Cursor Manager
//

DC_DATA (HBITMAP,   g_cmWorkBitmap );
DC_DATA (DWORD,     g_cmNextCursorStamp );
DC_DATA (BOOL,      g_cmCursorHidden );



//
// Hosted Entity Tracker
//
DC_DATA ( BASEDLIST,           g_hetWindowList );  // Anchor for hosted wnd list
DC_DATA ( BASEDLIST,           g_hetFreeWndList ); // Anchor for free list
DC_DATA ( BASEDLIST,           g_hetMemoryList );  // Anchor for memory block list

//
// Flag which indicates if the desktop is shared.
//
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );



//
// Order Accumulator
//

// Throughput
DC_DATA ( UINT,         g_oaFlow );

//
// Flag to indicate whether we are allowed to purge the order heap.
//
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);


//
// Order Encoder 
//

//
// Are we supporting all ROPS in a conference, or do we disallow ROPS which
// involve the destination bits.
//
DC_DATA ( BOOL,             g_oeSendOrders );

//
// Are text orders allowed?
//
DC_DATA ( BOOL,           g_oeTextEnabled );

//
// Array of supported orders
//
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );



//
// Temporary buffer to store the memblt and mem3blt orders which are
// initially created by the display driver interception code.  This buffer
// is used because the subsequent logic for these orders breaks down the
// original order into smaller tiled orders and then throws the original
// away.  So to keep a coherent order heap, we do not allocate the
// temporary order off the heap.
//
DC_DATA_ARRAY(BYTE,
                   g_oeTmpOrderBuffer,
                   sizeof(INT_ORDER) +
                       max( max( max(sizeof(MEMBLT_ORDER),
                                              sizeof(MEMBLT_R2_ORDER) ),
                                       sizeof(MEM3BLT_ORDER) ),
                               sizeof(MEM3BLT_R2_ORDER) ));

//
// Storage space to create a temporary solid brush for BitBlt orders.
//
DC_DATA ( OE_BRUSH_DATA,    g_oeBrushData );

//
// Local font matching data - this is passed from the share core
//
DC_DATA ( LPLOCALFONT,  g_poeLocalFonts );

//
// Local font index.  This is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, g_oeLocalFontIndex[65] gives the first index in g_oeLocalFonts
// that starts with the character 'A'.
//
DC_DATA_ARRAY( WORD,  g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );

//
// Number of local fonts
//
DC_DATA ( UINT,             g_oeNumFonts );

//
// Capabilities - from PROTCAPS_ORDERS
//
DC_DATA ( UINT,             g_oeFontCaps );

//
// Do we support baseline text orders for this conference?
//
DC_DATA ( BOOL,           g_oeBaselineTextEnabled );

//
// Local font matching data - this is passed from the share core
//
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, (ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1));

DC_DATA ( BOOL,             g_oeViewers );         // Accumulate graphics



//
// Send Bitmap Cache
//


//
// BPP for bitmap data sent over the wire
//
DC_DATA ( UINT,  g_sbcSendingBPP );

//
// Cache info
//
DC_DATA_ARRAY( SBC_SHM_CACHE_INFO,  g_asbcCacheInfo,  NUM_BMP_CACHES );


//
// Array of structures holding the info required to get the bitmap bits
// from the source surface into the shunt buffer.
//
DC_DATA_ARRAY (SBC_TILE_WORK_INFO, g_asbcWorkInfo, SBC_NUM_TILE_SIZES );

//
// The Id to use for the next tile passed to the share core in a shunt
// buffer.
//
DC_DATA ( WORD,   g_sbcNextTileId );

//
// This is the number of ticks per second which the performance timer
// generates.  We store this rather than making lots of calls to
// EngQueryPerformanceFrequency.
//
DC_DATA ( LONGLONG, g_sbcPerfFrequency );

//
// Array of structures containing info about bitmap cache thrashers
//
DC_DATA_ARRAY (SBC_THRASHERS,   g_sbcThrashers, SBC_NUM_THRASHERS );


//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\oe.c ===
#include "precomp.h"


//
// OE.C
// Order Encoder, display driver side
//
// Copyright(c) Microsoft 1997-
//

//
// Number of entries in the font alias table.
//
#define NUM_ALIAS_FONTS 3

//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
FONT_ALIAS_TABLE fontAliasTable[NUM_ALIAS_FONTS] =
{
    { "Helv",            "MS Sans Serif", 0 },
    { "MS Dialog",       "MS Sans Serif", 1 },
    { "MS Dialog Light", "MS Sans Serif", 0 }
};




//
// FUNCTION: OE_SendAsOrder see oe.h
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}


//
// OE_RectIntersectsSDA - see oe.h
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect(%d,%d)(%d,%d) intersects SDA(%d,%d)(%d,%d)",
                          rectVD.left, rectVD.top,
                          rectVD.right, rectVD.bottom,
                          g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                          g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitDWORD(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}


//
// DrvBitBlt - see NT DDK documentation.
//
BOOL DrvBitBlt( SURFOBJ  *psoDst,
                      SURFOBJ  *psoSrc,
                      SURFOBJ  *psoMask,
                      CLIPOBJ  *pco,
                      XLATEOBJ *pxlo,
                      RECTL    *prclDst,
                      POINTL   *pptlSrc,
                      POINTL   *pptlMask,
                      BRUSHOBJ *pbo,
                      POINTL   *pptlBrush,
                      ROP4      rop4 )
{
    LPOSI_PDEV               ppdev = (LPOSI_PDEV)psoDst->dhpdev;
    BOOL                    rc = TRUE;
    UINT                orderType = 0;
    BYTE                 rop3;
    LPINT_ORDER              pOrder = NULL;
    LPDSTBLT_ORDER          pDstBlt;
    LPSCRBLT_ORDER          pScrBlt;
    LPMEMBLT_ORDER          pMemBlt;
    LPMEM3BLT_ORDER         pMem3Blt;
    BOOL                  fSendOrder  = FALSE;
    BOOL                  fAccumulate = FALSE;
    UINT                fOrderFlags = OF_SPOILABLE;
    RECT                  bounds;
    RECT                  intersectRect;
    POINT                 origin;
    POE_BRUSH_DATA          pCurrentBrush;
    MEMBLT_ORDER_EXTRA_INFO memBltExtraInfo;

    DebugEntry(DrvBitBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;

    //
    // Get the bounding rectangle for the operation.
    //
    RECT_FROM_RECTL(bounds, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &bounds);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&bounds, 1);

    //
    // Check if this 4-way ROP simplifies to a 3-way ROP.  A 4-way ROP
    // contains two 3-way ROPS, one for each setting of a mask bit - the
    // high ROP3 corresponds to a value of zero in the mask bit.
    //
    // If the two 3-way ROPs are the same, we know the 4-way ROP is a 3-way
    // ROP.
    //
    if (ROP3_LOW_FROM_ROP4(rop4) == ROP3_HIGH_FROM_ROP4(rop4))
    {
        //
        // Take the high byte as the 3-way ROP.
        //
        rop3 = ROP3_HIGH_FROM_ROP4(rop4);
        TRACE_OUT(( "4-way ROP %04x is really 3-way %02x", rop4, rop3));
    }
    else
    {
        TRACE_OUT(( "4-way ROP %08x", rop4));
        DC_QUIT;
    }

    //
    // Determine the command type.  It can be one of the following.
    //
    // DSTBLT  - A destination only BLT (no source, or pattern)
    // PATBLT  - a pattern BLT (no source)
    // SCRBLT  - a screen to screen BLT
    // MEMBLT  - a memory to screen BLT (no pattern)
    // MEM3BLT - a memory to screen 3-way BLT
    //

    //
    // Check for destination only BLTs (ie. independent of source bits).
    //
    if ((psoSrc == NULL) || ROP3_NO_SOURCE(rop3))
    {
        //
        // Check for a pattern or true destination BLT.
        //
        if (ROP3_NO_PATTERN(rop3))
        {
            TRACE_OUT(( "DSTBLT"));
            orderType = ORD_DSTBLT;
        }
        else
        {
            TRACE_OUT(( "PATBLT"));
            orderType = ORD_PATBLT;
        }
    }
    else
    {
        //
        // We have a source BLT, check whether we have screen or memory
        // BLTs.
        //
        if (psoSrc->hsurf != ppdev->hsurfScreen)
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                ERROR_OUT(( "MEM to MEM blt!"));
            }
            else
            {
                //
                // We have a memory to screen BLT, check which type.
                //
                if ((ppdev->cBitsPerPel == 4) && (rop3 != 0xcc))
                {
                    //
                    // No order -- the result depends on the palette
                    // which is dicy in VGA
                    //
                    TRACE_OUT(("No order on VGA for rop 0x%02x", rop3));
                    DC_QUIT;
                }

                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "MEMBLT"));
                    orderType = ORD_MEMBLT;
                }
                else
                {
                    TRACE_OUT(( "MEM3BLT"));
                    orderType = ORD_MEM3BLT;
                }
            }
        }
        else
        {
            if (psoDst->hsurf != ppdev->hsurfScreen)
            {
                TRACE_OUT(( "SCR to MEM blt!"));
            }
            else
            {
                //
                // We only support destination only screen BLTs (ie.  no
                // patterns allowed).
                //
                if (ROP3_NO_PATTERN(rop3))
                {
                    TRACE_OUT(( "SCRBLT"));
                    orderType = ORD_SCRBLT;
                }
                else
                {
                    TRACE_OUT(( "Unsupported screen ROP %x", rop3));
                }
            }
        }
    }

    //
    // Check if we have a supported order.
    //
    if (orderType == 0)
    {
        TRACE_OUT(( "Unsupported BLT"));
        fAccumulate = FALSE;
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Order %d not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check if we are allowed to send the ROP.
    //
    if (!OESendRop3AsOrder(rop3))
    {
        TRACE_OUT(( "Cannot send ROP %d", rop3));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // If this is a Memblt, do an initial check on whether it is cachable
    //
    if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
    {
        //
        // We have to fill in a structure containing extra into
        // specifically for a MEM(3)BLT order.
        //
        memBltExtraInfo.pSource   = psoSrc;
        memBltExtraInfo.pDest     = psoDst;
        memBltExtraInfo.pXlateObj = pxlo;

        if (!SBC_DDIsMemScreenBltCachable(&memBltExtraInfo))
        {
            TRACE_OUT(( "MemBlt is not cachable"));
            DC_QUIT;
        }

        //
        // It is cachable.  Before we get SBC to do the caching, we have to
        // allow it to queue a color table (if required).
        //
        if (!SBC_DDMaybeQueueColorTable(ppdev))
        {
            TRACE_OUT(( "Unable to queue color table for MemBlt"));
            DC_QUIT;
        }
    }

    //
    // We have a recognised order - do the specific checks for each order.
    //
    switch (orderType)
    {
        case ORD_DSTBLT:
            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;

            //
            // Set the spoiler flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the order type.
            //
            pDstBlt->type = LOWORD(orderType);

            //
            // Virtual desktop co-ordinates.
            //
            pDstBlt->nLeftRect  = bounds.left;
            pDstBlt->nTopRect   = bounds.top;
            pDstBlt->nWidth     = bounds.right  - bounds.left + 1;
            pDstBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pDstBlt->bRop       = rop3;

            TRACE_OUT(( "DstBlt X %d Y %d w %d h %d rop %02X",
                    pDstBlt->nLeftRect,
                    pDstBlt->nTopRect,
                    pDstBlt->nWidth,
                    pDstBlt->nHeight,
                    pDstBlt->bRop));
            break;

        case ORD_PATBLT:
            if ( !OEEncodePatBlt(ppdev,
                                 pbo,
                                 pptlBrush,
                                 rop3,
                                 &bounds,
                                 &pOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                DC_QUIT;
            }

            fOrderFlags = pOrder->OrderHeader.Common.fOrderFlags;
            break;

        case ORD_SCRBLT:
            //
            // Check for a SCRBLT as a result of a Desktop Scroll.  We must
            // ignore these as they will stuff the remote desktop.
            //
            // The check is simple - if the virtual position of the source
            // is the same as the virual position of the target for a
            // SRCCOPY type SCRBLT, we have a hit...
            //
            POINT_FROM_POINTL(origin, (*pptlSrc));

            //
            // Allocate the memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER),0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;

            //
            // Store the order type.
            //
            pScrBlt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already converted
            // bounds to an inclusive rectangle in virtual co-ordinates.
            //
            pScrBlt->nLeftRect  = bounds.left;
            pScrBlt->nTopRect   = bounds.top;
            pScrBlt->nWidth     = bounds.right  - bounds.left + 1;
            pScrBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pScrBlt->bRop       = rop3;

            //
            // Source point on the screen.
            //
            OELPtoVirtual(&origin, 1);
            pScrBlt->nXSrc = origin.x;
            pScrBlt->nYSrc = origin.y;

            //
            // Screen to screen blts are Blocking orders (i.e.  they
            // prevent any previous orders from being spoilt).
            //
            // We do not mark Screen to Screen blts as SPOILER orders.  If
            // the ROP is opaque we could spoil the destination rect, but
            // only the area that does not overlap with the src rectangle.
            // The most common use of Screen to Screen blts is scrolling,
            // where the src and dst rects almost completely overlap,
            // giving only a small "spoiler" region.  The spoiler region
            // could also be complex (more that 1 rect).
            //
            // Consequently, the potential gains of trying to spoil using
            // these orders are small compared to the complexity of the
            // code required.
            //
            //
            fOrderFlags |= OF_BLOCKER;

            //
            // If the blt is screen to screen and the source overlaps the
            // destination and the clipping is not simple (> 1 rect) then
            // we do not want to send this as an order.
            //
            // (This is because we would need some complex code to
            // calculate the order in which to blt through each of the clip
            // rects.  As this case is pretty rare, it seems reasonable to
            // just send it as Screen Data).
            //
            if (!OEClippingIsSimple(pco))
            {
                //
                // Calculate the overlapping rectangle.
                //
                intersectRect.left  = max(pScrBlt->nLeftRect, pScrBlt->nXSrc);

                intersectRect.right = min(
                          pScrBlt->nLeftRect + pScrBlt->nWidth-1,
                          pScrBlt->nXSrc     + pScrBlt->nWidth-1 );

                intersectRect.top   = max(pScrBlt->nTopRect, pScrBlt->nYSrc);

                intersectRect.bottom = min(
                               pScrBlt->nTopRect + pScrBlt->nHeight-1,
                               pScrBlt->nYSrc    + pScrBlt->nHeight-1 );

                //
                // Check for a src / dst overlap.  If they overlap, the
                // intersection is a well-ordered non-trivial rectangle.
                //
                if ( (intersectRect.left <= intersectRect.right ) &&
                     (intersectRect.top  <= intersectRect.bottom) )
                {
                    //
                    // The src & dest overlap.  Free up the order memory
                    // and skip out now.  The destination rectangle will be
                    // added to the Screen Data Area.
                    //
                    OA_DDFreeOrderMem(pOrder);
                    DC_QUIT;
                }
            }

            TRACE_OUT(( "ScrBlt x %d y %d w %d h %d sx %d sy %d rop %02X",
                   pScrBlt->nLeftRect,
                   pScrBlt->nTopRect,
                   pScrBlt->nWidth,
                   pScrBlt->nHeight,
                   pScrBlt->nXSrc,
                   pScrBlt->nYSrc,
                   pScrBlt->bRop));
            break;

        case ORD_MEMBLT:
            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder  = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMemBlt = (LPMEMBLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                    = sizeof(MEMBLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMemBlt->type = LOWORD(orderType);

            //
            // Any data which is sent over the wire must be in virtual
            // desktop co-ordinates.  The bounding rectangle has already
            // been converted by OELRtoScreen.
            //
            pMemBlt->nLeftRect  = bounds.left;
            pMemBlt->nTopRect   = bounds.top;
            pMemBlt->nWidth     = bounds.right  - bounds.left + 1;
            pMemBlt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMemBlt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMemBlt->nXSrc = pptlSrc->x;
            pMemBlt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMemBlt->cacheId = 0;

            TRACE_OUT(( "MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %04X",
                   pMemBlt->nLeftRect,
                   pMemBlt->nTopRect,
                   pMemBlt->nWidth,
                   pMemBlt->nHeight,
                   pMemBlt->nXSrc,
                   pMemBlt->nYSrc,
                   pMemBlt->bRop));
            break;

        case ORD_MEM3BLT:
            //
            // Check that the brush pattern is simple.
            //
            if (!OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush))
            {
                TRACE_OUT(( "Brush is not simple"));
                orderType = 0;
                DC_QUIT;
            }

            //
            // Allocate the memory for the order - don't use OA as we are
            // only going to tile this order immediately.  Instead, we have
            // a static buffer to receive the template order data.
            //
            pOrder   = (LPINT_ORDER)g_oeTmpOrderBuffer;
            pMem3Blt = (LPMEM3BLT_ORDER)pOrder->abOrderData;
            pOrder->OrderHeader.Common.cbOrderDataLength
                                                   = sizeof(MEM3BLT_R2_ORDER);

            //
            // Store the order type.
            //
            pMem3Blt->type = LOWORD(orderType);

            //
            // All data which is sent over the wire must be in virtual
            // desktop co-ordinates.  OELRtoVirtual has already done this
            // conversion for us.
            //
            pMem3Blt->nLeftRect  = bounds.left;
            pMem3Blt->nTopRect   = bounds.top;
            pMem3Blt->nWidth     = bounds.right  - bounds.left + 1;
            pMem3Blt->nHeight    = bounds.bottom - bounds.top  + 1;
            pMem3Blt->bRop       = rop3;

            //
            // We need to store the source bitmap origin.  This is a memory
            // object, so screen/virtual conversions are unnecessary.
            //
            pMem3Blt->nXSrc = pptlSrc->x;
            pMem3Blt->nYSrc = pptlSrc->y;

            //
            // Mark the order as opaque if necessary.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
                fOrderFlags |= OF_SPOILER;
            }

            //
            // Store the src bitmap handle in the order.
            //
            pMem3Blt->cacheId = 0;

            //
            // Set up the information required for the pattern.
            //
            pMem3Blt->BackColor = pCurrentBrush->back;
            pMem3Blt->ForeColor = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pMem3Blt->BrushOrgX  = pptlBrush->x;
            pMem3Blt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pMem3Blt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pMem3Blt->BrushStyle = pCurrentBrush->style;
            pMem3Blt->BrushHatch = pCurrentBrush->style;

            RtlCopyMemory(pMem3Blt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pMem3Blt->BrushExtra));

            TRACE_OUT(( "Mem3Blt brush %02X %02X dx %d dy %d w %d h %d "
                         "sx %d sy %d rop %04X",
                    pMem3Blt->BrushStyle,
                    pMem3Blt->BrushHatch,
                    pMem3Blt->nLeftRect,
                    pMem3Blt->nTopRect,
                    pMem3Blt->nWidth,
                    pMem3Blt->nHeight,
                    pMem3Blt->nXSrc,
                    pMem3Blt->nYSrc,
                    pMem3Blt->bRop));
            break;

        default:
            ERROR_OUT(( "New unsupported order %08lx", orderType));
            orderType = 0;
            break;
    }

    //
    // We have generated an order so make sure we send it.
    //
    if (orderType != 0)
    {
        fSendOrder = TRUE;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Check if the ROP has a dependency on the destination.
        //
        if (!ROP3_NO_TARGET(rop3))
        {
            TRACE_OUT(( "ROP has a target dependency"));
            fOrderFlags |= OF_DESTROP;
        }

        //
        // Store the general order data.  The bounding rectagle
        // co-ordinates must be virtual desktop.  OELRtoVirtual has already
        // converted rect for us.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = (TSHR_UINT16)fOrderFlags;

        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, bounds);

        //
        // Add the order to the cache.  Note that we have the new tiled
        // processing for MEMBLT and MEM3BLT orders.
        //
        if ((orderType == ORD_MEMBLT) || (orderType == ORD_MEM3BLT))
        {
            OETileBitBltOrder(pOrder, &memBltExtraInfo, pco);
        }
        else
        {
            OEClipAndAddOrder(pOrder, NULL, pco);
        }
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&bounds, pco);
        }

    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvBitBlt, rc);
    return(rc);
}


//
// DrvStretchBlt - see NT DDK documentation.
//
BOOL DrvStretchBlt(SURFOBJ         *psoDst,
                         SURFOBJ         *psoSrc,
                         SURFOBJ         *psoMask,
                         CLIPOBJ         *pco,
                         XLATEOBJ        *pxlo,
                         COLORADJUSTMENT *pca,
                         POINTL          *pptlHTOrg,
                         RECTL           *prclDst,
                         RECTL           *prclSrc,
                         POINTL          *pptlMask,
                         ULONG            iMode)
{
    BOOL    rc = TRUE;
    RECT  rectSrc;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    POINTL  ptlSrc;
    BOOL    usedBitBlt  = FALSE;

    DebugEntry(DrvStretchBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get the source and destination rectangles
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check that we have a valid ROP code.  The NT DDK states that the ROP
    // code for the StretchBlt is implicit in the mask specification.  If a
    // mask is specified, we have an implicit ROP4 of 0xCCAA, otherwise the
    // code is 0xCCCC.
    //
    // Our BitBlt code only encodes orders for ROP3s, so we must throw any
    // StretchBlts with a mask.
    //
    if (psoMask != NULL)
    {
        TRACE_OUT(( "Mask specified"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Rectangles are now well-ordered, check if we have a degenerate (ie.
    // no stretch) case.
    //
    if ( (rectSrc.right  - rectSrc.left == rectDst.right  - rectDst.left) &&
         (rectSrc.bottom - rectSrc.top  == rectDst.bottom - rectDst.top ) )
    {
        //
        // This can be passed on to the BitBlt code.
        //
        usedBitBlt = TRUE;

        ptlSrc.x = prclSrc->left;
        ptlSrc.y = prclSrc->top;

        rc = DrvBitBlt(psoDst,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclDst,
                       &ptlSrc,
                       pptlMask,
                       NULL,
                       NULL,
                       0xCCCC);

        //
        // We have stored this object in the BitBlt, so don't store the
        // data again.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the data to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);

        //
        // Update the screen data area
        //
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStretchBlt, rc);
    return(rc);
}


//
// DrvCopyBits - see NT DDK documentation.
//
BOOL DrvCopyBits(SURFOBJ  *psoDst,
                       SURFOBJ  *psoSrc,
                       CLIPOBJ  *pco,
                       XLATEOBJ *pxlo,
                       RECTL    *prclDst,
                       POINTL   *pptlSrc)
{
    //
    // CopyBits is a fast path for the NT display drivers.  In our case it
    // can always be processed as a BITBLT.
    //
    return(DrvBitBlt( psoDst,
                    psoSrc,
                    NULL,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    NULL,
                    NULL,
                    NULL,
                    0xCCCC));
}


//
// DrvTextOut - see NT DDK documentation.
//
BOOL DrvTextOut(SURFOBJ  *pso,
                      STROBJ   *pstro,
                      FONTOBJ  *pfo,
                      CLIPOBJ  *pco,
                      RECTL    *prclExtra,
                      RECTL    *prclOpaque,
                      BRUSHOBJ *pboFore,
                      BRUSHOBJ *pboOpaque,
                      POINTL   *pptlOrg,
                      MIX       mix)
{
    LPOSI_PDEV           ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL                rc = TRUE;
    RECT              rectDst;
    RECT              rectText;
    LPINT_ORDER          pOrder;
    LPINT_ORDER          pOpaqueOrder;
    LPTEXTOUT_ORDER     pTextOut;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    BOOL              fSendOrder  = FALSE;
    BOOL              fAccumulate = FALSE;
    char              ansiString[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+2];
    ULONG               ansiLen;
    ULONG               tempLen;
    UINT            orderType = 0;
    ULONG               maxLength;
    LPSTR             lpVariable;
    BOOL                fMoreData;
    ULONG               count;
    ULONG               i;
    GLYPHPOS*           pGlyphData;
    int                 currentDelta;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                fontFlags;
    UINT                fontAscender;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontIndex;
    POINTL              lastPtl;
    LPCOMMON_TEXTORDER   pCommon;
    POINT               startPoint;
    BOOL              sendDeltaX = FALSE;

    DebugEntry(DrvTextOut);

    //
    // DO THIS _BEFORE_ TAKING LOCKS
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    if (prclOpaque != NULL)
    {
        RECT_FROM_RECTL(rectDst, (*prclOpaque));
    }
    else
    {
        RECT_FROM_RECTL(rectDst, pstro->rclBkGround);
        TRACE_OUT(( "Using STROBJ bgd for size"));
    }

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Determine which order we will generate
    //
    if ( ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) != 0) &&
         (prclOpaque == NULL) )
    {
        orderType = ORD_TEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }
    else
    {
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(orderType))
    {
        TRACE_OUT(( "Text order %x not allowed", orderType));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pboFore->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text fg"));
        DC_QUIT;
    }
    if (pboOpaque->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for text bg"));
        DC_QUIT;
    }

    //
    // Check that we don't have any modifiers rects on the font
    //
    if (prclExtra != NULL)
    {
        TRACE_OUT(( "Unsupported extra rects"));
        DC_QUIT;
    }

    //
    // Check that text orientation is OK.
    //
    if (pstro->flAccel & OE_BAD_TEXT_MASK)
    {
        TRACE_OUT(("DrvTextOut - unsupported flAccel 0x%08x", pstro->flAccel));
        DC_QUIT;
    }

    //
    // Check we have a valid string.
    //
    if (pstro->pwszOrg == NULL)
    {
        TRACE_OUT(( "No string - opaque %x", prclOpaque));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Convert the string to an ANSI representation.
    //
    RtlFillMemory(ansiString, sizeof(ansiString), 0);
    EngUnicodeToMultiByteN(ansiString,
                           maxLength,
                           &ansiLen,
                           pstro->pwszOrg,
                           pstro->cGlyphs * sizeof(WCHAR));


    //
    // The conversion claims it never fails, but we have seen results that
    // are completely different on the remote box.  So we convert the ANSI
    // string back to UNICODE and check that we still have what we started
    // with.
    //
    EngMultiByteToUnicodeN(g_oeTempString,
                           sizeof(g_oeTempString),
                           &tempLen,
                           ansiString,
                           ansiLen);

    //
    // Check we don't have too much data, or that the translation failed to
    // give the correct data.  This happens when we try to translate
    // UNICODE text.
    //
    if ( (tempLen != pstro->cGlyphs * sizeof(WCHAR))           ||
         (memcmp(pstro->pwszOrg, g_oeTempString, tempLen) != 0) )
    {
        TRACE_OUT(( "String not translated"));
        DC_QUIT;
    }

    //
    // Check that the font is valid.
    //
    if (!OECheckFontIsSupported(pfo, ansiString, ansiLen,
                                &fontHeight,
                                &fontAscender,
                                &fontWidth,
                                &fontWeight,
                                &fontFlags,
                                &fontIndex,
                                &sendDeltaX))
    {
        TRACE_OUT(( "Unsupported font for '%s'", ansiString));
        //
        // Check if there is an opaque rectangle. If so it is worth
        // splitting this out. Word can output an entire line comprising a
        // single character followed by background, eg bullets, where the
        // line is blanked by drawing the bullet character at the start of
        // the line followed by a large - >1000 pixel - opaque rect.
        // Splitting the opaque rect from the text means we can send a
        // small area of SD for the unmatched font char while encoding the
        // large opaque rectangle.
        //
        if ( (prclOpaque != NULL) &&
             (pstro->cGlyphs == 1) &&
             (pstro->flAccel & SO_HORIZONTAL) &&
             OE_SendAsOrder(ORD_PATBLT))
        {
            //
            // There is an opaque rectangle and a single char.
            // Encode the opaque rectangle. First get a copy of the target
            // rect so we can use it later (and flip it into screen
            // coordinates).
            //
            TRACE_OUT(( "Have 1 char + opaque rect"));
            rectText.left = rectDst.left;
            rectText.top = rectDst.top;
            rectText.right = rectDst.right + 1;
            rectText.bottom = rectDst.bottom + 1;

            //
            // Call into the PATBLT encoding function.
            //
            if ( !OEEncodePatBlt(ppdev,
                                 pboOpaque,
                                 pptlOrg,
                                 OE_COPYPEN_ROP,
                                 &rectDst,
                                 &pOpaqueOrder) )
            {
                //
                // Something went wrong with the encoding, so skip to the
                // end to add this operation to the SDA.
                //
                TRACE_OUT(( "Failed to encode opaque rect"));
                DC_QUIT;
            }

            //
            // Store the general order data.  The bounding rectagle
            // co-ordinates must be virtual desktop.  OELRtoVirtual has
            // already converted rect for us.
            //
            TSHR_RECT16_FROM_RECT(&pOpaqueOrder->OrderHeader.Common.rcsDst, rectDst);

            //
            // Add the order to the cache.
            //
            OEClipAndAddOrder(pOpaqueOrder, NULL, pco);

            //
            // Calculate the bounds of the text. Get the glyph positions
            // for the left and right, and assume the top and bottom equate
            // approximately to the opaque rectangle.
            //
            if ( pstro->pgp == NULL)
            {
                //
                // The string object doesn't contain the GLYPHPOS info, so
                // enumerate the glyphs.
                //
                TRACE_OUT(( "Enumerate glyphs"));
                STROBJ_vEnumStart(pstro);
                STROBJ_bEnum(pstro, &count, &pGlyphData);
            }
            else
            {
                //
                // The string object already contains the GLYPHPOS info, so
                // just grab the pointer to it.
                //
                pGlyphData = pstro->pgp;
            }

            rectDst = rectText;
            rectDst.left = max(rectDst.left, pGlyphData[0].ptl.x);
            if ( pstro->ulCharInc == 0 )
            {
                //
                // No character increment for this string object. Just use
                // the maximum glyph width to calculate the right bounding
                // edge.
                //
                TRACE_OUT(( "no charinc glyph %d trg %d left %d maxX %d",
                                                   pGlyphData[0].ptl.x,
                                                   rectDst.right,
                                                   rectDst.left,
                                                   pfo->cxMax));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                              pfo->cxMax - 1));
            }
            else
            {
                //
                // The string object has a character increment, so use it
                // to determine the right bounding edge.
                //
                TRACE_OUT(( "charinc %x glyph %d trg %d left %d",
                                                    pstro->ulCharInc,
                                                    pGlyphData[0].ptl.x,
                                                    rectDst.right,
                                                    rectDst.left));
                rectDst.right = min(rectDst.right, (int)(pGlyphData[0].ptl.x +
                                                        pstro->ulCharInc - 1));
            }

            //
            // Flip the target rectangle back to virtual coordinates.
            //
            rectDst.right -= 1;
            rectDst.bottom -= 1;
        }

        //
        // Skip to the end to add to the SDA.
        //
        DC_QUIT;
    }

    //
    // It is possible that the font matching blows our previous decision to
    // generate a TextOut order and we need to generate an ExtTextOut order
    // instead.  We need to reverify our parameters if this is the case.
    //
    if ((sendDeltaX) && (orderType != ORD_EXTTEXTOUT))
    {
        TRACE_OUT(( "Text order must be EXTTEXTOUT"));

        //
        // Set up for ExtTexOut orders.
        //
        orderType = ORD_EXTTEXTOUT;
        maxLength = ORD_MAX_STRING_LEN_WITH_DELTAS;

        //
        // Check if we are allowed to send this order (determined by the
        // negotiated capabilities of all the machines in the conference).
        //
        if (!OE_SendAsOrder(orderType))
        {
            TRACE_OUT(( "Text order %x not allowed", orderType));
            DC_QUIT;
        }

        //
        // Make sure we haven't blown the order size.
        //
        if (pstro->cGlyphs > maxLength)
        {
            TRACE_OUT(( "Text limit blown", pstro->cGlyphs));
            DC_QUIT;
        }
    }

    //
    // Get the proper start position for the text.
    //
    if ( pstro->pgp == NULL)
    {
        STROBJ_vEnumStart(pstro);
        STROBJ_bEnum(pstro, &count, &pGlyphData);
        if (count == 0)
        {
            WARNING_OUT(( "No glyphs"));
            DC_QUIT;
        }
    }
    else
    {
        pGlyphData = pstro->pgp;
    }

    startPoint.x = pGlyphData[0].ptl.x;

    //
    // Check if we should be using baseline alignment for the y
    // coordinate.  If we should be, the value in the glyph data is
    // correct.  If not, we the y coordinate is for the top of the
    // text, and we have to calculate it.
    //
    if (g_oeBaselineTextEnabled)
    {
        startPoint.y = pGlyphData[0].ptl.y;
        fontFlags   |= NF_BASELINE;
    }
    else
    {
        startPoint.y = pGlyphData[0].ptl.y - fontAscender;
    }

    //
    // Allocate memory for the order
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:
        {
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(TEXTOUT_ORDER)
                                          - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                          + ansiLen ),
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pTextOut->type    = ORD_TEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pTextOut->common;
        }
        break;


        case ORD_EXTTEXTOUT:
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is needed
            //
            //
            // Allocate the memory
            //
            pOrder = OA_DDAllocOrderMem((UINT)( sizeof(EXTTEXTOUT_ORDER)
                                      -  ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                                      - (ORD_MAX_STRING_LEN_WITH_DELTAS
                                                            * sizeof(TSHR_INT32))
                                      + ansiLen * (sizeof(TSHR_INT32) + 1)
                                      + 4),   // Allow for internal padding
                                      0);
            if (pOrder == NULL)
            {
                TRACE_OUT(( "Failed to alloc order"));
                DC_QUIT;
            }
            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;

            //
            // Set up the order type.
            //
            pExtTextOut->type = ORD_EXTTEXTOUT_TYPE;

            //
            // Get a pointer to the fields which are common to both TextOut
            // and ExtTextOut
            //
            pCommon           = &pExtTextOut->common;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown order %x", orderType));
            DC_QUIT;
        }
        break;
    }

    //
    // Fill in the fields which are common to both TextOut and ExtTextOut
    //
    // Convert to virtual coordinates
    //
    OELPtoVirtual(&startPoint, 1);

    //
    // The x and y values are available in virtual coords from the bounds
    // rectangle.
    //
    pCommon->nXStart = startPoint.x;
    pCommon->nYStart = startPoint.y;

    //
    // Get the text colours.
    //
    OEConvertColor(ppdev,
                   &pCommon->BackColor,
                   pboOpaque->iSolidColor,
                   NULL);
    OEConvertColor(ppdev,
                   &pCommon->ForeColor,
                   pboFore->iSolidColor,
                   NULL);

    //
    // The transparency of the operation is determined by whether we have
    // an opaque rectangle or not.
    //
    pCommon->BackMode    = (prclOpaque == NULL) ? TRANSPARENT : OPAQUE;

    //
    // NT has a character extra spacing, not a generic for every character
    // spacing.  So, we always set this value to 0.
    //
    pCommon->CharExtra   = 0;

    //
    // NT does not provide a break of any sorts.
    //
    pCommon->BreakExtra  = 0;
    pCommon->BreakCount  = 0;

    //
    // Copy the font details
    //
    pCommon->FontHeight  = fontHeight;
    pCommon->FontWidth   = fontWidth;
    pCommon->FontWeight  = fontWeight;
    pCommon->FontFlags   = fontFlags;
    pCommon->FontIndex   = fontIndex;

    //
    // Now fill in the order specific data
    //
    switch (orderType)
    {
        case ORD_TEXTOUT:

            //
            // Copy across the text string.
            //
            pTextOut->variableString.len = (BYTE)ansiLen;
            RtlCopyMemory(pTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "TEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pTextOut->common.nXStart,
                         pTextOut->common.nYStart,
                         pTextOut->common.BackMode,
                         pTextOut->common.ForeColor.red,
                         pTextOut->common.ForeColor.green,
                         pTextOut->common.ForeColor.blue,
                         pTextOut->common.BackColor.red,
                         pTextOut->common.BackColor.green,
                         pTextOut->common.BackColor.blue));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pTextOut->common.FontWidth,
                         pTextOut->common.FontHeight,
                         pTextOut->common.FontWeight,
                         pTextOut->common.FontFlags,
                         pTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        case ORD_EXTTEXTOUT:
            //
            // Since our text is only ever fully contained within the
            // opaque rectangle, we only set the opaque flag (and ignore
            // the clipping).
            //
            pExtTextOut->fuOptions = (prclOpaque == NULL) ? 0 : ETO_OPAQUE;

            //
            // Set up the bounding rectangle for the operation.
            // EXT_TEXT_OUT orders use TSHR_RECT32s, hence we can't directly
            // assign rectDst to it.
            //
            pExtTextOut->rectangle.left     = rectDst.left;
            pExtTextOut->rectangle.top      = rectDst.top;
            pExtTextOut->rectangle.right    = rectDst.right;
            pExtTextOut->rectangle.bottom   = rectDst.bottom;

            //
            // Copy across the text string.
            //
            pExtTextOut->variableString.len = ansiLen;
            RtlCopyMemory(pExtTextOut->variableString.string,
                          ansiString,
                          ansiLen);

            //
            // WHOOP WHOOP WHOOP - Prepare to shut your eyes...
            //
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we must not send the full
            // structure over the network as the text will only be, say, 10
            // characters while the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            lpVariable = ((LPBYTE)(&pExtTextOut->variableString))
                       + ansiLen
                       + sizeof(pExtTextOut->variableString.len);

            lpVariable = (LPSTR)
                         DC_ROUND_UP_4((UINT_PTR)lpVariable);

            lpDeltaPos = (LPVARIABLE_DELTAX)lpVariable;

            //
            // Do we need a delta array, or are the chars at their default
            // positions.
            //
            if ( sendDeltaX ||
                 ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) == 0) )
            {
                //
                // Store the length of the position deltas.
                //
                lpDeltaPos->len = ansiLen * sizeof(TSHR_INT32);

                //
                // Set up the position deltas.
                //
                STROBJ_vEnumStart(pstro);
                fMoreData    = TRUE;
                currentDelta = 0;
                while (fMoreData)
                {
                    //
                    // Get the next set of glyph data
                    //
                    fMoreData = STROBJ_bEnum(pstro, &count, &pGlyphData);
                    for (i = 0; i < count; i++)
                    {
                        //
                        // The first time through we must set up the first
                        // glyph position.
                        //
                        if ((currentDelta == 0) && (i == 0))
                        {
                            lastPtl.x = pGlyphData[0].ptl.x;
                            lastPtl.y = pGlyphData[0].ptl.y;

                            TRACE_OUT(( "First Pos %d", lastPtl.x));
                        }
                        else
                        {
                            //
                            // For subsequent entries, we need to add the
                            // delta on the X position to the array.
                            //
                            if (pstro->ulCharInc == 0)
                            {
                                 lpDeltaPos->deltaX[currentDelta]
                                                         = pGlyphData[i].ptl.x
                                                         - lastPtl.x;

                                //
                                // Check for delta Y's - which we can't
                                // encode
                                //
                                if (pGlyphData[i].ptl.y - lastPtl.y)
                                {
                                    WARNING_OUT(( "New Y %d",
                                                 pGlyphData[i].ptl.y));
                                    OA_DDFreeOrderMem(pOrder);
                                    DC_QUIT;
                                }

                                //
                                // Store the last position for the next
                                // time round.
                                //
                                lastPtl.x = pGlyphData[i].ptl.x;
                                lastPtl.y = pGlyphData[i].ptl.y;

                                TRACE_OUT(( "Next Pos %d %d", i, lastPtl.x));
                            }
                            else
                            {
                                lpDeltaPos->deltaX[currentDelta]
                                                           = pstro->ulCharInc;
                            }

                            currentDelta++;
                        }
                    }
                }

                //
                // For the last entry, we need to set up the data by hand
                // (there are only n-1 deltas for n chars)
                //
                // This is done for compatibility with Windows 95 which
                // requires the last delta to be the delta to the place
                // where the next char would be if there were n+1 chars in
                // the string.
                //
                if (pstro->ulCharInc == 0)
                {
                    //
                    // No characters left - fudge a value of the width of
                    // the last character.
                    //
                    lpDeltaPos->deltaX[currentDelta] =
                                 pGlyphData[count-1].pgdf->pgb->sizlBitmap.cx;
                }
                else
                {
                    //
                    // All chars are evenly spaced, so just stick the value
                    // in.
                    //
                    lpDeltaPos->deltaX[currentDelta] = pstro->ulCharInc;
                }

                //
                // WHOOP WHOOP WHOOP - You can open your eyes now...
                //

                //
                // We must indicate the presence of this field to the
                // receiver.
                //
                pExtTextOut->fuOptions |= ETO_LPDX;
            }
            else
            {
                //
                // Mark the delta array as empty.
                //
                lpDeltaPos->len = 0;
            }

            //
            // WHOOP WHOOP WHOOP - You can open your eyes now...
            //


            //
            // Make sure we send the order
            //
            fSendOrder = TRUE;

            TRACE_OUT(( "EXTTEXTOUT: X %u Y %u bm %u FC %02X%02X%02X "
                         "BC %02X%02X%02X",
                         pExtTextOut->common.nXStart,
                         pExtTextOut->common.nYStart,
                         pExtTextOut->common.BackMode,
                         pExtTextOut->common.ForeColor.red,
                         pExtTextOut->common.ForeColor.green,
                         pExtTextOut->common.ForeColor.blue,
                         pExtTextOut->common.BackColor.red,
                         pExtTextOut->common.BackColor.green,
                         pExtTextOut->common.BackColor.blue));

            TRACE_OUT(( "Extra: Opt %x X1 %d Y1 %d X2 %d Y2 %d",
                         pExtTextOut->fuOptions,
                         pExtTextOut->rectangle.left,
                         pExtTextOut->rectangle.top,
                         pExtTextOut->rectangle.right,
                         pExtTextOut->rectangle.bottom));

            TRACE_OUT(( "Font: fx %u fy %u fw %u ff %04x fh %u len %u",
                         pExtTextOut->common.FontWidth,
                         pExtTextOut->common.FontHeight,
                         pExtTextOut->common.FontWeight,
                         pExtTextOut->common.FontFlags,
                         pExtTextOut->common.FontIndex,
                         ansiLen));

            TRACE_OUT(( "String '%s'", ansiString));
            break;

        default:
            ERROR_OUT(( "Unknown order %x", orderType));
            break;
    }

DC_EXIT_POINT:
    //
    // If we did not send an order, we must accumulate the output in the
    // Screen Data Area.
    //
    if (fSendOrder)
    {
        //
        // Store the general order data.  The bounding rectangle position
        // must be in virtual desktop co-ordinates.  OELRtoVirtual has
        // already done this.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
        TSHR_RECT16_FROM_RECT(&pOrder->OrderHeader.Common.rcsDst, rectDst);

        //
        // Add the order to the cache.
        //
        OEClipAndAddOrder(pOrder, NULL, pco);
    }
    else
    {
        if (fAccumulate)
        {
            OEClipAndAddScreenData(&rectDst, pco);
        }
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvTextOut, rc);
    return(rc);
}


//
// DrvLineTo - see NT DDK documentation.
//
BOOL DrvLineTo(SURFOBJ   *pso,
                     CLIPOBJ   *pco,
                     BRUSHOBJ  *pbo,
                     LONG       x1,
                     LONG       y1,
                     LONG       x2,
                     LONG       y2,
                     RECTL     *prclBounds,
                     MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECT         rectDst;
    POINT           startPoint;
    POINT           endPoint;
    BOOL          fAccumulate = FALSE;

    DebugEntry(DrvLineTo);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclBounds));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert the data to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // Set up data for order
    //
    startPoint.x = x1;
    startPoint.y = y1;
    endPoint.x   = x2;
    endPoint.y   = y2;

    //
    // Store that order.
    //
    if (!OEAddLine(ppdev,
              &startPoint,
              &endPoint,
              &rectDst,
              mix & 0x1F,
              1,
              pbo->iSolidColor,
              pco))
    {
        TRACE_OUT(( "Failed to add order - use SDA"));
        DC_QUIT;
    }

    //
    // We have stored this object, so don't store the data in the SDA
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvLineTo, rc);
    return(rc);
}


//
// DrvStrokePath - see NT DDK documentation.
//
BOOL DrvStrokePath(SURFOBJ   *pso,
                         PATHOBJ   *ppo,
                         CLIPOBJ   *pco,
                         XFORMOBJ  *pxo,
                         BRUSHOBJ  *pbo,
                         POINTL    *pptlBrushOrg,
                         LINEATTRS *plineattrs,
                         MIX        mix)
{
    LPOSI_PDEV      ppdev = (LPOSI_PDEV)pso->dhpdev;
    BOOL           rc = TRUE;
    RECTFX         rectfxTrg;
    RECT         rectDst;
    BOOL           fMore = TRUE;
    PATHDATA       pathData;
    POINT        startPoint;
    POINT        nextPoint;
    POINT        endPoint;
    BOOL         fAccumulate = FALSE;
    UINT         i;

    DebugEntry(DrvStrokePath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Check if we are allowed to send this order (determined by the
    // negotiated capabilities of all the machines in the conference).
    //
    if (!OE_SendAsOrder(ORD_LINETO))
    {
        TRACE_OUT(( "LineTo order not allowed"));
        DC_QUIT;
    }

    //
    // Check for a valid brush for the test operation.
    //
    if (pbo->iSolidColor == -1)
    {
        TRACE_OUT(( "Bad brush for line"));
        DC_QUIT;
    }

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // See if we can optimize the path...
    //
    // We cannot send:
    //
    // - curvy lines (i.e. beziers)
    // - lines with funny end patterns (i.e. geometric lines)
    // - non Windows standard patterns
    //
    if ( ((ppo->fl        & PO_BEZIERS)   == 0) &&
         ((plineattrs->fl & LA_GEOMETRIC) == 0) &&
         (plineattrs->pstyle              == NULL) )
    {
        //
        // This is a set of solid cosmetic (i.e.  no fancy end styles)
        // lines.  Let's send those orders.
        //
        // NT stores all paths as a set of independent sub-paths.  Each
        // sub-path can start at a new point that is NOT linked to the
        // previous sub-path.
        //
        // Paths used for this function (as opposed to DrvFillPath or
        // DrvStrokeAndFillPath) do not need to be closed.
        //
        PATHOBJ_vEnumStart(ppo);

        while (fMore)
        {
            //
            // Get the next set of lines
            //
            fMore = PATHOBJ_bEnum(ppo, &pathData);

            TRACE_OUT(( "PTS: %lu FLAG: %08lx",
                         pathData.count,
                         pathData.flags));

            //
            // If this is the start of a path, remember the point in case
            // we need to close the path at the end.
            //
            if (pathData.flags & PD_BEGINSUBPATH)
            {
                POINT_FROM_POINTFIX(startPoint, pathData.pptfx[0]);
                POINT_FROM_POINTFIX(nextPoint,  pathData.pptfx[0]);
            }

            //
            // Generate orders for each line in the path.
            //
            for (i = 0; i < pathData.count; i++)
            {
                POINT_FROM_POINTFIX(endPoint, pathData.pptfx[i]);

                if ( (nextPoint.x != endPoint.x) ||
                     (nextPoint.y != endPoint.y) )
                {
                    if (!OEAddLine(ppdev,
                                   &nextPoint,
                                   &endPoint,
                                   &rectDst,
                                   mix & 0x1f,
                                   plineattrs->elWidth.l,
                                   pbo->iSolidColor,
                                   pco))
                    {
                        DC_QUIT;
                    }
                }

                nextPoint.x = endPoint.x;
                nextPoint.y = endPoint.y;
            }

            //
            // Close the path if necessary.
            //
            if ((pathData.flags & PD_CLOSEFIGURE) != 0)
            {
                if (!OEAddLine(ppdev,
                               &endPoint,
                               &startPoint,
                               &rectDst,
                               mix & 0x1f,
                               plineattrs->elWidth.l,
                               pbo->iSolidColor,
                               pco))
                {
                    DC_QUIT;
                }
            }
        }

        //
        // We have processed the entire thing as orders - don't send screen
        // data.
        //
        fAccumulate = FALSE;
    }

DC_EXIT_POINT:
    if (fAccumulate)
    {
        //
        // Convert the bounds to virtual coordinates.
        //
        OELRtoVirtual(&rectDst, 1);
        TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                     rectDst.left,
                     rectDst.top,
                     rectDst.right,
                     rectDst.bottom));

        //
        // Update the Screen Data Area
        //
        OEClipAndAddScreenData(&rectDst, pco);

    }
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokePath, rc);
    return(rc);
}


//
// DrvFillPath - see NT DDK documentation.
//
BOOL DrvFillPath(SURFOBJ  *pso,
                       PATHOBJ  *ppo,
                       CLIPOBJ  *pco,
                       BRUSHOBJ *pbo,
                       POINTL   *pptlBrushOrg,
                       MIX       mix,
                       FLONG     flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);
    TRACE_OUT(( "SDA: (%d,%d)(%d,%d)",
                 rectDst.left,
                 rectDst.top,
                 rectDst.right,
                 rectDst.bottom));

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvFillPath, rc);
    return(rc);
}


//
// DrvStrokeAndFillPath - see NT DDK documentation.
//
BOOL DrvStrokeAndFillPath(SURFOBJ   *pso,
                                PATHOBJ   *ppo,
                                CLIPOBJ   *pco,
                                XFORMOBJ  *pxo,
                                BRUSHOBJ  *pboStroke,
                                LINEATTRS *plineattrs,
                                BRUSHOBJ  *pboFill,
                                POINTL    *pptlBrushOrg,
                                MIX        mixFill,
                                FLONG      flOptions)
{
    BOOL    rc = TRUE;
    RECTFX  rectfxTrg;
    RECT  rectDst;

    DebugEntry(DrvStrokeAndFillPath);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    PATHOBJ_vGetBounds(ppo, &rectfxTrg);
    RECT_FROM_RECTFX(rectDst, rectfxTrg);

    //
    // Check if we are accumulating data for this function
    //
    if (!OEAccumulateOutput(pso, pco, &rectDst))
    {
        DC_QUIT;
    }

    //
    // Convert the bounds to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Update the Screen Data Area
    //
    OEClipAndAddScreenData(&rectDst, pco);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvStrokeAndFillPath, rc);
    return(rc);
}


//
// DrvPaint - see NT DDK documentation.
//
BOOL DrvPaint(SURFOBJ  *pso,
                    CLIPOBJ  *pco,
                    BRUSHOBJ *pbo,
                    POINTL   *pptlBrushOrg,
                    MIX       mix)
{
    BOOL    rc = TRUE;
    RECT  rectDst;
    BOOL  fAccumulate = FALSE;
    ROP4    rop4;

    DebugEntry(DrvPaint);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;


    OE_SHM_START_WRITING;


    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(pso, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

    //
    // Check for overcomplicated clipping.
    //
    if (OEClippingIsComplex(pco))
    {
        TRACE_OUT(( "Clipping is too complex"));
        DC_QUIT;
    }

    //
    // The low byte of the mix represents a ROP2.  We need a ROP4 for
    // BitBlt, so convert the mix as follows.
    //
    // Remember the definitions of 2, 3 & 4 way ROP codes.
    //
    //  Msk Pat Src Dst
    //
    //  1   1   1   1             ROP2 uses P & D only
    //  1   1   1   0                  
    //  1   1   0   1                         ROP3 uses P, S & D
    //  1   1   0   0     ROP2-1ROP3  ROP4
    //  1   0   1   1     (see                 ROP4 uses M, P, S & D
    //  1   0   1   0     note)      
    //  1   0   0   1                  
    //  1   0   0   0          
    //  0   1   1   1                   
    //  0   1   1   0                            NOTE: Windows defines its
    //  0   1   0   1                            ROP2 codes as the bitwise
    //  0   1   0   0                            value calculated here
    //  0   0   1   1                            plus one.  All other ROP
    //  0   0   1   0                            codes are the straight
    //  0   0   0   1                            bitwise value.
    //  0   0   0   0    
    //
    // Or, algorithmically...
    //
    // ROP3 = (ROP2 & 0x3) | ((ROP2 & 0xC) << 4) | (ROP2 << 2)
    //
    // ROP4 = (ROP3 << 8) | ROP3
    //
    mix  = (mix & 0x1F) - 1;
    rop4 = (mix & 0x3) | ((mix & 0xC) << 4) | (mix << 2);
    rop4 = (rop4 << 8) | rop4;

    //
    // This can be passed on to the BitBlt code.
    //
    rc = DrvBitBlt( pso,
                    NULL,
                    NULL,
                    pco,
                    NULL,
                    &pco->rclBounds,
                    NULL,
                    NULL,
                    pbo,
                    pptlBrushOrg,
                    rop4 );

    //
    // We have stored this object in the BitBlt, so don't store the data
    // again.
    //
    fAccumulate = FALSE;

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitDWORD(DrvPaint, rc);
    return(rc);
}


//
// OE_DDProcessRequest - see oe.h
//
ULONG OE_DDProcessRequest
(
    SURFOBJ* pso,
    UINT    cjIn,
    void *  pvIn,
    UINT    cjOut,
    void *  pvOut
)
{
    BOOL                    rc = TRUE;
    LPOSI_ESCAPE_HEADER      pHeader;

    DebugEntry(OE_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OE_ESC_NEW_FONTS:
        {
            if ((cjIn != sizeof(OE_NEW_FONTS)) ||
                (cjOut != sizeof(OE_NEW_FONTS)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_FONTS",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Get new local font data
            //
            OEDDSetNewFonts(pvIn);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            if ((cjIn != sizeof(OE_NEW_CAPABILITIES)) ||
                (cjOut != sizeof(OE_NEW_CAPABILITIES)))
            {
                ERROR_OUT(("OE_DDProcessRequest:  Invalid sizes %d, %d for OE_ESC_NEW_CAPABILITIES",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // The capabilities have changed - take the new copy.
            //
            OEDDSetNewCapabilities(pvIn);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised OE escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(OE_DDProcessRequest, rc);
    return((ULONG)rc);
}


//
// OE_DDTerm()
// This cleans up objects used
//
void OE_DDTerm(void)
{
    DebugEntry(OE_DDTerm);

    //
    // Free font list
    //
    if (g_poeLocalFonts)
    {
        TRACE_OUT(("OE_DDLocalHosting: freeing font block since we're done sharing"));
        EngFreeMem(g_poeLocalFonts);

        g_poeLocalFonts = NULL;
        g_oeNumFonts = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// DrvRealizeBrush - see NT DDK documentation.
//
BOOL DrvRealizeBrush(BRUSHOBJ *pbo,
                           SURFOBJ  *psoTarget,
                           SURFOBJ  *psoPattern,
                           SURFOBJ  *psoMask,
                           XLATEOBJ *pxlo,
                           ULONG    iHatch)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)psoTarget->dhpdev;
    BOOL      rc    = TRUE;
    LPBYTE  pData;
    BYTE   brushBits[8];
    UINT  color1;
    UINT  color2;
    int     i;
    int     j;
    BOOL    monochromeBrush = TRUE;

    DebugEntry(DrvRealizeBrush);

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Since this function is called only when we call BRUSHOBJ_pvGetRBrush
    // and we don't do any processing until we are in a share we don't need
    // an explicit check for hosting here ('coz that happened before the
    // call to realise the brush).
    //

    //
    // A valid brush satisfies either of the following criteria.
    //
    //  1) It is a standard hatch brush (as passed by DrvEnablePDEV)
    //  2) It is an 8x8 monochrome bitmap
    //

    //
    // Check for a Windows standard hatch
    //
    if (iHatch < HS_DDI_MAX)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_HATCHED,
                          NULL,
                          pxlo,
                          (BYTE)iHatch,
                          0,
                          1);
        DC_QUIT;
    }

    //
    // If the driver has been passed a dither color brush we can support
    // this by sending a solid color brush definition
    //
    if ((iHatch & RB_DITHERCOLOR) != 0)
    {
        TRACE_OUT(( "Standard hatch %lu", iHatch));
        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_SOLID,
                          NULL,
                          NULL,
                          (BYTE)iHatch,
                          iHatch & 0xFFFFFF,
                          0);
        DC_QUIT;
    }


    //
    // Check for a simple 8x8 brush
    //
    if ( (psoPattern->sizlBitmap.cx == 8) &&
         (psoPattern->sizlBitmap.cy == 8) )
    {
        //
        // Check for 2 colours only in the bitmap.
        //
        // NOTE: There's a flag (BMF_TOPDOWN) in psoPattern->fjBitmap
        // that's supposed to indicate whether the bitmap is top-down or
        // bottom-up, but it is not always set up correctly.  In fact, the
        // bitmaps are always the wrong way up for our protocol, so we have
        // to flip them regardless of the flag.  Hence the row numbers are
        // reversed ('i' loops) in all the conversions below.
        //
        pData = psoPattern->pvScan0;
        switch (psoPattern->iBitmapFormat)
        {
            case BMF_1BPP:
            {
                //
                // 1 bpp MUST be 2 colours maximum.
                //
                color1 = 1;
                color2 = 0;
                for (i = 7; i >= 0; i--)
                {
                    brushBits[i] = *pData;
                    pData       += psoPattern->lDelta;
                }
            }
            break;

            case BMF_4BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0] & 15;
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 4bpp->2 pixels per byte
                    //
                    for (j = 0; (j < 4) && (monochromeBrush); j++)
                    {
                        //
                        // Check the 1st pixel color
                        //
                        if ( (color1 != (UINT)(pData[j] & 0x0F)) &&
                             (color2 != (UINT)(pData[j] & 0x0F)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0x0F);
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Check the 2nd pixel color
                        //
                        if ( (color1 != (UINT)((pData[j] & 0xF0) >> 4)) &&
                             (color2 != (UINT)((pData[j] & 0xF0) >> 4)) )
                        {
                            if (color1 == color2)
                            {
                                color2 = (pData[j] & 0xF0) >> 4;
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Set up the brush data.  High bit is leftmost.
                        //
                        if ((UINT)(pData[j] & 0x0F) == color1)
                        {
                            brushBits[i] |= 0x40 >> (j * 2);
                        }
                        if ((UINT)(pData[j] & 0xF0) >> 4  == color1)
                        {
                            brushBits[i] |= 0x80 >> (j * 2);
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            case BMF_8BPP:
            {
                //
                // See if it is really a 2 colour brush.  Start off with
                // both colours the same.
                //
                color1 = pData[0];
                color2 = color1;

                //
                // Iterate through each row of the bitmap.
                //
                for (i = 7; (i >= 0) && (monochromeBrush); i--)
                {
                    brushBits[i] = 0;

                    //
                    // Check each pixel in the row: 8bpp->1 pixel per byte
                    //
                    for (j = 0; (j < 8) && (monochromeBrush); j++)
                    {
                        //
                        // Check each pixel.
                        //
                        if ( (color1 != pData[j]) &&
                             (color2 != pData[j]) )
                        {
                            if (color1 == color2)
                            {
                                color2 = pData[j];
                            }
                            else
                            {
                                monochromeBrush = FALSE;
                            }
                        }

                        //
                        // Update the brush data.  High bit is leftmost.
                        //
                        if (pData[j] == color1)
                        {
                           brushBits[i] |= 0x80 >> j;
                        }
                    }

                    //
                    // Get start of next row.
                    //
                    pData += psoPattern->lDelta;
                }
            }
            break;

            default:
            {
                //
                // Unsupported colour depth.
                //
                monochromeBrush = FALSE;
            }
            break;
        }
    }
    else
    {
        //
        // The brush is the wrong size or requires dithering and so cannot
        // be sent over the wire.
        //
        monochromeBrush = FALSE;
    }

    //
    // Store that brush.
    //
    if (monochromeBrush)
    {
        //
        // Store the brush - note that we have a monochrome brush where the
        // color bit is set up so that 0 = color2 and 1 = color1.  This
        // actually corresponds to 0 = fg and 1 = bg for the protocol
        // colors.
        //
        TRACE_OUT(( "Storing brush: type %d bg %x fg %x",
                     psoPattern->iBitmapFormat,
                     color1,
                     color2));

        rc = OEStoreBrush(ppdev,
                          pbo,
                          BS_PATTERN,
                          brushBits,
                          pxlo,
                          0,
                          color2,
                          color1);
    }
    else
    {
        TRACE_OUT(( "Rejected brush h %08lx s (%ld, %ld) fmt %lu",
                     iHatch,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cx : 0,
                     psoPattern != NULL ? psoPattern->sizlBitmap.cy : 0,
                     psoPattern != NULL ? psoPattern->iBitmapFormat : 0));
        rc = OEStoreBrush(ppdev, pbo, BS_NULL, NULL, pxlo, 0, 0, 0);
    }

DC_EXIT_POINT:

    DebugExitDWORD(DrvRealizeBrush, rc);
    return(rc);
}


//
// DrvSaveScreenBits - see NT DDK documentation.
//
ULONG_PTR DrvSaveScreenBits(SURFOBJ *pso,
                              ULONG    iMode,
                              ULONG_PTR    ident,
                              RECTL   *prcl)
{
    BOOL    rc;
    UINT  ourMode;
    RECT  rectDst;

    DebugEntry(DrvSaveScreenBits);

    TRACE_OUT(("DrvSaveScreenBits:  %s",
        ((iMode == SS_SAVE) ? "SAVE" :
            ((iMode == SS_RESTORE) ? "RESTORE" : "DISCARD"))));
    TRACE_OUT(("      rect        {%04ld, %04ld, %04ld, %04ld}",
        prcl->left, prcl->top, prcl->right, prcl->bottom));
    //
    // Default is TRUE, let SaveBits happen if we don't care.  Which we don't
    // if we have no shared memory (NetMeeting isn't running), no window list
    // (no shared apps), or the operation isn't intersecting a window we
    // care about.
    //
    // Note that if we return TRUE on a save, and FALSE on a restore later
    // (because we are now sharing that area for example), USER+GRE handle
    // that.  So it's ok.
    //
    rc = TRUE;

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    //
    // If we have no shared memory (NetMeeting isn't running), this will bail
    // out immediately.
    //

    OE_SHM_START_WRITING;


    //
    // Get the bounding rectangle for the operation.  NOTE that this is
    // meaningless for SS_FREE.
    //
    RECT_FROM_RECTL(rectDst, (*prcl));
    if (iMode != SS_FREE)
    {
        //
        // Check if we are accumulating data for this area, ONLY FOR
        // SAVEs.  We may get notified after a window is gone to
        // restore or discard bits we had saved.
        //
        if (!OEAccumulateOutputRect(pso, &rectDst))
        {
            TRACE_OUT(("DrvSaveScreenBits:  save/restore in area we don't care about"));
            DC_QUIT;
        }
    }

    //
    // Convert the NT orders to our generic save/restore types.
    //
    switch (iMode)
    {
        case SS_SAVE:
        {
            ourMode = ONBOARD_SAVE;
        }
        break;

        case SS_RESTORE:
        {
            ourMode = ONBOARD_RESTORE;
        }
        break;

        case SS_FREE:
        {
            ourMode = ONBOARD_DISCARD;
        }
        break;

        default:
        {
            ERROR_OUT(( "Unknown type %lu", iMode));
            DC_QUIT;
        }
    }

    //
    // Call through to the SSI handler.
    //
    rc = SSI_SaveScreenBitmap(&rectDst, ourMode);

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    TRACE_OUT(("DrvSaveScreenBits returning %d", rc));
    DebugExitDWORD(DrvSaveScreenBits, rc);
    return(rc);
}



//
// Function:    OEUnicodeStrlen
//
// Description: Get the length of a unicode string in bytes.
//
// Parameters:  pString - Unicode string to be read
//
// Returns:     Length of the Unicode string in bytes
//
int  OEUnicodeStrlen(PWSTR pString)
{
    int i;

    for (i = 0; pString[i] != 0; i++)
        ;

    return((i + 1) * sizeof(WCHAR));
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
//
void  OEExpandColor
(
    LPBYTE  lpField,
    ULONG   srcColor,
    ULONG   mask
)
{
    ULONG   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, *lpField));

    DebugExitVOID(OEExpandColor);
}


//
// Function:    OEConvertColor
//
// Description: Convert a color from the NT Display Driver into a TSHR_COLOR
//
// Parameters:  pDCColor  - (returned) color in protocol format
//              osColor   - color from the NT display driver
//              pxlo      - XLATEOBJ for the color to be converted
//                          (NULL if no translation is required)
//
// Returns:     (none)
//
void  OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pTshrColor,
                                         ULONG     osColor,
                                         XLATEOBJ* pxlo)
{
    ULONG    realIndex;

    DebugEntry(OEConvertColor);

    //
    // Make sure we have a default setting.
    //
    RtlFillMemory(pTshrColor, sizeof(TSHR_COLOR), 0);

    //
    // Check if color translation is required.
    //
    if ((pxlo != NULL) && (pxlo->flXlate != XO_TRIVIAL))
    {
        //
        // Convert from BMP to device color.
        //
        realIndex = XLATEOBJ_iXlate(pxlo, osColor);
        if (realIndex == -1)
        {
            ERROR_OUT(( "Failed to convert color 0x%lx", osColor));
            DC_QUIT;
        }
    }
    else
    {
        //
        // Use the OS color without translation
        //
        realIndex = osColor;
    }

    TRACE_OUT(( "Device color 0x%lX", realIndex));

    //
    // We now have the device specific version of the color.  Time to
    // convert it into a 24-bit RGB color as used by the line protocol.
    //
    switch (ppdev->iBitmapFormat)
    {
        case BMF_1BPP:
        case BMF_4BPP:
        case BMF_4RLE:
        case BMF_8BPP:
        case BMF_8RLE:
            //
            // Palette type device - use the device color as an index into
            // our palette array.
            //
            pTshrColor->red  = (BYTE)ppdev->pPal[realIndex].peRed;
            pTshrColor->green= (BYTE)ppdev->pPal[realIndex].peGreen;
            pTshrColor->blue = (BYTE)ppdev->pPal[realIndex].peBlue;
            break;

        case BMF_16BPP:
        case BMF_24BPP:
        case BMF_32BPP:
            //
            // Generic colour masks (could be eg.  5-6-5 for 16 or 8-8-8
            // for 24 bits per pel).  We must mask off the other bits and
            // shift down to bit 0.
            //
            OEExpandColor(&(pTshrColor->red),
                          realIndex,
                          ppdev->flRed);

            OEExpandColor(&(pTshrColor->green),
                          realIndex,
                          ppdev->flGreen);

            OEExpandColor(&(pTshrColor->blue),
                          realIndex,
                          ppdev->flBlue);
            break;

        default:
            ERROR_OUT(( "Unrecognised BMP color depth %lu",
                                                       ppdev->iBitmapFormat));
            break;
    }

    TRACE_OUT(( "Red %x green %x blue %x", pTshrColor->red,
                                            pTshrColor->green,
                                            pTshrColor->blue));

DC_EXIT_POINT:
    DebugExitVOID(OEConvertColor);
}


//
// Function:    OEStoreBrush
//
// Description: Store the brush data required for pattern realted orders.
//              This function is called by DrvRealiseBrush when it has data
//              to be stored about a brush.
//
// Parameters:  pbo        - BRUSHOBJ of the brush to be stored
//              style      - Style of the brush (as defined in the DC-Share
//                           protocol)
//              pBits      - Pointer to the bits which are used to define
//                           a BS_PATTERN brush.
//              pxlo       - XLATEOBJ for the brush.
//              hatch      - Standard Windows hatch pattern index for a
//                           BS_HATCHED brush.
//              color1     - index into XLATEOBJ for bit set color
//                           OR exact 24bpp color to use (pxlo == NULL)
//              color2     - index into XLATEOBJ for bit clear color
//                           OR exact 24bpp color to use (pxlo == NULL)
//
// Returns:     (none)
//
BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                       BRUSHOBJ* pbo,
                                       BYTE   style,
                                       LPBYTE  pBits,
                                       XLATEOBJ* pxlo,
                                       BYTE   hatch,
                                       UINT  color1,
                                       UINT  color2)
{
    BOOL         rc = FALSE;
    int          i;
    LPBYTE       pData;
    ULONG*         pColorTable;
    POE_BRUSH_DATA pBrush;

    DebugEntry(OEStoreBrush);

    //
    // Allocate the space for the brush data.
    //
    pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvAllocRbrush(pbo,
                                                    sizeof(OE_BRUSH_DATA));
    if (pBrush == NULL)
    {
        ERROR_OUT(( "No memory"));
        DC_QUIT;
    }

    //
    // Reset the brush definition
    //
    RtlFillMemory(pBrush, sizeof(OE_BRUSH_DATA), 0);

    //
    // Set the new brush data.
    //
    pBrush->style = style;
    pBrush->hatch = hatch;

    TRACE_OUT(( " Style: %d Hatch: %d", style, hatch));

    //
    // For pattern brushes, copy the brush specific data.
    //
    if (style == BS_PATTERN)
    {
        //
        // Copy the brush bits.  Since this is an 8x8 mono bitmap, we can
        // copy the first byte of the brush data for each scan line.
        //
        // NOTE however that the brush structures sent over the wire
        // re-use the hatching variable as the first byte of the brush data.
        //
        pData         = pBits;
        pBrush->hatch = *pData;
        TRACE_OUT(( " Hatch: %d", *pData));

        pData++;

        for (i = 0; i < 7; i++)
        {
            pBrush->brushData[i] = pData[i];
            TRACE_OUT(( " Data[%d]: %d", i, pData[i]));
        }

        //
        // Get pointer to the bitmap color table.
        //
        pColorTable = pxlo->pulXlate;
        if (pColorTable == NULL)
        {
            pColorTable = XLATEOBJ_piVector(pxlo);
        }
    }

    //
    // Store the foreground and background colours for the brush.
    //
    if (pxlo != NULL)
    {
        //
        // Conversion required.
        //
        OEConvertColor(ppdev,
                       &pBrush->fore,
                       color1,
                       pxlo);

        OEConvertColor(ppdev,
                       &pBrush->back,
                       color2,
                       pxlo);
    }
    else
    {
        //
        // We have been passed an exact 24bpp color - this only happens for
        // solid brushes so we don't need to convert color2.
        //
        pBrush->fore.red   = (BYTE) (color1 & 0x0000FF);
        pBrush->fore.green = (BYTE)((color1 & 0x00FF00) >> 8);
        pBrush->fore.blue  = (BYTE)((color1 & 0xFF0000) >> 16);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEStoreBrush, rc);
    return(rc);
}


//
// Function:    OECheckBrushIsSimple
//
// Description: Check that the brush is a 'simple' object we can transfer
//              over the DC-Share protocol.
//
// Parameters:  pbo - BRUSHOBJ of the brush to be checked.
//
// Returns:     TRUE  - brush can be sent as DC-Share order
//              FALSE - brush is too complicated.
//
BOOL  OECheckBrushIsSimple(LPOSI_PDEV       ppdev,
                                               BRUSHOBJ*       pbo,
                                               POE_BRUSH_DATA* ppBrush)
{
    BOOL         rc     = FALSE;
    POE_BRUSH_DATA pBrush = NULL;

    DebugEntry(OECheckBrushIsSimple);

    //
    // A 'simple' brush satisfies any of the following.
    //
    //  1) It is a solid color.
    //  2) It is a valid brush as stored by DrvRealizeBrush.
    //

    //
    // Check for a simple solid colour.
    //
    if (pbo->iSolidColor != -1)
    {
        //
        // Use the reserved brush definition to set up the solid colour.
        //
        TRACE_OUT(( "Simple solid colour %08lx", pbo->iSolidColor));
        pBrush = &g_oeBrushData;

        //
        // Set up the specific data for this brush.
        //
        OEConvertColor(ppdev, &pBrush->fore, pbo->iSolidColor, NULL);

        pBrush->back.red   = 0;
        pBrush->back.green = 0;
        pBrush->back.blue  = 0;

        pBrush->style      = BS_SOLID;
        pBrush->hatch      = 0;

        RtlFillMemory(pBrush->brushData, 7, 0);

        //
        // We have a valid brush - return true.
        //
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Check brush definition (which was stored when we realized the
    // brush).
    //
    pBrush = (POE_BRUSH_DATA)pbo->pvRbrush;
    if (pBrush == NULL)
    {
        pBrush = (POE_BRUSH_DATA)BRUSHOBJ_pvGetRbrush(pbo);
        if (pBrush == NULL)
        {
            //
            // We can get NULL returned from BRUSHOBJ_pvGetRbrush when the
            // brush is NULL or in low-memory situations (when the brush
            // realization may fail).
            //
            TRACE_OUT(( "NULL returned from BRUSHOBJ_pvGetRbrush"));
            DC_QUIT;
        }
    }

    //
    // Check it is an encodable brush.
    //
    if (pBrush->style == BS_NULL)
    {
        TRACE_OUT(( "Complex brush"));
        DC_QUIT;
    }

    //
    // Evrything passed - let's use this brush.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return the brush definition
    //
    *ppBrush = pBrush;

    TRACE_OUT(( "Returning %d - 0x%08lx", rc, pBrush));

    DebugExitDWORD(OECheckBrushIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsSimple
//
// Description: Check to see if the clipping on the graphics object is
//              trivial
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is trivial
//              FALSE - Clipping is complex
//
BOOL  OEClippingIsSimple(CLIPOBJ* pco)
{
    BOOL rc = TRUE;

    DebugEntry(OEClippingIsSimple);

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial (ignore clipping) or simple (one square) clipping -
            // no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        default:
            TRACE_OUT(( "Clipping is complex"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    rc = FALSE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsSimple, rc);
    return(rc);
}


//
// Function:    OEClippingIsComplex
//
// Description: Check to see if the clipping on the graphics object is too
//              complicated to be sent as an order or multiple orders.
//
// Parameters:  pco - CLIPOBJ of the graphics object to be checked.
//
// Returns:     TRUE  - Clipping is too complicated
//              FALSE - Clipping is sufficiently simple to send as orders
//
BOOL  OEClippingIsComplex(CLIPOBJ* pco)
{
    BOOL       rc         = FALSE;
    BOOL       fMoreRects;
    OE_ENUMRECTS clip;
    UINT       numRects = 0;

    DebugEntry(OEClippingIsComplex);

    //
    // If the any of the following are true, the clipping is not too
    // complicated.
    //
    //  1) The clip object does not exist.
    //  2) The clipping is trivial (the object exists, but there are no
    //     clipping rectangles).
    //  3) The clipping is a single rectangle.
    //  4) The object enumerates to less than 'n' rectangles.
    //

    //
    // Check for a valid clip object
    //
    if (pco == NULL)
    {
        TRACE_OUT(( "No clipobj"));
        DC_QUIT;
    }

    //
    // Check for complexity of clipping
    //
    switch (pco->iDComplexity)
    {
        case DC_TRIVIAL:
        case DC_RECT:
            //
            // Trivial or simple clipping - no worries.
            //
            TRACE_OUT(( "Simple clipping"));
            DC_QUIT;

        case DC_COMPLEX:
            //
            // Lots of rectangles - make sure that it is less than the
            // acceptable limit.
            // The documentation for this function incorrectly states that
            // the returned value is the total number of rectangles
            // comprising the clip region. In fact, -1 is always returned,
            // even when the final parameter is non-zero. This means we
            // have to enumerate to get the number of rects.
            //
            CLIPOBJ_cEnumStart(pco,
                               FALSE,
                               CT_RECTANGLES,
                               CD_ANY,
                               0);

            //
            // MSDN: It is possible for CLIPOBJ_bEnum to return TRUE with
            // the number of clipping rectangles equal to zero. In such
            // cases, the driver should call CLIPOBJ_bEnum again without
            // taking any action. Get as many rectangles as we permit for
            // order encoding - this loop should execute once only.
            // If the number of rects equals COMPLEX_CLIP_RECT_COUNT the
            // 1st invocation of CLIPOBJ_bEnum returns that there are more
            // rects and a second call returns there are no more without
            // returning any in addition to those returned on the first
            // call. Our buffer has space for COMPLEX_CLIP_RECT_COUNT+1
            // rects so we should never have to execute the loop more than
            // once.
            //
            do
            {
                fMoreRects = CLIPOBJ_bEnum(pco,
                                           sizeof(clip),
                                           (ULONG *)&clip.rects);
                numRects += clip.rects.c;
            } while ( fMoreRects && (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // If there are no more rectangles in the clip region then the
            // clipping complexity is within our limits for order encoding.
            //
            if ( numRects <= COMPLEX_CLIP_RECT_COUNT )
            {
                TRACE_OUT(( "Acceptable clipping %u", numRects));
                DC_QUIT;
            }
            break;

        default:
            ERROR_OUT(( "Unknown clipping"));
            break;
    }

    //
    // Failed all tests - must be too complicated.
    //
    TRACE_OUT(( "Complex clipping"));
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEClippingIsComplex, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutput
//
// Description: Check to see if we should accumulate this output for
//              sending to the remote machine.
//
// Parameters:  pso   - Pointer to the target surface
//              pco   - Pointer to the clip object (may be NULL)
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect)
{
    BOOL    rc = FALSE;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutput);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OEAccumulateOutput, rc);
    return(rc);
}


//
// Function:    OEAccumulateOutputRect
//
// Description: Check to see if we should accumulate the given output rect
//              for sending to the remote machine.
//
//              Most drawing functions will use OEAccumulateOutput, which
//              just checks for a single point within the hosted area.
//              This function checks for any part of the given rectangle
//              intersecting with the hosted area.  It is currently only
//              used by DrvSaveScreenBitmap - operations which may not
//              lie completetely within the hosted area.
//
// Parameters:  pso   - Pointer to the target surface
//              pRect - Pointer to the bounding rectangle of the operation
//
// Returns:     TRUE  - We should accumulate the output
//              FALSE - ignore the output
//
BOOL   OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect)
{
    BOOL    rc = FALSE;
    LPOSI_PDEV ppdev = ((LPOSI_PDEV)pso->dhpdev);

    DebugEntry(OEAccumulateOutputRect);

    //
    // Validate we have valid parameters to access the surface.
    //
    if (ppdev == NULL)
    {
        TRACE_OUT(( "NULL PDEV"));
        DC_QUIT;
    }

    //
    // Check for the screen surface, which will be a bitmap in the hosting
    // only code.
    //
    if (ppdev->hsurfScreen != pso->hsurf)
    {
        TRACE_OUT(( "Dest is not our surface"));
        DC_QUIT;
    }

    if (pso->dhsurf == NULL)
    {
        ERROR_OUT(( "NULL hSurf"));
        DC_QUIT;
    }

    //
    // Check if we are accumulating this window.
    //
    rc = TRUE;

DC_EXIT_POINT:
    TRACE_OUT(("OEAccumulateOutputRect:  rect {%d, %d, %d, %d} is %sshared",
        pRect->left, pRect->top, pRect->right, pRect->bottom,
        (rc ? "" : "NOT ")));
    DebugExitBOOL(OEAccumulateOutputRect, rc);
    return(rc);
}


//
// Function:    OESendRop3AsOrder
//
// Description: Check if we are allowed to send this 3-way ROP.  A ROP may
//              be disallowed if it relies on the destination data.
//
// Parameters:  rop3 - the 3-way ROP to be checked.
//
// Returns:     TRUE  - We are allowed to send this ROP
//              FALSE - We can't send this ROP
//
BOOL  OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        TRACE_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}




//
// Function:    OECheckFontIsSupported
//
// Description: Check if we are allowed to send this font.  Fonts are
//              disallowed while they are being negotiated on a new entry
//              to the share.
//
// Parameters:  pfo           - (IN)  the font to be checked
//              pFontText     - (IN)  text message to be sent
//              textLen       - (IN)  length of text message
//              pFontHeight   - (OUT) font height in points
//              pFontAscender - (OUT) font ascender in points
//              pFontWidth    - (OUT) ave font width in points
//              pFontWeight   - (OUT) font weight
//              pFontFlags    - (OUT) font style flags
//              pFontIndex    - (OUT) font table index
//              pSendDeltaX   - (OUT) Do we need to send delta X coords?
//
// Returns:     TRUE  - We are allowed to send this font
//              FALSE - We can't send this font
//
BOOL   OECheckFontIsSupported
(
    FONTOBJ*    pfo,
    LPSTR       pFontText,
    UINT        textLen,
    LPUINT      pFontHeight,
    LPUINT      pFontAscender,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL            rc = FALSE;
    PIFIMETRICS     pFontMetrics;
    UINT            codePage;
    UINT            i;
    UINT            iLocal;
    UINT            matchQuality;
    UINT            charWidthAdjustment = 0;
    char            fontName[FH_FACESIZE];
    ULONG           fontNameLen;
    PWSTR           pUnicodeString;
    XFORMOBJ*       pxform;
    POINTL          xformSize[3];
    int             compareResult;
    FLOATOBJ_XFORM  xformFloatData;

    DebugEntry(OECheckFontIsSupported);

    //
    // Set up default return values
    //
    *pSendDeltaX = FALSE;

    //
    // Check that we have a valid list of font data from the remotes.
    //
    if (!g_oeTextEnabled)
    {
        TRACE_OUT(( "Fonts unavailable"));
        DC_QUIT;
    }

    //
    // Check for valid font attributes
    //
    pFontMetrics = FONTOBJ_pifi(pfo);
    if (pFontMetrics->fsSelection & FM_SEL_OUTLINED)
    {
        TRACE_OUT(( "Unsupported font style"));
        DC_QUIT;
    }

    //
    // The current protocol cannot apply a general 2-D transform to text
    // orders, so we must reject any weird ones such as:
    //
    // - rotations
    // - X or Y shears
    // - X or Y reflections
    // - scaling with a negative value.
    //
    // Or put another way, we only allow:
    //
    // - the identity transformation
    // - scaling with a positive value.
    //
    pxform = FONTOBJ_pxoGetXform(pfo);
    if (pxform != NULL)
    {
        //
        // Get the details of the transformation.  Note we can ignore the
        // translation vector as it does not affect the font sizing /
        // orientation, so we are only interested in the matrix values...
        //

        //
        // NOTE:  Do NOT use floating point explicitly!
        // Can't do float ops in ring 0 with normal lib for x86.
        // Use FLOATOBJs instead and corresponding Eng services.
        // On alpha, these are macros and are way fast in any case.
        //

        if (XFORMOBJ_iGetFloatObjXform(pxform, &xformFloatData) != DDI_ERROR)
        {
            //
            // Rotations and shears will have cross dependencies on the x
            // and y components.
            //
            if ( (!FLOATOBJ_EqualLong(&xformFloatData.eM12, 0)) ||
                 (!FLOATOBJ_EqualLong(&xformFloatData.eM21, 0)) )
            {
                TRACE_OUT(( "Rejected rotn/shear"));
                DC_QUIT;
            }

            //
            // Reflections and scaling operations with negative scale
            // factors will have negative values on the leading diagonal of
            // the matrix.
            //
            if ( (FLOATOBJ_LessThanLong(&xformFloatData.eM11, 0)) ||
                 (FLOATOBJ_LessThanLong(&xformFloatData.eM22, 0)) )
            {
                TRACE_OUT(( "Rejected refln/-ive"));
                DC_QUIT;
            }
        }
    }

    //
    // Get the current font code page for font matching.
    //
    switch (pFontMetrics->jWinCharSet)
    {
        case ANSI_CHARSET:
            TRACE_OUT(( "ANSI font"));
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            TRACE_OUT(( "OEM font"));
            codePage = NF_CP_WIN_OEM;
            break;

        case SYMBOL_CHARSET:
            TRACE_OUT(("Symbol font"));
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            TRACE_OUT(( "Unknown CP %d", pFontMetrics->jWinCharSet));
            codePage = NF_CP_UNKNOWN;
            break;
    }

    //
    // Get the name of the font.
    //
    pUnicodeString = (PWSTR)( (LPBYTE)pFontMetrics +
                                        pFontMetrics->dpwszFamilyName );
    EngUnicodeToMultiByteN(fontName,
                           sizeof(fontName),
                           &fontNameLen,
                           pUnicodeString,
                           OEUnicodeStrlen(pUnicodeString));

    //
    // Search our Font Alias Table for the current family name.  If we find
    // it, replace it with the alias name from the table.
    //
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!strcmp((LPSTR)fontName,
                        (LPSTR)(fontAliasTable[i].pszOriginalFontName)))
        {
            TRACE_OUT(( "Alias name: %s -> %s",
                              (LPSTR)fontName,
                              (LPSTR)(fontAliasTable[i].pszAliasFontName)));
            strcpy((LPSTR)fontName,
                   (LPSTR)(fontAliasTable[i].pszAliasFontName));
            charWidthAdjustment = fontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    TRACE_OUT(( "Font name: '%s'", fontName));

    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same character as this font.  If this index
    // slot is empty (i.e.  has a value of USHRT_MAX) then the loop will
    // immediately exit
    //
    TRACE_OUT(( "Looking for matching fonts"));

    for (iLocal = g_oeLocalFontIndex[(BYTE)fontName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        TRACE_OUT(( "Trying font number %hd", iLocal));

        //
        // If this font is not supported remotely then skip it.
        //
        ASSERT(g_poeLocalFonts);
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // See if we've got a facename match
        //
        compareResult =
                 strcmp(g_poeLocalFonts[iLocal].Details.nfFaceName, fontName);

        if (compareResult < 0)
        {
            //
            // We haven't found a match yet, but we haven't gone far enough
            // into this list.
            //
            continue;
        }
        else if (compareResult > 0)
        {
            //
            // We're past the part of the local font array that's applicable.
            // We didn't find a match, it must not exist.
            //
            break;
        }

        //
        // The font names match.  Now see if the other attributes do...
        //

        //
        // This is looking promising - a font with the right name is
        // supported on the remote system.
        //
        // Start building up the details in the global variables while
        // making further checks...
        //
        *pFontFlags  = 0;
        *pFontIndex = iLocal;
        *pFontWeight = pFontMetrics->usWinWeight;

        //
        // Check for a fixed pitch font.
        //
        if ((pFontMetrics->jWinPitchAndFamily & FIXED_PITCH) != 0)
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Is it a TrueType font?
        //
        if ((pfo->flFontType & TRUETYPE_FONTTYPE) != 0)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Get the basic width and height.
        //
        xformSize[0].y = 0;
        xformSize[0].x = 0;
        xformSize[1].y = pFontMetrics->fwdUnitsPerEm;
        xformSize[1].x = pFontMetrics->fwdAveCharWidth;
        xformSize[2].y = pFontMetrics->fwdWinAscender;
        xformSize[2].x = 0;

        //
        // We now need to convert these sizes if the GDI has provided a
        // transform object.
        //
        if (pxform != NULL)
        {
            if (!XFORMOBJ_bApplyXform(pxform,
                                      XF_LTOL,
                                      3,
                                      &xformSize,
                                      &xformSize))
            {
                ERROR_OUT(( "Xform failed"));
                continue;
            }
        }

        //
        // Calculate the font width and height.
        //
        *pFontHeight = (UINT)(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = (UINT)(xformSize[1].x - xformSize[0].x
                                                 - charWidthAdjustment);

        TRACE_OUT(( "Device font size %hdx%hd", *pFontWidth, *pFontHeight));

        //
        // Get the offset to the start of the text cell.
        //
        *pFontAscender = (UINT)(xformSize[2].y - xformSize[0].y);

        //
        // Check that we have a matching pair - where we require that the
        // fonts (ie the one being used by the application and the one
        // we've matched with the remote system) are the same pitch (ie
        // variable or fixed) and use the same technology (ie TrueType or
        // not).
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
                ((TSHR_UINT16)(*pFontFlags) & NF_FIXED_PITCH))
        {
            TRACE_OUT(( "Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
                ((TSHR_UINT16)*pFontFlags & NF_TRUE_TYPE))
        {
            TRACE_OUT(( "True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes - either both
        // fixed pitch or both variable pitch - and using the same font
        // technology.
        //
        // If the font is fixed pitch then we must also check that this
        // particular size matches.
        //
        // If the font is not fixed pitch (scalable) then we assume that it
        // is matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(( "Size mismatch"));
                continue;
            }
        }

        //
        // Hey! We've got a matched pair!
        //
        rc = TRUE;
        TRACE_OUT(( "Found match at local font %hd", iLocal));
        break;
    }

    if (rc != TRUE)
    {
        TRACE_OUT(( "Couldn't find matching font in table"));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We have already put the pitch
    // flag in place.
    //
    if ( ((pFontMetrics->fsSelection & FM_SEL_ITALIC) != 0) ||
         ((pfo->flFontType           & FO_SIM_ITALIC) != 0) )
    {
        TRACE_OUT(( "Italic"));
        *pFontFlags |= NF_ITALIC;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_UNDERSCORE) != 0)
    {
        TRACE_OUT(( "Underline"));
        *pFontFlags |= NF_UNDERLINE;
    }
    if ((pFontMetrics->fsSelection & FM_SEL_STRIKEOUT) != 0)
    {
        TRACE_OUT(( "Strikeout"));
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }

    //
    // If the font is an exact match, or if it is an approximate match for
    // its entire range (0x00 to 0xFF) then send it happily.  If not...only
    // send chars within the range 0x20->0x7F ("true ASCII").
    //
    ASSERT(g_poeLocalFonts);
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // The approximate match is only valid if we use a font that
        // supports the ANSI character set.
        //
        if ((pFontMetrics->jWinCharSet & ANSI_CHARSET) != 0)
        {
            TRACE_OUT(( "Cannot do match without ANSI support"));
            DC_QUIT;
        }

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < textLen; i++)
        {
            if ( (pFontText[i] == 0) ||
                 ( (pFontText[i] >= NF_ASCII_FIRST) &&
                   (pFontText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            TRACE_OUT(( "found non ASCII char %x", pFontText[i]));
            DC_QUIT;
        }

    }

    //
    // We have a valid font. Now sort out delta X issues.
    //

    //
    // If we do not need to send delta X arrays then exit now.
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (textLen <= 1)
    {
        TRACE_OUT(( "String only %lu long", textLen));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if ((matchQuality & FH_SC_EXACT) != 0)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We have passed all the checks - we must send a delta X array.
    //
    TRACE_OUT(( "Must send delta X"));
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, rc);
    return(rc);
}


//
// Function:    OELPtoVirtual
//
// Description: Adjusts window coordinates to virtual desktop coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pPoints - Array of points to be converted
//              cPoints - Number of points to be converted
//
// Returns:     (none)
//
void  OELPtoVirtual
(
    LPPOINT aPts,
    UINT    cPts
)
{
    int         l;
    TSHR_INT16  s;

    DebugEntry(OELPtoVirtual);

    //
    // Convert to screen coordinates
    //
    while (cPts > 0)
    {
        //
        // Look for int16 overflow in the X coordinate
        //
        l = aPts->x;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int16 overflow in the Y coordinate
        //
        l = aPts->y;
        s = (TSHR_INT16)l;

        if (l == (int)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}


//
// Function:    OELRtoVirtual
//
// Description: Adjusts RECT in window coordinates to virtual coordinates.
//              Clips the result to [+32766, -32768].
//
// Parameters:  pRects  - Array of rects to be converted
//              numRects  - Number of rects to be converted
//
// Returns:     (none)
//
// NB.  This function takes a Windows rectangle (exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//
void OELRtoVirtual
(
    LPRECT  aRects,
    UINT    cRects
)
{
    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual((LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}


//
// Function:    OEClipAndAddOrder
//
// Description: Adds the order to the order buffer, splitting it up into
//              multiple orders if the clipping is complicated.  If we fail
//              to send the full order, we accumulate it in the SDA instead
//
// Parameters:  pOrder     - Order to be stored.
//              pExtraInfo - Pointer to extra data associated with the
//                           order.  This data depends on the order type,
//                           and may be NULL.
//              pco        - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddOrder(LPINT_ORDER pOrder,
                                             void *    pExtraInfo,
                                             CLIPOBJ*   pco)
{
    BOOL             fOrderClipped;
    BOOL             fMoreRects;
    RECT             clippedRect;
    RECT             orderRect;
    LPINT_ORDER         pNewOrder;
    LPINT_ORDER         pLastOrder = NULL;
    OE_ENUMRECTS       clip;
    UINT             i;
    UINT             numRects = 0;

    DebugEntry(OEClipAndAddOrder);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    orderRect.left   = pOrder->OrderHeader.Common.rcsDst.left;
    orderRect.top    = pOrder->OrderHeader.Common.rcsDst.top;
    orderRect.right  = pOrder->OrderHeader.Common.rcsDst.right + 1;
    orderRect.bottom = pOrder->OrderHeader.Common.rcsDst.bottom + 1;
    fOrderClipped    = FALSE;

    TRACE_OUT(( "orderRect: (%d,%d)(%d,%d)",
                 orderRect.left,
                 orderRect.top,
                 orderRect.right,
                 orderRect.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // No clipping object - just use the bounds
        //
        clippedRect   = orderRect;
        fOrderClipped = TRUE;
        pLastOrder    = pOrder;
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left   = max(clippedRect.left,   orderRect.left);
        clippedRect.bottom = min(clippedRect.bottom, orderRect.bottom);
        clippedRect.right  = min(clippedRect.right,  orderRect.right);
        clippedRect.top    = max(clippedRect.top,    orderRect.top);
        fOrderClipped = TRUE;
        pLastOrder     = pOrder;
    }
    else
    {
        //
        // OA can only cope as long as the orders are added in the same
        // order that they were allocated, so we need to do a little
        // shuffling here.
        //
        // We always keep one order outstanding (pLastOrder) and a flag to
        // indicate if it is valid (fOrderClipped).  The first time we find
        // a valid clipping rectangle, we set up pLastOrder and
        // fOrderClipped.  If we find we need to allocate a new order, we
        // request the memory for the new order (pNewOrder), add pLastOrder
        // and store pNewOrder in pLastOrder.
        //
        // Once we have finished enumerating the clipping rectangles, if
        // pLastOrder is valid, we add it in.
        //
        // Also, while we are adding all these orders, OA must not purge
        // the order heap otherwise we'll be left holding an invalid
        // pointer.
        //
        pNewOrder = pOrder;
        g_oaPurgeAllowed = FALSE;

        //
        // Multiple clipping rectangles - Enumerate all the rectangles
        // involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        //
        // Get the clip rectangles. We fetch these into the clip buffer
        // which is big enough to get all the clip rectangles we expect + 1.
        // If the order runs across this number of clip rects or more then
        // we will already have decided to send it as screen data.
        // The clip rectangle fetching is contained within a loop because,
        // while we expect to call CLIPOBJ_bEnum once only, it is possible
        // for this functio to return zero rects and report that there are
        // more to fetch (according to MSDN).
        //
        do
        {
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            //
            // The clipping object can decide that there are no more
            // rectangles and that this query has returned no rectangles,
            // so we must check for any valid data in the returned
            // rectangle list.
            //
            if (clip.rects.c == 0)
            {
                //
                // We didn't get any rects this time so go round again - if
                // we're finished, the loop termination condition will take
                // us out. CLIPOBJ_bEnum can return a count of zero when
                // there are still more rects.
                //
                TRACE_OUT(( "No rects this time, more %u", fMoreRects));
                continue;
            }

            //
            // To get to here we expect to have fetched all the rects and
            // no more. Do a quick check.
            //
            numRects += clip.rects.c;
            ASSERT( (numRects <= COMPLEX_CLIP_RECT_COUNT) );

            //
            // Process each clip rectangle by clipping the drawing order to
            // it.
            //
            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Check for an intersection
                //
                if ( (clip.rects.arcl[i].left >= orderRect.right)  ||
                     (clip.rects.arcl[i].bottom <= orderRect.top)    ||
                     (clip.rects.arcl[i].right <= orderRect.left)   ||
                     (clip.rects.arcl[i].top >= orderRect.bottom) )
                {
                    //
                    // No intersection, move on to next clip rect.
                    //
                    continue;
                }

                //
                // There is an intersection, so we may need to add a new
                // order to the buffer to cater for this rectangle.
                //
                if (fOrderClipped)
                {
                    //
                    // The order has already been clipped once, so it
                    // actually intersects more than one clip rect, ie
                    // fOrderClipped is always FALSE for at least the first
                    // clip rectangle in the clip.rects buffer.  We cope
                    // with this by duplicating the order and clipping it
                    // again.
                    //
                    pNewOrder = OA_DDAllocOrderMem(
                         pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);

                    if (pNewOrder == NULL)
                    {
                        WARNING_OUT(( "Order memory allocation failed" ));
                        goto CLIP_ORDER_FAILED;
                    }

                    //
                    // Copy the header & data from the original order to
                    // the new order (making sure that we don't overwrite
                    // the list information at the start of the header).
                    //
                    memcpy((LPBYTE)pNewOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              (LPBYTE)pLastOrder
                                    + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                              pLastOrder->OrderHeader.Common.cbOrderDataLength
                                    + sizeof(INT_ORDER_HEADER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

                    //
                    // Set the destination (clip) rectangle (in virtual
                    // desktop coordinates).
                    //
                    TSHR_RECT16_FROM_RECT(
                                       &pLastOrder->OrderHeader.Common.rcsDst,
                                       clippedRect);

                    pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
                    pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

                    TRACE_OUT(( "Adding duplicate order  (%d,%d) (%d,%d)",
                               pLastOrder->OrderHeader.Common.rcsDst.left,
                               pLastOrder->OrderHeader.Common.rcsDst.top,
                               pLastOrder->OrderHeader.Common.rcsDst.right,
                               pLastOrder->OrderHeader.Common.rcsDst.bottom));

                    //
                    // Add the order to the Order List.
                    //
                    OA_DDAddOrder(pLastOrder, pExtraInfo);
                }

                //
                // Update the clipping rectangle for the order to be sent.
                //
                clippedRect.left  = max(clip.rects.arcl[i].left,
                                           orderRect.left);
                clippedRect.bottom= min(clip.rects.arcl[i].bottom,
                                           orderRect.bottom);
                clippedRect.right = min(clip.rects.arcl[i].right,
                                           orderRect.right);
                clippedRect.top   = max(clip.rects.arcl[i].top,
                                           orderRect.top);
                fOrderClipped     = TRUE;
                pLastOrder        = pNewOrder;
            }
        } while (fMoreRects);
    }

    //
    // Check whether the clipping has removed the order entirely.
    //
    if (fOrderClipped)
    {
        TSHR_RECT16_FROM_RECT(&pLastOrder->OrderHeader.Common.rcsDst,
                                clippedRect);

        pLastOrder->OrderHeader.Common.rcsDst.right -= 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom -= 1;

        TRACE_OUT(( "Adding order  (%d,%d) (%d,%d)",
                    pLastOrder->OrderHeader.Common.rcsDst.left,
                    pLastOrder->OrderHeader.Common.rcsDst.top,
                    pLastOrder->OrderHeader.Common.rcsDst.right,
                    pLastOrder->OrderHeader.Common.rcsDst.bottom));

        //
        // Add the order to the Order List.
        //
        OA_DDAddOrder(pLastOrder, pExtraInfo);
    }
    else
    {

        TRACE_OUT(( "Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

    DC_QUIT;


CLIP_ORDER_FAILED:
    //
    // Allocation of memory for a duplicate order failed.  Just add the
    // original order's destination rect into the SDA and free the order.
    //
    // The order rectangle is already in inclusive virtual coordinates.
    //
    TRACE_OUT(( "Order add failed, add to SDA"));
    RECT_FROM_TSHR_RECT16(&orderRect,pLastOrder->OrderHeader.Common.rcsDst);
    OA_DDFreeOrderMem(pLastOrder);
    BA_AddScreenData(&orderRect);

DC_EXIT_POINT:
    //
    // Make sure that we always re-enable heap purging.
    //
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}


//
// Function:    OEClipAndAddScreenData
//
// Description: Determines if we need to accumulate any screen data for the
//              specified area.  If so, it is added to the SDA.
//
// Parameters:  pRect - Bounding rectangle of area to be accumulated
//              pco   - Clipping object for the area
//
// Returns:     (none)
//
void   OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco)
{
    RECT    SDACandidate;
    BOOL    fMoreRects;
    RECT    clippedRect;
    OE_ENUMRECTS clip;
    UINT    i;

    DebugEntry(OEClipAndAddScreenData);

    //
    // Convert the order rectangle passed in (in virtual co-ordinates) back
    // to screen co-ordinates.  It is going to be clipped against clip
    // rectangles returned to us in screen co-ordinates.
    //
    // Note that we also convert to exclusive coords here to make
    // comparison with the exclusive Windows coords easier.
    //
    SDACandidate.left   = pRect->left;
    SDACandidate.top    = pRect->top;
    SDACandidate.right  = pRect->right + 1;
    SDACandidate.bottom = pRect->bottom + 1;

    TRACE_OUT(( "SDACandidate: (%d,%d)(%d,%d)",
                 SDACandidate.left,
                 SDACandidate.top,
                 SDACandidate.right,
                 SDACandidate.bottom));

    //
    // Check if we have a clipping object at all.
    //
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        //
        // Convert the clipped rect into Virtual Desktop coords.
        //
        clippedRect         = SDACandidate;
        clippedRect.right  -= 1;
        clippedRect.bottom -= 1;

        //
        // Add the clipped rect into the SDA.
        //
        TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)", clippedRect.left,
                                                  clippedRect.top,
                                                  clippedRect.right,
                                                  clippedRect.bottom));

        BA_AddScreenData(&clippedRect);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        //
        // One clipping rectangle - use it directly, converting into
        // Virtual Desktop coords. Make sure the rectangle is valid before
        // adding to the SDA.
        //
        RECT_FROM_RECTL(clippedRect, pco->rclBounds);
        clippedRect.left = max(clippedRect.left, SDACandidate.left);
        clippedRect.right = min(clippedRect.right, SDACandidate.right) + -1;

        if ( clippedRect.left <= clippedRect.right )
        {
            clippedRect.bottom = min(clippedRect.bottom,
                                        SDACandidate.bottom) + -1;
            clippedRect.top = max(clippedRect.top, SDACandidate.top);

            if ( clippedRect.bottom >= clippedRect.top )
            {
                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA RECT (%d,%d)(%d,%d)",
                                                         clippedRect.left,
                                                         clippedRect.top,
                                                         clippedRect.right,
                                                         clippedRect.bottom));
                BA_AddScreenData(&clippedRect);
            }
        }
    }
    else
    {
        //
        // Enumerate all the rectangles involved in this drawing operation.
        // The documentation for this function incorrectly states that
        // the returned value is the total number of rectangles
        // comprising the clip region. In fact, -1 is always returned,
        // even when the final parameter is non-zero.
        //
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do
        {
            //
            // Get the next batch of clipping rectangles
            //
            fMoreRects = CLIPOBJ_bEnum(pco,
                                       sizeof(clip),
                                       (ULONG *)&clip.rects);

            for ( i = 0; i < clip.rects.c; i++ )
            {
                TRACE_OUT(( "  (%d,%d)(%d,%d)",
                             clip.rects.arcl[i].left,
                             clip.rects.arcl[i].top,
                             clip.rects.arcl[i].right,
                             clip.rects.arcl[i].bottom));

                //
                // Intersect the SDA rect with the clip rect, checking for
                // no intersection.
                //
                clippedRect.left  = max( clip.rects.arcl[i].left,
                                            SDACandidate.left );
                clippedRect.right = min( clip.rects.arcl[i].right,
                                            SDACandidate.right );

                if (clippedRect.left >= clippedRect.right)
                {
                    //
                    // No horizontal intersection.
                    //
                    continue;
                }

                clippedRect.bottom = min( clip.rects.arcl[i].bottom,
                                             SDACandidate.bottom );
                clippedRect.top    = max( clip.rects.arcl[i].top,
                                             SDACandidate.top );

                if (clippedRect.top >= clippedRect.bottom)
                {
                    //
                    // No vertical intersection.
                    //
                    continue;
                }

                //
                // Convert the clipped rect into Virtual Desktop coords.
                //
                clippedRect.right  -= 1;
                clippedRect.bottom -= 1;

                //
                // Add the clipped rect into the SDA.
                //
                TRACE_OUT(( "Adding SDA (%d,%d)(%d,%d)",
                             clippedRect.left,
                             clippedRect.top,
                             clippedRect.right,
                             clippedRect.bottom));

                BA_AddScreenData(&clippedRect);
            }
        } while (fMoreRects);
    }

    DebugExitVOID(OEClipAndAddScreenData);
}





//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    UINT    cbNewSize;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.
    //
    g_oeNumFonts = 0;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Free our previous font block if we had one.
    //
    if (g_poeLocalFonts)
    {
        EngFreeMem(g_poeLocalFonts);
        g_poeLocalFonts = NULL;
    }

    //
    // Alloc a new one, the size of the new font block.
    //
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);
    g_poeLocalFonts = EngAllocMem(0, cbNewSize, OSI_ALLOC_TAG);
    if (! g_poeLocalFonts)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }

    //
    // OK, if we're here, this is going to succeed.  Copy the info over.
    //
    g_oeNumFonts = pRequest->countFonts;

    memcpy(g_poeLocalFonts, pRequest->fontData, cbNewSize);

    memcpy(g_oeLocalFontIndex, pRequest->fontIndex,
              sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    DebugExitVOID(OEDDSetNewFonts);
}


//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    memcpy(g_oeOrderSupported,
              pCapabilities->orderSupported,
              sizeof(g_oeOrderSupported));

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));

    DebugExitVOID(OEDDSetNewCapabilities);
}


//
// Function:    OETileBitBltOrder
//
// Description: Divides a single large BitBlt order into a series of small,
//              "tiled" BitBlt orders, each of which is added to the order
//              queue.
//
// Parameters:  pOrder     - Template order to be tiled
//              pExtraInfo - Structure containing pointers to the source
//                           and destination surface objects, and a pointer
//                           to the color translation object for the Blt
//              pco        - Clipping object for the operation
//
// Returns:     TRUE - Stored in orders (and possibly some SDA)
//              FALSE- Stored in SDA (or contained bad data)
//
//
void   OETileBitBltOrder
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pExtraInfo,
    CLIPOBJ*                    pco
)
{
    UINT        tileWidth;
    UINT        tileHeight;
    int         srcLeft;
    int         srcTop;
    int         srcRight;
    int         srcBottom;
    int         xFirstTile;
    int         yFirstTile;
    int         xTile;
    int         yTile;
    UINT        type;
    int         bmpWidth, bmpHeight;
    RECT        destRect;

    DebugEntry(OETileBitBltOrder);

    //
    // Extract the src bitmap handle from the Order - if the order is not a
    // memory to screen blit, we get out now.
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    switch (type)
    {
        case ORD_MEMBLT_TYPE:
        {
            srcLeft   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
            destRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right = destRect.left +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom= destRect.top +
                ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        case ORD_MEM3BLT_TYPE:
        {
            srcLeft   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
            srcTop    = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
            srcRight  = srcLeft +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            srcBottom = srcTop +
                       ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;

            destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
            destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;
            destRect.right= destRect.left +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
            destRect.bottom = destRect.top +
                            ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        }
        break;

        default:
        {
            ERROR_OUT(( "Invalid order type %u", type));
        }
        break;
    }

    //
    // Fetch the bitmap details.
    //
    bmpWidth  = (int)pExtraInfo->pSource->sizlBitmap.cx;
    bmpHeight = (int)pExtraInfo->pSource->sizlBitmap.cy;

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        //
        // This could happen if some 2.x user joins the share.
        //
        TRACE_OUT(("Bitmap is not tileable"));
        OEClipAndAddScreenData(&destRect, pco);
    }
    else
    {
        //
        // Tile the order.  If an individual tile fails to get queued as an
        // order, OEAddTiledBitBltOrder() will add it as screen data.  Hence
        // no return value to be checked.
        //
        xFirstTile = srcLeft - (srcLeft % tileWidth);
        yFirstTile = srcTop - (srcTop % tileHeight);

        for (yTile = yFirstTile; yTile < srcBottom; yTile += tileHeight)
        {
            for (xTile = xFirstTile; xTile < srcRight; xTile += tileWidth)
            {
                OEAddTiledBitBltOrder(pOrder, pExtraInfo, pco, xTile, yTile,
                    tileWidth,  tileHeight);
            }
        }
    }

    DebugExitVOID(OETileBitBltOrder);
}



//
// Function:    OEAddTiledBitBltOrder
//
// Description: Takes an unmodified "large" BitBlt and a tile rectangle,
//              makes a copy of the order and modifies the copied order's
//              src/dest so it applies to the source tile only. The order
//              is added to the order queue.  If the allocation of the
//              "tiled" order fails, the destination rect is added to SDA
//
// Parameters:  pOrder     - Template order to be added
//              pExtraInfo - Pointer to the extra BitBlt info
//              pco        - Clipping object for the BitBlt
//              xTile      - X position of the tile
//              yTile      - Y position of the tile
//              tileWidth  - tile width
//              tileHeight - tile height
//
// Returns:     none
//
//
void   OEAddTiledBitBltOrder(
                                         LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                  xTile,
                                         int                  yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight)
{
    LPINT_ORDER pTileOrder;
    LPINT  pXSrc   = NULL;
    LPINT  pYSrc   = NULL;
    LPINT  pLeft   = NULL;
    LPINT  pTop    = NULL;
    LPINT  pWidth  = NULL;
    LPINT  pHeight = NULL;
    RECT    srcRect;
    RECT    destRect;
    UINT  type;

    DebugEntry(OETileAndAddBitBltOrder);

    //
    // This is a trusted interface - assume the type is correct
    //
    type = ((LPMEMBLT_ORDER)pOrder->abOrderData)->type;
    ASSERT(((type == ORD_MEMBLT_TYPE) || (type == ORD_MEM3BLT_TYPE)));

    //
    // Do processing which depends on the type of bit blt being tiled:
    // - save existing src and dest rects
    // - make a copy of the order (which will be the tile order)
    // - save pointers to the fields in the tile order which we're likely
    //   to change.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        srcRect.left  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEMBLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEMBLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEMBLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEMBLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEMBLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }
    else
    {
        srcRect.left  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nXSrc;
        srcRect.top   = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nYSrc;
        srcRect.right = srcRect.left +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nWidth;
        srcRect.bottom = srcRect.top +
                        ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nHeight;
        destRect.left = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nLeftRect;
        destRect.top  = ((LPMEM3BLT_ORDER)pOrder->abOrderData)->nTopRect;

        //
        // We must allocate enough space for the maximum size order that
        // SBC may use (i.e.  an R2 order).  We default to filling in the
        // data as an R1 order.
        //
        pTileOrder = OA_DDAllocOrderMem(sizeof(MEM3BLT_R2_ORDER),0);
        if (pTileOrder == NULL)
        {
            TRACE_OUT(( "No space for tile order"));
            DC_QUIT;
        }

        //
        // We must not mess up the linked list data in the orders.
        //
        RtlCopyMemory(((LPBYTE)pTileOrder) +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      ((LPBYTE)pOrder)     +
                                       FIELD_SIZE(INT_ORDER, OrderHeader.list),
                      sizeof(INT_ORDER_HEADER)
                                    + sizeof(MEM3BLT_R2_ORDER)
                                    - FIELD_SIZE(INT_ORDER, OrderHeader.list));

        pXSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nXSrc;
        pYSrc   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nYSrc;
        pWidth  = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nWidth;
        pHeight = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nHeight;
        pLeft   = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nLeftRect;
        pTop    = &((LPMEM3BLT_ORDER)pTileOrder->abOrderData)->nTopRect;
    }

    TRACE_OUT(( "Tiling order, orig srcLeft=%hd, srcTop=%hd, srcRight=%hd, "
           "srcBottom=%hd, destX=%hd, destY=%hd; "
           "xTile=%hd, yTile=%hd, tileW=%hd, tileH=%hd",
           srcRect.left, srcRect.top, srcRect.right, srcRect.bottom,
           destRect.left, destRect.top,
           xTile, yTile, tileWidth, tileHeight));

DC_EXIT_POINT:
    //
    // NOTE: ALL THE POINTERS MAY BE NULL AT THIS POINT - DO NOT USE THEM
    // UNTIL YOU VERIFY PTILEORDER IS NON-NULL.
    //
    // Intersect source and tile rects, and set up destination rect
    // accordingly - we need to do this even if we failed to copy the
    // order, because the tiled source rect will have to be added to the
    // screen data area.
    //
    if (xTile > srcRect.left)
    {
        destRect.left += (xTile - srcRect.left);
        srcRect.left = xTile;
    }

    if (yTile > srcRect.top)
    {
        destRect.top += (yTile - srcRect.top);
        srcRect.top = yTile;
    }

    srcRect.right  = min((UINT)srcRect.right, xTile + tileWidth);
    srcRect.bottom = min((UINT)srcRect.bottom, yTile + tileHeight);

    destRect.right  = destRect.left + (srcRect.right - srcRect.left);
    destRect.bottom = destRect.top + (srcRect.bottom - srcRect.top);

    //
    // If the order was successfully copied above, then modify the order
    // to contain the tiled coordinates, and add it to the order list.
    // Otherwise, send the dest rect as screen data.
    //
    if (pTileOrder != NULL)
    {
        TRACE_OUT(( "Tile order originally: srcX=%hd, srcY=%hd, destX=%hd, "
               "destY=%hd, w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));

        *pXSrc = srcRect.left;
        *pYSrc = srcRect.top;
        *pLeft = destRect.left;
        *pTop  = destRect.top;
        *pWidth = srcRect.right - srcRect.left;
        *pHeight = srcRect.bottom - srcRect.top;

        pTileOrder->OrderHeader.Common.rcsDst.left = (TSHR_INT16)destRect.left;
        pTileOrder->OrderHeader.Common.rcsDst.right = (TSHR_INT16)destRect.right;
        pTileOrder->OrderHeader.Common.rcsDst.top = (TSHR_INT16)destRect.top;
        pTileOrder->OrderHeader.Common.rcsDst.bottom =
                                                     (TSHR_INT16)destRect.bottom;

        TRACE_OUT(( "Adding order srcX=%hd, srcY=%hd, destX=%hd, destY=%hd,"
               " w=%hd, h=%hd",
               *pXSrc, *pYSrc, *pLeft, *pTop, *pWidth, *pHeight));
        OEClipAndAddOrder(pTileOrder, pExtraInfo, pco);
    }
    else
    {
        TRACE_OUT(( "Failed to allocate order - sending as screen data"));
        OEClipAndAddScreenData(&destRect, pco);
    }

    DebugExitVOID(OETileAndAddBitBltOrder);
}



// NAME:      OEAddLine
//
// PURPOSE:
//
// Add a LineTo order to the order heap.
//
// RETURNS:
//
// TRUE  - Attempted to add to heap
// FALSE - No room left to allocate an order
//
// PARAMS:
//
// ppdev      - display driver PDEV
// startPoint - start point of line
// endPoint   - end point of line
// rectDst    - bounding rectangle
// rop2       - ROP2 to use with line
// width      - width of line to add
// color      - color of line to add
// pco        - clipping object for drawing operation
//
BOOL  OEAddLine(LPOSI_PDEV ppdev,
                    LPPOINT  startPoint,
                    LPPOINT  endPoint,
                                    LPRECT   rectDst,
                                    UINT  rop2,
                                    UINT  width,
                                    UINT  color,
                                    CLIPOBJ*  pco)
{
    BOOL         rc = FALSE;
    LPLINETO_ORDER pLineTo;
    LPINT_ORDER     pOrder;

    DebugEntry(OEAddLine);

    //
    // Allocate the memory for the order.
    //
    pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER),0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to alloc order"));
        DC_QUIT;
    }
    pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

    //
    // Mark this order type.
    //
    pLineTo->type = ORD_LINETO_TYPE;

    //
    // Store the line end coordinates.
    //
    pLineTo->nXStart   = startPoint->x;
    pLineTo->nYStart   = startPoint->y;
    pLineTo->nXEnd     = endPoint->x;
    pLineTo->nYEnd     = endPoint->y;

    //
    // We must convert these values to virtual coords.
    //
    OELPtoVirtual((LPPOINT)&pLineTo->nXStart, 2);

    //
    // Always do solid lines, so it does not matter what we specify as the
    // back color.
    //
    RtlFillMemory(&pLineTo->BackColor,
                  sizeof(pLineTo->BackColor),
                  0);

    //
    // We only draw solid lines with no option as to what we do to the
    // background, so this is always transparent.
    //
    pLineTo->BackMode  = TRANSPARENT;

    //
    // Get the ROP value.
    //
    pLineTo->ROP2      = rop2;

    //
    // The NT Display Driver is only called to accelerate simple solid
    // lines.  So we only support pen styles of PS_SOLID.
    //
    pLineTo->PenStyle  = PS_SOLID;

    //
    // Get the pen width.
    //
    pLineTo->PenWidth = width;

    //
    // Set up the color.
    //
    OEConvertColor(ppdev,
                   &pLineTo->PenColor,
                   color,
                   NULL);

    TRACE_OUT(( "LineTo BC %02x%02x%02x BM %04X rop2 %02X "
                 "pen %04X %04X %02x%02x%02x x1 %d y1 %d x2 %d y2 %d",
            pLineTo->BackColor.red,
            pLineTo->BackColor.green,
            pLineTo->BackColor.blue,
            pLineTo->BackMode,
            pLineTo->ROP2,
            pLineTo->PenStyle,
            pLineTo->PenWidth,
            pLineTo->PenColor.red,
            pLineTo->PenColor.green,
            pLineTo->PenColor.blue,
            pLineTo->nXStart,
            pLineTo->nYStart,
            pLineTo->nXEnd,
            pLineTo->nYEnd));

    //
    // Store the general order data.  The bounding rectangle must be in to
    // virtual desktop co-ordinates.  OELRtoVirtual has already done this.
    //
    pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;
    pOrder->OrderHeader.Common.rcsDst.left   = (TSHR_INT16)rectDst->left;
    pOrder->OrderHeader.Common.rcsDst.right  = (TSHR_INT16)rectDst->right;
    pOrder->OrderHeader.Common.rcsDst.top    = (TSHR_INT16)rectDst->top;
    pOrder->OrderHeader.Common.rcsDst.bottom = (TSHR_INT16)rectDst->bottom;

    //
    // Store that order!
    //
    OEClipAndAddOrder(pOrder, NULL, pco);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OEAddLine, rc);
    return(rc);
}


// NAME:      OEEncodePatBlt
//
// PURPOSE:
//
// Attempts to encode a PatBlt order. This function allocates the memory
// for the encoded order (pointer returned in ppOrder). If the function
// completes successfully, it is the caller's responsibility to free this
// memory.
//
// RETURNS:
//
// TRUE  - Order encoded
// FALSE - Order not encoded (so add to SDA)
//
// PARAMS:
//
// ppdev       - display driver PDEV
// pbo         - brush object for the blt
// pptlBrush   - brush origin
// rop3        - 3-way rop to use
// pBounds     - bounding rectangle
// ppOrder     - the encoded order
//
BOOL  OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                         BRUSHOBJ   *pbo,
                                         POINTL     *pptlBrush,
                                         BYTE     rop3,
                                         LPRECT     pBounds,
                                         LPINT_ORDER *ppOrder)
{
    BOOL rc = FALSE;
    POE_BRUSH_DATA pCurrentBrush;
    LPPATBLT_ORDER pPatBlt;
    UINT orderFlags = OF_SPOILABLE;

    DebugEntry(OEEncodePatBlt);

    //
    // Check for a simple brush pattern.
    //
    if ( OECheckBrushIsSimple(ppdev, pbo, &pCurrentBrush) )
    {
        //
        // Allocate the memory for the order.
        //
        *ppOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER),0);
        if (*ppOrder != NULL)
        {
            pPatBlt = (LPPATBLT_ORDER)((*ppOrder)->abOrderData);

            //
            // Set the opaque flag if the rop is opaque.
            //
            if (ROP3_IS_OPAQUE(rop3))
            {
               orderFlags |= OF_SPOILER;
            }

            //
            // Set up order type.
            //
            pPatBlt->type = LOWORD(ORD_PATBLT);

            //
            // Virtual desktop co-ordinates.
            //
            pPatBlt->nLeftRect  = pBounds->left;
            pPatBlt->nTopRect   = pBounds->top;
            pPatBlt->nWidth     = pBounds->right  - pBounds->left + 1;
            pPatBlt->nHeight    = pBounds->bottom - pBounds->top  + 1;
            pPatBlt->bRop       = rop3;

            //
            // Pattern colours.
            //
            pPatBlt->BackColor  = pCurrentBrush->back;
            pPatBlt->ForeColor  = pCurrentBrush->fore;

            //
            // The protocol brush origin is the point on the screen where
            // we want the brush to start being drawn from (tiling where
            // necessary).  This must be in virtual coordinates.
            //
            pPatBlt->BrushOrgX  = pptlBrush->x;
            pPatBlt->BrushOrgY  = pptlBrush->y;
            OELPtoVirtual((LPPOINT)&pPatBlt->BrushOrgX, 1);

            //
            // Extra brush data from the data when we realised the brush.
            //
            pPatBlt->BrushStyle = pCurrentBrush->style;
            pPatBlt->BrushHatch = pCurrentBrush->hatch;

            RtlCopyMemory(pPatBlt->BrushExtra,
                          pCurrentBrush->brushData,
                          sizeof(pPatBlt->BrushExtra));

            TRACE_OUT(( "PatBlt BC %02x%02x%02x FC %02x%02x%02x "
                         "Brush %02X %02X X %d Y %d w %d h %d rop %02X",
                    pPatBlt->BackColor.red,
                    pPatBlt->BackColor.green,
                    pPatBlt->BackColor.blue,
                    pPatBlt->ForeColor.red,
                    pPatBlt->ForeColor.green,
                    pPatBlt->ForeColor.blue,
                    pPatBlt->BrushStyle,
                    pPatBlt->BrushHatch,
                    pPatBlt->nLeftRect,
                    pPatBlt->nTopRect,
                    pPatBlt->nWidth,
                    pPatBlt->nHeight,
                    pPatBlt->bRop));

            //
            // Copy any order flags into the encoded order structure.
            //
            (*ppOrder)->OrderHeader.Common.fOrderFlags = (TSHR_UINT16)orderFlags;

            rc = TRUE;
        }
        else
        {
            TRACE_OUT(( "Failed to alloc order"));
        }
    }
    else
    {
        TRACE_OUT(( "Brush is not simple"));
    }

    DebugExitDWORD(OEEncodePatBlt, rc);
    return(rc);
}




//
// DrvTransparentBlt()
// NEW FOR NT5
//
BOOL DrvTransparentBlt
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    ULONG       iTransColor,
    ULONG       ulReserved
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvTransparentBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvTransparentBlt, rc);
    return(rc);
}



//
// DrvAlphaBlend()
// NEW FOR NT5
//
BOOL DrvAlphaBlend
(
    SURFOBJ *   psoDst,
    SURFOBJ *   psoSrc,
    CLIPOBJ *   pco,
    XLATEOBJ *  pxlo,
    RECTL *     prclDst,
    RECTL *     prclSrc,
    BLENDOBJ *  pBlendObj
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvAlphaBlend);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));


    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvAlphaBlend, rc);
    return(rc);
}



//
// DrvPlgBlt()
// NEW FOR NT5
//
BOOL DrvPlgBlt
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMsk,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlBrushOrg,
    POINTFIX *          pptfx,
    RECTL *             prclDst,
    POINTL *            pptlSrc,
    ULONG               iMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvPlgBlt);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvPlgBlt, rc);
    return(rc);
}



//
// DrvStretchBltROP()
// NEW FOR NT5
//
BOOL DrvStretchBltROP
(
    SURFOBJ *           psoDst,
    SURFOBJ *           psoSrc,
    SURFOBJ *           psoMask,
    CLIPOBJ *           pco,
    XLATEOBJ *          pxlo,
    COLORADJUSTMENT *   pca,
    POINTL *            pptlHTOrg,
    RECTL *             prclDst,
    RECTL *             prclSrc,
    POINTL *            pptlMask,
    ULONG               iMode,
    BRUSHOBJ *          pbo,
    DWORD               rop4
)
{
    BOOL        rc = TRUE;
    RECT        rectSrc;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvStretchBltROP);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectSrc, (*prclSrc));
    RECT_FROM_RECTL(rectDst, (*prclDst));

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvStretchBltROP, rc);
    return(rc);
}



//
// DrvGradientFill()
// NEW FOR NT5
//
BOOL DrvGradientFill
(
    SURFOBJ *       psoDst,
    CLIPOBJ *       pco,
    XLATEOBJ *      pxlo,
    TRIVERTEX *     pVertex,
    ULONG           nVertex,
    PVOID           pMesh,
    ULONG           nMesh,
    RECTL *         prclExtents,
    POINTL *        pptlDitherOrg,
    ULONG           ulMode
)
{
    BOOL        rc = TRUE;
    RECT        rectDst;
    BOOL        fAccumulate = FALSE;

    DebugEntry(DrvGradientFill);

    //
    // DO THIS _BEFORE_ TAKING LOCK
    //
    if (!g_oeViewers)
        goto NO_LOCK_EXIT;

    OE_SHM_START_WRITING;

    //
    // Get bounding rectangle and convert to a RECT.
    //
    RECT_FROM_RECTL(rectDst, pco->rclBounds);

    //
    // Check if we are accumulating data for this function
    //
    fAccumulate = OEAccumulateOutput(psoDst, pco, &rectDst);
    if (!fAccumulate)
    {
        DC_QUIT;
    }

    //
    // Convert to virtual coordinates.
    //
    OELRtoVirtual(&rectDst, 1);

DC_EXIT_POINT:
    if (fAccumulate)
    {
        OEClipAndAddScreenData(&rectDst, pco);
    }

    OE_SHM_STOP_WRITING;

NO_LOCK_EXIT:
    DebugExitBOOL(DrvGradientFill, rc);
    return(rc);
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\oa.c ===
#include "precomp.h"


//
// OA.C
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//



//
// OA_DDProcessRequest - see oa.h
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(OA_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            if (cbRequest != sizeof(OA_FLOW_CONTROL))
            {
                ERROR_OUT(("OA_DDProcessRequest:  Invalid size %d for OA_ESC_FLOW_CONTROL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Save new order accum throughput value
            //
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_SHARED_DATA    lpoaShared;
    LPOA_FAST_DATA      lpoaFast;

    DebugEntry(OA_DDAddOrder);

    lpoaShared  = OA_SHM_START_WRITING;
    lpoaFast    = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(&lpoaFast->ordersAccumulated);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds ; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order by SDA"));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        if (!SBC_DDCacheMemScreenBlt(pNewOrder, pExtraInfo))
        {
            //
            // The memory to screen blt cannot be handled as an order (the
            // source bitmap could not cached).  Add the destination of the
            // blt into the SDA and discard the order.
            //
            TRACE_OUT(("Failed to cache mem->screen blt"));
            TRACE_OUT(("Add rect to SDA (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));

            RECT_FROM_TSHR_RECT16(&tmpRect,
                                    pNewOrder->OrderHeader.Common.rcsDst);
            OA_DDFreeOrderMem(pNewOrder);
            BA_AddScreenData(&tmpRect);
            DC_QUIT;
        }
        else
        {
            TRACE_OUT(("Cached MEMBLT targetted at (%d,%d)(%d,%d)",
                           pNewOrder->OrderHeader.Common.rcsDst.left,
                           pNewOrder->OrderHeader.Common.rcsDst.top,
                           pNewOrder->OrderHeader.Common.rcsDst.right,
                           pNewOrder->OrderHeader.Common.rcsDst.bottom ));
        }
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );


            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Adding to SDA (%d,%d) (%d,%d)",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER) != 0)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT      tferRect;
    int     targetSize;
    UINT    moveOffset;
    UINT    moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        SHM_CheckPointer(&lpoaShared->totalOrderBytes);
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        SHM_CheckPointer(&lpoaShared->orderListHead);
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA (%d,%d)(%d,%d)",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                SBC_DDOrderSpoiltNotification(pOrder);
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            SHM_CheckPointer(&lpoaShared->orderHeap);
            SHM_CheckPointer(&lpoaShared->orderListHead);

            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                RtlMoveMemory(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              OA_SHM_NEXTORDER
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // 
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // 
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = (UINT)((UINT_PTR)pOrder - (UINT_PTR)pNextOrderPos);
            moveBytes  = lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap);

            TRACE_OUT(("Moving %d bytes", moveBytes));

            RtlMoveMemory(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((LPBYTE)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;

    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    OA_SHM_STOP_WRITING;
    DebugExitPVOID(OA_DDAllocOrderMem, pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_SyncUpdatesNow);

    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPINT_ORDER pSaveOrder;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);

    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

    DebugExitPVOID(OA_DDRemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    OA_SHM_STOP_WRITING;

    DebugExitVOID(OA_DDSpoilOrdersByRect);
}





//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += (UINT)MAX_ORDER_SIZE(pNewOrder);

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        TRACE_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = (TSHR_UINT16)cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            TRACE_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  (WORD)cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitPVOID(OADDAllocOrderMemInit, pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)((LPBYTE)pOrder -
                                      (LPBYTE)(lpoaShared->orderHeap));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}


//
//
// OADDOrderIsValid(..)
//
// Determines if a pointer points to a valid order.
//
// Returns:
//   TRUE if valid order, FALSE if invalid.
//
//
BOOL  OADDOrderIsValid(LPINT_ORDER pOrder)
{
    BOOL rc;

    DebugEntry(OADDOrderIsValid);

    //
    // Check the order is not already spoilt
    //
    rc = ((pOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT) == 0);

    DebugExitBOOL(OADDOrderIsValid, rc);
    return(rc);
}


BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT   prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if ((pTargetOrder->OrderHeader.Common.fOrderFlags &
                                                 OF_SPOILABLE) != 0)
        {
            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    SBC_DDOrderSpoiltNotification(pTargetOrder);
                }

                TRACE_OUT(("Spoil by order (%hd, %hd) (%hd, %hd)",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\het.c ===
#include "precomp.h"


//
// HET.C
// Hosted Entity Tracker, NT Display Driver version
//
// Copyright(c)Microsoft 1997-
//

#include <limits.h>

//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    LPHET_WINDOW_MEMORY pMem;

    DebugEntry(HET_DDTerm);

    //
    // Clean up any window/graphics tracking stuff
    //
    g_hetDDDesktopIsShared = FALSE;
    HETDDViewing(NULL, FALSE);
    HETDDUnshareAll();


    //
    // Loop through the memory list blocks, freeing each.  Then clear
    // the Window and Free lists.
    //                           
    while (pMem = COM_BasedListFirst(&g_hetMemoryList, FIELD_OFFSET(HET_WINDOW_MEMORY, chain)))
    {
        TRACE_OUT(("HET_DDTerm:  Freeing memory block %lx", pMem));

        COM_BasedListRemove(&(pMem->chain));
        EngFreeMem(pMem);
    }

    //
    // Clear the window linked lists since they contain elements in
    // the now free memory block.
    //
    COM_BasedListInit(&g_hetFreeWndList);
    COM_BasedListInit(&g_hetWindowList);

    DebugExitVOID(HET_DDTerm);
}


//
// HET_DDProcessRequest - see host.h
//
ULONG HET_DDProcessRequest(SURFOBJ  *pso,
                               UINT  cjIn,
                               void *   pvIn,
                               UINT  cjOut,
                               void *   pvOut)
{
    ULONG rc = TRUE;
    LPOSI_ESCAPE_HEADER  pHeader;

    DebugEntry(HET_DDProcessRequest);

    pHeader = pvIn;
    TRACE_OUT(( "Request %#x", pHeader->escapeFn));
    switch (pHeader->escapeFn)
    {
        case HET_ESC_SHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_SHARE_WINDOW)) ||
                (cjOut != sizeof(HET_SHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            ((LPHET_SHARE_WINDOW)pvOut)->result =
                HETDDShareWindow(pso, (LPHET_SHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_WINDOW:
        {
            if ((cjIn != sizeof(HET_UNSHARE_WINDOW)) ||
                (cjOut != sizeof(HET_UNSHARE_WINDOW)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_WINDOW",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareWindow((LPHET_UNSHARE_WINDOW)pvIn);
        }
        break;

        case HET_ESC_UNSHARE_ALL:
        {
            if ((cjIn != sizeof(HET_UNSHARE_ALL)) ||
                (cjOut != sizeof(HET_UNSHARE_ALL)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_ALL",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDUnshareAll();
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_SHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_SHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_SHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            if ((cjIn != sizeof(HET_UNSHARE_DESKTOP)) ||
                (cjOut != sizeof(HET_UNSHARE_DESKTOP)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_UNSHARE_DESKTOP",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(NULL, FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            //
            // We may turn OFF viewing but keep stuff shared and the windows
            // tracked -- hosting a meeting and sharing something, for 
            // example. 
            //
            if ((cjIn != sizeof(HET_VIEWER)) ||
                (cjOut != sizeof(HET_VIEWER)))
            {
                ERROR_OUT(("HET_DDProcessRequest:  Invalid sizes %d, %d for HET_ESC_VIEWER",
                    cjIn, cjOut));
                rc = FALSE;
                DC_QUIT;
            }

            HETDDViewing(pso, (((LPHET_VIEWER)pvIn)->viewersPresent != 0));
            break;
        }

        default:
        {
            ERROR_OUT(( "Unknown request type %#x", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(HET_DDProcessRequest, rc);
    return(rc);
}


//
// HET_DDOutputIsHosted - see host.h
//
BOOL HET_DDOutputIsHosted(POINT pt)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;

    DebugEntry(HET_DDOutputIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the point passed in is within this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            if ((pt.x >= pWnd->rects.arcl[j].left) &&
                (pt.x <  pWnd->rects.arcl[j].right) &&
                (pt.y >= pWnd->rects.arcl[j].top) &&
                (pt.y <  pWnd->rects.arcl[j].bottom))
            {
                TRACE_OUT((
                    "Pt {%d, %d}, in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pt.x, pt.y, pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Pt not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd->hwnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputIsHosted, rc);
    return(rc);
}


//
// HET_DDOutputRectIsHosted - see host.h
//
BOOL HET_DDOutputRectIsHosted(LPRECT pRect)
{
    BOOL              rc = FALSE;
    UINT              j;
    LPHET_WINDOW_STRUCT  pWnd;
    RECT              rectIntersect;

    DebugEntry(HET_DDOutputRectIsHosted);

    //
    // Now check to see if the desktop is shared - if it is then simply
    // return TRUE.
    //
    if (g_hetDDDesktopIsShared)
    {
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Search through the window list
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // Search each enumerated rectangle
        //
        TRACE_OUT(( "Window %#x has %u rectangle(s)",
                pWnd, pWnd->rects.c));
        for (j = 0; j < pWnd->rects.c; j++)
        {
            //
            // See whether the rect passed in intersects this rectangle.
            // Note that at this point we are dealing with exclusive
            // co-ordinates.
            //
            rectIntersect.left = max( pRect->left,
                                         pWnd->rects.arcl[j].left );
            rectIntersect.top = max( pRect->top,
                                        pWnd->rects.arcl[j].top );
            rectIntersect.right = min( pRect->right,
                                          pWnd->rects.arcl[j].right );
            rectIntersect.bottom = min( pRect->bottom,
                                           pWnd->rects.arcl[j].bottom );

            //
            // If the intersection rectangle is well-ordered and non-NULL
            // then we have an intersection.
            //
            // The rects that we are dealing with are exclusive.
            //
            if ((rectIntersect.left < rectIntersect.right) &&
                (rectIntersect.top < rectIntersect.bottom))
            {
                TRACE_OUT((
             "Rect  {%d, %d, %d, %d} intersects win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom,
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

                //
                // Found it!  Re-order the list, most recently used first
                //
                COM_BasedListRemove(&(pWnd->chain));
                COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

                //
                // Stop looking
                //
                rc = TRUE;
                DC_QUIT;
            }

            TRACE_OUT(( "Rect not in win %#x rect %u {%ld, %ld, %ld, %ld}",
                    pWnd, j,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].right,
                    pWnd->rects.arcl[j].top, pWnd->rects.arcl[j].bottom ));

        } // for all rectangles

        //
        // Move on to next window
        //
        pWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

DC_EXIT_POINT:
    DebugExitBOOL(HET_DDOutputRectIsHosted, rc);
    return(rc);
}


//
//
// Name:        HETDDVisRgnCallback
//
// Description: WNDOBJ Callback
//
// Params:      pWo - pointer to the WNDOBJ which has changed
//              fl  - flags (se NT DDK documentation)
//
// Returns:     none
//
// Operation:
//
//
VOID CALLBACK HETDDVisRgnCallback(PWNDOBJ pWo, FLONG fl)
{
    ULONG               count;
    int               size;
    LPHET_WINDOW_STRUCT  pWnd;
    RECTL             rectl;
    UINT              i;

    DebugEntry(HETDDVisRgnCallback);

    //
    // Some calls pass a NULL pWo - exit now in this case
    //
    if (pWo == NULL)
    {
        DC_QUIT;
    }

    //
    // Find the window structure for this window
    //
    pWnd = pWo->pvConsumer;
    if (pWnd == NULL)
    {
        ERROR_OUT(( "Wndobj %x (fl %x) has no window structure", pWo, fl));
        DC_QUIT;
    }

    //
    // Check for window deletion
    //
    if (fl & WOC_DELETE)
    {
        TRACE_OUT(( "Wndobj %x (structure %x) deleted", pWo, pWo->pvConsumer));

        // ASSERT the window is valid
        ASSERT(pWnd->hwnd != NULL);

        //
        // Move the window from the active to the free list
        //
        COM_BasedListRemove(&(pWnd->chain));
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pWnd->chain));

#ifdef DEBUG
        // Check if this has reentrancy problems
        pWnd->hwnd = NULL;
#endif

        //
        // Do any processing if this is the last window to be unshared.
        //
        // If we are not keeping track of any windows, the first pointer in
        // the list will point to itself, ie list head->next == 0
        //
        if (g_hetWindowList.next == 0)
        {
            HETDDViewing(NULL, FALSE);
        }

        //
        // Exit now
        //
        DC_QUIT;
    }

    //
    // If we get here, this callback must be for a new visible region on a
    // tracked window.
    //

    //
    // Start the enumeration.  This function is supposed to count the
    // rectangles, but it always returns 0.
    //
    WNDOBJ_cEnumStart(pWo, CT_RECTANGLES, CD_ANY, 200);

    //
    // BOGUS BUGBUG LAURABU (perf opt for NT):
    //
    // NT will enum up to HET_WINDOW_RECTS at a time.  Note that the enum
    // function returns FALSE if, after obtaining the current batch, none
    // are left to grab the next time.
    //
    // If the visrgn is composed of more than that, we will wipe out the 
    // previous set of rects, then ensure that the bounding box of the 
    // preceding rects is the last rect in the list.
    //
    // This pulls in several cases.  For example if there are n visrgn piece
    // rects, and n == c*HET_WINDOW_RECTS + 1, we will end up with 2 entries:
    //      * The last piece rect
    //      * The bounding box of the previous n-1 piece rects 
    // A lot of output may be accumulated in deadspace as a result.
    //
    // A better algorithm may be to fill the first HET_WINDOW_RECTS-1 slots,
    // then union the rest into the last rectangle.  That way we make use of
    // all the slots.  But this could be awkward, since we need a scratch
    // ENUM_RECT struct rather than using the HET_WINDOW_STRUCT directly.
    //

    //
    // First time through, enumerate HET_WINDOW_RECTS rectangles.
    // Subsequent times, enumerate HET_WINDOW_RECTS-1 (see bottom of loop).
    // This guarantees that there will be room to store a combined
    // rectangle when we finally finish enumerating them.
    //
    pWnd->rects.c = HET_WINDOW_RECTS;
    rectl.left   = LONG_MAX;
    rectl.top    = LONG_MAX;
    rectl.right  = 0;
    rectl.bottom = 0;

    //
    // Enumerate the rectangles
    // NOTE that WNDOBJ_bEnum returns FALSE when there is nothing left
    // to enumerate AFTER grabbing this set.
    //

    while (WNDOBJ_bEnum(pWo, sizeof(pWnd->rects), (ULONG *)&pWnd->rects))
    {
#ifdef _DEBUG
        {
            char    trcStr[200];
            UINT    j;

            sprintf(trcStr, "WNDOBJ %p %d: ", pWo, pWnd->rects.c);

            for (j = 0; j < pWnd->rects.c; j++)
            {
                sprintf(trcStr, "%s {%ld, %ld, %ld, %ld} ", trcStr,
                    pWnd->rects.arcl[j].left, pWnd->rects.arcl[j].top,
                    pWnd->rects.arcl[j].right, pWnd->rects.arcl[j].bottom);
                if ((j & 3) == 3)       // output every 4th rect
                {
                    TRACE_OUT(( "%s", trcStr));
                    strcpy(trcStr, "                ");
                }
            }
            if ((j & 3) != 0)           // if any rects left
            {
                TRACE_OUT(( "%s", trcStr));
            }
        }
#endif

        //
        // Combine the preceding rectangles into one bounding rectangle
        //
        for (i = 0; i < pWnd->rects.c; i++)
        {
            if (pWnd->rects.arcl[i].left < rectl.left)
            {
                rectl.left = pWnd->rects.arcl[i].left;
            }
            if (pWnd->rects.arcl[i].top < rectl.top)
            {
                rectl.top = pWnd->rects.arcl[i].top;
            }
            if (pWnd->rects.arcl[i].right > rectl.right)
            {
                rectl.right = pWnd->rects.arcl[i].right;
            }
            if (pWnd->rects.arcl[i].bottom > rectl.bottom)
            {
                rectl.bottom = pWnd->rects.arcl[i].bottom;
            }
        }
        TRACE_OUT(( "Combined into {%ld, %ld, %ld, %ld}",
                rectl.left, rectl.top, rectl.right, rectl.bottom));

        //
        // Second & subsequent times, enumerate HET_WINDOW_RECTS-1
        //
        pWnd->rects.c = HET_WINDOW_RECTS - 1;
    }

    //
    // If any combining was done, save the combined rectangle now.
    //
    if (rectl.right != 0)
    {
        pWnd->rects.arcl[pWnd->rects.c] = rectl;
        pWnd->rects.c++;
        TRACE_OUT(( "Add combined rectangle to list"));
    }

    //
    // On the assumption that this WNDOBJ is the most likely to be the
    // target of the next output command, move it to the top of the list.
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(HETDDVisRgnCallback);
}


//
//
// Name:        HETDDShareWindow
//
// Description: Share a window (DD processing)
//
// Params:      pso      - SURFOBJ
//              pReq     - request received from DrvEscape
//
//
BOOL HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq)
{
    PWNDOBJ            pWo;
    FLONG              fl = WO_RGN_CLIENT | WO_RGN_UPDATE_ALL | WO_RGN_WINDOW;
    LPHET_WINDOW_STRUCT pWnd;
    BOOL                rc = FALSE;

    DebugEntry(HETDDShareWindow);

    ASSERT(!g_hetDDDesktopIsShared);

    //
    // Try to track the window
    //
    pWo = EngCreateWnd(pso, (HWND)pReq->winID, HETDDVisRgnCallback, fl, 0);

    //
    // Failed to track window - exit now
    //
    if (pWo == 0)
    {
        ERROR_OUT(( "Failed to track window %#x", pReq->winID));
        DC_QUIT;
    }

    //
    // Window is already tracked.  This happens when an invisible window is
    // shown in a process the USER shared, and we caught its create.
    //
    if (pWo == (PWNDOBJ)-1)
    {
        //
        // No more to do here
        //
        TRACE_OUT(( "Window %#x already tracked", pReq->winID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Add window into our list.
    //

    //
    // Find free window structure
    //
    pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

    //
    // If no free structures, grow the list
    //
    if (pWnd == NULL)
    {
        if (!HETDDAllocWndMem())
        {
            ERROR_OUT(( "Unable to allocate new window structures"));
            DC_QUIT;
        }

        pWnd = COM_BasedListFirst(&g_hetFreeWndList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    }

    //
    // Fill in the structure
    //
    TRACE_OUT(( "Fill in details for new window"));
    pWnd->hwnd     = (HWND)pReq->winID;
    pWnd->wndobj   = pWo;

    //
    // Set this to zero.  There's a brief period between the time we put
    // this in our tracked list and the time we get called back to recalc
    // the visrgn (because the ring 3 code invalidates the window completely).
    // We might get graphical output and we don't want to parse garbage
    // from this window's record.
    //
    pWnd->rects.c  = 0;

    //
    // Move the window structure from free to active list
    //
    COM_BasedListRemove(&(pWnd->chain));
    COM_BasedListInsertAfter(&g_hetWindowList, &(pWnd->chain));

    //
    // Save backwards pointer in the WNDOBJ
    // THIS MUST BE LAST since our callback can happen anytime afterwards.
    //
    // NOTE that the window's visrgn rects get into our list because the
    // ring3 code completely invalidates the window, causing the callback
    // to get called.
    //
    TRACE_OUT(( "Save pointer %#lx in Wndobj %#x", pWnd, pWo));
    WNDOBJ_vSetConsumer(pWo, pWnd);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDShareWindow, rc);
    return(rc);
}


//
//
// Name:        HETDDUnshareWindow
//
// Description: Unshare a window (DD processing)
//
//
//
void HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq)
{
    LPHET_WINDOW_STRUCT  pWnd, pNextWnd;

    DebugEntry(HETDDUnshareWindow);

    TRACE_OUT(( "Unshare %x", pReq->winID));
    //
    // Scan window list for this window and its descendants
    //
    pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));
    while (pWnd != NULL)
    {
        //
        // If this window is being unshared, free it
        //
        pNextWnd = COM_BasedListNext(&g_hetWindowList, pWnd, FIELD_OFFSET(HET_WINDOW_STRUCT, chain));

        if (pWnd->hwnd == (HWND)pReq->winID)
        {
            TRACE_OUT(( "Unsharing %x", pReq->winID));

            //
            // Stop tracking the window
            //
            HETDDDeleteAndFreeWnd(pWnd);
        }

        //
        // Go on to (previously saved) next window
        //
        pWnd = pNextWnd;
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareWindow);
}


//
//
// Name:        HETDDUnshareAll
//
// Description: Unshare all windows (DD processing) (what did you expect)
//
//
void HETDDUnshareAll(void)
{
    LPHET_WINDOW_STRUCT pWnd;

    DebugEntry(HETDDUnshareAll);

    //
    // Clear all window structures
    //
    while (pWnd = COM_BasedListFirst(&g_hetWindowList, FIELD_OFFSET(HET_WINDOW_STRUCT, chain)))
    {
        TRACE_OUT(( "Unshare Window structure %x", pWnd));

        //
        // Stop tracking the window
        //
        HETDDDeleteAndFreeWnd(pWnd);
    }

    //
    // Return to caller
    //
    DebugExitVOID(HETDDUnshareAll);
}


//
//
// Name:        HETDDAllocWndMem
//
// Description: Allocate memory for a (new) window list
//
// Parameters:  None
//
//
BOOL HETDDAllocWndMem(void)
{
    BOOL             rc = FALSE;
    int              i;
    LPHET_WINDOW_MEMORY pNew;

    DebugEntry(HETDDAllocWndMem);

    //
    // Allocate a new strucure
    //
    pNew = EngAllocMem(FL_ZERO_MEMORY, sizeof(HET_WINDOW_MEMORY), OSI_ALLOC_TAG);
    if (pNew == NULL)
    {
        ERROR_OUT(("HETDDAllocWndMem: unable to allocate memory"));
        DC_QUIT;
    }

    //
    // Add this memory block to the list of memory blocks
    //
    COM_BasedListInsertAfter(&g_hetMemoryList, &(pNew->chain));

    //
    // Add all new entries to free list
    //
    TRACE_OUT(("HETDDAllocWndMem: adding new entries to free list"));
    for (i = 0; i < HET_WINDOW_COUNT; i++)
    {
        COM_BasedListInsertAfter(&g_hetFreeWndList, &(pNew->wnd[i].chain));
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HETDDAllocWndMem, rc);
    return(rc);
}

//
//
// Name:        HETDDDeleteAndFreeWnd
//
// Description: Delete and window and free its window structure
//
// Parameters:  pWnd - pointer to window structure to delete & free
//
// Returns:     none
//
// Operation:   Ths function stops tracking a window and frees its memory
//
//
void HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd)
{
    DebugEntry(HETDDDeleteAndFreeWnd);

    //
    // Stop tracking the window
    //
    EngDeleteWnd(pWnd->wndobj);

    //
    // NOTE LAURABU!  EngDeleteWnd() will call the VisRgnCallback with
    // WO_DELETE, which will cause us to exectute a duplicate of exactly 
    // the code below.  So why do it twice (which is scary anyway), especially
    // the stop hosting code?
    //
    ASSERT(pWnd->hwnd == NULL);

    //
    // Return to caller
    //
    DebugExitVOID(HETDDDeleteAndFreeWnd);
}


//
// HETDDViewers()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing
(
    SURFOBJ *   pso,
    BOOL        fViewers
)
{
    DebugEntry(HETDDViewers);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        CM_DDViewing(pso, fViewers);

        if (g_oeViewers)
        {
            //
            // Force palette grab.
            //
            g_asSharedMemory->pmPaletteChanged = TRUE;
        }
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\sbc.c ===
#include "precomp.h"


//
// SBC.C
// Send Bitmap Cache, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
//
// SBC_DDProcessRequest() - see sbc.h
//
//
BOOL SBC_DDProcessRequest
(
    SURFOBJ*  pso,
    DWORD     fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD     cbResult
)
{
    BOOL            rc;
    LPOSI_PDEV      ppDev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(SBC_DDProcessRequest);

    //
    // Get the request number.
    //
    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            if (cbResult != sizeof(SBC_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SBC_DDProcessRequest:  Invalid size %d for SBC_ESC_NEW_CAPABILITIES",
                    cbResult));
                rc = FALSE;
                DC_QUIT;
            }
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pRequest);

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}


//
//
// SBC_DDInit() - see sbc.h
//
//
BOOL SBC_DDInit
(
    LPOSI_PDEV  ppDev,
    LPBYTE      pRestOfMemory,
    DWORD       cbRestOfMemory,
    LPOSI_INIT_REQUEST   pResult
)
{
    UINT    i;
    SIZEL   bitmapSize;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

    //
    // We have to create work DIBs to Blt into when SBC_CacheMemScreenBlt
    // is called.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(!g_asbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_asbcWorkInfo[i].mruIndex);
        ASSERT(!g_asbcWorkInfo[i].workBitmap);

        if (i == SBC_MEDIUM_TILE_INDEX)
        {
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth = MP_MEDIUM_TILE_WIDTH;
            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight = MP_MEDIUM_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = MP_LARGE_TILE_WIDTH;
            g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = MP_LARGE_TILE_HEIGHT;
        }

        //
        // Create the bitmap.  Note that we create it "top down" rather
        // than the default of "bottom up" to simplify copying data from
        // the bitmap (we don't have to work out offsets into the data - we
        // can copy from the beginning).
        //
        // We set the last parameter to NULL, to allow GDI to allocate
        // memory for the bits.  We can get a pointer to the bits later
        // when we have a SURFOBJ for the bitmap.
        //
        bitmapSize.cx = g_asbcWorkInfo[i].tileWidth;
        bitmapSize.cy = g_asbcWorkInfo[i].tileHeight;

        g_asbcWorkInfo[i].workBitmap = EngCreateBitmap(bitmapSize,
            BYTES_IN_BITMAP(g_asbcWorkInfo[i].tileWidth, 1, ppDev->cBitsPerPel),
            ppDev->iBitmapFormat, BMF_TOPDOWN, NULL);

        if (! g_asbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(( "Failed to create work bitmap %d", i));
            DC_QUIT;
        }
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers(ppDev, pRestOfMemory, cbRestOfMemory))
    {
        ERROR_OUT(( "Failed to create shunt buffers"));
        DC_QUIT;
    }

    //
    // Set up the remaining global variables
    //
    EngQueryPerformanceFrequency(&g_sbcPerfFrequency);

    //
    // OK, so we can create our SBC cache.  Fill in the details.
    //

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        //
        // This is filling in the APP address to the shunt buffers.
        //
        pResult->psbcTileData[i] = (LPBYTE)pResult->pSharedMemory +
            PTRBASE_TO_OFFSET(g_asbcWorkInfo[i].pShuntBuffer, g_asSharedMemory);
    }

    pResult->aBitmasks[0] = ppDev->flRed;
    pResult->aBitmasks[1] = ppDev->flGreen;
    pResult->aBitmasks[2] = ppDev->flBlue;

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so that we will send a color table to
    // the share core before our first Mem(3)Blt.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    rc = TRUE;
DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}


//
//
// SBC_DDTerm() - see sbc.h
//
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

    //
    // We just have to set the pointers to the shunt buffers to NULL
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if there
        if (g_asbcWorkInfo[i].workBitmap)
        {
            EngDeleteSurface((HSURF)g_asbcWorkInfo[i].workBitmap);
            g_asbcWorkInfo[i].workBitmap = 0;
        }

        g_asbcWorkInfo[i].pShuntBuffer = NULL;
        g_asbcWorkInfo[i].mruIndex        = 0;
    }

    DebugExitVOID(SBC_DDTerm);
}


//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo)
{
    BOOL            rc = FALSE;
    UINT            tileWidth;
    UINT            tileHeight;
    SURFOBJ *       pSourceSurf;

    DebugEntry(SBC_DDIsMemScreenBltCachable);

    //
    // Is this an RLE bitmap - these bitmaps can have effective transparent
    // sections which we cannot mimic with SBC.
    //
    pSourceSurf = pMemBltInfo->pSource;
    if ( (pSourceSurf->iBitmapFormat == BMF_4RLE) ||
         (pSourceSurf->iBitmapFormat == BMF_8RLE) )
    {
        TRACE_OUT(( "RLE Bitmap %d", pSourceSurf->iBitmapFormat));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (SBCDDIsBitmapThrasher(pSourceSurf))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Make sure that this bitmap can be tiled OK
    //
    if (!SBC_DDQueryBitmapTileSize(pSourceSurf->sizlBitmap.cx,
                                   pSourceSurf->sizlBitmap.cy,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER         pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   pMemBltInfo
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINTL              tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    UINT                type;
    SURFOBJ *           pDestSurf;
    SURFOBJ *           pSourceSurf;
    LPOSI_PDEV          pDestDev;
    SURFOBJ *           pWorkSurf = NULL;
    LPBYTE              pWorkBits;
    RECTL               destRectl;
    POINTL              sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(pMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //

    if (!SBC_DDQueryBitmapTileSize(bmpWidth, bmpHeight, &tileWidth, &tileHeight))
    {
        TRACE_OUT(("Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize = 0; tileSize < SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_asbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_asbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_asbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_asbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = (WORD)cxSubBitmapWidth;
    pTileData->height         = (WORD)cySubBitmapHeight;
    pTileData->tilingWidth    = (WORD)tileWidth;
    pTileData->tilingHeight   = (WORD)tileHeight;
    pTileData->majorCacheInfo = (UINT_PTR)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT_PTR)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_asbcWorkInfo[tileSize].tileWidth,
                 g_asbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);
}



//
// SBC_DDQueryBitmapTileSize()
//
// Once 2.X COMPAT is gone, we don't need this anymore.  We won't set our
// random cell sizes based off of what REMOTES say.
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT    bmpWidth,
    UINT    bmpHeight,
    UINT *  pTileWidth,
    UINT *  pTileHeight
)
{
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are currently changed when back level nodes
    // join in a 3.0 call, in which case we must take the MINIMUM of the
    // cell sizes/entries for everybody in the share.
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
            BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth,
                            g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight,
                            g_sbcSendingBPP))
    {
        //
        // This should be a short-term thing.  When an old dude joins the
        // share, we'll also adjust g_sbcSendingBPP.
        //
        TRACE_OUT(("SBC_DDQueryBitmapTileSize:  No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If the large size is adequate, use that cell size
    //
    if (g_asbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        BYTES_IN_BITMAP(g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth,
                        g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight,
                        g_sbcSendingBPP))
    {
        if ((bmpWidth > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth) ||
            (bmpHeight > g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight))
        {
            *pTileWidth = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth;
            *pTileHeight = g_asbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight;
            DC_QUIT;
        }
    }

    //
    // Sigh, medium cells it is.
    //
    *pTileWidth = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileWidth;
    *pTileHeight = g_asbcWorkInfo[SBC_MEDIUM_TILE_INDEX].tileHeight;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}




//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        for (j = 0; j < g_asbcWorkInfo[i].pShuntBuffer->numEntries ; j++)
        {
            pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[i].pShuntBuffer, j);
            pTileData->inUse = FALSE;
        }

        //
        // Reset the MRU counter for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    ppDev->paletteChanged = (ppDev->cBitsPerPel <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type = ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_asbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_asbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_asbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER                  pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (ppDev->cBitsPerPel > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!ppDev->paletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (ppDev->cBitsPerPel)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", ppDev->cBitsPerPel));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = (TSHR_UINT16)ppDev->cBitsPerPel;

    //
    // Unfortunately we can't just copy the palette from the PDEV into the
    // color table order because the PDEV has an array of PALETTEENTRY
    // structures which are RGBs whereas the order has an array of
    // TSHR_RGBQUADs which are BGRs...
    //
    numColors = COLORS_FOR_BPP(ppDev->cBitsPerPel);
    ASSERT(numColors);

    for (i = 0; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    ppDev->paletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}





//
// SBCDDCreateShuntBuffers()
//
// Here's where we calc how many cache entries (tiles) we can support.  This
// depends on:
//      * The amount of shared memory we have
//      * The color depth of the driver
//
// There is an upper bound on the amount of memory we'll use, since this
// maps to how much memory on remotes will be needed to store our sent
// cache entries.
//
// The tiles are created in a fixed proportion (MP_RATIO_MTOL).
//
// We return TRUE for success if we can set up the caches and create the
// objects necessary for a sent bitmap cache.
//
BOOL SBCDDCreateShuntBuffers
(
    LPOSI_PDEV  ppDev,
    LPBYTE      psbcSharedMemory,
    DWORD       sbcSharedMemorySize
)
{
    int     i;
    UINT    memPerBuffer[SBC_NUM_TILE_SIZES];
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numTiles[SBC_NUM_TILE_SIZES];
    UINT    memRequired;
    LPBYTE  pBuffer        = psbcSharedMemory;
    BOOL    rc             = FALSE;

    DebugEntry(SBCDDCreateShuntBuffers);

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    //
    // First make sure that we have some shared memory
    //
    if (sbcSharedMemorySize == 0)
    {
        ERROR_OUT(( "No SBC shared memory !"));
        DC_QUIT;
    }

    // Max out at MP_MEMORY_MAX bytes
    sbcSharedMemorySize = min(sbcSharedMemorySize, MP_MEMORY_MAX);

    //
    // Do we have enough shared memory to satisfy the requested number of
    // entries in each shunt buffer ?
    //
    memRequired = 0;

    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        memPerTile[i] = SBC_BYTES_PER_TILE(g_asbcWorkInfo[i].tileWidth,
                                           g_asbcWorkInfo[i].tileHeight,
                                           ppDev->cBitsPerPel);

        // We use the same amount of memory for each tile size.
        numTiles[i] = ((sbcSharedMemorySize / SBC_NUM_TILE_SIZES) -
                         (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA))) /
                        memPerTile[i];
        TRACE_OUT(("Can fit %d tiles of memory size %d in tile cache %d",
            numTiles[i], memPerTile[i], i));

        memPerBuffer[i] = (numTiles[i] * memPerTile[i]) +
                          (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA));
        memRequired    += memPerBuffer[i];
    }

    TRACE_OUT(( "%d bytes required for request, %d bytes available",
                 memRequired,
                 sbcSharedMemorySize));

    ASSERT(memRequired <= sbcSharedMemorySize);

    // Zero out rest of amount we're going to use
    RtlFillMemory(psbcSharedMemory, memRequired, 0);


    //
    // OK, we've got the
    //   - the bytes per tile in memPerTile[i]
    //   - number of entries per shunt buffer in numTiles[i]
    //   - the total size of each shunt buffer in memPerBuffer[i].
    //
    // Do the partitioning.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        g_asbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)pBuffer;

        g_asbcWorkInfo[i].pShuntBuffer->numEntries    = numTiles[i];
        g_asbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_asbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Move the buffer pointer past the memory we are using for this
        // shunt buffer.
        //
        pBuffer += memPerBuffer[i];

        TRACE_OUT(( "Shunt buffer %d at %#.8lx: tile bytes %u, "
                     "structure size %u, num entries %u",
                     i,
                     g_asbcWorkInfo[i].pShuntBuffer,
                     g_asbcWorkInfo[i].pShuntBuffer->numBytes,
                     g_asbcWorkInfo[i].pShuntBuffer->structureSize,
                     g_asbcWorkInfo[i].pShuntBuffer->numEntries));

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_asbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    //
    // Must be OK to get to here
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_MEDIUM_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    //
    // Make sure that we have a valid tile size
    //
    if (tileSize >= SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "Invalid tile size %d", tileSize));
        DC_QUIT;
    }

    //
    // Get a pointer to the next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileSize].pShuntBuffer,
                                        g_asbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_asbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_MEDIUM_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_asbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_asbcWorkInfo[tileSize].mruIndex = (g_asbcWorkInfo[tileSize].mruIndex + 1) %
                               g_asbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
//
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (g_sbcThrashers[i].hsurf == pSurfObj->hsurf)
        {
            bitmapInList = TRUE;

            if (g_sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             g_sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - g_sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                g_sbcThrashers[i].tickCount = nextTickCount;
                g_sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
        {
            if (evictTickCount > g_sbcThrashers[i].tickCount)
            {
                evictTickCount = g_sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     g_sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        g_sbcThrashers[updateIndex] = g_sbcThrashers[0];

        g_sbcThrashers[0].hsurf     = pSurfObj->hsurf;
        g_sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        g_sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
//
DWORD SBCDDGetTickCount(void)
{
    DWORD       tickCount;
    LONGLONG    perfTickCount;

    DebugEntry(SBCDDGetTickCount);

    //
    // Get the number of system ticks since the system was started.
    //
    EngQueryPerformanceCounter(&perfTickCount);

    //
    // Now convert this into a number of centi-seconds.  g_sbcPerfFrequency
    // contains the number of system ticks per second.
    //
    tickCount = (DWORD)((100 * perfTickCount) / g_sbcPerfFrequency);

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    g_sbcSendingBPP     = pCapabilities->sendingBpp;
    memcpy(&g_asbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_asbcCacheInfo));

    DebugExitVOID(SBCSetNewCapabilities);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\osi.c ===
#include "precomp.h"


//
// OSI.C
// OS Isolation layer, display driver side
//
// Copyright(c) Microsoft 1997-
//


#include <version.h>
#include <ndcgver.h>


//
// These are the default 20 Windows colors, lifted from the base S3 driver.
//
// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.
const PALETTEENTRY s_aWinColors[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};



//
// Functions supported by our Display Driver.  Each entry is of the form:
//
//  index    - NT DDK defined index for the DDI function
//
//  function - pointer to our intercept function
//
//
const DRVFN s_osiDriverFns[] =
{
    //
    // NT4 FUNCTIONS
    //
    { INDEX_DrvEnablePDEV,        (PFN)DrvEnablePDEV        },
    { INDEX_DrvCompletePDEV,      (PFN)DrvCompletePDEV      },
    { INDEX_DrvDisablePDEV,       (PFN)DrvDisablePDEV       },
    { INDEX_DrvEnableSurface,     (PFN)DrvEnableSurface     },
    { INDEX_DrvDisableSurface,    (PFN)DrvDisableSurface    },

    { INDEX_DrvAssertMode,        (PFN)DrvAssertMode        },
    { INDEX_DrvResetPDEV,         (PFN)DrvResetPDEV         },
        // INDEX_DrvCreateDeviceBitmap  not used
        // INDEX_DrvDeleteDeviceBitmap  not used
    { INDEX_DrvRealizeBrush,      (PFN)DrvRealizeBrush      },
        // INDEX_DrvDitherColor         not used
    { INDEX_DrvStrokePath,        (PFN)DrvStrokePath        },
    { INDEX_DrvFillPath,          (PFN)DrvFillPath          },

    { INDEX_DrvStrokeAndFillPath, (PFN)DrvStrokeAndFillPath },
    { INDEX_DrvPaint,             (PFN)DrvPaint             },
    { INDEX_DrvBitBlt,            (PFN)DrvBitBlt            },
    { INDEX_DrvCopyBits,          (PFN)DrvCopyBits          },
    { INDEX_DrvStretchBlt,        (PFN)DrvStretchBlt        },

    { INDEX_DrvSetPalette,        (PFN)DrvSetPalette        },
    { INDEX_DrvTextOut,           (PFN)DrvTextOut           },
    { INDEX_DrvEscape,            (PFN)DrvEscape            },
        // INDEX_DrvDrawEscape          not used
        // INDEX_DrvQueryFont           not used
        // INDEX_DrvQueryFontTree       not used
        // INDEX_DrvQueryFontData       not used
    { INDEX_DrvSetPointerShape,   (PFN)DrvSetPointerShape   },
    { INDEX_DrvMovePointer,       (PFN)DrvMovePointer       },

    { INDEX_DrvLineTo,            (PFN)DrvLineTo            },
        // INDEX_DrvSendPage            not used
        // INDEX_DrvStartPage           not used
        // INDEX_DrvEndDoc              not used
        // INDEX_DrvStartDoc            not used
        // INDEX_DrvGetGlyphMode        not used
        // INDEX_DrvSynchronize         not used
    { INDEX_DrvSaveScreenBits,    (PFN)DrvSaveScreenBits    },
    { INDEX_DrvGetModes,          (PFN)DrvGetModes          },
        // INDEX_DrvFree                not used
        // INDEX_DrvDestroyFont         not used
        // INDEX_DrvQueryFontCaps       not used
        // INDEX_DrvLoadFontFile        not used
        // INDEX_DrvUnloadFontFile      not used
        // INDEX_DrvFontManagement      not used
        // INDEX_DrvQueryTrueTypeTable  not used
        // INDEX_DrvQueryTrueTypeOutline    not used
        // INDEX_DrvGetTrueTypeFile     not used
        // INDEX_DrvQueryFontFile       not used
        // INDEX_DrvQueryAdvanceWidths  not used
        // INDEX_DrvSetPixelFormat      not used
        // INDEX_DrvDescribePixelFormat not used
        // INDEX_DrvSwapBuffers         not used
        // INDEX_DrvStartBanding        not used
        // INDEX_DrvNextBand            not used
        // INDEX_DrvGetDirectDrawInfo   not used
        // INDEX_DrvEnableDirectDraw    not used
        // INDEX_DrvDisableDirectDraw   not used
        // INDEX_DrvQuerySpoolType      not used

    //
    // NT5 FUNCTIONS - 5 of them currently.  If you add to this list,
    // update CFN_NT5 below.
    //
        // INDEX_DrvIcmCreateColorTransform not used
        // INDEX_DrvIcmDeleteColorTransform not used
        // INDEX_DrvIcmCheckBitmapBits  not used
        // INDEX_DrvIcmSetDeviceGammaRamp   not used
    { INDEX_DrvGradientFill,      (PFN)DrvGradientFill      },
    { INDEX_DrvStretchBltROP,     (PFN)DrvStretchBltROP     },

    { INDEX_DrvPlgBlt,            (PFN)DrvPlgBlt            },
    { INDEX_DrvAlphaBlend,        (PFN)DrvAlphaBlend        },
        // INDEX_DrvSynthesizeFont      not used
        // INDEX_DrvGetSynthesizedFontFiles not used
    { INDEX_DrvTransparentBlt,    (PFN)DrvTransparentBlt    },
        // INDEX_DrvQueryPerBandInfo    not used
        // INDEX_DrvQueryDeviceSupport  not used
        // INDEX_DrvConnect             not used
        // INDEX_DrvDisconnect          not used
        // INDEX_DrvReconnect           not used
        // INDEX_DrvShadowConnect       not used
        // INDEX_DrvShadowDisconnect    not used
        // INDEX_DrvInvalidateRect      not used
        // INDEX_DrvSetPointerPos       not used
        // INDEX_DrvDisplayIOCtl        not used
        // INDEX_DrvDeriveSurface       not used
        // INDEX_DrvQueryGlyphAttrs     not used
};


#define CFN_NT5         5



//
// s_osiDefaultGdi
//
// This contains the default GDIINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//       It is expected that DDML ignores a lot of these parameters and
//       uses the values from the primary driver instead
//

const GDIINFO s_osiDefaultGdi =
{
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    400,                    // ulHorzSize (display width: mm)
    300,                    // ulVertSize (display height: mm)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    1,                      // cPlanes
    (ULONG)-1,              // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)
    96,                     // ulLogPixelsX (filled in later)
    96,                     // ulLogPixelsY (filled in later)
    TC_RA_ABLE,             // flTextCaps - If we had wanted console windows
                        // to scroll by repainting the entire window,
                        // instead of doing a screen-to-screen blt, we
                        // would have set TC_SCROLLBLT (yes, the flag
                        // is backwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)
    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)
    1,                      // xStyleStep
    1,                      // yStyleStep
    3,                      // denStyleStep -- Styles have a one-to-one
                            // aspect ratio, and every dot is 3 pixels long
    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize
    0,                      // ulNumPalReg

    {
        { 6700, 3300, 0 },   //      Red
        { 2100, 7100, 0 },   //      Green
        { 1400,  800, 0 },   //      Blue
        { 1750, 3950, 0 },   //      Cyan
        { 4050, 2050, 0 },   //      Magenta
        { 4400, 5200, 0 },   //      Yellow
        { 3127, 3290, 0 },   //      AlignmentWhite
        20000,               //      RedGamma
        20000,               //      GreenGamma
        20000,               //      BlueGamma
        0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};


//
// s_osiDefaultDevInfo
//
// This contains the default DEVINFO fields that are passed back to GDI
// during DrvEnablePDEV.
//
// NOTE: This structure defaults to values for an 8bpp palette device.
//       Some fields are overwritten for different colour depths.
//
//
const DEVINFO s_osiDefaultDevInfo =
{
    {
        GCAPS_OPAQUERECT       |
        GCAPS_DITHERONREALIZE  |
        GCAPS_PALMANAGED       |
        GCAPS_MONO_DITHER      |
        GCAPS_COLOR_DITHER     |
        GCAPS_LAYERED
    },                          // NOTE: Only enable ASYNCMOVE if your code
                            //   and hardware can handle DrvMovePointer
                            //   calls at any time, even while another
                            //   thread is in the middle of a drawing
                            //   call such as DrvBitBlt.

                            // flGraphicsFlags
    {   16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"System"
    },
                            // lfDefaultFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        VARIABLE_PITCH | FF_DONTCARE, L"MS Sans Serif"
    },
                            // lfAnsiVarFont

    {
        12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,
        CLIP_STROKE_PRECIS,PROOF_QUALITY,
        FIXED_PITCH | FF_DONTCARE, L"Courier"
    },
                            // lfAnsiFixFont

    0,                          // cFonts
    BMF_8BPP,                   // iDitherFormat
    8,                          // cxDither
    8,                          // cyDither
    0                           // hpalDefault (filled in later)
};



//
// DrvEnableDriver - see NT DDK documentation.
//
// This is the only directly exported entry point to the display driver.
// All other entry points are exported through the data returned from this
// function.
//
BOOL DrvEnableDriver
(
    ULONG          iEngineVersion,
    ULONG          cj,
    DRVENABLEDATA* pded
)
{
    DebugEntry(DrvEnableDriver);

    INIT_OUT(("DrvEnableDriver(iEngineVersion = 0x%08x)", iEngineVersion));

    //
    // Check that the engine version is correct - we refuse to load on
    // other versions because we will almost certainly not work.
    //
    if ((iEngineVersion != DDI_DRIVER_VERSION_SP3) &&
        (iEngineVersion != DDI_DRIVER_VERSION_NT5))
    {
        INIT_OUT(("DrvEnableDriver: Not NT 4.0 SP-3 or NT 5.0; failing enable"));
        return(FALSE);
    }

    //
    // Fill in as much as we can.  Start with the entry points.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, pdrvfn) +
               FIELD_SIZE  (DRVENABLEDATA, pdrvfn) )
    {
        pded->pdrvfn = (DRVFN *)s_osiDriverFns;
    }

    //
    // Size of our entry point array.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, c) +
               FIELD_SIZE  (DRVENABLEDATA, c) )
    {
        //
        // If this is NT4, return back a subset -- it doesn't like tables
        // with unknown indeces
        //
        pded->c = sizeof(s_osiDriverFns) / sizeof(s_osiDriverFns[0]);
        if (iEngineVersion != DDI_DRIVER_VERSION_NT5)
        {
            pded->c -= CFN_NT5;
        }
        INIT_OUT(("DrvEnableDriver: Returning driver function count %u", pded->c));
    }

    //
    // DDI version this driver was targeted for is passed back to engine.
    // Future graphics engines may break calls down to old driver format.
    //
    if ( cj >= FIELD_OFFSET(DRVENABLEDATA, iDriverVersion) +
               FIELD_SIZE  (DRVENABLEDATA, iDriverVersion) )
    {
        //
        // Return back NT5 when we're on NT5.  Hopefully this will work
        // OK...
        //
        pded->iDriverVersion = iEngineVersion;
        INIT_OUT(("DrvEnableDriver: Returning driver version 0x%08x", pded->iDriverVersion));
    }

    DebugExitVOID(DrvEnableDriver);
    return(TRUE);
}


//
// DrvDisableDriver - see NT DDK documentation.
//
VOID DrvDisableDriver(VOID)
{
    DebugEntry(DrvDisableDriver);

    DebugExitVOID(DrvDisableDriver);
}


//
// DrvEnablePDEV - see NT DDK documentation.
//
// Initializes a bunch of fields for GDI, based on the mode we've been
// asked to do.  This is the first thing called after DrvEnableDriver, when
// GDI wants to get some information about us.
//
// (This function mostly returns back information; DrvEnableSurface is used
// for initializing the hardware and driver components.)
//
//
DHPDEV DrvEnablePDEV(DEVMODEW*   pdm,
                     PWSTR       pwszLogAddr,
                     ULONG       cPat,
                     HSURF*      phsurfPatterns,
                     ULONG       cjCaps,
                     ULONG*      pdevcaps,
                     ULONG       cjDevInfo,
                     DEVINFO*    pdi,
                     HDEV        hdev,
                     PWSTR       pwszDeviceName,
                     HANDLE      hDriver)
{
    DHPDEV    rc = NULL;
    LPOSI_PDEV ppdev = NULL;
    GDIINFO   gdiInfoNew;

    DebugEntry(DrvEnablePDEV);

    INIT_OUT(("DrvEnablePDEV: Parameters:"));
    INIT_OUT(("     PWSTR       pdm->dmDeviceName %ws", pdm->dmDeviceName));
    INIT_OUT(("     HDEV        hdev            0x%08x", hdev));
    INIT_OUT(("     PWSTR       pwszDeviceName  %ws", pwszDeviceName));
    INIT_OUT(("     HANDLE      hDriver         0x%08x", hDriver));

    //
    // This function only sets up local data, so shared memory protection
    // is not required.
    //

    //
    // Make sure that we have large enough data to reference.
    //
    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        ERROR_OUT(( "Buffer size too small %lu %lu", cjCaps, cjDevInfo));
        DC_QUIT;
    }

    //
    // Allocate a physical device structure.
    //
    ppdev = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_PDEV), OSI_ALLOC_TAG);
    if (ppdev == NULL)
    {
        ERROR_OUT(( "DrvEnablePDEV - Failed EngAllocMem"));
        DC_QUIT;
    }

    ppdev->hDriver = hDriver;

    //
    // Set up the current screen mode information based upon the supplied
    // mode settings.
    //
    if (!OSIInitializeMode((GDIINFO *)pdevcaps,
                                 pdm,
                                 ppdev,
                                 &gdiInfoNew,
                                 pdi))
    {
        ERROR_OUT(( "Failed to initialize mode"));
        DC_QUIT;
    }

    memcpy(pdevcaps, &gdiInfoNew, min(sizeof(GDIINFO), cjCaps));

    INIT_OUT(("DrvEnablePDEV: Returning DEVINFO:"));
    INIT_OUT(("     FLONG       flGraphicsCaps  0x%08x", pdi->flGraphicsCaps));
    INIT_OUT(("     ULONG       iDitherFormat   %d",     pdi->iDitherFormat));
    INIT_OUT(("     HPALETTE    hpalDefault     0x%08x", pdi->hpalDefault));

    INIT_OUT(("DrvEnablePDEV: Returning GDIINFO (pdevcaps):"));
    INIT_OUT(("     ULONG       ulVersion       0x%08x",    gdiInfoNew.ulVersion));
    INIT_OUT(("     ULONG       ulHorzSize      %d",    gdiInfoNew.ulHorzSize));
    INIT_OUT(("     ULONG       ulVertSize      %d",    gdiInfoNew.ulVertSize));
    INIT_OUT(("     ULONG       ulHorzRes       %d",    gdiInfoNew.ulHorzRes));
    INIT_OUT(("     ULONG       ulVertRes       %d",    gdiInfoNew.ulVertRes));
    INIT_OUT(("     ULONG       cBitsPixel      %d",    gdiInfoNew.cBitsPixel));
    INIT_OUT(("     ULONG       cPlanes         %d",    gdiInfoNew.cPlanes));
    INIT_OUT(("     ULONG       ulNumColors     %d",    gdiInfoNew.ulNumColors));
    INIT_OUT(("     ULONG       ulDACRed        0x%08x",    gdiInfoNew.ulDACRed));
    INIT_OUT(("     ULONG       ulDACGreen      0x%08x",    gdiInfoNew.ulDACGreen));
    INIT_OUT(("     ULONG       ulDACBlue       0x%08x",    gdiInfoNew.ulDACBlue));
    INIT_OUT(("     ULONG       ulHTOutputFormat %d",   gdiInfoNew.ulHTOutputFormat));

    //
    // We have successfully initialized - return the new PDEV.
    //
    rc = (DHPDEV)ppdev;

DC_EXIT_POINT:
    //
    // Release any resources if we failed to initialize.
    //
    if (rc == NULL)
    {
        ERROR_OUT(("DrvEnablePDEV failed; cleaning up by disabling"));
        DrvDisablePDEV(NULL);
    }

    DebugExitPVOID(DrvEnablePDEV, rc);
    return(rc);
}


//
// DrvDisablePDEV - see NT DDK documentation
//
// Release the resources allocated in DrvEnablePDEV.  If a surface has been
// enabled DrvDisableSurface will have already been called.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.
//
// Note: In an error, we may call this before DrvEnablePDEV is done.
//
//
VOID DrvDisablePDEV(DHPDEV  dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisablePDEV);

    INIT_OUT(("DrvDisablePDEV(dhpdev = 0x%08x)", dhpdev));

    //
    // Free the resources we allocated for the display.
    //
    if (ppdev != NULL)
    {
        if (ppdev->hpalCreated != NULL)
        {
            EngDeletePalette(ppdev->hpalCreated);
            ppdev->hpalCreated = NULL;
        }

        if (ppdev->pPal != NULL)
        {
            EngFreeMem(ppdev->pPal);
            ppdev->pPal = NULL;
        }

        EngFreeMem(ppdev);
    }

    DebugExitVOID(DrvDisablePDEV);
}


//
// DrvCompletePDEV - see NT DDK documentation
//
// Stores the HPDEV, the engine's handle for this PDEV, in the DHPDEV.
//
VOID DrvCompletePDEV( DHPDEV dhpdev,
                      HDEV   hdev )
{
    DebugEntry(DrvCompletePDEV);

    //
    // Store the device handle for our display handle.
    //
    INIT_OUT(("DrvCompletePDEV(dhpdev = 0x%08x, hdev = 0x%08x)", dhpdev, hdev));

    ((LPOSI_PDEV)dhpdev)->hdevEng = hdev;

    DebugExitVOID(DrvCompletePDEV);
}


//
// DrvResetPDEV - see NT DDK documentation
//
// Allows us to reject dynamic screen changes if necessary ON NT4 ONLY
// This is NOT CALLED on NT5.
//
BOOL DrvResetPDEV
(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
)
{
    BOOL rc = TRUE;

    DebugEntry(DrvResetPDEV);

    INIT_OUT(("DrvResetPDEV(dhpdevOld = 0x%08x, dhpdevNew = 0x%08x)", dhpdevOld,
        dhpdevNew));

    //
    // We can only allow the display driver to change modes while DC-Share
    // is not running.
    //
    if (g_shmMappedMemory != NULL)
    {
        //
        // Deny the request.
        //
        rc = FALSE;
    }

    DebugExitDWORD(DrvResetPDEV, rc);
    return(rc);
}


//
// DrvEnableSurface - see NT DDK documentation
//
// Creates the drawing surface and initializes driver components.  This
// function is called after DrvEnablePDEV, and performs the final device
// initialization.
//
//
HSURF DrvEnableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV  ppdev = (LPOSI_PDEV)dhpdev;
    HSURF      hsurf;
    SIZEL      sizl;
    LPOSI_DSURF pdsurf;
    HSURF      rc = 0;

    DWORD returnedDataLength;
    DWORD MaxWidth, MaxHeight;
    VIDEO_MEMORY videoMemory;
    VIDEO_MEMORY_INFORMATION videoMemoryInformation;

    DebugEntry(DrvEnableSurface);

    INIT_OUT(("DrvEnableSurface: Parameters:"));
    INIT_OUT(("     LPOSI_PDEV  ppdev           0x%08x", ppdev));
    INIT_OUT(("     HDRIVER     ->hDriver       0x%08x", ppdev->hDriver));
    INIT_OUT(("     INT         ->cxScreen      %d", ppdev->cxScreen));
    INIT_OUT(("     INT         ->cyScreen      %d", ppdev->cyScreen));

    //
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // DSURF structure allocated below.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.
    //
    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(OSI_DSURF), OSI_ALLOC_TAG);
    if (pdsurf == NULL)
    {
        ERROR_OUT(( "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        DC_QUIT;
    }

    //
    // Store the screen surface details.
    //
    ppdev->pdsurfScreen = pdsurf;
    pdsurf->sizl.cx     = ppdev->cxScreen;
    pdsurf->sizl.cy     = ppdev->cyScreen;
    pdsurf->ppdev       = ppdev;

    INIT_OUT(("DrvEnableSurface: Returning surface pointer 0x%08x", pdsurf));

    //
    // Only map the shared memory the first time we are called.
    //
    if (g_asSharedMemory == NULL)
    {
        //
        // Map the pointer to the shared section in the miniport driver
        //
        videoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                               &videoMemory,
                               sizeof(VIDEO_MEMORY),
                               &videoMemoryInformation,
                               sizeof(VIDEO_MEMORY_INFORMATION),
                               &returnedDataLength))
        {
            ERROR_OUT(( "Could not MAP miniport section"));
            DC_QUIT;
        }

        INIT_OUT(("DrvEnableSurface: Got video memory info from EngDeviceIoControl:"));
        INIT_OUT(("    FrameBufferBase          0x%08x", videoMemoryInformation.FrameBufferBase));
        INIT_OUT(("    FrameBufferLength        0x%08x", videoMemoryInformation.FrameBufferLength));

        g_shmSharedMemorySize = videoMemoryInformation.FrameBufferLength;

        // First block is shared memory header
        g_asSharedMemory = (LPSHM_SHARED_MEMORY)
                           videoMemoryInformation.FrameBufferBase;

        // Next are the two large OA_FAST_DATA blocks
        g_poaData[0]    = (LPOA_SHARED_DATA)(g_asSharedMemory + 1);
        g_poaData[1]    = (LPOA_SHARED_DATA)(g_poaData[0] + 1);
    }

    //
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we
    // ensure that GDI will only ever access the bitmaps bits via the Drv
    // calls that we've HOOKed.
    //
    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    //
    // Otherwise the primary display driver has its own bitmap used by the
    // physical hardware, so we do not need to do any drawing ourself.
    //
    INIT_OUT(("DrvEnableSurface: Calling EngCreateDeviceSurface with:"));
    INIT_OUT(("     Sizl.cx         %d", sizl.cx));
    INIT_OUT(("     Sizl.cy         %d", sizl.cy));
    INIT_OUT(("     BitmapFormat    %d", ppdev->iBitmapFormat));

    hsurf = EngCreateDeviceSurface( (DHSURF)pdsurf,
                                    sizl,
                                    ppdev->iBitmapFormat );

    if (hsurf == 0)
    {
        ERROR_OUT(( "Could not allocate surface"));
        DC_QUIT;
    }

    //
    // Store the screen surface handle.
    //
    ppdev->hsurfScreen = hsurf;

    //
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //
    if (!EngAssociateSurface(hsurf, ppdev->hdevEng,
                HOOK_BITBLT             |
                HOOK_STRETCHBLT         |
                HOOK_PLGBLT             |
                HOOK_TEXTOUT            |
                HOOK_PAINT              |       // OBSOLETE
                HOOK_STROKEPATH         |
                HOOK_FILLPATH           |
                HOOK_STROKEANDFILLPATH  |
                HOOK_LINETO             |
                HOOK_COPYBITS           |
                HOOK_STRETCHBLTROP      |
                HOOK_TRANSPARENTBLT     |
                HOOK_ALPHABLEND         |
                HOOK_GRADIENTFILL       |
                HOOK_SYNCHRONIZEACCESS))        // OBSOLETE
    {
        ERROR_OUT(( "DrvEnableSurface - Failed EngAssociateSurface"));
        DC_QUIT;
    }

    //
    // We have successfully associated the surface so return it to the GDI.
    //
    rc = hsurf;

DC_EXIT_POINT:
    //
    // Tidy up any resources if we failed.
    //
    if (rc == 0)
    {
        DrvDisableSurface((DHPDEV) ppdev);
    }

    DebugExitPVOID(DrvEnableSurface, rc);
    return(rc);
}


//
// DrvDisableSurface - see NT DDK documentation
//
// Free resources allocated by DrvEnableSurface.  Release the surface.
//
// Note that this function will be called when previewing modes in the
// Display Applet, but not at system shutdown.  If you need to reset the
// hardware at shutdown, you can do it in the miniport by providing a
// 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
//
// Note: In an error case, we may call this before DrvEnableSurface is
//       completely done.
//
VOID DrvDisableSurface(DHPDEV dhpdev)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvDisableSurface);

    INIT_OUT(("DrvDisableSurface(dhpdev = 0x%08x)", dhpdev));

    if (ppdev->hsurfScreen != 0)
    {
        EngDeleteSurface(ppdev->hsurfScreen);
    }

    if (ppdev->pdsurfScreen != NULL)
    {
        EngFreeMem(ppdev->pdsurfScreen);
    }

    DebugExitVOID(DrvDisableSurface);
}


//
// DrvEscape - see NT DDK documentation.
//
ULONG DrvEscape(SURFOBJ *pso,
                ULONG    iEsc,
                ULONG    cjIn,
                PVOID    pvIn,
                ULONG    cjOut,
                PVOID    pvOut)
{
    ULONG                   rc = FALSE;
    LPOSI_ESCAPE_HEADER     pHeader;

    DebugEntry(DrvEscape);

    TRACE_OUT(("DrvEscape called with escape %d", iEsc));

    //
    // All functions we support use an identifier in the input data to make
    // sure that we don't try to use another driver's escape functions.  If
    // the identifier is not present, we must not process the request.
    //
    // NOTE: This function is NOT protected for shared memory access
    // because it is responsible for allocating / deallocating the shared
    // memory.
    //

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cjIn < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        WARNING_OUT(("DrvEscape ignoring; input size %04d too small", cjIn));
        DC_QUIT;
    }
    if (cjOut < sizeof(OSI_ESCAPE_HEADER))
    {
        INIT_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        WARNING_OUT(("DrvEscape ignoring; output size %04d too small", cjOut));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    pHeader = pvIn;
    if (pHeader->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        INIT_OUT(("DrvEscape ignoring; identifier 0x%08x is not for Salem", pHeader->identifier));
        WARNING_OUT(("DrvEscape ignoring; identifier 0x%08x is not for Salem", pHeader->identifier));
        DC_QUIT;
    }
    else if (pHeader->version != DCS_MAKE_VERSION())
    {
        INIT_OUT(("DrvEscape failing; version 0x%08x of Salem is not that of driver",
            pHeader->version));
        WARNING_OUT(("DrvEscape failing; version 0x%08x of Salem is not that of driver",
            pHeader->version));
        DC_QUIT;
    }

    //
    // Everything is tickety boo - process the request.
    //
    switch (iEsc)
    {
        case OSI_ESC_CODE:
        {
            //
            // This is a request from the share core.  Pass it on to the
            // correct component.
            //
            TRACE_OUT(( "Function %ld", pHeader->escapeFn));

            if( (pHeader->escapeFn >= OSI_ESC_FIRST) &&
                (pHeader->escapeFn <= OSI_ESC_LAST ) )
            {
                //
                // OSI requests.
                //
                rc = OSI_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OE_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OE_ESC_LAST ) )
            {
                //
                // Order Encoder requests.
                //
                rc = OE_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_HET_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_HET_ESC_LAST) )
            {
                //
                // Non-locking (wnd tracking) HET requests
                //
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_SBC_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SBC_ESC_LAST ) )
            {
                //
                // Send Bitmap Cache requests
                //
                rc = SBC_DDProcessRequest(pso, pHeader->escapeFn, pvIn, pvOut, cjOut);
            }
            else if( (pHeader->escapeFn >= OSI_SSI_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_SSI_ESC_LAST ) )
            {
                //
                // Save Screen Bits requests.
                //
                rc = SSI_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_CM_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_CM_ESC_LAST ) )
            {
                //
                // Cursor Manager requests
                //
                rc = CM_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else if( (pHeader->escapeFn >= OSI_OA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_OA_ESC_LAST ) )
            {
                //
                // Order Accumulator requests.
                //
                rc = OA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn);
            }
            else if( (pHeader->escapeFn >= OSI_BA_ESC_FIRST) &&
                     (pHeader->escapeFn <= OSI_BA_ESC_LAST ) )
            {
                //
                // Bounds Accumulator requests.
                //
                rc = BA_DDProcessRequest(pHeader->escapeFn, pHeader, cjIn,
                    pvOut, cjOut);
            }
            else
            {
                WARNING_OUT(( "Unknown function", pHeader->escapeFn));
            }
        }
        break;

        case WNDOBJ_SETUP:
        {
            if ((pHeader->escapeFn >= OSI_HET_WO_ESC_FIRST) &&
                (pHeader->escapeFn <= OSI_HET_WO_ESC_LAST))
            {
                TRACE_OUT(("WNDOBJ_SETUP Escape code - pass to HET"));
                rc = HET_DDProcessRequest(pso, cjIn, pvIn, cjOut, pvOut);
            }
            else
            {
                INIT_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
                WARNING_OUT(("WNDOBJ_SETUP Escape is unrecognized, ignore"));
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised request %lu", iEsc));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitDWORD(DrvEscape, rc);
    return(rc);
}


//
// DrvSetPalette - see NT DDK documentation.
//
BOOL DrvSetPalette(DHPDEV  dhpdev,
                   PALOBJ* ppalo,
                   FLONG   fl,
                   ULONG   iStart,
                   ULONG   cColors)
{
    BOOL rc = FALSE;
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvSetPalette);

    //
    // Check that this doesn't hose our palette.  Note that NT passes a
    // zero indexed array element and a count, hence to fill a palette, the
    // values are 'start at 0 with 256 colours'.  Thus a total of 256 is
    // the maximum for our 8-bit palette.
    //
    if (iStart + cColors > OSI_MAX_PALETTE)
    {
        ERROR_OUT(("Overflow: start %lu count %lu", iStart, cColors));
        DC_QUIT;
    }

    //
    // Fill in the palette
    //
    if (cColors != PALOBJ_cGetColors(ppalo,
                                     iStart,
                                     cColors,
                                     (ULONG*)&ppdev->pPal[iStart]))
    {
        //
        // Don't bother tracing the return code - it's always 0.
        //
        ERROR_OUT(("Failed to read palette"));
        DC_QUIT;
    }

    //
    // BOGUS LAURABU!
    // For NT 5.0, do we need to turn around and reset the contents of
    // our created palette object with these new color values?  Real
    // display drivers don't (S3 e.g.)
    //

    //
    // Set the flag in the PDEV to indicate that the palette has changed
    //
    ppdev->paletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DrvSetPalette, rc);
    return(rc);
}


//
// DrvGetModes - see NT DDK documentation
//
// Returns the list of available modes for the device.
// As a mirroring driver, we return 0.  That will cause NT GRE to use
// whatever ChangeDisplaySettingsEx passed along.
//
ULONG DrvGetModes
(
    HANDLE      hDriver,
    ULONG       cjSize,
    DEVMODEW*   pdm
)
{
    return(0);
}


//
// DrvAssertMode - see NT DDK documentation.
//
BOOL DrvAssertMode
(
    DHPDEV  dhpdev,
    BOOL    bEnable
)
{
    LPOSI_PDEV ppdev = (LPOSI_PDEV)dhpdev;

    DebugEntry(DrvAssertMode);

    INIT_OUT(("DrvAssertMode(dhpdev = 0x%08x, bEnable = %d)", dhpdev, bEnable));

    //
    // Check for fullscreen switching.
    //
    if ((g_asSharedMemory != NULL) && (ppdev != NULL))
    {
        g_asSharedMemory->fullScreen = (BOOL)(!bEnable);
        TRACE_OUT(("Fullscreen is now  %d", g_asSharedMemory->fullScreen));
    }

    DebugExitVOID(DrvAssertMode);
    return(TRUE);
}



//
// Name:      OSIInitializeMode
//
// Purpose:
//
// Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
// devinfo based on the requested mode.
//
// Returns:
//
// TRUE  - Successfully initialized the data
// FALSE - Failed to set up mode data
//
// Params:
//
// pgdiRequested    - GDI info from the primary display driver (empty in NT 5.0)
// pdmRequested     - DEVMODE info with GDI's requested settings for our driver
// ppdev            - Our driver's private copy of settings, values
// pgdiReturn       - GDI info to return for our driver
// pdiReturn        - DEVINFO to return for our driver
//
BOOL  OSIInitializeMode
(
    const GDIINFO*      pgdiRequested,
    const DEVMODEW*     pdmRequested,
    LPOSI_PDEV          ppdev,
    GDIINFO*            pgdiReturn,
    DEVINFO*            pdiReturn
)
{
    BOOL                rc = FALSE;
    HPALETTE            hpal;
    ULONG               cColors;
    ULONG               iMode;

    DebugEntry(OSIInitializeMode);

    INIT_OUT(("DrvEnablePDEV: DEVMODEW requested contains:"));
    INIT_OUT(("     Screen width    -- %li", pdmRequested->dmPelsWidth));
    INIT_OUT(("     Screen height   -- %li", pdmRequested->dmPelsHeight));
    INIT_OUT(("     Bits per pel    -- %li", pdmRequested->dmBitsPerPel));
    INIT_OUT(("DrvEnablePDEV: DEVINFO parameter contains:"));
    INIT_OUT(("     flGraphicsCaps  -- 0x%08x", pdiReturn->flGraphicsCaps));
    INIT_OUT(("     iDitherFormat   -- 0x%08x", pdiReturn->iDitherFormat));
    INIT_OUT(("     hpalDefault     -- 0x%08x", pdiReturn->hpalDefault));
    INIT_OUT(("DrvEnablePDEV: GDIINFO (devcaps) parameter contains:"));
    INIT_OUT(("    ULONG       ulVersion       0x%08x",    pgdiRequested->ulVersion));
    INIT_OUT(("    ULONG       ulHorzSize      %d",    pgdiRequested->ulHorzSize));
    INIT_OUT(("    ULONG       ulVertSize      %d",    pgdiRequested->ulVertSize));
    INIT_OUT(("    ULONG       ulHorzRes       %d",    pgdiRequested->ulHorzRes));
    INIT_OUT(("    ULONG       ulVertRes       %d",    pgdiRequested->ulVertRes));
    INIT_OUT(("    ULONG       cBitsPixel      %d",    pgdiRequested->cBitsPixel));
    INIT_OUT(("    ULONG       cPlanes         %d",    pgdiRequested->cPlanes));
    INIT_OUT(("    ULONG       ulNumColors     %d",    pgdiRequested->ulNumColors));
    INIT_OUT(("    ULONG       ulDACRed        0x%08x",    pgdiRequested->ulDACRed));
    INIT_OUT(("    ULONG       ulDACGreen      0x%08x",    pgdiRequested->ulDACGreen));
    INIT_OUT(("    ULONG       ulDACBlue       0x%08x",    pgdiRequested->ulDACBlue));
    INIT_OUT(("    ULONG       ulHTOutputFormat %d",   pgdiRequested->ulHTOutputFormat));


    //
    // Fill in the GDIINFO we're returning with the info for our driver.
    // First, copy the default settings.
    //
    *pgdiReturn = s_osiDefaultGdi;

    //
    // Second, update the values that vary depending on the requested
    // mode and color depth.
    //

    pgdiReturn->ulHorzRes         = pdmRequested->dmPelsWidth;
    pgdiReturn->ulVertRes         = pdmRequested->dmPelsHeight;
    pgdiReturn->ulVRefresh        = pdmRequested->dmDisplayFrequency;
    pgdiReturn->ulLogPixelsX      = pdmRequested->dmLogPixels;
    pgdiReturn->ulLogPixelsY      = pdmRequested->dmLogPixels;

    //
    // If this is NT 4.0 SP-3, we get passed in the original GDIINFO of
    // the real display.  If not, we need to fake up one.
    //
    if (pgdiRequested->cPlanes != 0)
    {
        //
        // Now overwrite the defaults with the relevant information returned
        // from the kernel driver:
        //
        pgdiReturn->cBitsPixel        = pgdiRequested->cBitsPixel;
        pgdiReturn->cPlanes           = pgdiRequested->cPlanes;

        pgdiReturn->ulDACRed          = pgdiRequested->ulDACRed;
        pgdiReturn->ulDACGreen        = pgdiRequested->ulDACGreen;
        pgdiReturn->ulDACBlue         = pgdiRequested->ulDACBlue;
    }
    else
    {
        pgdiReturn->cBitsPixel        = pdmRequested->dmBitsPerPel;
        pgdiReturn->cPlanes           = 1;

        switch (pgdiReturn->cBitsPixel)
        {
            case 8:
                pgdiReturn->ulDACRed = pgdiReturn->ulDACGreen = pgdiReturn->ulDACBlue = 8;
                break;

            case 24:
                pgdiReturn->ulDACRed    = 0x00FF0000;
                pgdiReturn->ulDACGreen  = 0x0000FF00;
                pgdiReturn->ulDACBlue   = 0x000000FF;
                break;

            default:
                ERROR_OUT(("Invalid color depth in NT 5.0 mirror driver"));
                DC_QUIT;
                break;
        }
    }

    //
    // Now save private copies of info we're returning to GDI
    //
    ppdev->cxScreen         = pgdiReturn->ulHorzRes;
    ppdev->cyScreen         = pgdiReturn->ulVertRes;
    ppdev->cBitsPerPel      = pgdiReturn->cBitsPixel * pgdiReturn->cPlanes;
    if (ppdev->cBitsPerPel == 15)
        ppdev->cBitsPerPel = 16;
    ppdev->flRed            = pgdiReturn->ulDACRed;
    ppdev->flGreen          = pgdiReturn->ulDACGreen;
    ppdev->flBlue           = pgdiReturn->ulDACBlue;

    //
    // Fill in the devinfo structure with the default 8bpp values, taking
    // care not to trash the supplied hpalDefault (which allows us to
    // query information about the real display driver's color format).
    //
    // On NT 5.0, we don't get passed on the screen palette at all, we need
    // to create our own.
    //
    hpal = pdiReturn->hpalDefault;
    *pdiReturn = s_osiDefaultDevInfo;

    switch (pgdiReturn->cBitsPixel * pgdiReturn->cPlanes)
    {
        case 4:
        {
            //
            // NT 4.0 SP-3 ONLY
            //

            pgdiReturn->ulNumColors     = 16;
            pgdiReturn->ulNumPalReg     = 0;
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_4BPP;

            pdiReturn->flGraphicsCaps   &= ~GCAPS_PALMANAGED;
            pdiReturn->iDitherFormat    = BMF_4BPP;

            ppdev->iBitmapFormat        = BMF_4BPP;

            cColors = 16;
            goto AllocPalEntries;
        }
        break;

        case 8:
        {
            pgdiReturn->ulNumColors     = 20;
            pgdiReturn->ulNumPalReg     = 256;

            pdiReturn->iDitherFormat    = BMF_8BPP;

            ppdev->iBitmapFormat        = BMF_8BPP;

            cColors = 256;
AllocPalEntries:
            //
            // Alloc memory for the palette entries.
            //
            ppdev->pPal = EngAllocMem( FL_ZERO_MEMORY,
                            sizeof(PALETTEENTRY) * cColors,
                            OSI_ALLOC_TAG );
            if (ppdev->pPal == NULL)
            {
                ERROR_OUT(("Failed to allocate palette memory"));
                DC_QUIT;
            }
        }
        break;

        case 15:
        case 16:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_16BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_16BPP;

            ppdev->iBitmapFormat        = BMF_16BPP;
        }
        break;

        case 24:
        {
            //
            // DIB conversions will only work if we have a standard RGB
            // surface for 24bpp.
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_24BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_24BPP;

            ppdev->iBitmapFormat        = BMF_24BPP;
        }
        break;

        case 32:
        {
            //
            // NT 4.0 SP-3 ONLY
            //
            pgdiReturn->ulHTOutputFormat = HT_FORMAT_32BPP;

            pdiReturn->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
            pdiReturn->iDitherFormat    = BMF_32BPP;

            ppdev->iBitmapFormat        = BMF_32BPP;
        }
        break;

        default:
        {
            //
            // Unsupported bpp - pretend we are 8 bpp.
            //
            ERROR_OUT(("Unsupported bpp value: %d",
                pgdiReturn->cBitsPixel * pgdiReturn->cPlanes));
            DC_QUIT;
        }
        break;
    }


    if (!hpal)
    {
        //
        // This is NT 5.0.  We need to create a palette, either an 8bpp
        // indexed one, or a 24bpp bitfield one.
        //
        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            ULONG   ulLoop;

            //
            // We have to initialize the fixed part (top 10 and bottom 10)
            // of the palette entries.
            //
            for (ulLoop = 0; ulLoop < 10; ulLoop++)
            {
                // First 10
                ppdev->pPal[ulLoop]     = s_aWinColors[ulLoop];

                // Last 10
                ppdev->pPal[256 - 10 + ulLoop] = s_aWinColors[ulLoop + 10];
            }

            // Create the palette from the entries.
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*)ppdev->pPal,
                0, 0, 0);

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ASSERT(ppdev->iBitmapFormat == BMF_24BPP);

            hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
        }

        ppdev->hpalCreated = hpal;
        if (!hpal)
        {
            ERROR_OUT(("DrvEnablePDEV: could not create DEVINFO palette"));
            DC_QUIT;
        }
    }
    else
    {
        //
        // This is NT 4.0 SP-3.  Get the real bitmasks for > 8 bpp and
        // the current palette colors for <= 8 bpp.
        //
        if (pgdiReturn->cBitsPixel <= 8)
        {
            if (ppdev->iBitmapFormat == BMF_4BPP)
            {
                ASSERT(cColors == 16);
            }
            else
            {
                ASSERT(cColors == 256);
            }

            if (cColors != EngQueryPalette(hpal, &iMode, cColors,
                    (ULONG *)ppdev->pPal))
            {
                ERROR_OUT(("Failed to query current display palette"));
            }

            //
            // Set the flag in the PDEV to indicate that the palette has
            // changed.
            //
            ppdev->paletteChanged = TRUE;
        }
        else
        {
            ULONG       aulBitmasks[3];

            //
            // Query the true color bitmasks.
            //
            cColors = EngQueryPalette(hpal,
                               &iMode,
                               sizeof(aulBitmasks) / sizeof(aulBitmasks[0]),
                               &aulBitmasks[0] );

            if (cColors == 0)
            {
                ERROR_OUT(("Failed to query real bitmasks"));
            }

            if (iMode == PAL_INDEXED)
            {
                ERROR_OUT(("Bitmask palette is indexed"));
            }

            //
            // Get the real bitmasks for NT 4.0 SP-3 displays since we
            // get the same info the real global display does, and we need
            // to parse the bits in BitBlts, color tanslations, etc.
            //
            ppdev->flRed   = aulBitmasks[0];
            ppdev->flGreen = aulBitmasks[1];
            ppdev->flBlue  = aulBitmasks[2];
        }
    }

    pdiReturn->hpalDefault = hpal;

    rc = TRUE;

    INIT_OUT(("DrvEnablePDEV: Returning bitmasks of:"));
    INIT_OUT(("     red     %08x", ppdev->flRed));
    INIT_OUT(("     green   %08x", ppdev->flGreen));
    INIT_OUT(("     blue    %08x", ppdev->flBlue));

DC_EXIT_POINT:
    DebugExitBOOL(OSIInitializeMode, rc);
    return(rc);
}








//
// FUNCTION:      OSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
ULONG OSI_DDProcessRequest(SURFOBJ* pso,
                                     UINT cjIn,
                                     void *  pvIn,
                                     UINT cjOut,
                                     void *  pvOut)
{
    ULONG               rc;
    LPOSI_ESCAPE_HEADER pHeader;
    LPOSI_PDEV          ppdev = (LPOSI_PDEV)pso->dhpdev;

    DebugEntry(OSI_DDProcessRequest);

    //
    // Get the request number.
    //
    pHeader = pvIn;
    switch (pHeader->escapeFn)
    {
        case OSI_ESC_INIT:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_INIT"));
            ASSERT(cjOut == sizeof(OSI_INIT_REQUEST));

            //
            // Get shared memory block
            //
            OSI_DDInit(ppdev, (LPOSI_INIT_REQUEST)pvOut);
            rc = TRUE;
        }
        break;

        case OSI_ESC_TERM:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_TERM"));
            ASSERT(cjIn == sizeof(OSI_TERM_REQUEST));

            //
            // Cleanup, NM is going away
            //
            OSI_DDTerm(ppdev);
            rc = TRUE;
        }
        break;

        case OSI_ESC_SYNC_NOW:
        {
            TRACE_OUT(("DrvEscape:  OSI_ESC_SYNC_NOW"));
            ASSERT(cjIn == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            SBC_DDSyncUpdatesNow(ppdev);
            rc = TRUE;
        }
        break;


        default:
        {
            ERROR_OUT(("Unrecognised request %lu", pHeader->escapeFn));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}




//
// Function:    OSI_DDInit
//
// Description: Map the shared memory into Kernel and User space
//
// Parameters:  count - size of the buffer to return to user space
//              pData - pointer to the buffer to be returned to user space
//
// Returns:     (none)
//
void OSI_DDInit(LPOSI_PDEV ppdev, LPOSI_INIT_REQUEST pResult)
{
    DWORD               memRemaining;
    LPBYTE              pBuffer;

    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DebugEntry(OSI_DDInit);

    // Init to FALSE
    pResult->result = FALSE;

    // Initialize these to NULL
    pResult->pSharedMemory  = NULL;
    pResult->poaData[0]     = NULL;
    pResult->poaData[1]     = NULL;
    pResult->sbcEnabled   = FALSE;

    //
    // Check that the memory is available to the driver and that we are not
    // in a race condition.
    //
    if (g_asSharedMemory == NULL)
    {
        ERROR_OUT(("No memory available"));
        DC_QUIT;
    }

    if (g_shmMappedMemory != NULL)
    {
        //
        // We will never come in here with two copies of NetMeeting running.
        // The UI code prevents the second instance from starting long
        // before app sharing is in the picture.  Therefore, these are the
        // only possibilities:
        //
        //  (1) Previous version is almost shutdown but hasn't called OSI_DDTerm
        // yet and new version is starting up and calls OSI_DDInit
        //
        //  (2) Previous version terminated abnormally and never called
        // OSI_DDTerm().  This code handles the second case.  The first one
        // is handled by the same code in the UI that prevents two copies
        // from starting around the same time.
        //
        WARNING_OUT(("OSI_DDInit:  NetMeeting did not shutdown cleanly last time"));
        OSI_DDTerm(ppdev);
    }

    //
    // Map the shared section into the caller's process.
    //
    INIT_OUT(("OSI_DDInit: Mapping 0x%08x bytes of kernel memory at 0x%08x into caller process",
        g_shmSharedMemorySize, g_asSharedMemory));
    ShareMemory.ProcessHandle           = LongToHandle(-1);
    ShareMemory.ViewOffset              = 0;
    ShareMemory.ViewSize                = g_shmSharedMemorySize;
    ShareMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            &ShareMemoryInformation,
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
            &ReturnedDataLength) != 0)
    {
        ERROR_OUT(("Failed to map shared memory into calling process"));
        DC_QUIT;
    }

    //
    // USER MODE pointer (not valid in kernel mode)
    //
    INIT_OUT(("OSI_DDInit: Mapped 0x%08x bytes of kernel memory to user memory 0x%08x",
        g_shmSharedMemorySize, ShareMemoryInformation.VirtualAddress));

    g_shmMappedMemory      = ShareMemoryInformation.VirtualAddress;
    pResult->pSharedMemory = g_shmMappedMemory;
    pResult->poaData[0]    = ((LPSHM_SHARED_MEMORY)pResult->pSharedMemory) + 1;
    pResult->poaData[1]    = ((LPOA_SHARED_DATA)pResult->poaData[0]) + 1;

    TRACE_OUT(("Shared memory %08lx %08lx %08lx",
            pResult->pSharedMemory, pResult->poaData[0], pResult->poaData[1]));

    //
    // Clear out the shared memory, so it's ready for immediate use.
    // NOTE THAT THIS SETS ALL VALUES TO FALSE.
    // NOTE ALSO THAT THIS CLEARS the two OA_SHARED_DATAs also
    //
    RtlFillMemory(g_asSharedMemory, SHM_SIZE_USED, 0);
    g_asSharedMemory->displayToCore.indexCount    = 0;

    //
    // Set up our pointer to the variable part of the shared memory i.e.
    // the part which is not used for the SHM_SHARED_MEMORY structure
    // We must skip past g_asSharedMemory, two CM_FAST_DATA structs, and
    // two OA_SHARED_DATA structs.
    //
    pBuffer      = (LPBYTE)g_asSharedMemory;
    pBuffer     += SHM_SIZE_USED;
    memRemaining = g_shmSharedMemorySize - SHM_SIZE_USED;

    //
    // Initialise the other components required for DC-Share
    //

    //
    // Bounds accumulation
    //
    BA_DDInit();

    //
    // Cursor
    //
    if (!CM_DDInit(ppdev))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    //
    // Send Bitmap Cache
    // NOTE that if it initializes OK but no caching allowed, we will continue.
    //
    // This will fill in the tile buffers & info.  If no SBC caching allowed,
    // the sbcEnabled field will be FALSE.
    //
    if (SBC_DDInit(ppdev, pBuffer, memRemaining, pResult))
    {
        pResult->sbcEnabled = TRUE;
    }

    //
    // Mark memory as ready to use.
    //
    pResult->result = TRUE;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDInit);
}


//
// Function:    OSI_DDTerm
//
// Description: Cleanup when NM shuts down
//
// Returns:     (none)
//
void OSI_DDTerm(LPOSI_PDEV ppdev)
{
    DebugEntry(OSI_DDTerm);

    //
    // Check for a valid address - must be non-NULL.
    //
    if (!g_asSharedMemory)
    {
        ERROR_OUT(("Invalid memory"));
        DC_QUIT;
    }


    //
    // Terminate the dependent components.
    //

    //
    // Hosted Entity Tracker
    //
    HET_DDTerm();

    //
    // Order Encoding
    //
    OE_DDTerm();

    //
    // Send Bitmap Cache
    //
    SBC_DDTerm();

    //
    // Cursor manager.
    //
    CM_DDTerm();

    //
    // The shared memory will be unmapped automatically in this process
    // by OS cleanup, in both NT4 and NT5
    //
    g_shmMappedMemory = NULL;

DC_EXIT_POINT:
    DebugExitVOID(OSI_DDTerm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\shm.c ===
#include "precomp.h"


//
// SHM.C
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//


//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl;
    LPVOID              pMemBlock;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = 1;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    DebugExitPVOID(SHM_StartAccess, pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;
    }

    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    if (ptr == NULL)
    {
        ERROR_OUT(("Null pointer"));
        DC_QUIT;
    }

    ASSERT(g_asSharedMemory);

    if (((LPBYTE)ptr - (LPBYTE)g_asSharedMemory < 0) ||
        ((LPBYTE)ptr - (LPBYTE)g_asSharedMemory >= SHM_SIZE_USED))
    {
        ERROR_OUT(("Bad pointer"));
    }

DC_EXIT_POINT:
    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\ssi.c ===
#include "precomp.h"


//
// SSI.C
// Save Screenbits Interceptor, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
// SSI_DDProcessRequest - see ssi.h
//
BOOL SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            if (cbRequest != sizeof(SSI_RESET_LEVEL))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_RESET_LEVEL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            if (cbRequest != sizeof(SSI_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_NEW_CAPABILITIES",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}



//
// SSI_SaveScreenBitmap()
//
// see ssi.h for description.
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand)
{
    BOOL rc;

    DebugEntry(SSI_SaveScreenBitmap);

    //
    // Decide whether we can transmit this particular SaveBitmap command as
    // an order.
    //
    switch (wCommand)
    {
        case ONBOARD_SAVE:
        {
            //
            // Save the bits.
            //
            rc = SSISaveBits(lpRect);
        }
        break;

        case ONBOARD_RESTORE:
        {
            //
            // Restore the bits.
            //
            rc = SSIRestoreBits(lpRect);
        }
        break;

        case ONBOARD_DISCARD:
        {
            //
            // Discard the saved bits.
            //
            rc = SSIDiscardBits(lpRect);
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            rc = FALSE;
        }
    }

    if (g_ssiLocalSSBState.saveLevel == 0)
    {
        ASSERT(g_ssiRemoteSSBState.pelsSaved == 0);
    }

    DebugExitBOOL(SSI_SaveScreenBitmap, rc);
    return(rc);
}



//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits.
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the number of remote pels saved.
    //
    g_ssiRemoteSSBState.pelsSaved = 0;


    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT      lpRect,
    UINT        wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        WARNING_OUT(("SSISendSaveBitmapOrder failing; save bits orders not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(("SSISendSaveBitmapOrder:  ONBOARD_SAVE is failing; not enough space for %08d pels",
                    cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =  g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;


            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                                  CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       (TSHR_INT16)pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       (TSHR_INT16)pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       (TSHR_INT16)pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       (TSHR_INT16)pSaveBitmapOrder->nBottomRect;
            break;


        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            DC_QUIT;
    }

    TRACE_OUT(( "SaveBitmap op %d pos %ld rect %d %d %d %d",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // We deliberately do not call OA_DDClipAndAddOrder() because the
    // SaveBitmap order is never clipped.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we can't save it, no
// big deal--we'll fail the restore and that info will go as screen data.
//
// NOTE THAT THIS ROUTINE IS IN OPPOSITE FROM WIN95.  In Win95, we always
// return FALSE from save so that USER always uses bitmaps for save bits and
// we can track them.  In NT we always return TRUE from save because we
// can't track USER bitmaps.
//
// ALWAYS RETURN TRUE FROM THIS FUNCTION
//
// If FALSE is returned on a Display Driver SaveBits operation then Windows
// (USER) simulates the SaveBits call using BitBlts and DOES NOT make a
// corresponding RestoreBits call.  This makes it impossible for us to
// correctly track the drawing operations (the restore operation is a
// bitblt on a task that may not have been tracked) - and we can end up
// with unrestored areas on the remote.
//
// Therefore this routine should always return TRUE (apart from when
// something very very unexpected happens).  In the cases where we haven't
// saved the data we simply note the fact by storing ST_FAILED_TO_SAVE in
// our local SSB state structure.  Because we return TRUE, we get a
// RestoreBits call and, seeing that the Save failed (by looking in the
// local SSB state structure), we _then_ return FALSE to indicate that the
// Restore failed which causes Windows to invalidate and repaint the
// affected area.
//
//
BOOL SSISaveBits(LPRECT lpRect)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(( "saveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data, so if we sent a SAVEBITS order at
    // this point, we would not save the intersecting Screen Data.
    //
    // Otherwise mark the bits as saved (we don't have to do anything since
    // we are a chained display driver).
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_DISPLAY_DRIVER;
    }

    //
    // Store the rectangle saved
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = NULL;
    CURRENT_LOCAL_SSB_STATE.rect     = *lpRect;

    //
    // If the bits were successfully saved then we can try to send the
    // SaveBits command as an order.
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;
    
    TRACE_OUT(("SSISaveBits:"));
    TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

DC_EXIT_POINT:
    DebugExitBOOL(SSISaveBits, TRUE);
    return(TRUE);
}



//
// FUNCTION: SSIFindSlotAndDiscardAbove
//
// DESCRIPTION:
//
// Finds the top slot in the SSB stack which matches lpRect and updates
// g_ssiLocalSSBState.saveLevel to index it.
//
// PARAMETERS:
//
// lpRect - the SSB rectangle
//
// RETURNS: TRUE if a match was found, FALSE otherwise
//
//
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    //
    // Find the bits we are trying to restore
    //
    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if ((g_ssiLocalSSBState.saveState[i].rect.left   == lpRect->left)  &&
            (g_ssiLocalSSBState.saveState[i].rect.right  == lpRect->right) &&
            (g_ssiLocalSSBState.saveState[i].rect.top    == lpRect->top)   &&
            (g_ssiLocalSSBState.saveState[i].rect.bottom == lpRect->bottom) )
        {
            //
            // Found the one we were looking for
            //
            TRACE_OUT(("Found SPB at slot %d", i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    TRACE_OUT(("SSIFindSlotAndDiscardAbove:"));
    TRACE_OUT(("      saveLevel   is      %d", iNewSaveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}





//
// FUNCTION: SSIRestoreBits
//
// DESCRIPTION:
//
// Attempts to restore the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// If the bits were saved remotely then a RestoreBits order is sent to
// restore the remote bits.
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
// Note: if FALSE is returned on a RestoreBits operation then Windows will
// restore the screen by invalidating the area to be restored.
//
//
BOOL SSIRestoreBits(LPRECT lpRect)
{
    BOOL      rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(lpRect))
    {
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(lpRect, ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIRestoreBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}


//
// FUNCTION: SSIDiscardBits
//
// DESCRIPTION:
//
// Attempts to discard the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
//
BOOL SSIDiscardBits(LPRECT lpRect)
{
    BOOL rc = TRUE;

    DebugEntry(SSIDiscardBits);

    //
    // SS_FREE (discard) isn't called with a rectangle.  It is used to
    // discard the most recent save.
    //
    if (g_ssiLocalSSBState.saveLevel > 0)
    {
        --g_ssiLocalSSBState.saveLevel;

        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes
        // into.
        //

        //
        // If the bits were saved remotely then send a DISCARDBITS order.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            // 
            SSISendSaveBitmapOrder(lpRect, ONBOARD_DISCARD);
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIDiscardBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}


//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth    = 0;
    UINT    rectHeight   = 0;
    UINT    xGranularity = 1;
    UINT    yGranularity = 1;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect != NULL);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = lpRect->right  - lpRect->left;
    rectHeight = lpRect->bottom - lpRect->top;

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc =
      ((DWORD)(rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
      ((DWORD)(rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}


//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\dd\trc.c ===
#include "precomp.h"


//
// TRC.C
// Debug Tracing
// This emulates the code found in NMUTIL for ring0
//
// Copyright(c) Microsoft 1997-
//


#if defined(DEBUG) || defined(INIT_TRACE)


char        s_ASDbgArea[] = "Salem ";

#ifdef _M_ALPHA

va_list     g_trcDummyVa                =   {NULL, 0};
#define DUMMY_VA_LIST       g_trcDummyVa

#else

#define DUMMY_VA_LIST       NULL

#endif // _M_ALPHA



//
// Debug only
//

#ifdef DEBUG

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
// DbgZPrintFnExitPVOID()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s\n", szFn);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN %d\n", szFn, dwResult);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}

void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN 0x%p\n", szFn, ptr);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}


//
// DbgZPrintTrace()
//
// This prints out a trace string
//
void DbgZPrintTrace(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_TRACE)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "TRACE: %s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintWarning()
//
// This prints out a warning string
//
void DbgZPrintWarning(PSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "WARNING: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);
}


#endif // DEBUG




//
// DbgZPrintInit()
//
// This is special case tracing only for the init code, which can be
// built even in retail
//

void DbgZPrintInit(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_INIT)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "%s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintError()
//
// This prints out an error string then breaks into the kernel debugger.
//
void DbgZPrintError(LPSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "ERROR: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);

    EngDebugBreak();
}




#endif // DEBUG or INIT_TRACE

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\acpi.h ===
//
// ACPI.H
// This file is included by ObMan applets (namely, the old Whiteboard)
//
// Copyright (c) Microsoft, 1998-
//

#ifndef _H_ACPI
#define _H_ACPI


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Header that sets up OS flags. Include before everything else
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>


//
// Application Loader Programming Interface
//
#include <al.h>

//
// T.120 Data Conferencing Stuff
//
#include <ast120.h>

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Whiteboard Programming Interface
// C++
//
#include <wb.hpp>


#endif // _H_ACPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ba.h ===
//
// Bounds Accumulation
//

#ifndef _H_BA
#define _H_BA


//
// Number of rectangles used by the SDA.
// NOTE:  You can play around with this setting, building the core & the 
// display driver.  Bumping it up means finer update areas, bumping it down
// means more rect blobs of data.
//
#define BA_NUM_RECTS      10
#define BA_INVALID_RECT_INDEX ((UINT)-1)


//
// Values for OSI escape codes
//
#define BA_ESC(code)            (OSI_BA_ESC_FIRST + code)

#define BA_ESC_GET_BOUNDS       BA_ESC(0)
#define BA_ESC_RETURN_BOUNDS    BA_ESC(1)


//
//
// MACROS
//
//

//
// Macros to access the fast swapping shared memory.
//
#ifdef DLL_DISP

#define BA_FST_START_WRITING    SHM_StartAccess(SHM_BA_FAST)
#define BA_FST_STOP_WRITING     SHM_StopAccess(SHM_BA_FAST)


#else


#define BA_FST_START_READING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_READING

#define BA_FST_START_WRITING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_WRITING


#endif // DLL_DISP



//
//
// TYPES
//
//




//
// Structure: BA_BOUNDS_INFO
//
// Description: Structure used to pass bounds information between the
//              share core and the driver.
//
//
typedef struct tagBA_BOUNDS_INFO
{
    OSI_ESCAPE_HEADER   header;             // Common header               
    DWORD       numRects;                   // Num of bounds rects
    RECTL       rects[BA_NUM_RECTS];        // Rects
}
BA_BOUNDS_INFO;
typedef BA_BOUNDS_INFO FAR * LPBA_BOUNDS_INFO;


//
// Structure: BA_FAST_DATA
//
// Used to pass data from the screen output task to the Share Core on each
// periodic processing.
//
typedef struct tagBA_FAST_DATA
{
    DWORD    totalSDA;
} BA_FAST_DATA;
typedef BA_FAST_DATA FAR * LPBA_FAST_DATA;



//
//
// OVERVIEW
//
// The bounds code used to be common to the share core and the display
// driver, with the data stored in the double buffered shared memory.  This
// is no longer the case.
//
// The display driver now "owns" the bounds - they are no longer stored in
// shared memory - and does all the complex manipulations such as merging
// rectangles.  When the share core needs to process bounds, it gets a copy
// from the driver by calling BA_FetchBounds(), sends as much of the data
// as possible, then returns the remaining bounds to the driver by calling
// BA_ReturnBounds().
//
// The nett result of these changes is that all the code which was common
// to the share core and the display driver (in abaapi.c and abaint.c) is
// now only in the driver (in nbaapi.c and nbaint.c).  There are vastly
// simplified versions of the functions in the share core.
//
//



//
// BA_ResetBounds
//
#ifdef DLL_DISP
void BA_DDInit(void);

void BA_ResetBounds(void);
#endif // DLL_DISP



//
// Name:      BA_ReturnBounds
//
// Purpose:   Pass the share core's copy of the bounds to the driver.
//
// Returns:   Nothing
//
// Params:    None
//
// Operation: This resets the share core's bounds to NULL.
//

void BA_ReturnBounds(void);




//
// Name:        BA_CopyBounds
//
// Description: Copies the bounding rectangle list.
//
// Params (IN): pRects - pointer to array of RECTs to fill in.
//        (OUT):pNumrects - filled in with number of RECTs copied.
//        (IN): reset current rects or just get current state w/o changing
//              state.
//
// Returns:     TRUE or FALSE
//
// DESCRIPTION
//
// Returns the accumulated bounds for all applications in the bounds
// code's current list of applications.  The bounds returned will
// include all updates originating from these applications but they may
// also include updates outside these applications windows and updates
// originating from other applications.  Therefore the caller must clip
// the returned bounds to the windows of the applications being
// shadowed.
//
// PARAMETERS
//
// pRects:
//
// A pointer to an array of rectangles in which the bounds will be
// returned.  The contents of this array are only valid if *pRegion is NULL
// on return from BA_GetBounds.  There must
// be room for maxRects rectangles (as specified in the bndInitialise
// call).  pRects may be a NULL pointer if maxRects was set to 0 in the
// bndInitialise call.
//
// pNumRects:
//
// A pointer to a variable where the number of rectangles returned at
// pRects is returned.  The contents of this variable are only valid if
// *pRegion is NULL on return from BA_GetBounds.
//
// fReset:
// Whether to reset the core's bounds variables after getting the current
// state or not.
//
//
void BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);


#ifdef DLL_DISP


typedef struct tagDD_BOUNDS
{
    UINT    iNext;
    BOOL    InUse;
    RECT    Coord;
    DWORD   Area;
} DD_BOUNDS;
typedef DD_BOUNDS FAR* LPDD_BOUNDS;



//
// Name:      BA_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    BA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
BOOL    BA_DDProcessRequest(DWORD fnEscape, LPOSI_ESCAPE_HEADER pRequest,
                DWORD cbRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif // !IS_16


//
// Name:      BA_QuerySpoilingBounds
//
// Purpose:   Return the current spoiling bounds.  That is, the bounds
//            which the share core is currently processing.
//
// Returns:   Nothing
//
// Params:    IN/OUT pRects    - Pointer to an array of rectangles to
//                               return the bounds in.  There must be at
//                               least BA_NUM_RECTS entries in this
//                               array.  The first *pNumRects entries are
//                               valid on return.
//            IN/OUT pNumRects - Returns the number of rectangles forming
//                               the spoiling bounds (can be zero).
//

void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects);



//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//

//
// Note that bndRectsArray and bndRectsSizeArray must contain space for
// BA_NUM_RECTS+1 rectangles for the merge algorithm.
//

//
// The function will recurse to a maximum level when trying to split
// rectangles up.  When this limit is reached it will start merging
// rather than splitting
//
#define ADDR_RECURSE_LIMIT 20

//
// The following constants are used to determine overlaps.
//
// - OL_NONE through OL_MERGE_YMAX are return codes - which need to be
//   distinct from all possible outcode combinations - allowing for the
//   minus outcodes for enclosed cases.
//
// - EE_XMIN through EE_YMAX are outcodes - which need to be uniquely
//   ORable binary constants within a single nibble.
//
// - OL_ENCLOSED through OL_SPLIT_XMAX_YMAX are outcode combinations for
//   internal and external edge overlap cases.
//
// See Overlap() for further description.
//
#define OL_NONE               -1
#define OL_MERGE_XMIN         -2
#define OL_MERGE_YMIN         -3
#define OL_MERGE_XMAX         -4
#define OL_MERGE_YMAX         -5

#define EE_XMIN 0x0001
#define EE_YMIN 0x0002
#define EE_XMAX 0x0004
#define EE_YMAX 0x0008

#define OL_ENCLOSED           -(EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_XMIN -(EE_XMIN | EE_YMIN | EE_YMAX)
#define OL_PART_ENCLOSED_YMIN -(EE_XMIN | EE_YMIN | EE_XMAX)
#define OL_PART_ENCLOSED_XMAX -(EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_YMAX -(EE_XMIN | EE_XMAX | EE_YMAX)

#define OL_ENCLOSES           EE_XMIN | EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMIN EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMAX EE_XMIN | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_YMIN EE_XMIN | EE_XMAX | EE_YMAX
#define OL_PART_ENCLOSES_YMAX EE_XMIN | EE_XMAX | EE_YMIN
#define OL_SPLIT_X            EE_YMIN | EE_YMAX
#define OL_SPLIT_Y            EE_XMIN | EE_XMAX
#define OL_SPLIT_XMIN_YMIN    EE_XMAX | EE_YMAX
#define OL_SPLIT_XMAX_YMIN    EE_XMIN | EE_YMAX
#define OL_SPLIT_XMIN_YMAX    EE_XMAX | EE_YMIN
#define OL_SPLIT_XMAX_YMAX    EE_XMIN | EE_YMIN

int BAOverlap(LPRECT pRect1, LPRECT pRect2 );

//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect);

//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect);


void BA_AddScreenData(LPRECT pRect);


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect( LPRECT pCand,  int level );


#endif // DLL_DISP



#endif // _H_BA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\bcd.h ===
//
// BCD.H
// Bitmap Compression & Decompression
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BCD
#define _H_BCD



#define BCD_MATCHCOUNT      8192
#define BCD_NORMALSIZE      65000
#define BCD_XORSIZE         65000


//
// VERSION 2 RLE codes
//
//
// The following codes fill a full single byte address space.  The approach
// is to use the high order bits to identify the code type and the low
// order bits to encode the length of the associated run.  There are two
// forms of order
// - regular orders which have a 5 bit length field (31 bytes of data)
// - "lite" orders with a 4 bit length
//
// A value of 0 in the length field indicates an extended length, where
// the following byte contains the length of the data.  There is also a
// "mega mega" form which has a two byte length field. (See end of
// codespace of the codes that define the megamega form).
//
// A set of codes at the high end of the address space is used to encode
// commonly occuring short sequences, in particular
// - certain single byte FGBG codings
// - single bytes of BLACK and WHITE
//
//
// SUMMARY
// *******
//                      7 6 5 4 3 2 1 0  76543210  76543210  76543210
//
// MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>
//
// BG_RUN               0 0 0 <length->
//
// MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>
//
// FG_RUN               0 0 1 <length->
//
// MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...
//
// FG_BG_IMAGE          0 1 0 <length->  <-data->  ...
//
// MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>
//
// COLOR_RUN            0 1 1 <length->  <color->
//
// MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...
//
// COLOR_IMAGE          1 0 0 <length->  <-data->  ...
//
// MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...
//
// PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...
//
// SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>
//
// SET_FG_FG_RUN        1 1 0 0 <-len->  <color->
//
// SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...
//
// SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...
//
// MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->
//
// DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->
//
// MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0
//
// MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1
//
// MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0
//
// MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1
//
// MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0
//
// MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1
//
// MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0
//
// MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1
//
// MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0
//
// Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000
// (Note that 0x01 will generally handled by the single pel insertion code)
//
// Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000
//
// Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000
//
// Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000
//
// BLACK                1 1 1 1 1 1 0 1
//
// WHITE                1 1 1 1 1 1 1 0
//
// START_LOSSY          1 1 1 1 1 1 1 1
//
//
//
// GENERAL NOTES
//
//
// - For MEGA runs the length encoded is the length of the run minus the
//   maximum length of the non-mega form.
//   In  the mega-mega form we encode the plain 16 bit length, to keep
//   encoding/deconding simple.
//
// - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We
//   use the fact that this is not generated in normal encoding to
//   encode <n background><1 foreground><n background>.  The same pel
//   insertion convention applies to any combination of MEGA_BG run and
//   BG_RUN
//
// - A packed image is encoded when we find that all the color fields in a
//   run have 0 in the high order nibble. We do not currently use this code
//   for 8 bit compression, but it is supported by the V2 decoder.
//
// - The set fg color code (Used to exist in V1) has been retired in favor
//   of separate commands for those codes that may embed a color.  Generally
//   This saves one byte for every foreground color transition for 8bpp.
//
// - The color run code is new for V2.  It indicates a color run where the
//   XOR is not performed.  This applies to, for example, the line of bits
//   immediately below a text line.  (There is no special case for runs of
//   the bg color - these are treated as any other color run.)
//
// - Observation shows a high occurrence of BG runs split by single FGBG
//   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is
//   handled by the implicit BG run break). Save 1 byte by encoding as
//   single codes
//
// - There is a relatively high occurrence of single pel color codes ff and
//   00.  Save 1 byte by encoding as special characters
//
// - The length in a FGBG run is slightly strange.  Because they generally
//   occur in multiples of 8 bytes we get a big saving if we encode the
//   length of a short run as length/8.  However, for those special
//   cases where the length is not a multiple of 8 we encode a long run.
//   Therefore the long form can only cover the range 1-256 bytes.
//   beyond that we use the mega-mega form.
//
//
// DETAILS OF COMPRESSION CODES
//
//
// BG_RUN
//
// Represents a background run (black:0) of the specified length.
//
//
//
// FG_BG_IMAGE/SET_FG_FG_BG_IMAGE
//
// Represents a binary image containing only the current foreground(1) and
// background(0) colors.
//
//
//
// FG_RUN/SET_FG_FG_RUN
//
// Represents a continuous foreground run of the specified length.
// The foreground color is white by default, and is changed by the
// SET_FG_FG_RUN version of this code.
//
//
//
// DITHERED_RUN
//
// Represents a run of alternating colors of the specified length.
//
//
//
// COLOR_IMAGE
//
// Represents a color image of the specified length.  No XOR is performed.
// This data is uncompressed, so we hope that we won't see
// many of these codes!
//
//
//
// COLOR_RUN
//
// Represents a color run of the specified length.  No XOR is performed.
// Since the color is not XORed, it is unlikely to match the running
// foreground color information.  Therefore this code always carries a
// color byte and there is no SET_FG_COLOR_RUN form of the code.
//
//
//
// PACKED_COLOR_IMAGE
//
// Represents a color image of the specified length, with pairs of colors
// packed into a single byte.  (This can only be done when the color info
// is zero in the high order nibble.)
//
//
//
// START_LOSSY
//
// Informs the decoder that lossy mode has been established and any of the
// following color runs will need pixel doubling performing.
// RLE decoding will remain in this mode until the end of this block
//
//

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   // 20
#define CODE_FG_RUN                 0x20   // 20
#define CODE_FG_BG_IMAGE            0x40   // 20
#define CODE_COLOR_RUN              0x60   // 20
#define CODE_COLOR_IMAGE            0x80   // 20
#define CODE_PACKED_COLOR_IMAGE     0xA0   // 20
#define CODE_SET_FG_FG_RUN          0xC0   // 10
#define CODE_SET_FG_FG_BG           0xD0   // 10
#define CODE_DITHERED_RUN           0xE0   // 10
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE
#define CODE_START_LOSSY            0xFF

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

//
// The special FGBG codes that correspond to codes F0-F7
//
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

//
// Run types as stored in the run index array
//
#define RUN_BG                      1
#define RUN_BG_PEL                  2
#define RUN_FG                      3
#define RUN_COLOR                   4
#define RUN_DITHER                  5
#define IMAGE_FGBG                  6
#define IMAGE_COLOR                 7
#define IMAGE_LOSSY_ODD             8


//
// The following structure contains the results of our intermediate scan of
// the buffer.  The offset field contains the expected offset into the
// target buffer following decompression of the associated order and is
// used for self-diagnosis.
//
typedef struct
{
    WORD    length;
    BYTE    type;
    BYTE    fgChar;
}
MATCH;



//
// Function Prototypes
//
// Note that the function compresses the whole bitmap in one call.  However
// it performs two cycles internally, once for the first line and once for
// all subsequent lines.  pelsPerLine (the number of pels on a row) MUST be
// supplied.
//
// The paremeters should be obvious, save
//
// pLossy = pointer to flag indicating we maydiscard part of incompressible
//          data
//
// When lossy compression is enabled any color run carries only half the
// pels and they must be doubled up.  (Also the encoder replaces color on
// alternate lines with BG_RUN thus giving a fourfold reduction in the
// data, but the decoder does not need any special code to handle this).
//
// The encoder may decide not to honor the lossy request because the data
// is highly compressible anyway.  If it determines this then the lossy
// flag is reset so that the caller may determine whether a subsequent
// non-lossy transmission is required or not.
//
//


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void Unpack4bpp(LPBYTE destbuf,
                             LPBYTE srcbuf,
                             UINT   srclen);

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void Pack4bpp(LPBYTE destbuf,
                           LPBYTE srcbuf,
                           UINT   srclen);

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
void XORBuffer(LPBYTE destbuf, LPBYTE srcbuf, UINT srclen, int rowDelta);

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   numPels,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  UINT   dstBufferSize,
                                  LPBOOL pLossy,
                                  LPBYTE nrmbuf,
                                  LPBYTE xorbuf,
                                  MATCH  FAR  *match);

UINT    DecompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   bytes,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  LPBYTE nrmbuf);



//
// The Compressed Data header structure.
//
// Rather than add a field to indicate V1 vs V2 compression we use the
// fact that V2 compression treats all the bitmap as main body and sets
// the first row size to zero to distinguish them.  I hesitate to do this
// but any bandwidth saving is important.
//
typedef struct _CD_HEADER
{
    TSHR_UINT16     cbCompFirstRowSize;
    TSHR_UINT16     cbCompMainBodySize;
    TSHR_UINT16     cbScanWidth;
    TSHR_UINT16     cbUncompressedSize;
} CD_HEADER;
typedef CD_HEADER *PCD_HEADER;

#define IsV2CompressedDataHeader(p)  ((p)->cbCompFirstRowSize == 0)
#define SetV2CompressedDataHeader(p) ((p)->cbCompFirstRowSize = 0)


//
// Types of bitmap compression.
//
#ifdef _DEBUG // for assertion
#define RLE_V1     1
#endif
#define RLE_V2     2



//
//
// PROTOTYPES
//
//


#endif // _H_BCD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ast120.h ===
//
// AppSharing T.120 Layer
//      * GCC (conference management)
//      * MCS (data)
//      * FLOW (data queuing, flow control)
//
// This is also used by ObMan for old Whiteboard, but old Whiteboard will
// disappear in the next version of NM.
//
// Copyright (c) Microsoft 1998-
//

#ifndef _H_AST120
#define _H_AST120

#include <confreg.h>

// REAL T.120 headers
#include <t120.h>
#include <igccapp.h>
#include <imcsapp.h>

//
// GCC PART
//

//
// Call Manager Secondaries
//
#define CMTASK_FIRST    0
typedef enum
{
    CMTASK_OM = CMTASK_FIRST,
    CMTASK_AL,
    CMTASK_DCS,
    CMTASK_WB,
    CMTASK_MAX
}
CMTASK;



//
// The GCC Application Registry Key.  This is used for enrolling Groupware
// with GCC and for assigning tokens: for all tokens the registration key
// is the Groupware application key followed by the specific tokenKey for
// this secondary.
//
// The MFGCODE portion of this key has been assigned by the ITU.
//
//     USACode1    0xb5
//     USACode2    0x00
//     MFGCode1    0x53
//     MFGCode2    0x4c
//     "Groupware" 0x02
//
// The length of the key in bytes including the NULLTERM.
//
//
#define GROUPWARE_GCC_APPLICATION_KEY     "\xb5\x00\x53\x4c\x02"





//
// Call Manager Events
//
enum
{
    CMS_NEW_CALL = CM_BASE_EVENT,
    CMS_END_CALL,
    CMS_PERSON_JOINED,
    CMS_PERSON_LEFT,
    CMS_CHANNEL_REGISTER_CONFIRM,
    CMS_TOKEN_ASSIGN_CONFIRM
};



//
// CM_STATUS
//
typedef struct tagCM_STATUS
{
    UINT            callID;
    UINT            peopleCount;
    BOOL            fTopProvider;
    UINT            topProviderID;
    TSHR_PERSONID   localHandle;
    char            localName[TSHR_MAX_PERSON_NAME_LEN];
}
CM_STATUS;
typedef CM_STATUS * PCM_STATUS;


BOOL WINAPI CMS_GetStatus(PCM_STATUS pcmStatus);



//
// Secondary instance data
//
typedef struct tagCM_CLIENT
{
    STRUCTURE_STAMP
    PUT_CLIENT      putTask;
    CMTASK          taskType;
    UINT            useCount;

    // Registering Channel
    UINT            channelKey;

    // Assigning Token
    UINT            tokenKey;

    BOOL            exitProcRegistered:1;
}
CM_CLIENT;
typedef CM_CLIENT * PCM_CLIENT;



//
// Person element in linked list of people currently in conference
//
typedef struct tagCM_PERSON
{
    BASEDLIST           chain;
    TSHR_PERSONID       netID;
}
CM_PERSON;
typedef CM_PERSON * PCM_PERSON;



//
// Primary data
//
typedef struct tagCM_PRIMARY
{
    STRUCTURE_STAMP
    PUT_CLIENT          putTask;

    BOOL                exitProcRegistered;

    //
    // Secondary tasks
    //
    PCM_CLIENT          tasks[CMTASK_MAX];

    //
    // T.120/call state stuff
    //
    UINT                callID;
    BOOL                currentCall;
    BOOL                fTopProvider;

    BOOL                bGCCEnrolled;

    IGCCAppSap        * pIAppSap;
    UserID              gccUserID;
    UserID              gccTopProviderID;

    //
    // People conference stuff
    //
    char                localName[TSHR_MAX_PERSON_NAME_LEN];

    UINT                peopleCount;
    BASEDLIST           people;
}
CM_PRIMARY;
typedef CM_PRIMARY * PCM_PRIMARY;



__inline void ValidateCMP(PCM_PRIMARY pcmPrimary)
{
    ASSERT(!IsBadWritePtr(pcmPrimary, sizeof(CM_PRIMARY)));
    ASSERT(pcmPrimary->putTask);
}



__inline void ValidateCMS(PCM_CLIENT pcm)
{
    extern PCM_PRIMARY  g_pcmPrimary;

    ValidateCMP(g_pcmPrimary);

    ASSERT(!IsBadWritePtr(pcm, sizeof(CM_CLIENT)));
    ASSERT(pcm->putTask);

    ASSERT(pcm->taskType >= CMTASK_FIRST);
    ASSERT(pcm->taskType < CMTASK_MAX);
    ASSERT(g_pcmPrimary->tasks[pcm->taskType] == pcm);
}

//
// CM Primary Functions
//

BOOL CMP_Init(BOOL * pfCleanup);
void CMP_Term(void);

void CMPCallEnded(PCM_PRIMARY pcmPrimary);
void CMPBroadcast(PCM_PRIMARY pcmPrimary, UINT event, UINT param1, UINT param2);

void CALLBACK CMPExitProc(LPVOID pcmPrimary);


BOOL CMPGCCEnroll(PCM_PRIMARY pcmPrimary,
                  GCCConferenceID  conferenceID,
                  BOOL          fEnroll);

void CMPProcessPermitToEnroll(PCM_PRIMARY pcmPrimary,
                              GCCAppPermissionToEnrollInd FAR * pMsg);

void CMPProcessEnrollConfirm(PCM_PRIMARY pcmPrimary,
                             GCCAppEnrollConfirm FAR * pMsg);

void CMPProcessRegistryConfirm(PCM_PRIMARY pcmPrimary,
                               GCCMessageType         messageType,
                               GCCRegistryConfirm FAR * pMsg);

void CMPProcessAppRoster(PCM_PRIMARY pcmPrimary,
                         GCCConferenceID confID,
                         GCCApplicationRoster FAR * pAppRoster);

//
// Process GCC callbacks
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg FAR * pMsg);

void CMPBuildGCCRegistryKey(UINT dcgKeyNum, GCCRegistryKey FAR * pGCCKey, LPSTR dcgKeyStr);



//
// CM Secondary
//

BOOL CMS_Register(PUT_CLIENT putTask, CMTASK taskType, PCM_CLIENT * pCmHandle);
void CMS_Deregister(PCM_CLIENT * pCmHandle);


BOOL CMS_ChannelRegister(PCM_CLIENT pcmClient, UINT channelKey, UINT channelID);
BOOL CMS_AssignTokenId(PCM_CLIENT pcmClient, UINT tokenKey);

void CALLBACK CMSExitProc(LPVOID pcmClient);



//
// MCS PART
//


//
// Errors
//
enum
{
    // Generic errors
    NET_RC_NO_MEMORY                = NET_BASE_RC,
    NET_RC_INVALID_STATE,

    // S20 errors
    NET_RC_S20_FAIL,

    // MGC errors
    NET_RC_MGC_ALREADY_INITIALIZED,
    NET_RC_MGC_INVALID_USER_HANDLE,
    NET_RC_MGC_INVALID_LENGTH,
    NET_RC_MGC_INVALID_DOMAIN,
    NET_RC_MGC_TOO_MUCH_IN_USE,
    NET_RC_MGC_NOT_YOUR_BUFFER,
    NET_RC_MGC_LIST_FAIL,
    NET_RC_MGC_NOT_CONNECTED,
    NET_RC_MGC_NOT_SUPPORTED,
    NET_RC_MGC_NOT_INITIALIZED,
    NET_RC_MGC_INIT_FAIL,
    NET_RC_MGC_DOMAIN_IN_USE,
    NET_RC_MGC_NOT_ATTACHED,
    NET_RC_MGC_INVALID_CONN_HANDLE,
    NET_RC_MGC_INVALID_UP_DOWN_PARM,
    NET_RC_MGC_INVALID_REMOTE_ADDRESS,
    NET_RC_MGC_CALL_FAILED
};


//
// Results
//
typedef TSHR_UINT16     NET_RESULT;

enum
{
    NET_RESULT_OK   = 0,
    NET_RESULT_NOK,
    NET_RESULT_CHANNEL_UNAVAILABLE,
    NET_RESULT_DOMAIN_UNAVAILABLE,
    NET_RESULT_REJECTED,
    NET_RESULT_TOKEN_ALREADY_GRABBED,
    NET_RESULT_TOKEN_NOT_OWNED,
    NET_RESULT_NOT_SPECIFIED,
    NET_RESULT_UNKNOWN,
    NET_RESULT_USER_REJECTED
};


//
// Reaons
//
typedef enum
{
    NET_REASON_DOMAIN_DISCONNECTED = 1,
    NET_REASON_DOMAIN_UNAVAILABLE,
    NET_REASON_TOKEN_NONEXISTENT,
    NET_REASON_USER_REQUESTED,
    NET_REASON_CHANNEL_UNAVAILABLE,
    NET_REASON_UNKNOWN
}
NET_REASON;



//
// Events
//
enum
{
    NET_EVENT_USER_ATTACH = NET_BASE_EVENT,
    NET_EVENT_USER_DETACH,
    NET_EVENT_CHANNEL_JOIN,
    NET_EVENT_CHANNEL_LEAVE,
    NET_EVENT_TOKEN_GRAB,
    NET_EVENT_TOKEN_INHIBIT,
    NET_EVENT_DATA_RECEIVED,
    NET_FEEDBACK,
    NET_FLOW,
    NET_MG_SCHEDULE,
    NET_MG_WATCHDOG
};




//
// FOR MCS USERS (ALL APPS, INCLUDING CALL MANAGER)
//
//          state->|   0  |  1     |  2     |    3     |   4     |   5
//                 |CTRLR |CTRLR   |CTLR    |CTLR      |CTLR     |CTLR
//                 |state |state 2,|state2, |state2,   |state 3, |state 3
//                 | 0/1  |user not|user    |user      |user     |user
// verb/event      |      |attached|pending |attached  |attached |pending
//       |         |......|........|........|..........|.........|.........
//       V         |      |        |        |          |         |
// _get_buffer     |   X  |  X     |   X    |    -     |  **     |  X
// _free_buffer    |   X  |  X     |   X    |    -     |  -      |  -
// _realloc_bfr    |   X  |  X     |   X    |    -     |  -      |  -
// _attach_user    |   X  |  ->2   |   X    |    X     |  X      |  X
// _detach_user    |   X  |  X     |   X    |    ->1   |  ->0    |  X
// _channel_join   |   X  |  X     |   X    |    -     |  X      |  X
// _channel_leave  |   X  |  X     |   X    |    -     |  -      |  X
// _send_data      |   X  |  X     |   X    |    -     |  X      |  X
//                 |      |        |        |          |         |
// _STOP_CONTRLR*  |      |  ->0   |  ->5   |    ->4   |         |
//                 |      |        |        |          |         |
// _ATTACH_CNF OK  |      |        |  ->3   |          |         |  ->4
// _ATTACH_CNF FAIL|      |        |  ->1   |          |         |  ->0
// _DETACH_IND-SELF|      |        |  ->1   |   ->1    |  ->0    |
// _DETACH_IND-othr|      |        |        |    -     |  -      |
// _JOIN_CONFIRM   |      |        |        |    -     |  -      |
// _LEAVE_INDICAT  |      |        |        |    -     |  -      |
// _SEND_INDICAT   |      |        |        |    -     |  -      |
// =======================================================================
//
// NOTES ** when the controller is STOPPING the NET_GetBuffer
//          verb is valid but always returns a NULL buffer (no memory)
//
//       *  the STOP_CONTROLLER event is internally generated, and is
//          not seen across the API.  It is generated when the controller
//          issues the NET_StopController verb and causes the state change
//          (to state 0, 4 or 5) such that the NET_AttachUser,
//          ChannelJoin and NET_SendData verbs are rejected.
//
//
//



//
// Priorities
//
#define NET_INVALID_PRIORITY        ((NET_PRIORITY)-1)

enum
{
    NET_TOP_PRIORITY = 0,
    NET_HIGH_PRIORITY,
    NET_MEDIUM_PRIORITY,
    NET_LOW_PRIORITY,
    NET_NUM_PRIORITIES
};


//
// SFR6025: This flag is or-ed with the priority bit to indicate to the MCS
//          glue that it should send data on all channels.
//

//
// FOR OBMAN ONLY -- REMOVE IN NM 4.0
//
#define NET_SEND_ALL_PRIORITIES          0x8000






#define NET_ALL_REMOTES             ((NET_UID)1)
#define NET_INVALID_DOMAIN_ID       (0xFFFFFFFF)
#define NET_UNUSED_IDMCS            1





typedef TSHR_UINT16         NET_UID;            // MCS user IDs
typedef TSHR_UINT16         NET_CHANNEL_ID;     // MCS channel IDs
typedef TSHR_UINT16         NET_TOKEN_ID;       // MCS token IDs
typedef TSHR_UINT16         NET_PRIORITY;       // MCS priorities



//
// Forward decls of MGC structures
//
typedef struct tagMG_BUFFER *   PMG_BUFFER;
typedef struct tagMG_CLIENT *   PMG_CLIENT;


//
// Flow control structure - This contains the target latency (in mS) and
// stream size (in bytes) for each User Attachment
// lonchanc: used by S20, MG, and OM.
//
typedef struct tag_NET_FLOW_CONTROL
{
    UINT        latency[NET_NUM_PRIORITIES];
    UINT        streamSize[NET_NUM_PRIORITIES];
}
NET_FLOW_CONTROL, * PNET_FLOW_CONTROL;



//
// NET_EV_JOIN_CONFIRM and NET_EV_JOIN_CONFIRM_BY_KEY
// join_channel confirm:
// lonchanc: used by S20, MG, and OM.
//
typedef struct tagNET_JOIN_CNF_EVENT
{
    UINT                    callID;

    NET_RESULT              result;      // NET_RESULT_USER_ACCEPTED/REJECTED
    TSHR_UINT16             pad1;

    NET_CHANNEL_ID          correlator;
    NET_CHANNEL_ID          channel;
}
NET_JOIN_CNF_EVENT;
typedef NET_JOIN_CNF_EVENT * PNET_JOIN_CNF_EVENT;


//
// NET_EV_SEND_INDICATION
// send data indication: see MG_SendData()
// Despite its name, this event indicates that data has been RECEIVED!
// lonchanc: used by MG and S20
//
typedef struct tag_NET_SEND_IND_EVENT
{
    UINT                    callID;

    NET_PRIORITY            priority;
    NET_CHANNEL_ID          channel;

    UINT                    lengthOfData;
    LPBYTE                  data_ptr;      // Pointer to the real data.
}
NET_SEND_IND_EVENT;
typedef NET_SEND_IND_EVENT * PNET_SEND_IND_EVENT;



//
// MGC, FLOW CONTROL
//

//
// MG tasks
//
#define MGTASK_FIRST    0
typedef enum
{
    MGTASK_OM = MGTASK_FIRST,
    MGTASK_DCS,
    MGTASK_MAX
}
MGTASK;


//
// Buffer types
//
enum
{
    MG_TX_BUFFER = 1,
    MG_RX_BUFFER,
    MG_EV_BUFFER,
    MG_TX_PING,
    MG_TX_PONG,
    MG_TX_PANG,
    MG_RQ_CHANNEL_JOIN,
    MG_RQ_CHANNEL_JOIN_BY_KEY,
    MG_RQ_CHANNEL_LEAVE,
    MG_RQ_TOKEN_GRAB,
    MG_RQ_TOKEN_INHIBIT,
    MG_RQ_TOKEN_RELEASE
};


//
// Period of watchdog timer to detect lost connections
//
#define MG_TIMER_PERIOD                 1000


//
// MG priorities:
//
#define MG_HIGH_PRIORITY        NET_HIGH_PRIORITY
#define MG_MEDIUM_PRIORITY      NET_MEDIUM_PRIORITY
#define MG_LOW_PRIORITY         NET_LOW_PRIORITY

#define MG_PRIORITY_HIGHEST     MG_HIGH_PRIORITY
#define MG_PRIORITY_LOWEST      MG_LOW_PRIORITY
#define MG_NUM_PRIORITIES       (MG_PRIORITY_LOWEST - MG_PRIORITY_HIGHEST + 1)


//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NETPRIORITY_LOWEST.  Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set.  So, to validate a priority:
//  - knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
//  - set the valid raw prioririty to
//      NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//      NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//      the raw priority if it is in the valid range
//  - add the original ...ALL_PRIORITIES flag to the valid raw priority
//
#define MG_VALID_PRIORITY(p)                                                 \
    ((((p)&~NET_SEND_ALL_PRIORITIES)<MG_HIGH_PRIORITY)?                      \
      (MG_HIGH_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                      \
      (((p)&~NET_SEND_ALL_PRIORITIES)>MG_LOW_PRIORITY)?                      \
        (MG_LOW_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                     \
        (p))


//
//
// The initial stream size setting may appear high, but it is set so that
// in a LAN scenario we do not require the app to place a lot of forward
// pressure on the pipe before it opens up.  In a non-LAN scenario we may
// not do enough spoiling to start with, but in actual fact DCS tends
// to send less data than this limit anyway, so we should reduce it
// quite quickly without flooding the buffers.
//
#define FLO_INIT_STREAMSIZE     8000
#define FLO_MIN_STREAMSIZE       500
#define FLO_MAX_STREAMSIZE    256000
#define FLO_MIN_PINGTIME         100
#define FLO_INIT_PINGTIME       1000

//
// This is the max number of bytes that can be allocated per stream if a
// pong has not been received (i.e. FC is not operational).
//
#define FLO_MAX_PRE_FC_ALLOC   16000

//
// This is the max number of pkts outstanding before we apply back
// pressure:
//
#define FLO_MAX_RCV_PACKETS       5

//
// This is the max number of pkts outstanding before we get worried about
// creep:
//
#define FLO_MAX_RCV_PKTS_CREEP    250

//
// The maximum number of flow controlled streams.
//
#define FLO_MAX_STREAMS       128
#define FLO_NOT_CONTROLLED    FLO_MAX_STREAMS




//
// STRUCTURE : FLO_STREAM_DATA
//
// DESCRIPTION:
//
// This structure holds all the static data for a flow control stream
//
// FIELDS:
//
// channel
// priority
// pingValue         - Next ping value to be sent on the pipe
// eventNeeded       - We need to wake up the app because we have rejected
//                     a buffer allocation request
// backlog           - the allowable backlog in mS bejond which we apply
//                     back pressure
// pingNeeded        - Send a ping at the next opportunity
// pingTime          - Minimum time, in mS, between each ping
// gotPong           - Indicates we have received a pong from some remote
//                     party and so flow control can commence
// lastPingTime      - Time for last ping, in timer ticks
// nextPingTime      - Time for next ping, in timer ticks
// lastDenialTime    - Previous time (in ticks) that we started denying
//                     buffer requests
// curDenialTime     - Time in ticks that we most recently started denying
//                     buffer requests
// DC_ABSMaxBytesInPipe
//                   - Absolute maximum buffer allocation for this stream
// maxBytesInPipe    - Current buffer allocation limit
// bytesInPipe       - Current amount of data outstanding on this stream.
//                     This includes data currently waiting to be sent.
// users             - Base for queue of User correlators
// bytesAllocated    - The current amount of data in the glue for this
//                     stream which has not been sent. This is different
//                     to bytesInPipe which is the amount of unacknowledged
//                     data in this stream.
//
//
typedef struct tagFLO_STREAM_DATA
{
    STRUCTURE_STAMP

    NET_CHANNEL_ID      channel;
    WORD                gotPong:1;
    WORD                eventNeeded:1;
    WORD                pingNeeded:1;

    UINT                priority;
    UINT                pingValue;
    UINT                backlog;
    UINT                pingTime;
    UINT                lastPingTime;
    UINT                nextPingTime;
    UINT                lastDenialTime;
    UINT                curDenialTime;
    UINT                DC_ABSMaxBytesInPipe;
    UINT                maxBytesInPipe;
    UINT                bytesInPipe;
    UINT                bytesAllocated;

    BASEDLIST              users;
}
FLO_STREAM_DATA;
typedef FLO_STREAM_DATA * PFLO_STREAM_DATA;


void __inline ValidateFLOStr(PFLO_STREAM_DATA pStr)
{
    if (pStr != NULL)
    {
        ASSERT(!IsBadWritePtr(pStr, sizeof(FLO_STREAM_DATA)));
    }
}



//
// The FLO callback function
//
// A wakeup type callback indicates that a back pressure situation has
// been relieved.
//
// A buffermod callback indicates this as well, but also indicates that
// the buffer size for controlling flow on the designated channel/priority
// has changed.
//
#define FLO_WAKEUP     1
#define FLO_BUFFERMOD  2
typedef void (* PFLOCALLBACK)(PMG_CLIENT    pmgClient,
                                     UINT       callbackType,
                                     UINT       priority,
                                     UINT       newBufferSize);


//
// STRUCTURE : FLO_STATIC_DATA
//
// DESCRIPTION:
//
// This structure holds all the instance specific static data for the
// Flow Control DLL
//
// FIELDS:
//
// numStreams     - ID of the highest allocated stream
// rsvd           - reserved
// callback       - pointer to a callback function
// pStrData       - an array of FLO_STREAM_DATA pointers.
//
//
typedef struct FLO_STATIC_DATA
{
    UINT                numStreams;
    PFLOCALLBACK        callBack;
    PFLO_STREAM_DATA    pStrData[FLO_MAX_STREAMS];
}
FLO_STATIC_DATA;
typedef FLO_STATIC_DATA * PFLO_STATIC_DATA;



typedef struct FLO_USER
{
    BASEDLIST          list;

    STRUCTURE_STAMP

    WORD            userID;
    WORD            lastPongRcvd;
    WORD            pongNeeded;
    BYTE            sendPongID;
    BYTE            pad1;

    UINT            sentPongTime;    // Time we actually sent the pong
    WORD            rxPackets;       // Count of packets outstanding
    WORD            gotPong;         // Indicates this user has ponged
                                        // and they are permitted to apply
                                        // back pressure to our sends
    UINT            numPongs;        // total number of pongs from user
    UINT            pongDelay;       // total latency across pongs
}
FLO_USER;
typedef FLO_USER * PFLO_USER;


void __inline ValidateFLOUser(PFLO_USER pFloUser)
{
    ASSERT(!IsBadWritePtr(pFloUser, sizeof(FLO_USER)));
}


//
// Maximum wait time before assuming a user is offline
// We need to keep this high until the apps become "well behaved" and
// respond to the flow control buffer size recommendations.
//
#define FLO_MAX_WAIT_TIME     20000



//
//
// Client Control Block
//
//

typedef struct tagMG_CLIENT
{
    PUT_CLIENT      putTask;
    PCM_CLIENT      pcmClient;

    BASEDLIST       buffers;       // list of children buffers
    BASEDLIST       pendChain;     // Chain of pending request from client
    BASEDLIST       joinChain;     // Chain of pending join-by-key requests

    //
    // MCS user attachment info
    //
    PIMCSSap      	m_piMCSSap;       // user interface ptr returned by MCS
    UserID          userIDMCS;        // user ID returned by MCS
    FLO_STATIC_DATA flo;              // flow control structure


    WORD            eventProcReg:1;
    WORD            lowEventProcReg:1;
    WORD            exitProcReg:1;
    WORD            joinPending:1;   // Is there a channel join outstanding ?
    WORD            userAttached:1;

    WORD            joinNextCorr;

    NET_FLOW_CONTROL flowControl;  // flow control latency/backlog params
}
MG_CLIENT;


void __inline ValidateMGClient(PMG_CLIENT pmgc)
{
    ASSERT(!IsBadWritePtr(pmgc, sizeof(MG_CLIENT)));
    ValidateUTClient(pmgc->putTask);
}



typedef struct tagMG_INT_PKT_HEADER
{
    TSHR_UINT16         useCount;   // The use count of this packet.  This
                                    //   is required for sending the same
                                    //   data on multiple channels.

    TSHR_NET_PKT_HEADER header;
}
MG_INT_PKT_HEADER;
typedef MG_INT_PKT_HEADER * PMG_INT_PKT_HEADER;




//
//
// Buffer Control Block
//
//
typedef struct tagMG_BUFFER
{
    STRUCTURE_STAMP

    UINT                type;

    BASEDLIST           pendChain;      // Used when the buffer is added to the
    BASEDLIST           clientChain;

    PMG_INT_PKT_HEADER  pPktHeader;     // Pointer to MCS control info
    void *              pDataBuffer;    // Pointer passed to apps
    UINT                length;         // length of the associated packet

    ChannelID           channelId;      // Send destination, or token grab req
    ChannelID           channelKey;

    UserID              senderId;
    NET_PRIORITY        priority;

    BOOL                eventPosted;
    UINT                work;           // work field for misc use

    PFLO_STREAM_DATA    pStr;           // Pointer to the FC stream
}
MG_BUFFER;


void __inline ValidateMGBuffer(PMG_BUFFER pmgb)
{
    ASSERT(!IsBadWritePtr(pmgb, sizeof(MG_BUFFER)));
}


//
//
//
// MACROS
//
//
//

//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NET_PRIORITY_LOWEST. Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set. So, to validate a priority:
// -  knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
// -  set the valid raw priority to
//   -  NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//   -  NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//   -  the raw priority if it is in the valid range
// -  add the original ...ALL_PRIORITIES flag to the valid raw priority.
//


//
//
//
// FUNCTION PROTOTYPES
//
//
//

//
//
//  MGLongStopHandler(...)
//
// This function is registered as a low priority event handler for each
// client.  It catches any unprocessed network events and frees any
// associated memory.
//
//
BOOL CALLBACK MGLongStopHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);

//
//
//  MGEventHandler(...)
//
// This function is registered as a high priority event handler for the
// processing of MG_ChannelJoinByKey, MCS request handling and scheduling.
// It catches NET channel join confirm and CMS register channel confirm
// events, and massages them into the correct return events for the app.
// It queues requests coming from the app context into the glue context
// and schedules queued requests.
//
//
BOOL CALLBACK MGEventHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);


//
UINT MGHandleSendInd(PMG_CLIENT pmgClient, PSendData pSendInfo);



//
//
//  MGNewBuffer(...)
//  NewTxBuffer(...)
//  NewRxBuffer(...)
//  FreeBuffer(...)
//
// The New function allocates and initialises a buffer , allocates buffer
// memory of the specified size and type and adds the  to the client's
// list of buffer s.
//
// The Tx version performs flow control on the buffer allocation request
// The Rx version just allocates a receive buffer
//
// The Free function discards a buffer , discards the associated buffer
// memory, decrements the client's count of memory in use and removes the
//  from the client's list of buffer s.
//
//

void MGNewCorrelator(PMG_CLIENT ppmgClient, WORD * pCorrelator);

UINT MGNewBuffer(PMG_CLIENT pmgClient, UINT typeOfBuffer,
                                PMG_BUFFER     * ppBuffer);

UINT MGNewDataBuffer(PMG_CLIENT           pmgClient,
                                  UINT                typeOfBuffer,
                                  UINT                sizeOfBuffer,
                                  PMG_BUFFER     * ppBuffer);

UINT MGNewTxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                UINT              sizeOfBuffer,
                                PMG_BUFFER   * ppBuffer);

UINT MGNewRxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                NET_CHANNEL_ID        senderID,
                                PMG_BUFFER   		* ppBuffer);

void MGFreeBuffer(PMG_CLIENT pmgClient, PMG_BUFFER  * ppBuffer);


//
//
//  MGProcessDomainWatchdog(...)
//
// Handle domain watchdog timer ticks.
//
//
void MGProcessDomainWatchdog(PMG_CLIENT pmgClient);

void MGProcessEndFlow(PMG_CLIENT pmgClient, ChannelID channel);

UINT MGPostJoinConfirm(PMG_CLIENT pmgClient,
                                    NET_RESULT      result,
                                    NET_CHANNEL_ID  channel,
                                    NET_CHANNEL_ID  correlator);



NET_RESULT TranslateResult(WORD Result);


//
//
//  MGFLOCallBack(...)
//
// Callback poked by flow control to trigger the app to retry buffer
// requests thet were previously rejected
//
//
void        MGFLOCallBack(PMG_CLIENT    pmgClient,
                                  UINT      callbackType,
                                  UINT      priority,
                                  UINT      newBufferSize);




//
//
//  MGProcessPendingQueue(...)
//
// Called whenever MG wants to try and execute pending requests.  Requests
// are queued because they may fail for a transient reason, such as MCS
// buffer shortage.
//
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient);




BOOL    MG_Register(MGTASK task, PMG_CLIENT * pmgClient, PUT_CLIENT putTask);
void    MG_Deregister(PMG_CLIENT * ppmgClient);

void CALLBACK MGExitProc(LPVOID uData);






UINT  MG_Attach(PMG_CLIENT pmgClient,  UINT callID, PNET_FLOW_CONTROL pFlowControl);
void  MG_Detach(PMG_CLIENT pmgClient);
void  MGDetach(PMG_CLIENT pmgClient);



UINT MG_ChannelJoin(PMG_CLIENT pmgClient, NET_CHANNEL_ID * pCorrelator,
                                        NET_CHANNEL_ID  channel);

UINT MG_ChannelJoinByKey(PMG_CLIENT pmgClient,
                                             NET_CHANNEL_ID * pCorrelator,
                                             WORD          channelKey);

void MG_ChannelLeave(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel);


UINT MG_GetBuffer(PMG_CLIENT pmgClient, UINT length,
                                      NET_PRIORITY   priority,
                                      NET_CHANNEL_ID channel,
                                      void **       buffer);

void MG_FreeBuffer(PMG_CLIENT pmgClient,
                                       void **      buffer);

UINT MG_SendData(PMG_CLIENT pmgClient,
                                     NET_PRIORITY   priority,
                                     NET_CHANNEL_ID channel,
                                     UINT       length,
                                     void **       data);

UINT  MG_TokenGrab(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

UINT  MG_TokenInhibit(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

void MG_FlowControlStart(PMG_CLIENT  pmgClient,
                                          NET_CHANNEL_ID channel,
                                          NET_PRIORITY   priority,
                                          UINT       backlog,
                                          UINT       maxBytesOutstanding);

//
// API FUNCTION: FLO_UserTerm
//
// DESCRIPTION:
//
// Called by an application to end flow control on all the channels
// associated with a particular user.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
//
// RETURNS: Nothing.
//
//
void FLO_UserTerm(PMG_CLIENT pmgClient);



//
// API FUNCTION: FLO_StartControl
//
// DESCRIPTION:
//
// The application calls this function whenever it wants a data stream to
// be flow controlled
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// channel - channel id of channel to be flow controlled
// priority - priority of the stream to be controlled
// backlog - the maximum backlog (in mS) allowed for this stream
// maxBytesOutstanding - the maximum number of bytes allowed in the stream
//                       irrespective of the backlog.  0 = use default of
//                       64 KBytes
//
// RETURNS:
// None
//
//
void FLO_StartControl(PMG_CLIENT    pmgClient,
                              NET_CHANNEL_ID channel,
                              UINT       priority,
                              UINT       backlog,
                              UINT       maxBytesOutstanding);


void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
);

//
// API FUNCTION: FLO_AllocSend
//
// DESCRIPTION:
//
// The application is requesting a buffer in order to send a packet.  This
// may trigger a flow control packet in advance of the application packet.
// Flow control may choose to reject the packet with NET_OUT_OF_RESOURCE in
// which case the application must reschedule the allocation at a ater
// date.  To assist the rescheduling, if ever a send is rejected then flow
// control will call the application callback to trigger the reschedule.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     priority - The priority for this buffer
//     channel  - The channnel on which to send the packet
//     size     - The size of the packet
//     ppStr    - Pointer to the pointer to the FC stream. This is a
//                return value.
//
//
UINT FLO_AllocSend(PMG_CLIENT   pmgClient,
                             UINT               priority,
                             NET_CHANNEL_ID         channel,
                             UINT               size,
                             PFLO_STREAM_DATA * ppStr);

//
// API FUNCTION: FLO_ReallocSend
//
// DESCRIPTION:
//
// The application has requested that the glue send a packet, but the
// packet contains less data than originally requested.
// Flow control heuristics get thrown out unless we logically free the
// unused portion of the packet for reuse for other allocations.
// If we didn't do this then we might see a 8K packet, for example,
// complete in 1 second because the app only put 1K of data in it.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     pStr     - The flow control stream to be corrected
//     size     - The size of the packet that has been unused
//
// RETURNS:
//
// None
//
//
void FLO_ReallocSend(PMG_CLIENT pmgClient,
                             PFLO_STREAM_DATA       pStr,
                             UINT               size);

//
// API FUNCTION: FLO_DecrementAlloc
//
// DESCRIPTION:
//
// This function decrements the bytesAllocated count for a given stream.
// It is called whenever a packet is sent or removed from the send chain.
//
// PARAMETERS:
//
//     pStr     - The flow control stream to be decremented
//     size     - The size to decrement
//
// RETURNS:
//
// None
//
//
void FLO_DecrementAlloc(      PFLO_STREAM_DATA       pStr,
                                UINT               size);

//
// API FUNCTION: FLO_ReceivedPacket
//
// DESCRIPTION:
//
// Upon receipt of a flow control packet the MCS glue calls this function
// and then ignores the packet.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// pPkt     - pointer to the packet, for FLO to process
//
// RETURNS:
//
// None
//
//
void FLO_ReceivedPacket(PMG_CLIENT pmgClient, PTSHR_FLO_CONTROL pPkt);


//
// API FUNCTION: FLO_AllocReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer is now in use by the application
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attacgment cb
// priority
// channel
// size        - size of the buffer just been allocated
//
// RETURNS:
//
// None
//
//
void FLO_AllocReceive(PMG_CLIENT         pmgClient,
                              UINT       priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_FreeReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer has ben handed back by the
// application.
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attachment cb
// priority
// channel
// size        - size of the buffer just been freed
//
// RETURNS:
//
// None
//
//
void FLO_FreeReceive(PMG_CLIENT    pmgClient,
                              NET_PRIORITY priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_CheckUsers
//
// DESCRIPTION:
//
// Called periodically by each client to allow flow control to determine if
// remote users have left the channel
//
// PARAMETERS:
//
// pmg - pointer to the user
//
// RETURNS:
//
// None
//
//
void FLO_CheckUsers(PMG_CLIENT pmgClient);

//
// FLOGetStream()
//
UINT FLOGetStream(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel, UINT priority,
        PFLO_STREAM_DATA * ppStr);


void FLOStreamEndControl(PMG_CLIENT pmgClient, UINT stream);

void FLOPing(PMG_CLIENT pmgClient, UINT stream, UINT curtime);
void FLOPang(PMG_CLIENT pmgClient, UINT stream, UINT userID);
void FLOPong(PMG_CLIENT pmgClient, UINT stream, UINT userID, UINT pongID);


//
// API FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a user to a flow controlled stream
//
// PARAMETERS:
//
// userID - ID of the new user (single member channel ID)
// pStr - pointer to the stream to receive the new user
//
// RETURNS:
//
// None
//
//
PFLO_USER FLOAddUser(UINT         userID,
                                PFLO_STREAM_DATA pStr);

//
// API FUNCTION: FLO_RemoveUser
//
// DESCRIPTION:
//
// Remove a user from a flow controlled stream
//
// PARAMETERS:
//
// pmg - pointer to the MCS glue user
// userID - ID of the bad user (single member channel ID)
//
// RETURNS:
//
// None
//
//
void FLO_RemoveUser(PMG_CLIENT pmgClient, UINT userID);



//
// FUNCTION: MGCallback
//
// DESCRIPTION:
//
// This function is the callback passed to MCS.  The glue layer receives
// all communication from MCS via this function.  It converts MCS messages
// into DC-Groupware events and posts them to the relevant client(s).
//
//
void CALLBACK MGCallback( unsigned int       mcsMessageType,
                          unsigned long      eventData,
                          unsigned long      pUser );


#endif // _H_AST120

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\asmaster.h ===
#ifndef _ASMASTER_H_
#define _ASMASTER_H_




class ASMaster : public IAppSharing
{
    friend BOOL CALLBACK eventProc(LPVOID, UINT, UINT_PTR, UINT_PTR);

public:

	ASMaster(UINT flags, IAppSharingNotify * pNotify);
    ~ASMaster();

	//
	// IUnknown methods:
	//

    STDMETHOD(QueryInterface)(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	//
	// IAppSharing methods:
	//

    //
    // Status
    //
    STDMETHODIMP_(BOOL) IsSharingAvailable();
    STDMETHODIMP_(BOOL) CanShareNow();
    STDMETHODIMP_(BOOL) IsInShare();
    STDMETHODIMP_(BOOL) IsSharing();
    STDMETHODIMP_(BOOL) CanAllowControl();
    STDMETHODIMP_(BOOL) IsControllable();
    STDMETHODIMP GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus);

    // Share/Unshare this window
	STDMETHODIMP ShareDesktop(void);
	STDMETHODIMP UnshareDesktop(void);

    //
    // Control
    //

    // Viewer side
    STDMETHODIMP TakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP CancelTakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP ReleaseControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo);

    // Host side
    STDMETHODIMP AllowControl(BOOL fAllowed);
    STDMETHODIMP GiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP CancelGiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP RevokeControl(IAS_GCC_ID PersonTo);

    //
    // Event notifications
    //
    BOOL        OnEvent(UINT event, UINT_PTR param1, UINT_PTR param2);

public:
    IAppSharingNotify * m_pNotify;

protected:
    LONG                m_cRefs;
};


// callbacks

BOOL CALLBACK eventProc(LPVOID, UINT, UINT, UINT);

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait);
HWND         IsForDialog(HWND hwnd);


#endif // ! _ASMASTER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ch.h ===
//
// CH.H
// Cache Handler
// 
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CH
#define _H_CH


//
//
// DEFINES
//
//
#define CH_NUM_EVICTION_CATEGORIES  3

// 
// NOTES:
// 64K limit on cache
// CHCACHE includes one entry, so only subtract out header part
//
#define CH_MAX_CACHE_ENTRIES \
    ( (65535 - (sizeof(CHCACHE) - sizeof(CHENTRY))) / sizeof(CHENTRY) )


//
//
// TYPEDEFS
//
//


typedef struct tagCHCHAIN
{
    WORD    next;
    WORD    prev;
} CHCHAIN;
typedef CHCHAIN * PCHCHAIN;



//
// There are going to be thousands of cache entries so we need to keep
// the header as compact as possible.  We could drop the eviction
// category, but it is useful info and does round the entry to 16 bytes
// which makes indexing efficient.
//
// Note that the 16 bit code is restricted to 4096 entries unless we take
// steps to allow huge addressing of the entry array.
//


//
// CHENTRY
// Cache entry in a Cache tree
//
typedef struct tagCHENTRY
{
    struct tagCHENTRY * pParent;
    struct tagCHENTRY * pLeft;
    struct tagCHENTRY * pRight;
    WORD                lHeight;
    WORD                rHeight;
    UINT                cbData;
    LPBYTE              pData;
    UINT                checkSum;
    CHCHAIN             chain;
    WORD                evictionCategory;
    WORD                free;
} CHENTRY;
typedef CHENTRY * PCHENTRY;



//
// A CACHE
//

// FORWARD DECLARATION
typedef struct tagCHCACHE * PCHCACHE;

#ifdef __cplusplus

typedef void (* PFNCACHEDEL)(class ASHost * pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);

//
// Each cache may have several eviction categories.  These allow the caller
// to define classes of data so that it can control what is evicted from
// the cache.  To be a candidate for eviction the eviction class of a LRU
// entry must match, unless the number of entries in that category is
// less than the eviction threshold, in which case any cache entry is
// up for grabs.
//
// The EvictionThreshold() function can be used to tune eviction thresholds
// which default to cEntries/cNumEvictionCategories
//

typedef struct tagCHCACHE
{
    STRUCTURE_STAMP

    PFNCACHEDEL     pfnCacheDel;
    UINT            cEntries;
    UINT            cNumEvictionCategories;
    UINT            cbNotHashed;

    //
    // NOTE:  CH_NUM_EVICTION_CATEGORIES is 3, so 3 words + 3 words +
    // 3 words == 9 words, not DWORD aligned.  Hence we stick the WORD
    // field free after iMRUTail.  If CH_NUM_EVICTION_CATEGORIES ever
    // changes to an even value, reshuffle this structure.
    // 
    WORD            cEvictThreshold[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUHead[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUTail[CH_NUM_EVICTION_CATEGORIES];
    WORD            free;

    PCHENTRY        pRoot;
    PCHENTRY        pFirst;
    PCHENTRY        pLast;

    CHENTRY         Entry[1];
}
CHCACHE;
typedef CHCACHE * PCHCACHE;

#endif // __cplusplus


//
//
// MACROS
//
//

//
// BOGUS LAURABU
// In future, have debug signatures at front of objects to catch heap corruption
//

#define IsValidCache(pCache) \
    (!IsBadWritePtr((pCache), sizeof(CHCACHE)))

#define IsValidCacheEntry(pEntry) \
    (!IsBadWritePtr((pEntry), sizeof(CHENTRY)))

#define IsValidCacheIndex(pCache, iEntry) \
    ((iEntry >= 0) && (iEntry < (pCache)->cEntries))

#define IsCacheEntryInTree(pEntry) \
    (((pEntry)->lHeight != 0xFFFF) && ((pEntry)->rHeight != 0xFFFF))




#endif // _H_CH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\as.h ===
//
// App Sharing Header
//
// <DCS.H> is included BEFORE the other component headers, it has common
//      constants and typedefs.
// <AS.H> is included AFTER the other component headers, it has structure
//      definitions that depend on the structures in the component headers.
//

#ifndef _H_AS
#define _H_AS

class ASHost;
class ASPerson;
class ASView;
class ASShare;



//
// This is the data we keep for when we HOST application.  When not
// hosting, we don't have this data at all.  It's a fair amount of variables,
// hence it's worth allocating/freeing.  And when we support multiple
// simultaneous conferences, won't we be glad we don't have globals to
// remove?
//

class ASHost
{
public:
    STRUCTURE_STAMP

    //
    // Pointer back to share
    //
    ASShare *               m_pShare;

    //
    // Bounds rects
    //
    UINT                    m_baNumRects;
    RECT                    m_abaRects[BA_NUM_RECTS];

    //
    // Active Window Coordinator
    //
    HWND                    m_awcLastActiveWindow;
    UINT                    m_awcLastActiveMsg;

    //
    // Control
    //
    BOOL                    m_caRetrySendState;
    BOOL                    m_caAutoAcceptRequests:1;
    BOOL                    m_caTempRejectRequests:1;

    //
    // Cursor Manager
    //
    BOOL                    m_cmfUseColorCursorProtocol:1;
    BOOL                    m_cmfCursorHidden:1;
    BOOL                    m_cmfSyncPos:1;
    BOOL                    m_cmfCursorTransformApplied:1;
    POINT                   m_cmLastCursorPos;
    CURSORDESCRIPTION       m_cmLastCursorShape;
    UINT                    m_cmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_cmTxCacheHandle;

    //
    // Host Tracker
    //
    GUIEFFECTS              m_hetEffects;

    //
    // Order Accumulator
    //
    UINT                    m_oaFlow;

    //
    // OE2 OUTGOING encoding
    //
    PARTYORDERDATA          m_oe2Tx;

    //
    // PM OUTGOING cache, current colors
    //
    BOOL                    m_pmMustSendPalette:1;
    BOOL                    m_pmBuggedDriver:1;
    PALETTEENTRY            m_apmCurrentSystemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    TSHR_RGBQUAD            m_apmTxPaletteColors[PM_NUM_8BPP_PAL_ENTRIES];
    HPALETTE                m_pmTxPalette;
    UINT                    m_pmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_pmTxCacheHandle;
    PCOLORTABLECACHE        m_pmNextTxCacheEntry;
    COLORTABLECACHE         m_apmTxCache[TSHR_PM_CACHE_ENTRIES];
    TSHR_RGBQUAD            m_apmDDGreyRGB[PM_GREY_COUNT];

    //
    // Send bitmap cache
    //
    SBC_ORDER_INFO          m_sbcOrderInfo;
    SBC_TILE_WORK_INFO      m_asbcWorkInfo[SBC_NUM_TILE_SIZES];
    BMC_DIB_CACHE           m_asbcBmpCaches[NUM_BMP_CACHES];
    SBC_SHM_CACHE_INFO      m_asbcCacheInfo[NUM_BMP_CACHES];
    LPSBC_FASTPATH          m_sbcFastPath;


    //
    // Screen data
    //
    RECT                    m_sdgPendingRect;
    BOOL                    m_sdgRectIsPending:1;
    UINT                    m_sdgcLossy;
    RECT                    m_asdgLossyRect[BA_NUM_RECTS];

    //
    // Save bits
    //
    DWORD                   m_ssiSaveBitmapSize;  // Can go away in 4.0

    //
    // Shared window list
    //
    UINT                    m_swlCurrentDesktop;
    char                    m_aswlOurDesktopName[SWL_DESKTOPNAME_MAX];

    //
    // Updates
    //
    BOOL                    m_upBackPressure;
    BOOL                    m_upfUseSmallPackets:1;
    BOOL                    m_upfSyncTokenRequired:1;
    DWORD                   m_upLastSDTime;
    DWORD                   m_upLastOrdersTime;
    DWORD                   m_upLastTrialTime;
    DWORD                   m_upDeltaSD;
    DWORD                   m_upSDAccum;
    DWORD                   m_upDeltaOrders;
    DWORD                   m_upOrdersAccum;

    UINT                    m_usrSendingBPP;
    HDC                     m_usrWorkDC;

public:

    //
    // Local host starting
    //
    BOOL                    HET_HostStarting(ASShare *);

    BOOL                    CM_HostStarting(void);
    BOOL                    OE2_HostStarting(void);
    BOOL                    PM_HostStarting(void);
    BOOL                    SBC_HostStarting(void);
    BOOL                    SSI_HostStarting(void);
    BOOL                    SWL_HostStarting(void);
    BOOL                    VIEW_HostStarting(void);
    BOOL                    USR_HostStarting(void);

    //
    // Local host ended
    //
    void                    HET_HostEnded(void);

    void                    CA_HostEnded(void);
    void                    CM_HostEnded(void);
    void                    OE2_HostEnded(void);
    void                    PM_HostEnded(void);
    void                    SBC_HostEnded(void);
    void                    USR_HostEnded(void);

    //
    // Syncing, when already hosting and somebody else joins
    //
    void                    HET_SyncCommon(void);

    void                    HET_SyncAlreadyHosting(void);
    void                    CA_SyncAlreadyHosting(void);

    void                    AWC_SyncOutgoing(void);
    void                    BA_SyncOutgoing(void);
    void                    CM_SyncOutgoing(void);
    void                    OA_SyncOutgoing(void);
    void                    OE2_SyncOutgoing(void);
    void                    PM_SyncOutgoing(void);
    void                    SBC_SyncOutgoing(void);
    void                    SSI_SyncOutgoing(void);

    //
    // Periodic
    //
    void                    AWC_Periodic(void);
    void                    CA_Periodic(void);
    void                    CM_Periodic(void);
    void                    SWL_Periodic(void);
    void                    UP_Periodic(UINT currentTime);


    //
    // Component routines - public
    //

    void                    AWC_ActivateWindow(HWND hwnd);

    void                    BA_AddRect(LPRECT pRect);
    void                    BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);
    void                    BA_FetchBounds(void);
    UINT                    BA_QueryAccumulation(void);
    void                    BA_ReturnBounds(void);

    UINT                    CH_CacheData(PCHCACHE  pCache, LPBYTE pData,
                                UINT cbSize, UINT evictionCategory);
    void                    CH_ClearCache(PCHCACHE pCache );
    BOOL                    CH_CreateCache(PCHCACHE * ppCache, UINT cEntries,
                                UINT cEvictionCategories, UINT cbNotHashed,
                                PFNCACHEDEL pfnCacheDel);
    void                    CH_DestroyCache(PCHCACHE hCache);
    void                    CH_RemoveCacheEntry(PCHCACHE pCache, UINT iCacheEntry);
    BOOL                    CH_SearchAndCacheData(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    BOOL                    CH_SearchCache(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    void                    CH_TouchCacheEntry(PCHCACHE pCache, UINT iCacheEntry);

    void                    CM_ApplicationMovedCursor(void);
    void                    CM_Controlled(ASPerson * pasControlledBy);
    void                    CM_MaybeSendCursorMovedPacket(void);

    void                    HET_RepaintAll(void);

    void                    OA_FlowControl(UINT newBufferSize);
    LPINT_ORDER             OA_GetFirstListOrder(void);
    UINT                    OA_GetTotalOrderListBytes(void);
    void                    OA_LocalHostReset(void);
    UINT                    OA_QueryOrderAccum(void);
    LPINT_ORDER             OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder);
    void                    OA_ResetOrderList(void);

    BOOL                    OE_RectIntersectsSDA(LPRECT lpRect);

    TSHR_UINT16             OE2_EncodeOrder(LPINT_ORDER pIntOrder,
                                LPVOID pBuffer, TSHR_UINT16 cbBufferSize);
    BOOL                    OE2_UseFont(LPSTR pName, TSHR_UINT16 facelength,
                                TSHR_UINT16 CodePage, TSHR_UINT16 MaxHeight,
                                TSHR_UINT16 Height, TSHR_UINT16 Width,
                                TSHR_UINT16 Weight, TSHR_UINT16 flags);

    void                    PM_AdjustColorsForBuggedDisplayDrivers(LPTSHR_RGBQUAD pColors,
                                UINT cColors);
    BOOL                    PM_CacheTxColorTable(LPUINT pIndex, LPBOOL pNewEntry,
                                UINT cColors, LPTSHR_RGBQUAD pColors);
    HPALETTE                PM_GetLocalPalette(void);
    void                    PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors);
    BOOL                    PM_MaybeSendPalettePacket(void);

    void                    SBC_CacheCleared(void);
    void                    SBC_CacheEntryRemoved(UINT cache, UINT cacheIndex);
    UINT                    SBC_CopyPrivateOrderData(LPBYTE pDst,
                                LPCOM_ORDER pOrder, UINT cbFree);
    void                    SBC_OrderSentNotification(LPINT_ORDER pOrder);
    void                    SBC_PMCacheEntryRemoved(UINT cacheIndex);
    void                    SBC_ProcessInternalOrder(LPINT_ORDER pOrder);
    BOOL                    SBC_ProcessMemBltOrder(LPINT_ORDER pOrder,
                                LPINT_ORDER * ppNextOrder);
    void                    SBC_RecreateSendCache(UINT cache, UINT newEntries,
                                UINT newCellSize);

    void                    SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets);

    BOOL                    SWL_IsOurDesktopActive(void);
    void                    SWL_UpdateCurrentDesktop(void);

    void                    UP_FlowControl(UINT newSize);
    BOOL                    UP_MaybeSendSyncToken(void);

protected:
    void                    CHAvlBalanceTree(PCHCACHE, PCHENTRY);
    void                    CHAvlDelete(PCHCACHE, PCHENTRY, UINT);
    PCHENTRY                CHAvlFind(PCHCACHE, UINT, UINT);
    PCHENTRY                CHAvlFindEqual(PCHCACHE, PCHENTRY);
    void                    CHAvlInsert(PCHCACHE, PCHENTRY);
    LPBYTE                  CHAvlNext(PCHENTRY);
    LPBYTE                  CHAvlPrev(PCHENTRY);
    void                    CHAvlRebalance(PCHENTRY *);
    void                    CHAvlRotateLeft(PCHENTRY *);
    void                    CHAvlRotateRight(PCHENTRY *);
    void                    CHAvlSwapLeftmost(PCHCACHE, PCHENTRY, PCHENTRY);
    void                    CHAvlSwapRightmost(PCHCACHE, PCHENTRY, PCHENTRY);
    UINT                    CHCheckSum(LPBYTE pData, UINT cbDataSize);
    int                     CHCompare(UINT key, UINT cbSize, PCHENTRY pEntry);
    UINT                    CHEvictCacheEntry(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);
    UINT                    CHEvictLRUCacheEntry(PCHCACHE pCache, UINT evictionCategory, UINT evictionCount);
    BOOL                    CHFindFreeCacheEntry(PCHCACHE pCache, UINT* piEntry, UINT* pEvictionCount);
    void                    CHInitEntry(PCHENTRY);
    void                    CHRemoveEntry(PCHCACHE pCache, UINT iCacheEntry);
    UINT                    CHTreeSearch(PCHCACHE pCache, UINT checksum, UINT cbDataSize, LPBYTE pData);
    void                    CHUpdateMRUList(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);

    BOOL                    CMGetColorCursorDetails( LPCM_SHAPE pCursor,
                                LPTSHR_UINT16 pcxWidth, LPTSHR_UINT16 pcyHeight,
                                LPTSHR_UINT16 pxHotSpot, LPTSHR_UINT16 pyHotSpot,
                                LPBYTE pANDMask, LPTSHR_UINT16 pcbANDMask,
                                LPBYTE pXORBitmap, LPTSHR_UINT16 pcbXORBitmap );
    BOOL                    CMGetCursorTagInfo(LPCSTR szTagName);
    void                    CMRemoveCursorTransform(void);
    BOOL                    CMSetCursorTransform(LPBYTE pANDMask, LPBITMAPINFO pXORDIB);
    BOOL                    CMSendBitmapCursor(void);
    BOOL                    CMSendCachedCursor(UINT iCacheEntry);
    BOOL                    CMSendColorBitmapCursor(LPCM_SHAPE pCursor,
                                UINT iCacheEntry);
    BOOL                    CMSendCursorShape(LPCM_SHAPE lpCursorShape,
                                UINT cbCursorDataSize);
    BOOL                    CMSendMonoBitmapCursor(LPCM_SHAPE pCursor);
    BOOL                    CMSendSystemCursor(UINT cursorIDC);

    void                    OAFreeAllOrders(LPOA_SHARED_DATA);

    void                    OE2EncodeBounds(LPBYTE * ppNextFreeSpace,
                                LPTSHR_RECT16 pRect);

    void                    PMGetGrays(void);
    BOOL                    PMSendPalettePacket(LPTSHR_RGBQUAD  pColorTable,
                                UINT numColors);
    BOOL                    PMUpdateSystemPaletteColors(void);
    BOOL                    PMUpdateTxPaletteColors(void);

    void                    SBCAddToFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT cache,
                                UINT cacheIndex, UINT colorCacheIndex);
    BOOL                    SBCCacheBits(LPINT_ORDER pOrder, UINT cbDst,
                                LPBYTE pDIBits, UINT bitmapWidth,
                                UINT fixedBitmapWidth, UINT bitmapHeight,
                                UINT numBytes, UINT * pCache, UINT * pCacheIndex,
                                LPBOOL pIsNewEntry);
    BOOL                    SBCCacheColorTable(LPINT_ORDER pColorTableOrder,
                                LPTSHR_RGBQUAD pColorTable, UINT numColors,
                                UINT * pCacheIndex, LPBOOL pIsNewEntry);
    BOOL                    SBCFindInFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT * pCache,
                                UINT * pCacheIndex, UINT * pColorCacheIndex);
    void                    SBCFreeInternalOrders(void);
    BOOL                    SBCGetTileData(UINT tileId, LPSBC_TILE_DATA * ppTileData,
                                UINT * pTileType);
    void                    SBCInitCacheStructures(void);
    BOOL                    SBCInitFastPath(void);
    BOOL                    SBCInitInternalOrders(void);
    BOOL                    SBCSelectCache(UINT bitsSize, UINT * pCacheIndex);

    BOOL                    SDGSmallBltToNetwork(LPRECT pRect);
    BOOL                    SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPacket);

    UINT                    UPFetchOrdersIntoBuffer(LPBYTE pBuffer,
                                LPTSHR_UINT16 pcOrders, LPUINT pcbBufferSize);
    BOOL                    UPSendOrders(UINT *);
    UINT                    UPSendUpdates(void);

};


void PMCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);
void SBCCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);




//
// This is the per-person data we keep to VIEW a host.  When this person
// starts to host, we allocate this structure, and then subblocks as
// necessary like caches.  When this person stops hosting, we free it
// after freeing the objects contained within.
//
// NOTE that for some whacky 2.x compatibility, some things that should
// be in the ASView structure are actually kept in ASPerson because
// the information contained within has to stay around when that person
// isn't hosting.  With 3.0 hosts that's not the case.  So when 2.x
// compatibility goes away, move OD2 PM RBC fields here also.
//

class ASView
{
public:
    STRUCTURE_STAMP

    // DS vars
    // For NM 2.x machines only, the offset if their desktop is scrolled over
    POINT                   m_dsScreenOrigin;

    // OD vars, for playback of orders from this remote host
    HRGN                    m_odInvalRgnOrder;
    HRGN                    m_odInvalRgnTotal;
    UINT                    m_odInvalTotal;

    COLORREF                m_odLastBkColor;
    COLORREF                m_odLastTextColor;
    int                     m_odLastBkMode;
    int                     m_odLastROP2;
    UINT                    m_odLastFillMode;
    UINT                    m_odLastArcDirection;
    UINT                    m_odLastPenStyle;
    UINT                    m_odLastPenWidth;
    COLORREF                m_odLastPenColor;
    COLORREF                m_odLastForeColor;
    int                     m_odLastBrushOrgX;
    int                     m_odLastBrushOrgY;
    COLORREF                m_odLastBrushBkColor;
    COLORREF                m_odLastBrushTextColor;
    HBITMAP                 m_odLastBrushPattern;
    UINT                    m_odLastLogBrushStyle;
    UINT                    m_odLastLogBrushHatch;
    TSHR_COLOR              m_odLastLogBrushColor;
    BYTE                    m_odLastLogBrushExtra[7];
    int                     m_odLastCharExtra;
    int                     m_odLastJustExtra;
    int                     m_odLastJustCount;
    HFONT                   m_odLastFontID;
    UINT                    m_odLastFontCodePage;
    UINT                    m_odLastFontWidth;
    UINT                    m_odLastFontHeight;
    UINT                    m_odLastFontWeight;
    UINT                    m_odLastFontFlags;
    UINT                    m_odLastFontFaceLen;
    BYTE                    m_odLastFaceName[FH_FACESIZE];
    UINT                    m_odLastBaselineOffset;
    COLORREF                m_odLastVGAColor[OD_NUM_COLORS];
    TSHR_COLOR              m_odLastVGAResult[OD_NUM_COLORS];
    BOOL                    m_odRectReset;
    int                     m_odLastLeft;
    int                     m_odLastTop;
    int                     m_odLastRight;
    int                     m_odLastBottom;

    // SSI vars
    HDC                     m_ssiDC;
    HBITMAP                 m_ssiBitmap;              // Bitmap handle
    HBITMAP                 m_ssiOldBitmap;
    int                     m_ssiBitmapHeight;

    // USR vars
    HDC                     m_usrDC;
    HDC                     m_usrWorkDC;
    HBITMAP                 m_usrBitmap;
    HBITMAP                 m_usrOldBitmap;

    // VIEW vars
    HWND                    m_viewFrame;                // Frame
    HWND                    m_viewClient;               // Host view
    HWND                    m_viewStatusBar;            // Status bar
    UINT                    m_viewStatus;               // Current status
    HMENU                   m_viewMenuBar;              // Menu bar
    RECT                    m_viewSavedWindowRect;      // When full screen, old pos
    HWND                    m_viewInformDlg;            // Notification message up
    UINT                    m_viewInformMsg;            // Informational message

    BOOL                    m_viewFocus:1;              // Key strokes are going to this
    BOOL                    m_viewInMenuMode:1;         // In menu mode
    BOOL                    m_viewFullScreen:1;         // Full screen UI
    BOOL                    m_viewStatusBarOn:1;
    BOOL                    m_viewSavedStatusBarOn:1;
    BOOL                    m_viewFullScreenExitTrack:1;
    BOOL                    m_viewFullScreenExitMove:1;

    POINT                   m_viewSavedPos;
    POINT                   m_viewFullScreenExitStart;

    UINT                    m_viewMouseFlags;           // For capture
    POINT                   m_viewMouse;                // Mouse pos
    BOOL                    m_viewMouseOutside;         // Mouse is down, outside client
    int                     m_viewMouseWheelDelta;      // Intellimouse wheel insanity

    //
    // These are kept always in the view's client coords.  When the view
    // scrolls over, the shared and obscured regions are adjusted too.
    // When a new SWL packet for the host comes in, these regions are
    // saved accounting for scrolling too.
    //
    HRGN                    m_viewSharedRgn;           // Shared area, not obscured
    HRGN                    m_viewObscuredRgn;         // Shared area, obscured
    HRGN                    m_viewExtentRgn;
    HRGN                    m_viewScreenRgn;
    HRGN                    m_viewPaintRgn;
    HRGN                    m_viewScratchRgn;

    POINT                   m_viewPos;                 // View scroll pos
    POINT                   m_viewPage;                // View page size
    POINT                   m_viewPgSize;              // Page scroll inc
    POINT                   m_viewLnSize;              // Line scroll inc
};




//
// This is the per-person data we keep for each person in a conference.
// We dynamically allocate everybody but ourself (the local dude).
//


class ASPerson
{
public:
    STRUCTURE_STAMP

    ASPerson *              pasNext;

    // VIEW vars (allocated when this person is hosting that we use to VIEW them)
    ASView *                m_pView;

    // SC vars
    UINT                    mcsID;                      // MCS user_id
    char                    scName[TSHR_MAX_PERSON_NAME_LEN];  // Name
    BYTE                    scSyncSendStatus[SC_STREAM_COUNT];
    BYTE                    scSyncRecStatus[SC_STREAM_COUNT];

    //
    // AWC vars
    // When 2.x compat goes away, move these to AS_VIEW
    //
    TSHR_UINT32             awcActiveWinID;

    // CA vars
    BOOL                    m_caAllowControl;
    UINT                    m_caControlID;          // ONLY NODE WE ARE CONTROLLING/CONTROLLED BY
    ASPerson *              m_caControlledBy;
    ASPerson *              m_caInControlOf;

    //
    // CM vars
    // When 2.x compat goes away, move most of these to AS_VIEW
    //
    POINT                   cmPos;              // Position of the remote cursor, in his screen coords
    POINT                   cmHotSpot;          // The remote cursor hotspot
    BOOL                    cmShadowOff;
    HCURSOR                 cmhRemoteCursor;
    UINT                    ccmRxCache;         // # of entries in cache
    PCACHEDCURSOR           acmRxCache;         // Cached cursor array

    // CPC vars
    CPCALLCAPS              cpcCaps;

    // DCS vars
    PGDC_DICTIONARY         adcsDict;                   // POINTER

    // HET vars
    int                     hetCount;

    // OE vars
    UINT                    oecFonts;
    POEREMOTEFONT           poeFontInfo;

    //
    // NOTE:
    // These are here and not in the HOST data for 2.x compat.  2.x systems
    // don't reset outgoing info if they stay in a share while stopping/
    // restarting hosting.  3.0 systems do (look in HET_HostStarting()).
    // So we must keep the old gunky cache/decode data around for backlevel
    // systems.  Therefore we allocate it dynamically still.
    //

    // OD2 vars
    PPARTYORDERDATA         od2Party;

    // PM vars
    HPALETTE                pmPalette;
    UINT                    pmcColorTable;
    PCOLORTABLECACHE        apmColorTable;

    // RBC vars
    PRBC_HOST_INFO          prbcHost;

    // VIEW vars
    // NOTE: because of bugs in 2.x VD calcs, this is kept around while
    // the person is in the share, whether they are hosting or not.
    POINT                   viewExtent;              // View extent (may be > usrScreenSize for 2.x dudes)
};



//
// Allocated when in a share
//

class ASShare
{
public:
    STRUCTURE_STAMP

    ASHost *                m_pHost;
    ASPerson *              m_pasLocal;    // People list, starting with local person

    //
    // Bitmap Compressor/Decompressor
    //
    MATCH *                 m_amatch;
    LPBYTE                  m_abNormal;
    LPBYTE                  m_abXor;

    //
    // Control Arbitrator
    //
    char                    m_caToggle;
    char                    m_caPad1;
    short                   m_caPad2;
    BASEDLIST               m_caQueuedMsgs;
    ASPerson *              m_caWaitingForReplyFrom;
    UINT                    m_caWaitingForReplyMsg;

    HWND                    m_caQueryDlg;
    CA30PENDING             m_caQuery;

    //
    // Cursor
    //
    UINT                    m_cmCursorWidth;
    UINT                    m_cmCursorHeight;
    HCURSOR                 m_cmArrowCursor;
    POINT                   m_cmArrowCursorHotSpot;
    HBRUSH                  m_cmHatchBrush;
    HFONT                   m_cmCursorTagFont;

    DWORD                   m_dcsLastScheduleTime;
    DWORD                   m_dcsLastFastMiscTime;
    DWORD                   m_dcsLastIMTime;
    BOOL                    m_dcsLargePacketCompressionOnly;

    //
    // PKZIP
    //
    BYTE                    m_agdcWorkBuf[GDC_WORKBUF_SIZE];

    //
    // Fonts
    //
    BOOL                    m_fhLocalInfoSent;

    //
    // Hosting
    //
    UINT                    m_hetHostCount;
    BOOL                    m_hetRetrySendState;
    BOOL                    m_hetViewers;

    //
    // Input Manager
    //

    // GLOBAL (or costly to calc/load and undo repeatedly)
    WORD                    m_imScanVKLShift;
    WORD                    m_imScanVKRShift;
    HINSTANCE               m_imImmLib;
    IMMGVK                  m_imImmGVK;

    // IN CONTROL
    BOOL                    m_imfInControlEventIsPending:1;
    BOOL                    m_imfInControlCtrlDown:1;
    BOOL                    m_imfInControlShiftDown:1;
    BOOL                    m_imfInControlMenuDown:1;
    BOOL                    m_imfInControlCapsLock:1;
    BOOL                    m_imfInControlNumLock:1;
    BOOL                    m_imfInControlScrollLock:1;
    BOOL                    m_imfInControlConsumeMenuUp:1;
    BOOL                    m_imfInControlConsumeEscapeUp:1;
    BOOL                    m_imfInControlNewEvent:1;

    IMEVENT                 m_imInControlPendingEvent;
    IMEVENTQ                m_imInControlEventQ;
    BYTE                    m_aimInControlKeyStates[256];
    int                     m_imInControlMouseDownCount;
    DWORD                   m_imInControlMouseDownTime;
    UINT                    m_imInControlMouseWithhold;
    DWORD                   m_imInControlMouseSpoilRate;
    UINT                    m_imInControlNumEventsPending;
    UINT                    m_imInControlNumEventsReturned;
    UINT                    m_aimInControlEventsToReturn[15];
    UINT                    m_imInControlNextHotKeyEntry;
    BYTE                    m_aimInControlHotKeyArray[4];
    UINT                    m_imInControlNumDeadKeysDown;
    UINT                    m_imInControlNumDeadKeys;
    BYTE                    m_aimInControlDeadKeys[IM_MAX_DEAD_KEYS];

    // CONTROLLED (only when hosting!)
    BOOL                    m_imfControlledMouseButtonsReversed:1;
    BOOL                    m_imfControlledMouseClipped:1;
    BOOL                    m_imfControlledPaceInjection:1;
    BOOL                    m_imfControlledNewEvent:1;
    UINT                    m_imControlledNumEventsPending;
    UINT                    m_imControlledNumEventsReturned;
    UINT                    m_aimControlledEventsToReturn[15];
    UINT                    m_imControlledVKToReplay;
    IMEVENTQ                m_imControlledEventQ;
    IMOSQ                   m_imControlledOSQ;
    BYTE                    m_aimControlledControllerKeyStates[256];
    BYTE                    m_aimControlledKeyStates[256];
    BYTE                    m_aimControlledSavedKeyStates[256];
    DWORD                   m_imControlledLastLowLevelMouseEventTime;
    DWORD                   m_imControlledLastMouseRemoteTime;
    DWORD                   m_imControlledLastMouseLocalTime;
    DWORD                   m_imControlledLastIncompleteConversion;
    DWORD                   m_imControlledMouseBacklog;
    POINT                   m_imControlledLastMousePos;

    //
    // Order Encoder
    //
    BOOL                    m_oefSendOrders:1;
    BOOL                    m_oefTextEnabled:1;
    BOOL                    m_oefOE2EncodingOn:1;
    BOOL                    m_oefOE2Negotiable:1;
    BOOL                    m_oefBaseOE:1;
    BOOL                    m_oefAlignedOE:1;
    BYTE                    m_aoeOrderSupported[ORD_NUM_INTERNAL_ORDERS];
    PROTCAPS_ORDERS         m_oeCombinedOrderCaps;
    UINT                    m_oeOE2Flag;

    //
    // Share Controller
    //
    BOOL                    m_scfViewSelf:1;
#ifdef _DEBUG
    BOOL                    m_scfInSync:1;
#endif // _DEBUG
    UINT                    m_scShareVersion;
    int                     m_ascSynced[SC_STREAM_COUNT];
    LPBYTE                  m_ascTmpBuffer;

    POINT                   m_viewVDSize;
    int                     m_viewEdgeCX;
    int                     m_viewEdgeCY;
    HBRUSH                  m_viewObscuredBrush;
    HICON                   m_viewFullScreenExitIcon;
    int                     m_viewFullScreenCX;
    int                     m_viewFullScreenCY;
    int                     m_viewItemCX;
    int                     m_viewItemCY;
    int                     m_viewItemScrollCX;
    int                     m_viewItemScrollCY;
    int                     m_viewStatusBarCY;
    HCURSOR                 m_viewNotInControl;
    UINT                    m_viewMouseWheelScrollLines;

    HBITMAP                 m_usrBmp16;
    HBITMAP                 m_usrBmp32;
    HBITMAP                 m_usrBmp48;
    HBITMAP                 m_usrBmp64;
    HBITMAP                 m_usrBmp80;
    HBITMAP                 m_usrBmp96;
    HBITMAP                 m_usrBmp112;
    HBITMAP                 m_usrBmp128;
    HBITMAP                 m_usrBmp256;
    HBITMAP                 m_usrBmp1024;
    LPBYTE                  m_usrPBitmapBuffer;
    BOOL                    m_usrHatchBitmaps;
    BOOL                    m_usrHatchScreenData;
    int                     m_usrHatchColor;

public:
#ifdef _DEBUG
    void                ValidatePerson(ASPerson * pasPerson);
    void                ValidateView(ASPerson * pasPerson);
#else
    __inline void       ValidatePerson(ASPerson * pasPerson) {}
    __inline void       ValidateView(ASPerson * pasPerson) {}
#endif // _DEBUG


    //
    // Share init
    //
    BOOL                SC_ShareStarting(void);

    BOOL                BCD_ShareStarting(void);
    BOOL                CM_ShareStarting(void);
    BOOL                IM_ShareStarting(void);
    BOOL                VIEW_ShareStarting(void);
    BOOL                USR_ShareStarting(void);

    //
    // Share term
    //
    void                SC_ShareEnded(void);

    void                BCD_ShareEnded(void);
    void                CM_ShareEnded(void);
    void                IM_ShareEnded(void);
    void                VIEW_ShareEnded(void);
    void                USR_ShareEnded(void);

    //
    // Member joining share
    //
    BOOL                SC_PartyAdded(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    ASPerson *          SC_PartyJoiningShare(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    BOOL                CM_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                CPC_PartyJoiningShare(ASPerson * pasPerson, UINT cbCaps, void* pCapsData);
    BOOL                DCS_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                HET_PartyJoiningShare(ASPerson * pasPerson);

    //
    // Member leaving share
    //
    void                SC_PartyDeleted(UINT mcsID);
    void                SC_PartyLeftShare(UINT mcsID);
    void                CA_PartyLeftShare(ASPerson * pasPerson);
    void                CM_PartyLeftShare(ASPerson * pasPerson);
    void                DCS_PartyLeftShare(ASPerson * pasPerson);
    void                HET_PartyLeftShare(ASPerson * pasPerson);
    void                OD2_PartyLeftShare(ASPerson * pasPerson);
    void                OE_PartyLeftShare(ASPerson * pasPerson);
    void                PM_PartyLeftShare(ASPerson * pasPerson);
    void                RBC_PartyLeftShare(ASPerson * pasPerson);
    void                VIEW_PartyLeftShare(ASPerson * pasPerson);


    //
    // Recalc caps after somebody joined or left
    //
    void                SC_RecalcCaps(BOOL fJoiner);

    void                CM_RecalcCaps(BOOL fJoiner);
    void                DCS_RecalcCaps(BOOL fJoiner);
    void                OE_RecalcCaps(BOOL fJoiner);
    void                PM_RecalcCaps(BOOL fJoiner);
    void                SBC_RecalcCaps(BOOL fJoiner);
    void                SSI_RecalcCaps(BOOL fJoiner);
    void                USR_RecalcCaps(BOOL fJoiner);


    //
    // Syncing due to new member joined or reset
    //
    void                DCS_SyncOutgoing(void);
    void                IM_SyncOutgoing(void);
    void                OD2_SyncIncoming(ASPerson * pasPerson);
    void                OE_SyncOutgoing(void);


    //
    // Starting host view
    //
    BOOL                HET_ViewStarting(ASPerson * pasPerson);

    BOOL                CA_ViewStarting(ASPerson * pasPerson);
    BOOL                CM_ViewStarting(ASPerson * pasPerson);
    BOOL                OD_ViewStarting(ASPerson * pasPerson);
    BOOL                OD2_ViewStarting(ASPerson * pasPerson);
    BOOL                PM_ViewStarting(ASPerson * pasPErson);
    BOOL                RBC_ViewStarting(ASPerson * pasPerson);
    BOOL                SSI_ViewStarting(ASPerson * pasPerson);
    BOOL                VIEW_ViewStarting(ASPerson * pasPerson);
    BOOL                USR_ViewStarting(ASPerson * pasPerson);


    //
    // Stopped host view
    //
    void                HET_ViewEnded(ASPerson * pasPerson);

    void                CA_ViewEnded(ASPerson * pasPerson);
    void                CM_ViewEnded(ASPerson * pasPerson);
    void                OD_ViewEnded(ASPerson * pasPerson);
    void                OD2_ViewEnded(ASPerson * pasPerson);
    void                PM_ViewEnded(ASPerson * pasPerson);
    void                RBC_ViewEnded(ASPerson * pasPerson);
    void                SSI_ViewEnded(ASPerson * pasPerson);
    void                VIEW_ViewEnded(ASPerson * pasPerson);
    void                USR_ViewEnded(ASPerson * pasPerson);

    //
    // Periodic processing when in share, mostly for when hosting
    //
    void                SC_Periodic(void);

    void                CA_Periodic(void);
    void                HET_Periodic(void);
    void                IM_Periodic(void);
    void                OE_Periodic(void);

    //
    // Incoming packet handling
    //
    void                SC_ReceivedPacket(PS20DATAPACKET pPacket);
    void                AWC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA30_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CPC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                FH_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                HET_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                PM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                OD_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                SDP_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                SWL_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                UP_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);

    //
    // Random component routines
    //
    BOOL                AWC_SendMsg(UINT userTo, UINT msg, UINT data1, UINT data2);

    BOOL                BC_CompressBitmap( LPBYTE  pSrcBitmap,
                                LPBYTE  pDstBuffer,
                                LPUINT   pDstBufferSize,
                                UINT    bitmapWidth,
                                UINT    bitmapHeight,
                                UINT    bitmapBitsPerPel,
                                LPBOOL   pLossy);
    BOOL                BD_DecompressBitmap( LPBYTE  pCompressedData,
                                  LPBYTE  pDstBitmap,
                                  UINT    srcDataSize,
                                  UINT    bitmapWidth,
                                  UINT    bitmapHeight,
                                  UINT    bitmapBitsPerPel );

    void                CA_TakeControl(ASPerson * pasHost);
    void                CA_CancelTakeControl(ASPerson * pasHost, BOOL fPacket);
    void                CA_ReleaseControl(ASPerson * pasFrom, BOOL fPacket);
    void                CA_PassControl(ASPerson * pasHost, ASPerson * pasViewer);

    void                CA_AllowControl(BOOL fAllow);
    void                CA_GiveControl(ASPerson * pasInvite);
    void                CA_CancelGiveControl(ASPerson * pasViewer, BOOL fPacket);
    void                CA_RevokeControl(ASPerson * pasController, BOOL fPacket);

    void                CA_ClearLocalState(UINT clearFlags, ASPerson * pasRemote, BOOL fPacket);
    BOOL                CA_QueryDlgProc(HWND, UINT, WPARAM, LPARAM);

    void                CM_DrawShadowCursor(ASPerson * pasPerson, HDC hdc );
    void                CM_UpdateShadowCursor(ASPerson * pasPerson, BOOL fOff,
                                int xPosNew, int yPosNew, int xHotNew, int yHotNew);

    void                CPC_UpdatedCaps(PPROTCAPS pCaps);

#ifdef _DEBUG
    UINT                DCS_CompressAndSendPacket(UINT streamID, UINT nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#else
    void                DCS_CompressAndSendPacket(UINT streamID, UINT nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#endif // _DEBUG
    void                DCS_FlowControl(UINT newBufferSize);

    void                DCS_TakeControl(UINT gccOf);
    void                DCS_CancelTakeControl(UINT gccOf);
    void                DCS_ReleaseControl(UINT gccOf);
    void                DCS_PassControl(UINT gccOf, UINT gccTo);
    void                DCS_GiveControl(UINT gccTo);
    void                DCS_CancelGiveControl(UINT gccTo);
    void                DCS_RevokeControl(UINT gccTo);

    void                FH_ConvertAnyFontIDToLocal(LPCOM_ORDER pOrder, ASPerson * pasPerson);
    void                FH_DetermineFontSupport(void);
    void                FH_SendLocalFontInfo(void);

    void                HET_CalcViewers(ASPerson * pasLeaving);
    void                HET_HandleNewTopLevel(BOOL fShowing);
    void                HET_HandleRecountTopLevel(UINT newCount);
    void                HET_ShareApp(WPARAM, LPARAM);
    void                HET_ShareDesktop(void);
    void                HET_UnshareAll(void);
    void                HET_UnshareApp(WPARAM, LPARAM);
    BOOL                HET_WindowIsHosted(HWND winid);

    BOOL                IM_Controlled(ASPerson * pasControlledBy);
    void                IM_InControl(ASPerson * pasInControlOf);
    void                IM_OutgoingKeyboardInput(ASPerson * pasHost,
                            UINT vkCode, UINT keyData);
    void                IM_OutgoingMouseInput(ASPerson * pasHost,
                            LPPOINT pMousePos, UINT message, UINT extra);
    void                IM_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                IM_SyncOutgoingKeyboard(void);

    void                OD_ReplayOrder(ASPerson * pasFrom, LPCOM_ORDER pOrder, BOOL fPalRGB);
    void                OD_ResetRectRegion(ASPerson * pasPerson);
    void                OD_UpdateView(ASPerson * pasHost);

    void                OD2_CalculateBounds(LPCOM_ORDER pOrder, LPRECT pRect,
                                BOOL fDecoding, ASPerson * pasPerson);
    void                OD2_CalculateTextOutBounds(LPTEXTOUT_ORDER pTextOut,
                                LPRECT pRect, BOOL fDecoding, ASPerson * pasPerson);
    LPCOM_ORDER         OD2_DecodeOrder(void * pEOrder, LPUINT LengthDecoded,
                            ASPerson * pasPerson);

    void                OE_EnableText(BOOL enable);
    BOOL                OE_SendAsOrder(DWORD order);

    BOOL                PM_CacheRxColorTable(ASPerson *  pasPerson,
                                UINT index, UINT cColors, LPTSHR_RGBQUAD pColors);
    BOOL                PM_CreatePalette(UINT cEntries, LPTSHR_COLOR pNewEntries,
                            HPALETTE* phPal );
    void                PM_DeletePalette(HPALETTE palette);
    void                PM_GetColorTable(ASPerson * pasPerson, UINT index,
                                UINT * pcColors, LPTSHR_RGBQUAD pColors);

    HBITMAP             RBC_MapCacheIDToBitmapHandle(ASPerson * pasPerson,
                                UINT cacheIndex, UINT entry, UINT colorTable);
    void                RBC_ProcessCacheOrder(ASPerson * pasPerson, LPCOM_ORDER_UA pOrder);

    PS20DATAPACKET      SC_AllocPkt(UINT streamID, UINT nodeID, UINT len);
    ASPerson *          SC_PersonAllocate(UINT mcsID, LPSTR szName);
    ASPerson *          SC_PersonFromNetID(MCSID mcsID);
    ASPerson *          SC_PersonFromGccID(UINT gccID);
    void                SC_PersonFree(ASPerson * pasFree);
    BOOL                SC_ValidateNetID(MCSID mcsID, ASPerson** pLocal);

    void                SDP_DrawHatchedRect( HDC surface, int x, int y, int width, int height, UINT color);

    void                SSI_SaveBitmap(ASPerson * pasPerson, LPSAVEBITMAP_ORDER pSaveBitmap);

    BOOL                VIEW_DlgProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FrameWindowProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FullScreenExitProc(HWND, UINT, WPARAM, LPARAM);
    void                VIEW_HostStateChange(ASPerson * pasHost);
    void                VIEW_InControl(ASPerson * pasRemote, BOOL fStart);
    void                VIEW_InvalidateRect(ASPerson * pasHost, LPRECT lprc);
    void                VIEW_InvalidateRgn(ASPerson * pasHost, HRGN rgnUpdated);
    BOOL                VIEW_IsPointShared(ASPerson * pasHost, POINT pt);
    void                VIEW_Message(ASPerson * pasHost, UINT ids);
    void                VIEW_RecalcExtent(ASPerson * pasHost);
    void                VIEW_RecalcVD(void);
    void                VIEW_ScreenChanged(ASPerson * pasPerson);
    void                VIEW_SetHostRegions(ASPerson * pasHost, HRGN rgnShared, HRGN rgnObscured);
    void                VIEW_SyncCursorPos(ASPerson * pasHost, int x, int y);
    void                VIEW_UpdateStatus(ASPerson * pasHost, UINT idsStatus);
    LRESULT             VIEW_ViewWindowProc(HWND, UINT, WPARAM, LPARAM);


    void                USR_InitDIBitmapHeader(BITMAPINFOHEADER * pbh, UINT bpp);
    void                USR_ScreenChanged(ASPerson * pasPerson);
    void                USR_ScrollDesktop(ASPerson * pasPerson, int xNew, int yNew);
    BOOL                USR_UseFont(HDC hdc, HFONT* pHFONT,
                            LPTEXTMETRIC pMetrics, LPSTR pName, UINT charSet,
                            UINT maxHeight, UINT height, UINT width,
                            UINT weight, UINT flags);


protected:
    void                CAClearRemoteState(ASPerson * pasClear);
    BOOL                CAClearHostState(ASPerson * pasHost, ASPerson * pasController);
    void                CAStartWaiting(ASPerson * pasWait, UINT msgWait);

    BOOL                CAStartQuery(ASPerson * pasFrom, UINT msg, PCA30P pReq);
    void                CAFinishQuery(UINT result);
    void                CACancelQuery(ASPerson * pasFrom, BOOL fPacket);

    void                CAHandleRequestTakeControl(ASPerson * pasViewer, PCA_RTC_PACKET pPacket);
    void                CACompleteRequestTakeControl(ASPerson * pasFrom, PCA_RTC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestTakeControl(ASPerson * pasHost, PCA_REPLY_RTC_PACKET pPacket);

    void                CAHandleRequestGiveControl(ASPerson * pasHost, PCA_RGC_PACKET pPacket);
    void                CACompleteRequestGiveControl(ASPerson * pasFrom, PCA_RGC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestGiveControl(ASPerson * pasViewer, PCA_REPLY_RGC_PACKET pPacket);

    void                CAHandlePreferPassControl(ASPerson * pasController, PCA_PPC_PACKET pPacket);
    void                CACompletePreferPassControl(ASPerson * pasViewer, UINT mcsOrg, PCA_PPC_PACKET pPacket, UINT result);

    void                CAHandleInformReleasedControl(ASPerson * pasController, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformRevokedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);

    void                CAHandleNewState(ASPerson * pasHost, PCANOTPACKET pPacket);
    void                CAStartControlled(ASPerson * pasInControl, UINT controlID);
    void                CAStopControlled(void);
    void                CAStartInControl(ASPerson * pasControlled, UINT controlID);
    void                CAStopInControl(void);

    BOOL                CAFlushOutgoingPackets();
    void                CALangToggle(BOOL);
    UINT                CANewRequestID(void);
    BOOL                CAQueueSendPacket(UINT destID, UINT msg, PCA30P pPacket);
    BOOL                CASendPacket(UINT destID, UINT msg, PCA30P pPacket);

    BOOL                CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);
    HCURSOR             CMCreateColorCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap, UINT cbANDMask, UINT cbXORBitmap);
    BOOL                CMCreateIncoming(ASPerson * pasPerson);
    HCURSOR             CMCreateMonoCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap);
    void                CMDrawCursorTag(ASPerson * pasPerson, HDC hdc);
    void                CMFreeIncoming(ASPerson * pasPerson);
    UINT                CMProcessColorCursorPacket( PCMPACKETCOLORBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMProcessCursorIDPacket(PCMPACKETID pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot);
    UINT                CMProcessMonoCursorPacket(PCMPACKETMONOBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMReceivedCursorMovedPacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );
    void                CMReceivedCursorShapePacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );

    BOOL                CPCCapabilitiesChange(ASPerson * pasPerson, PPROTCAPS pCaps);

    ASPerson *          DCSGetPerson(UINT gccID, BOOL fNull);

    UINT                FHConsiderRemoteFonts(UINT cCommonFonts, ASPerson * pasPerson);
    UINT                FHGetLocalFontHandle(UINT remoteFont, ASPerson * pasPerson);
    void                FHMaybeEnableText(void);

    void                HETCheckSharing(BOOL fStartHost);
    BOOL                HETStartHosting(BOOL fDesktop);
    void                HETStopHosting(BOOL fDesktop);
    void                HETSendLocalCount(void);
    void                HETUpdateLocalCount(UINT newCount);
    void                HETUpdateRemoteCount(ASPerson * pasPerson, UINT newCount);

    BOOL                IMConvertAndSendEvent(ASPerson * pasFor, LPIMEVENT pIMEvent);
    UINT                IMConvertIMEventToOSEvent(LPIMEVENT pEvent, LPIMOSEVENT pOSEvent);
    void                IMDiscardUnreplayableOSEvents(void);
    void                IMGenerateFakeKeyPress(TSHR_UINT16 type,
                            TSHR_UINT16 key, TSHR_UINT16 flags);
    BYTE                IMGetHighLevelKeyState(UINT vk);
    void                IMSendKeyboardState(void);
    BOOL                IMTranslateIncoming(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    BOOL                IMTranslateOutgoing(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    void                IMAppendNetEvent(LPIMEVENT pIMEvent);

    void                IMFlushOutgoingEvents(void);
    void                IMInject(BOOL fStart);
    BOOL                IMInjectEvent(LPIMOSEVENT pEvent);
    BOOL                IMInjectingEvents(void);
    UINT                IMInsertModifierKeystrokes(BYTE curKBState, BYTE targetKBState,
                            LPUINT pEventQueue);
    void                IMMaybeAddDeadKey(BYTE vk);
    void                IMMaybeInjectEvents(void);
    void                IMSpoilEvents(void);
    void                IMUpdateAsyncArray(LPBYTE pimKeyStates, LPIMOSEVENT pEvent);

    void                ODAdjustColor(ASPerson * pasPerson, const TSHR_COLOR * pColorIn, LPTSHR_COLOR pColorOut, int type);
    void                ODDrawTextOrder(ASPerson * pasPerson, BOOL fExtText, BOOL fPalRGB,
                            LPCOMMON_TEXTORDER pCommon, LPSTR pText, UINT cchText,
                            LPRECT pExtRect, UINT extOptions, LPINT pExtDx);
    void                ODReplayARC(ASPerson * pasFrom, LPARC_ORDER pArc, BOOL fPalRGB);
    void                ODReplayCHORD(ASPerson * pasFrom, LPCHORD_ORDER pChord, BOOL fPalRGB);
    void                ODReplayDSTBLT(ASPerson * pasFrom, LPDSTBLT_ORDER pDstBlt, BOOL fPalRGB);
    void                ODReplayELLIPSE(ASPerson * pasFrom, LPELLIPSE_ORDER pEllipse, BOOL fPalRGB);
    void                ODReplayEXTTEXTOUT(ASPerson * pasFrom, LPEXTTEXTOUT_ORDER pExtTextOut, BOOL fPalRGB);
    void                ODReplayLINETO(ASPerson * pasFrom, LPLINETO_ORDER pLineTo, BOOL fPalRGB);
    void                ODReplayMEM3BLT(ASPerson * pasFrom, LPMEM3BLT_ORDER pMem3Blt, BOOL fPalRGB);
    void                ODReplayMEMBLT(ASPerson * pasFrom, LPMEMBLT_ORDER pMemBlt, BOOL fPalRGB);
    void                ODReplayOPAQUERECT(ASPerson * pasFrom, LPOPAQUERECT_ORDER pOpaqeRect, BOOL fPalRGB);
    void                ODReplayPATBLT(ASPerson * pasFrom, LPPATBLT_ORDER pPatBlt, BOOL fPalRGB);
    void                ODReplayPIE(ASPerson * pasFrom, LPPIE_ORDER pPie, BOOL fPalRGB);
    void                ODReplayPOLYBEZIER(ASPerson * pasFrom, LPPOLYBEZIER_ORDER pPolyBezier, BOOL fPalRGB);
    void                ODReplayPOLYGON(ASPerson * pasFrom, LPPOLYGON_ORDER pPolygon, BOOL fPalRGB);
    void                ODReplayRECTANGLE(ASPerson * pasFrom, LPRECTANGLE_ORDER pRectangle, BOOL fPalRGB);
    void                ODReplayROUNDRECT(ASPerson * pasFrom, LPROUNDRECT_ORDER pRoundRect, BOOL fPalRGB);
    void                ODReplaySCRBLT(ASPerson * pasFrom, LPSCRBLT_ORDER pScrBlt, BOOL fPalRGB);
    void                ODReplayTEXTOUT(ASPerson * pasFrom, LPTEXTOUT_ORDER pTextOut, BOOL fPalRGB);
    void                ODUseArcDirection(ASPerson * pasPerson, UINT dir);
    void                ODUseBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseBkMode(ASPerson * pasPerson, int mode);
    void                ODUseBrush(ASPerson * pasPerson, BOOL fPalRGB,
                            int x, int y, UINT Style, UINT Hatch,
                            TSHR_COLOR Color, BYTE  Extra[7]);
    void                ODUseFillMode(ASPerson * pasPerson, UINT mode);
    void                ODUseFont(ASPerson * pasPerson, LPSTR pName, UINT cchName,
                            UINT codePage, UINT maxHeight, UINT Height,
                            UINT Width, UINT Weight, UINT flags);
    void                ODUsePen(ASPerson * pasPerson, BOOL fPalRGB,
                            UINT style, UINT width, TSHR_COLOR color);
    void                ODUseRectRegion(ASPerson * pasPerson, int left,
                            int top, int right, int bottom);
    void                ODUseROP2(ASPerson * pasPerson, int rop);
    void                ODUseTextBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextCharacterExtra(ASPerson * pasPerson, int extra);
    void                ODUseTextColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextJustification(ASPerson * pasPerson, int extra, int count);

    void                OD2CopyFromDeltaCoords(LPTSHR_INT8* ppSrc, LPVOID pDst,
                                UINT cbDstField, BOOL fSigned, UINT numElements);
    void                OD2DecodeBounds(LPBYTE *ppNextDataToCopy,
                                LPTSHR_RECT16 pRect, ASPerson * pasPerson);
    void                OD2DecodeField(LPBYTE*  ppSrc, LPVOID pDest,
                                UINT cbSrcField, UINT cbDstField, BOOL fSigned,
                                UINT numElements);
    void                OD2FreeIncoming(ASPerson * pasPerson);
    BOOL                OD2UseFont(ASPerson * pasPerson, LPSTR pName,
                                UINT facelength, UINT codePage, UINT MaxHeight,
                                UINT Height, UINT Width, UINT Weight, UINT flags);

    void                OECapabilitiesChanged(void);

    void                PMFreeIncoming(ASPerson * pasPerson);

    void                RBCFreeIncoming(ASPerson * pasPerson);
    void                RBCStoreBitsInCacheBitmap(ASPerson *  pasPerson,
                            UINT cacheID, UINT iCacheEntry, UINT cxSubWidth,
                            UINT cxFixedWidth, UINT cySubHeight, UINT bpp,
                            LPBYTE pBitmapBits, UINT cbBitmapBits, BOOL fCompressed);

    BOOL                SCSyncStream(UINT streamID);

    void                SDPDrawHatchedRegion(HDC hdc, HRGN region, UINT hatchColor);
    void                SDPPlayScreenDataToRDB(ASPerson * pasPerson,
                            PSDPACKET pUpdates, LPBYTE pBits, LPRECT pPosition);

    void                VIEWClientAutoScroll(ASPerson *);
    void                VIEWClientCaptureStolen(ASPerson *);
    void                VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw);
    void                VIEWClientGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWClientMouseDown(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMove(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMsg(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseUp(ASPerson *, UINT, WPARAM, LPARAM, BOOL);
    void                VIEWClientMouseWheel(ASPerson *, WPARAM, LPARAM);
    void                VIEWClientPaint(ASPerson * pasHost);
    BOOL                VIEWClientScroll(ASPerson * pasHost, int xNew, int yNew);

    void                VIEWFrameAbout(ASPerson * pasHost);
    void                VIEWFrameCommand(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    BOOL                VIEWFrameCreate(ASPerson * pasHost);
    void                VIEWFrameFullScreen(ASPerson * pasHost, BOOL fFull);
    void                VIEWFrameGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWFrameHelp(ASPerson * pasHost);
    void                VIEWFrameInitMenuBar(ASPerson * pasHost);
    void                VIEWFrameOnMenuSelect(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    void                VIEWFrameResize(ASPerson * pasHost);
    void                VIEWFrameResizeChanged(ASPerson * pasHost);
    void                VIEWFrameSetStatus(ASPerson * pasHost, UINT idsStatus);

    void                VIEWFullScreenExitPaint(ASPerson * pasHost, HWND hwnd);

    void                VIEWStartControlled(BOOL fControlled);

    BOOL                USRCreateRemoteDesktop(ASPerson * pasPerson);
    void                USRDeleteRemoteDesktop(ASPerson * pasPerson);

};




typedef struct tagASSession
{
    // pasNext someday!
    UINT                    scState;

    UINT                    callID;     // ID of call
    MCSID                   gccID;      // GCC node_id
    BOOL                    fShareCreator;

    UINT                    cchLocalName;
    char                    achLocalName[TSHR_MAX_PERSON_NAME_LEN];
    ASShare *               pShare;
#ifdef _DEBUG
    DWORD                   scShareTime;
#endif
}
ASSession;


#endif // _H_AS

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\cm.h ===
//
// Cursor Manager
//

#ifndef _H_CM
#define _H_CM


//
//
// CONSTANTS
//
//

//
// Maximum cursor sizes.
//
#define CM_MAX_CURSOR_WIDTH            32
#define CM_MAX_CURSOR_HEIGHT           32

//
// This is the maximum size of the cursor data for the combined 1bpp AND
// mask and n bpp XOR mask.  We currently allow for a 32x32 cursor at
// 32bpp.  In this case the AND mask consumes 32*32/8 bytes (128) and the
// XOR mask consumes 32*32*4 bytes (4096).  Total is 32*4 + 32*32*4, which
// is (32*4)*(1 + 32), which is (32*4)*33
//
#define CM_MAX_CURSOR_DATA_SIZE        \
    ((CM_MAX_CURSOR_WIDTH/8) * CM_MAX_CURSOR_HEIGHT * 33)


//
// Thresholds for color intensity to distinguish between 24bpp colors which
// map to black, white, or a hatch pattern
//
#define CM_WHITE_THRESHOLD  (TSHR_UINT32)120000
#define CM_BLACK_THRESHOLD  (TSHR_UINT32)40000


//
// Shadow cursor tag constant declarations.
//
#define	NTRUNCLETTERS	    5 // For CreateAbbreviatedName - "A. B."
#define MAX_CURSOR_TAG_FONT_NAME_LENGTH 64
#define CURSOR_TAG_FONT_HEIGHT  -11

//
// This defines the size of the tag.. careful if you change these
// values... they must define a tag that fits in a hardcoded 32x32 bitmap.
//
#define	TAGXOFF	8
#define	TAGYOFF	20
#define	TAGXSIZ 24
#define	TAGYSIZ	12


typedef struct tag_curtaginfo
{
	WORD cHeight;
	WORD cWidth;
	BYTE aAndBits[ 32 * 32 / 8 ];
	BITMAPINFO bmInfo; // includes foreground color
	RGBQUAD rgbBackground[1]; // describes background color
	BYTE aXorBits[ 32 * 32 / 8 ]; // packed bits follow BITMAPINFO, color table
}
CURTAGINFO, * PCURTAGINFO;



typedef struct tagCACHEDCURSOR
{
    HCURSOR  hCursor;
    POINT     hotSpot;
}
CACHEDCURSOR;
typedef CACHEDCURSOR * PCACHEDCURSOR;


//
// Information about a remote party's cursor.
//
//
//
//
// Calculates the number of bytes wide a cursor is given the width of the
// cursor in pels. Cursors are 1bpp and word padded.
//
#define CM_BYTES_FROM_WIDTH(width) ((((width)+15)/16)*2)


//
//
// TYPES
//
//

//
// A POINTL has 32-bit coords in both 16-bit and 32-bit code
//
typedef struct tagCM_SHAPE_HEADER
{
    POINTL  ptHotSpot;
    WORD    cx;
    WORD    cy;
    WORD    cbRowWidth;
    BYTE    cPlanes;
    BYTE    cBitsPerPel;
} CM_SHAPE_HEADER;
typedef CM_SHAPE_HEADER FAR * LPCM_SHAPE_HEADER;

typedef struct tagCM_SHAPE
{
    CM_SHAPE_HEADER     hdr;
    BYTE                Masks[1]; // 1bpp AND mask, followed by n bpp XOR mask
} CM_SHAPE;
typedef CM_SHAPE FAR * LPCM_SHAPE;


typedef struct tagCM_SHAPE_DATA
{
    CM_SHAPE_HEADER     hdr;
    BYTE                data[CM_MAX_CURSOR_DATA_SIZE];
}
CM_SHAPE_DATA;
typedef CM_SHAPE_DATA FAR * LPCM_SHAPE_DATA;



// Structure: CM_FAST_DATA
//
// Description: Shared memory data - cursor description and usage flag
//
//   cmCursorStamp     - Cursor identifier: an integer written by the
//                       display driver
//   bitmasks          - RGB bitmasks for >8bpp cursors
//   colorTable        - Color table for <= 8bpp cursors
//   cmCursorShapeData - Cursor definition (AND, XOR masks, etc)
//
//
//
//  Note that a PALETTEENTRY is a DWORD, same in 16-bit and 32-bit code
//
typedef struct tagCM_FAST_DATA
{
    DWORD                   cmCursorStamp;
    DWORD                   bitmasks[3];
    PALETTEENTRY            colorTable[256];
    CM_SHAPE_DATA           cmCursorShapeData;
}
CM_FAST_DATA;
typedef CM_FAST_DATA FAR * LPCM_FAST_DATA;



//
//
// MACROS
//
//
#define CURSOR_AND_MASK_SIZE(pCursorShape) \
    ((pCursorShape)->hdr.cbRowWidth * (pCursorShape)->hdr.cy)

#define ROW_WORD_PAD(cbUnpaddedRow) \
    (((cbUnpaddedRow) + 1) & ~1)

#define CURSOR_XOR_BITMAP_SIZE(pCursorShape)                                 \
                     (ROW_WORD_PAD(((pCursorShape)->hdr.cx *                 \
                                    (pCursorShape)->hdr.cBitsPerPel) / 8) *  \
                     (pCursorShape)->hdr.cy)

#define CURSOR_DIB_BITS_SIZE(cx, cy, bpp)   \
                                       (ROW_WORD_PAD(((cx) * (bpp))/8) * (cy))

#define CURSORSHAPE_SIZE(pCursorShape) \
    sizeof(CM_SHAPE_HEADER) +               \
    CURSOR_AND_MASK_SIZE(pCursorShape) +     \
    CURSOR_XOR_BITMAP_SIZE(pCursorShape)

//
// Null cursor indications
//
#define CM_CURSOR_IS_NULL(pCursor) ((((pCursor)->hdr.cPlanes==(BYTE)0xFF) && \
                                    (pCursor)->hdr.cBitsPerPel == (BYTE)0xFF))

#define CM_SET_NULL_CURSOR(pCursor) (pCursor)->hdr.cPlanes = 0xFF;          \
                                    (pCursor)->hdr.cBitsPerPel = 0xFF;

//
// Expands a particular bit into a byte.  The bits are zero-indexed and
// numbered from the left.  The allowable range for pos is 0 to 7
// inclusive.
//
#define BIT_TO_BYTE(cbyte, pos) \
             ( (BYTE) ((((cbyte) >> (7 - (pos))) & 0x01) ? 0xFF : 0x00))

//
// Get two bits from a byte.  The bits are zero-indexed and numbered from
// the left.  The allowable range for pos is 0 to 3 inclusive.
//
#define GET_TWO_BITS(cbyte, pos)                                \
  ( (BYTE) (((cbyte) >> (2 * (3 - (pos)))) & 0x03) )

//
// Return the maximum size of palette (in bytes) required for a DIB at a
// given bpp.  This is 2 ^ bpp for bpp < 8, or 0 for > 8 bpp
//
#define PALETTE_SIZE(BPP)   (((BPP) > 8) ? 0 : ((1<<(BPP)) * sizeof(RGBQUAD)))


//
// Return a pointer to the actual bitmap bits within a DIB.
//
#define POINTER_TO_DIB_BITS(pDIB)                     \
        ((void *) ((LPBYTE)(pDIB) + DIB_BITS_OFFSET(pDIB)) )

//
// Calculate the offset of the data bits in a DIB.
//
#define DIB_BITS_OFFSET(pDIB)                         \
        (PALETTE_SIZE((pDIB)->bmiHeader.biBitCount) +   \
        sizeof(BITMAPINFOHEADER))

//
// Trace out info about a DIB.  PH is a pointer to a BITMAPINFOHEADER
//
#define CAP_TRACE_DIB_DBG(PH, NAME)                                          \
    TRACE_OUT(( "%s: %#.8lx, %ld x %ld, %hd bpp, %s encoded",               \
        (NAME), (DWORD)(PH), (PH)->biWidth, (PH)->biHeight, (PH)->biBitCount,\
        ((PH)->biCompression == BI_RLE8) ? "RLE8"                            \
            : (((PH)->biCompression == BI_RLE4) ? "RLE4" : "not")))

//
// Is the parameter a pointer to a Device Dependant Bitmap?
//
#define IS_DIB(PARAM) (*((LPWORD)(PARAM)) == 0x28)

//
// Driver supports color_cursors and async SetCursor.  This value is taken
// from the Win95 DDK.
//
#define C1_COLORCURSOR  0x0800


//
//
// PROTOTYPES
//
//





//
// Specific values for OSI escape codes
//
#define CM_ESC(code)        (OSI_CM_ESC_FIRST + code)

#define CM_ESC_XFORM        CM_ESC(0)



//
//
// STRUCTURES
//
//


// Structure: CM_DRV_XFORM_INFO
//
// Description: Structure passed from the share core to the display driver
// to pass cursor transform data
//
typedef struct tagCM_DRV_XFORM_INFO
{
    OSI_ESCAPE_HEADER header;

    //
    // Share core -> display driver.
    // Pointers to AND mask.  Note that this user-space pointer is also
    // valid in the display driver realm (ring0 if NT, 16-bit if W95)
    //
    LPBYTE          pANDMask;
    DWORD           width;
    DWORD           height;

    //
    // Driver -> share core.
    //
    DWORD           result;

} CM_DRV_XFORM_INFO;
typedef CM_DRV_XFORM_INFO FAR * LPCM_DRV_XFORM_INFO;


//
//
// PROTOTYPES
//
//

#ifdef DLL_DISP

//
// Name:      CM_DDProcessRequest
//
// Purpose:   Process CM requests from the Share Core which have been
//            to the display driver through the DrvEscape mechanism.
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    CM_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);
#else
ULONG   CM_DDProcessRequest(SURFOBJ*  pso,
                                UINT  cjIn,
                                void *   pvIn,
                                UINT  cjOut,
                                void *   pvOut);
#endif


#ifdef IS_16
BOOL    CM_DDInit(HDC);
#else
BOOL    CM_DDInit(LPOSI_PDEV ppDev);
#endif  // IS_16


#ifdef IS_16
void    CM_DDViewing(BOOL fViewers);
#else
void    CM_DDViewing(SURFOBJ * pso, BOOL fViewers);
#endif // IS_16

//
// Name:      CM_DDTerm
//
// Purpose:   Terminates the display driver component of the cursor
//            manager.
//
// Params:    None.
//
void CM_DDTerm(void);


#endif // DLL_DISP


typedef void ( *PFNCMCOPYTOMONO) ( LPBYTE pSrc,
                                                    LPBYTE pDst,
                                                    UINT   cx,
                                                    UINT   cy );


//
// Cursor type (as required by CMMaybeSendCursor).  The values are:
//
//  DEFAULTCURSOR   - standard pointer
//  DISPLAYEDCURSOR - displayed (eg.  bitmap) cursor
//
#define CM_CT_DEFAULTCURSOR   1
#define CM_CT_DISPLAYEDCURSOR 2

//
// Types of displayed cursor:
//
//  UNKNOWN      - ONLY to be used by resyncing code
//  SYSTEMCURSOR - Standard windows cursor
//  BITMAPCURSOR - Displayed cursor
//
#define CM_CD_UNKNOWN         0
#define CM_CD_SYSTEMCURSOR    1
#define CM_CD_BITMAPCURSOR    2

typedef struct tagCURSORDESCRIPTION
{
    DWORD       type;
    DWORD       id;
} CURSORDESCRIPTION;
typedef CURSORDESCRIPTION FAR * LPCURSORDESCRIPTION;

typedef struct tagCURSORIMAGE
{
    WORD                xHotSpot;
    WORD                yHotSpot;
    BITMAPINFOHEADER    crHeader;
    BYTE                crMasks[1];
} CURSORIMAGE;
typedef CURSORIMAGE FAR *LPCURSORIMAGE;



#ifndef DLL_DISP



BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);




//
// BOGUS LAURABU:
// We should use normal GDI StretchBlts to get the bitmap bits, not
// our own whacky pack/unpack code.
//
void CMCopy1bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy4bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy8bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy16bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

void CMCopy24bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

BOOL CMGetMonoCursor( LPTSHR_UINT16 pcxWidth,
                                   LPTSHR_UINT16 pcyHeight,
                                   LPTSHR_UINT16 pxHotSpot,
                                   LPTSHR_UINT16 pyHotSpot,
                                   LPBYTE  pANDBitmap,
                                   LPBYTE  pXORBitmap );



void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor);

void CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                              LPUINT      pcbANDMaskSize,
                                              LPUINT      pcbXORBitmapSize );

BOOL CMGetMonoCursorDetails( LPCM_SHAPE pCursor,
                                          LPTSHR_UINT16      pcxWidth,
                                          LPTSHR_UINT16      pcyHeight,
                                          LPTSHR_UINT16      pxHotSpot,
                                          LPTSHR_UINT16      pyHotSpot,
                                          LPBYTE       pANDBitmap,
                                          LPTSHR_UINT16      pcbANDBitmap,
                                          LPBYTE       pXORBitmap,
                                          LPTSHR_UINT16      pcbXORBitmap );


void CMRefreshWindowCursor(HWND window);


BOOL CMGetCursorShape( LPCM_SHAPE * ppCursorShape,
                                    LPUINT              pcbCursorDataSize );

HWND CMGetControllingWindow(void);


#define CM_SHM_START_READING  &g_asSharedMemory->cmFast[\
                   1 - g_asSharedMemory->fastPath.newBuffer]
#define CM_SHM_STOP_READING


#else


#ifdef IS_16
BOOL    CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult);
void    CMDDJiggleCursor(void);
#else
BOOL    CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo);
#endif


#define CM_SHM_START_WRITING  SHM_StartAccess(SHM_CM_FAST)
#define CM_SHM_STOP_WRITING   SHM_StopAccess(SHM_CM_FAST)



#endif // !DLL_DISP



#endif // _H_CM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\bmc.h ===
//
// BMC.H
// Bitmap Cache
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BMC
#define _H_BMC


//
// Bitmap caching order header
//
typedef struct tagBMC_ORDER_HDR
{
    TSHR_UINT8        bmcPacketType;
}
BMC_ORDER_HDR;
typedef BMC_ORDER_HDR FAR * PBMC_ORDER_HDR;


//
// Structure of data stored in DIB cache.
// The first few fields are variable and therefore not included in the
// cache hash.
//
#define BMC_DIB_NOT_HASHED   (FIELD_OFFSET(BMC_DIB_ENTRY, cx))
typedef struct tagBMC_DIB_ENTRY
{
    BYTE            inUse;
    BYTE            bCompressed;
    TSHR_UINT16     iCacheIndex;
    TSHR_UINT16     cx;
    TSHR_UINT16     cxFixed;
    TSHR_UINT16     cy;
    TSHR_UINT16     bpp;
    UINT            cCompressed;
    UINT            cBits;
    BYTE            bits[1];
}
BMC_DIB_ENTRY;
typedef BMC_DIB_ENTRY FAR * PBMC_DIB_ENTRY;


//
// DIB cache header
//
typedef struct tagBMC_DIB_CACHE
{
    PCHCACHE        handle;
    PBMC_DIB_ENTRY  freeEntry;
    LPBYTE          data;
    UINT            cEntries;
    UINT            cCellSize;
    UINT            cSize;
}
BMC_DIB_CACHE;
typedef BMC_DIB_CACHE * PBMC_DIB_CACHE;



//
// WE HAVE NO SMALL TILES ANYMORE
// Medium sized tiles must fit into a medium cell for the sending depth.
// Large sized tiles must fit into a large cell for the sending depth.
//
// Since true color sending can change dynamically, the easiest thing to do
// to cut down on memory usage is to check the capture depth.  If it's
// <= 8, then we can never send true color, so allocate for 8bpp.  Else
// allocate for 24bpp.
//

#define BYTES_IN_SCANLINE(width, bpp)   ((((width)*(bpp))+31)/32)*4

#define BYTES_IN_BITMAP(width, height, bpp)  (BYTES_IN_SCANLINE(width, bpp)*height)


__inline UINT  MaxBitmapHeight(UINT width, UINT bpp)
{
    UINT    bytesPerRow;

    //
    // If bpp is 4, there are width/2 bytes per Row
    // If bpp is 8, there are width bytes per Row
    // If bpp is 24, there are 3*width bytes per Row
    //
    bytesPerRow = BYTES_IN_SCANLINE(width, bpp);
    return((TSHR_MAX_SEND_PKT - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER)) / bytesPerRow);
}


//
// Define the cache identifiers which are transmitted in the hBitmap field
// of Memory->Screen blt orders.
//
// These are replaced by the receiver with their local (real) bitmap
// handle of the specified cache.
//
// Note that they are assumed to be contiguous with the smallest as 0
//
//
#define ID_SMALL_BMP_CACHE              0
#define ID_MEDIUM_BMP_CACHE             1
#define ID_LARGE_BMP_CACHE              2
#define NUM_BMP_CACHES                  3


//
// WHEN 2.X COMPAT IS GONE, WE CAN PLAY WITH THESE SIZES AT WILL.  But
// since the cell size (width * height * bpp) is negotiated when a 2.x
// node is in the share, we can not. Back level nodes assume a certain
// cell size.  So do new level nodes for now!
//

#define MP_SMALL_TILE_WIDTH             16
#define MP_SMALL_TILE_WIDTH             16
#define MP_MEDIUM_TILE_WIDTH            32
#define MP_MEDIUM_TILE_HEIGHT           32
#define MP_LARGE_TILE_WIDTH             64
#define MP_LARGE_TILE_HEIGHT            63


#define MP_CACHE_CELLSIZE(width, height, bpp)   \
    (BYTES_IN_BITMAP(width, height, bpp) + sizeof(BMC_DIB_ENTRY) - 1)


//
// Upper bound on the total cache memory we'll use (2 MB)
//
#define MP_MEMORY_MAX                   0x200000

#define COLORCACHEINDEX_NONE            0xFF

#define MEMBLT_CACHETABLE(pMemBlt) ((TSHR_UINT16)LOBYTE(pMemBlt->cacheId))
#define MEMBLT_COLORINDEX(pMemBlt) ((TSHR_UINT16)HIBYTE(pMemBlt->cacheId))
#define MEMBLT_COMBINEHANDLES(colort, bitmap)   ((TSHR_UINT16)MAKEWORD(bitmap, colort))


BOOL BMCAllocateCacheData(UINT numEntries, UINT cellSize, UINT cacheID,
        PBMC_DIB_CACHE pCache);
void BMCFreeCacheData(PBMC_DIB_CACHE pCache);


#endif // H_BMC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\dbgzones.h ===
#ifndef _DEBUG_ZONES_H_
#define _DEBUG_ZONES_H_

#include <mlzdbg.h>

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

enum
{
    ZONE_CORE = BASE_ZONE_INDEX,
    ZONE_NET,
    ZONE_ORDER,
    ZONE_OM,
    ZONE_INPUT,
    ZONE_WB,
    ZONE_UT
};

#endif // _DEBUG && MULTI_LEVEL_ZONES


#endif // _DEBUG_ZONES_H_


// lonchanc: this must be outside the _DEBUG_ZONE_H_ protection
// because cpi32dll.c and crspdll.c need to include this header
// again in order to initialize the debug zone data.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA) && defined(MULTI_LEVEL_ZONES)

static const PSTR c_apszDbgZones[] =
{
    "AppShr",      // debug zone module name
    DEFAULT_ZONES
    "Core",
    "Network",
    "Order",
    "ObMan",
    "Input",
    "Whiteboard",
    "UT",
};

#endif // _DEBUG && INIT_DBG_ZONE_DATA && MULTI_LEVEL_ZONES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\drvdbg.h ===
//
// DRVDBG.H
// Display Driver (NT-only right now) Debug Macros
//
// Copyright(c) Microsoft 1997-
//

#ifndef _H_DRVDBG
#define _H_DRVDBG


#ifdef  ASSERT
#undef  ASSERT
#endif // ASSERT


#define CCH_DEBUG_MAX           256

// Standard Zones
#define ZONE_INIT               0x0001
#define ZONE_TRACE              0x0002
#define ZONE_FUNCTION           0x0004
#define ZONE_MASK               0x0007
#define ZONE_OAHEAPCHECK        0x0008



#ifndef DEBUG

#define DebugEntry(x)
#define DebugExitVOID(x)
#define DebugExitDWORD(x, dw)
#define DebugExitBOOL(x, f)
#define DebugExitPVOID(x, ptr)

#define TRACE_OUT(x)
#define WARNING_OUT(x)
#define ASSERT(x)

#else



void DbgZPrintFn(LPSTR szFn);
void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult);
void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr);

#define DebugEntry(szFn)                DbgZPrintFn("ENTER "#szFn)
#define DebugExitVOID(szFn)             DbgZPrintFn("LEAVE "#szFn)
#define DebugExitDWORD(szFn, dwResult)  DbgZPrintFnExitDWORD("LEAVE "#szFn, dwResult)
#define DebugExitBOOL(szFn, fResult)    DbgZPrintFnExitDWORD("LEAVE "#szFn, fResult)
#define DebugExitPVOID(szFn, dwResult)  DbgZPrintFnExitPVOID("LEAVE "#szFn, dwResult)


void _cdecl DbgZPrintTrace(LPSTR pszFormat, ...);
void _cdecl DbgZPrintWarning(LPSTR pszFormat, ...);

#define TRACE_OUT(szMsg)                DbgZPrintTrace  szMsg
#define WARNING_OUT(szMsg)              DbgZPrintWarning  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg


extern char g_szAssertionFailure[];

#define ASSERT(exp)                     if (!(exp)) ERROR_OUT((g_szAssertionFailure))



#endif // !DEBUG


//
// For driver start up tracing in retail as well
//
#if defined(DEBUG) || defined(INIT_TRACE)

void _cdecl DbgZPrintInit(LPSTR pszFormat, ...);
void _cdecl DbgZPrintError(LPSTR pszFormat, ...);

#define INIT_OUT(szMsg)                 DbgZPrintInit  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg

#else

#define INIT_OUT(x)
#define ERROR_OUT(x)

#endif // DEBUG or INIT_TRACE



#endif // _H_DRVDBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\datainit.h ===
//
// Macros that create storage for vars
//

//
// Clear any previous definitions of the macros.
//
#undef DC_DATA
#undef DC_DATA_VAL
#undef DC_CONST_DATA
#undef DC_DATA_ARRAY
#undef DC_CONST_DATA_ARRAY
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA_2D_ARRAY


// This is for structs that can't use the DC_DATA macros; they can switch on it
#define DC_DEFINE_DATA

//
// Allocate Storage
//

#define DC_DATA(TYPE, Name) \
            TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            TYPE Name = Value

#define DC_CONST_DATA(TYPE, Name, Value) \
            const TYPE Name = Value


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            const TYPE Name[Size] = Value


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            const TYPE Name[Size1][Size2] = Value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\fh.h ===
//
// Font Handler
//

#ifndef _H_FH
#define _H_FH


//
// This is needed to define LPCOM_ORDER
//
#include <oa.h>


//
// Constants.
//

//
// The sent ID field is set up when we copy fonts to send; if we don't send
// the font we set it to this value:
//
#define FONT_NOT_SENT  (-1)

//
// Because a font can match to font ID zero, actually having an explicit
// 'no match' constant acts as an extra 'firewall'.  The remote match array
// is of UINTs, so we have to make this constant positive...
//
#define NO_FONT_MATCH  (0xffff)

//
// This dummy font id is used instead of a remote ID of 0 when we need to
// distinguish between a remote ID of 0, and a remote ID that on conversion
// to local gives zero.
//
#define DUMMY_FONT_ID   0xFFFF



//
// Font Width Table type.
//
typedef struct tagFHWIDTHTABLE
{
    BYTE     charWidths[256];
} FHWIDTHTABLE, FAR * PFHWIDTHTABLE;

//
// The local font structure contains the extra info we need for font
// matching; we can't change the NETWORKFONT structure because we have to
// maintain back compatibility
//
// This comment is slight tosh.  We can and do change NETWORKFONT (though
// only in a carefully managed way!).  The point is that the data outside
// of the Details field is only needed locally - it is not transmitted
// across the wire.
//
// Note that in FH_Init, we do a qsort, which assumes
// that the first thing in the LOCALFONT structure is the facename.  So
// bear this in mind if you change it.  We assume that the NETWORKFONT
// structure will always start with the facename.
//
typedef struct _LOCALFONT
{
    NETWORKFONT Details;                  // old structure - sent over wire
    TSHR_UINT16 lMaxBaselineExt;          // max height of this font
    char        RealName[FH_FACESIZE];    // Real font name
    TSHR_UINT32 SupportCode;              // font is supported - see below
}
LOCALFONT;
typedef LOCALFONT FAR * LPLOCALFONT;

//
// The following values are set in the SupportCode field of the LOCALFONT
// structure to indicate whether a font is supported in the current
// share. The values are designed to make it easy to calculate the lowest
// common denominator of two support codes (l.c.d.  = code1 & code2).
//
// A SupportCode contains the bit flag
//    FH_SC_MATCH if it describes any sort of match at all
//    FH_SC_ALL_CHARS if the match applies to all characters in the font,
//        as opposed to just the ASCII alphanumeric characters
//    FH_SC_EXACT if the match is considered exact,
//        as opposed to an approximate match
//
//
#define FH_SC_MATCH            1
#define FH_SC_ALL_CHARS        2
#define FH_SC_EXACT            4

//
// Forget it: no viable match.
//
#define FH_SC_NO_MATCH 0

//
// Every char is a good but not exact match.
//
#define FH_SC_APPROX_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS)

//
// Every char is likely to be an accurate match.
//
#define FH_SC_EXACT_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS | FH_SC_EXACT)

//
// Chars 20->7F are likely to be an accurate match.
//
#define FH_SC_EXACT_ASCII_MATCH (FH_SC_MATCH | FH_SC_EXACT)

//
// Chars 20->7F are likely to be good but not exact matches.
//
#define FH_SC_APPROX_ASCII_MATCH (FH_SC_MATCH)



//
// Structures and typedefs.
//
// The FONTNAME structure is used for each entry in the array of font
// names.
//
typedef struct tagFONTNAME
{
    char        szFontName[FH_FACESIZE];
}
FONTNAME;
typedef FONTNAME FAR * LPFONTNAME;


//
// Maximum number of fonts that we can handle at all.
//
#define FH_MAX_FONTS \
    (((TSHR_MAX_SEND_PKT - sizeof(FHPACKET)) / sizeof(NETWORKFONT)) + 1 )

//
// Size of index into local font table
//
#define FH_LOCAL_INDEX_SIZE  256


typedef struct tagFHFAMILIES
{
    STRUCTURE_STAMP

    UINT        fhcFamilies;
    FONTNAME    afhFamilies[FH_MAX_FONTS];
}
FHFAMILIES;
typedef FHFAMILIES FAR * LPFHFAMILIES;



//
// Local font list
//
// NOTE: The font index is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, afhFontIndex[65] gives the first index in afhFonts
// that starts with the character 'A'.
//
//
typedef struct tagFHLOCALFONTS
{
    STRUCTURE_STAMP

    UINT        fhNumFonts;
    TSHR_UINT16 afhFontIndex[FH_LOCAL_INDEX_SIZE];
    LOCALFONT   afhFonts[FH_MAX_FONTS];
}
FHLOCALFONTS;
typedef FHLOCALFONTS FAR * LPFHLOCALFONTS;




//
// FUNCTION: FH_GetFaceNameFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the face name of the font.
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// pFaceNameLength - pointer to variable to receive the length of the face
// name returned.
//
// RETURNS: pointer to face name.
//
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT  fontHandle,
                                                  LPUINT faceNameLength);

UINT FH_GetMaxHeightFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT FH_GetFontFlagsFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CharSet value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: CodePage
//
//
UINT FH_GetCodePageFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_Init
//
// DESCRIPTION:
//
// This routine finds all the fonts in the local system.  It is called from
// USR.
//
// PARAMETERS: VOID
//
// RETURNS: Number of fonts found
//
//
UINT FH_Init(void);
void FH_Term(void);


//
// API FUNCTION: FH_CreateAndSelectFont
//
// DESCRIPTION:
//
// Creates a logical font for the HPS/HDC supplied.
//
// PARAMETERS:
//
// surface - surface to create logical font for.
//
// pHNewFont - pointer to new font handle to use. This is returned.
//
// pHOldFont - pointer to old font handle (which was previously selected
// into the HPS or HDC).
//
// fontName - the facename of the font.
//
// codepage - codepage (though in most case just holds charset)
//
// fontMaxHeight - the max baseline extent of the font. (Do not confuse
// with fontHeight which is the cell height of the font).
//
// fontWidth,fontWeight,fontFlags - take the same values as the equivalent
// fields in a TEXTOUT or EXTTEXTOUT order.
//
// RETURNS: TRUE - success, FALSE - failure.
//
BOOL FH_CreateAndSelectFont(HDC    hdc,
                                         HFONT *        pHNewFont,
                                         HFONT *        pHOldFont,
                                         LPSTR        fontName,
                                         UINT         codepage,
                                         UINT         fontMaxHeight,
                                         UINT         fontHeight,
                                         UINT         fontWidth,
                                         UINT         fontWeight,
                                         UINT         fontFlags);


//
// API FUNCTION: FH_DeleteFont
//
// DESCRIPTION:
//
// Deletes/frees the supplied system font handle.
//
// PARAMETERS:
//
//  sysFontHandle - system font handle to delete/free
//
// RETURNS:
//
//  None
//
void FH_DeleteFont(HFONT hFont);

//
// API FUNCTION: FH_SelectFont
//
// DESCRIPTION:
//
// Selects a font identified by its system font handle into a surface.
//
// PARAMETERS:
//
//  surface - the surface to select the font into
//  sysFontHandle - system font handle
//
// RETURNS:
//
//  None
//
void FH_SelectFont(HDC hdc, HFONT hFont);


void FHAddFontToLocalTable( LPSTR  faceName,
                                         TSHR_UINT16 fontFlags,
                                         TSHR_UINT16 codePage,
                                         TSHR_UINT16 maxHeight,
                                         TSHR_UINT16 aveHeight,
                                         TSHR_UINT16 aveWidth,
                                         TSHR_UINT16 aspectX,
                                         TSHR_UINT16 aspectY,
                                         TSHR_UINT16 maxAscent);



void FHConsiderAllLocalFonts(void);

void FHSortAndIndexLocalFonts(void);

int  FHComp(LPVOID p1, LPVOID p2);
void FH_qsort(LPVOID base, UINT num, UINT size);

// prototypes UT_qsort routines
void shortsort(char *lo, char *hi, unsigned  width);
void swap(char *p, char *q, unsigned int width);

// this parameter defines the cutoff between using quick sort and
// insertion sort for arrays; arrays with lengths shorter or equal to the
// below value use insertion sort

#define CUTOFF 8


BOOL FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                           LPLOCALFONT    pFontInfo,
                                           UINT        fontHeight,
                                           UINT        fontWidth,
                                           UINT        fontWeight,
                                           UINT        fontFlags,
                                           LPTSHR_UINT16     pMaxAscent);

BOOL FHGetStringSpacing(UINT fontHandle,
                                     UINT fontHeight,
                                     UINT fontWidth,
                                     UINT fontWeight,
                                     UINT fontFlags,
                                     UINT stringLength,
                                     LPSTR string,
                                     LPTSHR_INT16 deltaXArray);

//
// FHCalculateSignatures - see fh.c.
//
void FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                        LPTSHR_INT16       pSigFats,
                                        LPTSHR_INT16       pSigThins,
                                        LPTSHR_INT16       pSigSymbol);

//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK FHEachFontFamily(
                            const ENUMLOGFONT   FAR * enumlogFont,
                            const NEWTEXTMETRIC FAR * TextMetric,
                            int                       FontType,
                            LPARAM                    lParam);

int CALLBACK FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                              const NEWTEXTMETRIC FAR * TextMetric,
                              int                       FontType,
                              LPARAM                    lParam);


#endif // _H_FH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\dcs.h ===
//
// DC-Share Stuff
//

#ifndef _H_DCS
#define _H_DCS



//
// RESOURCES
//

#include <resource.h>



//
// We piggyback some extra flags into the ExtTextOut options.  We must
// ensure that we dont clash with the Windows defined ones.
//
#define     ETO_WINDOWS         (0x0001 | ETO_OPAQUE | ETO_CLIPPED)
#define     ETO_LPDX            0x8000U


//
// Debugging Options (also in retail)
//
// NOTE:  THESE MUST STAY IN SYNC WITH WHAT'S in \ui\conf\dbgmenu.*
//

// View one's own shared stuff in a frame to see what others are getting
#define VIEW_INI_VIEWSELF                    "ViewOwnSharedStuff"

// Hatch the areas sent as screen data from the host when viewing them
#define USR_INI_HATCHSCREENDATA             "HatchScreenData"

// Hatch the areas sent as bitmap orders from the host when viewing them
#define USR_INI_HATCHBMPORDERS               "HatchBitmapOrders"

// Turn off flow control
#define S20_INI_NOFLOWCONTROL               "NoFlowControl"

//
// Change compression type (bunch of bit flags)
//      0x0000 (CT_NONE) is no compression
//      0x0001 (CT_PKZIP) is non-persistent dictionary PKZIP
//      0x0002 (CT_PERSIST_PKZIP) is persistent dictionary PKZIP
//
// Default value is 0x0003 (pkzip + persist pkzip)
//      
#define GDC_INI_COMPRESSION                 "GDCCompression"

//
// Change 2nd level order encoding (bunch of bitflags)
//      0x0001 (CAPS_ENCODING_BASE_OE)
//      0x0002 (CAPS_ENCODING_OE2_NEGOTIABLE)
//      0x0004 (CAPS_ENCODING_OE2_DISABLED)
//      0x0008 (CAPS_ENCODING_ALIGNED_OE)
//
// Default value is 0x0002
// To turn off 2nd level encoding, use 0x0006 (negotiable + disabled)
//
#define OE2_INI_2NDORDERENCODING            "2ndLevelOrderEncoding"


//
// Speedy link constant
//
#define DCS_FAST_THRESHOLD                      50000

//
// We will not compress packets smaller than this, whatever the link speed
//
#define DCS_MIN_COMPRESSABLE_PACKET             256

//
// We will not compress packets smaller than this on a fast link
// NOTE that is is the largest single T.120 preallocated packet size.
//
#define DCS_MIN_FAST_COMPRESSABLE_PACKET        8192

//
// We will not try to persistently compress packets larger than this
//
#define DCS_MAX_PDC_COMPRESSABLE_PACKET         4096





//
// Frequency (ms) with which the core performs timer tasks
//
// VOLUME_SAMPLE is the time beyond which we will take another sample of
// the bounds accumulation data.  If the screendata accumulated in this
// time is less than BOUNDS_ACCUM then we will try and send it immediately
// otherwise we wait until the orders have slowed down.
//
// UPDATE_PERIOD is the absolute maximum time between attempts to send data
//
// ANIMATION_SLOWDOWN id how many times we attempt to send mem-scrn blits
// over a PSTN connection.
//
// ANIMATION_DETECTION the interval, in mS, below which we determine the
// app is performing animation.  Must be low otherwise we slowdown during
// rapid typing.  The algorithm simply looks for repeated memblts to the
// same area
//
// DCS_ORDERS_TURNOFF_FREQUENCY
// The frequency of orders above which we start time slicing order
// transmission in order to give the host system a chance to draw the
// orders without having to send them in individual network packets.
//
// DCS_BOUNDS_TURNOFF_RATE
// Very important for performance of typing in Word that this value is not
// too low, since Word can generate 50K per keystroke.  On the other hand,
// it is important not to allow the capture of screendata until after an
// app that does a lot of blitting to the screen has finished.
//
// DCS_BOUNDS_IMMEDIATE_RATE
// To avoid sending excessive amounts of screendata we only send at the
// most ten times per second.  However, if the volumes are small then we
// override this to reduce latency
//
//
// The other rates control individual timer functions - see adcsapi.c for
// further details
// Note that the IM period is less than the likely rate of this function
// being scheduled.  This is set low so that we will, in general, call IM
// periodic every time to keep mouse moves flowing, but it will not be
// called repeatedly if there are several wakeups pending within a single
// scheduling cycle.
//
//
#define DCS_VOLUME_SAMPLE                       500
#define DCS_BOUNDS_TURNOFF_RATE              400000
#define DCS_BOUNDS_IMMEDIATE_RATE            100000
#define DCS_ORDERS_TURNOFF_FREQUENCY            100
#define DCS_SD_UPDATE_SHORT_PERIOD              100
#define DCS_SD_UPDATE_LONG_PERIOD              5000
#define DCS_ORDER_UPDATE_PERIOD                 100
#define DCS_FAST_MISC_PERIOD                    200
#define DCS_IM_PERIOD                            80



//
// Special Messages to synchronize APIs etc.
//
#if defined(DLL_CORE) || defined(DLL_HOOK)

#define DCS_FIRST_MSG               WM_APP

enum
{
    DCS_FINISH_INIT_MSG             = DCS_FIRST_MSG,
    DCS_PERIODIC_SCHEDULE_MSG,
    DCS_KILLSHARE_MSG,
    DCS_SHAREDESKTOP_MSG,
    DCS_UNSHAREDESKTOP_MSG,
    DCS_TAKECONTROL_MSG,
    DCS_CANCELTAKECONTROL_MSG,
    DCS_RELEASECONTROL_MSG,
    DCS_PASSCONTROL_MSG,
    DCS_ALLOWCONTROL_MSG,
    DCS_GIVECONTROL_MSG,
    DCS_CANCELGIVECONTROL_MSG,
    DCS_REVOKECONTROL_MSG
};

#endif // DLL_CORE or DLL_HOOK



//
//
// PROTOTYPES
//
//


BOOL DCS_Init(void);
void DCS_FinishInit(void);
void DCS_Term(void);





//
// DCS_NotifyUI()
//
// DESCRIPTION:
// Called by app sharing to notify the front end of various changes and
// actions.
//
void DCS_NotifyUI(UINT event, UINT parm1, UINT parm2);


void DCSLocalDesktopSizeChanged( UINT width, UINT height );



#define DCS_MAIN_WINDOW_CLASS   "Salem_MainWindow"


LRESULT CALLBACK DCSMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);


#define SHP_SETTING_TRUECOLOR           0x0001


//
// EVENTS
//

enum
{
    SH_EVT_APPSHARE_READY = SPI_BASE_EVENT,
    SH_EVT_SHARE_STARTED,
    SH_EVT_SHARING_STARTED,
    SH_EVT_SHARE_ENDED,
    SH_EVT_PERSON_JOINED,
    SH_EVT_PERSON_LEFT,
    SH_EVT_CONTROLLABLE,
    SH_EVT_STARTCONTROLLED,
    SH_EVT_STOPCONTROLLED,
    SH_EVT_STARTINCONTROL,
    SH_EVT_STOPINCONTROL,
};


//
// Function PROTOTYPES
//



#if defined(DLL_CORE)

#include <ias.h>



HRESULT     SHP_GetPersonStatus(UINT dwID, IAS_PERSON_STATUS * pStatus);


BOOL        SHP_ShareDesktop(void);
HRESULT     SHP_UnshareDesktop(void);


//
// COLLABORATION
//
HRESULT     SHP_TakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_CancelTakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_ReleaseControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_PassControl(IAS_GCC_ID PersonOf, UINT PersonTo);

HRESULT     SHP_AllowControl(BOOL fAllow);
HRESULT     SHP_GiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_CancelGiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_RevokeControl(IAS_GCC_ID PersonTo);


void        DCS_ShareDesktop(void);
void        DCS_UnshareDesktop(void);

#endif // DLL_CORE



#endif // _H_DCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\control.h ===
//
// CONTROL.H
// Control by us, control of us
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CA
#define _H_CA


//
//
// CONSTANTS
//
//

#define CA_SEND_EVENT           0x0001
#define CA_ALLOW_EVENT          0x0002


//
// Cleanup flags
//
#define CACLEAR_HOST            0x0001
#define CACLEAR_VIEW            0x0002
#define CACLEAR_ALL             0x0003


//
// Queued responses to control requests.  We try to send them right away,
// but that can fail.  
// Here's the logic:
//      
// (1) For TAKING/RELEASING control (viewer)
//     There's only one at most pending.  That's because a pending RELEASE
//          cancels out a pending TAKE.  
//
// (2) For RESPONDING/REVOKING control (host)
//     These never cancel out.  Each one will have a successive sequence ID.
//          There should NEVER be a pending BOUNCE in the queue with a 
//          pending RESPOND for the same controller/request ID.  Of course not,
//          since we don't change our state until the packet goes out,
//          and if the RESPOND CONFIRM packet hasn't gone out, we wouldn't
//          be bouncing anybody.
//      
// Outgoing requests take precedence over incoming ones.  In other words,
// if the UI/user/SDK code asks us to take control of a remote, we will
// turn any pending RESPOND CONFIRM packets into RESPOND DENIED ones.  If
// we are in control of another already, take will fail, it's the intermediate
// phase that's undoable only.
//
// Here's the basic logic flow to TAKE CONTROL:
//      Viewer makes new sequence ID
//      Viewer sends private packet to host, requesting control
//      Viewer changes state to "asked for control"
//      Host receives private packet
//      Host sends private response packet to viewer, confirming or denying control
//      If confirming, host broadcasts notification to everybody sometime
//          later.
//      When viewer gets response, viewer moves to incontrol state, or
//          backs off
//
// Here's the basic logic flow to RELEASE CONTROL:
//      Viewer initiated:
//          Send INFORM RELEASED private packet to host
//          Change state to not in control
//          Host receives private packet
//          Host ignores if out of date (bounced already or whatever)
//          Host changes state to not controlled otherwise
//      Host initiated:
//          Send INFORM BOUNCED private packet to viewer
//          Change state to not controlled
//          Viewer receives private packet
//          Viewer ignores if out of date (released already or whatever)
//          Viewer changes state to not in control otherwise
//
// While pending take control, waiting to here confirmation, or in control
//      pending requests to control us are denied.
//


typedef union
{
    CA_RTC_PACKET       rtc;
    CA_REPLY_RTC_PACKET rrtc;
    CA_RGC_PACKET       rgc;
    CA_REPLY_RGC_PACKET rrgc;
    CA_PPC_PACKET       ppc;
    CA_INFORM_PACKET    inform;
}
CA30P;
typedef CA30P * PCA30P;

class ASPerson;

typedef struct tagCA30PENDING
{
    ASPerson *      pasReplyTo;
    UINT            mcsOrg;
    UINT            msg;
    CA30P           request;
}
CA30PENDING;
typedef CA30PENDING * PCA30PENDING;


typedef struct tagCA30XREQ
{
    CA30P           packet;
}
CA30REQ;


//
// Private send/responses get queued up and our state can NOT change until
// they go out.
//
typedef struct tagCAREQUEST
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    UINT            destID;
    UINT            msg;
    CA30REQ         req30;
}
CAREQUEST;
typedef CAREQUEST * PCAREQUEST;


//
// The location of the keyboard language toggle hotkey setting in the
// registry.
//
#define LANGUAGE_TOGGLE_KEY     "keyboard layout\\toggle"
#define LANGUAGE_TOGGLE_KEY_VAL "Hotkey"

//
// A value we use to indicate that the registry entry is not present - it
// could be any value except for '1', '2', or '3'
//
#define LANGUAGE_TOGGLE_NOT_PRESENT   0


//
// Query dialog
//

#define IDT_CAQUERY         50
#define PERIOD_CAQUERY      30000   // 30 seconds

INT_PTR CALLBACK CAQueryDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_CA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\dcg.h ===
//
// DC Groupware Common stuff
//

#ifndef _H_DCG
#define _H_DCG



#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <memory.h>

#ifdef DLL_DISP

#ifdef IS_16
//
// Win16 Display Driver
//
#define STRICT
#define UNALIGNED
#include <windows.h>
#include <windowsx.h>
#include <winddi.h>


#define abs(A)  (((A) < 0)? -(A) : (A))

#define FIELD_OFFSET(type, field)       FIELDOFFSET(type, field)

#else

//
// Windows NT DDK include files (used to replace standard windows.h)       
//                                                                         
// The display driver runs in the Kernel space and so MUST NOT access any  
// Win32 functions or data.  Instead we can only use the Win32k functions  
// as described in the DDK.                                                
//
// NOTE ALSO:  OUR DRIVER MUST WORK ON NT4 AND WIN2K, so we use NT4 
// versions of headers.
//
#include <ntddk.h>
#include <windef.h>
#include <wingdi.h>
#include <ntddvd40.h>
#include <winddi40.h>

#endif // IS_16


// Debugging Macros
#include <drvdbg.h>


#else

#ifndef STRICT
#define STRICT
#endif

#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <winable.h>


#include <mlzdbg.h> // multi-level zone debug header file
#include <memtrack.h>
#include <strutil.h>

#endif // DLL_DISP


//
// DC_DATA macros to generate extern declarations.
// NOTE:  Keep this section in ssync with datainit.h, the header included
// by a file to actually generate storage for variables declared using the
// DC_DATA macros
//


#define DC_DATA(TYPE, Name) \
            extern TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            extern TYPE Name

#define DC_CONST_DATA(TYPE, Name, Value) \
            extern const TYPE Name


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            extern TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            extern const TYPE Name[Size]


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            extern TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            extern const TYPE Name[Size1][Size2]



typedef UINT FAR*       LPUINT;


typedef UINT                        MCSID;
#define MCSID_NULL                  ((MCSID)0)


//
// T.128 PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


#include <t_share.h>



//
// Defines the maximum number of BYTES allowed in a translated "shared by "
// string.                                                                 
//
#define DC_MAX_SHARED_BY_BUFFER     64
#define DC_MAX_SHAREDDESKTOP_BUFFER 64


//
// Registry prefix.                                                        
//
#define DC_REG_PREFIX             TEXT("SOFTWARE\\Microsoft\\Conferencing\\AppSharing\\")

//
// Limits                                                                  
//
#define MAX_TSHR_UINT16                 65535


//
// Return codes
//
#define UT_BASE_RC                     0x0000

#define OM_BASE_RC                     0x0200
#define OM_LAST_RC                     0x02FF

#define WB_BASE_RC                     0x0300
#define WB_LAST_RC                     0x03FF

#define NET_BASE_RC                    0x0700
#define NET_LAST_RC                    0x07FF

#define CM_BASE_RC                     0x0800
#define CM_LAST_RC                     0x08FF

#define AL_BASE_RC                     0x0a00
#define AL_LAST_RC                     0x0aFF


//
// Events                                                                  
// ======                                                                  
// This section lists the ranges available for each component when defining
// its events.  A component must not define events outside its permitted   
// range.                                                                  
//
#define UT_BASE_EVENT        (0x0600)   // Utility service events
#define UT_LAST_EVENT        (0x06FF)   // are in this range     

#define OM_BASE_EVENT        (0x0700)   // Object Manager events 
#define OM_LAST_EVENT        (0x07FF)   // are in this range     

#define NET_BASE_EVENT       (0x0800)   // Network layer events  
#define NET_LAST_EVENT       (0x08FF)   // are in this range     

#define CM_BASE_EVENT        (0x0900)   // Call Manager events   
#define CM_LAST_EVENT        (0x09FF)   // are in this range     

#define AL_BASE_EVENT        (0x0A00)   // Application Loader evts
#define AL_LAST_EVENT        (0x0AFF)   // are in this range     

#define SPI_BASE_EVENT       (0x0B00)   // SPI event numbers     
#define SPI_LAST_EVENT       (0x0BFF)

#define S20_BASE_EVENT       (0x0C00)   // S20 event numbers     
#define S20_LAST_EVENT       (0x0CFF)

//
// NOTE:  Keep this above WM_USER; WB reposts the events using the event
// as the message.  So it CANNOT conflict with an existing Win message.
//
#define WB_BASE_EVENT        (0x0D00)   // Whiteboard events     
#define WB_LAST_EVENT        (0x0DFF)   // are in this range     

#define SC_BASE_EVENT        (0x0E00)   // SC event numbers      
#define SC_LAST_EVENT        (0x0EFF)


#define DBG_INI_SECTION_NAME            "Debug"


//
// The GCC channel keys used with MG_ChannelJoinByKey.  They must be      
// unique.                                                                 
//                                                                         
// SFR6043: Modified these values from 41-43 to 421-423.  These values now 
// represent the default static channel numbers used.                      
//                                                                         
// FT (potentially) uses all key numbers in the range 600-1100.  If you add
// a new channel key, do not use a number in that range.                   
//
#define GCC_OBMAN_CHANNEL_KEY       421
#define GCC_AS_CHANNEL_KEY          422

//
// GCC Token keys                                                          
//
#define GCC_OBMAN_TOKEN_KEY         500



//
//                                                                         
// MACROS                                                                  
//                                                                         
//

#define DC_QUIT                        goto DC_EXIT_POINT


//
// DEBUG structure type stamps, to help us track memory leaks
//
#ifdef _DEBUG

typedef struct tagDBGSTAMP
{
    char    idStamp[8];
}
DBGSTAMP;

#define STRUCTURE_STAMP                 DBGSTAMP    stamp;
#define SET_STAMP(lpv, st)              lstrcpyn((lpv)->stamp.idStamp, "AS"#st, sizeof(DBGSTAMP))

#else

#define STRUCTURE_STAMP
#define SET_STAMP(lpv, st)

#endif // _DEBUG

//
// Cousin of the the FIELD macros supplied by 16-bit windows.h.       
//
#define FIELD_SIZE(type, field)   (sizeof(((type FAR *)0L)->field))


//
// Macro to round up a number to the nearest multiple of four.             
//
#define DC_ROUND_UP_4(x)  (((x) + 3L) & ~(3L))


//
// Unaligned pointer access macros -- first macros to extract an integer   
// from an UNALIGNED pointer.  Note that these macros assume that the      
// integer is in local byte order                                          
//
#ifndef DC_NO_UNALIGNED

#define EXTRACT_TSHR_UINT16_UA(pA)      (*(LPTSHR_UINT16_UA)(pA))
#define EXTRACT_TSHR_INT16_UA(pA)       (*(LPTSHR_INT16_UA)(pA))
#define EXTRACT_TSHR_UINT32_UA(pA)      (*(LPTSHR_UINT32_UA)(pA))
#define EXTRACT_TSHR_INT32_UA(pA)       (*(LPTSHR_INT32_UA)(pA))

#define INSERT_TSHR_UINT16_UA(pA,V)     (*(LPTSHR_UINT16_UA)(pA)) = (V)
#define INSERT_TSHR_INT16_UA(pA,V)      (*(LPTSHR_INT16_UA)(pA)) = (V)
#define INSERT_TSHR_UINT32_UA(pA,V)     (*(LPTSHR_UINT32_UA)(pA)) = (V)
#define INSERT_TSHR_INT32_UA(pA,V)      (*(LPTSHR_INT32_UA)(pA)) = (V)

#else

#define EXTRACT_TSHR_UINT16_UA(pA) ((TSHR_UINT16)  (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_UINT16) ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_INT16_UA(pA)  ((TSHR_INT16)   (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_INT16)  ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_UINT32_UA(pA) ((TSHR_UINT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[3]) << 24) )

#define EXTRACT_TSHR_INT32_UA(pA)  ((TSHR_INT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[3]) << 24) )


#define INSERT_TSHR_UINT16_UA(pA,V)                                     \
             {                                                          \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)     & 0x00FF);  \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8) & 0x00FF);  \
             }
#define INSERT_TSHR_INT16_UA(pA,V)  INSERT_TSHR_UINT16_UA(pA,V)

#define INSERT_TSHR_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)      & 0x000000FF); \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8)  & 0x000000FF); \
                 (((LPBYTE)(pA))[2]) = (BYTE)(((V)>>16) & 0x000000FF); \
                 (((LPBYTE)(pA))[3]) = (BYTE)(((V)>>24) & 0x000000FF); \
             }
#define INSERT_TSHR_INT32_UA(pA,V)  INSERT_TSHR_UINT32_UA(pA,V)


#endif




//
// Stamp type and macro: each module should use these when stamping its    
// data structures.                                                        
//
typedef TSHR_UINT32                       DC_ID_STAMP;

#define DC_MAKE_ID_STAMP(X1, X2, X3, X4)                                    \
   ((DC_ID_STAMP) (((DC_ID_STAMP) X4) << 24) |                                 \
                  (((DC_ID_STAMP) X3) << 16) |                                 \
                  (((DC_ID_STAMP) X2) <<  8) |                                 \
                  (((DC_ID_STAMP) X1) <<  0) )


//
// BOGUS LAURABU!
// COM_SIZEOF_RECT() was the old name of COM_SIZEOF_RECT_EXCLUSIVE(). But
// it was being used in the display driver on INCLUSIVE rects.  I fixed this,
// I changed it to use COM_SIZEOF_RECT_INCLUSIVE.  But this may uncover 
// other bugs.  The reason I found this--my 16-bit display driver generates
// no orders yet, all the DDI calls just add screen data.  So each little
// patblted strip, one pixel wide/high, gets sent via draw bounds as screen
// data.
//

__inline DWORD COM_SizeOfRectInclusive(LPRECT prc)
{
    return((DWORD)(prc->right+1-prc->left) * (DWORD)(prc->bottom+1-prc->top));
}

__inline DWORD COM_SizeOfRectExclusive(LPRECT prc)
{
    return((DWORD)(prc->right-prc->left) * (DWORD)(prc->bottom-prc->top));
}


//
// NORMAL rect<->rectl conversions
//
__inline void RECTL_TO_RECT(const RECTL FAR* lprclSrc, LPRECT lprcDst)
{
    lprcDst->left = lprclSrc->left;
    lprcDst->top = lprclSrc->top;
    lprcDst->right = lprclSrc->right;
    lprcDst->bottom = lprclSrc->bottom;
}


__inline void RECT_TO_RECTL(const RECT FAR* lprcSrc, LPRECTL lprclDst)
{
    lprclDst->left = lprcSrc->left;
    lprclDst->top = lprcSrc->top;
    lprclDst->right = lprcSrc->right;
    lprclDst->bottom = lprcSrc->bottom;
}


//
// This macro works on 32 bit unsigned ticks and returns TRUE if TIME is   
// between BEGIN and END (both inclusive) allowing for the wraparound.     
//
#define IN_TIME_RANGE(BEGIN, END, TIME)                                     \
    (((BEGIN) < (END)) ?                                                    \
    (((TIME) >= (BEGIN)) && ((TIME) <= (END))) :                            \
    (((TIME) >= (BEGIN)) || ((TIME) <= (END))))


//
// Convert BPP to number of colors.                                        
//
#define COLORS_FOR_BPP(BPP) (((BPP) > 8) ? 0 : (1 << (BPP)))


#define MAX_ITOA_LENGTH     18


#endif // _H_DCG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\gdc.h ===
//
// General Data Compression
//

#ifndef _H_GDC
#define _H_GDC


//
//
// CONSTANTS
//
//


//
// Scratch buffer mutex
//
#define GDC_MUTEX_NAME "GDCMutex"


//
// Compression Types (bit flags)
//
#define GCT_NOCOMPRESSION    0x0000
#define GCT_PKZIP            0x0001
#define GCT_PERSIST_PKZIP    0x0002
#define GCT_DEFAULT          (GCT_PKZIP | GCT_PERSIST_PKZIP)

//
// Compression Options for GCT_PKZIP
//
#define GDCCO_MAXSPEED        0
#define GDCCO_MAXCOMPRESSION  1



//
// Data sizes used to determine the saved dictionary space in our work 
// buffer.
//
#define GDC_DATA_SMALL          1024
#define GDC_DATA_MEDIUM         2048
#define GDC_DATA_MAX            4096


//
// Persistent Dictionaries used for compression/decompression
//
enum
{
    GDC_DICT_UPDATES = 0,
    GDC_DICT_MISC,
    GDC_DICT_INPUT,
    GDC_DICT_COUNT
};


typedef struct tagGDC_DICTIONARY
{
    UINT        cbUsed;                     // Amount of saved data
    BYTE        pData[GDC_DATA_MAX];      // Saved uncompressed data
} GDC_DICTIONARY;
typedef GDC_DICTIONARY * PGDC_DICTIONARY;


//
// Byte runs that can be replaced with smaller bit sequences
//
#define GDC_MINREP              2
#define GDC_MAXREP              (GDC_MINREP+(8*1)+2+4+8+16+32+64+128+256-4)
// GDC_MAXREP is 516, 129*4


//
// Holds uncompressed data for both compression/decompression
//
#define GDC_UNCOMPRESSED        (GDC_MAXREP + 2*GDC_DATA_MAX)

// 
// We don't need to double-buffer compressed data--we just read it out
// of the caller's source or write it into the caller's dest directly.
//
// NOTE:  With real PKZIP, which mostly reads from/writes to files,
// they don't have memory pointers containing raw data already.  That's
// whe original code we got used Read/Write routine callbacks.  This is
// no longer necessary.
//



//
// Random, little understood PKZIP table values, codes
//
#define KMP_THRESHOLD       10


#define GDC_LIT_SIZE        (256 + GDC_MAXREP + 2) 
// GDC_LIT_SIZE is 774


// EOF is last index of Lit array
#define EOF_CODE            (GDC_LIT_SIZE-1)
#define ABORT_CODE          (EOF_CODE+1)


//
// EXT_DIST_BITS is the # of bits needed to store an index into a GDC_DIST_SIZE
// array.  That's defined to be 64, which is 2^6, hence 6 bits.  Smaller
// dictionary compressions use fewer bits and hence not all of the DIST
// items.  The mask
// is used to pull the 6-bit sized index out of a byte.
//
#define GDC_DIST_SIZE               64

#define EXT_DIST_BITS_MIN           4
#define EXT_DIST_BITS_MEDIUM        5
#define EXT_DIST_BITS_MAC           6


#define GDC_LEN_SIZE                16
#define GDC_DECODED_SIZE            256


//
// The hash function has 4*256+5*256 different values, which means
// we need that many entries in our hash array.
//
#define GDC_HASHFN(x)               (4*(x)[0] + 5*(x)[1])
#define GDC_HASH_SIZE               (4*256 + 5*256)





//
// Structure:   GDC_IMPLODE
//
// Workspace for compressing our data.  We have simplified and shrunk this
// structure a fair amount, by having constant code/bit tables and not
// double-buffering the compressed result.  PKZIP's implode calculates the
// LitBits & LitCodes every time through (rather than storing 2 774 byte
// arrays in data--which would be a pain to declare anyway!), and makes a 
// private copy of the DistBits & DistCodes.  
//

typedef struct tagGDC_IMPLODE
{
    //
    // NO SOURCE INFO--we copy source chunks and maybe dictionary into 
    // RawData.  Then at the end we copy RawData back into the dictionary
    // if there is one.
    //

    //
    // Destination info
    //
    LPBYTE              pDst;       // Current Dest ptr (advances as we write)
    UINT                cbDst;      // Amount of Dest left (shrinks as we write)
    UINT                iDstBit;    // Current bit pos in Current Dest ptr byte

    //
    // Compression info
    //
    UINT                cbDictSize;
    UINT                cbDictUsed;
    UINT                ExtDistBits;
    UINT                ExtDistMask;

    //
    // Working info
    //
    UINT                Distance;            
    UINT                ibRawData;

    // NOTE: GDC_UNCOMPRESSED is a multiple of 4
    BYTE                RawData[GDC_UNCOMPRESSED];

    // NOTE:  This is DWORD aligned (GDC_MAXREP is a multiple of 4
    // and the extra 2 WORDS == 1 DWORD
    short               Next[2 + GDC_MAXREP];

    // NOTE: GDC_UNCOMPRESED is a multiple of 4
    WORD                SortArray[GDC_UNCOMPRESSED];

    // NOTE: This is DWORD aligned since GDC_HASH_SIZE is a multiple of 4
    WORD                HashArray[GDC_HASH_SIZE];
} GDC_IMPLODE, * PGDC_IMPLODE;



//
// GDC_EXPLODE
// Workspace for uncompressing our data.  We have vastly simplified and
// shrunk this structure as per the comments for GDC_IMPLODE.
//

typedef struct tagGDC_EXPLODE
{
    //
    // Source info
    //
    LPBYTE              pSrc;       // Current Src ptr (advances as we read)
    UINT                cbSrc;      // Amount of Src left (shrinks as we read)
    UINT                SrcByte;    // Look ahead byte in source
    UINT                SrcBits;    // Remainded src bits

    //
    // NO DEST INFO--we copy maybe dictionary into RawData at the beginning.
    // Then at the end we maybe copy RawData back into the dictionary.
    //

    //
    // Compression info
    //
    UINT                ExtDistBits;
    UINT                ExtDistMask;
    UINT                cbDictUsed;

    UINT                Distance;   
    UINT                iRawData;   // Current index into RawData
    BYTE                RawData[GDC_UNCOMPRESSED];
} GDC_EXPLODE, *PGDC_EXPLODE;


#define GDC_WORKBUF_SIZE    max(sizeof(GDC_IMPLODE), sizeof(GDC_EXPLODE))



//
// EXTERNAL FUNCTIONS
//

//
// API FUNCTION: GDC_Init()
//
// DESCRIPTION:
//
// Initialises the General Data Compressor.
// Must be called before any other GDC functions.
//
// PARAMETERS:
//
//
//
void GDC_Init(void);



//
// FUNCTION: GDC_Compress(..)
//
// DESCRIPTION:
//
// Compresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, valid ptr if persistent
//
// Options                  - specifies whether speed of compression or
//      size of the compressed data is the most important factor.  This
//      basically affects the amount of previous data saved for looking
//      backwards.  MAXSPEED means smaller dictionary.  MAXCOMPRESSION
//      means a bigger one.  The dictionary size is basically the amount
//      of overlap in the source data used when calculating the hash
//      index.
//
//   GDCCO_MAXSPEED         - compress the data as quickly as possible, at
//                            the expense of increased compressed data size
//
//   GDCCO_MAXCOMPRESSION   - compress the data as much as possible, at the
//                            expense of increased compression time.
// With a persistent dictionary, only GDCCO_MAXCOMPRESSION is meaningful.
//
// pSrc                     - pointer to the source (uncompressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            compressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the destina-
//                            tion can hold.  If the compressed result ends
//                            up being bigger than this amount, we bail
//                            out and don't compress the source at all.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.
//
//
BOOL GDC_Compress
(
    PGDC_DICTIONARY     pDictionary,
    UINT                Options,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);


//
// API FUNCTION: GDC_Decompress(..)
//
// DESCRIPTION:
//
// Decompresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, ptr to saved data if
//                            persistent.
//
// pSrc                     - pointer to the source (compressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            uncompressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the desina-
//                            tion can hold.  If the uncompressed result
//                            ends up being bigger than this amount, we
//                            bail out since we can't decompress it.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.

//
BOOL GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);




//
// INTERNAL FUNCTIONS
//


void GDCCalcDecode(const BYTE * pBits, const BYTE * pCodes, UINT size, LPBYTE pDecode);

LPBYTE GDCGetWorkBuf(void);
void   GDCReleaseWorkBuf(LPBYTE);


UINT GDCFindRep(PGDC_IMPLODE pgdcImp, LPBYTE Start);

void GDCSortBuffer(PGDC_IMPLODE pgdcImp, LPBYTE low, LPBYTE hi);

BOOL GDCOutputBits(PGDC_IMPLODE pgdcImp, WORD Cnt, WORD Code);



UINT GDCDecodeLit(PGDC_EXPLODE);

UINT GDCDecodeDist(PGDC_EXPLODE pgdcExp, UINT Len);

BOOL GDCWasteBits(PGDC_EXPLODE pgdcExp, UINT Bits);


#endif // _H_GDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\host.h ===
//
// Hosting (local or remote)
//

#ifndef _H_HET
#define _H_HET



//
// DC-Share includes
//
#include <osi.h>




BOOL    HET_Init(void);
void    HET_Term(void);


#if defined(DLL_CORE)


typedef struct tagGUIEFFECTS
{
    BOOL            hetAdvanced;
    BOOL            hetCursorShadow;
    ANIMATIONINFO   hetAnimation;
}
GUIEFFECTS;

void  HET_SetGUIEffects(BOOL fOn, GUIEFFECTS * pEffects);


#endif // DLL_CORE or DLL_HOOK


//
// Define escape codes
//

// These are normal
enum
{
    // These are normal
    HET_ESC_SHARE_DESKTOP       = OSI_HET_ESC_FIRST,
    HET_ESC_UNSHARE_DESKTOP,
    HET_ESC_VIEWER
};


// These are WNDOBJ_SETUP
enum
{
    HET_ESC_SHARE_WINDOW = OSI_HET_WO_ESC_FIRST,
    HET_ESC_UNSHARE_WINDOW,
    HET_ESC_UNSHARE_ALL
};



//
// Structure passed with a HET_ESC_SHARE_WINDOW request
//
typedef struct tagHET_SHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD               winID;          // window to share
    DWORD               result;         // Return code from HET_DDShareWindow
}
HET_SHARE_WINDOW;
typedef HET_SHARE_WINDOW FAR * LPHET_SHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_WINDOW request
//
typedef struct tagHET_UNSHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD               winID;          // window to unshare
}
HET_UNSHARE_WINDOW;
typedef HET_UNSHARE_WINDOW FAR * LPHET_UNSHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_ALL request
//
typedef struct tagHET_UNSHARE_ALL
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_ALL;
typedef HET_UNSHARE_ALL FAR * LPHET_UNSHARE_ALL;


//
// Structure passed with HET_ESC_SHARE_DESKTOP
//
typedef struct tagHET_SHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_SHARE_DESKTOP;
typedef HET_SHARE_DESKTOP FAR * LPHET_SHARE_DESKTOP;


//
// Structure passed with HET_ESC_UNSHARE_DESKTOP
//
typedef struct tagHET_UNSHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_DESKTOP;
typedef HET_UNSHARE_DESKTOP FAR * LPHET_UNSHARE_DESKTOP;


//
// Structure passed with HET_ESC_VIEWER
//
typedef struct tagHET_VIEWER
{
    OSI_ESCAPE_HEADER   header;
    LONG                viewersPresent;
}
HET_VIEWER;
typedef HET_VIEWER FAR * LPHET_VIEWER;



#ifdef DLL_DISP

#ifndef IS_16
//
// Number of rectangles allocated per window structure.  If a visible
// region exceeds that number, we will merge rects together and end up
// trapping a bit more output than necessary.
//
#define HET_WINDOW_RECTS        10


//
// HET's version of ENUMRECTS.  This is the same as Windows', except that
// it has HET_WINDOW_RECTS rectangles, not 1
//
typedef struct tagHET_ENUM_RECTS
{
    ULONG   c;                          // count of rectangles in use
    RECTL   arcl[HET_WINDOW_RECTS];     // rectangles
} HET_ENUM_RECTS;
typedef HET_ENUM_RECTS FAR * LPHET_ENUM_RECTS;

//
// The Window Structure kept for each tracked window
//
typedef struct tagHET_WINDOW_STRUCT
{
    BASEDLIST           chain;             // list chaining info
    HWND             hwnd;              // hwnd of this window
    WNDOBJ         * wndobj;            // WNDOBJ for this window
    HET_ENUM_RECTS   rects;             // rectangles
} HET_WINDOW_STRUCT;
typedef HET_WINDOW_STRUCT FAR * LPHET_WINDOW_STRUCT;


//
// Initial number of windows for which space is allocated
// We alloc about 1 page for each block of windows.  Need to account for
// the BASEDLIST at the front of HET_WINDOW_MEMORY.
//
#define HET_WINDOW_COUNT        ((0x1000 - sizeof(BASEDLIST)) / sizeof(HET_WINDOW_STRUCT))


//
// Layout of memory ued to hold window structures
//
typedef struct tagHET_WINDOW_MEMORY
{
    BASEDLIST              chain;
    HET_WINDOW_STRUCT   wnd[HET_WINDOW_COUNT];
} HET_WINDOW_MEMORY;
typedef HET_WINDOW_MEMORY FAR * LPHET_WINDOW_MEMORY;

#endif // !IS_16



#ifdef IS_16

void    HETDDViewing(BOOL fViewers);

#else

void    HETDDViewing(SURFOBJ *pso, BOOL fViewers);

BOOL    HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq);
void    HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq);
void    HETDDUnshareAll(void);

BOOL    HETDDAllocWndMem(void);
void    HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd);

VOID CALLBACK HETDDVisRgnCallback(WNDOBJ *pwo, FLONG fl);
#endif


#endif // DLL_DISP


#ifdef DLL_DISP

//
// INIT, TERM.  TERM is used to free the window list blocks when NetMeeting
// shuts down.  Otherwise that memory will stay allocated in the display
// driver forever.
//

void HET_DDTerm(void);


//
//
// Name:        HET_DDProcessRequest
//
// Description: Handle a DrvEscape request for HET
//
// Params:      pso   - pointer to a SURFOBJ
//              cjIn  - size of input buffer
//              pvIn  - input buffer
//              cjOut - size of output buffer
//              pvOut - output buffer
//
//
#ifdef IS_16

BOOL    HET_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

#else

ULONG   HET_DDProcessRequest(SURFOBJ  *pso,
                                        UINT cjIn,
                                        void *  pvIn,
                                        UINT cjOut,
                                        void *  pvOut);
#endif // IS_16


#endif // DLL_DISP



#endif // _H_HET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\im.h ===
//
// Input Manager
//

#ifndef _H_IM
#define _H_IM


#if defined(DLL_CORE) || defined(DLL_HOOK)

//
//
// CONSTANTS
//
//


//
// Values used when accumulating events to return from IEM_TranslateLocal
// and IEM_TranslateRemote.
//
#define IEM_EVENT_CTRL_DOWN         1
#define IEM_EVENT_CTRL_UP           2
#define IEM_EVENT_SHIFT_DOWN        3
#define IEM_EVENT_SHIFT_UP          4
#define IEM_EVENT_MENU_DOWN         5
#define IEM_EVENT_MENU_UP           6
#define IEM_EVENT_FORWARD           7
#define IEM_EVENT_CONSUMED          8
#define IEM_EVENT_REPLAY            9
#define IEM_EVENT_REPLAY_VK         10
#define IEM_EVENT_REPLAY_VK_DOWN    11
#define IEM_EVENT_REPLAY_VK_UP      12
#define IEM_EVENT_CAPS_LOCK_UP      13
#define IEM_EVENT_CAPS_LOCK_DOWN    14
#define IEM_EVENT_NUM_LOCK_UP       15
#define IEM_EVENT_NUM_LOCK_DOWN     16
#define IEM_EVENT_SCROLL_LOCK_UP    17
#define IEM_EVENT_SCROLL_LOCK_DOWN  18
#define IEM_EVENT_REPLAY_SPECIAL_VK 21
#define IEM_EVENT_EXTENDED_KEY      22
#define IEM_EVENT_REPLAY_SECONDARY  23
#define IEM_EVENT_SYSTEM            24
#define IEM_EVENT_NORMAL            25

#define IEM_EVENT_HOTKEY_BASE       50
//
// Range of hotkeys is 0 - 99
//
#define IEM_EVENT_KEYPAD0_DOWN      150
//
// Range of keypad down is 0-9
//
#define IEM_EVENT_KEYPAD0_UP        160

//
// The flags used in the return value from VkKeyScan.
//
#define IEM_SHIFT_DOWN              0x0001
#define IEM_CTRL_DOWN               0x0002
#define IEM_MENU_DOWN               0x0004


//
// Virtual key codes.
//
#define VK_INVALID      0xFF


//
// Given the keyboard packet flags the following macros tell us things
// about the key event.
//

//
// This is TRUE if this event is a key press.  It is FALSE for key releases
// and key repeats.
//
#define IS_IM_KEY_PRESS(A) \
(((A) & (TSHR_UINT16)(IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==0)

//
// This is TRUE if this event is a key release.  It is FALSE for key
// presses and key repeats.  Note that it is also TRUE for the
// theoretically impossible case of a key release when the key is already
// up (this combination could conceviably be generated if events are
// discarded by USER or our emulation of USER).
//
#define IS_IM_KEY_RELEASE(A) (((A) & IM_FLAG_KEYBOARD_RELEASE))

//
// This is TRUE if this event is a key repeat.  It is FALSE for key presses
// and key releases.
//
#define IS_IM_KEY_REPEAT(A) \
(((A) & (IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==\
IM_FLAG_KEYBOARD_DOWN)

//
// This is TRUE if the key is the right-variant of a modifier.  It is FALSE
// otherwise.
//
#define IS_IM_KEY_RIGHT(A) (((A) & IM_FLAG_KEYBOARD_RIGHT))


//
// The maximum amount of time that we expect an injected event to take to
// pass through USER.
//
#define IM_EVENT_PERCOLATE_TIME 300

//
// Max VK sync attempts.
//
#define IM_MAX_VK_SYNC_ATTEMPTS     10

//
// Declare our function prototype for <ImmGetVirtualKey>.
//
typedef UINT (WINAPI* IMMGVK)(HWND);



//
//
// MACROS
//
//
//
// Macros to convert between logical mouse co-ordinates (e.g. (320,240) for
// the centre of a VGA screen to the full 16-bit range co-ordinates used
// by Windows (e.g. (320,240) is (32767, 32767).
//
#define IM_MOUSEPOS_LOG_TO_OS(coord, size)                                  \
        (((65535L * (TSHR_UINT32)coord) + 32768L) / (TSHR_UINT32)size)

//
// Macros extracting information from the mouse event flags field (event
// mask).
//
#define IM_MEV_MOVE_ONLY(e) ((e).event.mouse.flags == MOUSEEVENTF_MOVE)
#define IM_MEV_MOVE(e) (((e).event.mouse.flags & MOUSEEVENTF_MOVE) != 0 )
#define IM_MEV_ABS_MOVE(e) (((e).event.mouse.flags &                   \
                 (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) ==             \
                             (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) ))
#define IM_MEV_BUTTON_DOWN(e) \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS) != 0 )
#define IM_MEV_BUTTON_UP(e)   \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS) != 0 )

#define IM_EVMASK_B1_DOWN(m) (((m) & MOUSEEVENTF_LEFTDOWN)   != 0 )
#define IM_EVMASK_B1_UP(m)   (((m) & MOUSEEVENTF_LEFTUP)     != 0 )
#define IM_EVMASK_B2_DOWN(m) (((m) & MOUSEEVENTF_RIGHTDOWN)  != 0 )
#define IM_EVMASK_B2_UP(m)   (((m) & MOUSEEVENTF_RIGHTUP)    != 0 )
#define IM_EVMASK_B3_DOWN(m) (((m) & MOUSEEVENTF_MIDDLEDOWN) != 0 )
#define IM_EVMASK_B3_UP(m)   (((m) & MOUSEEVENTF_MIDDLEUP)   != 0 )

#define IM_MEV_BUTTON1_DOWN(e) (IM_EVMASK_B1_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON2_DOWN(e) (IM_EVMASK_B2_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON3_DOWN(e) (IM_EVMASK_B3_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON1_UP(e) (IM_EVMASK_B1_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON2_UP(e) (IM_EVMASK_B2_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON3_UP(e) (IM_EVMASK_B3_UP((e).event.mouse.flags))

#define IM_KEV_KEYUP(e)    ((e).event.keyboard.flags & KEYEVENTF_KEYUP)
#define IM_KEV_KEYDOWN(e)  (!IM_KEV_KEYUP(e))
#define IM_KEV_VKCODE(e)   ((e).event.keyboard.vkCode)

#define IM_MOUSEEVENTF_BASE_FLAGS  ( MOUSEEVENTF_MOVE       | \
                                     MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_CLICK_FLAGS ( MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )


#define IM_MOUSEEVENTF_BUTTONDOWN_FLAGS ( MOUSEEVENTF_LEFTDOWN  |   \
                                          MOUSEEVENTF_RIGHTDOWN |   \
                                          MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_BUTTONUP_FLAGS ( MOUSEEVENTF_LEFTUP  |   \
                                        MOUSEEVENTF_RIGHTUP |   \
                                        MOUSEEVENTF_MIDDLEUP )



typedef struct tagKBDEV
{
    WORD    vkCode;
    WORD    scanCode;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
KBDEV, FAR *LPKBDEV;


typedef struct tagMSEV
{
    POINTL  pt;
    DWORD   cButtons;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
MSEV, FAR *LPMSEV;


//
// The IMOSEVENTS which we queue as they arrive from the mouse or
// keyboard hooks or after IMINCOMINGEVENTS have been translated into local
// events by the IEM.
//
typedef struct tagIMOSEVENT
{
    TSHR_UINT32      type;
        #define IM_MOUSE_EVENT      1
        #define IM_KEYBOARD_EVENT   2

    TSHR_UINT32      flags;
        #define IM_FLAG_DONT_REPLAY     0x0001
        #define IM_FLAG_UPDATESTATE     0x0002

    TSHR_UINT32     time;
    union
    {
        MSEV    mouse;
        KBDEV   keyboard;
    }
    event;
}
IMOSEVENT;
typedef IMOSEVENT FAR * LPIMOSEVENT;




#define IM_TRANSFER_EVENT_BUFFER_SIZE   32
#define IM_MAX_TRANSFER_EVENT_INDEX     (IM_TRANSFER_EVENT_BUFFER_SIZE-1)


typedef struct tagIMTRANSFEREVENT
{
    LONG        fInUse;
    IMOSEVENT   event;
}
IMTRANSFEREVENT, FAR * LPIMTRANSFEREVENT;



//
// For handling keyboard events in hooks
//
#define IM_MASK_KEYBOARD_SYSFLAGS           0xE100
#define IM_MASK_KEYBOARD_SYSSCANCODE        0x00FF

#define IM_MAX_DEAD_KEYS                    20

#define IM_SIZE_EVENTQ                      40
#define IM_SIZE_OSQ                         80  // 2*EVENTQ size - key up/down

//
// Define the flags that can be returned by IMConvertIMPacketToOSEvent().
//
#define IM_IMQUEUEREMOVE    0x0001
#define IM_OSQUEUEINJECT    0x0002

//
// For managing our key state arrays.
//
#define IM_KEY_STATE_FLAG_TOGGLE    (BYTE)0x01
#define IM_KEY_STATE_FLAG_DOWN      (BYTE)0x80

//
// Bounds for local mouse spoiling and packet piggyback target withhold
// Note that these are local spoiling values, to prevent the data pipe from
// getting clogged and introducing unnecessary latency.  Now, you may think
// that 30 move messages per second is a little low, but put this up any
// higher and USER at the other end will just spoil them when it injects
// them into the app - that would be totally wasteful of precious bandwidth.
//
#define IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS    100
#define IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS  75
#define IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS    50
#define IM_LOCAL_WITHHOLD_DELAY               150
#define IM_LOCAL_MOUSE_WITHHOLD                 5
#define IM_LOCAL_KEYBOARD_WITHHOLD              2

//
// For pacing the accumulation and injecting of mouse events.
// We should play back at the same rate as the highest local sampling rate
// less a small amount for processing delay on the remote system
//
#define IM_REMOTE_MOUSE_PLAYBACK_GAP_MS     20

//
// The amount of time to hold on to a mouse button down event in case a the
// user is just clicking on eg a scroll button.  If we did not hold on to
// the mouse button down event then the mouse button up would be sent in
// the next packet.  On a slow network this means the remote application
// may process the down period for much longer than the user wanted.
//
#define IM_MOUSE_UP_WAIT_TIME  50

#define IM_MIN_RECONVERSION_INTERVAL_MS     150


//
// #define used non-Windows to flag a VK code that equates to an ascii char
//
#define IM_TYPE_VK_ASCII       ((TSHR_UINT16)0x8880)


//
// Used for checking events about to be injected.
//
#define IM_KEY_IS_TOGGLE(A) \
(((A)==VK_CAPITAL)||((A)==VK_SCROLL)||((A)==VK_NUMLOCK))

#define IM_KEY_IS_MODIFIER(A) \
(((A)==VK_SHIFT)||((A)==VK_CONTROL)||((A)==VK_MENU))

//
// Used to check values in key state arrays.
//
#define IM_KEY_STATE_IS_UP(A) (!((A)&IM_KEY_STATE_FLAG_DOWN))
#define IM_KEY_STATE_IS_DOWN(A) ((A)&IM_KEY_STATE_FLAG_DOWN)

//
// Used to determine what sort of mouse event this is from the flags.
//
#define IM_IS_MOUSE_MOVE(A) \
    ((A) & IM_FLAG_MOUSE_MOVE)

#define IM_IS_MOUSE_PRESS(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && ((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_MOUSE_RELEASE(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && !((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_LEFT_CLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1))
#define IM_IS_LEFT_DCLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE))



//
// Holds NETWORK events, to person controlled by us, or from person in control
// of us.
//
typedef struct tagIMEVENTQ
{
    DWORD           head;
    DWORD           numEvents;
    IMEVENT         events[IM_SIZE_EVENTQ];
}
IMEVENTQ;
typedef IMEVENTQ FAR * LPIMEVENTQ;


//
// Holds translated events, suitable for injection from person
// in control of us, or pre-translated events to person controlled by us.
//
typedef struct tagIMOSQ
{
    DWORD           head;
    DWORD           numEvents;
    IMOSEVENT       events[IM_SIZE_OSQ];
}
IMOSQ;
typedef IMOSQ FAR * LPIMOSQ;


#define CIRCULAR_INDEX(start, rel_index, size) \
    (((start) + (rel_index)) % (size))




//
// To support collaboration in both NT (background service thread) and Win95 
// (win16 code) with as much of the common incoming/outgoing processing in
// one places, the IM data is separated into 4 types.  There are structures
// for each of these types, so that moving a variable from one to another
// is as easy as possible.  Note that the declarations are bitness-safe;
// they are the same size in 16-bit and 32-bit code.  And that the structures
// are DWORD aligned.
//
// (1) IM_SHARED_DATA
// This is data that both the CPI32 library needs to access, and one or 
// more of the NT/Win95 implementations of collaboration.
//
// (2) IM_NT_DATA
// This is data that only the NT version of collaboration needs.
//
// (3) IM_WIN95_DATA
// This is data that only the Win95 version of collaboration needs.
// 


//
// For NT, this shared structures is just declared in MNMCPI32.NT's data,
// and a pointer to it is used by the common lib.
//
// For Win95, this shared structure is allocated in a global memory block
// that can GlobalSmartPageLock() it as needed for access at interrupt time,
// and a pointer to it is mapped flat and returned to the common lib.
//
typedef struct tagIM_SHARED_DATA
{
#ifdef DEBUG
    DWORD           cbSize;         // To make sure everybody agrees on size
#endif

    //
    // For critical errors -- nonzero if one is up
    //
    DWORD           imSuspended;

    //
    // Control state
    //
    LONG            imControlled;
    LONG            imPaused;
    LONG            imUnattended;
}
IM_SHARED_DATA, FAR* LPIM_SHARED_DATA;


// NT specific IM state variables
typedef struct tagIM_NT_DATA
{
    //
    // Low level hook thread
    //
    DWORD           imLowLevelInputThread;

    //
    // Other desktop injection helper thread
    //
    DWORD           imOtherDesktopThread;

    //
    // Low level hook handles
    //
    HHOOK           imhLowLevelMouseHook;
    HHOOK           imhLowLevelKeyboardHook;
}
IM_NT_DATA, FAR* LPIM_NT_DATA;



// Win95 specific IM state variables
typedef struct tagIM_WIN95_DATA
{
    BOOL            imInjecting;
    BOOL            imLowLevelHooks;

    //
    // High level hook handles
    //
    HHOOK           imhHighLevelMouseHook;
}
IM_WIN95_DATA, FAR* LPIM_WIN95_DATA;



//
//
// MACROS
//
//
#define IM_SET_VK_DOWN(A) (A) |= (BYTE)0x80
#define IM_SET_VK_UP(A)   (A) &= (BYTE)0x7F
#define IM_TOGGLE_VK(A)   (A) ^= (BYTE)0x01

//
//
// PROTOTYPES
//
//


// NT only
BOOL WINAPI OSI_InstallHighLevelMouseHook(BOOL fOn);

BOOL WINAPI OSI_InstallControlledHooks(BOOL fOn);
void WINAPI OSI_InjectMouseEvent(DWORD flags, LONG x, LONG y,  DWORD mouseData, DWORD dwExtraInfo);
void WINAPI OSI_InjectKeyboardEvent(DWORD flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);
void WINAPI OSI_InjectCtrlAltDel(void);
void WINAPI OSI_DesktopSwitch(UINT from, UINT to);


//
// Internal Hook DLL functions.
//
#ifdef DLL_HOOK

#ifdef IS_16
BOOL    IM_DDInit(void);
void    IM_DDTerm(void);
#endif // IS_16

LRESULT CALLBACK IMMouseHookProc(int    code,
                                 WPARAM wParam,
                                 LPARAM lParam);

#endif // DLL_HOOK


#ifdef IS_16
void    IMCheckWin16LockPulse(void);
#else
DWORD   WINAPI IMLowLevelInputProcessor(LPVOID hEventWait);
DWORD   WINAPI IMOtherDesktopProc(LPVOID hEventWait);
LRESULT CALLBACK IMLowLevelMouseProc(int, WPARAM, LPARAM);
LRESULT CALLBACK IMLowLevelKeyboardProc(int, WPARAM, LPARAM);
#endif // IS_16

#endif // DLL_CORE or DLL_HOOK

#endif // _H_IM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\oe.h ===
//
// Order Encoder
//

#ifndef _H_OE
#define _H_OE



//
// Required headers
//
#include <oa.h>
#include <shm.h>
#include <fh.h>



//
// Specific values for OSI escape codes
//
#define OE_ESC(code)            (OSI_OE_ESC_FIRST + code)

#define OE_ESC_NEW_FONTS        OE_ESC(0)
#define OE_ESC_NEW_CAPABILITIES OE_ESC(1)


//
// Structure: OE_NEW_FONTS
//
// Description:
//
// Structure to pass new font data down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_FONTS
{
    OSI_ESCAPE_HEADER header;           // Common header
    WORD                fontCaps;       // R11 font capabilities
    WORD                countFonts;     // Number of fonts in data block

    LPLOCALFONT         fontData;       // Local font table, containing
                                        // FH_MAX_FONTS entries

    LPWORD              fontIndex;      // Font table index, containing
                                        // FH_LOCAL_INDEX_SIZE entries

} OE_NEW_FONTS;
typedef OE_NEW_FONTS FAR * LPOE_NEW_FONTS;


//
// Structure: OE_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendOrders;       // Are we allowed to send any
                                        // orders?

    DWORD           textEnabled;      // Are we allowed to send text
                                        // orders?

    DWORD           baselineTextEnabled;
                                        // Flag to indicate if we should
                                        //   encode text orders using
                                        //   baseline alignment.

    LPBYTE          orderSupported;     // Array of BYTE-sized booleans
}
OE_NEW_CAPABILITIES;
typedef OE_NEW_CAPABILITIES FAR * LPOE_NEW_CAPABILITIES;



//
// Flag to indicate support of second level order encoding.  This is used
// as a bitwise flag so that we can easily determine when parties have
// mixed capabilities.  Allowed values are:
//
//  OE2_FLAG_UNKNOWN       - OE2 supported has not been negotiated yet
//  OE2_FLAG_SUPPORTED     - OE2 is supported by at least one person
//  OE2_FLAG_NOT_SUPPORTED - OE2 is not supported by at least one person
//  OE2_FLAG_MIXED         - Oh no!  This results when we have 2 (or more)
//                           nodes that have differing OE2 support.  In
//                           this case we must disable OE2 encoding.
//
#define OE2_FLAG_UNKNOWN            0x00
#define OE2_FLAG_SUPPORTED          0x10
#define OE2_FLAG_NOT_SUPPORTED      0x01
#define OE2_FLAG_MIXED              0x11


//
//
// PROTOTYPES
//
//
#ifdef DLL_DISP



//
// Name:    OE_DDProcessRequest
//
// Purpose: Process an OE specific request from the Share Core
//
// Returns: TRUE if processed OK, FALSE otherwise
//
// Params:  pso   - SURFOBJ associated with ther request
//          cjIn  - size of input buffer
//          pvIn  - pointer to input buffer
//          cjOut - size of output buffer
//          pvOut - pointer to output buffer
//
#ifdef IS_16

BOOL    OE_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

BOOL    OE_DDInit(void);

void    OE_DDViewing(BOOL fStart);

#else

ULONG   OE_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

#endif // IS_16

void    OE_DDTerm(void);

void    OEDDSetNewFonts(LPOE_NEW_FONTS pDataIn);

void    OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCaps);

BOOL    OE_SendAsOrder(DWORD order);
BOOL    OE_RectIntersectsSDA(LPRECT lpRect);

#endif // ifdef DLL_DISP


//
// Function prototypes.
//

//
// OE_GetStringExtent(..)
//
// FUNCTION:
//
// Gets the extent (in logical coords) of the specified string.
// The extent returned encloses all pels of the specified string.
//
//
// PARAMETERS:
//
// hdc - DC handle
//
// pMetric - pointer to text metrics for the font for the string; if NULL,
// use the global text metrics
//
// lpszString - pointer to null terminated string
//
// cbString - number of bytes in string
//
// lpDx - pointer to character increments. If NULL, use default character
// increments
//
// pRect - pointer to rect where string extent is returned
//
// RETURNS:
//
// The amount of overhang included in the returned extent
//
//     ------------------------------------....
//     |                                  ****:
//     |                                  *   :
//     |                                 ***  :
//     |                                * |   :
//     |                               *  |   :
//     |                             **** |   :
//     ------------------------------------....
//                                            ^
//                                            :-------- bounds are wider
//                                        ^             than text extent
//                                        |             due to overhang
//                     real text extent ends here
//
//
int OE_GetStringExtent(HDC hdc,
                                TEXTMETRIC*    pMetric,
                                LPSTR       lpszString,
                                UINT         cbString,
                                LPRECT        pRect      );



//
// Macros to lock down the buffer that we want to use.
//
// NOTE: We do not have any OE specific shared memory, so we'll use the OA
// shared data as a surrogate for the lock.  Since the lock is counting, we
// have no worries.
//
#define OE_SHM_START_WRITING  OA_SHM_START_WRITING

#define OE_SHM_STOP_WRITING   OA_SHM_STOP_WRITING

//
// Number of rectangles that can make up a clip region before it is too
// complicated to send as an order.
//
#define COMPLEX_CLIP_RECT_COUNT     4

//
// Mask and valid values for TextOut flAccel flags
//
#define OE_BAD_TEXT_MASK  ( SO_VERTICAL | SO_REVERSED | SO_GLYPHINDEX_TEXTOUT )


#ifdef DLL_DISP
//
// Structure to store brushes used as BLT patterns.
//
// style     - Standard brush style (used in order to send brush type).
//
//             BS_HATCHED
//             BS_PATTERN
//             BS_SOLID
//             BS_NULL
//
// hatch     - Standard hatch definition.  Can be one of the following.
//
//             style = BS_HATCHED
//
//             HS_HORIZONTAL
//             HS_VERTICAL
//             HS_FDIAGONAL
//             HS_BDIAGONAL
//             HS_CROSS
//             HS_DIAGCROSS
//
//             style = BS_PATTERN
//
//             This field contains the first byte of the brush definition
//             from the brush bitmap.
//
// brushData - bit data for the brush.
//
// fore      - foreground color for the brush
//
// back      - background color for the brush
//
// brushData - bit data for the brush (8x8x1bpp - 1 (see above) = 7 bytes)
//
//
typedef struct tagOE_BRUSH_DATA
{
    BYTE  style;
    BYTE  hatch;
    BYTE  pad[2];
    TSHR_COLOR  fore;
    TSHR_COLOR  back;
    BYTE  brushData[7];
} OE_BRUSH_DATA, * POE_BRUSH_DATA;

#ifndef IS_16
//
// Structure allowing sufficient stack to be allocated for an ENUMRECTS
// structure containing more than one (in fact COMPLEX_CLIP_RECT_COUNT)
// rectangles.
// This holds one RECTL more than we need to allow us to determine whether
// there are too many rects for order encoding by making a single call to
// CLIPOBJ_bEnumRects.
//
typedef struct tagOE_ENUMRECTS
{
    ENUMRECTS rects;
    RECTL     extraRects[COMPLEX_CLIP_RECT_COUNT];
} OE_ENUMRECTS;
#endif // !IS_16
#endif

//
// Font Alias table structure.  The font aliases convert non-existant fonts
// to ones that Windows supports in its default installation.
//
// pszOriginalFontName - Name of the non-existant font to be aliased
//
// pszAliasFontName    - Name of the font Windows uses instead of the non
//                       existant font.
//
// charWidthAdjustment - Character adjustment to make a decent match.
//
typedef struct _FONT_ALIAS_TABLE
{
    LPBYTE          pszOriginalFontName;
    LPBYTE          pszAliasFontName;
    TSHR_UINT16     charWidthAdjustment;
}
FONT_ALIAS_TABLE;


//
// ROP4 to ROP3 conversion macros.  Note that we don't use the full Windows
// 3-way ROP code - we are only interested in the index byte.
//
#define ROP3_HIGH_FROM_ROP4(rop) ((TSHR_INT8)((rop & 0xff00) >> 8))
#define ROP3_LOW_FROM_ROP4(rop)  ((TSHR_INT8)((rop & 0x00ff)))

//
// OS specific RECTL to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
#define RECT_FROM_RECTL(dcr, rec) if (rec.right < rec.left)                \
                                    {                                        \
                                        dcr.left   = rec.right;              \
                                        dcr.right  = rec.left;               \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.left   = rec.left;               \
                                        dcr.right  = rec.right;              \
                                    }                                        \
                                    if (rec.bottom < rec.top)                \
                                    {                                        \
                                        dcr.bottom = rec.top;                \
                                        dcr.top    = rec.bottom;             \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.top    = rec.top;                \
                                        dcr.bottom = rec.bottom;             \
                                    }

//
// OS specific RECTFX to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
// A RECTFX uses fixed point (28.4 bit) numbers so we need to truncate the
// fraction and move to the correct integer value, i.e. shift right 4 bits.
//
#define RECT_FROM_RECTFX(dcr, rec)                                         \
                                if (rec.xRight < rec.xLeft)                  \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xRight);      \
                                    dcr.right = FXTOLCEILING(rec.xLeft);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xLeft);       \
                                    dcr.right = FXTOLCEILING(rec.xRight);    \
                                }                                            \
                                if (rec.yBottom < rec.yTop)                  \
                                {                                            \
                                    dcr.bottom= FXTOLCEILING(rec.yTop);      \
                                    dcr.top   = FXTOLFLOOR(rec.yBottom);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.top   = FXTOLFLOOR(rec.yTop);        \
                                    dcr.bottom= FXTOLCEILING(rec.yBottom);   \
                                }

#define POINT_FROM_POINTL(dcp, pnt) dcp.x = pnt.x;                \
                                    dcp.y = pnt.y


#define POINT_FROM_POINTFIX(dcp, pnt) dcp.x = FXTOLROUND(pnt.x);  \
                                      dcp.y = FXTOLROUND(pnt.y)


//
// Macros to check for articular types of ROP code.
//
#define ROP3_NO_PATTERN(rop) ((rop & 0x0f) == (rop >> 4))

#define ROP3_NO_SOURCE(rop)  ((rop & 0x33) == ((rop & 0xCC) >> 2))

#define ROP3_NO_TARGET(rop)  ((rop & 0x55) == ((rop & 0xAA) >> 1))

//
// Checking for SRCCOPY, PATCOPY, BLACKNESS, WHITENESS
//
#define ROP3_IS_OPAQUE(rop)  ( ((rop) == 0xCC) || ((rop) == 0xF0) || \
                               ((rop) == 0x00) || ((rop) == 0xFF) )

//
// 3-way rop equating to the COPYPEN mix.
//
#define OE_COPYPEN_ROP (BYTE)0xf0



#ifdef DLL_DISP

void  OEConvertMask(ULONG  mask, LPUINT pBitDepth, LPUINT pShift);


#ifdef IS_16

//
// GDI never made defines for these, so we will.
//
#define PALETTEINDEX_FLAG   0x01000000L
#define PALETTERGB_FLAG     0x02000000L
#define COLOR_FLAGS         0x03000000L

//
// This is a GLOBAL to cut down on stack space, and is only valid during
// the life of a DDI call that is not reentrant.
//
// When we calculate something, we set the bit saying we did.  This speeds 
// up our code a lot from NM 2.0 which used to calculate the same things
// over and over again.
//

#define OESTATE_SDA_DCB         0x0001  // Send as screen data, use DCBs
#define OESTATE_SDA_SCREEN      0x0002  // Send as screen data, use screen rc
#define OESTATE_SDA_MASK        0x0003  // Send rc as screen data
#define OESTATE_SDA_FONTCOMPLEX 0x0004  // Send as screen data if font too complex
#define OESTATE_OFFBYONEHACK    0x0010  // Add one pixel onto bottom after DDI
#define OESTATE_CURPOS          0x0020  // Save curpos before DDI call
#define OESTATE_DDISTUFF        0x003F

#define OESTATE_COORDS          0x0100
#define OESTATE_PEN             0x0200
#define OESTATE_BRUSH           0x0400
#define OESTATE_REGION          0x0800
#define OESTATE_FONT            0x1000
#define OESTATE_GET_MASK        0x1F00

#define MIN_BRUSH_WIDTH         8
#define MAX_BRUSH_WIDTH         16
#define TRACKED_BRUSH_HEIGHT    8

#define TRACKED_BRUSH_SIZE      8

typedef struct tagOESTATE
{
    UINT            uFlags;
    HDC             hdc;
    LPDC            lpdc;
    RECT            rc;

    //
    // These are used when calcing the bounds is too complicated, so we 
    // let GDI do it for us, albeit slower.
    //
    UINT            uGetDCB;
    UINT            uSetDCB;
    RECT            rcDCB;

    POINT           ptCurPos;
    POINT           ptDCOrg;
    POINT           ptPolarity;
    LOGPEN          logPen;
    LOGBRUSH        logBrush;
    BYTE            logBrushExtra[TRACKED_BRUSH_SIZE];
    LOGFONT         logFont;
    int             tmAlign;
    TEXTMETRIC      tmFont;
    REAL_RGNDATA    rgnData;
} OESTATE, FAR* LPOESTATE;

void    OEGetState(UINT uFlags);
BOOL    OEBeforeDDI(DDI_PATCH ddiType, HDC hdc, UINT flags);
BOOL    OEAfterDDI(DDI_PATCH ddiType, BOOL fWeCare, BOOL fOutputHappened);


#define OECHECK_PEN         0x0001
#define OECHECK_BRUSH       0x0002
#define OECHECK_FONT        0x0004
#define OECHECK_CLIPPING    0x0010
BOOL    OECheckOrder(DWORD order, UINT flags);


LPDC    OEValidateDC(HDC hdc, BOOL fSrc);
void    OEMaybeBitmapHasChanged(LPDC lpdc);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR* lpExtraInfo);
void    OEClipAndAddScreenData(LPRECT pRect);


void    OELPtoVirtual(HDC hdc, LPPOINT aPts, UINT cPts);
void    OELRtoVirtual(HDC hdc, LPRECT aRcs, UINT cRcs);

void    OEGetPolarity(void);
void    OEPolarityAdjust(LPRECT pRects, UINT cRects);
void    OEPenWidthAdjust(LPRECT lprc, UINT divisor);
BOOL    OETwoWayRopToThree(int, LPDWORD);

BOOL    OEClippingIsSimple(void);
BOOL    OEClippingIsComplex(void);
BOOL    OECheckPenIsSimple(void);
BOOL    OECheckBrushIsSimple(void);

void    OEExpandColor(LPBYTE lpField, DWORD clrSrc, DWORD fieldMask);
void    OEConvertColor(DWORD rgb, LPTSHR_COLOR lptshrDst, BOOL fAllowDither);
void    OEGetBrushInfo(LPTSHR_COLOR pClrBack, LPTSHR_COLOR pClrFore,
    LPTSHR_UINT32 lpBrushStyle, LPTSHR_UINT32 lpBrushHatch, LPBYTE lpBrushExtra);


void    OEAddLine(POINT ptStart, POINT ptEnd);
void    OEAddBlt(DWORD rop);
void    OEAddOpaqueRect(LPRECT);
void    OEAddRgnPaint(HRGN hrgnnPaint, HBRUSH hbrPaint, UINT rop);
void    OEAddPolyline(POINT ptStart, LPPOINT apts, UINT cpts);
void    OEAddPolyBezier(POINT ptStart, LPPOINT apts, UINT cpts);


//
// Cached font width info
//
typedef struct tagFH_CACHE
{
    UINT    fontIndex;
    UINT    fontWidth;
    UINT    fontHeight;
    UINT    fontWeight;
    UINT    fontFlags;
    UINT    charWidths[256];
} FH_CACHE, FAR* LPFH_CACHE;

void    OEAddText(POINT ptDst, UINT uOptions, LPRECT lprcClip, LPSTR lpszText,
            UINT cchText, LPINT lpdxCharSpacing);
int     OEGetStringExtent(LPSTR lpszText, UINT cchText, LPINT lpdxCharSpacing, LPRECT lprcExtent);
BOOL    OECheckFontIsSupported(LPSTR lpszText, UINT cchText, LPUINT pFontHeight,
    LPUINT pFontWidth, LPUINT pFontWeight, LPUINT pFontFlags,
    LPUINT pFontIndex, LPBOOL lpfSendDeltaX);
BOOL    OEAddDeltaX(LPEXTTEXTOUT_ORDER pExtTextOut, LPSTR lpszText, UINT cchText,
    LPINT lpdxCharSpacing, BOOL fSendDeltaX, POINT ptStart);

#else

void    OELPtoVirtual(LPPOINT pPoints, UINT cPoints);
void    OELRtoVirtual(LPRECT pRects, UINT cRects);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR * pExtraInfo, CLIPOBJ* pco);
void    OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco);

BOOL    OEClippingIsSimple(CLIPOBJ* pco);
BOOL    OEClippingIsComplex(CLIPOBJ* pco);
BOOL    OECheckBrushIsSimple(LPOSI_PDEV ppdev, BRUSHOBJ* pbo, POE_BRUSH_DATA * ppBrush);

void    OEExpandColor(LPBYTE lpField, ULONG clrSrc, ULONG mask);
void    OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pDCColor, ULONG osColor, XLATEOBJ* pxlo);
BOOL    OEAddLine(LPOSI_PDEV ppdev,
                             LPPOINT  startPoint,
                             LPPOINT  endPoint,
                             LPRECT   rectTrg,
                             UINT  rop2,
                             UINT  width,
                             UINT  color,
                             CLIPOBJ*  pco);


BOOL  OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect);
BOOL  OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect);


BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                BRUSHOBJ* pbo,
                                BYTE   style,
                                LPBYTE  pBits,
                                XLATEOBJ* pxlo,
                                BYTE   hatch,
                                UINT  color1,
                                UINT  color2);

BOOL  OECheckFontIsSupported(FONTOBJ*  pfo, LPSTR lpszText, UINT cchText,
    LPUINT fontHeight, LPUINT pFontAscent, LPUINT pFontWidth,
    LPUINT pFontWeight, LPUINT pFontFlags, LPUINT pFontIndex,
    LPBOOL pfSendDeltaX);


void  OETileBitBltOrder(LPINT_ORDER               pOrder,
                                     LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                     CLIPOBJ*                 pco);

void  OEAddTiledBitBltOrder(LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                      xTile,
                                         int                      yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight);

BOOL OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                 BRUSHOBJ   *pbo,
                                 POINTL     *pptlBrush,
                                 BYTE       rop3,
                                 LPRECT     pBounds,
                                 LPINT_ORDER *ppOrder);

#endif // !IS_16

#endif // DLL_DISP



//
// Structures and typedefs.
//

//
// Remote font is the structure we store for each font received from a
// remote party.  It mirrors the NETWORKFONT structure, with the facename
// replaced with an index value (used to map the remote font handle to the
// correct local font handle).
//
typedef struct _OEREMOTEFONT
{
    TSHR_UINT16    rfLocalHandle;
    TSHR_UINT16    rfFontFlags;
    TSHR_UINT16    rfAveWidth;
    TSHR_UINT16    rfAveHeight;
    // lonchanc: rfAspectX and rfAspectY are used in network packet header
    // for both R11 and R20. So, keep it around!
    TSHR_UINT16    rfAspectX;          // New field for r1.1
    TSHR_UINT16    rfAspectY;          // New field for r1.1
    TSHR_UINT8     rfSigFats;          // New field for r2.0
    TSHR_UINT8     rfSigThins;         // New field for r2.0
    TSHR_UINT16    rfSigSymbol;        // New field for r2.0
    TSHR_UINT16    rfCodePage;         // New field for R2.0
    TSHR_UINT16    rfMaxAscent;        // New field for R2.0
}
OEREMOTEFONT, * POEREMOTEFONT;


void    OEMaybeEnableText(void);
BOOL    OERectIntersectsSDA(LPRECT pRectVD);

BOOL    OESendRop3AsOrder(BYTE rop3);



#endif // _H_OE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\oa.h ===
//
// Order Accumulator
//

#ifndef _H_OA
#define _H_OA


#include <osi.h>

//
// Specific values for OSI escape codes
//
#define OA_ESC(code)                (OSI_OA_ESC_FIRST + code)
#define OA_ESC_FLOW_CONTROL         OA_ESC(0)


//
// Flow control constants for sizes/depths when slow, fast, etc.  The
// SLOW/FAST heap sizes are simply for spoiling.  OA_HEAP_MAX is really
// the size of the heap.
//
#define OA_FAST_HEAP                50000
#define OA_SLOW_HEAP                20000

//
// NOTE:  This is 64K - sizeof OA_SHARED_DATA header
//        If you add fields to header, subtract from this value
//
#define OA_HEAP_MAX                 65512

//
// Flow control constants for depth of order spoiling
//
#define OA_FAST_SCAN_DEPTH               50
#define OA_SLOW_SCAN_DEPTH              500


//
// Threshold for switching from FAST to SLOW order accum
//
#define OA_FAST_THRESHOLD           20000

//
// Value to indicate that you have reached the end of the order list
//
#define OA_NO_LIST          -1


#ifdef DLL_DISP

#define OA_SHM_START_WRITING    SHM_StartAccess(SHM_OA_DATA)
#define OA_SHM_STOP_WRITING     SHM_StopAccess(SHM_OA_DATA)

#define OA_FST_START_WRITING    SHM_StartAccess(SHM_OA_FAST)
#define OA_FST_STOP_WRITING     SHM_StopAccess(SHM_OA_FAST)

#else

#define OA_SHM_START_READING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_READING


#define OA_SHM_START_WRITING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_WRITING


#define OA_FST_START_READING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_READING     


#define OA_FST_START_WRITING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_WRITING     


#endif


//
// Maximum memory allowed for variable order data.
//
#define MAX_ADDITIONAL_DATA_BYTES 400000

//
// Invalid value to assign to deallocated order header pointers.
//
#define OA_DEAD_ORDER ((void FAR *)0xffffffff)

//
// Define the space to be reserved at the beginning of the segment
// for heap management.
//
#define RESERVED_HEAP_BYTES 16

//
// Define clip function return codes.
//
#define CR_NO_OVERLAP        1
#define CR_COMPLETE_OVERLAP  2
#define CR_SIMPLE_CLIP       3
#define CR_COMPLEX_OVERLAP   4
#define CR_COMPLEX_CLIP      5

//
// Macros that return the width and height of an order.
//
#define ORDER_WIDTH(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.right - \
                                pOrder->OrderHeader.Common.rcsDst.left + 1 )
#define ORDER_HEIGHT(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.bottom - \
                                pOrder->OrderHeader.Common.rcsDst.top + 1 )

//
// Define the minimum width and height of an order for us to try to spoil
// previous orders with it.  This helps performance, because it saves us
// trying to spoil earlier orders with very small orders.  However, if the
// order exceeds the FULL_SPOIL values then we spoil as originally, with
// the proviso that flow control may still prevent it.
//
#define FULL_SPOIL_WIDTH  16
#define FULL_SPOIL_HEIGHT 16


//
// Define a macro that calculates whether a rectangle lies completely
// within another rectangle.
//
#define RECT1_WITHIN_RECT2(rect1, rect2)   \
        ( (rect1.left   >= rect2.left  ) &&    \
          (rect1.top    >= rect2.top   ) &&    \
          (rect1.right  <= rect2.right ) &&    \
          (rect1.bottom <= rect2.bottom) )



//
// Structure: OA_NEW_PARAMS
//
// Description:
//
// Structure to pass new OA parameters down to the display driver from the
// Share Core.
//
//

enum
{
    OAFLOW_FAST = 0,
    OAFLOW_SLOW
};

typedef struct tagOA_FLOW_CONTROL
{
    OSI_ESCAPE_HEADER   header;     // Common header
    DWORD               oaFlow;     // Type -- fast, slow, etc.
}
OA_FLOW_CONTROL;
typedef OA_FLOW_CONTROL FAR * LPOA_FLOW_CONTROL;

//
// Structure used to store orders in the shared memory
//
// totalHeapOrderBytes       - Total bytes used in the order heap
//
// totalOrderBytes           - Total bytes used by order data
//
// totalAdditionalOrderBytes - Total bytes used as additional order data
//
// nextOrder                 - Offset for start of next new order
//
// orderListHead             - Order list head (uses standard BASEDLIST
//                             manipulation code)
//
// orderHeap                 - Order heap
//
typedef struct tagOA_SHARED_DATA
{
    DWORD       totalHeapOrderBytes;
    DWORD       totalOrderBytes;
    DWORD       totalAdditionalOrderBytes;
    LONG        nextOrder;

    BASEDLIST      orderListHead;

    BYTE        orderHeap[OA_HEAP_MAX];
}
OA_SHARED_DATA;
typedef OA_SHARED_DATA FAR * LPOA_SHARED_DATA;

//
// Structure used to store orders in the shared memory
//
// ordersAccumulated         - number of orders accumulated in the heap
//                             since the last double buffer swap.
//
//
typedef struct tagOA_FAST_DATA
{
    DWORD     ordersAccumulated;
} OA_FAST_DATA;
typedef OA_FAST_DATA FAR * LPOA_FAST_DATA;


//
//
// INT_ORDER_HEADER
//
// This structure contains the Common header (containing the fields which
// are sent over the network) and some additional fields which are only
// used on the host side)
//
// list
//     Offset to next and previous orders in the list
//     This field does not need to be transmitted across the network.
//
// additionalOrderData
//     Offset to the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// cbAdditionalOrderData
//     Size of the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// Common
//     Common header (which IS sent over the network)
//
// N.B.  If you change this structure, please make sure that you haven't
// broken the code in SBCInitInternalOrders.
//
//
typedef struct INT_ORDER_HEADER
{
    BASEDLIST              list;
    LONG                additionalOrderData;
    WORD                cbAdditionalOrderDataLength;
    WORD                pad1;
    COM_ORDER_HEADER    Common;
} INT_ORDER_HEADER;
typedef INT_ORDER_HEADER FAR *LPINT_ORDER_HEADER;


//
// Define an order with the internal only fields defined (this is only used
// on the sending end)
//
typedef struct _INT_ORDER
{
    INT_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
} INT_ORDER;
typedef INT_ORDER FAR *LPINT_ORDER;


// Structure: INT_COLORTABLE_ORDER_xBPP
//
// Description: Internal structures used to pass color table data to the
// share core.  These are never sent across the wire.
//
typedef struct tagINT_COLORTABLE_HEADER
{
    TSHR_UINT16    type;           // holds "CT" - INTORD_COLORTABLE
    TSHR_UINT16    bpp;            // 1, 4 or 8
} INT_COLORTABLE_HEADER, FAR * LPINT_COLORTABLE_HEADER;

typedef struct tagINT_COLORTABLE_ORDER_1BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[2];
} INT_COLORTABLE_ORDER_1BPP, FAR * LPINT_COLORTABLE_ORDER_1BPP;

typedef struct tagINT_COLORTABLE_ORDER_4BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[16];
} INT_COLORTABLE_ORDER_4BPP, FAR * LPINT_COLORTABLE_ORDER_4BPP;

typedef struct tagINT_COLORTABLE_ORDER_8BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[256];
} INT_COLORTABLE_ORDER_8BPP, FAR * LPINT_COLORTABLE_ORDER_8BPP;



//
// Macro to calculate a basic internal order size (including the Order
// Header).
//
#define INT_ORDER_SIZE(pOrder) \
(pOrder->OrderHeader.Common.cbOrderDataLength + sizeof(INT_ORDER_HEADER))


//
// Macro to calculate the maximum possible size of an order, including
// any Additional Order Data.
//
#define MAX_ORDER_SIZE(pOrder) \
(INT_ORDER_SIZE(pOrder) + (pOrder->OrderHeader.cbAdditionalOrderDataLength))

//
// Macro to determine whether an order is SCRBLT_ORDER.
//
#define ORDER_IS_SCRBLT(pOrder) \
         (((LPSCRBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_SCRBLT))

//
// Macro to determine whether an order is MEMBLT_ORDER.
//
#define ORDER_IS_MEMBLT(pOrder) \
     (((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT) || \
      ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT_R2))

//
// Macro to determine whether an order is MEM3BLT_ORDER.
//
#define ORDER_IS_MEM3BLT(pOrder) \
    (((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT) || \
     ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT_R2))



//
// PROTOTYPES
//

#ifdef DLL_DISP


//
// FUNCTION:      OA_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OA specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL  OA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);


//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength );

//
//
// OA_DDFreeOrderMem(..)
//
// Frees order memory allocated by OA_AllocOrderMem(..).
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
// Order memory is normally freed when the order is transmitted.
//
// This will be used if order memory has been allocated, and
// subsequently, before the order is passed to AddOrder(..), the
// allocator decides that the order should not be sent (e.g. if it
// is completely clipped out).
//
//
void OA_DDFreeOrderMem(LPINT_ORDER pOrder);

void OA_DDResetOrderList(void);

LPINT_ORDER OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder);

void OA_DDSyncUpdatesNow(void);

//
// Name:      OA_DDSpoilOrdersByRect
//
// Purpose:   Try to spoil orders by a given rectangle.
//
// Returns:   Nothing
//
// Params:    IN    pRect - Pointer to the spoiling rectangle
//
// Operation: This function will start at the end of the order heap (from
//            the newest order) and work towards the start of the heap.
//
void OA_DDSpoilOrdersByRect(LPRECT pRect);


//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completely covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo);


void     OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder);

LPINT_ORDER OADDAllocOrderMemInt(LPOA_SHARED_DATA lpoaShared, UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength);

void     OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder);

void     OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared);

BOOL     OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap);

void     OATrySpoilingByOrders(void);

void     OADDSpoilFromOrder(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder, LPRECT pRect);


#ifdef DEBUG
void    CheckOaHeap(LPOA_SHARED_DATA);
#else
#define CheckOaHeap(lpoaShared)
#endif

#endif // !DLL_DISP

#endif // _H_OA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ndcgver.h ===
//
// NDCGVER.H
// NM app sharing version for display driver/app checking
//
// Copyright (c) Microsoft 1997-
//
#define DCS_BUILD_STR "4.3.0."VERSIONBUILD_STR

#define DCS_BUILD_NUMBER    0

//
// This allows the ring 3 code and ring 0 code to check each other, make
// sure they are the same version.  We're changing setup and getting close
// to shipping version 2.0, we want to prevent weird faults and blue
// screens caused by mismatched components.  This is not something we will
// do forever.  When NT 5 is here, we'll dyna load and init our driver at
// startup and terminate it at shutdown.  But for now, since installing
// one of these beasts is messsy, an extra sanity check is a good thing.
//
#define DCS_PRODUCT_NUMBER  3               // Version 3.0 of NM
#define DCS_MAKE_VERSION()  MAKELONG(VERSIONBUILD, DCS_PRODUCT_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\od.h ===
//
// Order Decoder
//

#ifndef _H_OD
#define _H_OD



//
// Max # of accumulated bound rects we'll save in the total invalid
// region before simplifying it.
//
#define MAX_UPDATE_REGION_ORDERS 300


//
// Constants used by ODAdjustVGAColor (qv)
//
enum
{
    OD_BACK_COLOR   = 0,
    OD_FORE_COLOR   = 1,
    OD_PEN_COLOR    = 2,
    // number of the above colors.
    OD_NUM_COLORS   = 3
};


COLORREF __inline ODCustomRGB(BYTE r, BYTE g, BYTE b, BOOL fPaletteRGB)
{
    if (fPaletteRGB)
    {
        return(PALETTERGB(r, g, b));
    }
    else
    {
        return(RGB(r, g, b));
    }
}


//
// Structure used by ODAdjustVGAColor (qv)
//
typedef struct tagOD_ADJUST_VGA_STRUCT
{
    COLORREF    color;
    UINT        addMask;
    UINT        andMask;
    UINT        testMask;
    TSHR_COLOR  result;
}
OD_ADJUST_VGA_STRUCT;


//
// This internal routine is implemented as a macro rather than a function.
//
UINT __inline ODConvertToWindowsROP(UINT bRop)
{
    extern const UINT s_odWindowsROPs[256];

    ASSERT(bRop < 256);
    return(s_odWindowsROPs[bRop]);
}



#endif // _H_OD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\oe2.h ===
//
// Order Encoder 2nd Level
//

#ifndef _H_OE2
#define _H_OE2


//
//
// TYPEDEFS
//
//

//
// The party order data structure contains all the data that is used by
// either the 2nd level encoder or decoder to store info on a party.
//
// The encoder contains just 1 instance of this structure, for the local
// party.
//
// The decoder contains 1 instance of the structure per remote party.
//
typedef struct _PARTYORDERDATA
{
    STRUCTURE_STAMP

    //
    // A copy of the last order of each type.
    // These are stored as byte array because we dont have a structure
    // defined that has the header and the particular order defined.
    //
    BYTE LastDstblt[sizeof(COM_ORDER_HEADER)+sizeof(DSTBLT_ORDER)];
    BYTE LastPatblt[sizeof(COM_ORDER_HEADER)+sizeof(PATBLT_ORDER)];
    BYTE LastScrblt[sizeof(COM_ORDER_HEADER)+sizeof(SCRBLT_ORDER)];
    BYTE LastMemblt[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_ORDER)];
    BYTE LastMem3blt[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_ORDER)];
    BYTE LastRectangle[sizeof(COM_ORDER_HEADER)+sizeof(RECTANGLE_ORDER)];
    BYTE LastLineTo[sizeof(COM_ORDER_HEADER)+sizeof(LINETO_ORDER)];
    BYTE LastTextOut[sizeof(COM_ORDER_HEADER)+sizeof(TEXTOUT_ORDER)];
    BYTE LastExtTextOut[sizeof(COM_ORDER_HEADER)+sizeof(EXTTEXTOUT_ORDER)];
    BYTE LastOpaqueRect[sizeof(COM_ORDER_HEADER)+sizeof(OPAQUERECT_ORDER)];
    BYTE LastSaveBitmap[sizeof(COM_ORDER_HEADER)+sizeof(SAVEBITMAP_ORDER)];
    BYTE LastDeskScroll[sizeof(COM_ORDER_HEADER)+sizeof(DESKSCROLL_ORDER)];
    BYTE LastMembltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_R2_ORDER)];
    BYTE LastMem3bltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_R2_ORDER)];
    BYTE LastPolygon[sizeof(COM_ORDER_HEADER)+sizeof(POLYGON_ORDER)];
    BYTE LastPie[sizeof(COM_ORDER_HEADER)+sizeof(PIE_ORDER)];
    BYTE LastEllipse[sizeof(COM_ORDER_HEADER)+sizeof(ELLIPSE_ORDER)];
    BYTE LastArc[sizeof(COM_ORDER_HEADER)+sizeof(ARC_ORDER)];
    BYTE LastChord[sizeof(COM_ORDER_HEADER)+sizeof(CHORD_ORDER)];
    BYTE LastPolyBezier[sizeof(COM_ORDER_HEADER)+sizeof(POLYBEZIER_ORDER)];
    BYTE LastRoundRect[sizeof(COM_ORDER_HEADER)+sizeof(ROUNDRECT_ORDER)];

    //
    // The type and a pointer to the last order
    //
    BYTE     LastOrderType;
    LPCOM_ORDER  pLastOrder;

    //
    // Details of the last font that was used
    //
    HFONT     LastHFONT;
    UINT      LastCodePage;
    UINT      LastFontWidth;
    UINT      LastFontHeight;
    UINT      LastFontWeight;
    UINT      LastFontFlags;
    UINT      LastFontFaceLen;
    char      LastFaceName[FH_FACESIZE];

    //
    // The last bounds that were used.
    //
    TSHR_RECT16    LastBounds;

    //
    // Font metrics, currently unused by the encoder.
    //
    TEXTMETRIC      LastFontMetrics;

    //
    // An array of pointers to the last orders of each type.
    //
    void *     LastOrder[OE2_NUM_TYPES];
}
PARTYORDERDATA, * PPARTYORDERDATA, * * PPPARTYORDERDATA;


//
//  This structure contains information for a single field in an ORDER
//  structure
//
//  FieldPos          - The byte offset into the order structure to the
//                      start of the field.
//
//  FieldUnencodedLen - The length in bytes of the unencoded field.
//
//  FieldEncodedLen   - The length in bytes of the encoded field.  This
//                      should always be <= to FieldUnencodedLen.
//
//  FieldSigned       - Does this field contain a signed or unsigned value?
//
//  FieldType         - A description of the type of the field - this
//                      is used to determine how to encode / decode the
//                      field.
//
//
typedef struct tagOE2ETFIELD
{
    UINT      FieldPos;
    UINT      FieldUnencodedLen;
    UINT      FieldEncodedLen;
    BOOL      FieldSigned;
    UINT      FieldType;
}OE2ETFIELD;

typedef OE2ETFIELD const FAR * POE2ETFIELD;

//
// Array of pointers to the entries in the encoding table
//
typedef POE2ETFIELD  OE2ETTYPE[OE2_NUM_TYPES];

//
//  This structure contains information allowing an ORDER structure to be
//  encoded or decoded into a DCEO2ORDER structure.
//  The order table comprises
//
//      - an array of POE2ETFIELD pointers, indexed by the encoded type
//         index:
//
//              typedef OE2ETTYPE POE2ETFIELD[OE2_NUM_TYPES]
//
//      - one array of OE2ETFIELD structures for each of the 7 order
//         types (each order type has a different number of fields).
//         Note that there may not be more than 24 entries for a single
//         ORDER type.  The entries for an order type are terminated
//         by an entry with the FieldPos field set to 0.  The first
//         FieldPos is non-zero since it is the offset to the second
//         field of the order (type is ignored).
//
//  pFields - an array of POE2ETFIELD pointers, indexed by the encoded
//             type index.  This is used to identify the entry in this
//             table for an ORDER type.
//
//  NumFields - an array of bytes containing the number of fields in each
//              order structure for each order.
//
//  DstBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the DSTBLT_ORDER
//
//  PatBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the PATBLT_ORDER
//
//  ScrBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the SCRBLT_ORDER
//
//  MemBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEMBLT_ORDER
//
//  Mem3BltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEM3BLT_ORDER
//
//  TextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the TEXTOUT_ORDER
//
//  ExtTextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the EXTTEXTOUT_ORDER
//
//  RectangleFields - array of OE2ETFIELD structures (one for each field)
//                     for the RECTANGLE_ORDER
//
//  LineToFields - array of OE2ETFIELD structures (one for each field)
//                    for the LINETO_ORDER
//
//  OpaqueRectFields - array of OE2ETFIELD structures (one for each field)
//                    for the OPQAUERECT_ORDER
//
//  SaveBitmapFields - array of OE2ETFIELD structures (one for each field)
//                    for the SAVEBITMAP_ORDER
//
//  DeskScrollFields - array of OE2ETFIELD structures (one for each field)
//                    for the DESKSCROLL_ORDER
//  etc.
//
//
typedef struct tagOE2ETTABLE
{
        POE2ETFIELD pFields           [OE2_NUM_TYPES];
        BYTE     NumFields         [OE2_NUM_TYPES];
        OE2ETFIELD  DstBltFields      [OE2_NUM_DSTBLT_FIELDS];
        OE2ETFIELD  PatBltFields      [OE2_NUM_PATBLT_FIELDS];
        OE2ETFIELD  ScrBltFields      [OE2_NUM_SCRBLT_FIELDS];
        OE2ETFIELD  MemBltFields      [OE2_NUM_MEMBLT_FIELDS];
        OE2ETFIELD  Mem3BltFields     [OE2_NUM_MEM3BLT_FIELDS];
        OE2ETFIELD  TextOutFields     [OE2_NUM_TEXTOUT_FIELDS];
        OE2ETFIELD  ExtTextOutFields  [OE2_NUM_EXTTEXTOUT_FIELDS];
        OE2ETFIELD  RectangleFields   [OE2_NUM_RECTANGLE_FIELDS];
        OE2ETFIELD  LineToFields      [OE2_NUM_LINETO_FIELDS];
        OE2ETFIELD  OpaqueRectFields  [OE2_NUM_OPAQUERECT_FIELDS];
        OE2ETFIELD  SaveBitmapFields  [OE2_NUM_SAVEBITMAP_FIELDS];
        OE2ETFIELD  DeskScrollFields  [OE2_NUM_DESKSCROLL_FIELDS];
        OE2ETFIELD  MemBltR2Fields    [OE2_NUM_MEMBLT_R2_FIELDS];
        OE2ETFIELD  Mem3BltR2Fields   [OE2_NUM_MEM3BLT_R2_FIELDS];
        OE2ETFIELD  PolygonFields     [OE2_NUM_POLYGON_FIELDS];
        OE2ETFIELD  PieFields         [OE2_NUM_PIE_FIELDS];
        OE2ETFIELD  EllipseFields     [OE2_NUM_ELLIPSE_FIELDS];
        OE2ETFIELD  ArcFields         [OE2_NUM_ARC_FIELDS];
        OE2ETFIELD  ChordFields       [OE2_NUM_CHORD_FIELDS];
        OE2ETFIELD  PolyBezierFields  [OE2_NUM_POLYBEZIER_FIELDS];
        OE2ETFIELD  RoundRectFields   [OE2_NUM_ROUNDRECT_FIELDS];
} OE2ETTABLE;

//
//
// MACROS
//
//
//
// #define used to check that there is enough room left in the buffer
// for the encoded data which is about to be copied in.
//
#define ENOUGH_BUFFER(bend, start, datalen)   \
                  ( ((LPBYTE)(start)+(datalen)) <= (bend) )


//
// FUNCTION: OE2GetOrderType
//
// DESCRIPTION:
//
// This function converts the two byte flag used in an ORDER to record the
// type of order into an internal single byte value
//
// PARAMETERS:
//
//  pOrder    -  A pointer to the order
//
// RETURNS:
//
//  The type of the order (internal single byte value - see above)
//
//
BYTE OE2GetOrderType(LPCOM_ORDER  pOrder);

BOOL OE2CanUseDeltaCoords(void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);

void OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                       void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);


//
// FUNCTION: OE2EncodeField
//
// DESCRIPTION:
//
// Convert a field which is an array of 1 or more elements, from its
// encoded form to its decoded form.
//
// PARAMETERS:
//
// pSrc            - Array of source values.
// ppDest          - Array of destination values.
// srcFieldLength  - The size of each of the elements in the source array.
// destFieldLength - The size of each of the elements in the destination
//                   array.
// signedValue     - Is the element a signed value ?
// numElements     - The number of elements in the arrays.
//
// RETURNS:
//
// None.
//
//
void OE2EncodeField(void *    pSrc,
                                 PBYTE*  ppDest,
                                 UINT     srcFieldLength,
                                 UINT     destFieldLength,
                                 BOOL     signedValue,
                                 UINT     numElements);


#endif // _H_OE2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ntddvd40.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    ddvdeo.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Video device.

Author:

    Andre Vachon (andreva) 21-Jan-1992

Revision History:

--*/

//
// VideoIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// Name used to create the miniport logical device names
//

#define VIDEO_DEVICE_NAME "DISPLAY%d"
#define WVIDEO_DEVICE_NAME L"DISPLAY%d"


//
// The first set of IOCTLs are handle by the port driver and never seen
// by the miniport.
//

#define IOCTL_VIDEO_ENABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x00, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_REGISTER_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// All these IOCTL's must be both handled by the port and miniport since
// they require processing by both parties.
//
#define IOCTL_VIDEO_SAVE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x80, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x81, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// All these IOCTL's are public and must/can be handled by the miniport
// driver
//

#define IOCTL_VIDEO_QUERY_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESET_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x104, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOAD_AND_SET_FONT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_PALETTE_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x107, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x108, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10d, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x110, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x111, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x112, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x113, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x114, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_BANK_SELECT_CODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x115, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x116, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x117, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x118, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x119, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11a, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// New IOCTLs defined for product 1.0A
//

#define IOCTL_VIDEO_SET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11c, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11e, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// Many of the video ICOTLs are modal. When ever the palette is set, or the
// cursor is set or queried, it is done for the current mode.
//
// Modal specifies that the operation is only valid within a mode. Once a
// set mode operation is performed, the state associated to the modal IOCTL
// has been destroyed or reinitialized.
// Non-modal IOCTLs have their state preserved across set-mode operations.
//
// Optional IOCTLs are IOCTLs the miniport can optionally support. If the
// miniport does not support the IOCTL, it should return the appropriate
// error status.
// Required IOCTLs must be implemented in a miniport in order for the system
// to system properly.
//
// IOCTL_VIDEO_ENABLE_VDM                       Non-Modal    Private(1)
// IOCTL_VIDEO_DISABLE_VDM                      Non-Modal    Private(1)
// IOCTL_VIDEO_REGISTER_VDM                     Non-Modal    Private(1)
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE              Non-Modal    Required(2)
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE           Non-Modal    Required(2)
//
// IOCTL_VIDEO_QUERY_AVAIL_MODES                Non-Modal    Required
// IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES            Non-Modal    Required
// IOCTL_VIDEO_QUERY_CURRENT_MODE               Modal        Required
// IOCTL_VIDEO_SET_CURRENT_MODE                 Non-Modal    Required
// IOCTL_VIDEO_RESET_DEVICE                     Non-Modal    Required
//
// IOCTL_VIDEO_LOAD_AND_SET_FONT                Modal        Required(2)
//
// IOCTL_VIDEO_SET_PALETTE_REGISTERS            Modal        Required(2)
// IOCTL_VIDEO_SET_COLOR_REGISTERS              Modal        Required(3)
//
// IOCTL_VIDEO_ENABLE_CURSOR                    Modal        Required(2)
// IOCTL_VIDEO_DISABLE_CURSOR                   Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_ATTR                  Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_ATTR                Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_POSITION              Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_POSITION            Modal        Required(2)
//
// IOCTL_VIDEO_ENABLE_POINTER                   Modal        Optional
// IOCTL_VIDEO_DISABLE_POINTER                  Modal        Optional
// IOCTL_VIDEO_SET_POINTER_ATTR                 Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_ATTR               Modal        Optional
// IOCTL_VIDEO_SET_POINTER_POSITION             Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_POSITION           Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES       Non-Modal    Optional
//
// IOCTL_VIDEO_GET_BANK_SELECT_CODE             Modal        Required(2)
//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY                 Special(4)   Required
// IOCTL_VIDEO_UNMAP_VIDEO_MEMORY               Non-Modal    Required
// IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES       Non-Modal    Optional
// IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES        Non-Modal    Optional
//
// IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES         Non-Modal    Optional
//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT             Non-Modal    Optional
// IOCTL_VIDEO_GET_POWER_MANAGEMENT             Non-Modal    Optional

//
// (1) Private means the IOCTL is completely implemeted within the port driver
//     and the miniport does not need to support it.
//
// (2) These Required functions are for "Vga Compatible" miniports. They are
//     Optional for other, non vga-compatible (i.e frame buffers) drivers.
//     VGA compatible means here that the miniport implements all the VGA
//     functionality and that the VgaCompatible flag for the miniport in the
//     registry parameters is turned on.
//
// (3) This IOCTL is required if the device has a color lookup table (also
//     commonly called palette) the PALETTE IOCTL is used for VGA while the
//     COLOR IOCTL is the more general IOCTL that is called by the display
//     driver or application to set the colors in the devices internal
//     lookup table
//
// (4) This IOCTL is both modal and non-modal. It should map all of video
//     memory in the caller's address space. A set mode MUST NOT cause the
//     video memory to change location - in this sense it is non-modal.
//     However, this IOCTL returns the location size of the frame buffer within
//     video memory, and the frame buffer size and location may vary from mode
//     to mode - so that information is modal.
//


//
// Any IOCTL that returns information should return in the status block the
// size of the data returned.
// If the output buffer was too small, an error should be returned.
//
//
//
//



//
// IOCTL_VIDEO_ENABLE_VDM
// IOCTL_VIDEO_DISABLE_VDM
// IOCTL_VIDEO_REGISTER_VDM
//
// These IOCTLs are used to enable or disable a VDM's access to the video
// hardware. This call will cause the real video frame buffer to be mapped
// into the VDM's address space and get the video validator connected to the
// V86 emulator for direct video register access.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_VDM {
    HANDLE ProcessHandle;
} VIDEO_VDM, *PVIDEO_VDM;

//
//ProcessHandle - Handle to the process for which this request must be
//    performed. This is required because the console calls the miniport on
//    the behalf of the VDM process; we are not performing this request in
//    the context of the current caller.
//


typedef struct _VIDEO_REGISTER_VDM {
    ULONG MinimumStateSize;
} VIDEO_REGISTER_VDM, *PVIDEO_REGISTER_VDM;

//
//MinimumStateSize - Output value determining the minimum size required to
//    store the video hardware state when performing SAVE_HARDWARE_SATE or
//    RESTORE_HARDWARE_STATE Ioctls.
//


//
// Second set of structures
//

//
// These IOCTLs are used by the VDM and the console to communicate state
// changes between the VDM and the kernel video driver.
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE -
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE -
//
//
// This structure is at the start of the block used when saving or restoring
// the state of the video hardware using ConsoleHardwareState().
// the ULONG are offset to the location of the rest of the data. That data
// is stored within the same memory block pointed to by the
// VIDEO_HARDWARE_STATE structure, right after this header.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_HARDWARE_STATE_HEADER {
    ULONG Length;
    UCHAR PortValue[0x30];
    ULONG AttribIndexDataState;
    ULONG BasicSequencerOffset;
    ULONG BasicCrtContOffset;
    ULONG BasicGraphContOffset;
    ULONG BasicAttribContOffset;
    ULONG BasicDacOffset;
    ULONG BasicLatchesOffset;
    ULONG ExtendedSequencerOffset;
    ULONG ExtendedCrtContOffset;
    ULONG ExtendedGraphContOffset;
    ULONG ExtendedAttribContOffset;
    ULONG ExtendedDacOffset;
    ULONG ExtendedValidatorStateOffset;
    ULONG ExtendedMiscDataOffset;
    ULONG PlaneLength;
    ULONG Plane1Offset;
    ULONG Plane2Offset;
    ULONG Plane3Offset;
    ULONG Plane4Offset;
    ULONG VGAStateFlags;
    ULONG DIBOffset;
    ULONG DIBBitsPerPixel;
    ULONG DIBXResolution;
    ULONG DIBYResolution;
    ULONG DIBXlatOffset;
    ULONG DIBXlatLength;
} VIDEO_HARDWARE_STATE_HEADER, *PVIDEO_HARDWARE_STATE_HEADER;

//
// defines for VGAStateFlags
//

#define VIDEO_STATE_NON_STANDARD_VGA       0x00000001
#define VIDEO_STATE_UNEMULATED_VGA_STATE   0x00000002
#define VIDEO_STATE_PACKED_CHAIN4_MODE     0x00000004


typedef struct _VIDEO_HARDWARE_STATE {
    PVIDEO_HARDWARE_STATE_HEADER StateHeader;
    ULONG StateLength;
} VIDEO_HARDWARE_STATE, *PVIDEO_HARDWARE_STATE;

//
//Length - Length of the basic structure. Used for versioning purposes. The
//    length field should be initialized to be equal to
//    sizeof(VIDEO_HARDWARE_STATE_HEADER).
//
//PortValue - Array of entries containing the data values for port 3B0 through
//    3DF.
//
//AttribIndexDataState - State of the attribute index register.
//
//BasicSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    sequencer register set of the VGA.
//
//BasicCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    CRT register set of the VGA.
//
//BasicGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    graphics controller register set of the VGA.
//
//BasicAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    attribute controller register set of the VGA.
//
//BasicDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    DAC registers of the VGA.
//
//BasicLatchesOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    latches of the VGA.
//
//ExtendedSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    sequencer register set of the VGA.
//
//ExtendedCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    CRT register set of the VGA.
//
//ExtendedGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    graphics controller register set of the VGA.
//
//ExtendedAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    attribute controller register set of the VGA.
//
//ExtendedDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    DAC registers of the VGA.
//
//ExtendedValidatorStateOffset - Offset, in bytes, from the beginning of the
//    structure, to an area reserved for the miniport to put the unemulated
//    save state that the miniport uses to perform instruction validation for
//    DOS apps.
//
//ExtendedMiscDataOffset - Offset, in bytes, from the beginning of the structure,
//    to an area reserved for the use of the miniport.
//
//PlaneLength - Length of each of the following plane (if present)
//
//Plane1Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the first plane of video memory.
//
//Plane2Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the second plane of video memory.
//
//Plane3Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the third plane of video memory.
//
//Plane4Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the fourth plane of video memory.
//
//VGAStateFlags - Flags used for the interpretation of the VGA state.
//    VIDEO_STATE_NON_STANDARD_VGA is set when the set of registers the VGA
//        returns is not the basic set (all super vga's are not standard).
//        The VDM should not emulate the saved state unless a specific VDD
//        has been written for the device.
//    VIDEO_STATE_UNEMULATED_VGA_STATE specified the miniport has stored
//        informaiton in the ExtendedValidatorState field and the miniport
//        should treat this as a frozen state, whatever the registers say.
//    VIDEO_STATE_PACKED_CHAIN4_MODE indicates that in mode 13 (320x200x256).
//        the data is stored in a packed pixel format in the plane, as
//        opposed to the standard VGA format where the data is interleaved
//        at every four bytes, and on every 16K boundary, offset by one
//        extra byte.
//
//DIBOffset - Offset to the location of the DIB in the allocated data
//        structure. If NULL, no translation is available.
//
//DIBBitsPerPixel - Format of the DIB.
//
//DIBXResolution - Width of the DIB in pixels.
//
//DIBYResolution - Height of the DIB in pixels.
//
//DIBXlatOffset - Offset to the location of the translation vector
//    from DIB pixel values to 32-bit RGB (1 byte red, 1 byte green, 1 byte
//    blue, 1 byte empty). Maximum length 256. If NULL, the standard
//    VGA palette stored in this structure should be used.
//
//DIBXlatLength - Length of the RGB translation vector at DIBXlatOffset.
//
// For each of the offset fields, if an offset value is NULL, then there is
// no data for that offset.
// The length of a data area is:
//   1) the specific length given to it : plane length (planes) or XResolution *
//        Yresolution * BitsPerPel (DIB)
//   2) otherwise, the length = next_non-null_offset_value -
//                                   current_offset_value
//

//
//StateHeader - Pointer to the VIDEO_HARDWARE_STATE_HEADER structure.
//
//StateLength - Size of the VIDEO_HARDWARE_STATE_HEADER structure.
//

//
// IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES - Returns number of different modes
//                                     available on the controller.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_NUM_MODES {
    ULONG NumModes;
    ULONG ModeInformationLength;
} VIDEO_NUM_MODES, *PVIDEO_NUM_MODES;

//
//NumModes - Returns the number of modes supported by the kernel driver.
//
//ModeInformationLength - Length of the VIDEO_MODE_INFORMATION structure
//    for the IOCTL_VIDEO QUERY_AVAILABLE_MODES IOCTL.


//
// IOCTL_VIDEO_SET_CURRENT_MODE - Is used to set the mode of the controller.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_MODE {
    ULONG RequestedMode;
} VIDEO_MODE, *PVIDEO_MODE;

#define VIDEO_MODE_NO_ZERO_MEMORY 0x80000000 // High order bit of the mode
                                             // determines if the set mode
                                             // should (0) or should not (1)
                                             // cause the video memory to be
                                             // zeroed out simultaneously to
                                             // the set mode operation.

#define VIDEO_MODE_MAP_MEM_LINEAR 0x40000000 // Miniports which support this
                                             // flag will set a linear mode
                                             // if possible when this flag
                                             // is set.  Note: Some miniports
                                             // may return a linear mode even
                                             // if this flag is not set.


//
//RequestedMode - Indicates in which mode the adapter should be initialized.
//


//
// IOCTL_VIDEO_RESET_DEVICE - Is used to reset the mode of the adapter when GDI
//                            gives up control of the device to allow a VDM to
//                            access the hardware. x86 only.
//                            The default mode should be whatever is the
//                            default mode when the machine is booted
//
// No information is needed fo this function.
//



//
// IOCTL_VIDEO_QUERY_AVAIL_MODES - Returns information about each available
//                                 mode on the controller.
//
// IOCTL_VIDEO_QUERY_CURRENT_MODE - Returns the information for the current
//                                  controller mode.
//
// Information used by this function is passed using the following structure:
//
// NOTE This structure is matched exactly with the DISP_MODE structure
// in winddi.h - every change to this structure MUST be made to the
// structure in winddi.h.
//

typedef struct _VIDEO_MODE_INFORMATION {
    ULONG Length;
    ULONG ModeIndex;
    ULONG VisScreenWidth;
    ULONG VisScreenHeight;
    ULONG ScreenStride;
    ULONG NumberOfPlanes;
    ULONG BitsPerPlane;
    ULONG Frequency;
    ULONG XMillimeter;
    ULONG YMillimeter;
    ULONG NumberRedBits;
    ULONG NumberGreenBits;
    ULONG NumberBlueBits;
    ULONG RedMask;
    ULONG GreenMask;
    ULONG BlueMask;
    ULONG AttributeFlags;
    ULONG VideoMemoryBitmapWidth;
    ULONG VideoMemoryBitmapHeight;
    ULONG DriverSpecificAttributeFlags;
} VIDEO_MODE_INFORMATION, *PVIDEO_MODE_INFORMATION;

//
// Bit definitions for Attribute Flags
//

#define VIDEO_MODE_COLOR            0x0001  // 0 = Mono-compatible, 1 = Color
#define VIDEO_MODE_GRAPHICS         0x0002  // 0 = Text mode, 1 = Graphics
#define VIDEO_MODE_PALETTE_DRIVEN   0x0004  // 0 = Colors are direct
                                            // 1 = Colors are index to a palette
#define VIDEO_MODE_MANAGED_PALETTE  0x0008  // 0 = Palette is fixed (must be
                                            //     queried from miniport
                                            // 1 = Palette is settable.
#define VIDEO_MODE_INTERLACED       0x0010  // 1 = Mode is interlaced
                                            // 0 = non-interlaced
#define VIDEO_MODE_NO_OFF_SCREEN    0x0020  // 1 = Offscreen memory CAN NOT be
                                            //     used to store information.
                                            // 0 = Offscreen memory is available
#define VIDEO_MODE_NO_64_BIT_ACCESS 0x0040  // 1 = 64 bit memory writes to frame
                                            //     buffer are not handled properly.
                                            // 0 = 64 bit memory writes to frame
                                            //     buffer are handled properly.

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//ModeIndex - Number used to set this mode when calling the miniport driver.
//
//VisScreenWidth - Number of visible horizontal pixels on a scan line
//
//VisScreenHeight - Number of visible lines (or scan lines)
//
//ScreenStride - Delta, in *BYTES*, between the start of two scan lines.
//
//    NOTE: the width and height are in pixels, but the stride is in bytes !!!
//
//NumberOfPlanes - Number of separate planes combined by the device.
//
//BitsPerPlane - Number of bits per pixel on a plane.
//
//Frequency - Screen Frequency, in Hertz.
//
//XMillimeter - Size of the horizontal active region on the output device,
//    in millimeters.
//
//YMillimeter - Size of the vertical active region on the output device,
//    in millimeters.
//
//NumberRedBits - Number of bits in the red DAC.
//
//NumberGreenBits - Number of bits in the green DAC.
//
//NumberBlueBits - Number of bits in the blue DAC.
//
//RedMask - Red color Mask for device with direct color modes. Bits turned
//    on indicate the bit is of color Red.
//
//GreenMask - Green color Mask for device with direct color modes. Bits
//    turned on indicate the bit is of color Green.
//
//BlueMask - Blue color Mask for device with direct color modes. Bits
//    turned on indicate the bit is of color Blue.
//
//AttributeFlags. Flags indicating certain behavior for the device.
//
//VideoMemoryBitmapWidth - Width of the video memory bitmap.
//    VisScreenWidth <= VideoMemoryBitmapWidth <= ScreenStride
//
//VideoMemoryBitmapHeight - Height of the video memory bitmap.
//   VisScreenHeight <= VideoMemoryBitmapHeight = VideoRamLength / ScreenStride
//
//DriverSpecificAttributeFlags - Flags indicating certain behavior for the
//   device that are private to the miniport\display driver.
//


//
// IOCTL_VIDEO_LOAD_AND_SET_FONT - Is used to load a user-defined font.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_LOAD_FONT_INFORMATION {
    USHORT WidthInPixels;
    USHORT HeightInPixels;
    ULONG FontSize;
    UCHAR Font[1];
} VIDEO_LOAD_FONT_INFORMATION, *PVIDEO_LOAD_FONT_INFORMATION;

//
//WidthInPixels - Width of the characters in the font, in pixels.
//
//HeigthInPixels - Heigth of the characters in the font, in pixels.
//
//FontSize - Size of the font buffer being passed in, in bytes.
//
//Font - Start of the font buffer.
//


//
// IOCTL_VIDEO_SET_PALETTE_REGISTERS - Takes buffer containing
//                                     VIDEO_PALETTE_DATA where Colors[]
//                                     specifies the array containing the
//                                     color values for the palette registers.
//
// Information used by this function is passed using the following structure:
//
// NOTE: This should only be used by the VGA type drivers
//

typedef struct _VIDEO_PALETTE_DATA {
    USHORT NumEntries;
    USHORT FirstEntry;
    USHORT Colors[1];
} VIDEO_PALETTE_DATA, *PVIDEO_PALETTE_DATA;

//
//NumEntries - Number of entries in the array of color values.
//
//FirstEntry - Location in the device palette to which the first entry in the
//    list of colors should be copied to. The other entries in the color list
//    should be copied sequentially, from this starting point into the device's
//    palette.
//
//Colors - Array of color entries to copy into the device's color palette.
//

//
// IOCTL_VIDEO_SET_COLOR_REGISTERS - Takes buffer containing VIDEO_CLUT.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_CLUTDATA {
    UCHAR Red;
    UCHAR Green;
    UCHAR Blue;
    UCHAR Unused;
} VIDEO_CLUTDATA, *PVIDEO_CLUTDATA;

//
//Red - Bits to be put in the Red portion of the color registers.
//
//Green - Bits to be put in the Green portion of the color registers.
//
//Blue - Bits to be put in the Blue portion of the color registers.
//

typedef struct {
    USHORT   NumEntries;
    USHORT   FirstEntry;
    union {
        VIDEO_CLUTDATA RgbArray;
        ULONG RgbLong;
    } LookupTable[1];
} VIDEO_CLUT, *PVIDEO_CLUT;

//
//NumEntries - Number of entries in the LookupTable of color values.
//
//FirstEntry - Location in the device palette to which the first entry in the
//    LookupTable of colors should be copied to. The other entries in the
//    LookupTable should be copied sequentially, from this starting point into
//    the device's palette.
//
//LookupTable - Array of color entries to copy into the device's color
//    registers/palette. The color entries can be accessed as a genric 32 bit
//    value or as Red/Green/Blue/Unused fields.
//

//
// NOTE: Cursor vs. Pointer:
//    A cursor is a rectangular set of pixels which are used to indicate the
//    location of input coming from the keyboard.
//
//    A pointer is the set of pixels that are used to paint the shape
//    associated with the mouse.
//

//
// IOCTL_VIDEO_QUERY_CURSOR_POSITION - Returns the location of the cursor on
//                                     the screen.
//
// IOCTL_VIDEO_SET_CURSOR_POSITION - Is used to set the location of the
//                                   cursor on the screen.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_CURSOR_POSITION {
    SHORT Column;
    SHORT Row;
} VIDEO_CURSOR_POSITION, *PVIDEO_CURSOR_POSITION;

//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//


//
// IOCTL_VIDEO_QUERY_CURSOR_ATTR - Returns all attributes of the cursor.
//
// IOCTL_VIDEO_SET_CURSOR_ATTR - Is used to set the attributes of the cursor.
//
// Information used by this function is passed using the following structure:
//

//
// For the VGA:
// TopScanLine will be stored in the height when an IOCTL is made
// BottomScanLine will be stored in the width when an IOCTL is made
//

typedef struct _VIDEO_CURSOR_ATTRIBUTES {
    USHORT Width;
    USHORT Height;
    SHORT Column;
    SHORT Row;
    UCHAR Rate;
    UCHAR Enable;
} VIDEO_CURSOR_ATTRIBUTES, *PVIDEO_CURSOR_ATTRIBUTES;

//
//Width - Width of the cursor, in pixels.
//
//Height - Height of the cursor, in scans.
//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//
//Rate - Rate at which the cursor whould flash.
//
//Enable - Non-zero to display cursor, 0 not to display.
//

//
// IOCTL_VIDEO_QUERY_POINTER_POSITION - Returns the location of the pointer
//                                      on the screen
//
// IOCTL_VIDEO_SET_POINTER_POSITION - Is used to set the location of the
//                                    pointer on the screen.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_POINTER_POSITION {
    SHORT Column;
    SHORT Row;
} VIDEO_POINTER_POSITION, *PVIDEO_POINTER_POSITION;

//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//


//
// IOCTL_VIDEO_QUERY_POINTER_ATTR - Returns all attributes of the pointer.
//
// IOCTL_VIDEO_SET_POINTER_ATTR - Is used to set the attributes of the
//                                pointer.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_POINTER_ATTRIBUTES {
    ULONG Flags;
    ULONG Width;
    ULONG Height;
    ULONG WidthInBytes;
    ULONG Enable;
    SHORT Column;
    SHORT Row;
    UCHAR Pixels[1];
} VIDEO_POINTER_ATTRIBUTES, *PVIDEO_POINTER_ATTRIBUTES;

//
//Flags - color or mono pointer, same as for query pointer capabilities.
//
//Width - Width of the pointer, in pixels.
//
//Height - Height of the pointer, in scans.
//
//WidthInBytes - Width of the pointer, in bytes.
//
//Enable - Non-zero to display pointer, 0 not to display.
//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//
//Pixels - Start of pointer data, in device-compatible DIB format.
//    (Mask data is always in 1-bpp DIB format.)
//


//
// IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES - Returns capabilities of miniport
//                                          hardware cursor
//

typedef struct _VIDEO_POINTER_CAPABILITIES {
    ULONG Flags;
    ULONG MaxWidth;
    ULONG MaxHeight;
    ULONG HWPtrBitmapStart;
    ULONG HWPtrBitmapEnd;
} VIDEO_POINTER_CAPABILITIES, *PVIDEO_POINTER_CAPABILITIES;

//
// Flag bit definitions
//

#define VIDEO_MODE_ASYNC_POINTER  0x01 // 1 if the cursor can be updated
                                       // asynchronously to drawing operations.
#define VIDEO_MODE_MONO_POINTER   0x02 // 1 if a monochrome hardware pointer
                                       // is supported.
#define VIDEO_MODE_COLOR_POINTER  0x04 // 1 if a color hardware pointer is
                                       // supported.
#define VIDEO_MODE_ANIMATE_START  0x08 // The pointer being passed down has
#define VIDEO_MODE_ANIMATE_UPDATE 0x10 // the same hotspot as the previous
                                       // pointer

//
//MaxWidth - Widest pointer bitmap the miniport should be requested to load
//    for either monochrome or color pointer.
//
//MaxHeight - widest pointer bitmap the miniport should be requested to load
//    for either monochrome color pointer handled.
//
//HWPtrBitmapStart = first offset in bitmap of memory used to store hardware
//    pointer bitmap, in CPU-addressable units (-1 if not applicable). For
//    planar modes (like VGA mode 12h), this is a planar offset; for linear
//    modes (like VGA mode 13h), this is a linear offset. The CPU-addressable
//    translation in HC planar mode is assumed to be linearaddress/4,
//    because there are four planes at each address.
//
//HWPtrBitmapEnd = last offset in bitmap of memory used to store hardware
//    pointer bitmap (-1 if not applicable).
//
// Note: Miniport has options to reject any call to set a pointer.
//


//
// IOCTL_VIDEO_GET_BANK_SELECT_CODE - Called by the Windows display driver
//                                    to get a block of executable code used
//                                    to perform bank-switching in high
//                                    resolution SVGA drivers.
//
// Gets information needed to implement banking control for a selected mode.
//
// Information used by this function is passed using the following structures:
//

//
// The input from the caller in the input buffer is a VIDEO_MODE structure, as
// described under IOCTL_VIDEO_SET_CURRENT_MODE.
//
// RequestedMode - mode index for which banking information is desired.
//

//
// Returned in output buffer.
//

typedef struct _VIDEO_BANK_SELECT {
    ULONG Length;
    ULONG Size;
    ULONG BankingFlags;
    ULONG BankingType;
    ULONG PlanarHCBankingType;
    ULONG BitmapWidthInBytes;
    ULONG BitmapSize;
    ULONG Granularity;
    ULONG PlanarHCGranularity;
    ULONG CodeOffset;
    ULONG PlanarHCBankCodeOffset;
    ULONG PlanarHCEnableCodeOffset;
    ULONG PlanarHCDisableCodeOffset;
} VIDEO_BANK_SELECT, *PVIDEO_BANK_SELECT;

//
// Stored in the BankType and PlanarHCBankintType fields
//

typedef enum _VIDEO_BANK_TYPE {
    VideoNotBanked = 0,
    VideoBanked1RW,
    VideoBanked1R1W,
    VideoBanked2RW,
    NumVideoBankTypes
} VIDEO_BANK_TYPE, *PVIDEO_BANK_TYPE;

//
// Defines for BankingFlags.
//

#define PLANAR_HC               0x00000001

//
//Note: planar high-color ("planar HC") mode is a special 8-bpp-and-up
//    CPU addressing mode in which four bytes can be accessed at
//    once by using the VGA's planar hardware.  This mode is enabled
//    by turning off the Chain4 bit (bit 3 in Sequence Controller
//    register 4), so it is also known as non-Chain4 mode.  Planar HC
//    mode can greatly accelerate operations such as solid fills,
//    some pattern fills, and some blits.
//
//Note: the term "CPU-addressable bytes" means offsets measured
//    in bytes as accessed by the CPU.  In 16-color modes, this
//    merely means "measured in bytes" rather than "measured in
//    pixels," where each byte contains 8 pixels, as usual.
//    In normal high-color modes, "CPU-addressable bytes"
//    is exactly what you'd expect; it's the number of pixels in 256
//    color modes, pixels*2 in 16-bpp modes, and so on.  However, in
//    planar HC modes, there are four display memory bytes at every CPU-
//    addressable byte, because four planes are at each address, so
//    in 256 color modes the number of CPU-addressable bytes is
//    pixels/4, in 16-bpp modes CPU-addressable bytes = pixels/2, and
//    so on.  Basically, "CPU-addressable bytes" just means the
//    offsets the CPU needs to address banks properly in the
//    specified mode.
//
//Note: the start address must be set to 0 (displayed pixels must
//    start at offset 0 in display memory), and the banking windows
//    must fit within the 64K area starting at A000:0; no 128K
//    mappings, please, because there may be a monochrome adapter
//    in the system.
//
//Length - Length of the basic structure. Used for versioning by checking the
//    Length of the struct is at least as large as the value given by sizeof().
//
//Size - number of bytes required to hold all banking information for
//    this mode, including the VIDEO_BANK_SELECT structure and all
//    bank-switch code.  This is the size of the buffer that
//    VgaGetBankSelectCode requires in order properly to return info.
//
//BankingFlags - indicate the type of banking supported in this mode.
//    PLANAR_HC - if set, indicates that planar high-color (HC) mode
//          (non-Chain4 8-, 15-, 16-, 24-, and 32-bpp) is supported.
//          If this bit is set, the following fields must be filled in:
//              PlanarHCGranularity, pPlanarHCBankCode,
//              pPlanarHCEnableCode, pPlanarHCDisableCode.
//          This bit is ignored by the 16-color driver, as are the
//          associated fields.
//
//BankingType - These are the banking types supported by the adapter
//    when it is ina standard mode.
//
//    VideoNotBanked - this mode does not support or require banking.
//    VideoBanked1RW - this mode supports a single RW (readable and
//        writable) banking window.  The window is assumed to be
//        64K in size.
//    VideoBanked1R1W - this mode supports a single window, but the
//        window can be mapped to different areas of display memory
//        for reads and for writes.  The window is assumed to be
//        64K in size.
//    VideoBanked2RW - this mode supports two independently mappable
//        banking windows, each RW.  Each window is assumed to be
//        32K in size.  The second window is assumed
//        to start immediately after the end of the first, at
//        A000:8000.
//
//PlanarHCBankingType - These are the banking types supported by the
//    adapter when it is in a PLANAR HC mode.
//
//    See BankingType for defintions of each banking type.
//
//
//BitmapWidthInBytes - distance from start of one scan line to start
//    of next, counted in CPU-addressable bytes (not pixels).  The
//    CPU-addressable distance from one scan line to the next is
//    assumed to be BitmapWidthInBytes/4 in planar HC modes, because
//    there are four planes at each address.
//
//BitmapSize - size of display memory in CPU-addressable bytes (for
//    example, 256K on a 1 Mb SVGA in 16-color mode, because there
//    are four bytes at each address).  The CPU-addressable bitmap
//    size is assumed to be BitmapSize/4 in planar HC modes, because
//    there are four planes at each address.
//
//Granularity - granularity with which display memory may be mapped
//    into a banking window.  (That is, resolution with which the
//    display memory address mapped to the start of a window may be
//    set; anywhere from 1K to 64K, depending on the adapter.  If
//    Granularity < window size (either 64K or 32K), then adjacent
//    banks can overlap, and broken rasters can always be avoided.
//    If Granularity == window size, then banks are disjoint, and
//    display memory is basically segmented into banks.)  Granularity
//    is measured in CPU-addressable bytes.
//
//PlanarHCGranularity - granularity with which display memory may be
//    mapped into a banking window in planar HC mode.
//    PlanarHCGranularity is measured in CPU-addressable bytes, and
//    is typically but not always Granularity/4.  Ignored in
//    16-color modes.
//
//CodeOffset - base of the code section in the structure.
//
//PlanarHCBankCodeOffset - offset from Code of executable code
//    that performs planar HC mode bank switching.  Ignored in
//    16-color modes.
//
//PlanarHCEnableCodeOffset - offset from Code of executable code
//    that enables planar HC mode.  Ignored in 16-color modes.
//
//PlanarHCDisableCodeOffset - offset from Code of executable code
//    that disables planar HC mode.  Ignored in 16-color modes.
//
//Specification for bank switch code at Code:
//    Executes requested bank mappings.
//
//    Input:
//      EAX = bank number to which to map window #0
//      EDX = bank number to which to map window #1
//      interpreted according to BankingType as follows:
//        VideoBanked1RW - the single window is mapped to bank EAX,
//            EBX is ignored.
//        VideoBanked1RW - the read window is mapped to bank EAX,
//            the write window is mapped to bank EBX
//        VideoBanked1R1W - the window at A000:0 is mapped to bank EAX,
//            the window at A800:0 is mapped to bank EBX
//
//    Output: none
//
// Note: the definition of "bank n" is the bank that starts at
//    display memory offset Granularity*n.  In other words,
//    banks are assumed to start every Granularity CPU-addressable
//    bytes, and are numbered from 0 to number of banks-1.
//
//Specification for planar HC executable code:
//    ***To be filled in when we get to planar HC modes***
//


//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY - Maps the frame buffer into the callers
//                                address space.
// IOCTL_VIDEO_UNMAP_VIDEO_MEMORY - Unmaps the frame buffer from the callers
//                                  address space.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_MEMORY {
    PVOID RequestedVirtualAddress;
} VIDEO_MEMORY, *PVIDEO_MEMORY;

//
//RequestedVirtualAddress - For MAP: Requested virtual address for the video
//    memory. This value is optional. If zero is specified, the operating
//    system will choose an appropriate location.  For UNMAP: Virtual Address
//    of the base of video memory. The size is implicit since it can not
//    change (you can not add video memory dynamically!).
//

// IOCTL_VIDEO_SHARE_VIDEO_MEMORY - Maps the frame buffer to another process'
//                                  address space.  This IOCTL is initally
//                                  defined to support DCI.
// IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY - Unmaps a previously shared buffer.
//
// Note: for the MAP_VIDEO_MEMORY_IOCTL, the process handle is passed in
// the VirtualAddress filed, while for this IOCTL the handle is explicit.
//

typedef struct _VIDEO_SHARE_MEMORY {
    HANDLE ProcessHandle;
    ULONG ViewOffset;
    ULONG ViewSize;
    PVOID RequestedVirtualAddress;
} VIDEO_SHARE_MEMORY, *PVIDEO_SHARE_MEMORY;

typedef struct _VIDEO_SHARE_MEMORY_INFORMATION {
    ULONG SharedViewOffset;
    ULONG SharedViewSize;
    PVOID VirtualAddress;
} VIDEO_SHARE_MEMORY_INFORMATION, *PVIDEO_SHARE_MEMORY_INFORMATION;


//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY - Returns the virtual address and size of
//                                the frame buffer and video memory in the
//                                caller's address space.
//                                This IOCTL must be called after a call
//                                to the MAP IOCTL has been made.
//

typedef struct _VIDEO_MEMORY_INFORMATION {
    PVOID VideoRamBase;
    ULONG VideoRamLength;
    PVOID FrameBufferBase;
    ULONG FrameBufferLength;
} VIDEO_MEMORY_INFORMATION, *PVIDEO_MEMORY_INFORMATION;

//
//VideoRamBase - Virtual address of the Video RAM in the callers address space
//    (only valid if the memory is mapped.
//
//VideoRamLength - Linear length of the Video RAM in the caller's virtual
//    address space (memory accessible through a bank switch mechanism is not
//    described by this value).
//    This value must be equal to VideoMemoryBitmapHeight * ScreenStride
//
//FrameBufferBase - Virtual address of the Frame Buffer in the caller's
//    address space. The Frame buffer is the actively displayed part of Video
//    Ram.
//
//FrameBufferLength - Linear length of the Frame Buffer in the caller's
//    virtual address space (memory accessible through a bank switch mechanism
//    is not described by this value).
//    This value must be equal to VisScreenWidth * ScreenStride
//


//
// IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES - Returns the access range used to
//                                          program the hardware directly.
//                                          An array of these is returned if
//                                          multiple ranges exist.
//
// IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES - Frees up the access ranges that were
//                                         allocated by the QUERY_ACCESS_RANGES
//                                         call.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_PUBLIC_ACCESS_RANGES {
    ULONG InIoSpace;
    ULONG MappedInIoSpace;
    PVOID VirtualAddress;
} VIDEO_PUBLIC_ACCESS_RANGES, *PVIDEO_PUBLIC_ACCESS_RANGES;

//
//InIoSpace - Indicates if the hardware registers or ports are in IO space
//    or in memory space.
//
//MappedInIoSpace - Indicates if under the current platform the registers or
//    ports are mapped in IO Space or memory space.
//
//VirtualAddress - Location of the registers or IO ports as mapped under the
//    current architecture.
//


//
// IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES - Returns the color information
//                                        found in the monitors VDDPs
//                                        description file.
//
// NOTE: This structure must be filled out completely. A subset of the
//         values can not be returned.
//

typedef struct _VIDEO_COLOR_CAPABILITIES {
    ULONG Length;
    ULONG AttributeFlags;
    LONG  RedPhosphoreDecay;
    LONG  GreenPhosphoreDecay;
    LONG  BluePhosphoreDecay;
    LONG  WhiteChromaticity_x;
    LONG  WhiteChromaticity_y;
    LONG  WhiteChromaticity_Y;
    LONG  RedChromaticity_x;
    LONG  RedChromaticity_y;
    LONG  GreenChromaticity_x;
    LONG  GreenChromaticity_y;
    LONG  BlueChromaticity_x;
    LONG  BlueChromaticity_y;
    LONG  WhiteGamma;
    LONG  RedGamma;
    LONG  GreenGamma;
    LONG  BlueGamma;
} VIDEO_COLOR_CAPABILITIES, *PVIDEO_COLOR_CAPABILITIES;

//
// Flag Bit definitions
//

#define VIDEO_DEVICE_COLOR          0x1   // Is this device support color (1)
                                          // or monochrome only
#define VIDEO_OPTIONAL_GAMMET_TABLE 0x2   // Indicates that a gammet table can
                                          // be queried/set for the device
                                          // use other IOCTLs for that purpose.
//
//Length - Length of the basic structure. Used for versioning by checking the
//    Length of the struct is at least as large as the value given by sizeof().
//
//AttributesFlag - List of falgs determining some of the properties of the
//    device.
//
//See the VDDP documentation for the details on the various fields
//
//RedPhosphoreDecay
//GreenPhosphoreDecay
//BluePhosphoreDecay -
//
//WhiteChromaticity_x
//WhiteChromaticity_y
//WhiteChromaticity_Y -
//
//RedChromaticity_x
//RedChromaticity_y
//GreenChromaticity_x
//GreenChromaticity_y
//BlueChromaticity_x
//BlueChromaticity_y -
//
//WhiteGamma -
//
//RedGamma
//GreenGamma
//BlueGamma -
//
//All values returned in this structure are integers.
//The values returned must be floating point values * 10,000; i.e:
//a gamma of 2.34 would be returned as 23400.
//



//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT - Tells the device to change the power
//                                    consumption level of the device to the
//                                    new state.
// IOCTL_VIDEO_GET_POWER_MANAGEMENT - Return the current power consumption
//                                    level of the device.
//
// NOTE:
// This IOCTL is based on the VESA DPMS proposal.
// Changes to the DPMS standard will be refelcted in this IOCTL.
//

typedef enum _VIDEO_POWER_STATE {
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;


typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//DPMSVersion - Version of the DPMS standard supported by the device.
//              Only used in the "GET" IOCTL.
//
//PowerState - One of the power states listed in VIDEO_POWER_STATE.
//

//
// Note:
// Once the power has been turned off to the device, all other IOCTLs made
// to the miniport will be intercepted by the port driver and will return
// failiure, until the power on the device has been turned back on.
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\osi.h ===
//
// OS Isolation (BOGUS!)
//

#ifndef _H_OSI
#define _H_OSI


//
// Control for shared code
//


//
// Maximum number of entries in a palette.
//
#define OSI_MAX_PALETTE             256


// Structure: OSI_ESCAPE_HEADER
//
// Description: Structure common to all display driver requests.  These
// fields are checked before the Display Driver will attempt to process the
// request.
//
typedef struct tagOSI_ESCAPE_HEADER
{
    DWORD       padding;        // For faulty drivers
    DWORD       identifier;     // Unique identifier for all our requests.
    DWORD       escapeFn;       // Function to be processed.  In the case
                                // of ESC_QUERYSUPPORT, this is the ID
                                // of the function to be queried.
    DWORD       version;        // Version #
}
OSI_ESCAPE_HEADER;
typedef OSI_ESCAPE_HEADER FAR * LPOSI_ESCAPE_HEADER;


//
// Unique identifier for all our requests
//
#define OSI_ESCAPE_IDENTIFIER   0xED3B12DC

//
// Unique escape code for all our specific requests.
//
#define OSI_ESC_CODE            31170


//
// Internal Windows NT Escape Function WNDOBJ_SETUP.  This is the Escape
// code that must be called in order for the Display Driver to be allowed
// to call EngCreateWindow.  Unfortunately, it is defined in winddi.h,
// which can't be included in User-mode compilations.
//
// I define it here: if it changes in winddi.h, this line will fail to
// compile in a Display Driver compilation.
//
#define WNDOBJ_SETUP    4354        // for live video ExtEscape


//
// Allowed ranges of escape functions
//
#define OSI_ESC_FIRST           0
#define OSI_ESC_LAST            0xFF

#define OSI_OE_ESC_FIRST        0x100
#define OSI_OE_ESC_LAST         0x1FF

#define OSI_HET_ESC_FIRST       0x200
#define OSI_HET_ESC_LAST        0x2FF

#define OSI_SBC_ESC_FIRST       0x400
#define OSI_SBC_ESC_LAST        0x4FF

#define OSI_HET_WO_ESC_FIRST    0x500
#define OSI_HET_WO_ESC_LAST     0x5FF

#define OSI_SSI_ESC_FIRST       0x600
#define OSI_SSI_ESC_LAST        0x6FF

#define OSI_CM_ESC_FIRST        0x700
#define OSI_CM_ESC_LAST         0x7FF

#define OSI_OA_ESC_FIRST        0x800
#define OSI_OA_ESC_LAST         0x8FF

#define OSI_BA_ESC_FIRST        0x900
#define OSI_BA_ESC_LAST         0x9FF


//
// Specific values for OSI escape codes
//
#define OSI_ESC(code)                   (OSI_ESC_FIRST + code)

#define OSI_ESC_INIT                    OSI_ESC(0)
#define OSI_ESC_TERM                    OSI_ESC(1)
#define OSI_ESC_SYNC_NOW                OSI_ESC(2)



//
// Used to determine if our driver is around, hosting is possible, and to
// returned mapped shared memory if so after initializing.
//

#define SHM_SIZE_USED   (sizeof(SHM_SHARED_MEMORY) + 2*sizeof(OA_SHARED_DATA))

#define SHM_MEDIUM_TILE_INDEX       0
#define SHM_LARGE_TILE_INDEX        1
#define SHM_NUM_TILE_SIZES          2

typedef struct tagOSI_INIT_REQUEST
{
    OSI_ESCAPE_HEADER   header;
    DWORD               result;
    LPVOID              pSharedMemory;
    LPVOID              poaData[2];

    DWORD               sbcEnabled;
    LPVOID              psbcTileData[SHM_NUM_TILE_SIZES];
    DWORD               aBitmasks[3];
} OSI_INIT_REQUEST;
typedef OSI_INIT_REQUEST FAR* LPOSI_INIT_REQUEST;


//
// Used when shutting down to cleanup any allocated objects and memory
//
typedef struct tagOSI_TERM_REQUEST
{
    OSI_ESCAPE_HEADER   header;
} OSI_TERM_REQUEST;
typedef OSI_TERM_REQUEST FAR* LPOSI_TERM_REQUEST;



#ifdef DLL_DISP


#ifndef IS_16
//
// We have a circular structure dependency, so prototype the necessary data
// here.
//
typedef struct tagOSI_DSURF OSI_DSURF;



//
// Tag used to identify all memory allocated by the display driver.
//
#define OSI_ALLOC_TAG     'DDCD'


// Structure: OSI_PDEV
//
// Description:
//
// Contents of our private data pointer; GDI always passes this to us on
// each call to the display driver. This structure is initialized in
// DrvEnablePDEV handling.
//
typedef struct  tagOSI_PDEV
{
    //
    // Rendering extensions colour information.
    //
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen
    OSI_DSURF*  pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cBitsPerPel;            // Bits per pel (8,15,16,24,32,etc)
        // This is only 8 or 24 on NT 5.0!

    //
    // Color/pixel format
    //
    ULONG       iBitmapFormat;          // Current colour depth as defined
    FLONG       flRed;                  // Red mask for bitmask modes
    FLONG       flGreen;                // Green mask for bitmask modes
    FLONG       flBlue;                 // Blue mask for bitmask modes                                        // by the BMF_xBPP flags.

    //
    // Palette stuff
    //
    HPALETTE    hpalCreated;            // For NT 5.0 we have to return a palette
    PALETTEENTRY* pPal;                 // The palette if palette managed
    BOOL        paletteChanged;         // Set whenever the palette is
                                        //   changed.
}
OSI_PDEV;
typedef OSI_PDEV FAR * LPOSI_PDEV;


// Structure: OSI_DSURF
//
// Description:
//
// Surface specific information.  We need this structure to pass on to
// EngCreateSurface() during initializtion.  We ignore it subsequently.
//
typedef struct tagOSI_DSURF
{
    SIZEL     sizl;         // Size of the original bitmap
    LPOSI_PDEV ppdev;        // Pointer to the assocaited PDEV

}
OSI_DSURF;
typedef OSI_DSURF FAR * LPOSI_DSURF;



void OSI_DDInit(LPOSI_PDEV, LPOSI_INIT_REQUEST);
void OSI_DDTerm(LPOSI_PDEV);
#else
void OSI_DDTerm(void);
#endif // !IS_16

#else

//
// Used for other desktops thread.
//
enum
{
    OSI_WM_SETGUIEFFECTS = WM_USER,
    OSI_WM_DESKTOPREPAINT,
    OSI_WM_DESKTOPSWITCH,
    OSI_WM_MOUSEINJECT,
    OSI_WM_KEYBDINJECT,
    OSI_WM_INJECTSAS
};

#endif // DLL_DISP


//
// OSI_Load()
// Called when nmas.dll is first loaded.
//
void    OSI_Load(void);


//
// OSI_Unload()
// Called when nmas.dll is unloaded.
//
void    OSI_Unload(void);




//
// OSI_Init()
// Called when app sharing initializes in its service thread.  We determine
// if we can host, and get hold of buffers, data structures, etc. needed
// for hosting if so.
//
// Returns FALSE on severe failure.  The display driver on NT not being
// present isn't failure.  The graphic patches on Win95 not being safe isn't
// failure either.  In those two cases, AS will simply mark itself as
// unable to host, but can view fine.
//
void    OSI_Init(void);

//
// OSI_Term()
// Called when app sharing deinitializes in its service thread.
//
void    OSI_Term(void);


//
// OSI_FunctionRequest()
// Used to communicate with the display driver piece, the part which tracks
// graphical output in shared apps on the screen.
//
BOOL    OSI_FunctionRequest(DWORD functionId, LPOSI_ESCAPE_HEADER pRequest, DWORD requestLen);


// NT only!
void OSI_InitDriver50(BOOL fInit);

// NT only!
void OSI_RepaintDesktop(void);

// NT only!
void OSI_SetGUIEffects(BOOL fOff);

// NT only!
void WINAPI OSI_SetDriverName(LPCSTR szDriverName);


#ifdef DLL_DISP


#ifdef IS_16
BOOL    OSI_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
ULONG   OSI_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

BOOL    OSIInitializeMode(const GDIINFO* pGdiRequested, const DEVMODEW* pdmRequested,
    LPOSI_PDEV ppdev, GDIINFO* pgdiReturn, DEVINFO* pdiReturn);    

#endif // !IS_16



#endif // DLL_DISP

#endif // _H_OSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\resource.h ===
//
// Resource header
//


//
// Menus
//
#define IDM_FRAME                       100
    #define IDSM_CONTROL                  0
    #define IDSM_VIEW                     1
    #define IDSM_WINDOW                   2
    #define IDSM_HELP                     3
    
  

//
// Commands
//

// CONTROL
#define POS_CONTROLCMD                    0
#define POS_FORWARDCONTROLCMD             1

#define CMD_TOPMOST                     100
#define CMD_TAKECONTROL                 101
#define CMD_RELEASECONTROL              102
#define CMD_CANCELCONTROL               103
#define CMD_CTRLALTDEL                  104
#define CMD_VIEWSTATUSBAR               105
#define CMD_VIEWWINDOWBAR               106
#define CMD_VIEWFULLSCREEN              107
#define CMD_HELPTOPICS                  108
#define CMD_HELPABOUT                   109



// WINDOW
#define CMD_APPSTART                   1000
#define CMD_APPMAX                     5000

#define CMD_FORWARDCONTROLSTART        5000
#define CMD_FORWARDCONTROLMAX         10000



//
// STRINGS
// CVRTRES can't handle enum types, what a pain.
//

#define IDS_ABOUT                         1     // NO REAL STRING
#define IDS_RESTORE                       2

#define IDS_FONT_CURSORTAG              100

#define IDS_TITLE_SHAREDPROGRAMS        101
#define IDS_TITLE_SHAREDDESKTOP         102
#define IDS_TITLE_CONTROLLABLE          103
#define IDS_TITLE_INCONTROL             104

#define IDS_CMD_CTRLALTDEL              110
#define IDS_CMD_TAKECONTROL             111
#define IDS_CMD_CANCELCONTROL           112
#define IDS_CMD_RELEASECONTROL          113
#define IDS_CMD_BLANKPROGRAM            114

#define IDS_HIDDEN_WINDOW               115
#define IDS_NOTHING                     116
#define IDS_DESKTOP                     117
#define IDS_DESKTOP_LOWER               118
#define IDS_PROGRAMS                    119
#define IDS_PROGRAMS_LOWER              120
#define IDS_NOTINCALL                   121
#define IDS_SHARING_FORMAT              122
#define IDS_TOPMOST                     123

#define IDS_ALLOWCONTROL                124
#define IDS_PREVENTCONTROL              125
#define IDS_MSG_TOPREVENTCONTROL        126
#define IDS_MSG_TOALLOWCONTROL          127

#define IDS_STATUS_NONE                   0
#define IDS_STATUS_WAITINGFORCONTROL    150
#define IDS_STATUS_CONTROLPAUSED        151

//
// Inform dialog 
// NOTE:  Keep these in same order as CARESULT_ values
//
#define IDS_TITLE_TAKECONTROL_FAILED            200
#define IDS_ERR_TAKECONTROL_MIN                 200
#define IDS_ERR_TAKECONTROL_FIRST               202
#define IDS_ERR_TAKECONTROL_FAILED_BUSY         202
#define IDS_ERR_TAKECONTROL_FAILED_USER         203
#define IDS_ERR_TAKECONTROL_FAILED_WRONGSTATE   204
#define IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT     205
#define IDS_ERR_TAKECONTROL_LAST                IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT


//
// Query dialogs
//
#define IDS_TITLE_QUERY_TAKECONTROL             250
#define IDS_MSG_QUERY_TAKECONTROL               251
#define IDS_TITLE_QUERY_GIVECONTROL             252
#define IDS_MSG_QUERY_GIVECONTROL               253
#define IDS_TITLE_QUERY_FORWARDCONTROL          254
#define IDS_MSG_QUERY_FORWARDCONTROL            255
#define IDS_TITLE_QUERY_YIELDCONTROL            256
#define IDS_MSG_QUERY_YIELDCONTROL              257


//
// Add this to CMD id above & get status bar string
// SO KEEP THESE IN THE SAME ORDER AS THE CMD_ IDs ABOVE
//
#define IDS_STATUS_MENU_CONTROL                 400
#define IDS_STATUS_MENU_VIEW                    401
#define IDS_STATUS_MENU_WINDOW                  402
#define IDS_STATUS_MENU_HELP                    403
#define IDS_STATUS_MENU_FORWARDCONTROL          404
#define IDS_STATUS_CMDS_APP                     405
#define IDS_STATUS_CMDS_FORWARD                 406

#define IDS_STATUS_CMD_START                    500
#define IDS_STATUS_CMD_TOPMOST                  600
#define IDS_STATUS_CMD_TAKECONTROL              601
#define IDS_STATUS_CMD_RELEASECONTROL           602
#define IDS_STATUS_CMD_CANCELCONTROL            603
#define IDS_STATUS_CMD_CTRLALTDEL               604
#define IDS_STATUS_CMD_VIEWSTATUSBAR            605
#define IDS_STATUS_CMD_VIEWWINDOWBAR            606
#define IDS_STATUS_CMD_VIEWFULLSCREEN           607
#define IDS_STATUS_CMD_HELPTOPICS               608
#define IDS_STATUS_CMD_HELPABOUT                609


//
// DIALOGS
//

#define IDD_HOSTUI                          100
    #define CTRL_PROGRAM_LIST               50
    #define CTRL_SHARE_BTN                  51
    #define CTRL_UNSHARE_BTN                52
    #define CTRL_UNSHAREALL_BTN             53
    #define CTRL_ENABLETRUECOLOR_CHECK      54
    #define CTRL_CONTROL_MSG                55
    #define CTRL_ALLOWCONTROL_BTN           56
    #define CTRL_PREVENTCONTROL_BTN         57
    #define CTRL_AUTOACCEPTCONTROL_CHECK    58
    #define CTRL_TEMPREJECTCONTROL_CHECK    59

#define IDD_INFORM                      101
    #define CTRL_INFORM                  50
#define IDD_QUERY                       102
    #define CTRL_QUERY                   50
#define IDD_ABOUT                       103
    #define CTRL_ABOUTVERSION            50

//
// BITMAPS
//

#define IDB_HATCH32X32                  100
#define IDB_OBSCURED                    101


//
// ICONS
//
#define IDI_SHAREICON                   101
#define IDI_DESKTOPICON                 102
#define IDI_CANCELFULLSCREEN            103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\rbc.h ===
//
// Received Bitmap Cache
//

#ifndef _H_RBC
#define _H_RBC


//
// Number of RGB entries in the colour tables.
//
#define RBC_MAX_PALETTE_ENTRIES 256


//
// Information stored for each remote host.
//
typedef struct tagRBC_HOST_INFO
{
    STRUCTURE_STAMP

    BMC_DIB_CACHE   bitmapCache[NUM_BMP_CACHES];
}
RBC_HOST_INFO;

typedef RBC_HOST_INFO  * PRBC_HOST_INFO;



#endif // _H_RBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\pm.h ===
//
// Palette Manager
//

#ifndef _H_PM
#define _H_PM



//
//
// CONSTANTS
//
//


//
// The number of true greys we want a true color system to deliver from a
// GetDIBits call. To vary this (number of greys and/or grey RGBs)
// -  alter the number defined for PM_GREY_COUNT below
// -  define suitable values for the grey RGBs below (PM_LIGHT_GREY, etc)
// -  change the initialisers for pmOurGreyRGB in wpmdata.c
// -  recompile the entire PM component.
//
#define PM_GREY_COUNT 5

//
// Grey RGBs passed into the true color display driver for conversion to
// a driver representation via an 8bpp GetDIBits.
//
#define PM_GREY1      0x00C0C0C0
#define PM_GREY2      0x00808080
#define PM_GREY3      0x006a6a6a
#define PM_GREY4      0x00555555
#define PM_GREY5      0x00333333



#define PM_NUM_1BPP_PAL_ENTRIES         2
#define PM_NUM_4BPP_PAL_ENTRIES         16
#define PM_NUM_8BPP_PAL_ENTRIES         256
#define PM_NUM_TRUECOLOR_PAL_ENTRIES    0


//
// The color table cache structure
//
typedef struct tagCOLORTABLECACHE
{
    BOOL    inUse;
    UINT    cColors;
    TSHR_RGBQUAD colors[256];
}
COLORTABLECACHE;
typedef COLORTABLECACHE * PCOLORTABLECACHE;



#endif // _H_PM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\sc.h ===
//
// Share Controller
//

#ifndef _H_SC
#define _H_SC


//
//
// CONSTANTS
//
//

//
// Values for compression support array
// - PR_UNKNOWN - don't know (yet) what level this party supports
// - PR_LEVEL1  - Only PKZIP compression is supported.  Compressed packets
//                are identified by the top bit of the compressionType
//                field.  All other bits of compressionType are meaningless
// - PR_LEVEL2  - Multiple compression types are supported.  The compression
//                used for each packet is identified by the compressionType
//                field.
//
#define PR_UNKNOWN  0
#define PR_LEVEL1   1
#define PR_LEVEL2   2




//
// STATES
//
//


enum
{
    SCS_TERM            = 0,
    SCS_INIT,
    SCS_SHAREENDING,
    SCS_SHAREPENDING,
    SCS_SHARING,
    SCS_NUM_STATES
};

//
// Number of supported streams 
// THIS MUST MATCH PROT_STR values!
//
#define SC_STREAM_LOW      1
#define SC_STREAM_HIGH     4
#define SC_STREAM_COUNT    4



//
// Sync status constants
//
#define SC_NOT_SYNCED      0
#define SC_SYNCED          1




//
// PROTOTYPES
//


//
// SC_Init()
// SC_Term()
//
// Init and term routines
//
BOOL SC_Init(void);
void SC_Term(void);



UINT SC_Callback(UINT eventType, MCSID mcsID, UINT cbData1, UINT cbData2, UINT cbData3);

BOOL SC_Start(UINT mcsIDLocal);
void SC_End(void);

//
// SC_CreateShare(): S20_CREATE or S20_JOIN
//
BOOL SC_CreateShare(UINT what);
//
// SC_EndShare()
//
void SC_EndShare(void);


void SCCheckForCMCall(void);

#endif // _H_SC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\sbc.h ===
//
// Sent Bitmap Cache
//

#ifndef _H_SBC
#define _H_SBC


#include <oa.h>
#include <shm.h>
#include <osi.h>
#include <ch.h>
#include <bmc.h>


//
//
// Constants
//
//



#define SBC_NUM_THRASHERS   8       // The number of bitmaps we monitor for
                                    // "thrashiness" at any given time.

#define SBC_THRASH_INTERVAL 50      // The interval (in centi-seconds) at
                                    // which bitmaps have to change in
                                    // order to be classified as thrashers


//
// Eviction categories
//
#define SBC_NUM_CATEGORIES        3


//
// Specific values for OSI escape codes
//
#define SBC_ESC(code)                   (OSI_SBC_ESC_FIRST + code)

#define SBC_ESC_NEW_CAPABILITIES        SBC_ESC(0)



//
// Value indicating that a bitmap should not be fast pathed
//
#define SBC_DONT_FASTPATH       0xffffffff


//
// Index into sbcTileWorkInfo at which the data for various tile sizes is
// stored.
//
#define SBC_MEDIUM_TILE_INDEX       SHM_MEDIUM_TILE_INDEX
#define SBC_LARGE_TILE_INDEX        SHM_LARGE_TILE_INDEX
#define SBC_NUM_TILE_SIZES          SHM_NUM_TILE_SIZES





//
//
// Macros
//
//

//
// Calculate the number of bytes required for a tile entry of the given
// dimensions.
//
#define SBC_BYTES_PER_TILE(WIDTH, HEIGHT, BPP)              \
            (BYTES_IN_BITMAP((WIDTH), (HEIGHT), (BPP))      \
                + sizeof(SBC_TILE_DATA))                    \



//
// SBC_TILE_TYPE
//
// Given an SBC tile Id, return the tile type.
//
// Returns one of:
//      SBC_SMALL_TILE
//      SBC_LARGE_TILE
//
// The top bit of the Id is clear for small tiles, and set for large tiles.
//
#define SBC_TILE_TYPE(TILEID)  \
    (((TILEID) & 0x8000) ? SBC_LARGE_TILE_INDEX : SBC_MEDIUM_TILE_INDEX)





//
//
// Structures
//
//

//
// Structure: SBC_SHM_CACHE_INFO
//
// Description: Structure which is used to pass information about a bitmap
// cache from the share core to the display driver.
//
//
typedef struct tagSBC_SHM_CACHE_INFO
{
    WORD    cEntries;       // The number of entries in this cache.
    WORD    cCellSize;      // The maximum bytes available for each cache entry.
}
SBC_SHM_CACHE_INFO;
typedef SBC_SHM_CACHE_INFO FAR * LPSBC_SHM_CACHE_INFO;


//
// Structure: SBC_TILE_DATA
//
// Description: Structure used to pass the DIB bits for tile in a MEMBLT
// order from the driver to the share core.  There is an array of these
// structures in each SBC shunt buffer.
//
// Notes: The inUse field should only be set to TRUE by the driver when it
// has finished filling in the entry, and to FALSE by the share core when
// it has finished processing the data held in the entry.  When inUse is
// FALSE, the remaining data is not valid, and should not be accessed by
// the share core.
//
// The width and height fields give the dimensions of the data which is
// held in the bitData field.  If the tile is set up to hold a maximum
// of 32x32, the scanlines in bitData will always be 32 even if width is
// set to less than 32 - there will just be unused data at the end of each
// scanline.
//
//
typedef struct tagSBC_TILE_DATA
{
    WORD        inUse;              // Is this entry in use?
    WORD        tileId;             // An identifier for this entry.  This
                                    //   matches an ID stored in the
                                    //   cacheId field of a MEMBLT order
                                    //   passed from the driver to the
                                    //   share core in the order buffer.

    DWORD       bytesUsed;          // The number of bytes of data in
                                    //   bitData which is actually used for
                                    //   this entry.

    WORD        srcX;               // The source coordinates of the Mem(3)Blt
    WORD        srcY;

    WORD        width;              // The dimensions of the data in bitData
    WORD        height;

    WORD        tilingWidth;        // The dimensions at which tiling was
    WORD        tilingHeight;       //   carried out.  This is not
                                    //   necessarily the same as the
                                    //   dimensions of the tiles in this
                                    //   shunt buffer.

    DWORD_PTR   majorCacheInfo;     // Information which the share core can
    DWORD       minorCacheInfo;     //   use to optimize cache handling.
                                    //   A value of SBC_DONT_FASTPATH for
                                    //   majorCacheInfo indicates that the
                                    //   optimization should not be used.
                                    //

    DWORD_PTR   majorPalette;       // Palette information for the fast
    DWORD       minorPalette;       //   pathing.  These two fields
                                    //   uniquely identify the colour
                                    //   conversion object associated with
                                    //   the bitmap.

    BYTE        bitData[4];         // Start of the bit data.  The total
                                    //   number of bits is given by the
                                    //   numBits field of the
                                    //   SBC_SHUNT_BUFFER structure at the
                                    //   head of the shunt buffer which
                                    //   this entry is placed in.
} SBC_TILE_DATA;
typedef SBC_TILE_DATA FAR * LPSBC_TILE_DATA;



//
// Structure: SBC_SHUNT_BUFFER
//
// Description: Structure placed at the head of a shunt buffer used to pass
// bit data from the driver to the share core.  It is followed by an array
// of SBC_TILE_DATA structures.
//
// Note: The SBC_TILE_DATA structures are all the same size, but the size
// is not fixed at compile time (there are a variable number of bits), so
// do not use array notation to reference them.
//
//
typedef struct tagSBC_SHUNT_BUFFER
{
    DWORD           numBytes;       // The number of bytes in the bitData
                                    //   fields of the SBC_TILE_DATA stryct
    DWORD           structureSize;  // The total size of each SBC_TILE_DATA
                                    //   structure
    DWORD           numEntries;     // The number of SBC_TILE_DATA
                                    //   structures in the shunt buffer
    SBC_TILE_DATA   firstEntry;     // The first SBC_TILE_DATA entry

} SBC_SHUNT_BUFFER;
typedef SBC_SHUNT_BUFFER FAR * LPSBC_SHUNT_BUFFER;



//
// Structure: SBC_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSBC_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;               // Common header

    DWORD               sendingBpp;         // Bpp at which bitmaps are sent

    LPSBC_SHM_CACHE_INFO cacheInfo;         // Caching details

} SBC_NEW_CAPABILITIES;
typedef SBC_NEW_CAPABILITIES FAR * LPSBC_NEW_CAPABILITIES;


//
// Structure: SBC_ORDER_INFO
//
// Description: This structure holds all the information SBC needs about
// the two internal orders which it stores to hold data color table and bit
// data for a MEMBLT order.
//
// pColorTableOrder is allocated with enough color table entries for
// usrSendingbpp bitmaps.
//
// pBitmapBitsOrder is allocated with enough room for the maximum tile size
// which we will send out at usrSendingbpp.
//
// If sentColorTable is TRUE, the data in pColorTableOrder may not be
// valid.
//
// If sentBitmapBits is TRUE, the data in pBitmapBitsOrder may not be
// valid.
//
//
typedef struct tagSBC_ORDER_INFO
{
    LPINT_ORDER  pColorTableOrder;       // Pointer to a color table order.
    LPINT_ORDER  pBitmapBitsOrder;       // Pointer to a bitmap bits order.
    DWORD        bitmapBitsDataSize;     // The number of bytes allocated
                                        //   for the data field of the
                                        //   bitmap bits order.
    LPINT_ORDER  pOrder;                 // Pointer to the MEMBLT order for
                                        //   which we currently hold data.
                                        //   DO NOT DEREFERENCE THIS - IT
                                        //   IS FOR NUMERICAL COMPARISON
                                        //   ONLY
    DWORD       validData;              // Do we have valid data for
                                        //   pOrder ?
    DWORD       sentColorTable;         // Has the color table been sent
                                        //   over the wire ?
    DWORD       sentBitmapBits;         // Have the bitmap bits been sent
                                        //   over the wire ?
    DWORD       sentMemBlt;             // Has the MEMBLT order itself been
                                        //   sent over the wire ?

}
SBC_ORDER_INFO, FAR * LPSBC_ORDER_INFO;



//
// Structure: SBC_TILE_WORK_INFO
//
// Description: This structure contains all the elements required for
// manipulating tiles of a given size.  There should be an array of these
// structures - one per tile size.
//
//
typedef struct tagSBC_TILE_WORK_INFO
{
    LPSBC_SHUNT_BUFFER   pShuntBuffer;   // Pointer to the shunt buffer to
                                        //   containing tiles of this tile
                                        //   size.
    UINT            mruIndex;       // The last entry accessed in
                                        //   the shunt buffer pointed to by
                                        //   pShuntBuffer.
    HBITMAP         workBitmap;     // The bitmap to use for processing
                                        //   this tile size.  This is
                                        //   tileWidth x tileHeight at
                                        //   native bpp.
#ifndef DLL_DISP
    LPBYTE          pWorkBitmapBits;// Pointer to the start of the bits
#endif // DLL_DISP
                                        //   in the bitmap.
    UINT            tileWidth;      // The width of workBitmap.
    UINT            tileHeight;     // The height of workBitmap.
} SBC_TILE_WORK_INFO, FAR * LPSBC_TILE_WORK_INFO;



//
// Structure: SBC_FASTPATH_ENTRY
//
// Description: Structure holding one entry in the SBC fast path.
//
//
typedef struct tagSBC_FASTPATH_ENTRY
{
    BASEDLIST      list;           // Offsets to the next / prev entries in
                                //   the fast path
    DWORD_PTR   majorInfo;      // Major cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD       minorInfo;      // Minor cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD_PTR   majorPalette;   // Major palette info from the shunt buffer
                                //   This is the pointer to the XLATEOBJ
    DWORD       minorPalette;   // Minor palette info from the shunt buffer
                                //   This is the iUniq of the XLATEOBJ

    LONG        srcX;           // The coordinate in the source bitmap of
    LONG        srcY;           //   the source of the MemBlt
    DWORD       width;          // The width / height of the entry in the
    DWORD       height;         //   cache.

    WORD        cache;          // The cache and index at which the bitmap
    WORD        cacheIndex;     //   stored.
    WORD        colorIndex;
    WORD        pad;

} SBC_FASTPATH_ENTRY, FAR * LPSBC_FASTPATH_ENTRY;


//
// Structure: SBC_FASTPATH
//
// Description: Structure holding the SBC fast pathing information.
//
//

#define SBC_FASTPATH_ENTRIES    100

typedef struct tagSBC_FASTPATH
{
    STRUCTURE_STAMP

    BASEDLIST              usedList;   // Offsets to the first / last used
                                    //   entries in the fast path.
    BASEDLIST              freeList;   // Offsets to the first / last free
                                    //   entries in the fast path.
    SBC_FASTPATH_ENTRY      entry[SBC_FASTPATH_ENTRIES];
}
SBC_FASTPATH;
typedef SBC_FASTPATH FAR * LPSBC_FASTPATH;


#ifdef DLL_DISP

// Structure: SBC_THRASHERS
//
// Description: Structure which is used to hold information about when a
// source surface (bitmap) last changed, in order to determine whether the
// surface will cause thrashing in the bitmap cache.
//

typedef struct tagSBC_THRASHERS
{
#ifdef IS_16
    HBITMAP     hsurf;
#else
    HSURF       hsurf;          // The hsurf of the surface object being
                                //   monitored.
    DWORD       iUniq;          // The last noted iUniq field from the
                                //   surface object being monitored.
#endif // IS_16
    DWORD       tickCount;      // The system tick count (in centi-seconds)
                                //   at which we last saw this surface
                                //   change
} SBC_THRASHERS;
typedef SBC_THRASHERS FAR * LPSBC_THRASHERS;


//
//
// Function prototypes
//
//


void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pRequest);

BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData);

DWORD SBCDDGetTickCount(void);

#ifdef IS_16
BOOL SBCDDCreateShuntBuffers(void);
#else
BOOL SBCDDCreateShuntBuffers(LPOSI_PDEV ppDev, LPBYTE psbcMem, DWORD sbcMem);
#endif

#ifndef IS_16
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj);
#endif // !IS_16


#endif // DLL_DISP


//
// SBC_TILE_PTR_FROM_INDEX
//
// Given a pointer to a shunt buffer and a tile index, return a pointer to
// the tile at the given index.
//
// Get a pointer to the first entry in the shunt buffer, and add INDEX
// times the size of each entry.
//
__inline LPSBC_TILE_DATA SBCTilePtrFromIndex(LPSBC_SHUNT_BUFFER pBuffer, UINT index)
{
    LPSBC_TILE_DATA lpsbc;

    lpsbc = (LPSBC_TILE_DATA)((LPBYTE)&pBuffer->firstEntry +
        index * pBuffer->structureSize);
    return(lpsbc);
}




#ifdef DLL_DISP

//
//
// Typedefs
//
//

#ifdef IS_16

typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    HDC             hdcSrc;
    UINT            fuColorUse;
    LPVOID          lpBits;
    LPBITMAPINFO    lpbmi;
    HPALETTE        hpalDst;
    UINT            uPad;
} MEMBLT_ORDER_EXTRA_INFO, FAR* LPMEMBLT_ORDER_EXTRA_INFO;

#else
//
// Structure: MEMBLT_ORDER_EXTRA_INFO
//
// Description: Extra information required by SBC to process a MEMBLT
// order.
//
//
typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    SURFOBJ*    pSource;        // Pointer to the source surface of the
                                //   MemBlt
    SURFOBJ*    pDest;          // Pointer to the destination surface of
                                //   the MemBlt
    XLATEOBJ*   pXlateObj;      // Pointer to the XlateObj used in the
                                //   MemBlt
} MEMBLT_ORDER_EXTRA_INFO, FAR * LPMEMBLT_ORDER_EXTRA_INFO;
#endif // !IS_16


//
// Name:      SBC_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//
#ifdef IS_16
BOOL  SBC_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
void  SBC_DDTossFromCache(HBITMAP);
#else
BOOL  SBC_DDProcessRequest(SURFOBJ*  pso, DWORD fnEscape,
            LPOSI_ESCAPE_HEADER pRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif


//
// Name:      SBC_DDInit
//
// Purpose:   Initialize the device driver SBC specific "stuff".
//
#ifdef IS_16
BOOL SBC_DDInit(HDC hdc, LPDWORD ppShuntBuffers, LPDWORD pBitmasks);
#else
BOOL SBC_DDInit(LPOSI_PDEV ppDev, LPBYTE pRestOfMemory, DWORD cbRestOfMemory,
    LPOSI_INIT_REQUEST pResult);
#endif


//
// Name:      SBC_DDTerm
//
// Purpose:   Terminate the device driver SBC specific "stuff"
//
// Returns:   Nothing
//
// Params:    None
//
void SBC_DDTerm(void);


//
// Name:       SBC_DDIsMemScreenBltCachable
//
// Purpose:    Check to see whether a MemBlt is cachable.
//
// Returns:    TRUE if the MemBlt is cachable, FALSE otherwise.
//
// Params:     IN  pMemBltInfo - Info about the MEMBLT to be cached.
//
// Operation:  Note that if this function returns TRUE, it DOES NOT
//             guarantee that SBC_DDCacheMemScreenBlt will succeed.
//             However, a FALSE return code does guarantee that
//             SBC_DDCacheMemScreenBlt would fail.
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);


//
// Name:      SBC_DDCacheMemScreenBlt
//
// Purpose:   Try to cache a memory to screen blt operation
//
// Returns:   TRUE if the memory to screen blt was handled as an order
//            (i.e. the src bitmap could be cached)
//
//            FALSE if the memory to screen blt could not be handled as an
//            order.  In this case the caller should add the destination
//            rectangle of the blt into the Screen Data Area.
//
// Params:    IN  pOrder      - Pointer to either a MEMBLT order or a
//                              MEM3BLT order.  This order must be
//                              initialized before calling this function.
//            IN  pMemBltInfo - Extra info about the MEMBLT to be cached.
//
// Operation: Before calling this function, the caller should call
//            SBC_DDMaybeQueueColorTable() to queue a color table for the
//            MemBlt (if required).
//
BOOL SBC_DDCacheMemScreenBlt(LPINT_ORDER pOrder, LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);

//
// THIS CAN GO WHEN 2.x COMPAT DOES -- the SEND TILE SIZES WON'T BE
// NEGOTIATED.
//
BOOL SBC_DDQueryBitmapTileSize(UINT bmpWidth, UINT bmpHeight,
            UINT * pTileWidth, UINT * pTileHeight);


//
// Name:      SBC_DDSyncUpdatesNow
//
// Purpose:   Discard any pending orders.
//
// Returns:   Nothing
//
// Params:    IN  ppDev - Pointer to our device PDEV
//
// Operation: This function will mark all entries in the shunt buffers as
//            being free.  It is vital that this operation is synched with
//            the share core operation of removing all orders from the
//            order buffer to ensure that there are no MemBlt orders left
//            which refer to freed shunt buffer entries.
//
#ifdef IS_16
void SBC_DDSyncUpdatesNow(void);
#else
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev);
#endif // IS_16


//
// Name:      SBC_DDOrderSpoiltNotification
//
// Purpose:   Called to notify SBC that a Mem(3)Blt order has been spoilt
//            before being passed to the share core.  This function marks
//            the corresponding shunt buffer entry as being free.
//
// Returns:   Nothing
//
// Params:    IN  pOrder - Pointer to the Mem(3)Blt order being spoilt.
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder);


//
// Name:      SBC_DDMaybeQueueColorTable
//
// Purpose:   If our device palette has changed since the last time we
//            queued a color table order to the share core, queue a new
//            color table order with details of the new palette.
//
// Returns:   TRUE if the color table was queued, or no color table was
//            required.
//
//            FALSE if a color table is required, but could not be queued.
//
// Params:    IN ppDev - a pointer to our device PDEV
//
// Operation: This function should be called before SBC_DDCacheMemScreenBlt
//            to queue the color table used for the Mem(3)Blt.  If this
//            function fails (returns FALSE), the caller should not call
//            SBC_DDCacheMemScreenBlt, but add the area covered by the
//            Mem(3)Blt to the screen data area instead.
//
//            This function is required to work round a limitation in the
//            order heap which means that we cannot have more than one
//            OA_AllocOrderMem outstanding waiting for an OA_AddOrder.
//
//            i.e. We cannot queue the color table order from
//            SBC_DDCacheMemScreenBlt because this gives the following
//            sequence of calls.
//
//              OA_AllocOrderMem for Mem(3)Blt
//              OA_AllocOrderMem for color table
//              OA_AddOrder for color table
//              OA_AddOrder for Mem(3)Blt
//
#ifdef IS_16
BOOL SBC_DDMaybeQueueColorTable(void);
#else
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev);
#endif


#endif // DLL_DISP



#endif // _H_SBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\shm.h ===
//
// Shared Memory Manager
//

#ifndef _H_SHM
#define _H_SHM


#include <oa.h>
#include <ba.h>
#include <osi.h>
#include <sbc.h>
#include <cm.h>


//
// List of component IDs for the data blocks passed around using shared
// memory.
//
#define SHM_OA_DATA                     0
#define SHM_OA_FAST                     1
#define SHM_BA_FAST                     2
#define SHM_CM_FAST                     3

//
// Number of components (actual number of entries in the above list).
//
#define SHM_NUM_COMPONENTS              4

//
// Structure to keep track of the buffer being used to pass data between
// the display driver and the share core.
//
// busyFlag      - indicates whether the display driver is using the memory
//
// newBuffer     - index for which buffer the display driver should next
//                 use to access the memory.
//
// currentBuffer - index for the buffer in use by the display driver if
//                 busyFlag is set.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// indexCount    - count of how many times we have recursed into accessing
//                 the buffer.  The busyFlag and currentBuffer should only
//                 be updated if indexCount was set to or changed from 0.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// bufferBusy    - indicates whether a particular buffer is being used
//                 by the display driver.
//
//
typedef struct tagBUFFER_CONTROL
{
    long    busyFlag;
    long    newBuffer;
    long    currentBuffer;
    long    indexCount;
    long    bufferBusy[2];
} BUFFER_CONTROL;
typedef BUFFER_CONTROL FAR * LPBUFFER_CONTROL;


//
// Shared memory as used by the display driver and share core to
// communicate.
//
// On Win95, we can not easily address memory that isn't in a 64K segment
// So on both platforms, when we map the shared memory, we also return pointers
// to the CM_FAST_DATA structures anda the OA_FAST_DATA structures, each of
// which lives in its own segment.
//
// On NT, the CM_FAST_DATA blocks come right after this one, then the 
// OA_SHARED_DATA blocks.
//
//
//  GENERAL
//  =======
//
// dataChanged   - flags to indicate if a data block has been altered
//                 (only used by the share core)
//
//  FAST PATH DATA
//  ==============
//
// fastPath      - buffer controls
//
// oaFast        - OA fast changing data
//
// baFast        - BA fast changing data
//
//  DISPLAY DRIVER -> SHARE CORE
//  ============================
//
// displayToCore - buffer controls
//
//
typedef struct tagSHM_SHARED_MEMORY
{
    //
    // Flag set by display driver when the display is in full screen mode.
    // (e.g. DOS full screen).
    //
    DWORD           fullScreen;

    //
    // Flag set by display driver or core when system palette has altered
    //
    LONG            pmPaletteChanged;

    //
    // Flag set by display driver when the cursor is hidden.
    //
    LONG            cmCursorHidden;

    //
    // Data passed from the Display Driver up to the Share Core.
    //
    BUFFER_CONTROL  displayToCore;


    long            dataChanged[SHM_NUM_COMPONENTS];

    //
    // Data passed regularly from the Display Driver to the Share Core.
    //
    // This buffer is switched on each periodic processing by the share
    // core.  If the criteria for reading are satisfied, the main DD->SHCO
    // buffer is switched.
    //
    BUFFER_CONTROL  fastPath;

    BA_FAST_DATA    baFast[2];

    OA_FAST_DATA    oaFast[2];

    CM_FAST_DATA    cmFast[2];

    //
    // DO NOT BUMP SHARED MEMORY SIZE PAST 64K
    // 16-bit display driver puts each oaData in a 64K block
    // The SHM_ESC_MAP_MEMORY request returns back the pointers
    // to each oaData in addition to the shared memory block.  In the
    // the case of the 32-bit NT display driver, the memory allocated is
    // in fact contiguous, so there's no waste in that case.
    //
} SHM_SHARED_MEMORY;
typedef SHM_SHARED_MEMORY FAR * LPSHM_SHARED_MEMORY;



//
// Macros to access the shared memory
//
//
//  OVERVIEW
//  ~~~~~~~~
//
// Note the following sets of macros are split into two parts - one for
// accessing memory from the NT kernel and one for the Share Core.  This
// code plays a significant role in the synchronization of the shared
// memory, so make sure you know how it works...
//
// The shared memory is double buffered, so that the kernel mode display
// driver can come in at any point and is NEVER blocked by the share core
// for access.  The data is split into two major blocks - one to pass data
// from the kernel to the Share Core and the other to pass the data back.
//
// The macros assume a certain structure to the shared memory which is
// described below.
//
// NO VALIDATION OF POINTERS IS DONE IN THESE MACROS.
//
//
//  DISPLAY DRIVER ACCESS
//  ~~~~~~~~~~~~~~~~~~~~~
//
//                    
//                     Shared Memory                
//                     ~~~~~~~~~~~~~                
//                                                  
//                        
//                                              
//                      kernel       fast path  
//                       -> SHCO                
//                                              
//                                              
//                      (details                
//                         below)               
//                                              
//                        
//                    
//
//
//
//        
//         Kernel to share core data block                     
//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
//                           
//                            busyFlag                     
//           Share Core           1        Display Driver  
//                                                         
//           (read buffer)    newBuffer    (write buffer)  
//                                                        
//                         <>                 
//           bufferBusy                    bufferBusy      
//               0                             1           
//                          currentBuffer                  
//                                                        
//                                >                 
//                                                         
//                                                         
//                           indexCount                    
//                                5                        
//                           
//                                                             
//                                                             
//        
//
// The entire major block has a busyFlag, which indicates if the display
// driver is accessing any of its shared memory.  This flag is set as soon
// as the display driver needs access to the shared memory (i.e.  on entry
// to the display driver graphics functions).
//
// The display driver then reads the index (newBuffer in the above drawing)
// to decide which buffer to use.  This is stored in the currentBuffer
// index to use until the display driver releases the shared memory.  The
// secondary bufferBusy is now set for the buffer in use.
//
// The indexCount is maintained of the number of times the display driver
// has started access to a block of memory so that (both) busyFlag and
// bufferBusy can be released when the display driver has truly finished
// with the memory.
//
//
//  SHARE CORE ACCESS
//  ~~~~~~~~~~~~~~~~~
//
// To access the shared memory, the share core just pulls out the data from
// the buffer that the Share Core is not using (ie.  the buffer pointed to
// by NOT newBuffer).
//
// The synchronization between the two processes comes from the buffer
// switch.
//
//
//  BUFFER SWITCHING (AND SYNCHRONIZATION)
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Buffer switching is determined by the Share Core.  Data is accumulated
// by the Share Core and sent on the periodic timing events.  For full
// details on the swapping method, refer to NSHMINT.C
//
// Data (such as window tracking) can be passed down at the meoment it is
// generated by using the OSI functions.
//
// The Share Core also determines when it wants to get the latest set of
// orders and screen data area and forces the switch.  This is detailed in
// NSHMINT.C
//
//
//  THE MACROS!
//  ~~~~~~~~~~~
//
// So, now we know a bit about the shared memory, what macros do we have to
// access the shared memory?  Here goes...
//
//
//  SHM_SYNC_READ      - Force a sync of the read buffer between the tasks.
//                       This should be called only by the Share Core.
//
//  SHM_SYNC_FAST      - Force a sync of the fast path buffer.
//                       This should be called only by the Share Core.
//
//
#ifdef DLL_DISP

LPVOID  SHM_StartAccess(int block);

void    SHM_StopAccess(int block);


//
// Macro to check any pointers that we are going to dereference.
//
#ifdef _DEBUG
void    SHM_CheckPointer(LPVOID ptr);
#else
#define SHM_CheckPointer(ptr)
#endif // _DEBUG


#else // !DLL_DISP

void  SHM_SwitchReadBuffer(void);

void  SHM_SwitchFastBuffer(void);

#endif // DLL_DISP


#endif // _H_SHM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\s20.h ===
//
// Share 2.0 Interface
//

#ifndef _H_S20
#define _H_S20


BOOL S20_Init(void);
void S20_Term(void);


//
// We can send to one person or broadcast to everyone listening to the
// app sharing channel.  The userID for one person is the mcsID, we get it
// in S20 create/join/respond packets along with name + caps.
//

PS20DATAPACKET S20_AllocDataPkt(UINT streamID, UINT nodeID, UINT len);
void S20_FreeDataPkt(PS20DATAPACKET pPacket);
void S20_SendDataPkt(UINT streamID, UINT nodeID, PS20DATAPACKET pPacket);


//
// API FUNCTION: S20_UTEventProc
//
// DESCRIPTION:
//
// Handles NET_EVENTS
//
// PARAMETERS: standard UT event handler
//
// RETURNS: standard UT event handler
//
BOOL CALLBACK S20_UTEventProc(LPVOID userData, UINT event, UINT_PTR data1, UINT_PTR data2);


//
//
// CONSTANTS
//
//


//
// States
//
typedef enum
{
    S20_TERM                = 0,
    S20_INIT,
    S20_ATTACH_PEND,
    S20_JOIN_PEND,
    S20_NO_SHARE,
    S20_SHARE_PEND,
    S20_SHARE_STARTING,
    S20_IN_SHARE,
    S20_NUM_STATES
}
S20_STATE;


#define S20_MAX_QUEUED_CONTROL_PACKETS             20

//
// These pool sizes and latencies control how DC Share T120 flow control
// behaves.  They are tuned for performance so you had better understand
// what you are doing if you change them!
//
// For example, can you explain why any setting other than 0 for the medium
// priority will break DC Share?  If not then go and read/understand
// amgcflo.c and then look at how DC-Share will interact with it.
//
// To summarize:
//
// We don't control the top priority or medium priority pools because they
// carry non-spoilable data that must therefore flow at a lower bandwidth
// than the transport.  In fact, applying back pressure to these streams
// will cause DC-Share to fail in some cases.
//
// Low priority is where flow control really takes effect, since we want
// the pipe to open right up (to 200K per ping) over fast transports but
// to throttle back (to 1K per second possibly!) over slow transports.
//
//
#define S20_LATENCY_TOP_PRIORITY                    0
#define S20_LATENCY_HIGH_PRIORITY                   0
#define S20_LATENCY_MEDIUM_PRIORITY                 0
#define S20_LATENCY_LOW_PRIORITY                 7000

#define S20_SIZE_TOP_PRIORITY                       0
#define S20_SIZE_HIGH_PRIORITY                      0
#define S20_SIZE_MEDIUM_PRIORITY                    0
#define S20_SIZE_LOW_PRIORITY                   99000


//
//
// MACROS
//
//

#define S20_GET_CREATOR(A) ((TSHR_UINT16)(A & 0xFFFF))


//
//
// TYPEDEFS
//
//
typedef struct tagS20CONTROLPACKETQENTRY
{
    UINT            what;
    TSHR_UINT32     correlator;
    UINT            who;
    UINT            priority;
}
S20CONTROLPACKETQENTRY;

typedef S20CONTROLPACKETQENTRY * PS20CONTROLPACKETQENTRY;

//
//
// PROTOTYPES
//
//

BOOL S20CreateOrJoinShare(
    UINT    what,
    UINT    callID);

void S20LeaveOrEndShare(void);

UINT S20MakeControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    PS20PACKETHEADER * ppPacket,
    LPUINT     pLength,
    UINT      priority);

UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority);

UINT S20FlushAndSendControlPacket(
    UINT      what,
    UINT    correlator,
    UINT      who,
    UINT      priority);

UINT S20SendControlPacket(
    PS20PACKETHEADER  pPacket,
    UINT      length,
    UINT      priority);

UINT S20SendQueuedControlPackets(void);

void S20AttachConfirm(NET_UID userID, NET_RESULT result, UINT callID);
void S20DetachIndication(NET_UID userID, UINT callID);
void S20LeaveIndication(NET_CHANNEL_ID channelID, UINT callID);

void S20JoinConfirm(PNET_JOIN_CNF_EVENT pEvent);
void S20SendIndication(PNET_SEND_IND_EVENT pEvent);

void S20Flow(UINT priority, UINT newBufferSize);


void S20CreateMsg(PS20CREATEPACKET  pS20Packet);
void S20JoinMsg(PS20JOINPACKET  pS20Packet);
void S20RespondMsg(PS20RESPONDPACKET  pS20Packet);
void S20DeleteMsg(PS20DELETEPACKET  pS20Packet);
void S20LeaveMsg(PS20LEAVEPACKET  pS20Packet);
void S20EndMsg(PS20ENDPACKET  pS20Packet);
void S20DataMsg(PS20DATAPACKET  pS20Packet);
void S20CollisionMsg(PS20COLLISIONPACKET pS20Packet);

BOOL S20MaybeAddNewParty(MCSID mcsID,
    UINT      lenCaps,
    UINT      lenName,
    LPBYTE    pData);

void S20MaybeIssuePersonDelete(MCSID mcsID);

UINT S20NewCorrelator(void);

NET_PRIORITY S20StreamToS20Priority(UINT  streamID);


#endif // _H_S20

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\sch.h ===
//
// Scheduler
//

#ifndef _H_SCH
#define _H_SCH


//
//
// CONSTANTS
//
//
#define SCH_MODE_ASLEEP  0
#define SCH_MODE_NORMAL  1
#define SCH_MODE_TURBO   2


//
// All of the following values are times in milliseconds.
//
#define SCH_PERIOD_NORMAL        200
#define SCH_PERIOD_TURBO         100
#define SCH_TURBO_MODE_DURATION 1000


#define SCH_EVENT_NAME "DCS_SCHEDULE_EVENT"



//
//
// PROTOTYPES
//
//
// Name:      SCH_Init
//
// Purpose:   Scheduler initialization function.
//
// Params:    None.
//
BOOL SCH_Init(void);

// Name:      SCH_Term
//
// Purpose:   Scheduler termination function.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_Term(void);

// Name:      SCH_ContinueScheduling
//
// Purpose:   Called by components when they want periodic scheduling to
//            continue.  They are guaranteed to get at least one more
//            periodic callback following a call to this function.
//            If they want further callbacks then they must call this
//            function again during their periodic processing.
//
// Returns:   Nothing.
//
// Params:    schedulingMode - either SCH_MODE_NORMAL or SCH_MODE_TURBO
//
// Operation:
//            SCH_MODE_NORMAL triggers periodic processing at 200ms
//            intervals (5 times a second)
//
//            SCH_MODE_TURBO triggers periodic processing at 100ms
//            intervals (10 times a second)
//
//            The scheduler automatically drops from SCH_MODE_TURBO back
//            to SCH_MODE_NORMAL after 1 second of turbo mode processing.
//
//            SCH_MODE_TURBO overrides SCH_MODE_NORMAL, so if calls to
//            this function are made with SCH_MODE_NORMAL when the
//            scheduler is in TURBO mode, TURBO mode continues.
//
//            If this function is not called during processing of a
//            scheduler callback message then the scheduler enters
//            SLEEP mode - and will not generate any more periodic
//            callbacks until it is woken by another call to
//            this function, or until the output accumulation code
//            signals the scheduler's event.
//
void SCH_ContinueScheduling(UINT schedulingMode);

// Name:      SCH_SchedulingMessageProcessed
//
// Purpose:   A feedback function called by the Share Core to signal that
//            a scheduler message has been received.  This ensures that
//            that the scheduler only ever has one scheduler message
//            outstanding at a time.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_SchedulingMessageProcessed(void);

// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to COM_SignalThreadStarted
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
DWORD WINAPI SCH_PacingProcessor(LPVOID lpParam);



void SCHSetMode(UINT newMode);
void SCHPostSchedulingMessage(void);


#endif // _H_SCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\swl.h ===
//
// Shared Window List
//

#ifndef _H_SWL
#define _H_SWL



//
// Return codes.
//

#define SWL_RC_ERROR    0
#define SWL_RC_SENT     1
#define SWL_RC_NOT_SENT 2


//
// DESKTOP types
//
enum
{
    DESKTOP_OURS = 0,
    DESKTOP_WINLOGON,
    DESKTOP_SCREENSAVER,
    DESKTOP_OTHER
};

#define NAME_DESKTOP_WINLOGON       "Winlogon"
#define NAME_DESKTOP_SCREENSAVER    "Screen-saver"
#define NAME_DESKTOP_DEFAULT        "Default"

#define SWL_DESKTOPNAME_MAX         64


#endif // _H_SWL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ssi.h ===
//
// SaveScreenbits Interceptor
//

#ifndef _H_SSI
#define _H_SSI


//
// CONSTANTS
//
#define ST_FAILED_TO_SAVE           0
#define ST_SAVED_BY_DISPLAY_DRIVER  1
#define ST_SAVED_BY_BMP_SIMULATION  2


//
// Maximum depth of save bitmaps we can handle.
//
#define SSB_MAX_SAVE_LEVEL  6

//
// Define the values that can be passed in the flags field of
// SaveScreenBits.
//
// These should be defined in a Windows header - but they are not. In any
// case they are referred to in generic code, so need to be defined here.
//

//
// There are the display driver's SaveBits routine command values, and we
// use them also in our protocol.
//
#define ONBOARD_SAVE        0x0000
#define ONBOARD_RESTORE     0x0001
#define ONBOARD_DISCARD     0x0002


//
//
// MACROS
//
//

//
// Macro that makes it easier (more readable) to access the current
// local SSB state.
//
#define CURRENT_LOCAL_SSB_STATE \
  g_ssiLocalSSBState.saveState[g_ssiLocalSSBState.saveLevel]


#define ROUNDUP(val, granularity) \
  ((val+(granularity-1)) / granularity * granularity)


//
// Specific values for OSI escape codes
//
#define SSI_ESC(code)                   (OSI_SSI_ESC_FIRST + code)

#define SSI_ESC_RESET_LEVEL             SSI_ESC(0)
#define SSI_ESC_NEW_CAPABILITIES        SSI_ESC(1)


//
//
// TYPES
//
//

//
// Local SaveScreenBitmap state structures.
//
typedef struct tagSAVE_STATE
{
    int         saveType;           // ST_xxxx
    HBITMAP     hbmpSave;           // SPB bitmap from USER
    BOOL        fSavedRemotely;
    DWORD       remoteSavedPosition;// valid if (fSavedRemotely == TRUE)
    DWORD       remotePelsRequired; // valid if (fSavedRemotely == TRUE)
    RECT        rect;
} SAVE_STATE, FAR * LPSAVE_STATE;

typedef struct tagLOCAL_SSB_STATE
{
    WORD        xGranularity;
    WORD        yGranularity;
    int         saveLevel;
    SAVE_STATE  saveState[SSB_MAX_SAVE_LEVEL];
} LOCAL_SSB_STATE, FAR* LPLOCAL_SSB_STATE;

//
// Remote SaveScreenBitmap structures.
//
typedef struct tagREMOTE_SSB_STATE
{
    DWORD           pelsSaved;
}
REMOTE_SSB_STATE, FAR* LPREMOTE_SSB_STATE;


//
// SSI_RESET_LEVEL
//
// Resets saved level
//
typedef struct tagSSI_RESET_LEVEL
{
    OSI_ESCAPE_HEADER   header;
}
SSI_RESET_LEVEL;
typedef SSI_RESET_LEVEL FAR * LPSSI_RESET_LEVEL;


//
// Structure: SSI_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSSI_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendSaveBitmapSize;  // Size of the save screen bitmap

    WORD            xGranularity;     // X granularity for SSB

    WORD            yGranularity;     // Y granularity for SSB

}
SSI_NEW_CAPABILITIES;
typedef SSI_NEW_CAPABILITIES FAR * LPSSI_NEW_CAPABILITIES;



//
// FUNCTION: SSI_SaveScreenBitmap
//
//
// DESCRIPTION:
//
// The main SaveScreenBitmap function, called by the SaveScreenBitmap
// Interceptor (SSI).
//
// Saves, restores and discards the specified bits using the Display Driver
// and/or our own SaveScreenBitmap simulation.
//
// Sends the SaveScreenBitmap function as an order if possible.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// wCommand - SaveScreenBitmap command (SSB_SAVEBITS, SSB_RESTOREBITS,
// SSB_DISCARDBITS).
//
//
// RETURNS:
//
// TRUE if operation succeeded.  FALSE if operation failed.
//
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand);


#ifdef DLL_DISP
//
// FUNCTION:      SSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an SSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL    SSI_DDProcessRequest(UINT escapeFn, LPOSI_ESCAPE_HEADER pRequest, DWORD cbResult);

BOOL SSI_DDInit(void);
void SSI_DDTerm(void);

#ifdef IS_16

void SSI_DDViewing(BOOL);

void SSISaveBits(HBITMAP, LPRECT);
BOOL SSIRestoreBits(HBITMAP);
BOOL SSIDiscardBits(HBITMAP);
BOOL SSIFindSlotAndDiscardAbove(HBITMAP);

#else

BOOL SSISaveBits(LPRECT lpRect);
BOOL SSIRestoreBits(LPRECT lpRect);
BOOL SSIDiscardBits(LPRECT lpRect);
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect);

#endif // IS_16

#endif // DLL_DISP


void SSIResetSaveScreenBitmap(void);


BOOL SSISendSaveBitmapOrder( LPRECT lpRect, UINT  wCommand );

void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pssiNew);

DWORD SSIRemotePelsRequired(LPRECT lpRect);

     
#endif // _H_SSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\t_share.h ===
//
// T.SHARE protocol
//

#ifndef _H_T_SHARE
#define _H_T_SHARE


//
// TSHARE PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


////////////////////////////////
//
// BASIC TYPES
//
////////////////////////////////

typedef char                                  TSHR_CHAR;
typedef TSHR_CHAR           FAR*            LPTSHR_CHAR;
typedef TSHR_CHAR UNALIGNED FAR*            LPTSHR_CHAR_UA;


typedef signed char                           TSHR_INT8;
typedef TSHR_INT8           FAR*            LPTSHR_INT8;
typedef TSHR_INT8 UNALIGNED FAR*            LPTSHR_INT8_UA;

typedef BYTE                                  TSHR_UINT8;
typedef TSHR_UINT8          FAR*            LPTSHR_UINT8;  
typedef TSHR_UINT8 UNALIGNED FAR *          LPTSHR_UINT8_UA;


typedef short                                 TSHR_INT16;
typedef TSHR_INT16          FAR*            LPTSHR_INT16;
typedef TSHR_INT16 UNALIGNED FAR *          LPTSHR_INT16_UA;

typedef unsigned short                        TSHR_UINT16;
typedef TSHR_UINT16         FAR*            LPTSHR_UINT16;
typedef TSHR_UINT16 UNALIGNED FAR *         LPTSHR_UINT16_UA;


typedef long                                  TSHR_INT32;
typedef TSHR_INT32          FAR*            LPTSHR_INT32;
typedef TSHR_INT32  UNALIGNED FAR *         LPTSHR_INT32_UA;

typedef unsigned long                         TSHR_UINT32;
typedef TSHR_UINT32         FAR*            LPTSHR_UINT32;
typedef TSHR_UINT32 UNALIGNED FAR *         LPTSHR_UINT32_UA;

// TSHR_PERSONID
typedef TSHR_UINT32         TSHR_PERSONID;
typedef TSHR_PERSONID *     LPTSHR_PERSONID;



// TSHR_POINT16 -- POINT with WORD fields

typedef struct tagTSHR_POINT16
{
    TSHR_INT16      x;
    TSHR_INT16      y;
}
TSHR_POINT16;
typedef TSHR_POINT16 FAR * LPTSHR_POINT16;



// TSHR_POINT32 -- POINT with DWORD fields

typedef struct tagTSHR_POINT32
{
    TSHR_INT32      x;
    TSHR_INT32      y;
}
TSHR_POINT32;
typedef TSHR_POINT32 FAR * LPTSHR_POINT32;



// Conversion Macros
_inline void TSHR_POINT16_FROM_POINT(LPTSHR_POINT16 pPt16, POINT pt)
{
    pPt16->x = (TSHR_INT16)pt.x;
    pPt16->y = (TSHR_INT16)pt.y;
}

_inline void POINT_FROM_TSHR_POINT16(LPPOINT pPt, TSHR_POINT16 pt16)
{
    pPt->x = pt16.x;
    pPt->y = pt16.y;
}



// TSHR_RECT16 -- RECT with WORD fields

typedef struct tagTSHR_RECT16
{
    TSHR_INT16      left;
    TSHR_INT16      top;
    TSHR_INT16      right;
    TSHR_INT16      bottom;
}
TSHR_RECT16;
typedef TSHR_RECT16 FAR *   LPTSHR_RECT16;


// TSHR_RECT32 -- RECT with DWORD fields

typedef struct tagTSHR_RECT32
{
    TSHR_INT32      left;
    TSHR_INT32      top;
    TSHR_INT32      right;
    TSHR_INT32      bottom;
}
TSHR_RECT32;
typedef TSHR_RECT32 FAR *   LPTSHR_RECT32;



// Conversion Macros
#ifdef IS_16
#define TSHR_RECT16_FROM_RECT(lprcTshr, rc) \
    CopyRect((LPRECT)lprcTshr, &rc)

#define RECT_FROM_TSHR_RECT16(lprc, tshrrc) \
    CopyRect(lprc, (LPRECT)&tshrrc)

#else
_inline void TSHR_RECT16_FROM_RECT(LPTSHR_RECT16 pRect16, RECT rect)
{
    pRect16->left   = (TSHR_INT16)rect.left;
    pRect16->top    = (TSHR_INT16)rect.top;
    pRect16->right  = (TSHR_INT16)rect.right;
    pRect16->bottom = (TSHR_INT16)rect.bottom;
}

__inline void RECT_FROM_TSHR_RECT16(LPRECT pRect, TSHR_RECT16 rect16)
{
    pRect->left   = rect16.left;
    pRect->top    = rect16.top;
    pRect->right  = rect16.right;
    pRect->bottom = rect16.bottom;
}
#endif // IS_16



//
// TSHR_RGBQUAD
// =======
// rgbBlue         : blue value.
// rgbGreen        : green value.
//
// rgbRed          : red value.
// rgbReserved     : reserved.
//
typedef struct tagTSHR_RGBQUAD
{
    TSHR_UINT8   rgbBlue;
    TSHR_UINT8   rgbGreen;
    TSHR_UINT8   rgbRed;
    TSHR_UINT8   rgbReserved;
}
TSHR_RGBQUAD;
typedef TSHR_RGBQUAD FAR * LPTSHR_RGBQUAD;


//
// TSHR_COLOR
// =======
// red             : red value.
// green           : green value.
// blue            : blue value.
//
typedef struct tagTSHR_COLOR
{
    TSHR_UINT8   red;
    TSHR_UINT8   green;
    TSHR_UINT8   blue;
}
TSHR_COLOR;
typedef TSHR_COLOR FAR * LPTSHR_COLOR;


//
// TSHR_COLORS
// ========
// fg              : foreground color.
// bg              : background color.
//
typedef struct tagTSHR_COLORS
{
    TSHR_COLOR fg;
    TSHR_COLOR bg;
}
TSHR_COLORS;
typedef TSHR_COLORS FAR * LPTSHR_COLORS;


//
// BITMAPINFO_ours                                                         
// ===============                                                         
// bmiHeader       :                                                       
// bmiColors       :                                                       
//
typedef struct tagBITMAPINFO_ours
{
    BITMAPINFOHEADER   bmiHeader;
    TSHR_RGBQUAD          bmiColors[256];
}
BITMAPINFO_ours;



#define TSHR_RGBQUAD_TO_TSHR_COLOR(TshrRGBQuad, TshrColor)  \
        TshrColor.red = TshrRGBQuad.rgbRed;           \
        TshrColor.green = TshrRGBQuad.rgbGreen;       \
        TshrColor.blue = TshrRGBQuad.rgbBlue

#define TSHR_COLOR_TO_PALETTEENTRY(TshrColor, pe) \
        pe.peGreen = TshrColor.green;          \
        pe.peRed = TshrColor.red;              \
        pe.peBlue = TshrColor.blue;            \
        pe.peFlags = 0

#define TSHR_RGBQUAD_TO_PALETTEENTRY(TshrRGBQuad, pe) \
        pe.peRed   = TshrRGBQuad.rgbRed;           \
        pe.peGreen = TshrRGBQuad.rgbGreen;         \
        pe.peBlue  = TshrRGBQuad.rgbBlue;          \
        pe.peFlags = 0





//
// DATE
// =======
// day             : day of the month (1-31).
// month           : month (1-12).
// year            : year (e.g. 1996).
//
typedef struct tagTSHR_DATE
{
    TSHR_UINT8   day;
    TSHR_UINT8   month;
    TSHR_UINT16 year;
} TSHR_DATE;
typedef TSHR_DATE FAR * LPTSHR_DATE;


//
// TSHR_TIME
// =======
// hour            : hour (0-23).
// min             : minute (0-59).
// sec             : seconds (0-59).
// hundredths      : hundredths of a second (0-99).
//
typedef struct tagTSHR_TIME
{
    TSHR_UINT8   hour;
    TSHR_UINT8   min;
    TSHR_UINT8   sec;
    TSHR_UINT8   hundredths;
}
TSHR_TIME;
typedef TSHR_TIME FAR * LPTSHR_TIME;



//
// Maximum length of a person name                                         
//
#define TSHR_MAX_PERSON_NAME_LEN     48



//
// Common person information:  This is an ObMan object
//
typedef struct tagTSHR_PERSON_DATA
{
    char                personName[TSHR_MAX_PERSON_NAME_LEN];
    TSHR_PERSONID       personHandle;     // Call manager ID
}
TSHR_PERSON_DATA;
typedef TSHR_PERSON_DATA *  PTSHR_PERSON_DATA;




////////////////////////////////
//
// CAPABILITIES
//
////////////////////////////////


//
// Version numbers.
//
#define CAPS_VERSION_10         0x0100          // SALEM 1.0
#define CAPS_VERSION_OLDEST_SUPPORTED   CAPS_VERSION_10
#define CAPS_VERSION_CURRENT            CAPS_VERSION_10

//
// Operating system and operating system version numbers.
//
#define CAPS_WINDOWS            0x0001

#define CAPS_WINDOWS_31         0x0001
#define CAPS_WINDOWS_95         0x0002
#define CAPS_WINDOWS_NT         0x0003

//
// Logical capabilities field values.
//
#define CAPS_UNDEFINED          0
#define CAPS_SUPPORTED          1
#define CAPS_UNSUPPORTED        2

//
// Number of order fields in the orders array.  This must never change
// because the fields within the capabilities structure must never move.
// If more orders fields are required then they must be added to the end of
// the capabilities structure.
//
#define CAPS_MAX_NUM_ORDERS     32

//
// String length of the driver name field in the capabilities structure.
// This allows for an 8.3 driver name (eg VGA.DRV), a NULL, and padding.
//
#define CAPS_DRIVER_NAME_LENGTH  16

//
// Capabilities (group structures) IDs currently defined.  Each ID
// corresponds to a different PROTCAPS structure. (See below).
//
#define CAPS_ID_GENERAL      1
#define CAPS_ID_SCREEN       2
#define CAPS_ID_ORDERS       3
#define CAPS_ID_BITMAPCACHE  4
#define CAPS_ID_CM           5
#define CAPS_ID_SC           6
#define CAPS_ID_PM           7



//
// Capabilities structure header.
//
typedef struct tagPROTCAPSHEADER
{
    TSHR_UINT16         capID;
    TSHR_UINT16         capSize;
}
PROTCAPSHEADER;


//
// Structure passed to CPC_RegisterCapabilities and returned by
// CPC_EnumerateCapabilities. The data field is of variable length (but
// always ends dword aligned).
//
typedef struct tagPROTCAPS
{
    PROTCAPSHEADER      header;
    TSHR_UINT32         data[1];
}
PROTCAPS;
typedef PROTCAPS *PPROTCAPS;



//
// Structure returned by CPC_GetCombinedCapabilities and as part of a
// NET_EV_PERSON_ADD event.
//
typedef struct tagPROTCOMBINEDCAPS_HEADER
{
    TSHR_UINT16         numCapabilities;
    TSHR_UINT16         pad1;
}
PROTCOMBINEDCAPS_HEADER;
typedef PROTCOMBINEDCAPS_HEADER * PPROTCOMBINEDCAPS_HEADER;

typedef struct tagPROTCOMBINEDCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS            capabilities[1];
}
PROTCOMBINEDCAPS;
typedef PROTCOMBINEDCAPS * PPROTCOMBINEDCAPS;
typedef PPROTCOMBINEDCAPS * PPPROTCOMBINEDCAPS;




//
//
// Curent capabilities structure (corresponding to the generic structures
// defined above)....
//
// Note that these must be DWORD padded in size for the current code to
// work correctly on all platforms.
//
//


//
// AS type flags
//
#define AS_SERVICE      0x0001
#define AS_UNATTENDED   0x0002

//
// General capabilities.
//
typedef struct tagPROTCAPS_GENERAL
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         OS;                         
    TSHR_UINT16         OSVersion;                  
    TSHR_UINT16         version;                    
    TSHR_UINT16         typeFlags;                  // NEW FOR 3.0
}
PROTCAPS_GENERAL;
typedef PROTCAPS_GENERAL *PPROTCAPS_GENERAL;

#define PROTCAPS_GENERAL_SIZE_NM20      FIELD_OFFSET(PROTCAPS_GENERAL, genCompressionLevel)


//
// Values for genCompressionLevel
//
// Level 0 : Only GDC_PKZIP compression is allowed in entire share session
//           (genCompressionType indicates if a node supports it)
//           Bit 15 (PT_COMPRESSED) of packetType field is used to
//           indicate if a packet is compressed.
//
// Level 1 : Each nodes genCompressionType indicates which compression
//           algorithms it can use to DECOMPRESS packets.
//           A node can compress a packet with any compression algorithm
//           that the receiving node(s) can decompress with.
//           The top byte of packetType indicates which compression
//           algorithm a packet ahs been compressed with.
//
// If the genCompressionLevel field is not present in a nodes GENERAL
// capabilities then that node is assumed to be use level 0.
//
#define CAPS_GEN_COMPRESSION_LEVEL_0    ((TSHR_UINT16)0x0000)
#define CAPS_GEN_COMPRESSION_LEVEL_1    ((TSHR_UINT16)0x0001)

//
// Bitmap capabilities.
//
typedef struct tagPROTCAPS_SCREEN
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsBPP;
    TSHR_UINT16         capsSupports1BPP;           // OBSOLETE 3.0
    TSHR_UINT16         capsSupports4BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsSupports8BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsScreenWidth;
    TSHR_UINT16         capsScreenHeight;
    TSHR_UINT16         capsSupportsDesktopResize;
    TSHR_UINT16         capsSupports24BPP;
}
PROTCAPS_SCREEN;
typedef PROTCAPS_SCREEN *PPROTCAPS_SCREEN;

#define PROTCAPS_SCREEN_SIZE_NM21       FIELD_OFFSET(PROTCAPS_SCREEN, capsSupportsTrueColor)



//
// Orders capabilities.
//
typedef struct tagPROTCAPS_ORDERS
{
    PROTCAPSHEADER     header;
    TSHR_UINT32        capsSaveBitmapSize;
    TSHR_UINT16        capsSaveBitmapXGranularity;
    TSHR_UINT16        capsSaveBitmapYGranularity;
    TSHR_UINT16        capsMaxOrderlevel;
    TSHR_UINT16        capsNumFonts;                                // OBSOLETE
    TSHR_UINT16        capsEncodingLevel;  // See below
    BYTE               capsOrders[CAPS_MAX_NUM_ORDERS];
    TSHR_UINT16        capsfFonts;         // only introduced at r1.1
    TSHR_UINT16        pad1;           // For DWORD alignment
}
PROTCAPS_ORDERS;
typedef PROTCAPS_ORDERS *PPROTCAPS_ORDERS;

#define PROTCAPS_ORDERS_SIZE_NM20       FIELD_OFFSET(PROTCAPS_ORDERS, pad2)



//
// Define the size of the bitmap used for the SaveBitmap order.            
// These dimensions must be multiples of the granularity values below.     
//
#define     TSHR_SSI_BITMAP_WIDTH           400
#define     TSHR_SSI_BITMAP_HEIGHT          400
#define     TSHR_SSI_BITMAP_SIZE            (TSHR_SSI_BITMAP_WIDTH * TSHR_SSI_BITMAP_HEIGHT)

#define     TSHR_SSI_BITMAP_X_GRANULARITY   1
#define     TSHR_SSI_BITMAP_Y_GRANULARITY   20


//
//
// These flags can be set in the capsfFonts fields. See also the defines
// below related to these flags (which must be updated when a new flag
// is defined).
//
#define CAPS_FONT_ASPECT            0x0001
#define CAPS_FONT_SIGNATURE         0x0002
#define CAPS_FONT_CODEPAGE          0x0004
#define CAPS_FONT_RESERVED1         0x0008      // Reserved for future BiDi support
#define CAPS_FONT_OLD_NEED_X        0x0010
#define CAPS_FONT_NEED_X_SOMETIMES  0x0020
#define CAPS_FONT_NEED_X_ALWAYS     0x0040
#define CAPS_FONT_R20_SIGNATURE     0x0080
#define CAPS_FONT_EM_HEIGHT         0x0100
#define CAPS_FONT_ALLOW_BASELINE    0x0200

//
// How the CAPS_FONT_XXX flags should be combined when adding a person to
// the share.
//
    //
    // AND these flags... the capability is relevant only if ALL parties
    // have it
    //
#define CAPS_FONT_AND_FLAGS     ( CAPS_FONT_ASPECT           \
                                | CAPS_FONT_SIGNATURE        \
                                | CAPS_FONT_R20_SIGNATURE    \
                                | CAPS_FONT_EM_HEIGHT        \
                                | CAPS_FONT_CODEPAGE         \
                                | CAPS_FONT_RESERVED1        \
                                | CAPS_FONT_ALLOW_BASELINE )
    //
    // OR these flags... the capability is relevant if ANY ONE party
    // requires it.
    //
#define CAPS_FONT_OR_FLAGS      ( CAPS_FONT_OLD_NEED_X       \
                                | CAPS_FONT_NEED_X_SOMETIMES \
                                | CAPS_FONT_NEED_X_ALWAYS    )

//
// Which of the CAPS_FONT_XXX flags should be switched on/off in the
// combined received capabilities when a person joins the call who does not
// have the capsfFonts field.
//
#define CAPS_FONT_OFF_FLAGS     ( CAPS_FONT_ASPECT    \
                                | CAPS_FONT_SIGNATURE \
                                | CAPS_FONT_CODEPAGE  \
                                | CAPS_FONT_RESERVED1 \
                                | CAPS_FONT_ALLOW_BASELINE )
#define CAPS_FONT_ON_FLAGS      ( 0                   )

#ifdef _DEBUG // for assertion
#define CAPS_FONT_R11_TEST_FLAGS    ( CAPS_FONT_ASPECT    \
                                    | CAPS_FONT_SIGNATURE \
                                    | CAPS_FONT_CODEPAGE  \
                                    | CAPS_FONT_RESERVED1 )
#endif

#define CAPS_FONT_R20_TEST_FLAGS    ( CAPS_FONT_R20_SIGNATURE \
                                    | CAPS_FONT_EM_HEIGHT )

//
// Level of order encoding support (capsEncodingLevel)
//
// These flags specify the types of order encoding and the level of
// negotiation supported.  The flags and their meanings are as follows.
//
// CAPS_ENCODING_BASE_OE
// - The base OE protocol is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_NEGOTIABLE
// - We can negotiate whether OE2 is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_DISABLED
// - OE2 is disabled on this machine.  This flag is apparently upside down
// so that we can support R1,1, which will set it to 0 (because the
// capability didn;t exist in R1.1).
// CAPS_ENCODING_ALIGNED_OE
// - The aligned OE protocol is supported.  R1.1 does not support this.
//
//
#define CAPS_ENCODING_BASE_OE               0x0001
#define CAPS_ENCODING_OE2_NEGOTIABLE        0x0002
#define CAPS_ENCODING_OE2_DISABLED          0x0004
#define CAPS_ENCODING_ALIGNED_OE            0x0008

//
// Encoding level
//
#define CAPS_ENCODING_DCGC20    ( CAPS_ENCODING_BASE_OE \
                                | CAPS_ENCODING_OE2_NEGOTIABLE)
//
// Encoding level supported by Millennium codebase
//
#define CAPS_ENCODING_DEFAULT   ( CAPS_ENCODING_OE2_NEGOTIABLE )

//
// Bitmap Cache capabilities.
//
typedef struct tagPROTCAPS_BITMAPCACHE_DETAILS
{
    TSHR_UINT16         capsSmallCacheNumEntries;
    TSHR_UINT16         capsSmallCacheCellSize;
    TSHR_UINT16         capsMediumCacheNumEntries;
    TSHR_UINT16         capsMediumCacheCellSize;
    TSHR_UINT16         capsLargeCacheNumEntries;
    TSHR_UINT16         capsLargeCacheCellSize;
}
PROTCAPS_BITMAPCACHE_DETAILS;

typedef struct tagPROTCAPS_BITMAPCACHE
{
    PROTCAPSHEADER  header;
    PROTCAPS_BITMAPCACHE_DETAILS sender;
}
PROTCAPS_BITMAPCACHE;
typedef PROTCAPS_BITMAPCACHE *PPROTCAPS_BITMAPCACHE;




//
// CM capabilities.
//
typedef struct tagPROTCAPS_CM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsSupportsColorCursors;
    TSHR_UINT16         capsCursorCacheSize;
}
PROTCAPS_CM;
typedef PROTCAPS_CM * PPROTCAPS_CM;

#define TSHR_CM_CACHE_ENTRIES   25




//
// PM capabilities.
//
typedef struct tagPROTCAPS_PM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsColorTableCacheSize;

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16         pad1;
}
PROTCAPS_PM;
typedef PROTCAPS_PM * PPROTCAPS_PM;

#define PROTCAPS_PM_SIZE_NM20   FIELD_OFFSET(PROTCAPS_PM, pad1)


#define TSHR_PM_CACHE_ENTRIES       6




//
// SC capabilities.
//
typedef struct tagPROTCAPS_SC
{
    PROTCAPSHEADER      header;
    TSHR_PERSONID       gccID;
}
PROTCAPS_SC;
typedef PROTCAPS_SC * PPROTCAPS_SC;




// If you add a PROTCAPS_ strcuture to CPCALLCAPS, update the count
#define PROTCAPS_COUNT      7

typedef struct tagCPCALLCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS_GENERAL        general;
    PROTCAPS_SCREEN         screen;
    PROTCAPS_ORDERS         orders;
    PROTCAPS_BITMAPCACHE    bitmaps;
    PROTCAPS_CM             cursor;
    PROTCAPS_PM             palette;
    PROTCAPS_SC             share;
}
CPCALLCAPS;
typedef CPCALLCAPS * PCPCALLCAPS;



////////////////////////////////
//
// ORDERS
//
////////////////////////////////


//
//
// COM_ORDER_HEADER
//
// Any orders supplied to the accumulation functions must have
// the following fields filled in:
//
// cbOrderDataLength
//   The length in bytes of the order data (i.e. EXCLUDING the
//   header - which is always a fixed size).
//
// fOrderFlags
//   This can hold a combination of the following flags:
//
//   OF_SPOILER - the order can spoil earlier SPOILABLE ones that it
//                overlaps
//
//   OF_SPOILABLE - the order can be spoilt by SPOILER orders that overlap
//                  it
//
//   OF_BLOCKER - no orders before this one may be spoilt
//
//   OF_PRIVATE - a private order (used by bitmap caching code)
//
//   OF_NOTCLIPPED - this flag is set by OD2 on the DECODING side of the
//                   order processing to indicate that the order is not
//                   clipped. ie the rectangle is the bounding rectangle
//                   but does not result in any clipping taking place.
//                   THIS FLAG IS NOT TRANSMITTED ACROSS THE NETWORK.
//
//   OF_INTERNAL - the order is an internal order, and should not be sent
//                 over the wire.  An internal order is used to pass data
//                 from the device driver to the share core.
//
//   OF_DESTROP - the order has a ROP which relies on the contents of the
//                destination (relies on what is already on the screen).
//
// rcsDst
//   The bounding rectangle of the order in INCLUSIVE screen (pel) coords.
//
//
typedef struct tagCOM_ORDER_HEADER
{
    TSHR_UINT16         cbOrderDataLength;
    TSHR_UINT16         fOrderFlags;
    TSHR_RECT16         rcsDst;
}
COM_ORDER_HEADER;
typedef COM_ORDER_HEADER FAR * LPCOM_ORDER_HEADER;


//
// COM_ORDER_HEADER fOrderFlags values
//
#define OF_SPOILER          0x0001
#define OF_SPOILABLE        0x0002
#define OF_BLOCKER          0x0004
#define OF_PRIVATE          0x0008
#define OF_NOTCLIPPED       0x0010
#define OF_SPOILT           0x0020
#define OF_INTERNAL         0x0040
#define OF_DESTROP          0x0080


//
// Each type of order's structure is the bytes in abOrderData[].
//
typedef struct tagCOM_ORDER
{
    COM_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
}
COM_ORDER;
typedef COM_ORDER           FAR * LPCOM_ORDER;
typedef COM_ORDER UNALIGNED FAR * LPCOM_ORDER_UA;


//
// Macro to calculate a basic common order size (including the Order
// Header).
//
#define COM_ORDER_SIZE(pOrder) \
    (pOrder->OrderHeader.cbOrderDataLength + sizeof(COM_ORDER_HEADER))




//
// The various drawing order structures have the following design objectives
//
//      the first field - type - is common to all orders.
//      field ordering is kept as regular as possible amongst similar
//          orders so that compression may find more regular sequences
//      fields are naturally aligned (dwords on dword boundaries etc)
//      fields are reordered so to preserve alignment rather than add
//          padding
//      padding is added as a last resort.
//      variable sized data comes at the end of the structure.
//
// All rectangles are inclusive of start and end points.
//
// All points are in screen coordinates, with (0,0) at top left.
//
// Interpretation of individual field values is as in Windows
//      in particular pens, brushes and font are as defined for Windows 3.1
//



//
// Orders - the high word is used as an index into a table
//        - the low word is a 2 character ASCII type descriptor and is the
//          only part actually passed in the order.
//
#define ORD_DSTBLT_INDEX        0x0000
#define ORD_PATBLT_INDEX        0x0001
#define ORD_SCRBLT_INDEX        0x0002
#define ORD_MEMBLT_INDEX        0x0003
#define ORD_MEM3BLT_INDEX       0x0004
#define ORD_TEXTOUT_INDEX       0x0005
#define ORD_EXTTEXTOUT_INDEX    0x0006
#define ORD_RECTANGLE_INDEX     0x0007
#define ORD_LINETO_INDEX        0x0008
#define ORD_UNUSED_INDEX        0x0009
#define ORD_OPAQUERECT_INDEX    0x000A
#define ORD_SAVEBITMAP_INDEX    0x000B
#define ORD_RESERVED_INDEX      0x000C
#define ORD_MEMBLT_R2_INDEX     0x000D
#define ORD_MEM3BLT_R2_INDEX    0x000E
#define ORD_POLYGON_INDEX       0x000F
#define ORD_PIE_INDEX           0x0010
#define ORD_ELLIPSE_INDEX       0x0011
#define ORD_ARC_INDEX           0x0012
#define ORD_CHORD_INDEX         0x0013
#define ORD_POLYBEZIER_INDEX    0x0014
#define ORD_ROUNDRECT_INDEX     0x0015
//
// It IS OK to use order 000C!  These numbers don't clash with OE2_* in
// aoe2int.h.  Replace ORD_RESERVED_INDEX (0xC) for the next new order.
//
// NOTE: When you use this index, OE_GetLocalOrderSupport must be updated
// to allow the order.
//

#define ORD_DSTBLT_TYPE         0x4244      // "DB"
#define ORD_PATBLT_TYPE         0x4250      // "PB"
#define ORD_SCRBLT_TYPE         0x4253      // "SB"
#define ORD_MEMBLT_TYPE         0x424d      // "MB"
#define ORD_MEM3BLT_TYPE        0x4233      // "3B"
#define ORD_TEXTOUT_TYPE        0x4f54      // "TO"
#define ORD_EXTTEXTOUT_TYPE     0x5445      // "ET"
#define ORD_RECTANGLE_TYPE      0x5452      // "RT"
#define ORD_LINETO_TYPE         0x544c      // "LT"
#define ORD_OPAQUERECT_TYPE     0x524f      // "OR"
#define ORD_SAVEBITMAP_TYPE     0x5653      // "SV"
#define ORD_MEMBLT_R2_TYPE      0x434d      // "MC"
#define ORD_MEM3BLT_R2_TYPE     0x4333      // "3C"
#define ORD_POLYGON_TYPE        0x4750      // "PG"
#define ORD_PIE_TYPE            0x4950      // "PI"
#define ORD_ELLIPSE_TYPE        0x4c45      // "EL"
#define ORD_ARC_TYPE            0x5241      // "AR"
#define ORD_CHORD_TYPE          0x4443      // "CD"
#define ORD_POLYBEZIER_TYPE     0x5A50      // "PZ"
#define ORD_ROUNDRECT_TYPE      0x5252      // "RR"


#define ORD_DSTBLT          MAKELONG(ORD_DSTBLT_TYPE, ORD_DSTBLT_INDEX)
#define ORD_PATBLT          MAKELONG(ORD_PATBLT_TYPE, ORD_PATBLT_INDEX)
#define ORD_SCRBLT          MAKELONG(ORD_SCRBLT_TYPE, ORD_SCRBLT_INDEX)
#define ORD_MEMBLT          MAKELONG(ORD_MEMBLT_TYPE, ORD_MEMBLT_INDEX)
#define ORD_MEM3BLT         MAKELONG(ORD_MEM3BLT_TYPE, ORD_MEM3BLT_INDEX)
#define ORD_TEXTOUT         MAKELONG(ORD_TEXTOUT_TYPE, ORD_TEXTOUT_INDEX)
#define ORD_EXTTEXTOUT      MAKELONG(ORD_EXTTEXTOUT_TYPE, ORD_EXTTEXTOUT_INDEX)
#define ORD_RECTANGLE       MAKELONG(ORD_RECTANGLE_TYPE, ORD_RECTANGLE_INDEX)
#define ORD_LINETO          MAKELONG(ORD_LINETO_TYPE, ORD_LINETO_INDEX)
#define ORD_OPAQUERECT      MAKELONG(ORD_OPAQUERECT_TYPE, ORD_OPAQUERECT_INDEX)
#define ORD_SAVEBITMAP      MAKELONG(ORD_SAVEBITMAP_TYPE, ORD_SAVEBITMAP_INDEX)
#define ORD_MEMBLT_R2       MAKELONG(ORD_MEMBLT_R2_TYPE, ORD_MEMBLT_R2_INDEX)
#define ORD_MEM3BLT_R2      MAKELONG(ORD_MEM3BLT_R2_TYPE, ORD_MEM3BLT_R2_INDEX)
#define ORD_POLYGON         MAKELONG(ORD_POLYGON_TYPE, ORD_POLYGON_INDEX)
#define ORD_PIE             MAKELONG(ORD_PIE_TYPE, ORD_PIE_INDEX)
#define ORD_ELLIPSE         MAKELONG(ORD_ELLIPSE_TYPE, ORD_ELLIPSE_INDEX)
#define ORD_ARC             MAKELONG(ORD_ARC_TYPE, ORD_ARC_INDEX)
#define ORD_CHORD           MAKELONG(ORD_CHORD_TYPE, ORD_CHORD_INDEX)
#define ORD_POLYBEZIER      MAKELONG(ORD_POLYBEZIER_TYPE, ORD_POLYBEZIER_INDEX)
#define ORD_ROUNDRECT       MAKELONG(ORD_ROUNDRECT_TYPE, ORD_ROUNDRECT_INDEX)


//
// The following order is special - support is not negotiated by the
// capsOrders field in the orders capabilities structure.
// The high words start at 32, ie after CAPS_MAX_NUM_ORDERS.
//
// ORD_NUM_INTERNAL_ORDERS is the number of orders we use internally - this
// include all CAPS_MAX_NUM_ORDERS, plus any of these special orders.
//
#define ORD_DESKSCROLL_INDEX    0x0020
#define ORD_DESKSCROLL_TYPE     0x5344      // "DS"
#define ORD_DESKSCROLL          MAKELONG(ORD_DESKSCROLL_TYPE, ORD_DESKSCROLL_INDEX)

#define INTORD_COLORTABLE_INDEX 0x000C
#define INTORD_COLORTABLE_TYPE  0x5443      // "CT"
#define INTORD_COLORTABLE       MAKELONG(INTORD_COLORTABLE_TYPE, INTORD_COLORTABLE_INDEX)

#define ORD_NUM_INTERNAL_ORDERS 33
#define ORD_NUM_LEVEL_1_ORDERS  22

#define ORD_LEVEL_1_ORDERS      1

//
// The maximum length of string which we will send as an order (either as
// TextOut or ExtTextOut) when a delta X array is supplied or not.
//
//
// NOTE:  THESE MUST TOTAL LESS THAN 256 BECAUSE THE TOTAL ENCODED SIZE 
// MUST FIT IN ONE BYTE.
//
//      STRING_LEN_WITHOUT_DELTAS       --  1 byte per char
//      STRING_LEN_WITH_DELTAS          --  1 byte per char + 1 byte per delta
//      ORD_MAX_POLYGON_POINTS          --  4 bytes per point (2 each coord)
//      ORD_MAX_POLYBEZIER_POINTS       --  4 bytes per point (2 each coord)
//
#define ORD_MAX_STRING_LEN_WITHOUT_DELTAS   255
#define ORD_MAX_STRING_LEN_WITH_DELTAS      127
#define ORD_MAX_POLYGON_POINTS              63
#define ORD_MAX_POLYBEZIER_POINTS           63

//
// Direction codes for arc drawing orders (pie, arc, chord).
// Specifies direction that pie, arc, and chord figures are drawn.
//
#define     ORD_ARC_COUNTERCLOCKWISE            1
#define     ORD_ARC_CLOCKWISE                   2

//
// Fill-mode codes for polygon drawing.
//
// Alternate fills area between odd-numbered and even-numbered polygon
// sides on each scan line.
//
// Winding fills any region with a nonzero winding value.
//
#define     ORD_FILLMODE_ALTERNATE              1
#define     ORD_FILLMODE_WINDING                2

//
// DstBlt (Destination only Screen Blt)
//
typedef struct _DSTBLT_ORDER
{
    TSHR_UINT16     type;           // holds "DB" - ORD_DSTBLT
    TSHR_INT16      pad1;

    TSHR_INT32      nLeftRect;      // x upper left
    TSHR_INT32      nTopRect;       // y upper left
    TSHR_INT32      nWidth;         // dest width
    TSHR_INT32      nHeight;        // dest height

    TSHR_UINT8      bRop;           // ROP
    TSHR_UINT8      pad2[3];
} DSTBLT_ORDER, FAR * LPDSTBLT_ORDER;

//
// PatBlt (Pattern to Screen Blt)
//
typedef struct _PATBLT_ORDER
{
    TSHR_UINT16    type;           // holds "PB" - ORD_PATBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_COLOR         BackColor;
    TSHR_UINT8      pad2;
    TSHR_COLOR         ForeColor;
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

} PATBLT_ORDER, FAR * LPPATBLT_ORDER;

//
// ScrBlt (Screen to Screen Blt)
//
typedef struct _SCRBLT_ORDER
{
    TSHR_UINT16    type;           // holds "SB" - ORD_SCRBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

} SCRBLT_ORDER, FAR * LPSCRBLT_ORDER;

//
// @@@ The common parts of MEMBLT_ORDER / MEMBLT_R2_ORDER and MEM3BLT_ORDER
// / MEM3BLT_R2_ORDER should be merged into a single structure.  There is
// code which assumes that the common fields have the same types which goes
// wrong if these are not the same.
//


//
// Define the structure for Bitmap Cache Orders.
// These are sent in Order Packets as "private" orders.
//

//
// Define the possible Bitmap Cache Packet Types.
//
#define BMC_PT_BITMAP_BITS_UNCOMPRESSED   0
#define BMC_PT_COLOR_TABLE                1
#define BMC_PT_BITMAP_BITS_COMPRESSED     2


//
// NOTE: avoid unions to get structure size / alignment correct.
//


// Structure: BMC_BITMAP_BITS_DATA
//
// Description: This is the part of the bitmap bits order which is common
// to both R1 and R2 protocols.
//
typedef struct tagBMC_BITMAP_BITS_DATA
{
    TSHR_UINT8      bmcPacketType;      // One of:
                                    //   BMC_PT_BITMAP_BITS_COMPRESSED
                                    //   BMC_PT_BITMAP_BITS_UNCOMPRESSED
    TSHR_UINT8      cacheID;            // Cache ID
    // lonchanc: do not remove iCacheEntryR1 for backward compatibility
    TSHR_UINT8      iCacheEntryR1;      // Cache index (only used for R1
                                    //   protocol
    TSHR_UINT8      cxSubBitmapWidth;   // Bitmap width
    TSHR_UINT8      cySubBitmapHeight;  // Bitmap height
    TSHR_UINT8      bpp;                // Number of bits per pel of bitmap
    TSHR_UINT16     cbBitmapBits;       // Number of bytes of data required to
                                    //   send the bits.
}
BMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA           FAR  * PBMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA UNALIGNED FAR * PBMC_BITMAP_BITS_DATA_UA;




// Structure: BMC_BITMAP_BITS_ORDER_R2
//
// Description: The data which is sent across the wire for an R2 bitmap
// bits order.  The data field is the start of an array of bytes of length
// header.cbBitmapBits
//
// We need a 16 bit cache index in R2.  We could add another 8 bit entry
// and merge with the R1 field, but in the interests of protocol
// cleanliness we should add a whole 16 bit field and make the R1 index
// "reserved" in the protocol documentation.
//
//
typedef struct tagBMC_BITMAP_BITS_ORDER_R2
{
    BMC_BITMAP_BITS_DATA    header;         // Common header information
    TSHR_UINT16             iCacheEntryR2;  // R2 cache index.  The high
                                            //   byte is a color table
                                            //   index, and the low byte
                                            //   is the bitmap bits cache
                                            //   index.
    TSHR_UINT8              data[2];        // Start of the bitmap bits.
}
BMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 FAR           * PBMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 UNALIGNED FAR * PBMC_BITMAP_BITS_ORDER_R2_UA;


//
// Structure sent for color data.  The data field is the first entry in an
// array of colorTableSize entries.
//
typedef struct tagBMC_COLOR_TABLE_ORDER
{
    TSHR_UINT8         bmcPacketType;      // BMC_PT_COLORTABLE
    TSHR_UINT8         index;              // Color table cache index
    TSHR_UINT16        colorTableSize;     // Number of entries in the
                                        //   color table being sent.
    TSHR_RGBQUAD       data[1];            // Start of an array of color table
                                        //   entries.
}
BMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER FAR            * PBMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER UNALIGNED FAR * PBMC_COLOR_TABLE_ORDER_UA;



//
// MemBlt (Memory to Screen Blt)
// R1 protocol
//
typedef struct _MEMBLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

}
MEMBLT_ORDER, FAR * LPMEMBLT_ORDER;


//
// MemBltR2 (Memory to Screen Blt for R2 protocol)
// Added cache index
//
typedef struct _MEMBLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MC" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_UINT16    cacheIndex;

} MEMBLT_R2_ORDER, FAR * LPMEMBLT_R2_ORDER;


//
// Mem3Blt (Memory Pattern to Screen 3 way ROP Blt)
//
typedef struct _MEM3BLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

} MEM3BLT_ORDER, FAR * LPMEM3BLT_ORDER;

//
// Mem3Blt (Memory to Screen Blt) for R2 (multipoint) protocols
// Add a cache index field rather than using nXSrc.
//
typedef struct _MEM3BLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

    TSHR_UINT16    cacheIndex;

} MEM3BLT_R2_ORDER, FAR * LPMEM3BLT_R2_ORDER;

//
// Variable length text structure as used by TextOut and ExtTextOut orders
//
typedef struct tagVARIABLE_STRING
{
    TSHR_UINT32    len;
    TSHR_CHAR   string[ORD_MAX_STRING_LEN_WITHOUT_DELTAS];
    TSHR_UINT8        pad;
} VARIABLE_STRING;

//
// Variable length position deltas as used by ExtTextOut.
//
typedef struct tagVARIABLE_DELTAX
{
    TSHR_UINT32    len;
    TSHR_INT32     deltaX[ORD_MAX_STRING_LEN_WITH_DELTAS];
} VARIABLE_DELTAX, FAR * LPVARIABLE_DELTAX;

//
// Variable length point array used by Polygon.
//
typedef struct tagVARIABLE_POINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYGON_POINTS];
} VARIABLE_POINTS, FAR * LPVARIABLE_POINTS;

//
// Variable length point array used by PolyBezier.
//
typedef struct tagVARIABLE_BEZIERPOINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYBEZIER_POINTS];
} VARIABLE_BEZIERPOINTS, FAR * LPVARIABLE_BEZIERPOINTS;

//
// The common part of the TEXTOUT and EXTTEXTOUT orders
//
typedef struct tagCOMMON_TEXTORDER
{
    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // X location of string
    TSHR_INT32     nYStart;        // Y location of string

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     CharExtra;      // extra character spacing
    TSHR_INT32     BreakExtra;     // justification break amount
    TSHR_INT32     BreakCount;     // justification break count

    TSHR_INT32     FontHeight;
    TSHR_INT32     FontWidth;
    TSHR_UINT32    FontWeight;
    TSHR_UINT32    FontFlags;
    TSHR_UINT32    FontIndex;
} COMMON_TEXTORDER, FAR * LPCOMMON_TEXTORDER;

//
// TextOut
//
typedef struct _TEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "TO" - ORD_TEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    //
    // The following variable data occurs here.  (Remember to change the
    // code in OD2CalculateTextOutBounds if you change these).
    //
    VARIABLE_STRING variableString;

} TEXTOUT_ORDER, FAR * LPTEXTOUT_ORDER;


//
// ExtTextOut
//
typedef struct _EXTTEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "ET" - ORD_EXTTEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    TSHR_UINT16        fuOptions;      // option flags
    TSHR_UINT16        pad4;

    TSHR_RECT32     rectangle;

    //
    // The following variable data occurs here.
    //
    //      char[cbString]  - the string of chars to be output
    //      TSHR_INT32[cbString] - X deltas for the string
    //
    // (Remember to change the code in OD2CalculateExtTextOutBounds if you
    // change these).
    //
    VARIABLE_STRING variableString;

    VARIABLE_DELTAX variableDeltaX;

} EXTTEXTOUT_ORDER, FAR * LPEXTTEXTOUT_ORDER;

//
// Rectangle
//
typedef struct _RECTANGLE_ORDER
{
    TSHR_UINT16    type;           // holds "RT" - ORD_RECTANGLE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} RECTANGLE_ORDER, FAR * LPRECTANGLE_ORDER;

//
// LineTo
//
typedef struct _LINETO_ORDER
{
    TSHR_UINT16    type;           // holds "LT" - ORD_LINETO
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // x line start
    TSHR_INT32     nYStart;        // y line start
    TSHR_INT32     nXEnd;          // x line end
    TSHR_INT32     nYEnd;          // y line end

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;
} LINETO_ORDER, FAR * LPLINETO_ORDER;

//
// OpaqueRect
//
typedef struct _OPAQUE_RECT
{
    TSHR_UINT16    type;           // holds "OR" - ORD_OPAQUERECT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_COLOR     Color;          // opaque color
    TSHR_UINT8      pad2;
} OPAQUERECT_ORDER, FAR * LPOPAQUERECT_ORDER;

//
// SaveBitmap (incorporating RestoreBitmap)
//
#define SV_SAVEBITS      0
#define SV_RESTOREBITS   1

typedef struct _SAVEBITMAP_ORDER
{
    TSHR_UINT16    type;           // holds "SV" - ORD_SAVEBITMAP
    TSHR_INT16     pad1;

    TSHR_UINT32    SavedBitmapPosition;

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_UINT32    Operation;      // SV_xxxxxxxx
} SAVEBITMAP_ORDER, FAR * LPSAVEBITMAP_ORDER;

//
// Desktop scroll order
//
// The desktop order is special - it is a non-private order which is second
// level encoded, BUT support is not negotiated via its own entry in the
// capsOrdesr array in the orders capabilities.
//
// (Sending support is determined via a number of factors - at r2.x receive
// support for ORD_SCRBLT implies support for ORD_DESKSCROLL as well).
//
//
typedef struct _DESKSCROLL_ORDER
{
    TSHR_UINT16    type;           // holds "DS" - ORD_DESKSCROLL
    TSHR_INT16     pad1;

    TSHR_INT32     xOrigin;
    TSHR_INT32     yOrigin;
} DESKSCROLL_ORDER, FAR * LPDESKSCROLL_ORDER;


//
// Polygon
//
typedef struct _POLYGON_ORDER
{
    TSHR_UINT16    type;           // holds "PG" - ORD_POLYGON
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    FillMode;       // ORD_FILLMODE_ALTERNATE or
                                // ORD_FILLMODE_WINDING

    //
    // The following variable data occurs here.
    //
    VARIABLE_POINTS variablePoints;

} POLYGON_ORDER, FAR * LPPOLYGON_ORDER;


//
// Pie
//
typedef struct _PIE_ORDER
{
    TSHR_UINT16    type;           // holds "PI" - ORD_PIE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;


    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // ORD_ARC_COUNTERCLOCKWISE or
                                // ORD_ARC_CLOCKWISE
} PIE_ORDER, FAR * LPPIE_ORDER;


//
// Ellipse
//
typedef struct _ELLIPSE_ORDER
{
    TSHR_UINT16    type;           // holds "EL" - ORD_ELLIPSE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} ELLIPSE_ORDER, FAR * LPELLIPSE_ORDER;


//
// Arc
//
typedef struct _ARC_ORDER
{
    TSHR_UINT16    type;           // holds "AR" - ORD_ARC
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AS_CLOCKWISE
} ARC_ORDER, FAR * LPARC_ORDER;


//
// Chord
//
typedef struct _CHORD_ORDER
{
    TSHR_UINT16    type;           // holds "CD" - ORD_CHORD
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AD_CLOCKWISE
} CHORD_ORDER, FAR * LPCHORD_ORDER;


//
// PolyBezier
//
typedef struct _POLYBEZIER_ORDER
{
    TSHR_UINT16    type;           // holds "PZ" - ORD_POLYBEZIER
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad4;

    //
    // The following variable data occurs here.
    //
    VARIABLE_BEZIERPOINTS variablePoints;

} POLYBEZIER_ORDER, FAR * LPPOLYBEZIER_ORDER;


//
// RoundRect
//
typedef struct _ROUNDRECT_ORDER
{
    TSHR_UINT16    type;           // holds "RR" - ORD_ROUNDRECT
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_INT32     nEllipseWidth;  // ellipse width
    TSHR_INT32     nEllipseHeight; // ellipse height

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
}
ROUNDRECT_ORDER, FAR * LPROUNDRECT_ORDER;



////////////////////////////////
//
// ORDER ENCODING
//
////////////////////////////////


//
// Overview of Second Order Encoding
//
// Second order encoding works by only sending over the network the fields
// in an order which have changed since the last time the order was sent.
// A copy of the last example of each order sent is maintained at the
// encoding end and at the decoding end.  Whilst encoding, the fields in
// the order being encoded are checked against the fields in the copy of
// the last order of this type encoded.  The data in the field is only
// encoded if it has changed. The decoding end then only needs to copy the
// changed fields into its copy of the order.
//


//
// Encoded Order types.
//
// Note that most of these agree with the ORD_XXXXX defines, but not all,
// which is probably a mistake.  However it doesn't matter since the code
// does not assume equivalence.  It is unfortunately too late to change
// since the the shipping code uses the 2 sets of numbers:
//
//     - the OE2 protocol uses these numbers
//     - the capabilities structure uses the ORD_XXXXX numbers.
//
// Since this split exists, the DESKTOP SCROLL order, whose highword places
// it outside the CAPS_MAX_NUM_ORDERS range, is also mapped to a different
// number, so that the OE2 values have no gaps.
//
#define OE2_DSTBLT_ORDER      (HIWORD(ORD_DSTBLT))
#define OE2_PATBLT_ORDER      (HIWORD(ORD_PATBLT))
#define OE2_SCRBLT_ORDER      (HIWORD(ORD_SCRBLT))
#define OE2_MEMBLT_ORDER      (HIWORD(ORD_MEMBLT))
#define OE2_MEM3BLT_ORDER     (HIWORD(ORD_MEM3BLT))
#define OE2_TEXTOUT_ORDER     (HIWORD(ORD_TEXTOUT))
#define OE2_EXTTEXTOUT_ORDER  (HIWORD(ORD_EXTTEXTOUT))
// 0x07 was FastFrame, which is no longer supported.
#define OE2_RECTANGLE_ORDER   0x08
#define OE2_LINETO_ORDER      0x09
#define OE2_OPAQUERECT_ORDER  (HIWORD(ORD_OPAQUERECT))
#define OE2_SAVEBITMAP_ORDER  (HIWORD(ORD_SAVEBITMAP))
#define OE2_DESKSCROLL_ORDER  0x0c
#define OE2_MEMBLT_R2_ORDER   (HIWORD(ORD_MEMBLT_R2))
#define OE2_MEM3BLT_R2_ORDER  (HIWORD(ORD_MEM3BLT_R2))
#define OE2_POLYGON_ORDER     (HIWORD(ORD_POLYGON))
#define OE2_PIE_ORDER         (HIWORD(ORD_PIE))
#define OE2_ELLIPSE_ORDER     (HIWORD(ORD_ELLIPSE))
#define OE2_ARC_ORDER         (HIWORD(ORD_ARC))
#define OE2_CHORD_ORDER       (HIWORD(ORD_CHORD))
#define OE2_POLYBEZIER_ORDER  (HIWORD(ORD_POLYBEZIER))
#define OE2_ROUNDRECT_ORDER   (HIWORD(ORD_ROUNDRECT))
#define OE2_UNKNOWN_ORDER     0xFF


//
// #defines used to extract fields from a pointer to one of the text orders
//
#define TEXTFIELD(order)   ((TEXTOUT_ORDER*)(order->abOrderData))
#define EXTTEXTFIELD(order)   ((EXTTEXTOUT_ORDER*)(order->abOrderData))

//
// Number of order types.
//
#define OE2_NUM_TYPES  22

//
// Constants defining the number of changeable fields in an ORDER
// (including the "type" field which is always a word at the beginning of
// each order)
//
#define    OE2_NUM_DSTBLT_FIELDS       6
#define    OE2_NUM_PATBLT_FIELDS       13
#define    OE2_NUM_SCRBLT_FIELDS       8
#define    OE2_NUM_MEMBLT_FIELDS       9
#define    OE2_NUM_MEM3BLT_FIELDS      16
#define    OE2_NUM_TEXTOUT_FIELDS      15
#define    OE2_NUM_EXTTEXTOUT_FIELDS   22
#define    OE2_NUM_RECTANGLE_FIELDS    17
#define    OE2_NUM_LINETO_FIELDS       11
#define    OE2_NUM_OPAQUERECT_FIELDS   6
#define    OE2_NUM_SAVEBITMAP_FIELDS   7
#define    OE2_NUM_DESKSCROLL_FIELDS   3
#define    OE2_NUM_MEMBLT_R2_FIELDS    10
#define    OE2_NUM_MEM3BLT_R2_FIELDS   17
#define    OE2_NUM_POLYGON_FIELDS      15
#define    OE2_NUM_PIE_FIELDS          22
#define    OE2_NUM_ELLIPSE_FIELDS      17
#define    OE2_NUM_ARC_FIELDS          16
#define    OE2_NUM_CHORD_FIELDS        22
#define    OE2_NUM_POLYBEZIER_FIELDS   9
#define    OE2_NUM_ROUNDRECT_FIELDS    19


//
// ControlFlags:
//
// Information about how the order is encoded.  (See OE2_CF_XXX flags
// description).
//
// EncodedOrder:
//
// Contains N bytes of flags followed by an array of bytes containing the
// fields which have changed since this order was last encoded.  (If there
// are M fields in the order then N is M/8).  The position of each bit set
// in the flags gives the relative position of the entry for a field in the
// encoding table (if the first bit is set, then the entry is the first one
// in the encoding table etc.)
//
//
typedef struct tagDCEO2ORDER
{
    BYTE     ControlFlags;
    BYTE     EncodedOrder[1];
}
DCEO2ORDER;
typedef DCEO2ORDER FAR * PDCEO2ORDER;



//
// FLAGS USED INTERNALLY BY OE2
//
//  The encoded order (DCEO2ORDER) Flags field contains information
//  about which fields in the ORDER HEADER need updating
//  These control bits are the same for all orders and have the following
//  values:
//
#define OE2_CF_STANDARD_ENC     0x01U // standard encoding follows...
#define OE2_CF_UNENCODED        0x02U // not encoded
#define OE2_CF_BOUNDS           0x04U // bounding (clip) rectangle supplied
#define OE2_CF_TYPE_CHANGE      0x08U // type of order different from previous
#define OE2_CF_DELTACOORDS      0x10U // coords are TSHR_INT8 deltas from previous
#define OE2_CF_RESERVED1        0x20U //
#define OE2_CF_RESERVED2        0x40U //
#define OE2_CF_RESERVED3        0x80U //


//
// Flags use by OE2EncodeBounds and OE2DecodeBounds to indicate how the
// four coordinates in the bounding rectangle were encoded relative the the
// previous bounding rectangle.  The encoding used is a byte of flags
// followed by a variable number of 16bit coordinate values and 8bit delta
// coordinate values (which may be interleaved).  See functions for more
// information.
//
#define OE2_BCF_LEFT            0x01
#define OE2_BCF_TOP             0x02
#define OE2_BCF_RIGHT           0x04
#define OE2_BCF_BOTTOM          0x08
#define OE2_BCF_DELTA_LEFT      0x10
#define OE2_BCF_DELTA_TOP       0x20
#define OE2_BCF_DELTA_RIGHT     0x40
#define OE2_BCF_DELTA_BOTTOM    0x80

//
// OE2ETFIELD entry flag types.
//
#define OE2_ETF_FIXED           0x01
#define OE2_ETF_VARIABLE        0x02
#define OE2_ETF_COORDINATES     0x04
#define OE2_ETF_DATA            0x08

//
// Define the maximum sizes of fields within encoded orders.
//
#define  OE2_CONTROL_FLAGS_FIELD_SIZE       1
#define  OE2_TYPE_FIELD_SIZE                1
#define  OE2_MAX_FIELD_FLAG_BYTES           4
#define  OE2_MAX_ADDITIONAL_BOUNDS_BYTES    1




//////////////////////////////////////////
//
// T.SHARE PACKETS, FLOW CONTROL
//
//////////////////////////////////////////

//
// Maximum size of application packets (bytes).
// NOTE:
// Packet size can not just change.  There are no caps for it currently.
// Moreover, even though theoretically the field size is a WORD, flow
// control uses the high bit to determine flow packets.
//


//
// HEADER in front of TSHR_FLO_CONTROL/S20PACKETs
//

typedef struct tagTSHR_NET_PKT_HEADER
{
    TSHR_UINT16         pktLength;
}
TSHR_NET_PKT_HEADER;
typedef TSHR_NET_PKT_HEADER * PTSHR_NET_PKT_HEADER;


//
// Packet types:                                                           
// S20 packets have pktLength <  TSHR_PKT_FLOW            
// FLO packets have pktLength == TSHR_PKT_FLOW
//
#define TSHR_PKT_FLOW                                 0x8000


// WE'RE STUCK WITH THIS OUTGOING VALUE BECAUSE OF FLOW CONTROL!  IT ASSUMES
// PACKETS of size > MG_PKT_FLOW are flow control packets.  Back level dudes
// are hosted because of it...

#define TSHR_MAX_SEND_PKT         32000



typedef struct TSHR_FLO_CONTROL
{
    TSHR_UINT16             packetType;
    TSHR_UINT8              stream;
    TSHR_UINT8              pingPongID;
    TSHR_UINT16             userID;
}
TSHR_FLO_CONTROL;
typedef TSHR_FLO_CONTROL * PTSHR_FLO_CONTROL;


//
// TSHR_FLO_CONTROL packetType values
//
#define PACKET_TYPE_NOPING   0x0040
#define PACKET_TYPE_PING     0x0041
#define PACKET_TYPE_PONG     0x0042
#define PACKET_TYPE_PANG     0x0043




//////////////////////////////////////////
//
// T.SHARE CONTROL PACKETS
//
//////////////////////////////////////////

//
// CORRELATORS
//
// Most S20 messsages contain a correlator field.  This field is used
// to identify which share the message belongs to and is used to
// resolve races at share start up and discard stale messages received.
//
// A correlator is a 32 bit number which contains two parts.  The first
// 16 bits (the low word in Intel format) contains the user ID of the
// party which created the share.  The second 16 bits contains a count
// supplied by the party which created the share (ie the first share
// they create is 1 the second 2 etc).  This should ensure unique
// correlators for every share created for a long enough period to
// ensure no stale data is left.
//
// A new correlator is always present on a create message.  All
// respond, delete and leave messages must contain the correct
// correlator for the share.  A join message does not contain a
// correlator.  A party which issues a join message will find out the
// share's correlator on the first respond message they receive.
//
// Respond messages also contain the user ID of the party which sent
// out the original create or join to which they are responding.  There
// is one exception when a `sweep-up' respond is sent which contains
// zero in the originator field.  This respond is sent by a party which
// is joining a share as soon as they receive the first response (and
// therefore know the share correlator).  This sweep-up respond handles
// simultaneous joiners where a party was joining when it too received
// a join message.  When this happens the party ignores the join and
// will later receive a sweep-up respond message which they will
// process.
//


typedef struct tagS20PACKETHEADER
{
    TSHR_UINT16     packetType;
    TSHR_UINT16     user;
}
S20PACKETHEADER;
typedef S20PACKETHEADER * PS20PACKETHEADER;


//
// S20PACKETHEADER packetType values
//
// A single bit means that this version will only interoperate
// with itself.  More than one bit indicates cross version
// interoperability.
//
// IN NM 4.0, GET RID OF S20_2X_VERSION SUPPORT!
//
#define S20_PACKET_TYPE_MASK    0x000F
#define S20_2X_VERSION          0x0010
#define S20_30_VERSION          0x0020

#define S20_CURRENT_VERSION     S20_30_VERSION
#define S20_ALL_VERSIONS        (S20_2X_VERSION | S20_30_VERSION)

#define S20_CREATE              1
#define S20_JOIN                2
#define S20_RESPOND             3
#define S20_DELETE              4
#define S20_LEAVE               5
#define S20_END                 6
#define S20_DATA                7
#define S20_COLLISION           8



//
// To create the share
//
typedef struct tagS20CREATEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20CREATEPACKET;
typedef S20CREATEPACKET * PS20CREATEPACKET;



//
// To join a share created by somebody else
//
typedef struct tagS20JOINPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20JOINPACKET;
typedef S20JOINPACKET * PS20JOINPACKET;




//
// To respond to a create packet
//
typedef struct tagS20RESPONDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     originator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20RESPONDPACKET;
typedef S20RESPONDPACKET * PS20RESPONDPACKET;




//
// To remove a person from a share (if the creator can't join the person in)
//
typedef struct tagS20DELETEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     target;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20DELETEPACKET;
typedef S20DELETEPACKET * PS20DELETEPACKET;



//
// To leave a share yourself
//
typedef struct tagS20LEAVEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
}
S20LEAVEPACKET;
typedef S20LEAVEPACKET * PS20LEAVEPACKET;




//
// To end a share you created
//
typedef struct tagS20ENDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20ENDPACKET;
typedef S20ENDPACKET * PS20ENDPACKET;


//
// To tell somebody creating a share that one already exists
//
typedef struct tagS20COLLISIONPACKET
{
    S20PACKETHEADER     header;
    TSHR_UINT32         correlator;
}
S20COLLISIONPACKET;
typedef S20COLLISIONPACKET * PS20COLLISIONPACKET;





/////////////////////////////////
//
// T.SHARE DATA PACKETS
//
/////////////////////////////////


//
// Data sent when in share (this structure is followed by the different
// packets described below)
//
typedef struct tagDATAPACKETHEADER
{
    TSHR_UINT8      dataType;             // DT_ identifier
    TSHR_UINT8      compressionType;
    TSHR_UINT16     compressedLength;
}
DATAPACKETHEADER;
typedef DATAPACKETHEADER * PDATAPACKETHEADER;


//
// DATAPACKETHEADER dataType values
//

#define DT_UP                   0x02
#define DT_UNUSED_USR_FH_10     0x09    // OBSOLETE
#define DT_UNUSED_USR_FH_11     0x0A    // OBSOLETE
#define DT_FH                   0x0B

#define DT_CA                   0x14    // OLD (2.x)
#define DT_CA30                 0x15    // NEW (3.0)
#define DT_HET30                0x16    // NEW (3.0)
#define DT_AWC                  0x17
#define DT_UNUSED_SWL           0x18    // NOT FOR DESKTOP SHARING
#define DT_HET                  0x19    // OLD (2.x)
#define DT_UNUSED_DS            0x1A    // OBSOLETE
#define DT_CM                   0x1B
#define DT_IM                   0x1C    
#define DT_UNUSED_HCA           0x1D    // OBSOLETE
#define DT_UNUSED_SC            0x1E    // OBSOLETE
#define DT_SNI                  0x1F
#define DT_CPC                  0x20


//
// DATAPACKETHEADER compressionType values
//
// There are two formats for this field.
//
// If all nodes participating in the share session have the capability
// genCompressionLevel >= 1 then the compressionType is a one of the
// following 8bit integers.
//
// Otherwise the the packet is compressed with GCT_PKZIP if the top bit is
// set and the packet is not compressed if it is not set.  The remaining
// bits are undefined (and will NOT be all zero)
//
//
// Note: Each of these values has a GCT_... value associated with it.
//       These values indicate which bit of the GCT_... values this
//       compression type represents.  Eg. a value of 5 here pairs with the
//       value 0x0010 (ie bit 5 set)
//
#define     CT_NONE                 0
#define     CT_PKZIP                1
#define     CT_PERSIST_PKZIP        2
#define     CT_OLD_COMPRESSED       0x80




typedef struct tagS20DATAPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT8      ackID;                  // OBSOLETE
    TSHR_UINT8      stream;
    TSHR_UINT16     dataLength;

    DATAPACKETHEADER    data;
    // data specific to DT_ type follows here
}
S20DATAPACKET;
typedef S20DATAPACKET * PS20DATAPACKET;


//
// S20DATAPACKET stream values
//
//
// The streams and priotities used by AppSharing
//
#define PROT_STR_INVALID                0          
#define PROT_STR_UPDATES                1       // SNI_STREAM_LOW
#define PROT_STR_MISC                   2          
#define PROT_STR_UNUSED                 3       // NOT USED!    
#define PROT_STR_INPUT                  4
#define NUM_PROT_STR                    5





//
// DT_AWC
// Active Window packets
//

typedef struct tagAWCPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         token;          // OBSOLETE
    TSHR_UINT32         data1;
    TSHR_UINT32         data2;
}
AWCPACKET;
typedef AWCPACKET *PAWCPACKET;




//
// AWCPACKET msg values
//
#define AWC_MSG_INVALID                         0x0000
#define AWC_MSG_ACTIVE_CHANGE_LOCAL             0x0001
#define AWC_MSG_ACTIVE_CHANGE_SHARED            0x0002
#define AWC_MSG_ACTIVE_CHANGE_INVISIBLE         0x0003  
#define AWC_MSG_ACTIVE_CHANGE_CAPTURED          0x0004  // OBSOLETE
#define AWC_MSG_ACTIVATE_WINDOW                 0x8001
#define AWC_MSG_CLOSE_WINDOW                    0x8002  // OBSOLETE
#define AWC_MSG_RESTORE_WINDOW                  0x8003
#define AWC_MSG_TASKBAR_RBUTTON                 0x8004  // OBSOLETE
#define AWC_MSG_SAS                             0x8005
#define AWC_MSG_SYSCOMMAND_HELPKEYS             0x8011  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPINDEX            0x8012  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPEXTENDED         0x8013  // OBSOLETE



//
// DT_CA
// OLD Control Arbitration packets
//

typedef struct tagCAPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         data1;
    TSHR_UINT32         data2;
}
CAPACKET;
typedef CAPACKET *PCAPACKET;





//
// CAPACKET msg values, 2.x
// These are all broadcasted, control is global
//
#define CA_MSG_NOTIFY_STATE         0

//
// Notification (broadcast) packet
//
typedef struct tagCANOTPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         state;
    TSHR_UINT32         controllerID;
}
CANOTPACKET;
typedef CANOTPACKET * PCANOTPACKET;

//
// CA_MSG_NOTIFY_STATE
//  state               - controllable or not
//  controllerID        - controller net ID or 0 if nobody
//

// state flags:
#define CASTATE_ALLOWCONTROL        0x0001




//
// CA_OLDMSG_REQUEST_CONTROL
// Broadcasted to request taking of global control
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_GRANTED_CONTROL
// Broadcasted by node(s) who think they own the control token, when they
// grant the control token to node who asked for it via REQUEST.
//      data1   -   netID of person given control
//      data2   -   control token generation
//

//
// CA_OLDMSG_DETACH
// Broadcasted when node stops collaborating
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_COOPERATE
// Broadcasted when node starts collaborating
//      data1   -   unused
//      data2   -   unused
//




//
// DT_CA30
// NEW Control packets
//


//
// These are PRIVATE SEND packets, on PROT_STR_INPUT, from one node to another.
// They go out in order, and are queued if not able to send for retry later.
//

//
// Common header for CA30 packets.
//
typedef struct tagCA30PACKETHEADER
{
    S20DATAPACKET       header;
    TSHR_UINT32         msg;
}
CA30PACKETHEADER;
typedef CA30PACKETHEADER * PCA30PACKETHEADER;


//
// CA30PACKETHEADER msg values
//
#define CA_REQUEST_TAKECONTROL          1       // From viewer to host
#define CA_REPLY_REQUEST_TAKECONTROL    2       // From host to viewer
#define CA_REQUEST_GIVECONTROL          3       // From host to viewer
#define CA_REPLY_REQUEST_GIVECONTROL    4       // From viewer to host
#define CA_PREFER_PASSCONTROL           5       // From controller to host

#define CA_INFORM_RELEASEDCONTROL       0x8001  // From controller to host
#define CA_INFORM_REVOKEDCONTROL        0x8002  // From host to controller
#define CA_INFORM_PAUSEDCONTROL         0x8003  // From host to controller
#define CA_INFORM_UNPAUSEDCONTROL       0x8004  // From host to controller


//
// REPLY packet result values
//
#define CARESULT_CONFIRMED                      0
#define CARESULT_DENIED                         1
#define CARESULT_DENIED_BUSY                    2
#define CARESULT_DENIED_USER                    3
#define CARESULT_DENIED_WRONGSTATE              4
#define CARESULT_DENIED_TIMEDOUT                5



//
// ALL packets also have a CA30PACKETHEADER in front of them.
//


//
// CA_REQUEST_TAKECONTROL
//  Sender      is viewer
//  Receiver    is host
//      viewerControlID -   unique viewer request ID
//
// Receiver should reply with CA_REPLY_REQUEST_TAKECONTROL
// Sender should cancel with CA_INFORM_RELEASEDCONTROL
//
typedef struct tagCA_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
}
CA_RTC_PACKET;
typedef CA_RTC_PACKET * PCA_RTC_PACKET;



//
// CA_REPLY_REQUEST_TAKECONTROL
//  Sender      is host
//  Receiver    is viewer, who sent original TAKECONTROL request
//      viewerControlID -   viewer request ID from TAKECONTROL request
//      hostControlID   -   unique host request ID
//      result          -   CARESULT value, success or failure
//
typedef struct tagCA_REPLY_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         result;
    TSHR_UINT32         hostControlID;
}
CA_REPLY_RTC_PACKET;
typedef CA_REPLY_RTC_PACKET * PCA_REPLY_RTC_PACKET;




//
// CA_PREFER_PASSCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   controller request ID from take operation
//      hostControlID   -   host request ID from reply to take operation.
//      mcsPassTo       -   MCS ID of viewer to pass to
//
// No reply is required
// Sender is not in control when this gets out
// Receiver can then, if he chooses, turn around and ask 3rd party to control
//
typedef struct tagCA_PPC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
    TSHR_UINT32         mcsPassTo;
}
CA_PPC_PACKET;
typedef CA_PPC_PACKET * PCA_PPC_PACKET;




//
// CA_REQUEST_GIVECONTROL
//  Sender      is host
//  Receiver    is viewer
//      hostControlID   -   unique host request ID
//      mcsPassFrom     -   person passing control, zero if none
//
// Receiver should reply with CA_REPLY_REQUEST_GIVECONTROL
// Sender should cancel with CA_INFORM_REVOKEDCONTROL
//
typedef struct tagCA_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    TSHR_UINT32         mcsPassFrom;
}
CA_RGC_PACKET;
typedef CA_RGC_PACKET * PCA_RGC_PACKET;



//
// CA_REPLY_REQUEST_GIVECONTROL
//  Sender      is viewer
//  Receiver    is host, who sent original TAKECONTROL invite
//      hostControlID   -   host request ID from TAKECONTROL invite
//      mcsPassFrom     -   person passing us control, 0 if none
//      result          -   CARESULT value, success or failure
//      viewerControlID -   unique viewer request ID
//
typedef struct tagCA_REPLY_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    TSHR_UINT32         mcsPassFrom;
    TSHR_UINT32         result;
    TSHR_UINT32         viewerControlID;
}
CA_REPLY_RGC_PACKET;
typedef CA_REPLY_RGC_PACKET * PCA_REPLY_RGC_PACKET;




//
// INFORM packets
// These are sent to cancel a REQUEST packet, or after the control
// operation has completed, to terminate it.  If cancelling, then the 
// other party's controlID will be zero since we won't have heard back from
// them yet to get it.
//
typedef struct tagCA_INFORM_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
}
CA_INFORM_PACKET;
typedef CA_INFORM_PACKET * PCA_INFORM_PACKET;


//
// CA_INFORM_RELEASEDCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   viewer request ID from 
//          REQUEST_TAKECONTROL 
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If viewer is cancelling REQUEST_TAKECONTROL then hostControlID is 0
//

//
// CA_INFORM_REVOKEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If host is cancelling REQUEST_GIVECONTROL then viewerControlID is 0
//

//
// CA_INFORM_PAUSEDCONTROL
// CA_INFORM_UNPAUSEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//



//
// DT_CM
// Cursor shape/position packets
//      There are three types of shape packets: mono bitmaps, color cached,
//      constant IDs
//


typedef struct tagCMPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         type;
    TSHR_UINT16         flags;
}
CMPACKETHEADER;
typedef CMPACKETHEADER * PCMPACKETHEADER;




//
// CMPACKETHEADER type values
//
#define CM_CURSOR_ID                        1
#define CM_CURSOR_MONO_BITMAP               2
#define CM_CURSOR_MOVE                      3
#define CM_CURSOR_BITMAP_COMPRESSED         4   // OBSOLETE
#define CM_CURSOR_COLORTABLE                5   // OBSOLETE
#define CM_CURSOR_COLOR_BITMAP              6
#define CM_CURSOR_COLOR_CACHE               7


//
// CMPACKETHEADER sync flag values
//
#define CM_SYNC_CURSORPOS                   0x0001
    //
    // This will be set if, when we played back input, the cursor
    // didn't end up where it was asked to go.  This could happen if an
    // app clips the cursor or snaps it.  As such, we mark this field
    // when we send a notification of our current pos so that the controller
    // knows to move his cursor to be in line with ours.
    //



//
// type CM_CURSOR_ID
//
// This packet is sent when the cursor has changed and it is now one of
// the system cursors.
//
typedef struct tagCMPACKETID
{
    CMPACKETHEADER      header;

    TSHR_UINT32         idc;
}
CMPACKETID;
typedef CMPACKETID * PCMPACKETID;




//
// CMPACKETID idc values
//
#define CM_IDC_NULL         0
#define CM_IDC_ARROW        32512


//
// type CM_CURSOR_MONO_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined mono cursor.
//
// The cursor size cannot be greater than 32x32.
typedef struct tagCMPACKETMONOBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     width;
    TSHR_UINT16     height;
    TSHR_UINT16     cbBits;
    BYTE            aBits[1];
}
CMPACKETMONOBITMAP;
typedef CMPACKETMONOBITMAP * PCMPACKETMONOBITMAP;





//
// type CM_CURSOR_COLOR_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined color cursor.
//
typedef struct tagCMPACKETCOLORBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     cacheIndex;
    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     cxWidth;
    TSHR_UINT16     cyHeight;
    TSHR_UINT16     cbANDMask;
    TSHR_UINT16     cbXORBitmap;
    BYTE            aBits[1];
}
CMPACKETCOLORBITMAP;
typedef CMPACKETCOLORBITMAP * PCMPACKETCOLORBITMAP;





//
// type CM_CURSOR_COLOR_CACHE
//
// This packet is sent out when the cursor changes and the new
// definition resides in the cache.
//
//
typedef struct tagCMPACKETCOLORCACHE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         cacheIndex;
}
CMPACKETCOLORCACHE;
typedef CMPACKETCOLORCACHE * PCMPACKETCOLORCACHE;






//
// type CM_CURSOR_MOVE
//
// This packet is sent whenever the CM is told that the application has
// moved the cursor.
//
typedef struct tagCMPACKETMOVE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         xPos;
    TSHR_UINT16         yPos;
}
CMPACKETMOVE;
typedef CMPACKETMOVE * PCMPACKETMOVE;





//
// DT_CPC
// Capabilities change packet
//
typedef struct tagCPCPACKET
{
    S20DATAPACKET       header;

    PROTCAPS            caps;
}
CPCPACKET;
typedef CPCPACKET * PCPCPACKET;




//
// DT_FH
// Supported local font list packet
//



//
// The NETWORKFONT is the font description which is sent across the network
// when negotiating font support.
//

//
// Flags for the nfFontFlags field
//
#define NF_FIXED_PITCH      0x0001
#define NF_FIXED_SIZE       0x0002
#define NF_ITALIC           0x0004
#define NF_UNDERLINE        0x0008
#define NF_STRIKEOUT        0x0010

#define NF_OEM_CHARSET      0x0020
#define NF_RESERVED1        0x0040      // Reserved for future BiDi support
#define NF_TRUE_TYPE        0x0080
#define NF_BASELINE         0x0100

#define NF_PRE_R11      (NF_FIXED_PITCH | NF_FIXED_SIZE | \
                         NF_ITALIC | NF_UNDERLINE | NF_STRIKEOUT)

//
// Mask for local-only font flags - that must not flow on the wire.
//
#define NF_LOCAL            (NF_OEM_CHARSET | NF_TRUE_TYPE)

//
// A special value for the signature field which means no signature.
//
#define NF_NO_SIGNATURE 0

//
// The FH_FACESIZE is equal to the Windows specific constant LF_FACESIZE.
//
#define FH_FACESIZE 32


//
// SFRFONT
// Let us define these things more fully...
// nfFaceName   font face name (not family name, not style)
// nfFontFlags  see above
// nfAveWidth   in Windows set to tmAveCharWidth
// nfAveHeight  NOT THE AVERAGE HEIGHT but the height of a character with
//              full ascender (but no accent) AND descender.  There is no
//              such character but never mind.
//              Windows: set to tmHeight - tmInternalLeading
// nfAspectX
// nfAspectY
// nfSignature: in R11 set to an obscure checksum
//              in R20 set to two one-byte values and one two byte value.
//              Based on the widths of the actual text for fixed width
//              fonts and on 16x16 scalable fonts.  .
//              (The 16x16 is effectively part of the protocol)
//              nfSigFats   the sum of the widths (in pels) of the chars
//                          0-9,@-Z,$,%,&. divided by two: the fat chars
//              nfSigThins  the sum of the widths (in pels) of the chars
//                          0x20->0x7F EXCLUDING those summed in nfSigFats.
//                          Again - divided by two.  The thin chars.
//              nfSigSymbol The sum of the widths (in pels) of the chars
//                          x80->xFF.
// nfCodePage:  new use in R20: code page (not charset)
//              This field is set to 0 for ANSI (meaning WINDOWS ANSI)
//                         is set to 255 for OEM (meaning Windows OEM font)
//                         is set to the defined codepage if known
//                         is set to 0xFFFF when not known.
//
// nfMaxAscent:     The height of a character with no descender, plus any
//              internal leading.
//              = tmAscent in windows
//              For fixed size fonts we send the values you would expect.
//              For scalable fonts, we get the tmAscent (or equivalent) for
//              a very large font (say height-by-width of 100x100).  The
//              size selected must be the same on ALL platforms so is
//              effectively part of the protocol - hence is defined in
//              this file as NF_MAXASCENT_HEIGHT and .._WIDTH.
//
//
#define NF_CP_WIN_ANSI      0
#define NF_CP_WIN_SYMBOL    2
#define NF_CP_WIN_OEM       255
#define NF_CP_UNKNOWN       0xFFFF

//
// Define the start and end point of the ASCII sub-range
//
#define NF_ASCII_FIRST       0x20
#define NF_ASCII_LAST        0x7F
#define NF_ASCII_ZERO        0x30
#define NF_ASCII_Z           0x5B
#define NF_ASCII_DOLLAR      0x24
#define NF_ASCII_PERCENT     0x25
#define NF_ASCII_AMPERSAND   0x26


//
// The height/width of the font to ask for when getting the metrics info
// for scalable fonts.
// These (in particular the height) are CHARACTER SIZES not CELL sizes.
// This is because the font protocol exchanges character sizes not cell
// sizes.  (The char height is the cell height minus any internal leading.)
//
#define NF_METRICS_HEIGHT 100
#define NF_METRICS_WIDTH  100

//
// The wire-format font information structure
//
typedef struct tagNETWORKFONT
{
    TSHR_CHAR      nfFaceName[FH_FACESIZE];
    TSHR_UINT16    nfFontFlags;
    TSHR_UINT16    nfAveWidth;
    TSHR_UINT16    nfAveHeight;
    TSHR_UINT16    nfAspectX;          // New field for r1.1
    TSHR_UINT16    nfAspectY;          // New field for r1.1
    TSHR_UINT8     nfSigFats;          // New field for r2.0
    TSHR_UINT8     nfSigThins;         // New field for r2.0
    TSHR_UINT16    nfSigSymbol;        // New field for r2.0
    TSHR_UINT16    nfCodePage;         // New field for R2.0
    TSHR_UINT16    nfMaxAscent;        // New field for R2.0
}
NETWORKFONT;
typedef NETWORKFONT * LPNETWORKFONT;


typedef struct tagFHPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         cFonts;
    TSHR_UINT16         cbFontSize;
    NETWORKFONT         aFonts[1];
}
FHPACKET;
typedef FHPACKET * PFHPACKET;




//
// DT_HET
// Hosting state (nothing, apps, desktop)
//

typedef struct tagHETPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         hostState;  // ONLY ONE VALUE FOR MSG; IF MORE MAKE MORE STRUCTS
}
HETPACKET;
typedef HETPACKET * PHETPACKET;



//
// HETPACKET msg values
//
#define HET_MSG_NUMHOSTED           1


//
// HETPACKET hostState values
//
#define HET_NOTHOSTING              0
#define HET_APPSSHARED              0x0001      // Packet only
#define HET_DESKTOPSHARED           0xFFFF      // Packet and per-person data



//
// DT_IM
// Input events
//

//
// This is the base keyboard event (IM_TYPE_ASCII, IM_TYPE_VK1,
// IM_TYPE_VK2).  Future keyboard events may append extra fields.  The
// flags defined in the base keyboard event must be set to reasonable
// values in all future keyboard events.
//
// flags:
//
//  bit 0-6: unused (available for future keyboard events)
//  bit 7: Secondary key (unused).
//  bit 8: SET - extended key, RESET - normal key
//  bit 9-11: unused (available for future keyboard events)
//  bit 12: SET - when replayed this key stroke should NOT cause
// anything to happen
//  bit 13: reserved - this flag is not part of the protocol and is
// never sent.  It is used internally by IEM when processing received
// packets.
//  bit 14: SET - previously down, RESET previously up
//  bit 15: SET - key release, RESET key press
//
//
typedef struct tagIMKEYBOARD
{
    TSHR_UINT16     flags;
    TSHR_UINT16     keyCode;
}
IMKEYBOARD;
typedef IMKEYBOARD * PIMKEYBOARD;


//
// IMKEYBOARD flags values
//
#define IM_FLAG_KEYBOARD_RIGHT              0x0001
#define IM_FLAG_KEYBOARD_UPDATESTATE        0x0002  // not sent; just internal
#define IM_FLAG_KEYBOARD_SECONDARY          0x0080
#define IM_FLAG_KEYBOARD_EXTENDED           0x0100
#define IM_FLAG_KEYBOARD_QUIET              0x1000
#define IM_FLAG_KEYBOARD_ALT_DOWN           0x2000
#define IM_FLAG_KEYBOARD_DOWN               0x4000
#define IM_FLAG_KEYBOARD_RELEASE            0x8000

//
// This is the base mouse event (IM_TYPE_3BUTTON).  Future mouse events
// may append extra fields but they must include all the fields in the
// base mouse event and these must be set to reasonable values.
//
// flags:
//
//  bit 0-8: ignored by old systems
//           new systems: signed wheel rotation amount if bit 9 set
//  bit 9:   ignored by old systems
//           new systems: SET - wheel rotate, RESET - other event
//                          (takes precedent over bit 11 - mouse move)
//
//  bit 10:  SET - double click, RESET - single click
//  bit 11:  SET - mouse move (ignore bits 9,10, 12-15), RESET - mouse
//           action
//  bit 12:  SET - button 1 (left button)
//  bit 13:  SET - button 2 (right button)
//  bit 14:  SET - button 3 (middle button)
//  bit 15:  SET - button press, RESET - button release
//
//
typedef struct tagIMMOUSE
{
    TSHR_UINT16    flags;
    TSHR_INT16     x;
    TSHR_INT16     y;
}
IMMOUSE;
typedef IMMOUSE * PIMMOUSE;


//
// IMMOUSE flags values
//
#define IM_FLAG_MOUSE_WHEEL             0x0200
#define IM_FLAG_MOUSE_DIRECTION         0x0100
#define IM_FLAG_MOUSE_ROTATION_MASK     0x01FF
#define IM_FLAG_MOUSE_DOUBLE            0x0400
#define IM_FLAG_MOUSE_MOVE              0x0800
#define IM_FLAG_MOUSE_BUTTON1           0x1000
#define IM_FLAG_MOUSE_BUTTON2           0x2000
#define IM_FLAG_MOUSE_BUTTON3           0x4000
#define IM_FLAG_MOUSE_DOWN              0x8000


typedef struct tagIMEVENT
{
    TSHR_UINT32     timeMS;
    TSHR_UINT16     type;
    union
    {
        IMKEYBOARD      keyboard;
        IMMOUSE         mouse;
    }
    data;
}
IMEVENT;
typedef IMEVENT *     PIMEVENT;
typedef IMEVENT FAR * LPIMEVENT;


//
// IMEVENT type values
//
#define IM_TYPE_SYNC            0x0000          // OBSOLETE 2.X
#define IM_TYPE_ASCII           0x0001
#define IM_TYPE_VK1             0x0002
#define IM_TYPE_VK2             0x0003
#define IM_TYPE_3BUTTON         0x8001


typedef struct tagIMPACKET
{
    S20DATAPACKET   header;

    TSHR_UINT16     numEvents;
    TSHR_UINT16     padding;
    IMEVENT         aEvents[1];
}
IMPACKET;
typedef IMPACKET *     PIMPACKET;
typedef IMPACKET FAR * LPIMPACKET;




//
// DT_UP
// Update packet (orders, screen data, palettes)
//


typedef struct tagUPPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         updateType;
    TSHR_UINT16         padding;
}
UPPACKETHEADER;
typedef UPPACKETHEADER * PUPPACKETHEADER;




//
// UPPACKETHEADER updateType values
//
#define UPD_ORDERS       0
#define UPD_SCREEN_DATA  1
#define UPD_PALETTE      2
#define UPD_SYNC         3


//
// UPD_ORDERS
//
typedef struct tagORDPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT16         cOrders;
    TSHR_UINT16         sendBPP;
    BYTE                data[1];
}
ORDPACKET;
typedef ORDPACKET * PORDPACKET;




//
// UPD_SCREEN_DATA
//
// Bitmap packet contains bitmap image of window changes made by a shared
// application.  These packets are sent when a screen update occurs that
// can not be sent as an order. The structure contains the following
// fields:
//
//  winID - window handle of the shared window from which the update came
//  position - virtual desktop position of the update
//  realWidth - width of update bitmap
//  realHeight - height of update bitmap
//  format - bits per pel of update bitmap
//  dataSize - size in bytes of following bitmap data
//  firstData - first byte in array of bytes that contains the bitmap
//
// Note that the realWidth is not always the same as the width of the
// update as given by the position field rectangle. This is because a
// number of fixed size cached bitmaps are used for speed when generating
// the update packets. The bitmap data (firstData onwards) should be
// set into a bitmap of realWidth, realHeight dimensions by the receiver
// and then the appropriate portion blted to the desired destination
// determined by the position rectangle. The valid portion of the bitmap
// always starts 0,0 within the bitmap.
//
typedef struct tagSDPACKET
{
    UPPACKETHEADER      header;

    TSHR_RECT16         position;
    TSHR_UINT16         realWidth;
    TSHR_UINT16         realHeight;
    TSHR_UINT16         format;
    TSHR_UINT16         compressed;
    TSHR_UINT16         dataSize;
    BYTE                data[1];
}
SDPACKET;
typedef SDPACKET * PSDPACKET;




//
// UPD_PALETTE
//
// Palette packet.  This is sent before any SDPACKETS to define the
// colors in the bitmap data.  The fields are as follows:
//
//  numColors - the number of colors in the palette
//  firstColor - the first entry in an array of TSHR_COLORs
//
// The TSHR_COLOR structures are 3 bytes long (r,g,b) and are NOT padded.
//
//
typedef struct tagPMPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT32         numColors;
    TSHR_COLOR          aColors[1];
}
PMPACKET;
typedef PMPACKET * PPMPACKET;



//
// UPD_SYNC
//
typedef struct tagUPSPACKET
{
    UPPACKETHEADER      header;
}
UPSPACKET;
typedef UPSPACKET * PUPSPACKET;




//
// DT_SNI
// Share controller packet
//

typedef struct tagSNIPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         message;
    TSHR_UINT16         destination;
}
SNIPACKET;
typedef SNIPACKET * PSNIPACKET;



//
// SNIPACKET message values
//
#define SNI_MSG_SYNC    1

//
// For a SNI_MSG_SYNC,
// The network ID of the destination (all syncs are broadcast
// and discarded at the destination if they are not for the
// destination).
//



#endif // _H_T_SHARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\view.h ===
//
// View UI to present shared applications/desktop of a remote host
//

#ifndef _H_VIEW
#define _H_VIEW


//
//
// CONSTANTS
//
//

//
// The class name of the frame containing the view of shared applications
// from a particular user.
//
#define VIEW_FRAME_CLASS_NAME           "Salem_Frame"
#define VIEW_CLIENT_CLASS_NAME          "Salem_Client"
#define VIEW_FULLEXIT_CLASS_NAME        "Salem_FullExit"


//
// Metrics
//

//
// LAURABU:  For international, consider making this larger (i.e, German,
// Slavic, and DBCS systems)
//
#define VIEW_MAX_ITEM_CHARS             20

//
// IDs
//
#define IDVIEW_ITEMS         1      // Window bar item list
#define IDVIEW_SCROLL        2      // Window bar scroll
#define IDT_AUTOSCROLL      50      // Period is DoubleClick time metric


//
// Init/Term
//
BOOL VIEW_Init(void);
void VIEW_Term(void);


//
// Frame
//
LRESULT CALLBACK VIEWFrameWindowProc(HWND, UINT, WPARAM, LPARAM);


//
// View
//
LRESULT CALLBACK VIEWClientWindowProc(HWND, UINT, WPARAM, LPARAM);

//
// FullScreen Exit
//
LRESULT CALLBACK VIEWFullScreenExitProc(HWND, UINT, WPARAM, LPARAM);

//
// Informational dialog
//
INT_PTR    CALLBACK VIEWDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_VIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\thk\asthkls.inc ===
; File: asthkls.inc
;
; Nothing here
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\thk\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\usr.h ===
//
// Update Shared Regions
//

#ifndef _H_USR
#define _H_USR

//
//                                                                         
// CONSTANTS                                                               
//                                                                         
//

//
// Drawing order support constants.                                        
//
#define MAX_X_SIZE               128
#define MEGA_X_SIZE              256
#define MEGA_WIDE_X_SIZE        1024




//
// Used for bitmap and cache hatching.
//
#define USR_HATCH_COLOR_RED  1
#define USR_HATCH_COLOR_BLUE 2



//
// Default order packet sizes.                                             
//                                                                         
// Note that this is the size of the initially allocated packet.  After the
// packet has been processed by the General Data Compressor (GDC) the      
// transmitted packet size may well be smaller than the specified value.   
//                                                                         
// Also note that (in general) the smaller the order packets are, the worse
// the GDC compression ratio will be (it prefers to compress big packets). 
//                                                                         
//

#define SMALL_ORDER_PACKET_SIZE  0x0C00
#define LARGE_ORDER_PACKET_SIZE  0x7800




//
//                                                                         
// PROTOTYPES                                                              
//                                                                         
//


//
//
// Force the window to redraw along with all its children.  (Need to use   
// RDW_ERASENOW flag because otherwise RedrawWindow makes the mistake of  
// posting the WM_PAINT before the WM_ERASE.  BeginPaint call will validate
// all of the window so the WM_ERASE will have a null update region).      
//
#if defined(DLL_CORE) || defined(DLL_HOOK)
 
void __inline USR_RepaintWindow(HWND hwnd)
{
    UINT    flags = RDW_FRAME | RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN;

    if (hwnd)
    {
        //
        // Only erasenow/updatenow for top level windows.  The desktop's
        // children are all on different threads, this would cause out-of-
        // order results.
        //
        flags |= RDW_ERASENOW | RDW_UPDATENOW;
    }

    RedrawWindow(hwnd, NULL, NULL, flags);
}

#endif // DLL_CORE or DLL_HOOK




#endif // _H_USR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\global.h ===
#ifndef _MAKECERT_GLOBAL_H
#define _MAKECERT_GLOBAL_H

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <wincrypt.h>

#include <confdbg.h>
#include <strutil.h>
#include <regentry.h>
#include <confreg.h>
#include <nmmkcert.h>

#include "nmpvkhlp.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\winddi40.h ===
/*++

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:

    winddi.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interface.

--*/

#ifndef _WINDDI_
#define _WINDDI_

#include <ddrawint.h>

//
// drivers and other components that include this should NOT include
// windows.h  They should be system conponents that only use GDI internals
// and therefore only include wingdi.h
//

typedef ptrdiff_t PTRDIFF;
typedef PTRDIFF    *PPTRDIFF;
typedef LONG FIX;
typedef FIX     *PFIX;
typedef ULONG ROP4;
typedef ULONG MIX;

typedef ULONG HGLYPH;
typedef HGLYPH *PHGLYPH;
#define HGLYPH_INVALID ((HGLYPH)-1)

typedef ULONG           IDENT;

//
// handles for font file and font context objects
//

typedef ULONG HFF;
typedef ULONG HFC;
#define HFF_INVALID ((HFF) 0)
#define HFC_INVALID ((HFC) 0)

#define FD_ERROR  0xFFFFFFFF
#define DDI_ERROR 0xFFFFFFFF

typedef struct _POINTE      /* pte  */
{
    FLOAT x;
    FLOAT y;
} POINTE, *PPOINTE;

typedef union _FLOAT_LONG
{
   FLOAT   e;
   LONG    l;
} FLOAT_LONG, *PFLOAT_LONG;

typedef struct  _POINTFIX
{
    FIX   x;
    FIX   y;
} POINTFIX, *PPOINTFIX;

typedef struct _RECTFX
{
    FIX   xLeft;
    FIX   yTop;
    FIX   xRight;
    FIX   yBottom;
} RECTFX, *PRECTFX;


DECLARE_HANDLE(HBM);
DECLARE_HANDLE(HDEV);
DECLARE_HANDLE(HSURF);
DECLARE_HANDLE(DHSURF);
DECLARE_HANDLE(DHPDEV);
DECLARE_HANDLE(HDRVOBJ);

#define LTOFX(x)            ((x)<<4)

#define FXTOL(x)            ((x)>>4)
#define FXTOLFLOOR(x)       ((x)>>4)
#define FXTOLCEILING(x)     ((x + 0x0F)>>4)
#define FXTOLROUND(x)       ((((x) >> 3) + 1) >> 1)

// context information

typedef struct _FD_XFORM {
        FLOAT eXX;
        FLOAT eXY;
        FLOAT eYX;
        FLOAT eYY;
} FD_XFORM, *PFD_XFORM;



typedef struct _FD_DEVICEMETRICS {       // devm
    FLONG  flRealizedType;
    POINTE pteBase;
    POINTE pteSide;
    LONG   lD;
    FIX    fxMaxAscender;
    FIX    fxMaxDescender;
    POINTL ptlUnderline1;
    POINTL ptlStrikeOut;
    POINTL ptlULThickness;
    POINTL ptlSOThickness;
    ULONG  cxMax;                      // max pel width of bitmaps

// the fields formerly in REALIZE_EXTRA as well as some new fields:

    ULONG cyMax;      // did not use to be here
    ULONG cjGlyphMax; // (cxMax + 7)/8 * cyMax, or at least it should be

    FD_XFORM  fdxQuantized;
    LONG      lNonLinearExtLeading;
    LONG      lNonLinearIntLeading;
    LONG      lNonLinearMaxCharWidth;
    LONG      lNonLinearAvgCharWidth;

// some new fields

    LONG      lMinA;
    LONG      lMinC;
    LONG      lMinD;

    LONG      alReserved[1]; // just in case we need it.

} FD_DEVICEMETRICS, *PFD_DEVICEMETRICS;

typedef struct _LIGATURE { /* lig */
        ULONG culSize;
        LPWSTR pwsz;
        ULONG chglyph;
        HGLYPH ahglyph[1];
} LIGATURE, *PLIGATURE;

typedef struct _FD_LIGATURE {
        ULONG culThis;
        ULONG ulType;
        ULONG cLigatures;
        LIGATURE alig[1];
} FD_LIGATURE;


// glyph handle must be 32 bit


// signed 16 bit integer type denoting number of FUnit's

typedef SHORT FWORD;

// point in the 32.32 bit precission

typedef struct _POINTQF    // ptq
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
} POINTQF, *PPOINTQF;

//. Structures


//     devm.flRealizedType flags

// FDM_TYPE_ZERO_BEARINGS           // all glyphs have zero a and c spaces

// the following two features refer to all glyphs in this font realization

// FDM_TYPE_CHAR_INC_EQUAL_BM_BASE  // base width == cx for horiz, == cy for vert.
// FDM_TYPE_MAXEXT_EQUAL_BM_SIDE    // side width == cy for horiz, == cx for vert.

#define FDM_TYPE_BM_SIDE_CONST          0x00000001
#define FDM_TYPE_MAXEXT_EQUAL_BM_SIDE   0x00000002
#define FDM_TYPE_CHAR_INC_EQUAL_BM_BASE 0x00000004
#define FDM_TYPE_ZERO_BEARINGS          0x00000008
#define FDM_TYPE_CONST_BEARINGS         0x00000010


// structures for describing a supported set of glyphs in a font

typedef struct _WCRUN {
    WCHAR   wcLow;        // lowest character in run  inclusive
    USHORT  cGlyphs;      // wcHighInclusive = wcLow + cGlyphs - 1;
    HGLYPH *phg;          // pointer to an array of cGlyphs HGLYPH's
} WCRUN, *PWCRUN;

// If phg is set to (HGLYPH *)NULL, for all wc's in this particular run
// the handle can be computed as simple zero extension:
//        HGLYPH hg = (HGLYPH) wc;
//
// If phg is not NULL, memory pointed to by phg, allocated by the driver,
// WILL NOT MOVE.


typedef struct _FD_GLYPHSET {
    ULONG    cjThis;           // size of this structure in butes
    FLONG    flAccel;          // accel flags, bits to be explained below
    ULONG    cGlyphsSupported; // sum over all wcrun's of wcrun.cGlyphs
    ULONG    cRuns;
    WCRUN    awcrun[1];        // an array of cRun WCRUN structures
} FD_GLYPHSET, *PFD_GLYPHSET;

// If GS_UNICODE_HANDLES  bit is set,
// for ALL WCRUNS in this FD_GLYPHSET the handles are
// obtained by zero extending unicode code points of
// the corresponding supported glyphs, i.e. all gs.phg's are NULL

#define GS_UNICODE_HANDLES      0x00000001

// If GS_8BIT_HANDLES bit is set, all handles are in 0-255 range.
// This is just an ansi font then and we are really making up all
// the unicode stuff about this font.

#define GS_8BIT_HANDLES         0x00000002

// all handles fit in 16 bits.
// to 8 bit handles as it should.

#define GS_16BIT_HANDLES        0x00000004


// ligatures


typedef struct _FD_KERNINGPAIR {
    WCHAR  wcFirst;
    WCHAR  wcSecond;
    FWORD  fwdKern;
} FD_KERNINGPAIR;

// IFIMETRICS constants

#define FM_VERSION_NUMBER                   0x0

//
// IFIMETRICS::fsType flags
//
#define FM_TYPE_LICENSED                    0x2
#define FM_READONLY_EMBED                   0x4
#define FM_EDITABLE_EMBED                   0x8
#define FM_NO_EMBEDDING                     FM_TYPE_LICENSED

//
// IFIMETRICS::flInfo flags
//
#define FM_INFO_TECH_TRUETYPE               0x00000001
#define FM_INFO_TECH_BITMAP                 0x00000002
#define FM_INFO_TECH_STROKE                 0x00000004
#define FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   0x00000008
#define FM_INFO_ARB_XFORMS                  0x00000010
#define FM_INFO_1BPP                        0x00000020
#define FM_INFO_4BPP                        0x00000040
#define FM_INFO_8BPP                        0x00000080
#define FM_INFO_16BPP                       0x00000100
#define FM_INFO_24BPP                       0x00000200
#define FM_INFO_32BPP                       0x00000400
#define FM_INFO_INTEGER_WIDTH               0x00000800
#define FM_INFO_CONSTANT_WIDTH              0x00001000
#define FM_INFO_NOT_CONTIGUOUS              0x00002000
#define FM_INFO_PID_EMBEDDED                0x00004000
#define FM_INFO_RETURNS_OUTLINES            0x00008000
#define FM_INFO_RETURNS_STROKES             0x00010000
#define FM_INFO_RETURNS_BITMAPS             0x00020000
#define FM_INFO_UNICODE_COMPLIANT           0x00040000
#define FM_INFO_RIGHT_HANDED                0x00080000
#define FM_INFO_INTEGRAL_SCALING            0x00100000
#define FM_INFO_90DEGREE_ROTATIONS          0x00200000
#define FM_INFO_OPTICALLY_FIXED_PITCH       0x00400000
#define FM_INFO_DO_NOT_ENUMERATE            0x00800000
#define FM_INFO_ISOTROPIC_SCALING_ONLY      0x01000000
#define FM_INFO_ANISOTROPIC_SCALING_ONLY    0x02000000
#define FM_INFO_TID_EMBEDDED                0x04000000
#define FM_INFO_FAMILY_EQUIV                0x08000000
#define FM_INFO_DBCS_FIXED_PITCH            0x10000000
#define FM_INFO_NONNEGATIVE_AC              0x20000000
#define FM_INFO_IGNORE_TC_RA_ABLE           0x40000000
#define FM_INFO_TECH_TYPE1                  0x80000000

// max number of charsets supported in a tt font, 16 according to win95 guys

#define MAXCHARSETS 16

//
// IFIMETRICS::ulPanoseCulture
//
#define  FM_PANOSE_CULTURE_LATIN     0x0


//
// IFMETRICS::fsSelection flags
//
#define  FM_SEL_ITALIC          0x0001
#define  FM_SEL_UNDERSCORE      0x0002
#define  FM_SEL_NEGATIVE        0x0004
#define  FM_SEL_OUTLINED        0x0008
#define  FM_SEL_STRIKEOUT       0x0010
#define  FM_SEL_BOLD            0x0020
#define  FM_SEL_REGULAR         0x0040

//
// The FONTDIFF structure contains all of the fields that could
// possibly change under simulation
//
typedef struct _FONTDIFF {
    BYTE   jReserved1;      // 0x0
    BYTE   jReserved2;      // 0x1
    BYTE   jReserved3;      // 0x2
    BYTE   bWeight;         // 0x3  Panose Weight
    USHORT usWinWeight;     // 0x4
    FSHORT fsSelection;     // 0x6
    FWORD  fwdAveCharWidth; // 0x8
    FWORD  fwdMaxCharInc;   // 0xA
    POINTL ptlCaret;        // 0xC
} FONTDIFF;

typedef struct _FONTSIM {
    PTRDIFF  dpBold;       // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpItalic;     // offset from beginning of FONTSIM to FONTDIFF
    PTRDIFF  dpBoldItalic; // offset from beginning of FONTSIM to FONTDIFF
} FONTSIM;


typedef struct _IFIMETRICS {
    ULONG    cjThis;           // includes attached information
    ULONG    cjIfiExtra;       // sizeof IFIEXTRA if any, formerly ulVersion
    PTRDIFF  dpwszFamilyName;
    PTRDIFF  dpwszStyleName;
    PTRDIFF  dpwszFaceName;
    PTRDIFF  dpwszUniqueName;
    PTRDIFF  dpFontSim;
    LONG     lEmbedId;
    LONG     lItalicAngle;
    LONG     lCharBias;

// dpCharSet field replaced alReserved[0].
// If the 3.51 pcl minidrivers are still to work on NT 4.0 this field must not
// move because they will have 0 at this position.

    PTRDIFF  dpCharSets;
    BYTE     jWinCharSet;           // as in LOGFONT::lfCharSet
    BYTE     jWinPitchAndFamily;    // as in LOGFONT::lfPitchAndFamily
    USHORT   usWinWeight;           // as in LOGFONT::lfWeight
    ULONG    flInfo;                // see above
    USHORT   fsSelection;           // see above
    USHORT   fsType;                // see above
    FWORD    fwdUnitsPerEm;         // em height
    FWORD    fwdLowestPPEm;         // readable limit
    FWORD    fwdWinAscender;
    FWORD    fwdWinDescender;
    FWORD    fwdMacAscender;
    FWORD    fwdMacDescender;
    FWORD    fwdMacLineGap;
    FWORD    fwdTypoAscender;
    FWORD    fwdTypoDescender;
    FWORD    fwdTypoLineGap;
    FWORD    fwdAveCharWidth;
    FWORD    fwdMaxCharInc;
    FWORD    fwdCapHeight;
    FWORD    fwdXHeight;
    FWORD    fwdSubscriptXSize;
    FWORD    fwdSubscriptYSize;
    FWORD    fwdSubscriptXOffset;
    FWORD    fwdSubscriptYOffset;
    FWORD    fwdSuperscriptXSize;
    FWORD    fwdSuperscriptYSize;
    FWORD    fwdSuperscriptXOffset;
    FWORD    fwdSuperscriptYOffset;
    FWORD    fwdUnderscoreSize;
    FWORD    fwdUnderscorePosition;
    FWORD    fwdStrikeoutSize;
    FWORD    fwdStrikeoutPosition;
    BYTE     chFirstChar;           // for win 3.1 compatibility
    BYTE     chLastChar;            // for win 3.1 compatibility
    BYTE     chDefaultChar;         // for win 3.1 compatibility
    BYTE     chBreakChar;           // for win 3.1 compatibility
    WCHAR    wcFirstChar;           // lowest supported code in Unicode set
    WCHAR    wcLastChar;            // highest supported code in Unicode set
    WCHAR    wcDefaultChar;
    WCHAR    wcBreakChar;
    POINTL   ptlBaseline;           //
    POINTL   ptlAspect;             // designed aspect ratio (bitmaps)
    POINTL   ptlCaret;              // points along caret
    RECTL    rclFontBox;            // bounding box for all glyphs (font space)
    BYTE     achVendId[4];          // as per TrueType
    ULONG    cKerningPairs;
    ULONG    ulPanoseCulture;
    PANOSE   panose;
} IFIMETRICS, *PIFIMETRICS;


// rather than adding the fields of IFIEXTRA  to IFIMETRICS itself
// we add them as a separate structure. This structure, if present at all,
// lies below IFIMETRICS in memory.
// If IFIEXTRA is present at all, ifi.cjIfiExtra (formerly ulVersion)
// will contain size of IFIEXTRA including any reserved fields.
// That way ulVersion = 0 (NT 3.51 or less) printer minidrivers
// will work with NT 4.0.

typedef struct _IFIEXTRA
{
    ULONG    ulIdentifier;   // used for Type 1 fonts only
    PTRDIFF  dpFontSig;      // nontrivial for tt only, at least for now.
    ULONG    cig;            // maxp->numGlyphs, # of distinct glyph indicies
    ULONG    aulReserved[1]; // in case we need even more stuff in the future
} IFIEXTRA, *PIFIEXTRA;


/**************************************************************************\
 *
\**************************************************************************/

/* OpenGL DDI ExtEscape escape numbers (4352 - 4607) */

#define OPENGL_CMD      4352        /* for OpenGL ExtEscape */
#define OPENGL_GETINFO  4353        /* for OpenGL ExtEscape */
#define WNDOBJ_SETUP    4354        /* for live video ExtEscape */

#define DDI_DRIVER_VERSION      0x00020000
#define DDI_DRIVER_VERSION_SP3  0x00020003
#define DDI_DRIVER_VERSION_NT5  0x00030000

#define GDI_DRIVER_VERSION 0x4000   /* for NT version 4.0.00 */

typedef int (*PFN)();

typedef struct  _DRVFN  /* drvfn */
{
    ULONG   iFunc;
    PFN     pfn;
} DRVFN, *PDRVFN;


/* Required functions           */

#define INDEX_DrvEnablePDEV                      0L
#define INDEX_DrvCompletePDEV                    1L
#define INDEX_DrvDisablePDEV                     2L
#define INDEX_DrvEnableSurface                   3L
#define INDEX_DrvDisableSurface                  4L

/* Other functions              */

#define INDEX_DrvAssertMode                      5L
#define INDEX_DrvOffset                          6L     // Obsolete
#define INDEX_DrvResetPDEV                       7L
#define INDEX_DrvDisableDriver                   8L
#define INDEX_DrvCreateDeviceBitmap             10L
#define INDEX_DrvDeleteDeviceBitmap             11L
#define INDEX_DrvRealizeBrush                   12L
#define INDEX_DrvDitherColor                    13L
#define INDEX_DrvStrokePath                     14L
#define INDEX_DrvFillPath                       15L
#define INDEX_DrvStrokeAndFillPath              16L
#define INDEX_DrvPaint                          17L
#define INDEX_DrvBitBlt                         18L
#define INDEX_DrvCopyBits                       19L
#define INDEX_DrvStretchBlt                     20L
#define INDEX_DrvSetPalette                     22L
#define INDEX_DrvTextOut                        23L
#define INDEX_DrvEscape                         24L
#define INDEX_DrvDrawEscape                     25L
#define INDEX_DrvQueryFont                      26L
#define INDEX_DrvQueryFontTree                  27L
#define INDEX_DrvQueryFontData                  28L
#define INDEX_DrvSetPointerShape                29L
#define INDEX_DrvMovePointer                    30L
#define INDEX_DrvLineTo                         31L
#define INDEX_DrvSendPage                       32L
#define INDEX_DrvStartPage                      33L
#define INDEX_DrvEndDoc                         34L
#define INDEX_DrvStartDoc                       35L
#define INDEX_DrvGetGlyphMode                   37L
#define INDEX_DrvSynchronize                    38L
#define INDEX_DrvSaveScreenBits                 40L
#define INDEX_DrvGetModes                       41L
#define INDEX_DrvFree                           42L
#define INDEX_DrvDestroyFont                    43L
#define INDEX_DrvQueryFontCaps                  44L
#define INDEX_DrvLoadFontFile                   45L
#define INDEX_DrvUnloadFontFile                 46L
#define INDEX_DrvFontManagement                 47L
#define INDEX_DrvQueryTrueTypeTable             48L
#define INDEX_DrvQueryTrueTypeOutline           49L
#define INDEX_DrvGetTrueTypeFile                50L
#define INDEX_DrvQueryFontFile                  51L
#define INDEX_DrvMovePanning                    52L
#define INDEX_DrvQueryAdvanceWidths             53L
#define INDEX_DrvSetPixelFormat                 54L
#define INDEX_DrvDescribePixelFormat            55L
#define INDEX_DrvSwapBuffers                    56L
#define INDEX_DrvStartBanding                   57L
#define INDEX_DrvNextBand                       58L
#define INDEX_DrvGetDirectDrawInfo              59L
#define INDEX_DrvEnableDirectDraw               60L
#define INDEX_DrvDisableDirectDraw              61L
#define INDEX_DrvQuerySpoolType                 62L

//
// NEW FOR NT5
//
#define INDEX_DrvIcmCreateColorTransform        64L
#define INDEX_DrvIcmDeleteColorTransform        65L
#define INDEX_DrvIcmCheckBitmapBits             66L
#define INDEX_DrvIcmSetDeviceGammaRamp          67L
#define INDEX_DrvGradientFill                   68L
#define INDEX_DrvStretchBltROP                  69L
#define INDEX_DrvPlgBlt                         70L
#define INDEX_DrvAlphaBlend                     71L
#define INDEX_DrvSynthesizeFont                 72L
#define INDEX_DrvGetSynthesizedFontFiles        73L
#define INDEX_DrvTransparentBlt                 74L
#define INDEX_DrvQueryPerBandInfo               75L
#define INDEX_DrvQueryDeviceSupport             76L
#define INDEX_DrvConnect                        77L
#define INDEX_DrvDisconnect                     78L
#define INDEX_DrvReconnect                      79L
#define INDEX_DrvShadowConnect                  80L
#define INDEX_DrvShadowDisconnect               81L
#define INDEX_DrvInvalidateRect                 82L
#define INDEX_DrvSetPointerPos                  83L
#define INDEX_DrvDisplayIOCtl                   84L
#define INDEX_DrvDeriveSurface                  85L
#define INDEX_DrvQueryGlyphAttrs                86L

/* The total number of dispatched functions */

#define INDEX_LAST                              87L


typedef struct  tagDRVENABLEDATA
{
    ULONG   iDriverVersion;
    ULONG   c;
    DRVFN  *pdrvfn;
} DRVENABLEDATA, *PDRVENABLEDATA;

typedef struct  tagDEVINFO
{
    FLONG       flGraphicsCaps;
    LOGFONTW     lfDefaultFont;
    LOGFONTW     lfAnsiVarFont;
    LOGFONTW     lfAnsiFixFont;
    ULONG       cFonts;
    ULONG       iDitherFormat;
    USHORT      cxDither;
    USHORT      cyDither;
    HPALETTE    hpalDefault;
} DEVINFO, *PDEVINFO;

#define GCAPS_BEZIERS           0x00000001
#define GCAPS_GEOMETRICWIDE     0x00000002
#define GCAPS_ALTERNATEFILL     0x00000004
#define GCAPS_WINDINGFILL       0x00000008
#define GCAPS_HALFTONE          0x00000010
#define GCAPS_COLOR_DITHER      0x00000020
#define GCAPS_HORIZSTRIKE       0x00000040
#define GCAPS_VERTSTRIKE        0x00000080
#define GCAPS_OPAQUERECT        0x00000100
#define GCAPS_VECTORFONT        0x00000200
#define GCAPS_MONO_DITHER       0x00000400
#define GCAPS_ASYNCCHANGE       0x00000800
#define GCAPS_ASYNCMOVE         0x00001000
#define GCAPS_DONTJOURNAL       0x00002000
#define GCAPS_DIRECTDRAW        0x00004000
#define GCAPS_ARBRUSHOPAQUE     0x00008000
#define GCAPS_PANNING           0x00010000
#define GCAPS_HIGHRESTEXT       0x00040000
#define GCAPS_PALMANAGED        0x00080000
#define GCAPS_DITHERONREALIZE   0x00200000
#define GCAPS_NO64BITMEMACCESS  0x00400000
#define GCAPS_FORCEDITHER       0x00800000
#define GCAPS_GRAY16            0x01000000
#define GCAPS_LAYERED           0x08000000
#define GCAPS_ARBRUSHTEXT       0x10000000

typedef struct  _LINEATTRS
{
    FLONG       fl;
    ULONG       iJoin;
    ULONG       iEndCap;
    FLOAT_LONG  elWidth;
    FLOAT       eMiterLimit;
    ULONG       cstyle;
    PFLOAT_LONG pstyle;
    FLOAT_LONG  elStyleState;
} LINEATTRS, *PLINEATTRS;

#define LA_GEOMETRIC        0x00000001
#define LA_ALTERNATE        0x00000002
#define LA_STARTGAP         0x00000004
#define LA_STYLED           0x00000008

#define JOIN_ROUND          0L
#define JOIN_BEVEL          1L
#define JOIN_MITER          2L

#define ENDCAP_ROUND        0L
#define ENDCAP_SQUARE       1L
#define ENDCAP_BUTT         2L

typedef LONG  LDECI4;

typedef struct _CIECHROMA
{
    LDECI4   x;
    LDECI4   y;
    LDECI4   Y;
}CIECHROMA;

typedef struct _COLORINFO
{
    CIECHROMA  Red;
    CIECHROMA  Green;
    CIECHROMA  Blue;
    CIECHROMA  Cyan;
    CIECHROMA  Magenta;
    CIECHROMA  Yellow;
    CIECHROMA  AlignmentWhite;

    LDECI4  RedGamma;
    LDECI4  GreenGamma;
    LDECI4  BlueGamma;

    LDECI4  MagentaInCyanDye;
    LDECI4  YellowInCyanDye;
    LDECI4  CyanInMagentaDye;
    LDECI4  YellowInMagentaDye;
    LDECI4  CyanInYellowDye;
    LDECI4  MagentaInYellowDye;
}COLORINFO, *PCOLORINFO;

// Allowed values for GDIINFO.ulPrimaryOrder.

#define PRIMARY_ORDER_ABC       0
#define PRIMARY_ORDER_ACB       1
#define PRIMARY_ORDER_BAC       2
#define PRIMARY_ORDER_BCA       3
#define PRIMARY_ORDER_CBA       4
#define PRIMARY_ORDER_CAB       5

// Allowed values for GDIINFO.ulHTPatternSize.

#define HT_PATSIZE_2x2          0
#define HT_PATSIZE_2x2_M        1
#define HT_PATSIZE_4x4          2
#define HT_PATSIZE_4x4_M        3
#define HT_PATSIZE_6x6          4
#define HT_PATSIZE_6x6_M        5
#define HT_PATSIZE_8x8          6
#define HT_PATSIZE_8x8_M        7
#define HT_PATSIZE_10x10        8
#define HT_PATSIZE_10x10_M      9
#define HT_PATSIZE_12x12        10
#define HT_PATSIZE_12x12_M      11
#define HT_PATSIZE_14x14        12
#define HT_PATSIZE_14x14_M      13
#define HT_PATSIZE_16x16        14
#define HT_PATSIZE_16x16_M      15
#define HT_PATSIZE_MAX_INDEX    HT_PATSIZE_16x16_M
#define HT_PATSIZE_DEFAULT      HT_PATSIZE_4x4_M

// Allowed values for GDIINFO.ulHTOutputFormat.

#define HT_FORMAT_1BPP          0
#define HT_FORMAT_4BPP          2
#define HT_FORMAT_4BPP_IRGB     3
#define HT_FORMAT_8BPP          4
#define HT_FORMAT_16BPP         5
#define HT_FORMAT_24BPP         6
#define HT_FORMAT_32BPP         7

// Allowed values for GDIINFO.flHTFlags.

#define HT_FLAG_SQUARE_DEVICE_PEL    0x00000001
#define HT_FLAG_HAS_BLACK_DYE        0x00000002
#define HT_FLAG_ADDITIVE_PRIMS       0x00000004
#define HT_FLAG_OUTPUT_CMY           0x00000100

typedef struct _GDIINFO
{
    ULONG ulVersion;
    ULONG ulTechnology;
    ULONG ulHorzSize;
    ULONG ulVertSize;
    ULONG ulHorzRes;
    ULONG ulVertRes;
    ULONG cBitsPixel;
    ULONG cPlanes;
    ULONG ulNumColors;
    ULONG flRaster;
    ULONG ulLogPixelsX;
    ULONG ulLogPixelsY;
    ULONG flTextCaps;

    ULONG ulDACRed;
    ULONG ulDACGreen;
    ULONG ulDACBlue;

    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulAspectXY;

    LONG  xStyleStep;
    LONG  yStyleStep;
    LONG  denStyleStep;

    POINTL ptlPhysOffset;
    SIZEL  szlPhysSize;

    ULONG ulNumPalReg;

// These fields are for halftone initialization.

    COLORINFO ciDevice;
    ULONG     ulDevicePelsDPI;
    ULONG     ulPrimaryOrder;
    ULONG     ulHTPatternSize;
    ULONG     ulHTOutputFormat;
    ULONG     flHTFlags;

    ULONG ulVRefresh;
    ULONG ulBltAlignment;

    ULONG ulPanningHorzRes;
    ULONG ulPanningVertRes;

} GDIINFO, *PGDIINFO;

/*
 * User objects
 */

typedef struct _BRUSHOBJ
{
    ULONG   iSolidColor;
    PVOID   pvRbrush;
} BRUSHOBJ;

typedef struct _CLIPOBJ
{
    ULONG   iUniq;
    RECTL   rclBounds;
    BYTE    iDComplexity;
    BYTE    iFComplexity;
    BYTE    iMode;
    BYTE    fjOptions;
} CLIPOBJ;

typedef struct _DRIVEROBJ DRIVEROBJ;

typedef BOOL (CALLBACK * FREEOBJPROC)(DRIVEROBJ *pDriverObj);

typedef struct _DRIVEROBJ
{
    PVOID       pvObj;
    FREEOBJPROC pFreeProc;
    HDEV        hdev;
    DHPDEV      dhpdev;
} DRIVEROBJ;

typedef struct _FONTOBJ
{
    ULONG   iUniq;
    ULONG   iFace;
    ULONG   cxMax;
    FLONG   flFontType;
    ULONG   iTTUniq;
    ULONG   iFile;
    SIZE    sizLogResPpi;
    ULONG   ulStyleSize;
    PVOID   pvConsumer;
    PVOID   pvProducer;
} FONTOBJ;

typedef struct _BLENDOBJ
{
    BLENDFUNCTION BlendFunction;
}BLENDOBJ,*PBLENDOBJ;


typedef BYTE GAMMA_TABLES[2][256];

//
// FONTOBJ::flFontType
//
#define FO_TYPE_RASTER   RASTER_FONTTYPE     /* 0x1 */
#define FO_TYPE_DEVICE   DEVICE_FONTTYPE     /* 0x2 */
#define FO_TYPE_TRUETYPE TRUETYPE_FONTTYPE   /* 0x4 */
#define FO_SIM_BOLD      0x00002000
#define FO_SIM_ITALIC    0x00004000
#define FO_EM_HEIGHT     0x00008000
#define FO_GRAY16        0x00010000          /* [1] */
#define FO_NOGRAY16      0x00020000          /* [1] */
#define FO_NOHINTS       0x00040000          /* [3] */
#define FO_NO_CHOICE     0x00080000          /* [3] */

/**************************************************************************\
*
*   [1]
*
*   If the FO_GRAY16 flag is set then the bitmaps of the font
*   are 4-bit per pixel blending (alpha) values. A value of zero
*   means that the the resulting pixel should be equal to the
*   background color. If the value of the alpha value is k != 0
*   then the resulting pixel must be:
*
*       c0 = background color
*       c1 = foreground color
*       b  = blending value = (k+1)/16  // {k = 1,2,..,15}
*       b  = 0 (k = 0)
*       d0 = gamma[c0], d1 = gamma[c1]  // luminance components
*       d = (1 - b)*d0 + b*d1           // blended luminance
*       c = lambda[d]                   // blended device voltage
*
*   where gamma[] takes a color component from application space
*   to CIE space and labmda[] takes a color from CIE space to
*   device color space
*
*   GDI will set this bit if it request a font be gray scaled
*   to 16 values then GDI will set FO_GRAY16 upon entry to
*   DrvQueryFontData().  If the font driver cannot (or will
*   not) grayscale a particular realization of a font then the
*   font provider will zero out FO_GRAY16  and set FO_NOGRAY16
*   to inform GDI that
*   the gray scaling request cannot (or should not) be
*   satisfied.
*
*   [2]
*
*   The FO_NOHINTS indicates that hints were not used in the formation
*   of the glyph images. GDI will set this bit to request that hinting
*   be supressed. The font provider will set this bit accroding to the
*   rendering scheme that it used in generating the glyph image.
*
*   [3]
*
*   The FO_NO_CHOICE flag indicates that the flags FO_GRAY16 and
*   FO_NOHINTS must be obeyed if at all possible.
*
\**************************************************************************/

typedef struct _PALOBJ
{
    ULONG   ulReserved;
} PALOBJ;

typedef struct _PATHOBJ
{
    FLONG   fl;
    ULONG   cCurves;
} PATHOBJ;

typedef struct _SURFOBJ
{
    DHSURF  dhsurf;
    HSURF   hsurf;
    DHPDEV  dhpdev;
    HDEV    hdev;
    SIZEL   sizlBitmap;
    ULONG   cjBits;
    PVOID   pvBits;
    PVOID   pvScan0;
    LONG    lDelta;
    ULONG   iUniq;
    ULONG   iBitmapFormat;
    USHORT  iType;
    USHORT  fjBitmap;
} SURFOBJ;

typedef struct _WNDOBJ
{
    CLIPOBJ  coClient;
    PVOID    pvConsumer;
    RECTL    rclClient;
    SURFOBJ *psoOwner;
} WNDOBJ, *PWNDOBJ;

typedef struct _XFORMOBJ
{
    ULONG ulReserved;
} XFORMOBJ;

typedef struct _XLATEOBJ
{
    ULONG   iUniq;
    FLONG   flXlate;
    USHORT  iSrcType;
    USHORT  iDstType;
    ULONG   cEntries;
    ULONG  *pulXlate;
} XLATEOBJ;

/*
 * BRUSHOBJ callbacks
 */

PVOID APIENTRY BRUSHOBJ_pvAllocRbrush(
BRUSHOBJ *pbo,
ULONG     cj);

PVOID APIENTRY BRUSHOBJ_pvGetRbrush(BRUSHOBJ *pbo);

ULONG APIENTRY BRUSHOBJ_ulGetBrushColor(BRUSHOBJ *pbo);

/*
 * CLIPOBJ callbacks
 */

#define DC_TRIVIAL      0
#define DC_RECT         1
#define DC_COMPLEX      3

#define FC_RECT         1
#define FC_RECT4        2
#define FC_COMPLEX      3

#define TC_RECTANGLES   0
#define TC_PATHOBJ      2

#define OC_BANK_CLIP    1

#define CT_RECTANGLES   0L

#define CD_RIGHTDOWN    0L
#define CD_LEFTDOWN     1L
#define CD_RIGHTUP      2L
#define CD_LEFTUP       3L
#define CD_ANY          4L

#define CD_LEFTWARDS    1L
#define CD_UPWARDS      2L

typedef struct _ENUMRECTS
{
    ULONG       c;
    RECTL       arcl[1];
} ENUMRECTS;

ULONG APIENTRY CLIPOBJ_cEnumStart(
CLIPOBJ *pco,
BOOL     bAll,
ULONG    iType,
ULONG    iDirection,
ULONG    cLimit);

BOOL APIENTRY CLIPOBJ_bEnum(
CLIPOBJ *pco,
ULONG    cj,
ULONG   *pul);

PATHOBJ * APIENTRY CLIPOBJ_ppoGetPath(CLIPOBJ* pco);

/*
 *   FONTOBJ callbacks
 */

typedef struct _GLYPHBITS
{
    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    BYTE        aj[1];
} GLYPHBITS;

#define FO_HGLYPHS          0L
#define FO_GLYPHBITS        1L
#define FO_PATHOBJ          2L

#define FD_NEGATIVE_FONT    1L

#define FO_DEVICE_FONT      1L
#define FO_OUTLINE_CAPABLE  2L

typedef union _GLYPHDEF
{
    GLYPHBITS  *pgb;
    PATHOBJ    *ppo;
} GLYPHDEF;

typedef struct _GLYPHPOS    /* gp */
{
    HGLYPH      hg;
    GLYPHDEF   *pgdf;
    POINTL      ptl;
} GLYPHPOS,*PGLYPHPOS;


// individual glyph data

// r is a unit vector along the baseline in device coordinates.
// s is a unit vector in the ascent direction in device coordinates.
// A, B, and C, are simple tranforms of the notional space versions into
// (28.4) device coordinates.  The dot products of those vectors with r
// are recorded here.  Note that the high words of ptqD are also 28.4
// device coordinates.  The low words provide extra accuracy.

// THE STRUCTURE DIFFERS IN ORDERING FROM NT 3.51 VERSION OF THE STRUCTURE.
// ptqD has been moved to the bottom.
// This requires only recompile of all the drivers.

typedef struct _GLYPHDATA {
        GLYPHDEF gdf;               // pointer to GLYPHBITS or to PATHOBJ
        HGLYPH   hg;                // glyhp handle
        FIX      fxD;               // Character increment amount: D*r.
        FIX      fxA;               // Prebearing amount: A*r.
        FIX      fxAB;              // Advancing edge of character: (A+B)*r.
        FIX      fxInkTop;          // Baseline to inkbox top along s.
        FIX      fxInkBottom;       // Baseline to inkbox bottom along s.
        RECTL    rclInk;            // Ink box with sides parallel to x,y axes
        POINTQF  ptqD;              // Character increment vector: D=A+B+C.
} GLYPHDATA;


// flAccel flags for STROBJ

// SO_FLAG_DEFAULT_PLACEMENT // defult inc vectors used to position chars
// SO_HORIZONTAL             // "left to right" or "right to left"
// SO_VERTICAL               // "top to bottom" or "bottom to top"
// SO_REVERSED               // set if horiz & "right to left" or if vert &  "bottom to top"
// SO_ZERO_BEARINGS          // all glyphs have zero a and c spaces
// SO_CHAR_INC_EQUAL_BM_BASE // base == cx for horiz, == cy for vert.
// SO_MAXEXT_EQUAL_BM_SIDE   // side == cy for horiz, == cx for vert.

// do not substitute device font for tt font even if device font sub table
// tells the driver this should be done

// SO_DO_NOT_SUBSTITUTE_DEVICE_FONT

#define SO_FLAG_DEFAULT_PLACEMENT        0x00000001
#define SO_HORIZONTAL                    0x00000002
#define SO_VERTICAL                      0x00000004
#define SO_REVERSED                      0x00000008
#define SO_ZERO_BEARINGS                 0x00000010
#define SO_CHAR_INC_EQUAL_BM_BASE        0x00000020
#define SO_MAXEXT_EQUAL_BM_SIDE          0x00000040
#define SO_DO_NOT_SUBSTITUTE_DEVICE_FONT 0x00000080
#define SO_GLYPHINDEX_TEXTOUT            0x00000100
#define SO_ESC_NOT_ORIENT                0x00000200

typedef struct _STROBJ
{
    ULONG     cGlyphs;     // # of glyphs to render
    FLONG     flAccel;     // accel flags
    ULONG     ulCharInc;   // non-zero only if fixed pitch font, equal to advanced width.
    RECTL     rclBkGround; // bk ground  rect of the string in device coords
    GLYPHPOS *pgp;         // If non-NULL then has all glyphs.
    LPWSTR    pwszOrg;     // pointer to original unicode string.
} STROBJ;

typedef struct _FONTINFO /* fi */
{
    ULONG   cjThis;
    FLONG   flCaps;
    ULONG   cGlyphsSupported;
    ULONG   cjMaxGlyph1;
    ULONG   cjMaxGlyph4;
    ULONG   cjMaxGlyph8;
    ULONG   cjMaxGlyph32;
} FONTINFO, *PFONTINFO;

ULONG APIENTRY FONTOBJ_cGetAllGlyphHandles(
FONTOBJ *pfo,
HGLYPH  *phg);

VOID APIENTRY FONTOBJ_vGetInfo(
FONTOBJ  *pfo,
ULONG     cjSize,
FONTINFO *pfi);

ULONG APIENTRY FONTOBJ_cGetGlyphs(
FONTOBJ *pfo,
ULONG    iMode,
ULONG    cGlyph,
HGLYPH  *phg,
PVOID   *ppvGlyph);

GAMMA_TABLES* APIENTRY FONTOBJ_pGetGammaTables(FONTOBJ *pfo);

XFORMOBJ * APIENTRY FONTOBJ_pxoGetXform(FONTOBJ *pfo);
IFIMETRICS * APIENTRY FONTOBJ_pifi(FONTOBJ *pfo);

PVOID  FONTOBJ_pvTrueTypeFontFile(
FONTOBJ *pfo,
ULONG   *pcjFile);

// possible values that iMode can take:

/*
 * PALOBJ callbacks
 */

#define PAL_INDEXED       0x00000001
#define PAL_BITFIELDS     0x00000002
#define PAL_RGB           0x00000004
#define PAL_BGR           0x00000008

ULONG APIENTRY PALOBJ_cGetColors(
PALOBJ *ppalo,
ULONG   iStart,
ULONG   cColors,
ULONG  *pulColors);

/*
 * PATHOBJ callbacks
 */

#define PO_BEZIERS          0x00000001
#define PO_ELLIPSE          0x00000002
#define PO_ALL_INTEGERS     0x00000004
#define PO_ENUM_AS_INTEGERS 0x00000008

#define PD_BEGINSUBPATH   0x00000001
#define PD_ENDSUBPATH     0x00000002
#define PD_RESETSTYLE     0x00000004
#define PD_CLOSEFIGURE    0x00000008
#define PD_BEZIERS        0x00000010
#define PD_ALL           (PD_BEGINSUBPATH | \
                          PD_ENDSUBPATH   | \
                          PD_RESETSTYLE   | \
                          PD_CLOSEFIGURE  | \
                          PD_BEZIERS)

typedef struct  _PATHDATA
{
    FLONG    flags;
    ULONG    count;
    POINTFIX *pptfx;
} PATHDATA, *PPATHDATA;

typedef struct  _RUN
{
    LONG    iStart;
    LONG    iStop;
} RUN, *PRUN;

typedef struct  _CLIPLINE
{
    POINTFIX ptfxA;
    POINTFIX ptfxB;
    LONG    lStyleState;
    ULONG   c;
    RUN     arun[1];
} CLIPLINE, *PCLIPLINE;

VOID APIENTRY PATHOBJ_vEnumStart(PATHOBJ *ppo);

BOOL APIENTRY PATHOBJ_bEnum(
PATHOBJ  *ppo,
PATHDATA *ppd);

VOID APIENTRY PATHOBJ_vEnumStartClipLines(
PATHOBJ   *ppo,
CLIPOBJ   *pco,
SURFOBJ   *pso,
LINEATTRS *pla);

BOOL APIENTRY PATHOBJ_bEnumClipLines(
PATHOBJ  *ppo,
ULONG     cb,
CLIPLINE *pcl);

BOOL APIENTRY PATHOBJ_bMoveTo(
PATHOBJ    *ppo,
POINTFIX    ptfx);

BOOL APIENTRY PATHOBJ_bPolyLineTo(
PATHOBJ   *ppo,
POINTFIX  *pptfx,
ULONG      cptfx);

BOOL APIENTRY PATHOBJ_bPolyBezierTo(
PATHOBJ   *ppo,
POINTFIX  *pptfx,
ULONG      cptfx);

BOOL APIENTRY PATHOBJ_bCloseFigure(PATHOBJ   *ppo);

VOID APIENTRY PATHOBJ_vGetBounds(
PATHOBJ *ppo,
PRECTFX prectfx);

/*
 * STROBJ callbacks
 */

VOID APIENTRY STROBJ_vEnumStart(
STROBJ *pstro);

BOOL APIENTRY STROBJ_bEnum(
STROBJ    *pstro,
ULONG     *pc,
PGLYPHPOS *ppgpos);

DWORD APIENTRY STROBJ_dwGetCodePage(
STROBJ  *pstro);

#define SGI_EXTRASPACE 0

/*
 * SURFOBJ callbacks
 */

#define STYPE_BITMAP    0L
#define STYPE_DEVICE    1L
#define STYPE_DEVBITMAP 3L

#define BMF_1BPP       1L
#define BMF_4BPP       2L
#define BMF_8BPP       3L
#define BMF_16BPP      4L
#define BMF_24BPP      5L
#define BMF_32BPP      6L
#define BMF_4RLE       7L
#define BMF_8RLE       8L

#define BMF_TOPDOWN    0x0001
#define BMF_NOZEROINIT 0x0002
#define BMF_DONTCACHE  0x0004
#define BMF_USERMEM    0x0008
#define BMF_KMSECTION  0x0010


/*
 * XFORMOBJ callbacks
 */

#define GX_IDENTITY     0L
#define GX_OFFSET       1L
#define GX_SCALE        2L
#define GX_GENERAL      3L

#define XF_LTOL         0L
#define XF_INV_LTOL     1L
#define XF_LTOFX        2L
#define XF_INV_FXTOL    3L

ULONG APIENTRY XFORMOBJ_iGetXform(
XFORMOBJ *pxo,
XFORM    *pxform);

BOOL APIENTRY XFORMOBJ_bApplyXform(
XFORMOBJ *pxo,
ULONG     iMode,
ULONG     cPoints,
PVOID     pvIn,
PVOID     pvOut);

/*
 * XLATEOBJ callbacks
 */

#define XO_TRIVIAL      0x00000001
#define XO_TABLE        0x00000002
#define XO_TO_MONO      0x00000004

#define XO_SRCPALETTE    1
#define XO_DESTPALETTE   2
#define XO_DESTDCPALETTE 3
#define XO_SRCBITFIELDS  4
#define XO_DESTBITFIELDS 5

ULONG APIENTRY XLATEOBJ_iXlate(XLATEOBJ *pxlo, ULONG iColor);
ULONG * APIENTRY XLATEOBJ_piVector(XLATEOBJ *pxlo);
ULONG APIENTRY XLATEOBJ_cGetPalette(
XLATEOBJ *pxlo,
ULONG     iPal,
ULONG     cPal,
ULONG    *pPal);

/*
 * Engine callbacks - error logging
 */

VOID APIENTRY EngSetLastError(ULONG);
ULONG APIENTRY EngGetLastError();

/*
 * Engine callbacks - Surfaces
 */

#define HOOK_BITBLT                     0x00000001
#define HOOK_STRETCHBLT                 0x00000002
#define HOOK_PLGBLT                     0x00000004
#define HOOK_TEXTOUT                    0x00000008
#define HOOK_PAINT                      0x00000010      // Obsolete
#define HOOK_STROKEPATH                 0x00000020
#define HOOK_FILLPATH                   0x00000040
#define HOOK_STROKEANDFILLPATH          0x00000080
#define HOOK_LINETO                     0x00000100
#define HOOK_COPYBITS                   0x00000400
#define HOOK_MOVEPANNING                0x00000800      // Obsolete
#define HOOK_SYNCHRONIZE                0x00001000
#define HOOK_SYNCHRONIZEACCESS          0x00004000      // Obsolete

//
// NEW FOR NT5
//
#define HOOK_STRETCHBLTROP              0x00002000
#define HOOK_TRANSPARENTBLT             0x00008000
#define HOOK_ALPHABLEND                 0x00010000
#define HOOK_GRADIENTFILL               0x00020000
#define HOOK_FLAGS                      0x0003b7ff


HBITMAP APIENTRY EngCreateBitmap(
SIZEL sizl,
LONG  lWidth,
ULONG iFormat,
FLONG fl,
PVOID pvBits);

HSURF APIENTRY EngCreateDeviceSurface(DHSURF dhsurf, SIZEL sizl, ULONG iFormatCompat);
HBITMAP APIENTRY EngCreateDeviceBitmap(DHSURF dhsurf, SIZEL sizl, ULONG iFormatCompat);
BOOL APIENTRY EngDeleteSurface(HSURF hsurf);
SURFOBJ * APIENTRY EngLockSurface(HSURF hsurf);
VOID APIENTRY EngUnlockSurface(SURFOBJ *pso);

BOOL APIENTRY EngEraseSurface(
SURFOBJ *pso,
RECTL   *prcl,
ULONG    iColor);

BOOL APIENTRY EngAssociateSurface(
HSURF hsurf,
HDEV  hdev,
FLONG flHooks);

BOOL APIENTRY EngMarkBandingSurface( HSURF hsurf );

BOOL APIENTRY EngCheckAbort(SURFOBJ *pso);

/*
 * Engine callbacks - Paths
 */

PATHOBJ * APIENTRY EngCreatePath();
VOID APIENTRY EngDeletePath(PATHOBJ *ppo);

/*
 * Engine callbacks - Palettes
 */

HPALETTE APIENTRY EngCreatePalette(
ULONG  iMode,
ULONG  cColors,
ULONG *pulColors,
FLONG  flRed,
FLONG  flGreen,
FLONG  flBlue);

ULONG APIENTRY EngQueryPalette(
HPALETTE    hpal,
ULONG      *piMode,
ULONG       cColors,
ULONG      *pulColors);

BOOL APIENTRY EngDeletePalette(HPALETTE hpal);

/*
 * Engine callbacks - Clipping
 */

CLIPOBJ * APIENTRY EngCreateClip();
VOID APIENTRY EngDeleteClip(CLIPOBJ *pco);

/*
 * Function prototypes
 */

// These are the only EXPORTED functions for ANY driver

BOOL APIENTRY DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA *pded);

/*
 * Driver functions
 */

DHPDEV APIENTRY DrvEnablePDEV(
DEVMODEW *pdm,
LPWSTR    pwszLogAddress,
ULONG     cPat,
HSURF    *phsurfPatterns,
ULONG     cjCaps,
ULONG    *pdevcaps,
ULONG     cjDevInfo,
DEVINFO  *pdi,
HDEV      hdev,
LPWSTR    pwszDeviceName,
HANDLE    hDriver);

#define HS_DDI_MAX 6

BOOL  APIENTRY DrvResetPDEV(DHPDEV dhpdevOld, DHPDEV dhpdevNew);

VOID  APIENTRY DrvCompletePDEV(DHPDEV dhpdev,HDEV hdev);

HSURF APIENTRY DrvEnableSurface(DHPDEV dhpdev);
VOID  APIENTRY DrvSynchronize(DHPDEV dhpdev,RECTL *prcl);
VOID  APIENTRY DrvDisableSurface(DHPDEV dhpdev);
VOID  APIENTRY DrvDisablePDEV(DHPDEV dhpdev);

BOOL APIENTRY DrvStartBanding(SURFOBJ *pso, POINTL *pptl);
BOOL APIENTRY DrvNextBand(SURFOBJ *pso, POINTL *pptl);

/* DrvSaveScreenBits - iMode definitions */

#define SS_SAVE    0
#define SS_RESTORE 1
#define SS_FREE    2

ULONG APIENTRY DrvSaveScreenBits(SURFOBJ *pso,ULONG iMode,ULONG ident,RECTL *prcl);

/*
 * Desktops
 */

BOOL  APIENTRY DrvAssertMode(
DHPDEV dhpdev,
BOOL   bEnable);

ULONG APIENTRY DrvGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW *pdm);

BOOL APIENTRY DrvPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode
    );


/*
 * Bitmaps
 */

HBITMAP APIENTRY DrvCreateDeviceBitmap (
DHPDEV dhpdev,
SIZEL  sizl,
ULONG  iFormat);

VOID  APIENTRY DrvDeleteDeviceBitmap(DHSURF dhsurf);

/*
 * Palettes
 */

BOOL APIENTRY DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ *ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors);

/*
 * Brushes
 */

#define DM_DEFAULT    0x00000001
#define DM_MONOCHROME 0x00000002

#define DCR_SOLID       0
#define DCR_DRIVER      1
#define DCR_HALFTONE    2

ULONG APIENTRY DrvDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG *pul);

BOOL APIENTRY DrvRealizeBrush(
BRUSHOBJ *pbo,
SURFOBJ  *psoTarget,
SURFOBJ  *psoPattern,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo,
ULONG    iHatch);

#define RB_DITHERCOLOR 0x80000000L


/*
 * Fonts
 */

PIFIMETRICS APIENTRY DrvQueryFont(
DHPDEV dhpdev,
ULONG  iFile,
ULONG  iFace,
ULONG  *pid);

// #define QFT_UNICODE     0L
#define QFT_LIGATURES   1L
#define QFT_KERNPAIRS   2L
#define QFT_GLYPHSET    3L

PVOID APIENTRY DrvQueryFontTree(
DHPDEV dhpdev,
ULONG  iFile,
ULONG  iFace,
ULONG  iMode,
ULONG  *pid);

#define QFD_GLYPHANDBITMAP    1L
#define QFD_GLYPHANDOUTLINE   2L
#define QFD_MAXEXTENTS        3L
#define QFD_TT_GLYPHANDBITMAP 4L
#define QFD_TT_GRAY1_BITMAP   5L
#define QFD_TT_GRAY2_BITMAP   6L
#define QFD_TT_GRAY4_BITMAP   8L
#define QFD_TT_GRAY8_BITMAP   9L

#define QFD_TT_MONO_BITMAP QFD_TT_GRAY1_BITMAP

LONG APIENTRY DrvQueryFontData(
DHPDEV      dhpdev,
FONTOBJ    *pfo,
ULONG       iMode,
HGLYPH      hg,
GLYPHDATA  *pgd,
PVOID       pv,
ULONG       cjSize);

VOID APIENTRY DrvFree(
PVOID   pv,
ULONG   id);

VOID APIENTRY DrvDestroyFont(
FONTOBJ *pfo);

// Capability flags for DrvQueryCaps.

#define QC_OUTLINES             0x00000001
#define QC_1BIT                 0x00000002
#define QC_4BIT                 0x00000004

//
// This is a mask of the capabilites of a font provider that can return more
// than just glyph metrics (i.e., bitmaps and/or outlines).  If a driver has
// one or more of these capabilities, then it is FONT DRIVER.
//
// Drivers should only set individual bits. GDI will check if any are turned on
// using this define.
//

#define QC_FONTDRIVERCAPS   ( QC_OUTLINES | QC_1BIT | QC_4BIT )



LONG APIENTRY DrvQueryFontCaps(
ULONG   culCaps,
ULONG  *pulCaps);

ULONG APIENTRY DrvLoadFontFile(
ULONG   cFiles,  // number of font files associated with this font
ULONG  *piFile,  // handles for individual files, cFiles of them
PVOID  *ppvView, // array of cFiles views
ULONG  *pcjView, // array of their sizes
ULONG   ulLangID);

BOOL APIENTRY DrvUnloadFontFile(
ULONG   iFile);

LONG APIENTRY DrvQueryTrueTypeTable(
ULONG   iFile,
ULONG   ulFont,
ULONG   ulTag,
PTRDIFF dpStart,
ULONG   cjBuf,
BYTE   *pjBuf);

BOOL APIENTRY DrvQueryAdvanceWidths(
DHPDEV   dhpdev,
FONTOBJ *pfo,
ULONG    iMode,
HGLYPH  *phg,
PVOID    pvWidths,
ULONG    cGlyphs);

// Values for iMode

#define QAW_GETWIDTHS       0
#define QAW_GETEASYWIDTHS   1

LONG APIENTRY DrvQueryTrueTypeOutline(
DHPDEV      dhpdev,
FONTOBJ    *pfo,
HGLYPH      hglyph,
BOOL        bMetricsOnly,
GLYPHDATA  *pgldt,
ULONG       cjBuf,
TTPOLYGONHEADER *ppoly);

PVOID APIENTRY DrvGetTrueTypeFile (
ULONG   iFile,
ULONG  *pcj);

// values for ulMode:

#define QFF_DESCRIPTION     1L
#define QFF_NUMFACES        2L

LONG APIENTRY DrvQueryFontFile(
ULONG   iFile,
ULONG   ulMode,
ULONG   cjBuf,
ULONG  *pulBuf);

/*
 * BitBlt
 */

BOOL APIENTRY DrvBitBlt(
SURFOBJ  *psoTrg,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclTrg,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4);

BOOL APIENTRY DrvStretchBlt(
SURFOBJ         *psoDest,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlHTOrg,
RECTL           *prclDest,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode);


BOOL APIENTRY DrvStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    DWORD            rop4
    );

BOOL APIENTRY DrvAlphaBlend(
    SURFOBJ       *psoDest,
    SURFOBJ       *psoSrc,
    CLIPOBJ       *pco,
    XLATEOBJ      *pxlo,
    RECTL         *prclDest,
    RECTL         *prclSrc,
    BLENDOBJ      *pBlendObj
    );

BOOL APIENTRY DrvGradientFill(
    SURFOBJ         *psoDest,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    TRIVERTEX       *pVertex,
    ULONG            nVertex,
    PVOID            pMesh,
    ULONG            nMesh,
    RECTL           *prclExtents,
    POINTL          *pptlDitherOrg,
    ULONG            ulMode
    );

BOOL APIENTRY DrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
);


BOOL APIENTRY DrvCopyBits(
SURFOBJ  *psoDest,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDest,
POINTL   *pptlSrc);

/*
 * Text Output
 */

BOOL APIENTRY DrvTextOut(
SURFOBJ  *pso,
STROBJ   *pstro,
FONTOBJ  *pfo,
CLIPOBJ  *pco,
RECTL    *prclExtra,
RECTL    *prclOpaque,
BRUSHOBJ *pboFore,
BRUSHOBJ *pboOpaque,
POINTL   *pptlOrg,
MIX       mix);

/*
 * Graphics Output
 */

BOOL APIENTRY DrvLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix);

BOOL APIENTRY DrvStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX        mix);

#define FP_ALTERNATEMODE    1L
#define FP_WINDINGMODE      2L

BOOL APIENTRY DrvFillPath(
SURFOBJ  *pso,
PATHOBJ  *ppo,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix,
FLONG     flOptions);

BOOL APIENTRY DrvStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *plineattrs,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mixFill,
FLONG      flOptions);

BOOL APIENTRY DrvPaint(
SURFOBJ  *pso,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix);

/*
 * Pointers
 */

#define SPS_ERROR               0
#define SPS_DECLINE             1
#define SPS_ACCEPT_NOEXCLUDE    2
#define SPS_ACCEPT_EXCLUDE      3

#define SPS_CHANGE        0x00000001L
#define SPS_ASYNCCHANGE   0x00000002L
#define SPS_ANIMATESTART  0x00000004L
#define SPS_ANIMATEUPDATE 0x00000008L

ULONG APIENTRY DrvSetPointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL    *prcl,
FLONG     fl);

VOID APIENTRY DrvMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl);

/*
 * Printing
 */

BOOL  APIENTRY DrvSendPage(SURFOBJ *pso);
BOOL  APIENTRY DrvStartPage(SURFOBJ *pso);

ULONG APIENTRY DrvEscape(
SURFOBJ *pso,
ULONG    iEsc,
ULONG    cjIn,
PVOID    pvIn,
ULONG    cjOut,
PVOID    pvOut);

BOOL  APIENTRY DrvStartDoc(
SURFOBJ *pso,
LPWSTR   pwszDocName,
DWORD    dwJobId);

#define ED_ABORTDOC    1

BOOL  APIENTRY DrvEndDoc(SURFOBJ *pso, FLONG fl);

BOOL  APIENTRY DrvQuerySpoolType(DHPDEV, LPWSTR);

ULONG APIENTRY DrvDrawEscape(
SURFOBJ *pso,
ULONG    iEsc,
CLIPOBJ *pco,
RECTL   *prcl,
ULONG    cjIn,
PVOID    pvIn);

ULONG APIENTRY DrvGetGlyphMode(DHPDEV, FONTOBJ *);

ULONG APIENTRY DrvFontManagement(
SURFOBJ *pso,
FONTOBJ *pfo,
ULONG    iMode,
ULONG    cjIn,
PVOID    pvIn,
ULONG    cjOut,
PVOID    pvOut);

/*
 * DirectDraw
 */

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS           *pCallBacks,
DD_SURFACECALLBACKS    *pSurfaceCallBacks,
DD_PALETTECALLBACKS    *pPaletteCallBacks);

VOID DrvDisableDirectDraw(
DHPDEV  dhpdev);

BOOL DrvGetDirectDrawInfo(
DHPDEV        dhpdev,
DD_HALINFO   *pHalInfo,
DWORD        *pdwNumHeaps,
VIDEOMEMORY  *pvmList,
DWORD        *pdwNumFourCCCodes,
DWORD        *pdwFourCC);

/*
 * Engine callbacks - tracking clip region changes
 */

#define WOC_RGN_CLIENT_DELTA    0x0001
#define WOC_RGN_CLIENT          0x0002
#define WOC_RGN_SURFACE_DELTA   0x0004
#define WOC_RGN_SURFACE         0x0008
#define WOC_CHANGED             0x0010
#define WOC_DELETE              0x0020

typedef VOID (CALLBACK * WNDOBJCHANGEPROC)(WNDOBJ *pwo, FLONG fl);

#define WO_RGN_CLIENT_DELTA     0x0001
#define WO_RGN_CLIENT           0x0002
#define WO_RGN_SURFACE_DELTA    0x0004
#define WO_RGN_SURFACE          0x0008
#define WO_RGN_UPDATE_ALL       0x0010
#define WO_RGN_WINDOW           0x0020

WNDOBJ * APIENTRY EngCreateWnd(
SURFOBJ         *pso,
HWND             hwnd,
WNDOBJCHANGEPROC pfn,
FLONG            fl,
int              iPixelFormat);

VOID EngDeleteWnd(
WNDOBJ  *pwo);

ULONG APIENTRY WNDOBJ_cEnumStart(
WNDOBJ  *pwo,
ULONG    iType,
ULONG    iDirection,
ULONG    cLimit);

BOOL APIENTRY WNDOBJ_bEnum(
WNDOBJ  *pwo,
ULONG    cj,
ULONG   *pul);

VOID APIENTRY WNDOBJ_vSetConsumer(
WNDOBJ  *pwo,
PVOID    pvConsumer);

/*
 * Engine callbacks - tracking driver managed resources
 */

HDRVOBJ APIENTRY EngCreateDriverObj(
PVOID pvObj,
FREEOBJPROC pFreeObjProc,
HDEV hdev);

BOOL APIENTRY EngDeleteDriverObj(
HDRVOBJ hdo,
BOOL bCallBack,
BOOL bLocked);

DRIVEROBJ * APIENTRY EngLockDriverObj(HDRVOBJ hdo);
BOOL APIENTRY EngUnlockDriverObj(HDRVOBJ hdo);

/*
 * Engine callback - return current process handle.
 */

HANDLE APIENTRY EngGetProcessHandle();

/*
 * Pixel formats
 */

BOOL APIENTRY DrvSetPixelFormat(
SURFOBJ *pso,
LONG     iPixelFormat,
HWND     hwnd);

LONG APIENTRY DrvDescribePixelFormat(
DHPDEV   dhpdev,
LONG     iPixelFormat,
ULONG    cjpfd,
PIXELFORMATDESCRIPTOR *ppfd);

/*
 * Swap buffers
 */

BOOL APIENTRY DrvSwapBuffers(
SURFOBJ *pso,
WNDOBJ  *pwo);

/*
 * Function prototypes - Engine Simulations
 */

BOOL APIENTRY EngBitBlt(
SURFOBJ  *psoTrg,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclTrg,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4);

BOOL APIENTRY EngLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix);

BOOL APIENTRY EngStretchBlt(
SURFOBJ         *psoDest,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlHTOrg,
RECTL           *prclDest,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode);

BOOL APIENTRY EngTextOut(
SURFOBJ  *pso,
STROBJ   *pstro,
FONTOBJ  *pfo,
CLIPOBJ  *pco,
RECTL    *prclExtra,
RECTL    *prclOpaque,
BRUSHOBJ *pboFore,
BRUSHOBJ *pboOpaque,
POINTL   *pptlOrg,
MIX       mix);

BOOL APIENTRY EngStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX        mix);

BOOL APIENTRY EngFillPath(
SURFOBJ  *pso,
PATHOBJ  *ppo,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix,
FLONG     flOptions);

BOOL APIENTRY EngStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *plineattrs,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mixFill,
FLONG      flOptions);

BOOL APIENTRY EngPaint(
SURFOBJ  *pso,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix);

BOOL APIENTRY EngCopyBits(
SURFOBJ  *psoDest,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDest,
POINTL   *pptlSrc);

ULONG APIENTRY EngSetPointerShape(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
SURFOBJ  *psoColor,
XLATEOBJ *pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL    *prcl,
FLONG     fl);

VOID APIENTRY EngMovePointer(
SURFOBJ  *pso,
LONG      x,
LONG      y,
RECTL    *prcl);


//
// Halftone releated APIs
//


LONG
APIENTRY
HT_ComputeRGBGammaTable(
    USHORT  GammaTableEntries,
    USHORT  GammaTableType,
    USHORT  RedGamma,
    USHORT  GreenGamma,
    USHORT  BlueGamma,
    LPBYTE  pGammaTable
    );

LONG
APIENTRY
HT_Get8BPPFormatPalette(
    LPPALETTEENTRY  pPaletteEntry,
    USHORT          RedGamma,
    USHORT          GreenGamma,
    USHORT          BlueGamma
    );


typedef struct _DEVHTINFO {
    DWORD       HTFlags;
    DWORD       HTPatternSize;
    DWORD       DevPelsDPI;
    COLORINFO   ColorInfo;
    } DEVHTINFO, *PDEVHTINFO;

#define DEVHTADJF_COLOR_DEVICE      0x00000001
#define DEVHTADJF_ADDITIVE_DEVICE   0x00000002

typedef struct _DEVHTADJDATA {
    DWORD       DeviceFlags;
    DWORD       DeviceXDPI;
    DWORD       DeviceYDPI;
    PDEVHTINFO  pDefHTInfo;
    PDEVHTINFO  pAdjHTInfo;
    } DEVHTADJDATA, *PDEVHTADJDATA;

LONG
APIENTRY
HTUI_DeviceColorAdjustment(
    LPSTR           pDeviceName,
    PDEVHTADJDATA   pDevHTAdjData
    );


//
// General support APIS
//

VOID
APIENTRY
EngDebugBreak(
    VOID
    );

VOID
APIENTRY
EngDebugPrint(
    PCHAR StandardPrefix,
    PCHAR DebugMessage,
    va_list ap
    );

VOID
APIENTRY
EngQueryPerformanceCounter(
    LONGLONG  *pPerformanceCount
    );

VOID
APIENTRY
EngQueryPerformanceFrequency(
    LONGLONG  *pFrequency
    );

BOOL
APIENTRY
EngSetPointerTag(
    HDEV       hdev,
    SURFOBJ   *psoMask,
    SURFOBJ   *psoColor,
    XLATEOBJ  *pxlo,
    FLONG      fl
    );

//
// Kernel mode memory operations
//

#define FL_ZERO_MEMORY      0x00000001

PVOID
APIENTRY
EngAllocMem(
    ULONG Flags,
    ULONG MemSize,
    ULONG Tag
    );

VOID
APIENTRY
EngFreeMem(
    PVOID Mem
    );

//
// User mode memory Operations
//

VOID
APIENTRY
EngProbeForRead(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    );

VOID
APIENTRY
EngProbeForReadAndWrite(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    );

PVOID
APIENTRY
EngAllocUserMem(
    ULONG cj,
    ULONG tag
    );

HANDLE
APIENTRY
EngSecureMem(
    PVOID Address,
    ULONG Length
    );

VOID
APIENTRY
EngUnsecureMem(
    HANDLE hSecure
    );


VOID
APIENTRY
EngFreeUserMem(
    PVOID pv
    );




DWORD
APIENTRY
EngDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    );

int
APIENTRY
EngMulDiv(
    int a,
    int b,
    int c);


//
// Loading drivers and gettings entry points from them
//

HANDLE
APIENTRY
EngLoadImage(
    LPWSTR pwszDriver
    );

PVOID
APIENTRY
EngFindImageProcAddress(
    HANDLE hModule,
    LPSTR lpProcName
    );

VOID
APIENTRY
EngUnloadImage(
    HANDLE hModule
    );

//
// callback for extra PDEV information
//

LPWSTR
APIENTRY
EngGetPrinterDataFileName(
    HDEV hdev
    );

LPWSTR
APIENTRY
EngGetDriverName(
    HDEV hdev
    );

typedef struct _TYPE1_FONT
{
    HANDLE  hPFM;
    HANDLE  hPFB;
    ULONG   ulIdentifier;
} TYPE1_FONT;


BOOL
APIENTRY
EngGetType1FontList(
    HDEV            hdev,
    TYPE1_FONT      *pType1Buffer,
    ULONG           cjType1Buffer,
    PULONG          pulLocalFonts,
    PULONG          pulRemoteFonts,
    LARGE_INTEGER   *pLastModified
    );


//
// Manipulating resource sections
//

HANDLE
APIENTRY
EngLoadModule(
    LPWSTR pwsz
    );

PVOID
APIENTRY
EngMapModule(
    HANDLE h,
    PULONG pSize
    );

PVOID
APIENTRY
EngFindResource(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize
    );

VOID
APIENTRY
EngFreeModule(
    HANDLE h
    );

//
// FontFile Callbacks
//

VOID
APIENTRY
EngUnmapFontFile(
    ULONG iFile
    );

BOOL
APIENTRY
EngMapFontFile(
    ULONG  iFile,
    PULONG *ppjBuf,
    ULONG  *pcjBuf
    );

//
// Semaphores
//

DECLARE_HANDLE(HSEMAPHORE);

HSEMAPHORE
APIENTRY
EngCreateSemaphore(
    VOID
    );

VOID
APIENTRY
EngAcquireSemaphore(
    HSEMAPHORE hsem
    );

VOID
APIENTRY
EngReleaseSemaphore(
    HSEMAPHORE hsem
    );

VOID
APIENTRY
EngDeleteSemaphore(
    HSEMAPHORE hsem
    );

VOID
APIENTRY
EngMultiByteToUnicodeN(
    LPWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );

VOID
APIENTRY
EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );



// for the spooler

DWORD
APIENTRY
EngGetPrinterData(
    HANDLE   hPrinter,
    LPWSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
    );


DWORD
APIENTRY
EngSetPrinterData(
   HANDLE   hPrinter,
   LPWSTR   pType,
   DWORD    dwType,
   LPBYTE   lpbPrinterData,
   DWORD    cjPrinterData
);


BOOL
APIENTRY
EngGetForm(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
    );

BOOL
APIENTRY
EngWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
    );


BOOL
APIENTRY
EngGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
APIENTRY
EngEnumForms(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    );


ULONG
APIENTRY
EngEscape(
    HANDLE   hPrinter,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut
    );


#ifdef _X86_

    typedef struct _FLOATOBJ
    {
        ULONG ul1;
        ULONG ul2;
    } FLOATOBJ, *PFLOATOBJ;

    VOID  FLOATOBJ_SetFloat(PFLOATOBJ,FLOAT);
    VOID  FLOATOBJ_SetLong(PFLOATOBJ,LONG);

    LONG  FLOATOBJ_GetFloat(PFLOATOBJ);
    LONG  FLOATOBJ_GetLong(PFLOATOBJ);

    VOID  FLOATOBJ_AddFloat(PFLOATOBJ,FLOAT);
    VOID  FLOATOBJ_AddLong(PFLOATOBJ,LONG);
    VOID  FLOATOBJ_Add(PFLOATOBJ,PFLOATOBJ);

    VOID  FLOATOBJ_SubFloat(PFLOATOBJ,FLOAT);
    VOID  FLOATOBJ_SubLong(PFLOATOBJ,LONG);
    VOID  FLOATOBJ_Sub(PFLOATOBJ,PFLOATOBJ);

    VOID  FLOATOBJ_MulFloat(PFLOATOBJ,FLOAT);
    VOID  FLOATOBJ_MulLong(PFLOATOBJ,LONG);
    VOID  FLOATOBJ_Mul(PFLOATOBJ,PFLOATOBJ);

    VOID  FLOATOBJ_DivFloat(PFLOATOBJ,FLOAT);
    VOID  FLOATOBJ_DivLong(PFLOATOBJ,LONG);
    VOID  FLOATOBJ_Div(PFLOATOBJ,PFLOATOBJ);

    VOID  FLOATOBJ_Neg(PFLOATOBJ);

    BOOL  FLOATOBJ_EqualLong(PFLOATOBJ,LONG);
    BOOL  FLOATOBJ_GreaterThanLong(PFLOATOBJ,LONG);
    BOOL  FLOATOBJ_LessThanLong(PFLOATOBJ,LONG);

    BOOL  FLOATOBJ_Equal(PFLOATOBJ,PFLOATOBJ);
    BOOL  FLOATOBJ_GreaterThan(PFLOATOBJ,PFLOATOBJ);
    BOOL  FLOATOBJ_LessThan(PFLOATOBJ,PFLOATOBJ);


#else

    // any platform that has support for floats in the kernel

    typedef FLOAT FLOATOBJ;
    typedef FLOAT *PFLOATOBJ;

    #define   FLOATOBJ_SetFloat(pf,f)       {*(pf) = (f);           }
    #define   FLOATOBJ_SetLong(pf,l)        {*(pf) = (FLOAT)(l);    }

    #define   FLOATOBJ_GetFloat(pf)         *((PULONG)pf)
    #define   FLOATOBJ_GetLong(pf)          (LONG)*(pf)

    #define   FLOATOBJ_AddFloat(pf,f)       {*(pf) += f;            }
    #define   FLOATOBJ_AddLong(pf,l)        {*(pf) += (LONG)(l);    }
    #define   FLOATOBJ_Add(pf,pf1)          {*(pf) += *(pf1);       }

    #define   FLOATOBJ_SubFloat(pf,f)       {*(pf) -= f;            }
    #define   FLOATOBJ_SubLong(pf,l)        {*(pf) -= (LONG)(l);    }
    #define   FLOATOBJ_Sub(pf,pf1)          {*(pf) -= *(pf1);       }

    #define   FLOATOBJ_MulFloat(pf,f)       {*(pf) *= f;            }
    #define   FLOATOBJ_MulLong(pf,l)        {*(pf) *= (LONG)(l);    }
    #define   FLOATOBJ_Mul(pf,pf1)          {*(pf) *= *(pf1);       }

    #define   FLOATOBJ_DivFloat(pf,f)       {*(pf) /= f;            }
    #define   FLOATOBJ_DivLong(pf,l)        {*(pf) /= (LONG)(l);    }
    #define   FLOATOBJ_Div(pf,pf1)          {*(pf) /= *(pf1);       }

    #define   FLOATOBJ_Neg(pf)              {*(pf) = -*(pf);        }

    #define   FLOATOBJ_EqualLong(pf,l)          (*(pf) == (FLOAT)(l))
    #define   FLOATOBJ_GreaterThanLong(pf,l)    (*(pf) >  (FLOAT)(l))
    #define   FLOATOBJ_LessThanLong(pf,l)       (*(pf) <  (FLOAT)(l))

    #define   FLOATOBJ_Equal(pf,pf1)            (*(pf) == *(pf1))
    #define   FLOATOBJ_GreaterThan(pf,pf1)      (*(pf) >  *(pf1))
    #define   FLOATOBJ_LessThan(pf,pf1)         (*(pf) <  *(pf1))


#endif // _FLOATOBJ_

typedef struct  tagFLOATOBJ_XFORM
{
    FLOATOBJ eM11;
    FLOATOBJ eM12;
    FLOATOBJ eM21;
    FLOATOBJ eM22;
    FLOATOBJ eDx;
    FLOATOBJ eDy;
} FLOATOBJ_XFORM, *PFLOATOBJ_XFORM, FAR *LPFLOATOBJ_XFORM;

ULONG
APIENTRY
XFORMOBJ_iGetFloatObjXform(
    XFORMOBJ *pxo,
    FLOATOBJ_XFORM * pfxo);

// SORT specific defines

typedef int (__cdecl *SORTCOMP)(const void *pv1, const void *pv2);

VOID
APIENTRY
EngSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp);

typedef struct _ENG_TIME_FIELDS {
    USHORT usYear;        // range [1601...]
    USHORT usMonth;       // range [1..12]
    USHORT usDay;         // range [1..31]
    USHORT usHour;        // range [0..23]
    USHORT usMinute;      // range [0..59]
    USHORT usSecond;      // range [0..59]
    USHORT usMilliseconds;// range [0..999]
    USHORT usWeekday;     // range [0..6] == [Sunday..Saturday]
} ENG_TIME_FIELDS, *PENG_TIME_FIELDS;

VOID EngQueryLocalTime(
    PENG_TIME_FIELDS);



FD_GLYPHSET *
APIENTRY
EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    );


INT
APIENTRY
EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

INT
APIENTRY
EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    );

VOID
APIENTRY
EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    );


HANDLE
APIENTRY
EngLoadModuleForWrite(
    LPWSTR pwsz,
    ULONG  cjSizeOfModule
    );

BOOL
APIENTRY
EngGetFileChangeTime(
    HANDLE          h,
    LARGE_INTEGER   *pChangeTime
    );

LPWSTR
APIENTRY
EngGetFilePath(
    HANDLE h
  );

ULONG
APIENTRY
EngSaveFloatingPointState(
    VOID   *pBuffer,
    ULONG   cjBufferSize
    );

BOOL
APIENTRY
EngRestoreFloatingPointState(
    VOID   *pBuffer
    );

//
// DirectDraw surface locking
//

PDD_SURFACE_LOCAL
APIENTRY
EngLockDirectDrawSurface(
        HANDLE hSurface
        );

BOOL
APIENTRY
EngUnlockDirectDrawSurface(
        PDD_SURFACE_LOCAL pSurface
        );

//
//  Engine Event support.
//

//
//  Opaque type for event objects.
//

typedef struct _PENG_EVENT * PEVENT;

//
//  This routine can only be called on PEVENTS returned from EngCreateEvent()
//  and must not be called on PEVENTs returned from EngMapEvent().
//

BOOL
EngDeleteEvent(
    IN  PEVENT      pEngEvent
    );

BOOL
EngCreateEvent(
    OUT PEVENT *    ppEngEvent
    );

//
//  This routine must be called by Display driver process terminate. This routine can only
//  be called on pEvent PEVENTs returned by EngMapEvent(). It must not be called on
//  pEvents returned via EngCreateEvent(). It must not be called in the PDRVCLEANPROC typed
//  below
//

BOOL
EngUnmapEvent(
    IN  HDRVOBJ     pDrvObj
    );

//
//      PDRVCLEANPROC   pDrvCleanProc    - Pointer to function to be called
//          when the process in whose context this event was mapped
//          terminates. It is a requirement that EngUnmapEvent not be called
//          in this routine.
//

typedef
BOOLEAN
(*PDRVCLEANPROC)(
    PVOID           pDriverCleanupContext
    );

//
//  Can be called by Display driver. This routine returns a valid HDRVOBJ if
//  successful, NULL otherwise.
//
//  Arguments:
//      HDEV            hDev             - Device handle.
//      HANDLE          hUserObject      - user mode HANDLE to event.
//      PEVENT        * ppEvent          - Pointer to ENG_EVENT to be filled.
//          No waiting is allowed on mapped events.
//      PDRVCLEANPROC   pDrvCleanProc    - Pointer to function to be called
//          when the process in whose context this event was mapped
//          terminates. It is a requirement that EngUnmapEvent not be called
//          in this routine.
//      PVOID           pCleanupContext    - Pointer to driver managed resource
//          passed to pEventDeleteProc at process termination.
//
//  Returns:
//      HDRVOBJ - a handle to a DRVOBJ. Important: if the driver wishes to do
//      cleanup itself, it must call EngUnmapEvent on the HDRVOBJ returned
//      from this routine.
//
HDRVOBJ
EngMapEvent(
    IN  HDEV            hDev,
    IN  HANDLE          hUserObject,
    OUT PEVENT        * ppEvent,
    IN  PDRVCLEANPROC   pDrvUnmapProc,
    IN  PVOID           pDrvUnmapContext
    );

//
//  May be called by Display driver. Can only be called on events created by
//  the Display driver, not on mapped events. Returns TRUE if successful,
//  FALSE otherwise. FALSE indicates an invalid parameter, which must not
//  be used again.
//

BOOL
EngWaitForSingleObject(
    IN  PEVENT          pEngEvent,
    IN  PLARGE_INTEGER  pTimeOut
    );

//
//  PUBLIC, called by Display driver.
//  Private info: Basically a wrapper for KeSetEvent(). Can be called on
//  created or mapped events. Returns TRUE if successful, FALSE otherwise.
//  FALSE indicates an invalid parameter, which must not be used again.
//

BOOL
EngSetEvent(
    IN  PEVENT          pEngEvent
    );


#endif  //  _WINDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\h\ut.h ===
//
// Utilities
//

#ifndef _H_UT
#define _H_UT



//
// Data types stored in the profile information.
//
#define COM_PROFTYPE_STRING     1L
#define COM_PROFTYPE_INT        2L
#define COM_PROFTYPE_BOOL       3L
#define COM_PROFTYPE_UNKNOWN    4L


#define COM_MAX_SUBKEY         256
#define COM_MAX_BOOL_STRING    5



//
//
// TYPEDEFS
//
//


//
// Priorities for UT_RegisterEventProc()
//
// Event procedures are registered with a priority that affects the order
// that the event procedures are called in.
//
// All event procedures of a given priority are called before event
// procedures of a numerically lower priority.
//
// The priority can be any number between 0 and UT_MAX_PRIORITY
//
// The following values have been defined for specific uses:
//  UT_PRIORITY_OBMAN :     Used by OBMAN so its client event procedures
//                            are called before those of the client
//  UT_PRIORITY_APPSHARE    : Used by the DCShare Core to ensure it sees
//                            events before 'Normal' event procs.
//  UT_PRIORITY_NORMAL      : For all cases where the order of callling is
//                            not important.
//  UT_PRIORITY_NETWORK     : Used by the Network Layer to free any
//                            unprocessed network buffers.
//  UT_PRIORITY_LAST        : Used by the Utility Services to get the
//                            default event procedure called last
//
//
typedef enum
{
    UT_PRIORITY_LAST = 0,
    UT_PRIORITY_NETWORK,
    UT_PRIORITY_NORMAL,
    UT_PRIORITY_APPSHARING,
    UT_PRIORITY_OBMAN,
    UT_PRIORITY_MAX
} UT_PRIORITY;
typedef UT_PRIORITY * PUT_PRIORITY;



//
// SYSTEM LIMITS
//

//
// Maximum number of event handlers for each task
//
#define UTEVENT_HANDLERS_MAX            4

//
// Maximum number of exit procedures
//
#define UTEXIT_PROCS_MAX                4


//
// The groupware critsects, identified by constant
//
#define UTLOCK_FIRST        0
typedef enum
{
    UTLOCK_UT = UTLOCK_FIRST,
    UTLOCK_OM,              // obman
    UTLOCK_AL,              // app loader
    UTLOCK_T120,            // gcc/mcs
    UTLOCK_AS,              // app sharing
    UTLOCK_MAX
}
UTLOCK;


// Event message
#define WM_UTTRIGGER_MSG    (WM_APP)


//
// BASEDLIST
//
// This is a list structure with based offsets
//
// next            : the next item in the list
// prev            : the previous item in the list
//
//
typedef struct tagBASEDLIST
{
    DWORD       next;
    DWORD       prev;
}
BASEDLIST;
typedef BASEDLIST FAR * PBASEDLIST;


typedef struct
{
    BASEDLIST  chain;
    void FAR *pData;
}
SIMPLE_LIST, FAR * PSIMPLE_LIST;



//
//
// MACROS
//
//
//
// List handling
// =============
// The common functions support the concept of a doubly linked list of
// objects.  Objects can be inserted and removed from specified locations
// in the list.
//
// At start of day the calling application must call COM_BasedListInit with a
// pointer to a private piece of memory for a BASEDLIST structure.  The list
// handling will initialise this structure.  The application must not
// release this memory while the list is active.  (Nor must it release any
// object while it is in a list!)
//
// The list functions can only manage a single list, however the app
// can load objects with multiple lists.  Each call to the common list
// functions takes a BASEDLIST pointer as the object handle and if the
// application defines multiple BASEDLIST structures within an object then it
// may manage them through the list functions.
//
//
// List chaining
// =============
// For normal list chaining, we have something like
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = pointer->next;
//   }
//
// When using lists whose elements contain offsets (in this case, relative
// offsets) to the next element, we have to cast to a 32-bit integer before
// we can add the offset.  This macro encapsulates this, and the example
// above would be modified as follows to use it:
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = (TYPE) COM_BasedNextListField(pointer);
//   }
//
// Note also that the value returned by the macro is a pointer to a generic
// list object i.e.  a PBASEDLIST, and so must be cast back to the
// appropriate type.
//
//

//
// List traversing macros
// ======================
// These macros make use of DC_NEXT and DC_PREV, but also take the type of
// list being traversed in order to return the start pointer of the chained
// structure.
//
// The LIST_FIND macro supports the searching of a list, matching a key
// value to a selected structure element.
//
// The parameters to the macros are as follows:
//
//   pHead (type: PBASEDLIST)
//   -----
//      a pointer the root of the list
//
//   pEntry (type: STRUCT FAR * FAR *)
//   ------
//      a pointer to pointer to structure to chain from
//
//   STRUCT (a type name)
//   ------
//      the type of **pEntry
//
//   chain (a field name)
//   -----
//      the text name of the field in STRUCT which is the link along which
//      you wish to traverse
//
//   field (a field name)
//   -----
//      when FINDing, the text name of the field in STRUCT against which
//      you wish to match
//
//   key (a value, of the same type as STRUCT.field)
//   ---
//      when FINDing, the value to match against STRUCT.field against
//
//



//
// Offset arithmetic
// =================
// Using offsets within memory blocks, rather than pointers, to refer to
// objects in shared memory (as necessitated by the DC-Groupware shared
// memory architecture) presents certain difficulties.  Pointer arithmetic
// in C assumes that addition/subtraction operations involve objects of the
// same type and the offsets are presented as number of units of that
// particular type, rather than number of bytes.
//
// Therefore, pointers must be cast to integers before performing
// arithmetic on them (note that casting the pointers to byte pointers is
// not enough since on segmented architectures C performs bounds checking
// when doing pointer arithmetic which we don't want).
//
// Since this would make for cumbersome code if repeated everywhere, we
// define some useful macros to convert
//
// - an (offset, base) pair to a pointer (OFFSETBASE_TO_PTR)
//
// - a (pointer, base) pair to an offset (PTRBASE_TO_OFFSET)
//
// - a NULL pointer value to an offset(NULLBASE_TO_OFFSET)
//
// The offset calculated is the offset of the first parameter from the
// second.  As described above, the pointers passed in must be cast to
// 32-bit unsigned integers first, subtracted to get the offset, and then
// cast to 32-bit signed.
//
// The NULLBASE_TO_OFFSET value gives an offset that after translation back
// to a pointer gives a NULL.  This is NOT the same as a NULL offset, since
// this translates back to the base pointer (which is a perfectly valid
// address).
//
//
#define PTRBASE_TO_OFFSET(pObject, pBase)                               \
      (LONG)(((DWORD_PTR)(pObject)) - ((DWORD_PTR)(pBase)))

#define OFFSETBASE_TO_PTR(offset, pBase)                                \
      ((void FAR *) ((DWORD_PTR)(pBase) + (LONG)(offset)))

#define NULLBASE_TO_OFFSET(pBase)                                       \
      ((DWORD_PTR) (0L - (LONG_PTR)(pBase)))


__inline BOOL COM_BasedListIsEmpty ( PBASEDLIST pHead )
{
    ASSERT((pHead->next == 0 && pHead->prev == 0) ||
           (pHead->next != 0 && pHead->prev != 0));
    return (pHead->next == 0);
}

__inline void FAR * COM_BasedFieldToStruct ( PBASEDLIST pField, UINT nOffset )
{
    return (void FAR *) ((DWORD_PTR)pField - nOffset);
}

__inline PBASEDLIST COM_BasedStructToField ( void FAR * pStruct, UINT nOffset )
{
    return (PBASEDLIST) ((DWORD_PTR) pStruct + nOffset);
}

__inline PBASEDLIST COM_BasedNextListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->next, p);
}

__inline PBASEDLIST COM_BasedPrevListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->prev, p);
}

void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset );
void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset );

typedef enum
{
    LIST_FIND_FROM_FIRST,
    LIST_FIND_FROM_NEXT
}
LIST_FIND_TYPE;

void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT           nOffset,
                           int           nOffsetKey,
                           DWORD_PTR     Key,
                           int           cbKeySize );


PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData );
void FAR *   COM_SimpleListRemoveHead ( PBASEDLIST pHead );

//
//
// FUNCTION PROTOTYPES
//
//

//
// API FUNCTION: COM_Rect16sIntersect(...)
//
// DESCRIPTION:
// ============
// Checks whether two TSHR_RECT16s rectangles intersect.  Rectangles are
// defined to be inclusive of all edges.
//
// PARAMETERS:
// ===========
// pRect1          : pointer to a TSHR_RECT16 rectangle.
// pRect2          : pointer to a TSHR_RECT16 rectangle.
//
// RETURNS:
// ========
// TRUE - if the rectangles intersect
// FALSE - otherwise.
//
//
__inline BOOL COM_Rect16sIntersect(LPTSHR_RECT16 pRect1, LPTSHR_RECT16 pRect2)
{
    if ((pRect1->left > pRect2->right) ||
        (pRect1->right < pRect2->left) ||
        (pRect1->top > pRect2->bottom) ||
        (pRect1->bottom < pRect2->top))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}


//
// API FUNCTION: COM_BasedListInit(...)
//
// DESCRIPTION:
// ============
// Initialise a list root.
//
// PARAMETERS:
// ===========
// pListRoot       : pointer to the list root.
//
// RETURNS:
// ========
// Nothing.
//
//
__inline void COM_BasedListInit(PBASEDLIST pListRoot)
{
    //
    // The <next> and <prev> items in a list are the offsets, from the list
    // item, of the next and previous list items.
    //
    // In an empty list, the next item after the root is the root itself,
    // so the <next> offset is zero.  Likewise for <prev>.
    //
    pListRoot->next = 0;
    pListRoot->prev = 0;
}


//
// API FUNCTION: COM_BasedListInsertBefore(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
void COM_BasedListInsertBefore(PBASEDLIST pListLink, PBASEDLIST pNewLink);


//
// API FUNCTION: COM_BasedListInsertAfter(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
//
void COM_BasedListInsertAfter(PBASEDLIST pListLink,  PBASEDLIST pNewLink);

//
// API FUNCTION: COM_BasedListRemove(...)
//
// DESCRIPTION:
// ============
// This function removes an item from a list.  The item to be removed is
// specified by a pointer to the BASEDLIST structure within the item.
//
// PARAMETERS:
// ===========
// pListLink       : pointer to link of the item to be removed.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_BasedListRemove(PBASEDLIST pListLink);


//
// API FUNCTION: COM_ReadProfInt(...)
//
// DESCRIPTION:
// ============
// This reads a private profile integer from the registry.
//
// PARAMETERS:
// ===========
// pSection        : section containing the entry to read.
// pEntry          : entry name of integer to retrieve.
// defaultValue    : default value to return
// pValue          : buffer to return the entry in.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_ReadProfInt(LPSTR pSection, LPSTR pEntry, int defValue, int * pValue);

#ifndef DLL_DISP
//
// API FUNCTION: DCS_StartThread(...)
//
// DESCRIPTION:
// ============
// Start a new thread of execution
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
//
//
BOOL DCS_StartThread(LPTHREAD_START_ROUTINE entryFunction);
#endif // DLL_DISP



#ifndef DLL_DISP
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int  bufferSize,
                                 ULONG expectedDataType);
#endif // DLL_DISP





#define MAKE_SUBALLOC_PTR(pPool, chunkOffset)   OFFSETBASE_TO_PTR(chunkOffset, pPool)

#define MAKE_SUBALLOC_OFFSET(pPool, pChunk)     PTRBASE_TO_OFFSET(pChunk, pPool)


//
//
// Return codes - all offset from UT_BASE_RC
//
//

enum
{
    UT_RC_OK                    = UT_BASE_RC,
    UT_RC_NO_MEM
};


//
// The maximum number of UT events which we try to process without yielding
//
#define MAX_EVENTS_TO_PROCESS    10


//
//
// Types
//
//

//
// Utility Functions Interface handle
//
typedef struct tagUT_CLIENT *    PUT_CLIENT;


#define UTTASK_FIRST        0
typedef enum
{
    UTTASK_UI = UTTASK_FIRST,
    UTTASK_CMG,
    UTTASK_OM,
    UTTASK_AL,
    UTTASK_DCS,
    UTTASK_WB,
    UTTASK_MAX
}
UT_TASK;


//
// Event procedure registered by UT_RegisterEvent().
//
// Takes event handler registered data, event number and 2 parameters
//      Returns TRUE if event processed
//      Returns FALSE if not and event should be passed on to next handler
//
//
typedef BOOL (CALLBACK * UTEVENT_PROC)(LPVOID, UINT, UINT_PTR, UINT_PTR);

//
// Exit procedure
//
typedef void (CALLBACK * UTEXIT_PROC)( LPVOID exitData );

//
// The name of the class used to create UT windows
//
#define UT_WINDOW_CLASS     "DCUTWindowClass"

//
// The ID of the timer to use for trigger events.
//
#define UT_DELAYED_TIMER_ID 0x10101010


//
//
// Prototypes
//
//

//
//
// Task routines
//
//   UT_WndProc()              Subclassing window procedure
//   UT_InitTask()             Initialise a task
//   UT_TermTask()             Terminate a task
//   UT_RegisterEvent()        Register an event handler
//   UT_DeregisterEvent()      Deregisters an event handler
//   UT_RegisterExit()         Register an exit routine
//   UT_DeregisterExit()       Deregister an exit routine
//   UT_PostEvent()            Send an event to a task
//
//

LRESULT CALLBACK  UT_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL UT_InitTask(UT_TASK task, PUT_CLIENT * pputTask);

//
//
// Overview:
//   This registers a task and assigns it a handle.
//   All other Utility Functions require this handle to be passed to them.
//
//   If a task has already been registered with the same process ID, the
//   utilities handle that has already been allocated is returned.
//   This is to allows the Utility Functions to be used in the context of
//   tasks that DC-SHARE has intercepted the graphics calls for.
//
//   Each task is identified by a name.
//
// Parameters:
//
//   task
//     Unique it for identifying task
//
//   pUtHandle (returned)
//     Utility Services handle to be used for all calls to the Utility
//     Services by this task
//
//


void UT_TermTask(PUT_CLIENT * pputTask);
//
//
// Overview:
//   This de-registers a task
//   All task resources are freed and the utHandle is released
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//

void UT_RegisterEvent(PUT_CLIENT      putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID       eventData,
                                UT_PRIORITY  priority);

void UT_DeregisterEvent(PUT_CLIENT  putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID      eventData);

void UT_PostEvent(PUT_CLIENT putTaskFrom,
                                     PUT_CLIENT putTaskTo,
                                     UINT    delay,
                                     UINT    eventNo,
                                     UINT_PTR param1,
                                     UINT_PTR param2);

#define NO_DELAY        0

//
//
// Overview:
//   This posts an event to another task.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
//   toHandle
//     Utility Functions TASK handle of task to post event to
//
//   delay
//     Delay (in milliseconds) before event is posted
//
//   eventNo
//     event to be posted (see autevt.h for details of events)
//
//   param1
//     parameter 1 for event (meaning depends on event)
//
//   param2
//     parameter 2 for event (meaning depends on event)
//
//
// NOTES:
//
//   1)  The delay time is in milliseconds.  This may not be supported by
//       underlying OS but the setting and checking of the pop time value
//       is OS specific.
//
//   2)  The posting of events is asynchronous, the delay is simply
//       the time before the event is posted.  The task the event is
//       posted to will receive the event NOT BEFRE this time is up.
//
//   3)  If an event is posted with a delay specified, the sending task
//       must continue to process messages for the event to be posted
//

void UT_RegisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);
void UT_DeregisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);



//
// Memory routines
//      UT_MallocRefCount
//      UT_BumpUpRefCount
//      UT_FreeRefCount
//


void *  UT_MallocRefCount(UINT cbSizeMem, BOOL fZeroMem);
void    UT_BumpUpRefCount(void * pMemory);
void    UT_FreeRefCount(void ** ppMemory, BOOL fNullOnlyWhenFreed);


// Ref count allocs
typedef struct tagUTREFCOUNTHEADER
{
    STRUCTURE_STAMP
    UINT    refCount;
}
UTREFCOUNTHEADER;
typedef UTREFCOUNTHEADER * PUTREFCOUNTHEADER;



//
// UT_MoveMemory()
// Replacement for CRT memmove(); handles overlapping
//
void *  UT_MoveMemory(void * dst, const void * src, size_t count);



//
// Locks
// - UT_Lock()       - Locks a lock
// - UT_Unlock()     - Unlocks a lock
//

#ifndef DLL_DISP
extern CRITICAL_SECTION g_utLocks[UTLOCK_MAX];

__inline void UT_Lock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    EnterCriticalSection(&g_utLocks[lock]);
}

__inline void UT_Unlock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    LeaveCriticalSection(&g_utLocks[lock]);
}

#endif // DLL_DISP


//
// Tasks
// UT_HandleProcessStart()
// UT_HandleProcessEnd()
// UT_HandleThreadEnd()
//

BOOL UT_HandleProcessStart(HINSTANCE hInstance);

void UT_HandleProcessEnd(void);

void UT_HandleThreadEnd(void);



//
// Structure for holding an event.  The first two fields allow the event to
// be held on the delayed event Q to be scheduled later.
//
typedef struct tagUTEVENT_INFO
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    // Params
    UINT            event;
    UINT_PTR        param1;
    UINT_PTR        param2;

    PUT_CLIENT      putTo;
    UINT            popTime;
}
UTEVENT_INFO;
typedef UTEVENT_INFO  * PUTEVENT_INFO;


#ifndef DLL_DISP
void __inline ValidateEventInfo(PUTEVENT_INFO pEventInfo)
{
    ASSERT(!IsBadWritePtr(pEventInfo, sizeof(UTEVENT_INFO)));
}
#endif // DLL_DISP


//
// Information held about each exit procedure
//
typedef struct tagUTEXIT_PROC_INFO
{
    UTEXIT_PROC     exitProc;
    LPVOID          exitData;
} UTEXIT_PROC_INFO;
typedef UTEXIT_PROC_INFO * PUTEXIT_PROC_INFO;

//
// Information held about each event procedure
//
typedef struct tagUTEVENT_PROC_INFO
{
    UTEVENT_PROC    eventProc;
    LPVOID          eventData;
    UT_PRIORITY     priority;
}
UTEVENT_PROC_INFO;
typedef UTEVENT_PROC_INFO * PUTEVENT_PROC_INFO;


//
//
// UT_CLIENT
//
// Information stored about each Utilities registered task.  A pointer to
// this structure is returned as the UT Handle from UT_InitTask(), and is
// passed in as a parameter to subsequent calls to UT.
//
// This structure is allocated in the shared memory bank.
//
// This should be a multiple of 4 bytes to ensure DWORD alignment of the
// allocated memory
//
//
typedef struct tagUT_CLIENT
{
    DWORD               dwThreadId;
    HWND                utHwnd;         // Window to post UT events to

    UTEXIT_PROC_INFO    exitProcs[UTEXIT_PROCS_MAX];
                                         // Exit procedures registered for
                                         //   this task.
    UTEVENT_PROC_INFO   eventHandlers[UTEVENT_HANDLERS_MAX];
                                         // Event procedures registered for
                                         //   this task.

    BASEDLIST           pendingEvents;   // List of events for this task
                                         //   which are ready to be
                                         //   processed.
    BASEDLIST           delayedEvents;   // List of delayed events destined
                                         //   for this task.
}
UT_CLIENT;


#ifndef DLL_DISP
void __inline ValidateUTClient(PUT_CLIENT putTask)
{
    extern UT_CLIENT    g_autTasks[UTTASK_MAX];

    ASSERT(putTask >= &(g_autTasks[UTTASK_FIRST]));
    ASSERT(putTask < &(g_autTasks[UTTASK_MAX]));
    ASSERT(putTask->dwThreadId);
}
#endif // DLL_DISP


//
//
// UTTaskEnd(...)
//
//   This routine frees all resources associated with the task and
//   releases the handle
//
// Parameters:
//
//   pTaskData - The Utility Functions handle for the task that is ending
//
//
void UTTaskEnd(PUT_CLIENT putTask);



//
//
// Overview:
// This routine is called to check the status of delayed events and to post
// them to the target process if required.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
// NOTES:
//
// 1) This routine is called periodically or whenever the application
//       believes a delayed event has popped.
//
// Return codes: None
//
//
void UTCheckEvents(PUT_CLIENT putTask);
void UTCheckDelayedEvents(PUT_CLIENT putTask);


//
//
// UTProcessEvent(...)
//
// Overview:
//   This process an event for the current task
//
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//
//   event
//     The event to process
//
//   param1
//     The 1st parameter for the event
//
//   param2
//     The 2nd parameter for the event
//
//
void UTProcessEvent(PUT_CLIENT putTask, UINT event, UINT_PTR param1, UINT_PTR param2);


//
//
// UTProcessDelayedEvent(...)
//
// A delayed event destined for the current task is ready to be processed.
//
//   pTaskData   - The current tasks data.
//   eventOffset - Offset into the shared memory bank at which the event
//                 is stored.
//
//
void UTProcessDelayedEvent(PUT_CLIENT putTask, DWORD eventOffset);



//
//
// UTPostImmediateEvt(...)
//
// This function adds an event to a task's pending event queue, and posts
// a trigger event if required.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostImmediateEvt(PUT_CLIENT          putTaskFrom,
                        PUT_CLIENT          putTaskTo,
                        UINT                event,
                        UINT_PTR            param1,
                        UINT_PTR            param2);


//
//
// UTPostDelayedEvt(...)
//
// This function adds an event to a task's delayed event queue, and starts
// a timer (on the destination's task) to get that task to process the
// event when the timer ticks.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   delay           - the delay (in milliseconds)
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostDelayedEvt(PUT_CLIENT            putTaskFrom,
                                    PUT_CLIENT  putTaskTo,
                                   UINT         delay,
                                   UINT         event,
                                   UINT_PTR     param1,
                                   UINT_PTR     param2);

//
//
// Overview:
//   This posts a event to another task
//
// Parameters:
//
//   pSrcTaskInfo  - task data for the source task
//   pDestTaskInfo - task data for the dest task
//
void UTTriggerEvt(PUT_CLIENT putTaskFrom, PUT_CLIENT putTaskTo);


//
//
// Overview:
//   This starts a delayed-event timer for a task.
//
// Parameters:
//   pTaskData
//     The task data for the task
//
//   popTime
//     The target time for the timer to pop - this is an OS specific value
//     in the same format as that returned by UTPopTime().
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime);



#endif // _H_UT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\thk\asthk.h ===
// --------------------------------------------------------------------------
//
//  ASTHK.H
//
//  Declarations of 32->16 thunk APIs
//
//  Copyright(c) Microsoft, 1996-
//
//
//  On non x86 platforms, these APIs are #defined instead of implemented,
//  since thunks are in .ASM and that is only x86.  We'll clean this W95-NT
//  stuff up later.
//
// --------------------------------------------------------------------------
#ifndef _H_ASTHK
#define _H_ASTHK


//
// MAIN functions
//

//
// Prototypes for secret KERNEL32 functions
//
BOOL        WINAPI  FT_thkConnectToFlatThkPeer(LPSTR pszDll16, LPSTR pszDll32);
UINT        WINAPI  FreeLibrary16(UINT hmod16);

//
// NMNASWIN.DLL functions
//

// General
void        WINAPI  OSILoad16(LPDWORD lphInst);
BOOL        WINAPI  OSIInit16(DWORD version, HWND hwnd, LPDWORD ppdcsShared,
    LPDWORD ppoaShared, LPDWORD ppimShared, LPDWORD psbcEnabled,
    LPDWORD pShuntBuffers, LPDWORD pBitmasks);
void        WINAPI  OSITerm16(BOOL fUnloading);
BOOL        WINAPI  OSIFunctionRequest16(DWORD escape, void FAR* lpvEscInfo, DWORD cbEscInfo);

// IM
BOOL        WINAPI  OSIInstallControlledHooks16(BOOL fEnable);
void        WINAPI  OSIInjectMouseEvent16(UINT flags, int x, int y, UINT mouseData, DWORD dwExtraInfo);
void        WINAPI  OSIInjectKeyboardEvent16(UINT flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);

#endif // _H_ASTHK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\nmpvkhlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       nmpvkhlp.h
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __NMPVKHLP_H__
#define __NMPVKHLP_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv);

// The following is also needed for non-x86 due to a bug in advapi32 for
// CryptAcquireContextW. 
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecert.rc
//
#define IDR_PVKROOT                 101
#define IDR_ROOTCERTIFICATE         102
#define IDS_DEFNAME                 103

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\nmmkcert.cpp ===
//+-------------------------------------------------------------------------
//
// RdMkCert - Remote Desktop internal certificate generator
//
//            Generates NetMeeting default user certificates. The NetMeeting
//            root key and certificate are stored as a program resource.
//
// ClausGi    7/29/98 created based on MAKECERT
//
//--------------------------------------------------------------------------

#include "global.h"
#include <memtrack.h>

#ifdef DEBUG
HDBGZONE    ghDbgZone = NULL;
static PTCHAR _rgZonesNmMkCert[] = { TEXT("rdmkcert"), };
#endif /* DEBUG */

//+-------------------------------------------------------------------------
//  contants
//--------------------------------------------------------------------------

//allow max 10 extensions per certificate
#define MAX_EXT_CNT 10

//+-------------------------------------------------------------------------
//  globals
//--------------------------------------------------------------------------

WCHAR*   g_wszSubjectKey            = L"_RdMkCert";
WCHAR*     g_wszSubjectStore          = WSZNMSTORE;
DWORD     g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_CURRENT_USER;

DWORD     g_dwIssuerKeySpec          = AT_SIGNATURE;
DWORD    g_dwSubjectKeySpec         = AT_KEYEXCHANGE;

WCHAR   *g_wszSubjectDisplayName = NULL; // BUGBUG set this?

LPWSTR  g_wszIssuerProviderName   = NULL;
LPWSTR    g_wszSubjectProviderName    = NULL;

WCHAR*   g_wszSubjectX500Name;

DWORD g_dwProvType = PROV_RSA_FULL;

HMODULE    hModule=NULL;

BOOL MakeCert(DWORD dwFlags);

BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            hModule = hDllInst;
            ASSERT (hModule != NULL);
            DBGINIT(&ghDbgZone, _rgZonesNmMkCert);
            DisableThreadLibraryCalls (hDllInst);
            DBG_INIT_MEMORY_TRACKING(hDllInst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            DBG_CHECK_MEMORY_TRACKING(hDllInst);
            hModule = NULL;
            break;
        }

        default:
            break;
    }
    return (TRUE);
}

//
// X.509 cert strings must be from X.208 printable character set... this
// function enforces that.
//

static const char szPrintable[] = " '()+,-./:=?\"";   // along with A-Za-z0-9

VOID MkPrintableString ( LPSTR szString )
{
    CHAR * p = szString;

    while ( *p )
    {
        if (!(('a' <= *p && *p <='z') ||
              ('A' <= *p && *p <='Z') ||
              ('0' <= *p && *p <='9') ||
              _StrChr(szPrintable,*p)))
        {
            *p = '-';
        }
        p++;
    }
}

DWORD WINAPI NmMakeCert(     LPCSTR szFirstName,
                            LPCSTR szLastName,
                            LPCSTR szEmailName,
                            LPCSTR szCity,
                            LPCSTR szCountry,
                            DWORD flags)
{
    DWORD dwRet = -1;

    WARNING_OUT(("NmMakeCert called"));

    // Form the unencoded X500 subject string. It would be nice to
    // use official constants for the below... CertRDNValueToString?

    UINT cbX500Name = ( szFirstName ? lstrlen(szFirstName) : 0 ) +
                      ( szLastName ? lstrlen(szLastName) : 0 ) +
                      ( szEmailName ? lstrlen(szEmailName) : 0 ) +
                      ( szCity ? lstrlen(szCity) : 0 ) +
                      ( szCountry ? lstrlen(szCountry) : 0 ) +
                      128; // Extra is for RDN OID strings: CN= etc.

    char * pX500Name = new char[cbX500Name];

    if ( NULL == pX500Name )
    {
        ERROR_OUT(("couldn't allocate %d bytes for x500 name", cbX500Name));
        goto cleanup;
    }

    ASSERT( ( szFirstName && *szFirstName ) || ( szLastName && *szLastName ) );

    wsprintf( pX500Name, "CN=\"%s %s\"", szFirstName ? szFirstName : "", szLastName ? szLastName : "" );

    if ( szEmailName && *szEmailName )
        wsprintf( pX500Name + lstrlen(pX500Name), ", E=\"%s\"", szEmailName );

    if ( szCity && *szCity )
        wsprintf( pX500Name + lstrlen(pX500Name), ", S=\"%s\"", szCity );

    if ( szCountry && *szCountry )
        wsprintf( pX500Name + lstrlen(pX500Name), ", C=\"%s\"", szCountry );

    MkPrintableString ( pX500Name );

    g_wszSubjectX500Name = AnsiToUnicode ( pX500Name );

    ASSERT(g_wszSubjectX500Name);

    if ( flags & NMMKCERT_F_LOCAL_MACHINE )
    {
        // We are being asked to generate a local machine cert...
        // change the subject store flag and the key container name
        g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        g_wszSubjectKey = L"_RdMkMchCert";
    }

    // If we're on NT5 we have to generate the cert using the
    // PROV_RSA_SCHANNEL provider, on other platforms this provider type
    // doesn't exist.

    OSVERSIONINFO       osVersion;

    ZeroMemory(&osVersion, sizeof(osVersion));
    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    GetVersionEx(&osVersion);

    if (osVersion.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osVersion.dwMajorVersion >= 5)
    {
        g_dwProvType = PROV_RSA_SCHANNEL;
    }

    // Get to work and make the certificate
    if (!MakeCert(flags))
    {
        WARNING_OUT(("NmMakeCert failed."));
    }
    else
    {
        dwRet = 1;
    }

cleanup:

    if ( NULL != g_wszSubjectX500Name )
    {
        delete g_wszSubjectX500Name;
    }

    if ( NULL != pX500Name )
    {
        delete pX500Name;
    }

    return dwRet;
}


// RUNDLL entry point for certificate uninstall... the prototype is given
// by RUNDLL32.EXE requirements!
void CALLBACK NmMakeCertCleanup ( HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow )
{
    // Clean up exisint certs and private keys
    MakeCert(NMMKCERT_F_CLEANUP_ONLY);
    g_dwSubjectStoreFlag          = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    g_wszSubjectKey = L"_RdMkMchCert";
    MakeCert(NMMKCERT_F_LOCAL_MACHINE|NMMKCERT_F_CLEANUP_ONLY);
}


//+=========================================================================
//  Local Support Functions
//==========================================================================

//+=========================================================================
//  MakeCert support functions
//==========================================================================

BOOL VerifyIssuerKey( IN HCRYPTPROV hProv,
        IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo);
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer);

BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
BOOL EncodeSubject(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateSpcCommonName(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

BOOL    SaveCertToStore(HCRYPTPROV    hProv,
                        HCERTSTORE        hStore,
                        DWORD        dwFlag,
                        BYTE        *pbEncodedCert,
                        DWORD        cbEncodedCert,
                        LPWSTR        wszPvk,
                        DWORD        dwKeySpecification,
                        LPWSTR        wszCapiProv,
                        DWORD        dwCapiProvType);


//+-------------------------------------------------------------------------
//  Get the root's certificate from the program's resources
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetRootCertContext()
{
    PCCERT_CONTEXT    pCert = NULL;
    HRSRC            hRes;

    //
    // The root certificate is stored as a resource of ours.
    // Load it...
    //
    if (0 != (hRes = FindResource(hModule, MAKEINTRESOURCE(IDR_ROOTCERTIFICATE),
                        "CER"))) {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);

            if (cbRes && pbRes)
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    pbRes, cbRes);
            if ( NULL == pCert )
            {
                DWORD dwError = GetLastError();
            }

            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (pCert == NULL)
    {
        ERROR_OUT(("Error creating root cert: %x", GetLastError()));
    }
    return pCert;
}

//+-------------------------------------------------------------------------
//  Get the root's private key from the program's resources and create
//  a temporary key provider container
//--------------------------------------------------------------------------
HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV        hProv = 0;
    HRSRC            hRes;
    WCHAR            wszRootSig[] = L"Root Signature";

    *ppwszTmpContainer = NULL;

    if (0 != (hRes = FindResource(hModule,MAKEINTRESOURCE(IDR_PVKROOT),"PVK")))
    {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(hModule, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(hModule, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes) {
                PvkPrivateKeyAcquireContextFromMemory(
                    g_wszIssuerProviderName,
                    PROV_RSA_FULL,
                    pbRes,
                    cbRes,
                    NULL,               // hwndOwner
                    wszRootSig,
                    &g_dwIssuerKeySpec,
                    &hProv
                    );
            }
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (hProv == 0)
    {
        ERROR_OUT(("couldn't create root key provider: %x", GetLastError()));
    }
    return hProv;
}

//+-------------------------------------------------------------------------
//  Make the subject certificate. If the subject doesn't have a private
//  key, then, create.
//--------------------------------------------------------------------------
BOOL MakeCert(DWORD dwFlags)
{
    BOOL fResult;

    HCRYPTPROV        hIssuerProv = 0;
    LPWSTR            pwszTmpIssuerContainer = NULL;
    PCCERT_CONTEXT    pIssuerCertContext = NULL;
    PCERT_INFO        pIssuerCert =NULL; // not allocated

    HCRYPTPROV        hSubjectProv = 0;
    LPWSTR            pwszTmpSubjectContainer = NULL;

    PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo = NULL;         // not allocated
    PCERT_PUBLIC_KEY_INFO pAllocSubjectPubKeyInfo = NULL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded =0;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded =0;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded =0;
    BYTE *pbEKUEncoded = NULL;
    DWORD cbEKUEncoded = 0;

    CERT_INFO Cert;
    GUID SerialNumber;
    HCERTSTORE                hStore=NULL;

    CERT_EXTENSION rgExt[MAX_EXT_CNT];
    DWORD cExt = 0;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        szOID_RSA_MD5RSA, 0, 0
    };

    if (0 == (hSubjectProv = GetSubjectProv(&pwszTmpSubjectContainer)))
        goto ErrorReturn;


#define TEMP_CLEAN_CODE
#ifdef TEMP_CLEAN_CODE
    // open the system store where we used to generate certs
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        L"MY" );

        if ( hStore )
        {
                //
                // Delete all old certs
                //
                PCCERT_CONTEXT pCertContext = NULL;

                // Clear out any certificate(s) we may have added before
                while ( pCertContext = CertEnumCertificatesInStore(
                                                                                hStore, (PCERT_CONTEXT)pCertContext ))
                {
                        DWORD dwMagic;
                        DWORD cbMagic;

                        cbMagic = sizeof(dwMagic);

                        if (CertGetCertificateContextProperty(pCertContext,
                                CERT_FIRST_USER_PROP_ID, &dwMagic, &cbMagic) &&
                                cbMagic == sizeof(dwMagic) && dwMagic == NMMKCERT_MAGIC )
                        {
                                CertDeleteCertificateFromStore(pCertContext);
                                // Restart the enumeration
                                pCertContext = NULL;
                                continue;
                        }
                }
                CertCloseStore(hStore,0);
        }
#endif // TEMP_CLEAN_CODE

    // open a new cert store
    hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        hSubjectProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG | g_dwSubjectStoreFlag,
        g_wszSubjectStore);

    if(hStore==NULL)
        goto ErrorReturn;

    // Empty the store
    PCCERT_CONTEXT pCertContext;
    while ( pCertContext = CertEnumCertificatesInStore ( hStore, NULL ))
    {
        if ( !CertDeleteCertificateFromStore ( pCertContext ))
        {
            WARNING_OUT(("Failed to delete certificate: %x", GetLastError()));
            break;
        }
    }

    // If NMMKCERT_F_CLEANUP_ONLY is set, we are done
    if ( dwFlags & NMMKCERT_F_CLEANUP_ONLY )
    {
        // We've just deleted the existing certs, now delete the
        // private key container and exit.
        CryptAcquireContextU(
                &hSubjectProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));
        fResult = TRUE;
        goto CommonReturn;
    }

    //
    // Get access to the subject's (public) key, creating it if necessary
    //
    if (!GetPublicKey(hSubjectProv, &pAllocSubjectPubKeyInfo))
        goto ErrorReturn;
    pSubjectPubKeyInfo = pAllocSubjectPubKeyInfo;


    //
    // Encode the subject name
    //
    if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
        goto ErrorReturn;

    //
    // Get access to the issuer's (private) key
    //
    hIssuerProv= GetRootProv(&pwszTmpIssuerContainer);

    if (NULL == (pIssuerCertContext = GetRootCertContext()))
        goto ErrorReturn;

    pIssuerCert = pIssuerCertContext->pCertInfo;

    if (!VerifyIssuerKey(hIssuerProv, &pIssuerCert->SubjectPublicKeyInfo))
        goto ErrorReturn;

    //
    // Update the CERT_INFO
    //
    ClearStruct(&Cert);
    Cert.dwVersion = CERT_V3;

    CoCreateGuid(&SerialNumber);
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);

    Cert.SignatureAlgorithm = SignatureAlgorithm;
    Cert.Issuer.pbData = pIssuerCert->Subject.pbData;
    Cert.Issuer.cbData = pIssuerCert->Subject.cbData;

    {
        SYSTEMTIME st;

        // Valid starting now...
        GetSystemTimeAsFileTime(&Cert.NotBefore);

        // Ending in 2039 (arbitrarily)
        ClearStruct(&st);
        st.wYear  = 2039;
        st.wMonth = 12;
        st.wDay   = 31;
        st.wHour  = 23;
        st.wMinute= 59;
        st.wSecond= 59;
        SystemTimeToFileTime(&st, &Cert.NotAfter);
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pSubjectPubKeyInfo;

    // Cert Extensions

    if (!CreateEnhancedKeyUsage(
            &pbEKUEncoded,
            &cbEKUEncoded))
        goto ErrorReturn;

    rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
    rgExt[cExt].fCritical = FALSE;
    rgExt[cExt].Value.pbData = pbEKUEncoded;
    rgExt[cExt].Value.cbData = cbEKUEncoded;
    cExt++;

    if (g_wszSubjectDisplayName) {
        if (!CreateSpcCommonName(
                &pbSpcCommonNameEncoded,
                &cbSpcCommonNameEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_COMMON_NAME;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSpcCommonNameEncoded;
        rgExt[cExt].Value.cbData = cbSpcCommonNameEncoded;
        cExt++;
    }

    Cert.rgExtension = rgExt;
    Cert.cExtension = cExt;

    //
    // Sign and encode the certificate
    //
    cbCertEncoded = 0;
    CryptSignAndEncodeCertificate(
        hIssuerProv,
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        X509_CERT_TO_BE_SIGNED,
        &Cert,
        &Cert.SignatureAlgorithm,
        NULL,                       // pvHashAuxInfo
        NULL,                       // pbEncoded
        &cbCertEncoded
        );
    if (cbCertEncoded == 0) {
        ERROR_OUT(("CryptSignAndEncodeCertificate failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbCertEncoded = new BYTE[cbCertEncoded];
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hIssuerProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        ERROR_OUT(("CryptSignAndEncodeCertificate(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    // Output the encoded certificate to an cerificate store

    ASSERT(g_wszSubjectStore);
    ASSERT(AT_KEYEXCHANGE == g_dwSubjectKeySpec);

    if((!SaveCertToStore(hSubjectProv,
            hStore,
            g_dwSubjectStoreFlag,
            pbCertEncoded,
            cbCertEncoded,
            g_wszSubjectKey,
            g_dwSubjectKeySpec,
            g_wszSubjectProviderName,
            g_dwProvType)))
    {
        ERROR_OUT(("SaveCertToStore failed: %x", GetLastError()));
        goto ErrorReturn;

    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:

    PvkFreeCryptProv(hSubjectProv, g_wszSubjectProviderName,
                    g_dwProvType,pwszTmpSubjectContainer);

    //free the cert store
    if(hStore)
         CertCloseStore(hStore, 0);
    if (pIssuerCertContext)
        CertFreeCertificateContext(pIssuerCertContext);
    if (pAllocSubjectPubKeyInfo)
        delete (pAllocSubjectPubKeyInfo);
    if (pbSubjectEncoded)
        delete (pbSubjectEncoded);
    if (pbEKUEncoded)
        delete (pbEKUEncoded);
    if (pbSpcCommonNameEncoded)
        delete (pbSpcCommonNameEncoded);
    if (pbCertEncoded)
        delete (pbCertEncoded);
    if (hIssuerProv)
        CryptReleaseContext(hIssuerProv,0);

    return fResult;
}

//+-------------------------------------------------------------------------
//  save the certificate to a certificate store.  Attach private key information
//  to the certificate
//--------------------------------------------------------------------------
BOOL    SaveCertToStore(
                HCRYPTPROV hProv,
                HCERTSTORE hStore,        DWORD dwFlag,
                BYTE *pbEncodedCert,    DWORD cbEncodedCert,
                LPWSTR wszPvk,
                DWORD dwKeySpecification,
                LPWSTR wszCapiProv,        DWORD dwCapiProvType)
{
        BOOL                    fResult=FALSE;
        PCCERT_CONTEXT            pCertContext=NULL;
        CRYPT_KEY_PROV_INFO        KeyProvInfo;

        HCRYPTPROV              hDefaultProvName=NULL;
        DWORD                   cbData=0;
        LPSTR                   pszName=NULL;
        LPWSTR                  pwszName=NULL;

        //init
        ClearStruct(&KeyProvInfo);

        //add the encoded certificate to store
        if(!CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    &pCertContext))
            goto CLEANUP;

        //add properties to the certificate
        KeyProvInfo.pwszContainerName=wszPvk;
        KeyProvInfo.pwszProvName=wszCapiProv,
        KeyProvInfo.dwProvType=dwCapiProvType,
        KeyProvInfo.dwKeySpec=dwKeySpecification;

        if ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE )
        {
            // If this is a local machine cert, set the keyset flags
            // indicating that the private key will be under HKLM
            KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;
        }

        ASSERT(AT_KEYEXCHANGE == dwKeySpecification);

        //if wszCapiProv is NULL, we get the default provider name
        if(NULL==wszCapiProv)
        {
            //get the default provider
            if(CryptAcquireContext(&hDefaultProvName,
                                    NULL,
                                    NULL,
                                    KeyProvInfo.dwProvType,
                                    CRYPT_VERIFYCONTEXT))
            {

                //get the provider name
                if(CryptGetProvParam(hDefaultProvName,
                                    PP_NAME,
                                    NULL,
                                    &cbData,
                                    0) && (0!=cbData))
                {

                    if(pszName= new CHAR[cbData])
                    {
                        if(CryptGetProvParam(hDefaultProvName,
                                            PP_NAME,
                                            (BYTE *)pszName,
                                            &cbData,
                                            0))
                        {
                            pwszName= AnsiToUnicode(pszName);

                            KeyProvInfo.pwszProvName=pwszName;
                        }
                    }
                }
            }
        }

        //free the provider as we want
        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        hDefaultProvName=NULL;

        //add property related to the key container
        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                &KeyProvInfo))
            goto CLEANUP;

        //
        // Load the display name from resource and create a blob to
        // set the cert friendly name.
        //
        CHAR szFriendlyName[128];

        if (!LoadString(hModule, IDS_DEFNAME, szFriendlyName,
                                    sizeof(szFriendlyName)))
        {
            ERROR_OUT(("LoadString failed: %d", GetLastError()));
            goto CLEANUP;
        }

        WCHAR *pwszFriendlyName;

        pwszFriendlyName = AnsiToUnicode ( szFriendlyName );

        if ( NULL == pwszFriendlyName )
        {
            ERROR_OUT(("AnsiToUnicode failed"));
            goto CLEANUP;
        }

        CRYPT_DATA_BLOB FriendlyName;

        FriendlyName.pbData = (PBYTE)pwszFriendlyName;
        FriendlyName.cbData = ( lstrlenW(pwszFriendlyName) + 1 ) *
                                sizeof(WCHAR);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                0,
                &FriendlyName))
            goto CLEANUP;

        //
        // Add magic ID
        //
        CRYPT_DATA_BLOB MagicBlob;
        DWORD dwMagic;

        dwMagic = NMMKCERT_MAGIC;
        MagicBlob.pbData = (PBYTE)&dwMagic;
        MagicBlob.cbData = sizeof(dwMagic);

        if(!CertSetCertificateContextProperty(
                pCertContext,
                CERT_FIRST_USER_PROP_ID,
                0,
                &MagicBlob))
            goto CLEANUP;

        fResult=TRUE;

CLEANUP:

        if (pwszFriendlyName)
            delete pwszFriendlyName;

        //free the cert context
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pszName)
            delete (pszName);

        if(pwszName)
           delete pwszName;

        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        return fResult;

}

//+-------------------------------------------------------------------------
//  Verify the issuer's certificate. The public key in the certificate
//  must match the public key associated with the private key in the
//  issuer's provider
//--------------------------------------------------------------------------
BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    // Get issuer's public key
    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        g_dwIssuerKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0)
    {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwIssuerKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CrypteExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    if (!CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            pIssuerKeyInfo,
            pPubKeyInfo)) {
        // BUGBUG:: This might be the test root with an incorrectly
        // encoded public key. Convert to the capi representation and
        // compare.
        BYTE rgProvKey[256]; //BUGBUG needs appropriate constant or calc
        BYTE rgCertKey[256]; //BUGBUG needs appropriate constant or calc
        DWORD cbProvKey = sizeof(rgProvKey);
        DWORD cbCertKey = sizeof(rgCertKey);

        if (!CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pIssuerKeyInfo->PublicKey.pbData,
                    pIssuerKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgProvKey,
                    &cbProvKey)                             ||
            !CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pPubKeyInfo->PublicKey.pbData,
                    pPubKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgCertKey,
                    &cbCertKey)                             ||
                cbProvKey == 0 || cbProvKey != cbCertKey    ||
                memcmp(rgProvKey, rgCertKey, cbProvKey) != 0) {
            ERROR_OUT(("mismatch: %x", GetLastError()));
            goto ErrorReturn;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pPubKeyInfo)
        delete (pPubKeyInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Get the subject's private key provider
//--------------------------------------------------------------------------
HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV    hProv=0;
    WCHAR        wszKeyName[40] = L"Subject Key";
    int            ids;
    WCHAR       *wszRegKeyName=NULL;
    BOOL        fResult;
    HCRYPTKEY    hKey=NULL;
    GUID        TmpContainerUuid;

    //try to get the hProv from the private key container
    if(S_OK != PvkGetCryptProv(NULL,
                                wszKeyName,
                                g_wszSubjectProviderName,
                                g_dwProvType,
                                NULL,
                                g_wszSubjectKey,
                                &g_dwSubjectKeySpec,
                                ppwszTmpContainer,
                                &hProv))
        hProv=0;

    //generate the private keys
    if (0 == hProv)
    {
        //now that we have to generate private keys, generate
        //AT_KEYEXCHANGE key

        // If there is an existing container with the name of the
        // one we are about to create, attempt to delete it first so
        // that creating it won't fail. This should only happen if the
        // container exists but we were unable to acquire a context to
        // it previously.
        CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_DELETEKEYSET |
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 ));

        // Open a new key container
        if (!CryptAcquireContextU(
                &hProv,
                g_wszSubjectKey,
                g_wszSubjectProviderName,
                g_dwProvType,
                CRYPT_NEWKEYSET |
                    ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                        CRYPT_MACHINE_KEYSET : 0 )))
        {
            ERROR_OUT(("CryptAcquireContext failed: %x", GetLastError()));
            goto CreateKeyError;
        }

        //generate new keys in the key container - make sure its EXPORTABLE
        //for SCHANNEL! (Note: remove that when SCHANNEL no longer needs it).
        if (!CryptGenKey( hProv, g_dwSubjectKeySpec, CRYPT_EXPORTABLE, &hKey))
        {
            ERROR_OUT(("CryptGenKey failed: %x", GetLastError()));
            goto CreateKeyError;
        }
        else
            CryptDestroyKey(hKey);

        //try to get the user key
        if (CryptGetUserKey( hProv, g_dwSubjectKeySpec, &hKey))
        {
            CryptDestroyKey(hKey);
        }
        else
        {
            // Doesn't have the specified public key
            CryptReleaseContext(hProv, 0);
            hProv=0;
        }

        if (0 == hProv )
        {
            ERROR_OUT(("sub key error: %x", GetLastError()));
            goto ErrorReturn;
        }
    } //hProv==0

    goto CommonReturn;

CreateKeyError:
ErrorReturn:
    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
CommonReturn:
    if(wszRegKeyName)
        delete (wszRegKeyName);

    return hProv;
}



//+-------------------------------------------------------------------------
//  Allocate and get the public key info for the provider
//--------------------------------------------------------------------------
BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        g_dwSubjectKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        ERROR_OUT(("CryptExportPublicKeyInfo failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo]))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            g_dwSubjectKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        ERROR_OUT(("CryptExportPublicKeyInfo(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        delete (pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert and encode the subject's X500 formatted name
//--------------------------------------------------------------------------
BOOL EncodeSubject(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL            fResult;
    DWORD            cbEncodedSubject=0;
    BYTE            *pbEncodedSubject=NULL;
    BYTE            *pbEncoded = NULL;
    DWORD            cbEncoded;

    //encode the wszSubjectX500Name into an encoded X509_NAME

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        NULL,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    pbEncodedSubject = new BYTE[cbEncodedSubject];
    if (pbEncodedSubject == NULL) goto ErrorReturn;

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        g_wszSubjectX500Name,
        0,
        NULL,
        pbEncodedSubject,
        &cbEncodedSubject,
        NULL))
    {
        ERROR_OUT(("CertStrToNameW(2) failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    cbEncoded=cbEncodedSubject;
    pbEncoded=pbEncodedSubject;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


// The test root's public key isn't encoded properly in the certificate.
// It's missing a leading zero to make it a unsigned integer.
static BYTE rgbTestRoot[] = {
    #include "root.h"
};
static CERT_PUBLIC_KEY_INFO TestRootPublicKeyInfo = {
    szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0
};

static BYTE rgbTestRootInfoAsn[] = {
    #include "rootasn.h"
};

//+-------------------------------------------------------------------------
//  X509 Extensions: Allocate and Encode functions
//--------------------------------------------------------------------------

BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL               fResult = TRUE;
    LPBYTE             pbEncoded =NULL;
    DWORD              cbEncoded;
    PCERT_ENHKEY_USAGE pUsage =NULL;

    //
    // Allocate a cert enhanced key usage structure and fill it in
    //

    pUsage = (PCERT_ENHKEY_USAGE) new BYTE[sizeof(CERT_ENHKEY_USAGE) +
                                                2 * sizeof(LPSTR)];
    if ( pUsage != NULL )
    {
        pUsage->cUsageIdentifier = 2;
        pUsage->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage+sizeof(CERT_ENHKEY_USAGE));

        pUsage->rgpszUsageIdentifier[0] = szOID_PKIX_KP_CLIENT_AUTH;
        pUsage->rgpszUsageIdentifier[1] = szOID_PKIX_KP_SERVER_AUTH;
    }
    else
    {
        fResult = FALSE;
    }

    //
    // Encode the usage
    //

    if ( fResult == TRUE )
    {
        fResult = CryptEncodeObject(
                       X509_ASN_ENCODING,
                       szOID_ENHANCED_KEY_USAGE,
                       pUsage,
                       NULL,
                       &cbEncoded
                       );

        if ( fResult == TRUE )
        {
            pbEncoded = new BYTE[cbEncoded];
            if ( pbEncoded != NULL )
            {
                fResult = CryptEncodeObject(
                               X509_ASN_ENCODING,
                               szOID_ENHANCED_KEY_USAGE,
                               pUsage,
                               pbEncoded,
                               &cbEncoded
                               );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }

    //
    // Cleanup
    //

    delete (pUsage);

    if ( fResult == TRUE )
    {
        *ppbEncoded = pbEncoded;
        *pcbEncoded = cbEncoded;
    }
    else
    {
        delete (pbEncoded);
    }

    return( fResult );
}

BOOL CreateSpcCommonName(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_NAME_VALUE NameValue;

    NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
    NameValue.Value.pbData =  (BYTE *) g_wszSubjectDisplayName;
    NameValue.Value.cbData =0;

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }
    pbEncoded = new BYTE[cbEncoded];
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME_VALUE,
            &NameValue,
            pbEncoded,
            &cbEncoded
            )) {
        ERROR_OUT(("CryptEncodeObject failed: %x", GetLastError()));
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        delete (pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\rootasn.h ===
0x30,0x5B,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,
0x00,0x03,0x4A,0x00,0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,
0xD6,0xE7,0xD9,0x66,0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,
0xB1,0xF7,0x87,0x30,0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,
0x5F,0x42,0xB6,0x9D,0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,
0x58,0x11,0xCB,0x40,0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\root.h ===
0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\common.inc ===
#
#  GHOST: h\shlguid.h and all of dev except this file.
#

##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the NetMeeting project.
#
# History:
#    Common NetMeeting makefile created 13-Aug-96 Chris Pirich (chrispi)
#    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
#    Created 27-Sep-94 by Bob Day (bobday)
#    from template created 12-Apr-1990 by Steve Wood (stevewo)
#
#
#
#
# Required definitions:
#
#     ROOT
#        Path to nm project root.
#
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#

!if !defined(ROOT)
!error  ROOT must be defined in sources file
!endif

!if !defined(DEVROOT)
!error  DEVROOT must be defined in sources file
!endif

!if "$(BUILD_PRODUCT)" != "NT"
OAK_INC_PATH=$(ROOT)\h		# A hack so version.rc can always be found.
SDK_LIB_PATH    = $(DEVROOT)\lib\*
SDK_INC_PATH    = $(DEVROOT)\inc
CRT_LIB_PATH    = $(DEVROOT)\lib\*
CRT_INC_PATH    = $(DEVROOT)\inc
#
# Set private paths
#

INCLUDES        = ..;$(ROOT)\dev\inc;$(ROOT)\h;$(ROOT)\h\t120;$(INCLUDES)
!else
INCLUDES        = ..;$(ROOT)\h;$(ROOT)\h\t120;$(INCLUDES);
!endif

COFFBASE_TXT_FILE = $(ROOT)\h\coffbase.txt
MASTER_VERSION_FILE=$(ROOT)\h\version.h

#
# Set common options
#

# Defining this allows windows.h to include other headers
#NOT_LEAN_AND_MEAN = 1

# Don't link to NT libs - defining this brings in int64.lib
# USE_NOLIBS      = 1

# Use multi-thread CRT by default
USE_LIBCMT        = 1

# Use C-runtime DLL by default
USE_MSVCRT        = 1

# don't use stdcall by default
386_STDCALL       = 0

UMTYPE            = windows

#
# Lego options
#
!if defined(NTBBT)

#NTPROFILEINPUT  = 1
!endif

# ****** "FINAL" should be defined only for golden builds ******
C_DEFINES       = $(C_DEFINES) -DFINAL

!if defined(USE_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
NMUTIL_LIB      = nmutilw
!else
NMUTIL_LIB      = nmutila
# Insure that we will work on Win 95
CHICAGO_PROJECT   = 1
CHICAGO_PRODUCT   = 1
NO_NTDLL          = 1
!endif

#
# Additional compiler flags
#
!if "$(BUILD_PRODUCT)" == "NT"
WIN32_WINNT_VERSION=0x500
#WIN32_WIN95_VERSION=0x040a
WIN32_IE_VERSION   =0x0500
WIN32_DEFINE= -D_WIN32_WINDOWS=0x500 -D_WIN32_WINNT=0x0500
#C_DEFINES          =$(C_DEFINES) -DSTRICT -DOS_WINDOWS -DWIN_95_32_BIT -DNASHVILLE
C_DEFINES          =$(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32
!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif
ATL_VER            = 30
USE_STATIC_ATL     = 1
#-D_ATL_NO_DEBUG_CRT
!else

#WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
#C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT

!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
DEBUG_CRTS         = 1
NTDEBUG            = ntsd
NTDEBUGTYPE        = windbg
!endif

USE_PDB            = 1
USE_PDB_TO_COMPILE = 1
#
# Additional linker flags
#

LINKER_FLAGS    = $(LINKER_FLAGS) -map

#
# Get all maps and syms
#

USE_MAPSYM = 1
!endif		# BUILD_PRODUCT != NT

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\cert\pvkutil.cpp ===
#include "global.h"


//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------

typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

// BUGBUG: enum from pvk.h?
#ifndef ENTER_PASSWORD
#define ENTER_PASSWORD    0
#endif // ENTER_PASSWORD

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0

#define MAX_PVK_FILE_LEN            4096

typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);

extern DWORD     g_dwSubjectStoreFlag;

//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(GUID) * 2 + 1) * sizeof(WCHAR))

//-------------------------------------------------------------------------
//
//    Call GetLastError and convert the return code to HRESULT
//--------------------------------------------------------------------------
HRESULT WINAPI SignError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

static BOOL LoadKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hKey = 0;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr)))
    {
        ERROR_OUT(("can't read in-memory pvk file hdr"));
        goto BadPvkFile;
    }
    
    ASSERT( Hdr.dwMagic == PVK_MAGIC );

    // Treat as a "normal" private key file
    cbPvk = Hdr.cbPvk;
    if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
        Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
        cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
    goto BadPvkFile;

    if (pdwKeySpec) {
        DWORD dwKeySpec = *pdwKeySpec;
        *pdwKeySpec = Hdr.dwKeySpec;
        if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
            SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
            goto ErrorReturn;
        }
    }

    // Allocate and read the private key
    if (NULL == (pbPvk = new BYTE[cbPvk]))
        goto ErrorReturn;
    if (!pfnRead(hRead, pbPvk, cbPvk))
        goto BadPvkFile;

    ASSERT(Hdr.dwEncryptType == PVK_NO_ENCRYPT);

    // Decrypt and import the private key
    if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, 0, dwFlags,
            &hKey))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        delete (pbPvk);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL AcquireKeyContextW(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    GUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    // UuidCreate(&TmpContainerUuid);
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }

    if (NULL == (pwszTmpContainer = (LPWSTR) new BYTE[
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES]))
        goto ErrorReturn;
    LStrCpyW(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET |
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        goto ErrorReturn;

    if (!LoadKeyW(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    fResult = FALSE;

CommonReturn:
    if (pwszTmpContainer) {
        delete (pwszTmpContainer);
    }
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{

    HRESULT hr = S_OK;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        delete (pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get crypto provider to based on either the pvkfile or key container name
//--------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(    IN HWND hwnd,
                            IN LPCWSTR pwszCaption,
                            IN LPCWSTR pwszCapiProvider,
                            IN DWORD   dwProviderType,
                            IN LPCWSTR pwszPvkFile,
                            IN LPCWSTR pwszKeyContainerName,
                            IN DWORD   *pdwKeySpec,
                            OUT LPWSTR *ppwszTmpContainer,
                            OUT HCRYPTPROV *phCryptProv)
{
    HANDLE    hFile=NULL;
    HRESULT    hr=E_FAIL;
    DWORD    dwRequiredKeySpec=0;

    //Init
    *ppwszTmpContainer=NULL;
    *phCryptProv=NULL;

    //get the provider handle based on the key container name
    if(!CryptAcquireContextU(phCryptProv,
                pwszKeyContainerName,
                pwszCapiProvider,
                dwProviderType,
                ( g_dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE ?
                    CRYPT_MACHINE_KEYSET : 0 )))
        return SignError();

    dwRequiredKeySpec=*pdwKeySpec;

    //make sure *pdwKeySpec is the correct key spec
    HCRYPTKEY hPubKey;
    if (CryptGetUserKey(
        *phCryptProv,
        dwRequiredKeySpec,
        &hPubKey
        )) 
    {
        CryptDestroyKey(hPubKey);
        *pdwKeySpec=dwRequiredKeySpec;
        return S_OK;
    } 
    else 
    {
        // Doesn't have the specified public key
        hr=SignError();
        CryptReleaseContext(*phCryptProv, 0);
        *phCryptProv=NULL;
        return hr;
    }        
}



void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    
    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);
    } else {
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\warning.h ===
#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
//#pragma warning(3:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
****/

#ifndef _INC_CONIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* function prototypes */

#ifndef _WINDOWS
char * __cdecl _cgets(char *);
int __cdecl _cprintf(const char *, ...);
int __cdecl _cputs(const char *);
int __cdecl _cscanf(const char *, ...);
int __cdecl _getch(void);
int __cdecl _getche(void);
#endif 
int __cdecl _inp(unsigned);
unsigned __cdecl _inpw(unsigned);
#ifndef _WINDOWS
int __cdecl _kbhit(void);
#endif 
int __cdecl _outp(unsigned, int);
unsigned __cdecl _outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl _putch(int);
int __cdecl _ungetch(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _WINDOWS
char * __cdecl cgets(char *);
int __cdecl cprintf(const char *, ...);
int __cdecl cputs(const char *);
int __cdecl cscanf(const char *, ...);
int __cdecl getch(void);
int __cdecl getche(void);
#endif 
int __cdecl inp(unsigned);
unsigned __cdecl inpw(unsigned);
#ifndef _WINDOWS
int __cdecl kbhit(void);
#endif 
int __cdecl outp(unsigned, int);
unsigned __cdecl outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl putch(int);
int __cdecl ungetch(int);
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CONIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ios class.
*   [AT&T C++]
*
****/

#ifndef _INC_IOS
#define _INC_IOS


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class streambuf;
class ostream;

class ios {

public:
    enum io_state {  goodbit = 0x00,
             eofbit  = 0x01,
             failbit = 0x02,
             badbit  = 0x04 };

    enum open_mode { in        = 0x01,
             out       = 0x02,
             ate       = 0x04,
             app       = 0x08,
             trunc     = 0x10,
             nocreate  = 0x20,
             noreplace = 0x40,
             binary    = 0x80 };    // CONSIDER: not in latest spec.

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
        left       = 0x0002,
        right      = 0x0004,
        internal   = 0x0008,
        dec        = 0x0010,
        oct        = 0x0020,
        hex        = 0x0040,
        showbase   = 0x0080,
        showpoint  = 0x0100,
        uppercase  = 0x0200,
        showpos    = 0x0400,
        scientific = 0x0800,
        fixed      = 0x1000,
        unitbuf    = 0x2000,
        stdio      = 0x4000
                 };

    static const long basefield;    // dec | oct | hex
    static const long adjustfield;  // left | right | internal
    static const long floatfield;   // scientific | fixed

    ios(streambuf*);            // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long _HFAR_ & iword(int) const;
    inline void _HFAR_ * _HFAR_ & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

protected:
    ios();
    ios(const ios&);            // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;           // not used
    int     ospecial;           // not used
    int     isfx_special;       // not used
    int     osfx_special;       // not used
    int     x_delbuf;           // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    int     x_width;
    char    x_fill;

    static void (*stdioflush)();    // not used
public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static long _HFAR_ * x_statebuf;  // used by xalloc()
    static int x_curindex;
// consider: make interal static to ios::sync_with_stdio()
    static int sunk_with_stdio;     // make sure sync_with done only once
};

inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
inline long ios::setf(long _l){ long _lO; _lO = x_flags; x_flags |= _l; return _lO; }
inline long ios::unsetf(long _l){ long _lO; _lO = x_flags; x_flags &= (~_l); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ state = _i; }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long _HFAR_ & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void _HFAR_ * _HFAR_ & ios::pword(int _i) const { return (void _HFAR_ * _HFAR_ &)x_statebuf[_i]; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER      0x1 /* upper case letter */
#define _LOWER      0x2 /* lower case letter */
#define _DIGIT      0x4 /* digit[0-9] */
#define _SPACE      0x8 /* tab, carriage return, newline, */
                /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif 

#ifdef _INTL
int __cdecl __isleadbyte(int);
#endif 

/* the character classification macro definitions */

#define isalpha(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c) ( (_ctype+1)[_c] & _UPPER )
#define islower(_c) ( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c) ( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)    ( (_ctype+1)[_c] & _HEX )
#define isspace(_c) ( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c) ( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c) ( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c) ( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c) ( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c) ( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c) ( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif 
#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef isleadbyte
#ifdef _INTL
#define isleadbyte(_c)  __isleadbyte(_c)
#else 
#define isleadbyte(_c)  (0)
#endif 
#endif 

/* extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else 
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CTYPE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [ANSI/System V]
*
****/

#ifndef _INC_ERRNO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* declare reference to errno */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 

/* Error Codes */

#define EZERO       0
#define EPERM       1
#define ENOENT      2
#define ESRCH       3
#define EINTR       4
#define EIO     5
#define ENXIO       6
#define E2BIG       7
#define ENOEXEC     8
#define EBADF       9
#define ECHILD      10
#define EAGAIN      11
#define ENOMEM      12
#define EACCES      13
#define EFAULT      14
#define ENOTBLK     15
#define EBUSY       16
#define EEXIST      17
#define EXDEV       18
#define ENODEV      19
#define ENOTDIR     20
#define EISDIR      21
#define EINVAL      22
#define ENFILE      23
#define EMFILE      24
#define ENOTTY      25
#define ETXTBSY     26
#define EFBIG       27
#define ENOSPC      28
#define ESPIPE      29
#define EROFS       30
#define EMLINK      31
#define EPIPE       32
#define EDOM        33
#define ERANGE      34
#define EUCLEAN     35
#define EDEADLOCK   36

#ifdef __cplusplus
}
#endif 

#define _INC_ERRNO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* function prototypes */

int __cdecl _chdir(const char *);
int __cdecl _chdrive(int);
char * __cdecl _getcwd(char *, int);
char * __cdecl _getdcwd(int, char *, int);
int __cdecl _getdrive(void);
int __cdecl _mkdir(const char *);
int __cdecl _rmdir(const char *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl chdir(const char *);
char * __cdecl getcwd(char *, int);
int __cdecl mkdir(const char *);
int __cdecl rmdir(const char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DIRECT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
****/

#ifndef _INC_IO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };

#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

int __cdecl _access(const char *, int);
int __cdecl _chmod(const char *, int);
int __cdecl _chsize(int, long);
int __cdecl _close(int);
int __cdecl _commit(int);
int __cdecl _creat(const char *, int);
int __cdecl _dup(int);
int __cdecl _dup2(int, int);
int __cdecl _eof(int);
long __cdecl _filelength(int);
int __cdecl _isatty(int);
int __cdecl _locking(int, int, long);
long __cdecl _lseek(int, long, int);
char * __cdecl _mktemp(char *);
int __cdecl _open(const char *, int, ...);
int __cdecl _read(int, void *, unsigned int);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
int __cdecl _setmode(int, int);
int __cdecl _sopen(const char *, int, int, ...);
long __cdecl _tell(int);
int __cdecl _umask(int);
int __cdecl _unlink(const char *);
int __cdecl _write(int, const void *, unsigned int);
#ifdef _WINDOWS
#ifndef _WINDLL
int __cdecl _wabout(char *);
int __cdecl _wclose(int, int);
int __cdecl _wgetexit(void);
int __cdecl _wgetfocus(void);
long __cdecl _wgetscreenbuf(int);
int __cdecl _wgetsize(int, int, struct _wsizeinfo *);
int __cdecl _wmenuclick(int);
int __cdecl _wopen(struct _wopeninfo *, struct _wsizeinfo *, int);
int __cdecl _wsetexit(int);
int __cdecl _wsetfocus(int);
int __cdecl _wsetscreenbuf(int, long);
int __cdecl _wsetsize(int, struct _wsizeinfo *);
void __cdecl _wyield(void);
#endif 
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl access(const char *, int);
int __cdecl chmod(const char *, int);
int __cdecl chsize(int, long);
int __cdecl close(int);
int __cdecl creat(const char *, int);
int __cdecl dup(int);
int __cdecl dup2(int, int);
int __cdecl eof(int);
long __cdecl filelength(int);
int __cdecl isatty(int);
int __cdecl locking(int, int, long);
long __cdecl lseek(int, long, int);
char * __cdecl mktemp(char *);
int __cdecl open(const char *, int, ...);
int __cdecl read(int, void *, unsigned int);
int __cdecl setmode(int, int);
int __cdecl sopen(const char *, int, int, ...);
long __cdecl tell(int);
int __cdecl umask(int);
int __cdecl unlink(const char *);
int __cdecl write(int, const void *, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_IO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

typedef long streamoff, streampos;

#include <ios.h>        // Define ios.

#include <streamb.h>        // Define streambuf.

#include <istream.h>        // Define istream.

#include <ostream.h>        // Define ostream.

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class iostream : public istream, public ostream {
public:
    iostream(streambuf*);
    virtual ~iostream();
protected:
// consider: make private??
    iostream();
    iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
    iostream(ios&);
    iostream(istream&);
    iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class Iostream_init {
public:
    Iostream_init();
    Iostream_init(ios &, int =0);   // treat as private
    ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the filebuf and fstream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef int filedesc;

class filebuf : public streambuf {
public:
static  const int   openprot;   // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int   sh_compat;  // compatibility share mode
static  const int   sh_none;    // exclusive mode no sharing
static  const int   sh_read;    // allow read sharing
static  const int   sh_write;   // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int   binary;
static  const int   text;

            filebuf();
            filebuf(filedesc);
            filebuf(filedesc, char _HFAR_ *, int);
            ~filebuf();

    filebuf*    attach(filedesc);
    filedesc    fd() const { return (x_fd==-1) ? EOF : x_fd; }
    int     is_open() const { return (x_fd!=-1); }
    filebuf*    open(const char _HFAR_ *, int, int = filebuf::openprot);
    filebuf*    close();
    int     setmode(int = filebuf::text);

virtual int     overflow(int=EOF);
virtual int     underflow();

virtual streambuf*  setbuf(char _HFAR_ *, int);
virtual streampos   seekoff(streamoff, ios::seek_dir, int);
// virtual  streampos   seekpos(streampos, int);
virtual int     sync();

private:
    filedesc    x_fd;
    int     x_fOpened;
};

class ifstream : public istream {
public:
    ifstream();
    ifstream(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    ifstream(filedesc);
    ifstream(filedesc, char _HFAR_ *, int);
    ~ifstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class ofstream : public ostream {
public:
    ofstream();
    ofstream(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    ofstream(filedesc);
    ofstream(filedesc, char _HFAR_ *, int);
    ~ofstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class fstream : public iostream {
public:
    fstream();
    fstream(const char _HFAR_ *, int, int = filebuf::openprot);
    fstream(filedesc);
    fstream(filedesc, char _HFAR_ *, int);
    ~fstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT      8     /* number of bits in a char */
#define SCHAR_MIN   (-127)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else 
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;          /* unsigned CHAR_MAX value */
#else 
extern "C" unsigned int _charmax;   /* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif 
#endif 
#define MB_LEN_MAX    2     /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32767)    /* minimum (signed) short value */
#define SHRT_MAX      32767     /* maximum (signed) short value */
#define USHRT_MAX     0xffff    /* maximum unsigned short value */
#define INT_MIN     (-32767)    /* minimum (signed) int value */
#define INT_MAX       32767     /* maximum (signed) int value */
#define UINT_MAX      0xffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647)   /* minimum (signed) long value */
#define LONG_MAX      2147483647    /* maximum (signed) long value */
#define ULONG_MAX     0xffffffff    /* maximum unsigned long value */

#define _INC_LIMITS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __interrupt _interrupt
#define __near      _near
#endif 

#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED
#pragma pack(2)

struct _DOSERROR {
    int exterror;
    char errclass;
    char action;
    char locus;
    };

#if ((!defined (__STDC__)) && (!defined (__cplusplus)))
/* Non-ANSI name for compatibility */
struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };
#endif 

#pragma pack()
#define _DOSERROR_DEFINED
#endif 


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED
#pragma pack(2)

struct _find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define find_t _find_t
#endif 

#pragma pack()
#define _FIND_T_DEFINED
#endif 


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED
#pragma pack(2)

struct _dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;      /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct _dostime_t {
    unsigned char hour; /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define dosdate_t _dosdate_t
#define dostime_t _dostime_t
#endif 

#pragma pack()
#define _DATETIME_T_DEFINED
#endif 


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t _diskfree_t
#endif 

#define _DISKFREE_T_DEFINED
#endif 


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                    /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL   0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY   0x01    /* Read only file */
#define _A_HIDDEN   0x02    /* Hidden file */
#define _A_SYSTEM   0x04    /* System file */
#define _A_VOLID    0x08    /* Volume ID file */
#define _A_SUBDIR   0x10    /* Subdirectory */
#define _A_ARCH     0x20    /* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

/* macro to construct a far pointer from segment and offset values
 */

#define _MK_FP(seg, offset) (void __far *)(((unsigned long)seg << 16) \
    + (unsigned long)(unsigned)offset)

/* external variable declarations */

extern unsigned int __near __cdecl _osversion;


/* function prototypes */

#ifndef _MT
int __cdecl _bdos(int, unsigned int, unsigned int);
#ifndef _WINDOWS
void __cdecl _chain_intr(void (__cdecl __interrupt __far *)());
#endif 
void __cdecl _disable(void);
#ifndef _WINDOWS
unsigned __cdecl _dos_allocmem(unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_close(int);
unsigned __cdecl _dos_commit(int);
unsigned __cdecl _dos_creat(const char *, unsigned, int *);
unsigned __cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned __cdecl _dos_findfirst(const char *, unsigned, struct _find_t *);
unsigned __cdecl _dos_findnext(struct _find_t *);
#ifndef _WINDOWS
unsigned __cdecl _dos_freemem(unsigned);
#endif 
void __cdecl _dos_getdate(struct _dosdate_t *);
void __cdecl _dos_getdrive(unsigned *);
unsigned __cdecl _dos_getdiskfree(unsigned, struct _diskfree_t *);
unsigned __cdecl _dos_getfileattr(const char *, unsigned *);
unsigned __cdecl _dos_getftime(int, unsigned *, unsigned *);
void __cdecl _dos_gettime(struct _dostime_t *);
void (__cdecl __interrupt __far * __cdecl _dos_getvect(unsigned))();
#ifndef _WINDOWS
void __cdecl _dos_keep(unsigned, unsigned);
#endif 
unsigned __cdecl _dos_lock(int, int, unsigned long, unsigned long);
unsigned __cdecl _dos_open(const char *, unsigned, int *);
unsigned __cdecl _dos_read(int, void __far *, unsigned, unsigned *);
unsigned long __cdecl _dos_seek(int, unsigned long, int);
#ifndef _WINDOWS
unsigned __cdecl _dos_setblock(unsigned, unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_setdate(struct _dosdate_t *);
void __cdecl _dos_setdrive(unsigned, unsigned *);
unsigned __cdecl _dos_setfileattr(const char *, unsigned);
unsigned __cdecl _dos_setftime(int, unsigned, unsigned);
unsigned __cdecl _dos_settime(struct _dostime_t *);
#ifndef _WINDOWS
void __cdecl _dos_setvect(unsigned, void (__cdecl __interrupt __far *)());
#endif 
unsigned __cdecl _dos_write(int, const void __far *, unsigned, unsigned *);
int __cdecl _dosexterr(struct _DOSERROR *);
void __cdecl _enable(void);
#ifndef _WINDOWS
void __cdecl _harderr(void (__far __cdecl *)(unsigned, unsigned,
    unsigned __far *));
void __cdecl _hardresume(int);
void __cdecl _hardretn(int);
#endif 
int __cdecl _intdos(union _REGS *, union _REGS *);
int __cdecl _intdosx(union _REGS *, union _REGS *, struct _SREGS *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);
#endif 

void __cdecl _segread(struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define FP_SEG     _FP_SEG
#define FP_OFF     _FP_OFF
#define MK_FP      _MK_FP

#ifndef _MT
int __cdecl bdos(int, unsigned int, unsigned int);
int __cdecl intdos(union REGS *, union REGS *);
int __cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#ifndef __cplusplus
int __cdecl dosexterr(struct DOSERROR *);
#endif 
#endif 
void __cdecl segread(struct SREGS *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the istream class.
*   [AT&T C++]
*
****/

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { }

    inline istream& operator>>(istream& (*_f)(istream&));
    inline istream& operator>>(ios& (*_f)(ios&));
    istream& operator>>(char _HFAR_ *);
    inline istream& operator>>(unsigned char _HFAR_ *);
    inline istream& operator>>(signed char _HFAR_ *);
    istream& operator>>(char _HFAR_ &);
    inline istream& operator>>(unsigned char _HFAR_ &);
    inline istream& operator>>(signed char _HFAR_ &);
    istream& operator>>(short _HFAR_ &);
    istream& operator>>(unsigned short _HFAR_ &);
    istream& operator>>(int _HFAR_ &);
    istream& operator>>(unsigned int _HFAR_ &);
    istream& operator>>(long _HFAR_ &);
    istream& operator>>(unsigned long _HFAR_ &);
    istream& operator>>(float _HFAR_ &);
    istream& operator>>(double _HFAR_ &);
    istream& operator>>(long double _HFAR_ &);
    istream& operator>>(streambuf*);

    int get();
    istream& get(char _HFAR_ *,int,char ='\n');
    inline istream& get(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& get(signed char _HFAR_ *,int,char ='\n');
    istream& get(char _HFAR_ &);
    inline istream& get(unsigned char _HFAR_ &);
    inline istream& get(signed char _HFAR_ &);
    istream& get(streambuf&,char ='\n');
    inline istream& getline(char _HFAR_ *,int,char ='\n');
    inline istream& getline(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& getline(signed char _HFAR_ *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char _HFAR_ *,int);
    inline istream& read(unsigned char _HFAR_ *,int);
    inline istream& read(signed char _HFAR_ *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();    // consider: protect and friend with manipulator ws
protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    int do_ipfx(int);

private:
    istream(ios&);
    int getint(char _HFAR_ *);
    int getdouble(char _HFAR_ *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (*_f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (*_f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }
    inline istream& istream::operator>>(signed char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }

    inline istream& istream::operator>>(unsigned char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }
    inline istream& istream::operator>>(signed char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }

    inline istream& istream::get(unsigned char _HFAR_ * b, int lim ,char delim) { return get((char _HFAR_ *)b, lim, delim); }
    inline istream& istream::get(signed char _HFAR_ * b, int lim, char delim) { return get((char _HFAR_ *)b, lim, delim); }

    inline istream& istream::get(unsigned char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }
    inline istream& istream::get(signed char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }

    inline istream& istream::getline(char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get(_b, _lim, _delim); }
    inline istream& istream::getline(unsigned char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }
    inline istream& istream::getline(signed char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }

    inline istream& istream::ignore(int _n,int delim) { _fGline++; return get((char _HFAR_ *)0, _n+1, (char)delim); }

    inline istream& istream::read(unsigned char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }
    inline istream& istream::read(signed char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }

class istream_withassign : public istream {
    public:
        istream_withassign();
        istream_withassign(streambuf*);
        ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

#ifndef _WINDLL
extern istream_withassign cin;
#endif 

inline istream& ws(istream& _ins) { _ins.eatwhite(); return _ins; }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
****/

#ifndef _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* definition of _exception struct - this struct is passed to the _matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
#pragma pack(2)

struct _exception {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif 

#pragma pack()
#define _EXCEPTION_DEFINED
#endif 


/* definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED

struct _complex {
    double x,y; /* real and imaginary parts */
    } ;

#ifndef __cplusplus
#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct complex {
    double x,y; /* real and imaginary parts */
    } ;
#endif 
#endif 

#define _COMPLEX_DEFINED
#endif 


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of _HUGE (XENIX) and HUGE_VAL (ANSI) error return values used
 * by several floating point math routines
 */

extern double __near __cdecl _HUGE;
#define HUGE_VAL _HUGE


/* function prototypes */

#ifdef _MT
int __cdecl  abs(int);
double  __pascal acos(double);
double  __pascal asin(double);
double  __pascal atan(double);
double  __pascal atan2(double, double);
double  __pascal atof(const char *);
double  __pascal _cabs(struct _complex);
double  __pascal ceil(double);
double  __pascal cos(double);
double  __pascal cosh(double);
int __cdecl  _dieeetomsbin(double *, double *);
int __cdecl  _dmsbintoieee(double *, double *);
double  __pascal exp(double);
double  __pascal fabs(double);
int __cdecl  _fieeetomsbin(float *, float *);
double  __pascal floor(double);
double  __pascal fmod(double, double);
int __cdecl  _fmsbintoieee(float *, float *);
double  __pascal frexp(double, int *);
double  __pascal _hypot(double, double);
double  __pascal _j0(double);
double  __pascal _j1(double);
double  __pascal _jn(int, double);
long    __cdecl  labs(long);
double  __pascal ldexp(double, int);
double  __pascal log(double);
double  __pascal log10(double);
int __cdecl  _matherr(struct _exception *);
double  __pascal modf(double, double *);
double  __pascal pow(double, double);
double  __pascal sin(double);
double  __pascal sinh(double);
double  __pascal sqrt(double);
double  __pascal tan(double);
double  __pascal tanh(double);
double  __pascal _y0(double);
double  __pascal _y1(double);
double  __pascal _yn(int, double);

#else 
int __cdecl abs(int);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double, double);
double  __cdecl atof(const char *);
double  __cdecl _cabs(struct _complex);
double  __cdecl ceil(double);
double  __cdecl cos(double);
double  __cdecl cosh(double);
int __cdecl _dieeetomsbin(double *, double *);
int __cdecl _dmsbintoieee(double *, double *);
double  __cdecl exp(double);
double  __cdecl fabs(double);
int __cdecl _fieeetomsbin(float *, float *);
double  __cdecl floor(double);
double  __cdecl fmod(double, double);
int __cdecl _fmsbintoieee(float *, float *);
double  __cdecl frexp(double, int *);
double  __cdecl _hypot(double, double);
double  __cdecl _j0(double);
double  __cdecl _j1(double);
double  __cdecl _jn(int, double);
long    __cdecl labs(long);
double  __cdecl ldexp(double, int);
double  __cdecl log(double);
double  __cdecl log10(double);
int __cdecl _matherr(struct _exception *);
double  __cdecl modf(double, double *);
double  __cdecl pow(double, double);
double  __cdecl sin(double);
double  __cdecl sinh(double);
double  __cdecl sqrt(double);
double  __cdecl tan(double);
double  __cdecl tanh(double);
double  __cdecl _y0(double);
double  __cdecl _y1(double);
double  __cdecl _yn(int, double);
#endif 


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
#pragma pack(2)
struct _exceptionl {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    long double arg1;   /* first argument to function */
    long double arg2;   /* second argument (if any) to function */
    long double retval; /* value to be returned by function */
    } ;
#pragma pack()
#define _LD_EXCEPTION_DEFINED
#endif 


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
#pragma pack(2)
struct _complexl {
    long double x,y;    /* real and imaginary parts */
    } ;
#pragma pack()
#define _LD_COMPLEX_DEFINED
#endif 

extern long double __near __cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int      __cdecl _matherrl(struct _exceptionl *);
long double  __cdecl modfl(long double, long double *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr _matherr

extern double __near __cdecl HUGE;

#ifdef _MT
#ifndef __cplusplus
double  __pascal cabs(struct complex);
#endif 
double  __pascal hypot(double, double);
double  __pascal j0(double);
double  __pascal j1(double);
double  __pascal jn(int, double);
double  __pascal y0(double);
double  __pascal y1(double);
double  __pascal yn(int, double);
#else 
#ifndef __cplusplus
double  __cdecl cabs(struct complex);
#endif 
double  __cdecl hypot(double, double);
double  __cdecl j0(double);
double  __cdecl j1(double);
double  __cdecl jn(int, double);
double  __cdecl y0(double);
double  __cdecl y1(double);
double  __cdecl yn(int, double);
#endif 

int __cdecl dieeetomsbin(double *, double *);
int __cdecl dmsbintoieee(double *, double *);
int __cdecl fieeetomsbin(float *, float *);
int __cdecl fmsbintoieee(float *, float *);

long double  __cdecl cabsl(struct _complexl);
long double  __cdecl hypotl(long double, long double);

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_MATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
void * __cdecl memcpy(void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MEMORY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\mmsystem.h ===
/*==========================================================================
 *
 *  mmsystem.h -- Include file for Multimedia API's
 *  mmsysp.h -- Internal include file for Multimedia API's       // ;internal
 *
 *  Version 4.00
 *
 *  Copyright (C) 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifndef _INC_MMSYSP                 // ;internal
#define _INC_MMSYSP                 // ;internal


#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef _WIN32
#ifndef _WINMM_
#define	WINMMAPI	DECLSPEC_IMPORT
#else
#define	WINMMAPI
#endif
#define _loadds
#define _huge
#else
#define	WINMMAPI
#endif

#ifdef  BUILDDLL                                // ;internal
#undef  WINAPI                                  // ;internal
#define WINAPI            _loadds FAR PASCAL    // ;internal
#undef  CALLBACK                                // ;internal
#define CALLBACK          _loadds FAR PASCAL    // ;internal
#endif  /* ifdef BUILDDLL */                    // ;internal

#ifdef _WIN32_VXD

#define NEAR
#define FAR

#define DECLARE_HANDLE(x) typedef WORD x
#define WINAPI

typedef DWORD LPSTR;
typedef DWORD LPVOID;
typedef DWORD LPCSTR;
typedef DWORD LPCWSTR;
typedef DWORD LRESULT;
typedef DWORD LPARAM;
typedef DWORD WPARAM;

typedef short WCHAR;

#endif

/****************************************************************************

		    General constants and data types

****************************************************************************/


/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   256    /* max error text length (including NULL) */
#define MAX_JOYSTICKOEMVXDNAME 260 /* max oem vxd name length (including NULL) */


/*
 *  Microsoft Manufacturer and Product ID's (these have been moved to
 *  MMREG.H for Windows 4.00 and above).
 */
#if (WINVER <= 0x030A)
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif

#ifndef MM_MIDI_MAPPER
#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif
#endif



/* general data types */

#ifdef _WIN32
typedef UINT        MMVERSION;  /* major (high byte), minor (low byte) */
#else
typedef UINT        VERSION;    /* major (high byte), minor (low byte) */
#endif
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
				/* call as if(err=xxxx(...)) Error(err); else */
#define _MMRESULT_

typedef UINT FAR   *LPUINT;



/* MMTIME data structure */
typedef struct mmtime_tag
{
    UINT            wType;      /* indicates the contents of the union */
    union
    {
	DWORD       ms;         /* milliseconds */
	DWORD       sample;     /* samples */
	DWORD       cb;         /* byte count */
	DWORD       ticks;      /* ticks in MIDI stream */

	/* SMPTE */
	struct
	{
	    BYTE    hour;       /* hours */
	    BYTE    min;        /* minutes */
	    BYTE    sec;        /* seconds */
	    BYTE    frame;      /* frames  */
	    BYTE    fps;        /* frames per second */
	    BYTE    dummy;      /* pad */
#ifdef _WIN32
	    BYTE    pad[2];
#endif
	} smpte;

	/* MIDI */
	struct
	{
	    DWORD songptrpos;   /* song pointer position */
	} midi;
    } u;
} MMTIME, *PMMTIME, NEAR *NPMMTIME, FAR *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
#define TIME_TICKS      0x0020  /* Ticks within MIDI stream */


/*
 *
 *
 */
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
		((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
		((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))



/****************************************************************************

		    Multimedia Extensions Window Messages

****************************************************************************/
/* Multimedia messages */                       // ;internal
#define WM_MM_RESERVED_FIRST    0x03A0          // ;internal
#define WM_MM_RESERVED_LAST     0x03DF          // ;internal

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */
/* 0x3BA is open */						// ;internal

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9
#if (WINVER < 0x400)			// ;internal
#define MM_MCISYSTEM_STRING 0x3CA	// ;internal
#endif					// ;internal

/* these are also in msvideo.h */
#ifndef MM_DRVM_OPEN
 #define MM_DRVM_OPEN       0x3D0           /* installable drivers */
 #define MM_DRVM_CLOSE      0x3D1
 #define MM_DRVM_DATA       0x3D2
 #define MM_DRVM_ERROR      0x3D3
#endif

/* these are used by msacm.h */
#define MM_STREAM_OPEN	    0x3D4
#define MM_STREAM_CLOSE	    0x3D5
#define MM_STREAM_DONE	    0x3D6
#define MM_STREAM_ERROR	    0x3D7

#if(WINVER >= 0x0400)
#define MM_MOM_POSITIONCB   0x3CA           /* Callback for MEVT_POSITIONCB */

#ifndef MM_MCISIGNAL
 #define MM_MCISIGNAL        0x3CB
#endif

#define MM_MIM_MOREDATA      0x3CC          /* MIM_DONE w/ pending events */

/* 0x3CF is open */						// ;internal

#endif /* WINVER >= 0x0400 */
#define MM_MIXM_LINE_CHANGE     0x3D0       /* mixer line change notify */
#define MM_MIXM_CONTROL_CHANGE  0x3D1       /* mixer control change notify */

/* 3D8 - 3DF are reserved for Haiku */    // ;internal

/****************************************************************************

		String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256
#define MIXERR_BASE            1024

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

			General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_HANDLEBUSY   (MMSYSERR_BASE + 12) /* handle being used */
						   /* simultaneously on another */
						   /* thread (eg callback) */
#define MMSYSERR_INVALIDALIAS (MMSYSERR_BASE + 13) /* specified alias not found */
#define MMSYSERR_BADDB        (MMSYSERR_BASE + 14) /* bad registry database */
#define MMSYSERR_KEYNOTFOUND  (MMSYSERR_BASE + 15) /* registry key not found */
#define MMSYSERR_READERROR    (MMSYSERR_BASE + 16) /* registry read error */
#define MMSYSERR_WRITEERROR   (MMSYSERR_BASE + 17) /* registry write error */
#define MMSYSERR_DELETEERROR  (MMSYSERR_BASE + 18) /* registry delete error */
#define MMSYSERR_VALNOTFOUND  (MMSYSERR_BASE + 19) /* registry value not found */
#define MMSYSERR_NODRIVERCB   (MMSYSERR_BASE + 20) /* driver does not call DriverCallback */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 20) /* last error in range */

#if (WINVER < 0x030a) || defined(_WIN32)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV


/****************************************************************************

			Installable driver support

****************************************************************************/

#ifdef _WIN32
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;

#else
typedef struct DRVCONFIGINFOEX {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
    DWORD    dnDevNode;
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, NEAR *NPDRVCONFIGINFOEX, FAR *LPDRVCONFIGINFOEX;
#endif

#if (WINVER < 0x030a) || defined(_WIN32)

#ifndef DRV_LOAD

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_POWER               0x000F
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
#ifdef _WIN32
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCWSTR  lpszDCISectionName;
    LPCWSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#else
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO, *PDRVCONFIGINFO, NEAR *NPDRVCONFIGINFO, FAR *LPDRVCONFIGINFO;
#endif

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* installable driver function prototypes */
#ifdef _WIN32
 #ifndef _WIN32_VXD

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

WINMMAPI LRESULT   WINAPI CloseDriver(HDRVR hDriver, LONG lParam1, LONG lParam2);
WINMMAPI HDRVR     WINAPI OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LONG lParam2);
WINMMAPI LRESULT   WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LONG lParam1, LONG lParam2);
WINMMAPI HMODULE   WINAPI DrvGetModuleHandle(HDRVR hDriver);
WINMMAPI HMODULE   WINAPI GetDriverModuleHandle(HDRVR hDriver);
WINMMAPI LRESULT   WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
 #endif /* ifndef _WIN32_VXD */
#else
LRESULT   WINAPI DrvClose(HDRVR hdrvr, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hdrvr);
LRESULT   WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
#define DefDriverProc DrvDefDriverProc
#endif /* ifdef _WIN32 */
#endif /* DRV_LOAD */
#endif /* ifdef (WINVER < 0x030a) || defined(_WIN32) */

#if (WINVER >= 0x030a)
/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

			  Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */
#define CALLBACK_THUNK      0x00040000l    /* dwCallback is a Ring0 Thread Handle */	// ;internal
#ifdef _WIN32
#define CALLBACK_THREAD     (CALLBACK_TASK)/* thread ID replaces 16 bit task */
#define CALLBACK_EVENT      0x00050000l    /* dwCallback is an EVENT Handle */
#endif
#define CALLBACK_EVENT16    0x00060000l    /* dwCallback is an EVENT under Win16*/	// ;internal

#ifndef _WIN32_VXD 

#ifdef  BUILDDLL    // ;internal
typedef void (FAR PASCAL DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);          // ;internal
#else   /* ifdef BUILDDLL */    // ;internal
typedef void (CALLBACK DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */    // ;internal

typedef DRVCALLBACK FAR *LPDRVCALLBACK;
#ifdef _WIN32
typedef DRVCALLBACK     *PDRVCALLBACK;
#endif

#endif   /* ifndef _WIN32_VXD */ 

#ifndef MMNOMMSYSTEM
#ifndef _WIN32_VXD
/****************************************************************************

		    General MMSYSTEM support

****************************************************************************/

#if (WINVER <= 0x030A)
WINMMAPI UINT WINAPI mmsystemGetVersion(void);
#endif
WINMMAPI UINT WINAPI mmsystemGetVersion(void);				// ;internal
#ifdef _WIN32
#define OutputDebugStr  OutputDebugString
#else
void WINAPI OutputDebugStr(LPCSTR);
void FAR CDECL _loadds OutputDebugStrF(LPCSTR pszFormat, ...);		// ;internal
#endif

void WINAPI winmmUntileBuffer(DWORD dwTilingInfo);                      // ;internal
DWORD WINAPI winmmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);       // ;internal
BOOL WINAPI mmShowMMCPLPropertySheet(HWND hWnd, LPSTR szPropSheetID, LPSTR szTabName, LPSTR szCaption); // ;internal
#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMSYSTEM */

#ifndef MMNOSOUND
#ifndef _WIN32_VXD
/****************************************************************************

			    Sound support

****************************************************************************/

#ifdef _WIN32

WINMMAPI BOOL WINAPI sndPlaySoundA(LPCSTR pszSound, UINT fuSound);
WINMMAPI BOOL WINAPI sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);
#ifdef UNICODE
#define sndPlaySound  sndPlaySoundW
#else
#define sndPlaySound  sndPlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI sndPlaySound(LPCSTR pszSound, UINT fuSound);
#endif

/*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* silence (!default) if sound not found */
#define SND_MEMORY          0x0004  /* pszSound points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */

#define SND_NOWAIT	0x00002000L /* don't wait if the driver is busy */
#define SND_ALIAS       0x00010000L /* name is a registry alias */
#define SND_ALIAS_ID	0x00110000L /* alias is a predefined ID */
#define SND_FILENAME    0x00020000L /* name is file name */
#define SND_RESOURCE    0x00040004L /* name is resource name or atom */
#if(WINVER >= 0x0400)
#define SND_PURGE           0x0040  /* purge non-static events for task */
#define SND_APPLICATION     0x0080  /* look for application specific association */
#define	SND_LOPRIORITY	0x10000000L /* low priority sound */ // ;internal
#define	SND_EVENTTIME	0x20000000L /* dangerous event time */ // ;internal
#endif /* WINVER >= 0x0400 */
#define SND_VALIDFLAGS  0x0017201F  // Set of valid flag bits.  Anything outside  // ;internal
                                    // this range will raise an error             // ;internal

#define SND_ALIAS_START	0           /* alias base */

#ifdef _WIN32
#define	sndAlias(ch0, ch1)	(SND_ALIAS_START + (DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8))

#define SND_ALIAS_SYSTEMASTERISK        sndAlias('S', '*')
#define SND_ALIAS_SYSTEMQUESTION        sndAlias('S', '?')
#define SND_ALIAS_SYSTEMHAND            sndAlias('S', 'H')
#define SND_ALIAS_SYSTEMEXIT            sndAlias('S', 'E')
#define SND_ALIAS_SYSTEMSTART           sndAlias('S', 'S')
#define SND_ALIAS_SYSTEMWELCOME         sndAlias('S', 'W')
#define SND_ALIAS_SYSTEMEXCLAMATION     sndAlias('S', '!')
#define SND_ALIAS_SYSTEMDEFAULT         sndAlias('S', 'D')


WINMMAPI BOOL WINAPI PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
WINMMAPI BOOL WINAPI PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
#ifdef UNICODE
#define PlaySound  PlaySoundW
#else
#define PlaySound  PlaySoundA
#endif // !UNICODE

#else
BOOL WINAPI PlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
#endif

#define SND_SNDPLAYSOUNDF_VALID 0x20FF          // ;internal
#define SND_PLAYSOUNDF_VALID    0x301720DFL	// ;internal
#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOSOUND */

#ifndef MMNOWAVE
/****************************************************************************

			Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
#ifndef _WIN32_VXD
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;
#endif

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     ((UINT)-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY         0x0001
#define  WAVE_ALLOWSYNC            0x0002
#if(WINVER >= 0x0400)
#define  WAVE_MAPPED               0x0004
#define  WAVE_FORMAT_DIRECT        0x0008
#define  WAVE_FORMAT_DIRECT_QUERY  (WAVE_FORMAT_QUERY | WAVE_FORMAT_DIRECT)
#ifndef _WIN32							// ;internal
#define  WAVE_SHARED               0x8000			// ;internal
#endif								// ;internal
#endif /* WINVER >= 0x0400 */
#define  WAVE_VALID                0x800F			// ;internal


/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag FAR *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR, *PWAVEHDR, NEAR *NPWAVEHDR, FAR *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */
#define	WHDR_MAPPED	0x00001000  /* thunked header */	// ;internal
#define WHDR_VALID      0x0000101F  /* valid flags */		// ;internal


/* waveform output device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
typedef struct tagWAVEOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    WORD    wReserved1;            /* packing */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;
#ifdef UNICODE
typedef WAVEOUTCAPSW WAVEOUTCAPS;
typedef PWAVEOUTCAPSW PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSW NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSW LPWAVEOUTCAPS;
#else
typedef WAVEOUTCAPSA WAVEOUTCAPS;
typedef PWAVEOUTCAPSA PWAVEOUTCAPS;
typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS;
typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS;
#endif // UNICODE

#else
typedef struct waveoutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS, *PWAVEOUTCAPS, NEAR *NPWAVEOUTCAPS, FAR *LPWAVEOUTCAPS;
#endif

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010
#define WAVECAPS_SAMPLEACCURATE 0x0020
#define WAVECAPS_DIRECTSOUND    0x0040


/* waveform input device capabilities structure */
#ifdef _WIN32

typedef struct tagWAVEINCAPSA {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
typedef struct tagWAVEINCAPSW {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    MMVERSION vDriverVersion;        /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
    WORD    wReserved1;              /* structure packing */
} WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;
#ifdef UNICODE
typedef WAVEINCAPSW WAVEINCAPS;
typedef PWAVEINCAPSW PWAVEINCAPS;
typedef NPWAVEINCAPSW NPWAVEINCAPS;
typedef LPWAVEINCAPSW LPWAVEINCAPS;
#else
typedef WAVEINCAPSA WAVEINCAPS;
typedef PWAVEINCAPSA PWAVEINCAPS;
typedef NPWAVEINCAPSA NPWAVEINCAPS;
typedef LPWAVEINCAPSA LPWAVEINCAPS;
#endif // UNICODE

#else
typedef struct waveincaps_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS, *PWAVEINCAPS, NEAR *NPWAVEINCAPS, FAR *LPWAVEINCAPS;
#endif

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */


/* OLD general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT, *PWAVEFORMAT, NEAR *NPWAVEFORMAT, FAR *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1


/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT, *PPCMWAVEFORMAT, NEAR *NPPCMWAVEFORMAT, FAR *LPPCMWAVEFORMAT;

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_

/*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 */
typedef struct tWAVEFORMATEX
{
    WORD        wFormatTag;         /* format type */
    WORD        nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD       nSamplesPerSec;     /* sample rate */
    DWORD       nAvgBytesPerSec;    /* for buffer estimation */
    WORD        nBlockAlign;        /* block size of data */
    WORD        wBitsPerSample;     /* number of bits per sample of mono data */
    WORD        cbSize;             /* the count in bytes of the size of */
				    /* extra information (after cbSize) */
} WAVEFORMATEX, *PWAVEFORMATEX, NEAR *NPWAVEFORMATEX, FAR *LPWAVEFORMATEX;
typedef const WAVEFORMATEX FAR *LPCWAVEFORMATEX;

#endif /* _WAVEFORMATEX_ */

#ifndef _WIN32_VXD
/* waveform audio function prototypes */
WINMMAPI UINT WINAPI waveOutGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
WINMMAPI MMRESULT WINAPI waveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
#ifdef UNICODE
#define waveOutGetDevCaps  waveOutGetDevCapsW
#else
#define waveOutGetDevCaps  waveOutGetDevCapsA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI waveOutGetDevCaps(UINT uDeviceID, LPWAVEOUTCAPS pwoc, UINT cbwoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveOutGetErrorText  waveOutGetErrorTextW
#else
#define waveOutGetErrorText  waveOutGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveOutClose(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveOutPause(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutRestart(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutReset(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutBreakLoop(HWAVEOUT hwo);
WINMMAPI MMRESULT WINAPI waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);
WINMMAPI MMRESULT WINAPI waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);
WINMMAPI MMRESULT WINAPI waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);
WINMMAPI MMRESULT WINAPI waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);
WINMMAPI MMRESULT WINAPI waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI waveInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetDevCapsA(UINT uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);
WINMMAPI MMRESULT WINAPI waveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);
#ifdef UNICODE
#define waveInGetDevCaps  waveInGetDevCapsW
#else
#define waveInGetDevCaps  waveInGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetDevCaps(UINT uDeviceID, LPWAVEINCAPS pwic, UINT cbwic);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define waveInGetErrorText  waveInGetErrorTextW
#else
#define waveInGetErrorText  waveInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI waveInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI waveInOpen(LPHWAVEIN phwi, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

WINMMAPI MMRESULT WINAPI waveInClose(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);
WINMMAPI MMRESULT WINAPI waveInStart(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInStop(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInReset(HWAVEIN hwi);
WINMMAPI MMRESULT WINAPI waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);
WINMMAPI MMRESULT WINAPI waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

			    MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no configured instruments */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid MIF */
#define MIDIERR_BADOPENMODE   (MIDIERR_BASE + 6)   /* operation unsupported w/ open mode */
#define MIDIERR_DONT_CONTINUE (MIDIERR_BASE + 7)   /* thru device 'eating' a message */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 7)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
DECLARE_HANDLE(HMIDISTRM);
#ifndef _WIN32_VXD
typedef HMIDI FAR *LPHMIDI;
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef HMIDISTRM FAR *LPHMIDISTRM;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;
#endif  /* ifndef _WIN32_VXD */

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

#if(WINVER >= 0x0400)
#define MIM_MOREDATA      MM_MIM_MOREDATA
#define MOM_POSITIONCB    MM_MOM_POSITIONCB
#endif /* WINVER >= 0x0400 */

/* device ID for MIDI mapper */
#define MIDIMAPPER     ((UINT)-1)
#define MIDI_MAPPER    ((UINT)-1)

#if(WINVER >= 0x0400)
/* flags for dwFlags parm of midiInOpen() */
#define MIDI_IO_CONTROL     0x00000008L                         // ;internal
#define MIDI_IO_INPUT       0x00000010L  /*future*/             // ;internal
#define MIDI_IO_STATUS      0x00000020L
#define MIDI_IO_OWNED       0x00004000L                         // ;internal
#define MIDI_IO_SHARED      0x00008000L                         // ;internal
#define MIDI_I_VALID        0xC027                              // ;internal
#define MIDI_O_VALID        0xC00E				// ;internal
#endif /* WINVER >= 0x0400 */

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */
#define MIDI_CACHE_ALL      1
#define MIDI_CACHE_BESTFIT  2
#define MIDI_CACHE_QUERY    3
#define MIDI_UNCACHE        4
#define MIDI_CACHE_VALID    (MIDI_CACHE_ALL | MIDI_CACHE_BESTFIT | MIDI_CACHE_QUERY | MIDI_UNCACHE)     // ;internal


/* MIDI output device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIOUTCAPSA {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    CHAR    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
typedef struct tagMIDIOUTCAPSW {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    MMVERSION vDriverVersion;      /* version of the driver */
    WCHAR   szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;
#ifdef UNICODE
typedef MIDIOUTCAPSW MIDIOUTCAPS;
typedef PMIDIOUTCAPSW PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSW NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSW LPMIDIOUTCAPS;
#else
typedef MIDIOUTCAPSA MIDIOUTCAPS;
typedef PMIDIOUTCAPSA PMIDIOUTCAPS;
typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS;
typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS;
#endif // UNICODE

#else
typedef struct midioutcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS, *PMIDIOUTCAPS, NEAR *NPMIDIOUTCAPS, FAR *LPMIDIOUTCAPS;
#endif

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004
#if(WINVER >= 0x0400)
#define MIDICAPS_STREAM          0x0008  /* driver supports midiStreamOut directly */
#endif /* WINVER >= 0x0400 */


/* MIDI input device capabilities structure */
#ifdef _WIN32

typedef struct tagMIDIINCAPSA {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
typedef struct tagMIDIINCAPSW {
    WORD        wMid;                   /* manufacturer ID */
    WORD        wPid;                   /* product ID */
    MMVERSION   vDriverVersion;         /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];   /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;
#ifdef UNICODE
typedef MIDIINCAPSW MIDIINCAPS;
typedef PMIDIINCAPSW PMIDIINCAPS;
typedef NPMIDIINCAPSW NPMIDIINCAPS;
typedef LPMIDIINCAPSW LPMIDIINCAPS;
#else
typedef MIDIINCAPSA MIDIINCAPS;
typedef PMIDIINCAPSA PMIDIINCAPS;
typedef NPMIDIINCAPSA NPMIDIINCAPS;
typedef LPMIDIINCAPSA LPMIDIINCAPS;
#endif // UNICODE

#else
typedef struct midiincaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS, *PMIDIINCAPS, NEAR *NPMIDIINCAPS, FAR *LPMIDIINCAPS;
#endif


/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag FAR *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
#if (WINVER >= 0x0400)
    DWORD       dwOffset;             /* Callback offset into buffer */
    DWORD       dwReserved[8];        /* Reserved for MMSYSTEM */
#endif
} MIDIHDR, *PMIDIHDR, NEAR *NPMIDIHDR, FAR *LPMIDIHDR;

/* 3.1 style MIDIHDR for parameter validation */	// ;internal
typedef struct midihdr31_tag {	// ;internal
    LPSTR       lpData;               /* pointer to locked data block */	// ;internal
    DWORD       dwBufferLength;       /* length of data in data block */	// ;internal
    DWORD       dwBytesRecorded;      /* used for input only */	// ;internal
    DWORD       dwUser;               /* for client's use */	// ;internal
    DWORD       dwFlags;              /* assorted flags (see defines) */	// ;internal
    struct midihdr_tag FAR *lpNext;   /* reserved for driver */	// ;internal
    DWORD       reserved;             /* reserved for driver */	// ;internal
} MIDIHDR31, *PMIDIHDR31, NEAR *NPMIDIHDR31, FAR *LPMIDIHDR31;	// ;internal

#if(WINVER >= 0x0400)
typedef struct midievent_tag
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
    DWORD       dwParms[1];           /* Parameters if this is a long event */
} MIDIEVENT;

typedef struct midistrmbuffver_tag
{
    DWORD       dwVersion;                  /* Stream buffer format version */
    DWORD       dwMid;                      /* Manufacturer ID as defined in MMREG.H */
    DWORD       dwOEMVersion;               /* Manufacturer version for custom ext */
} MIDISTRMBUFFVER;
#endif /* WINVER >= 0x0400 */

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */
#define MHDR_ISSTRM     0x00000008       /* Buffer is stream buffer */
#define MHDR_SENDING    0x00000020       // ;internal
#define	MHDR_MAPPED	0x00001000       /* thunked header */	// ;internal
#define MHDR_SHADOWHDR  0x00002000       /* MIDIHDR is 16-bit shadow */ // ;internal
#define MHDR_VALID      0x0000302F       /* valid flags */	// ;internal
/*#define MHDR_VALID      0xFFFF000F       /* valid flags */	// ;internal */

#define MHDR_SAVE       0x00003000       /* Save these flags */  // ;internal
                                         /* past driver calls */ // ;internal
#if(WINVER >= 0x0400)
/* */
/* Type codes which go in the high byte of the event DWORD of a stream buffer */
/* */
/* Type codes 00-7F contain parameters within the low 24 bits */
/* Type codes 80-FF contain a length of their parameter in the low 24 */
/* bits, followed by their parameter data in the buffer. The event */
/* DWORD contains the exact byte length; the parm data itself must be */
/* padded to be an even multiple of 4 bytes long. */
/* */

#define MEVT_F_SHORT        0x00000000L
#define MEVT_F_LONG         0x80000000L
#define MEVT_F_CALLBACK     0x40000000L

#define MEVT_EVENTTYPE(x)   ((BYTE)(((x)>>24)&0xFF))
#define MEVT_EVENTPARM(x)   ((DWORD)((x)&0x00FFFFFFL))

#define MEVT_SHORTMSG       ((BYTE)0x00)    /* parm = shortmsg for midiOutShortMsg */
#define MEVT_TEMPO          ((BYTE)0x01)    /* parm = new tempo in microsec/qn     */
#define MEVT_NOP            ((BYTE)0x02)    /* parm = unused; does nothing         */

/* 0x04-0x7F reserved */

#define MEVT_LONGMSG        ((BYTE)0x80)    /* parm = bytes to send verbatim       */
#define MEVT_COMMENT        ((BYTE)0x82)    /* parm = comment data                 */
#define MEVT_VERSION        ((BYTE)0x84)    /* parm = MIDISTRMBUFFVER struct       */

/* 0x81-0xFF reserved */

#define MIDISTRM_ERROR      (-2)

/* */
/* Structures and defines for midiStreamProperty */
/* */
#define MIDIPROP_SET        0x80000000L
#define MIDIPROP_GET        0x40000000L
#define MIDIPROP_PROPVAL    0x3FFFFFFFL // ;internal

/* These are intentionally both non-zero so the app cannot accidentally */
/* leave the operation off and happen to appear to work due to default */
/* action. */

#define MIDIPROP_TIMEDIV    0x00000001L
#define MIDIPROP_TEMPO      0x00000002L

typedef struct midiproptimediv_tag
{
    DWORD       cbStruct;
    DWORD       dwTimeDiv;
} MIDIPROPTIMEDIV, FAR *LPMIDIPROPTIMEDIV;

typedef struct midiproptempo_tag
{
    DWORD       cbStruct;
    DWORD       dwTempo;
} MIDIPROPTEMPO, FAR *LPMIDIPROPTEMPO;

#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* MIDI function prototypes */
WINMMAPI UINT WINAPI midiOutGetNumDevs(void);
#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiStreamClose(HMIDISTRM hms);

WINMMAPI MMRESULT WINAPI midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty);
WINMMAPI MMRESULT WINAPI midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt);

WINMMAPI MMRESULT WINAPI midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiStreamPause(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamRestart(HMIDISTRM hms);
WINMMAPI MMRESULT WINAPI midiStreamStop(HMIDISTRM hms);

#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
WINMMAPI MMRESULT WINAPI midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);
#endif
#endif /* WINVER >= 0x0400 */

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetDevCapsA(UINT uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
WINMMAPI MMRESULT WINAPI midiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);
#ifdef UNICODE
#define midiOutGetDevCaps  midiOutGetDevCapsW
#else
#define midiOutGetDevCaps  midiOutGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI midiOutGetDevCaps(UINT uDeviceID, LPMIDIOUTCAPS pmoc, UINT cbmoc);
#endif

#if (WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
#else
WINMMAPI MMRESULT WINAPI midiOutGetVolume(UINT uId, LPDWORD pdwVolume);
WINMMAPI MMRESULT WINAPI midiOutSetVolume(UINT uId, DWORD dwVolume);
#endif

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiOutGetErrorText  midiOutGetErrorTextW
#else
#define midiOutGetErrorText  midiOutGetErrorTextA
#endif // !UNICODE

#else
WINMMAPI MMRESULT WINAPI midiOutGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiOutClose(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);
WINMMAPI MMRESULT WINAPI midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiOutReset(HMIDIOUT hmo);
WINMMAPI MMRESULT WINAPI midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);
WINMMAPI MMRESULT WINAPI midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

WINMMAPI UINT WINAPI midiInGetNumDevs(void);

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI midiInGetDevCapsA(UINT uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);
#ifdef UNICODE
#define midiInGetDevCaps  midiInGetDevCapsW
#else
#define midiInGetDevCaps  midiInGetDevCapsA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);
WINMMAPI MMRESULT WINAPI midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define midiInGetErrorText  midiInGetErrorTextW
#else
#define midiInGetErrorText  midiInGetErrorTextA
#endif // !UNICODE

#else
MMRESULT WINAPI midiInGetDevCaps(UINT uDeviceID, LPMIDIINCAPS pmic, UINT cbmic);
WINMMAPI MMRESULT WINAPI midiInGetErrorText(MMRESULT mmrError, LPSTR pszText, UINT cchText);
#endif

WINMMAPI MMRESULT WINAPI midiInOpen(LPHMIDIIN phmi, UINT uDeviceID,
	DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
WINMMAPI MMRESULT WINAPI midiInClose(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);
WINMMAPI MMRESULT WINAPI midiInStart(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInStop(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInReset(HMIDIIN hmi);
WINMMAPI MMRESULT WINAPI midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

			Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     ((UINT)-1)


/* Auxiliary audio device capabilities structure */
#ifdef _WIN32

typedef struct tagAUXCAPSA {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    CHAR        szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
typedef struct tagAUXCAPSW {
    WORD        wMid;                /* manufacturer ID */
    WORD        wPid;                /* product ID */
    MMVERSION   vDriverVersion;      /* version of the driver */
    WCHAR       szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    WORD        wTechnology;         /* type of device */
    WORD        wReserved1;          /* padding */
    DWORD       dwSupport;           /* functionality supported by driver */
} AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;
#ifdef UNICODE
typedef AUXCAPSW AUXCAPS;
typedef PAUXCAPSW PAUXCAPS;
typedef NPAUXCAPSW NPAUXCAPS;
typedef LPAUXCAPSW LPAUXCAPS;
#else
typedef AUXCAPSA AUXCAPS;
typedef PAUXCAPSA PAUXCAPS;
typedef NPAUXCAPSA NPAUXCAPS;
typedef LPAUXCAPSA LPAUXCAPS;
#endif // UNICODE

#else
typedef struct auxcaps_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS, *PAUXCAPS, NEAR *NPAUXCAPS, FAR *LPAUXCAPS;
#endif

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

#ifndef _WIN32_VXD

/* auxiliary audio function prototypes */
WINMMAPI UINT WINAPI auxGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac);
WINMMAPI MMRESULT WINAPI auxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);
#ifdef UNICODE
#define auxGetDevCaps  auxGetDevCapsW
#else
#define auxGetDevCaps  auxGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI auxGetDevCaps(UINT uDeviceID, LPAUXCAPS pac, UINT cbac);
#endif
WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

#if (WINVER >= 0x030a)
#ifdef _WIN32
WINMMAPI MMRESULT WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#else
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD dw1, DWORD dw2);
#endif
#endif /* ifdef WINVER >= 0x030a */

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOAUX */


#ifndef MMNOMIXER
#ifndef _WIN32_VXD
/****************************************************************************

			    Mixer Support

****************************************************************************/

DECLARE_HANDLE(HMIXEROBJ);
typedef HMIXEROBJ FAR *LPHMIXEROBJ;

DECLARE_HANDLE(HMIXER);
typedef HMIXER     FAR *LPHMIXER;

#define MIXER_SHORT_NAME_CHARS   16
#define MIXER_LONG_NAME_CHARS    64

/* */
/*  MMRESULT error return values specific to the mixer API */
/* */
/* */
#define MIXERR_INVALLINE            (MIXERR_BASE + 0)
#define MIXERR_INVALCONTROL         (MIXERR_BASE + 1)
#define MIXERR_INVALVALUE           (MIXERR_BASE + 2)
#define MIXERR_LASTERROR            (MIXERR_BASE + 2)


#define MIXER_OBJECTF_HANDLE    0x80000000L
#define MIXER_OBJECTF_MIXER     0x00000000L
#define MIXER_OBJECTF_HMIXER    (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIXER)
#define MIXER_OBJECTF_WAVEOUT   0x10000000L
#define MIXER_OBJECTF_HWAVEOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEOUT)
#define MIXER_OBJECTF_WAVEIN    0x20000000L
#define MIXER_OBJECTF_HWAVEIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_WAVEIN)
#define MIXER_OBJECTF_MIDIOUT   0x30000000L
#define MIXER_OBJECTF_HMIDIOUT  (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIOUT)
#define MIXER_OBJECTF_MIDIIN    0x40000000L
#define MIXER_OBJECTF_HMIDIIN   (MIXER_OBJECTF_HANDLE|MIXER_OBJECTF_MIDIIN)
#define MIXER_OBJECTF_AUX       0x50000000L

#define MIXER_OBJECTF_TYPEMASK  0xF0000000L     // ;internal

WINMMAPI UINT WINAPI mixerGetNumDevs(void);

#ifdef _WIN32

typedef struct tagMIXERCAPSA {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    CHAR            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
typedef struct tagMIXERCAPSW {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    MMVERSION       vDriverVersion;         /* version of the driver */
    WCHAR           szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;
#ifdef UNICODE
typedef MIXERCAPSW MIXERCAPS;
typedef PMIXERCAPSW PMIXERCAPS;
typedef LPMIXERCAPSW LPMIXERCAPS;
#else
typedef MIXERCAPSA MIXERCAPS;
typedef PMIXERCAPSA PMIXERCAPS;
typedef LPMIXERCAPSA LPMIXERCAPS;
#endif // UNICODE

#else
typedef struct tMIXERCAPS {
    WORD            wMid;                   /* manufacturer id */
    WORD            wPid;                   /* product id */
    VERSION         vDriverVersion;         /* version of the driver */
    char            szPname[MAXPNAMELEN];   /* product name */
    DWORD           fdwSupport;             /* misc. support bits */
    DWORD           cDestinations;          /* count of destinations */
} MIXERCAPS, *PMIXERCAPS, FAR *LPMIXERCAPS;
#endif

#define MIXERCAPS_SUPPORTF_xxx          0x00000000L     // ;internal



#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetDevCapsA(UINT uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);
WINMMAPI MMRESULT WINAPI mixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);
#ifdef UNICODE
#define mixerGetDevCaps  mixerGetDevCapsW
#else
#define mixerGetDevCaps  mixerGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetDevCaps(UINT uMxId, LPMIXERCAPS pmxcaps, UINT cbmxcaps);
#endif

WINMMAPI MMRESULT WINAPI mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);

#define MIXER_OPENF_VALID       (MIXER_OBJECTF_TYPEMASK | CALLBACK_TYPEMASK)  // ;internal

WINMMAPI MMRESULT WINAPI mixerClose(HMIXER hmx);

WINMMAPI DWORD WINAPI mixerMessage(HMIXER hmx, UINT uMsg, DWORD dwParam1, DWORD dwParam2);


#ifdef _WIN32

typedef struct tagMIXERLINEA {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	CHAR    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
typedef struct tagMIXERLINEW {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	MMVERSION vDriverVersion;       /*      " */
	WCHAR   szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;
#ifdef UNICODE
typedef MIXERLINEW MIXERLINE;
typedef PMIXERLINEW PMIXERLINE;
typedef LPMIXERLINEW LPMIXERLINE;
#else
typedef MIXERLINEA MIXERLINE;
typedef PMIXERLINEA PMIXERLINE;
typedef LPMIXERLINEA LPMIXERLINE;
#endif // UNICODE

#else
typedef struct tMIXERLINE {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    char        szShortName[MIXER_SHORT_NAME_CHARS];
    char        szName[MIXER_LONG_NAME_CHARS];
    struct {
	DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
	DWORD   dwDeviceID;             /* target device ID of device type */
	WORD    wMid;                   /* of target device */
	WORD    wPid;                   /*      " */
	VERSION vDriverVersion;         /*      " */
	char    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINE, *PMIXERLINE, FAR *LPMIXERLINE;
#endif

/* */
/*  MIXERLINE.fdwLine */
/* */
/* */
#define MIXERLINE_LINEF_ACTIVE              0x00000001L
#define MIXERLINE_LINEF_DISCONNECTED        0x00008000L
#define MIXERLINE_LINEF_SOURCE              0x80000000L


/* */
/*  MIXERLINE.dwComponentType */
/* */
/*  component types for destinations and sources */
/* */
/* */
#define MIXERLINE_COMPONENTTYPE_DST_FIRST       0x00000000L
#define MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_DST_DIGITAL     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_DST_LINE        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_DST_MONITOR     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    (MIXERLINE_COMPONENTTYPE_DST_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  (MIXERLINE_COMPONENTTYPE_DST_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   (MIXERLINE_COMPONENTTYPE_DST_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_DST_WAVEIN      (MIXERLINE_COMPONENTTYPE_DST_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_DST_VOICEIN     (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_DST_LAST        (MIXERLINE_COMPONENTTYPE_DST_FIRST + 8)

#define MIXERLINE_COMPONENTTYPE_SRC_FIRST       0x00001000L
#define MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 0)
#define MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 1)
#define MIXERLINE_COMPONENTTYPE_SRC_LINE        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 2)
#define MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 3)
#define MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 4)
#define MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 5)
#define MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 6)
#define MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 7)
#define MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 8)
#define MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 9)
#define MIXERLINE_COMPONENTTYPE_SRC_ANALOG      (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)
#define MIXERLINE_COMPONENTTYPE_SRC_LAST        (MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10)


/* */
/*  MIXERLINE.Target.dwType */
/* */
/* */
#define MIXERLINE_TARGETTYPE_UNDEFINED      0
#define MIXERLINE_TARGETTYPE_WAVEOUT        1
#define MIXERLINE_TARGETTYPE_WAVEIN         2
#define MIXERLINE_TARGETTYPE_MIDIOUT        3
#define MIXERLINE_TARGETTYPE_MIDIIN         4
#define MIXERLINE_TARGETTYPE_AUX            5

#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);
WINMMAPI MMRESULT WINAPI mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);
#ifdef UNICODE
#define mixerGetLineInfo  mixerGetLineInfoW
#else
#define mixerGetLineInfo  mixerGetLineInfoA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineInfo(HMIXEROBJ hmxobj, LPMIXERLINE pmxl, DWORD fdwInfo);
#endif


#define MIXER_GETLINEINFOF_DESTINATION      0x00000000L
#define MIXER_GETLINEINFOF_SOURCE           0x00000001L
#define MIXER_GETLINEINFOF_LINEID           0x00000002L
#define MIXER_GETLINEINFOF_COMPONENTTYPE    0x00000003L
#define MIXER_GETLINEINFOF_TARGETTYPE       0x00000004L

#define MIXER_GETLINEINFOF_QUERYMASK        0x0000000FL

#define MIXER_GETLINEINFOF_VALID            (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINEINFOF_QUERYMASK)    // ;internal


WINMMAPI MMRESULT WINAPI mixerGetID(HMIXEROBJ hmxobj, UINT FAR *puMxId, DWORD fdwId);

#define MIXER_GETIDF_VALID      (MIXER_OBJECTF_TYPEMASK)    // ;internal


/* */
/*  MIXERCONTROL */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLA {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
typedef struct tagMIXERCONTROLW {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    WCHAR           szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;
#ifdef UNICODE
typedef MIXERCONTROLW MIXERCONTROL;
typedef PMIXERCONTROLW PMIXERCONTROL;
typedef LPMIXERCONTROLW LPMIXERCONTROL;
#else
typedef MIXERCONTROLA MIXERCONTROL;
typedef PMIXERCONTROLA PMIXERCONTROL;
typedef LPMIXERCONTROLA LPMIXERCONTROL;
#endif // UNICODE

#else
typedef struct tMIXERCONTROL {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    char            szShortName[MIXER_SHORT_NAME_CHARS];
    char            szName[MIXER_LONG_NAME_CHARS];
    union {
	struct {
	    LONG    lMinimum;           /* signed minimum for this control */
	    LONG    lMaximum;           /* signed maximum for this control */
	};
	struct {
	    DWORD   dwMinimum;          /* unsigned minimum for this control */
	    DWORD   dwMaximum;          /* unsigned maximum for this control */
	};
	DWORD       dwReserved[6];
    } Bounds;
    union {
	DWORD       cSteps;             /* # of steps between min & max */
	DWORD       cbCustomData;       /* size in bytes of custom data */
	DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROL, *PMIXERCONTROL, FAR *LPMIXERCONTROL;
#endif

/* */
/*  MIXERCONTROL.fdwControl */
/* */
/* */
#define MIXERCONTROL_CONTROLF_UNIFORM   0x00000001L
#define MIXERCONTROL_CONTROLF_MULTIPLE  0x00000002L
#define MIXERCONTROL_CONTROLF_DISABLED  0x80000000L

#define MIXERCONTROL_CONTROLF_VALID     0x80000003L  // ;internal



/* */
/*  MIXERCONTROL_CONTROLTYPE_xxx building block defines */
/* */
/* */
#define MIXERCONTROL_CT_CLASS_MASK          0xF0000000L
#define MIXERCONTROL_CT_CLASS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_CLASS_METER         0x10000000L
#define MIXERCONTROL_CT_CLASS_SWITCH        0x20000000L
#define MIXERCONTROL_CT_CLASS_NUMBER        0x30000000L
#define MIXERCONTROL_CT_CLASS_SLIDER        0x40000000L
#define MIXERCONTROL_CT_CLASS_FADER         0x50000000L
#define MIXERCONTROL_CT_CLASS_TIME          0x60000000L
#define MIXERCONTROL_CT_CLASS_LIST          0x70000000L


#define MIXERCONTROL_CT_SUBCLASS_MASK       0x0F000000L

#define MIXERCONTROL_CT_SC_SWITCH_BOOLEAN   0x00000000L
#define MIXERCONTROL_CT_SC_SWITCH_BUTTON    0x01000000L

#define MIXERCONTROL_CT_SC_METER_POLLED     0x00000000L

#define MIXERCONTROL_CT_SC_TIME_MICROSECS   0x00000000L
#define MIXERCONTROL_CT_SC_TIME_MILLISECS   0x01000000L

#define MIXERCONTROL_CT_SC_LIST_SINGLE      0x00000000L
#define MIXERCONTROL_CT_SC_LIST_MULTIPLE    0x01000000L


#define MIXERCONTROL_CT_UNITS_MASK          0x00FF0000L
#define MIXERCONTROL_CT_UNITS_CUSTOM        0x00000000L
#define MIXERCONTROL_CT_UNITS_BOOLEAN       0x00010000L
#define MIXERCONTROL_CT_UNITS_SIGNED        0x00020000L
#define MIXERCONTROL_CT_UNITS_UNSIGNED      0x00030000L
#define MIXERCONTROL_CT_UNITS_DECIBELS      0x00040000L /* in 10ths */
#define MIXERCONTROL_CT_UNITS_PERCENT       0x00050000L /* in 10ths */


/* */
/*  Commonly used control types for specifying MIXERCONTROL.dwControlType */
/* */

#define MIXERCONTROL_CONTROLTYPE_CUSTOM         (MIXERCONTROL_CT_CLASS_CUSTOM | MIXERCONTROL_CT_UNITS_CUSTOM)
#define MIXERCONTROL_CONTROLTYPE_BOOLEANMETER   (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_SIGNEDMETER    (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PEAKMETER      (MIXERCONTROL_CONTROLTYPE_SIGNEDMETER + 1)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER  (MIXERCONTROL_CT_CLASS_METER | MIXERCONTROL_CT_SC_METER_POLLED | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_BOOLEAN        (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BOOLEAN | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_ONOFF          (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 1)
#define MIXERCONTROL_CONTROLTYPE_MUTE           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 2)
#define MIXERCONTROL_CONTROLTYPE_MONO           (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 3)
#define MIXERCONTROL_CONTROLTYPE_LOUDNESS       (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 4)
#define MIXERCONTROL_CONTROLTYPE_STEREOENH      (MIXERCONTROL_CONTROLTYPE_BOOLEAN + 5)
#define MIXERCONTROL_CONTROLTYPE_BUTTON         (MIXERCONTROL_CT_CLASS_SWITCH | MIXERCONTROL_CT_SC_SWITCH_BUTTON | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_DECIBELS       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_DECIBELS)
#define MIXERCONTROL_CONTROLTYPE_SIGNED         (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_UNSIGNED       (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_PERCENT        (MIXERCONTROL_CT_CLASS_NUMBER | MIXERCONTROL_CT_UNITS_PERCENT)
#define MIXERCONTROL_CONTROLTYPE_SLIDER         (MIXERCONTROL_CT_CLASS_SLIDER | MIXERCONTROL_CT_UNITS_SIGNED)
#define MIXERCONTROL_CONTROLTYPE_PAN            (MIXERCONTROL_CONTROLTYPE_SLIDER + 1)
#define MIXERCONTROL_CONTROLTYPE_QSOUNDPAN      (MIXERCONTROL_CONTROLTYPE_SLIDER + 2)
#define MIXERCONTROL_CONTROLTYPE_FADER          (MIXERCONTROL_CT_CLASS_FADER | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_VOLUME         (MIXERCONTROL_CONTROLTYPE_FADER + 1)
#define MIXERCONTROL_CONTROLTYPE_BASS           (MIXERCONTROL_CONTROLTYPE_FADER + 2)
#define MIXERCONTROL_CONTROLTYPE_TREBLE         (MIXERCONTROL_CONTROLTYPE_FADER + 3)
#define MIXERCONTROL_CONTROLTYPE_EQUALIZER      (MIXERCONTROL_CONTROLTYPE_FADER + 4)
#define MIXERCONTROL_CONTROLTYPE_SINGLESELECT   (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_SINGLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MUX            (MIXERCONTROL_CONTROLTYPE_SINGLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT (MIXERCONTROL_CT_CLASS_LIST | MIXERCONTROL_CT_SC_LIST_MULTIPLE | MIXERCONTROL_CT_UNITS_BOOLEAN)
#define MIXERCONTROL_CONTROLTYPE_MIXER          (MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT + 1)
#define MIXERCONTROL_CONTROLTYPE_MICROTIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MICROSECS | MIXERCONTROL_CT_UNITS_UNSIGNED)
#define MIXERCONTROL_CONTROLTYPE_MILLITIME      (MIXERCONTROL_CT_CLASS_TIME | MIXERCONTROL_CT_SC_TIME_MILLISECS | MIXERCONTROL_CT_UNITS_UNSIGNED)

/* */
/*  MIXERLINECONTROLS */
/* */
#ifdef _WIN32

typedef struct tagMIXERLINECONTROLSA {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLA pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
typedef struct tagMIXERLINECONTROLSW {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROLW pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;
#ifdef UNICODE
typedef MIXERLINECONTROLSW MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSW PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSW LPMIXERLINECONTROLS;
#else
typedef MIXERLINECONTROLSA MIXERLINECONTROLS;
typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS;
typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS;
#endif // UNICODE

#else
typedef struct tMIXERLINECONTROLS {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
	DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
	DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROL  pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLS, *PMIXERLINECONTROLS, FAR *LPMIXERLINECONTROLS;
#endif


/* */
/* */
/* */
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);
WINMMAPI MMRESULT WINAPI mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);
#ifdef UNICODE
#define mixerGetLineControls  mixerGetLineControlsW
#else
#define mixerGetLineControls  mixerGetLineControlsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetLineControls(HMIXEROBJ hmxobj, LPMIXERLINECONTROLS pmxlc, DWORD fdwControls);
#endif


#define MIXER_GETLINECONTROLSF_ALL          0x00000000L
#define MIXER_GETLINECONTROLSF_ONEBYID      0x00000001L
#define MIXER_GETLINECONTROLSF_ONEBYTYPE    0x00000002L

#define MIXER_GETLINECONTROLSF_QUERYMASK    0x0000000FL

#define MIXER_GETLINECONTROLSF_VALID    (MIXER_OBJECTF_TYPEMASK | MIXER_GETLINECONTROLSF_QUERYMASK)  // ;internal


typedef struct tMIXERCONTROLDETAILS {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */
    DWORD           dwControlID;    /* control id to get/set details on */
    DWORD           cChannels;      /* number of channels in paDetails array */
    union {
	HWND        hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */
	DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */
    LPVOID          paDetails;      /* pointer to array of details_XX structs */
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, FAR *LPMIXERCONTROLDETAILS;


/* */
/*  MIXER_GETCONTROLDETAILSF_LISTTEXT */
/* */
/* */
#ifdef _WIN32

typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW {
    DWORD           dwParam1;
    DWORD           dwParam2;
    WCHAR           szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;
#ifdef UNICODE
typedef MIXERCONTROLDETAILS_LISTTEXTW MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTW PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTW LPMIXERCONTROLDETAILS_LISTTEXT;
#else
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT;
typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT;
typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT;
#endif // UNICODE

#else
typedef struct tMIXERCONTROLDETAILS_LISTTEXT {
    DWORD           dwParam1;
    DWORD           dwParam2;
    char            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, FAR *LPMIXERCONTROLDETAILS_LISTTEXT;
#endif

/* */
/*  MIXER_GETCONTROLDETAILSF_VALUE */
/* */
/* */
typedef struct tMIXERCONTROLDETAILS_BOOLEAN {
    LONG            fValue;
}       MIXERCONTROLDETAILS_BOOLEAN,
      *PMIXERCONTROLDETAILS_BOOLEAN,
 FAR *LPMIXERCONTROLDETAILS_BOOLEAN;

typedef struct tMIXERCONTROLDETAILS_SIGNED {
    LONG            lValue;
}       MIXERCONTROLDETAILS_SIGNED,
      *PMIXERCONTROLDETAILS_SIGNED,
 FAR *LPMIXERCONTROLDETAILS_SIGNED;


typedef struct tMIXERCONTROLDETAILS_UNSIGNED {
    DWORD           dwValue;
}       MIXERCONTROLDETAILS_UNSIGNED,
      *PMIXERCONTROLDETAILS_UNSIGNED,
 FAR *LPMIXERCONTROLDETAILS_UNSIGNED;


#ifdef _WIN32

WINMMAPI MMRESULT WINAPI mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
WINMMAPI MMRESULT WINAPI mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#ifdef UNICODE
#define mixerGetControlDetails  mixerGetControlDetailsW
#else
#define mixerGetControlDetails  mixerGetControlDetailsA
#endif // !UNICODE

#else
MMRESULT WINAPI mixerGetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);
#endif

#define MIXER_GETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_GETCONTROLDETAILSF_LISTTEXT   0x00000001L

#define MIXER_GETCONTROLDETAILSF_QUERYMASK  0x0000000FL

#define MIXER_GETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_GETCONTROLDETAILSF_QUERYMASK) // ;internal


WINMMAPI MMRESULT WINAPI mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

#define MIXER_SETCONTROLDETAILSF_VALUE      0x00000000L
#define MIXER_SETCONTROLDETAILSF_CUSTOM     0x00000001L

#define MIXER_SETCONTROLDETAILSF_QUERYMASK  0x0000000FL

#define MIXER_SETCONTROLDETAILSF_VALID      (MIXER_OBJECTF_TYPEMASK | MIXER_SETCONTROLDETAILSF_QUERYMASK) // ;internal

#endif /* ifndef _WIN32_VXD */
#endif /* ifndef MMNOMIXER */


#ifndef MMNOTIMER
#ifndef _WIN32_VXD
/****************************************************************************

			    Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
#ifdef  BUILDDLL                                   // ;internal
typedef void (FAR PASCAL TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);           // ;internal
#else   /* ifdef BUILDDLL */                       // ;internal
typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
#endif  /* ifdef BUILDDLL */                       // ;internal

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for fuEvent parameter of timeSetEvent() function */
#define TIME_ONESHOT    0x0000   /* program timer for single event */
#define TIME_PERIODIC   0x0001   /* program for continuous periodic event */

#ifdef _WIN32
#define TIME_CALLBACK_FUNCTION      0x0000  /* callback is function */
#define TIME_CALLBACK_EVENT_SET     0x0010  /* callback is event - use SetEvent */
#define TIME_CALLBACK_EVENT_PULSE   0x0020  /* callback is event - use PulseEvent */
#define TIME_CALLBACK_TYPEMASK      0x00F0  // ;internal
#endif


/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
} TIMECAPS, *PTIMECAPS, NEAR *NPTIMECAPS, FAR *LPTIMECAPS;

/* timer function prototypes */
WINMMAPI MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
WINMMAPI DWORD WINAPI timeGetTime(void);
WINMMAPI MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
WINMMAPI MMRESULT WINAPI timeKillEvent(UINT uTimerID);
WINMMAPI MMRESULT WINAPI timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);
WINMMAPI MMRESULT WINAPI timeBeginPeriod(UINT uPeriod);
WINMMAPI MMRESULT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

			    Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* constants used with JOYINFOEX */
#define JOY_BUTTON5         0x00000010l
#define JOY_BUTTON6         0x00000020l
#define JOY_BUTTON7         0x00000040l
#define JOY_BUTTON8         0x00000080l
#define JOY_BUTTON9         0x00000100l
#define JOY_BUTTON10        0x00000200l
#define JOY_BUTTON11        0x00000400l
#define JOY_BUTTON12        0x00000800l
#define JOY_BUTTON13        0x00001000l
#define JOY_BUTTON14        0x00002000l
#define JOY_BUTTON15        0x00004000l
#define JOY_BUTTON16        0x00008000l
#define JOY_BUTTON17        0x00010000l
#define JOY_BUTTON18        0x00020000l
#define JOY_BUTTON19        0x00040000l
#define JOY_BUTTON20        0x00080000l
#define JOY_BUTTON21        0x00100000l
#define JOY_BUTTON22        0x00200000l
#define JOY_BUTTON23        0x00400000l
#define JOY_BUTTON24        0x00800000l
#define JOY_BUTTON25        0x01000000l
#define JOY_BUTTON26        0x02000000l
#define JOY_BUTTON27        0x04000000l
#define JOY_BUTTON28        0x08000000l
#define JOY_BUTTON29        0x10000000l
#define JOY_BUTTON30        0x20000000l
#define JOY_BUTTON31        0x40000000l
#define JOY_BUTTON32        0x80000000l

/* constants used with JOYINFOEX structure */
#define JOY_POVCENTERED		(WORD) -1
#define JOY_POVFORWARD		0
#define JOY_POVRIGHT		9000
#define JOY_POVBACKWARD		18000
#define JOY_POVLEFT		27000

#define JOY_RETURNX		0x00000001l
#define JOY_RETURNY		0x00000002l
#define JOY_RETURNZ		0x00000004l
#define JOY_RETURNR		0x00000008l
#define JOY_RETURNU		0x00000010l	/* axis 5 */
#define JOY_RETURNV		0x00000020l	/* axis 6 */
#define JOY_RETURNPOV		0x00000040l
#define JOY_RETURNBUTTONS	0x00000080l
#define JOY_RETURNRAWDATA	0x00000100l
#define JOY_RETURNPOVCTS	0x00000200l
#define JOY_RETURNCENTERED	0x00000400l
#define JOY_USEDEADZONE		0x00000800l
#define JOY_RETURNALL		(JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
				 JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
				 JOY_RETURNPOV | JOY_RETURNBUTTONS)
#define JOY_CAL_READALWAYS	0x00010000l
#define JOY_CAL_READXYONLY	0x00020000l
#define JOY_CAL_READ3		0x00040000l
#define JOY_CAL_READ4		0x00080000l
#define JOY_CAL_READXONLY	0x00100000l
#define JOY_CAL_READYONLY	0x00200000l
#define JOY_CAL_READ5		0x00400000l
#define JOY_CAL_READ6		0x00800000l
#define JOY_CAL_READZONLY	0x01000000l
#define JOY_CAL_READRONLY	0x02000000l
#define JOY_CAL_READUONLY	0x04000000l
#define JOY_CAL_READVONLY	0x08000000l

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick driver capabilites */
#define JOYCAPS_HASZ		0x0001
#define JOYCAPS_HASR		0x0002
#define JOYCAPS_HASU		0x0004
#define JOYCAPS_HASV		0x0008
#define JOYCAPS_HASPOV		0x0010
#define JOYCAPS_POV4DIR		0x0020
#define JOYCAPS_POVCTS		0x0040



/* joystick device capabilities data structure */
#ifdef _WIN32

typedef struct tagJOYCAPSA {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    CHAR    szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    CHAR    szRegKey[MAXPNAMELEN];/* registry key */
    CHAR    szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
typedef struct tagJOYCAPSW {
    WORD    wMid;                /* manufacturer ID */
    WORD    wPid;                /* product ID */
    WCHAR   szPname[MAXPNAMELEN];/* product name (NULL terminated string) */
    UINT    wXmin;               /* minimum x position value */
    UINT    wXmax;               /* maximum x position value */
    UINT    wYmin;               /* minimum y position value */
    UINT    wYmax;               /* maximum y position value */
    UINT    wZmin;               /* minimum z position value */
    UINT    wZmax;               /* maximum z position value */
    UINT    wNumButtons;         /* number of buttons */
    UINT    wPeriodMin;          /* minimum message period when captured */
    UINT    wPeriodMax;          /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT    wRmin;               /* minimum r position value */
    UINT    wRmax;               /* maximum r position value */
    UINT    wUmin;               /* minimum u (5th axis) position value */
    UINT    wUmax;               /* maximum u (5th axis) position value */
    UINT    wVmin;               /* minimum v (6th axis) position value */
    UINT    wVmax;               /* maximum v (6th axis) position value */
    UINT    wCaps;	 	 /* joystick capabilites */
    UINT    wMaxAxes;	 	 /* maximum number of axes supported */
    UINT    wNumAxes;	 	 /* number of axes in use */
    UINT    wMaxButtons;	 /* maximum number of buttons supported */
    WCHAR   szRegKey[MAXPNAMELEN];/* registry key */
    WCHAR   szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;
#ifdef UNICODE
typedef JOYCAPSW JOYCAPS;
typedef PJOYCAPSW PJOYCAPS;
typedef NPJOYCAPSW NPJOYCAPS;
typedef LPJOYCAPSW LPJOYCAPS;
#else
typedef JOYCAPSA JOYCAPS;
typedef PJOYCAPSA PJOYCAPS;
typedef NPJOYCAPSA NPJOYCAPS;
typedef LPJOYCAPSA LPJOYCAPS;
#endif // UNICODE

#else
typedef struct joycaps_tag {
    WORD wMid;                  /* manufacturer ID */
    WORD wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
#if (WINVER >= 0x0400)
    UINT wRmin;                 /* minimum r position value */
    UINT wRmax;                 /* maximum r position value */
    UINT wUmin;                 /* minimum u (5th axis) position value */
    UINT wUmax;                 /* maximum u (5th axis) position value */
    UINT wVmin;                 /* minimum v (6th axis) position value */
    UINT wVmax;                 /* maximum v (6th axis) position value */
    UINT wCaps;                 /* joystick capabilites */
    UINT wMaxAxes;	 	/* maximum number of axes supported */
    UINT wNumAxes;	 	/* number of axes in use */
    UINT wMaxButtons;	 	/* maximum number of buttons supported */
    char szRegKey[MAXPNAMELEN]; /* registry key */
    char szOEMVxD[MAX_JOYSTICKOEMVXDNAME]; /* OEM VxD in use */
#endif
} JOYCAPS, *PJOYCAPS, NEAR *NPJOYCAPS, FAR *LPJOYCAPS;
#endif


/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
} JOYINFO, *PJOYINFO, NEAR *NPJOYINFO, FAR *LPJOYINFO;

#if(WINVER >= 0x0400)
typedef struct joyinfoex_tag {
    DWORD dwSize;		 /* size of structure */
    DWORD dwFlags;		 /* flags to indicate what to return */
    DWORD dwXpos;                /* x position */
    DWORD dwYpos;                /* y position */
    DWORD dwZpos;                /* z position */
    DWORD dwRpos;		 /* rudder/4th axis position */
    DWORD dwUpos;		 /* 5th axis position */
    DWORD dwVpos;		 /* 6th axis position */
    DWORD dwButtons;             /* button states */
    DWORD dwButtonNumber;        /* current button number pressed */
    DWORD dwPOV;                 /* point of view state */
    DWORD dwReserved1;		 /* reserved for communication between winmm & driver */
    DWORD dwReserved2;		 /* reserved for future expansion */
} JOYINFOEX, *PJOYINFOEX, NEAR *NPJOYINFOEX, FAR *LPJOYINFOEX;
#endif /* WINVER >= 0x0400 */

#ifndef _WIN32_VXD

/* joystick function prototypes */
WINMMAPI UINT WINAPI joyGetNumDevs(void);
#ifdef _WIN32

WINMMAPI MMRESULT WINAPI joyGetDevCapsA(UINT uJoyID, LPJOYCAPSA pjc, UINT cbjc);
WINMMAPI MMRESULT WINAPI joyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);
#ifdef UNICODE
#define joyGetDevCaps  joyGetDevCapsW
#else
#define joyGetDevCaps  joyGetDevCapsA
#endif // !UNICODE

#else
MMRESULT WINAPI joyGetDevCaps(UINT uJoyID, LPJOYCAPS pjc, UINT cbjc);
#endif
WINMMAPI MMRESULT WINAPI joyGetPos(UINT uJoyID, LPJOYINFO pji);

#if(WINVER >= 0x0400)
WINMMAPI MMRESULT WINAPI joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);
#endif /* WINVER >= 0x0400 */

WINMMAPI MMRESULT WINAPI joyGetThreshold(UINT uJoyID, LPUINT puThreshold);
WINMMAPI MMRESULT WINAPI joyReleaseCapture(UINT uJoyID);
WINMMAPI MMRESULT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL fChanged);
WINMMAPI MMRESULT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

UINT WINAPI joySetCalibration(UINT uJoyID, LPUINT puXbase,	// ;internal
              LPUINT puXdelta, LPUINT puYbase, LPUINT puYdelta,	// ;internal
              LPUINT puZbase, LPUINT puZdelta);	// ;internal
#if (WINVER >= 0x0400)	// ;internal
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );	// ;internal
#endif	// ;internal

#endif /* ifndef _WIN32_VXD */

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
#ifndef _WIN32_VXD
/****************************************************************************

			Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE                256
#define MMIOERR_FILENOTFOUND        (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY         (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN          (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE         (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD          (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE         (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK          (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND        (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND       (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED          (MMIOERR_BASE + 10) /*  */
#define MMIOERR_PATHNOTFOUND        (MMIOERR_BASE + 11) /* path incorrect */
#define MMIOERR_ACCESSDENIED        (MMIOERR_BASE + 12) /* file was protected */
#define MMIOERR_SHARINGVIOLATION    (MMIOERR_BASE + 13) /* file in use */
#define MMIOERR_NETWORKERROR        (MMIOERR_BASE + 14) /* network not responding */
#define MMIOERR_TOOMANYOPENFILES    (MMIOERR_BASE + 15) /* no more file handles  */
#define MMIOERR_INVALIDFILE         (MMIOERR_BASE + 16) /* default error file error */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg,
	    LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;


/* general MMIO information data structure */
typedef struct _MMIOINFO
{
	/* general fields */
	DWORD           dwFlags;        /* general status flags */
	FOURCC          fccIOProc;      /* pointer to I/O procedure */
	LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
	UINT            wErrorRet;      /* place for error to be returned */
	HTASK           htask;          /* alternate local task */

	/* fields maintained by MMIO functions during buffered I/O */
	LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
	HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
	HPSTR           pchNext;        /* pointer to next byte to read/write */
	HPSTR           pchEndRead;     /* pointer to last valid byte to read */
	HPSTR           pchEndWrite;    /* pointer to last byte to write */
	LONG            lBufOffset;     /* disk offset of start of buffer */

	/* fields maintained by I/O procedure */
	LONG            lDiskOffset;    /* disk offset of next read or write */
	DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

	/* other fields maintained by MMIO */
	DWORD           dwReserved1;    /* reserved for MMIO use */
	DWORD           dwReserved2;    /* reserved for MMIO use */
	HMMIO           hmmio;          /* handle to open file */
} MMIOINFO, *PMMIOINFO, NEAR *NPMMIOINFO, FAR *LPMMIOINFO;
typedef const MMIOINFO FAR *LPCMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
	FOURCC          ckid;           /* chunk ID */
	DWORD           cksize;         /* chunk size */
	FOURCC          fccType;        /* form type or list type */
	DWORD           dwDataOffset;   /* offset of data portion of chunk */
	DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO, *PMMCKINFO, NEAR *NPMMCKINFO, FAR *LPMMCKINFO;
typedef const MMCKINFO *LPCMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */

#define MMIO_OPEN_VALID 0x0003FFFF      /* valid flags for mmioOpen */ // ;internal
#define MMIO_FLUSH_VALID MMIO_EMPTYBUF  /* valid flags for mmioFlush */ // ;internal
#define MMIO_ADVANCE_VALID (MMIO_WRITE | MMIO_READ)     /* valid flags for mmioAdvance */ // ;internal
#define MMIO_FOURCC_VALID MMIO_TOUPPER  /* valid flags for mmioStringToFOURCC */ // ;internal
#define MMIO_DESCEND_VALID (MMIO_FINDCHUNK | MMIO_FINDRIFF | MMIO_FINDLIST) // ;internal
#define MMIO_CREATE_VALID (MMIO_CREATERIFF | MMIO_CREATELIST)   // ;internal

#define MMIO_WIN31_TASK 0x80000000   // ;internal

/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_UNICODEPROC    0x01000000  /* mmioInstallIOProc: Unicode MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */

#define MMIO_VALIDPROC      0x10070000  /* valid for mmioInstallIOProc */ // ;internal

/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC(ch0, ch1, ch2, ch3)  MAKEFOURCC(ch0, ch1, ch2, ch3)

/* MMIO function prototypes */
#ifdef _WIN32

WINMMAPI FOURCC WINAPI mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);
WINMMAPI FOURCC WINAPI mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);
#ifdef UNICODE
#define mmioStringToFOURCC  mmioStringToFOURCCW
#else
#define mmioStringToFOURCC  mmioStringToFOURCCA
#endif // !UNICODE
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
WINMMAPI LPMMIOPROC WINAPI mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
#ifdef UNICODE
#define mmioInstallIOProc  mmioInstallIOProcW
#else
#define mmioInstallIOProc  mmioInstallIOProcA
#endif // !UNICODE
WINMMAPI HMMIO WINAPI mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
WINMMAPI HMMIO WINAPI mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#ifdef UNICODE
#define mmioOpen  mmioOpenW
#else
#define mmioOpen  mmioOpenA
#endif // !UNICODE
WINMMAPI MMRESULT WINAPI mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
WINMMAPI MMRESULT WINAPI mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);
#ifdef UNICODE
#define mmioRename  mmioRenameW
#else
#define mmioRename  mmioRenameA
#endif // !UNICODE
#else
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
#if (WINVER >= 0x030a)
MMRESULT WINAPI mmioRename(LPCSTR pszFileName, LPCSTR pszNewFileName, const MMIOINFO FAR* pmmioinfo, DWORD fdwRename);
#endif /* ifdef WINVER >= 0x030a */
#endif

WINMMAPI MMRESULT WINAPI mmioClose(HMMIO hmmio, UINT fuClose);
WINMMAPI LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
WINMMAPI LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
WINMMAPI LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
WINMMAPI MMRESULT WINAPI mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
WINMMAPI MMRESULT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT fuBuffer);
WINMMAPI MMRESULT WINAPI mmioFlush(HMMIO hmmio, UINT fuFlush);
WINMMAPI MMRESULT WINAPI mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
WINMMAPI LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMsg,
    LPARAM lParam1, LPARAM lParam2);
WINMMAPI MMRESULT WINAPI mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki,
    const MMCKINFO FAR* pmmckiParent, UINT fuDescend);
WINMMAPI MMRESULT WINAPI mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
WINMMAPI MMRESULT WINAPI mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
#ifndef _WIN32_VXD
/****************************************************************************

			    MCI support

****************************************************************************/

#ifndef _MCIERROR_              /* MCIERROR is defined in some post 3.1 apps */
#define _MCIERROR_
typedef DWORD   MCIERROR;       /* error return code, 0 means no error */
#endif

#ifndef _MCIDEVICEID_           /* Same with MCIDEVICEID */
#define _MCIDEVICEID_
typedef UINT    MCIDEVICEID;    /* MCI device ID type */
#endif


typedef UINT (CALLBACK *YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

/* MCI function prototypes */
#ifdef _WIN32

WINMMAPI MCIERROR WINAPI mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
WINMMAPI MCIERROR WINAPI mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
#ifdef UNICODE
#define mciSendCommand  mciSendCommandW
#else
#define mciSendCommand  mciSendCommandA
#endif // !UNICODE
WINMMAPI MCIERROR  WINAPI mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
WINMMAPI MCIERROR  WINAPI mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
#ifdef UNICODE
#define mciSendString  mciSendStringW
#else
#define mciSendString  mciSendStringA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDA(LPCSTR pszDevice);
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDW(LPCWSTR pszDevice);
#ifdef UNICODE
#define mciGetDeviceID  mciGetDeviceIDW
#else
#define mciGetDeviceID  mciGetDeviceIDA
#endif // !UNICODE
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType );
WINMMAPI MCIDEVICEID WINAPI mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );
#ifdef UNICODE
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDW
#else
#define mciGetDeviceIDFromElementID  mciGetDeviceIDFromElementIDA
#endif // !UNICODE
WINMMAPI BOOL WINAPI mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);
WINMMAPI BOOL WINAPI mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);
#ifdef UNICODE
#define mciGetErrorString  mciGetErrorStringW
#else
#define mciGetErrorString  mciGetErrorStringA
#endif // !UNICODE

#else
MCIERROR WINAPI mciSendCommand(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);
MCIERROR  WINAPI mciSendString(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
MCIDEVICEID WINAPI mciGetDeviceID(LPCSTR pszDevice);
BOOL WINAPI mciGetErrorString(MCIERROR mcierr, LPSTR pszText, UINT cchText);
#endif

WINMMAPI BOOL WINAPI mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
WINMMAPI HTASK WINAPI mciGetCreatorTask(MCIDEVICEID mciId);
WINMMAPI YIELDPROC WINAPI mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
WINMMAPI BOOL WINAPI mciExecute(LPCSTR pszCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

#define MCIERR_NO_IDENTITY              (MCIERR_BASE + 94)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

#define MCI_FIRST                       DRV_MCI_FIRST   /* 0x0800 */
/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SOUND                       0x0812    // ;internal
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856
#define	MCI_WIN32CLIENT			0x0857	// ;internal

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (DRV_MCI_FIRST + 0x400)
#define MCI_LAST                        0x0FFF


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               ((MCIDEVICEID)-1)

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 513 /* (MCI_STRING_OFFSET + 1) */
#define MCI_DEVTYPE_VIDEODISC           514 /* (MCI_STRING_OFFSET + 2) */
#define MCI_DEVTYPE_OVERLAY             515 /* (MCI_STRING_OFFSET + 3) */
#define MCI_DEVTYPE_CD_AUDIO            516 /* (MCI_STRING_OFFSET + 4) */
#define MCI_DEVTYPE_DAT                 517 /* (MCI_STRING_OFFSET + 5) */
#define MCI_DEVTYPE_SCANNER             518 /* (MCI_STRING_OFFSET + 6) */
#define MCI_DEVTYPE_ANIMATION           519 /* (MCI_STRING_OFFSET + 7) */
#define MCI_DEVTYPE_DIGITAL_VIDEO       520 /* (MCI_STRING_OFFSET + 8) */
#define MCI_DEVTYPE_OTHER               521 /* (MCI_STRING_OFFSET + 9) */
#define MCI_DEVTYPE_WAVEFORM_AUDIO      522 /* (MCI_STRING_OFFSET + 10) */
#define MCI_DEVTYPE_SEQUENCER           523 /* (MCI_STRING_OFFSET + 11) */

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

#define MCI_DEVTYPE_FIRST_USER          0x1000
/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
						  ((WORD)(s)<<8)) | \
						 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s) | \
						   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
						  ((WORD)(m)<<8)) | \
						 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L
#define MCI_INFO_MEDIA_UPC              0x00000400L
#define MCI_INFO_MEDIA_IDENTITY         0x00000800L
#define MCI_INFO_NAME                   0x00001000L
#define MCI_INFO_COPYRIGHT              0x00002000L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SOUND command message */	// ;internal
#define MCI_SOUND_NAME                  0x00000100L		// ;internal
								// ;internal
/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L


/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, FAR *LPMCI_GENERIC_PARMS;


/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR     lpstrDeviceType;
    LPCSTR     lpstrElementName;
    LPCSTR     lpstrAlias;
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
typedef struct tagMCI_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR    lpstrDeviceType;
    LPCWSTR    lpstrElementName;
    LPCWSTR    lpstrAlias;
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OPEN_PARMSW MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSW PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSW LPMCI_OPEN_PARMS;
#else
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OPEN_PARMS {
    DWORD       dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
} MCI_OPEN_PARMS, FAR *LPMCI_OPEN_PARMS;
#endif


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, FAR *LPMCI_PLAY_PARMS;


/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, FAR *LPMCI_SEEK_PARMS;


/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, FAR * LPMCI_STATUS_PARMS;


/* parameter block for MCI_INFO command message */
#ifdef _WIN32

typedef struct tagMCI_INFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSA, * LPMCI_INFO_PARMSA;
typedef struct tagMCI_INFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMSW, * LPMCI_INFO_PARMSW;
#ifdef UNICODE
typedef MCI_INFO_PARMSW MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSW LPMCI_INFO_PARMS;
#else
typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS, FAR * LPMCI_INFO_PARMS;
#endif


/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, FAR * LPMCI_GETDEVCAPS_PARMS;


/* parameter block for MCI_SYSINFO command message */
#ifdef _WIN32

typedef struct tagMCI_SYSINFO_PARMSA {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, * LPMCI_SYSINFO_PARMSA;
typedef struct tagMCI_SYSINFO_PARMSW {
    DWORD   dwCallback;
    LPWSTR  lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, * LPMCI_SYSINFO_PARMSW;
#ifdef UNICODE
typedef MCI_SYSINFO_PARMSW MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSW PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSW LPMCI_SYSINFO_PARMS;
#else
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    WORD    wDeviceType;
    WORD    wReserved0;
} MCI_SYSINFO_PARMS, FAR * LPMCI_SYSINFO_PARMS;
#endif


/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS, *PMCI_SET_PARMS, FAR *LPMCI_SET_PARMS;


/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
#ifdef _WIN32
    int     nVirtKey;
    HWND    hwndBreak;
#else
    short   nVirtKey;
    WORD    wReserved0;             /* padding for Win 16 */
    HWND    hwndBreak;
    WORD    wReserved1;             /* padding for Win 16 */
#endif
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, FAR * LPMCI_BREAK_PARMS;


/* parameter block for MCI_SOUND command message */	// ;internal
#ifdef _WIN32	// ;internal

typedef struct tagMCI_SOUND_PARMSA {	// ;internal
    DWORD   dwCallback;	// ;internal
    LPCSTR    lpstrSoundName;	// ;internal
} MCI_SOUND_PARMSA, *PMCI_SOUND_PARMSA, *LPMCI_SOUND_PARMSA;	// ;internal
typedef struct tagMCI_SOUND_PARMSW {	// ;internal
    DWORD   dwCallback;	// ;internal
    LPCWSTR   lpstrSoundName;	// ;internal
} MCI_SOUND_PARMSW, *PMCI_SOUND_PARMSW, *LPMCI_SOUND_PARMSW;	// ;internal
#ifdef UNICODE	// ;internal
typedef MCI_SOUND_PARMSW MCI_SOUND_PARMS;	// ;internal
typedef PMCI_SOUND_PARMSW PMCI_SOUND_PARMS;	// ;internal
typedef LPMCI_SOUND_PARMSW LPMCI_SOUND_PARMS;	// ;internal
#else	// ;internal
typedef MCI_SOUND_PARMSA MCI_SOUND_PARMS;	// ;internal
typedef PMCI_SOUND_PARMSA PMCI_SOUND_PARMS;	// ;internal
typedef LPMCI_SOUND_PARMSA LPMCI_SOUND_PARMS;	// ;internal
#endif // UNICODE	// ;internal

#else	// ;internal
typedef struct tagMCI_SOUND_PARMS {	// ;internal
    DWORD   dwCallback;	// ;internal
    LPCSTR  lpstrSoundName;	// ;internal
} MCI_SOUND_PARMS;	// ;internal
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;	// ;internal
#endif	// ;internal



/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_SAVE_PARMSA {
    DWORD    dwCallback;
    LPCSTR    lpfilename;
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, * LPMCI_SAVE_PARMSA;
typedef struct tagMCI_SAVE_PARMSW {
    DWORD    dwCallback;
    LPCWSTR   lpfilename;
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, * LPMCI_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_SAVE_PARMSW MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSW PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSW LPMCI_SAVE_PARMS;
#else
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS, FAR * LPMCI_SAVE_PARMS;
#endif


/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_LOAD_PARMSA {
    DWORD    dwCallback;
    LPCSTR      lpfilename;
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, * LPMCI_LOAD_PARMSA;
typedef struct tagMCI_LOAD_PARMSW {
    DWORD    dwCallback;
    LPCWSTR     lpfilename;
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, * LPMCI_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_LOAD_PARMSW MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSW PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSW LPMCI_LOAD_PARMS;
#else
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS, FAR * LPMCI_LOAD_PARMS;
#endif


/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS, FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, FAR *LPMCI_VD_PLAY_PARMS;


/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, FAR *LPMCI_VD_STEP_PARMS;


/* parameter block for MCI_ESCAPE command message */
#ifdef _WIN32

typedef struct tagMCI_VD_ESCAPE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpstrCommand;
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
typedef struct tagMCI_VD_ESCAPE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpstrCommand;
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;
#ifdef UNICODE
typedef MCI_VD_ESCAPE_PARMSW MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSW PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSW LPMCI_VD_ESCAPE_PARMS;
#else
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS, FAR *LPMCI_VD_ESCAPE_PARMS;
#endif

/* MCI extensions for CD audio devices */

/* flags for the dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_CDA_STATUS_TYPE_TRACK       0x00004001L

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) */
#define MCI_CDA_TRACK_AUDIO             (MCI_CD_OFFSET + 0)
#define MCI_CDA_TRACK_OTHER             (MCI_CD_OFFSET + 1)

/* MCI extensions for waveform audio devices */

#define MCI_WAVE_PCM                    (MCI_WAVE_OFFSET + 0)
#define MCI_WAVE_MAPPER                 (MCI_WAVE_OFFSET + 1)

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L


/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_WAVE_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
typedef struct tagMCI_WAVE_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_WAVE_OPEN_PARMSW MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSW PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSW LPMCI_WAVE_OPEN_PARMS;
#else
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS, FAR *LPMCI_WAVE_OPEN_PARMS;
#endif


/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, FAR *LPMCI_WAVE_DELETE_PARMS;


/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
#ifdef _WIN32
    UINT    wInput;
    UINT    wOutput;
#else
    WORD    wInput;
    WORD    wReserved0;
    WORD    wOutput;
    WORD    wReserved1;
#endif
    WORD    wFormatTag;
    WORD    wReserved2;
    WORD    nChannels;
    WORD    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    WORD    nBlockAlign;
    WORD    wReserved4;
    WORD    wBitsPerSample;
    WORD    wReserved5;
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533
#define     MCI_SEQ_MAPPER              65535

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL
#define MCI_SEQ_STATUS_NAME             0x0000400BL
#define MCI_SEQ_STATUS_COPYRIGHT        0x0000400CL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L


/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L


/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
typedef struct tagMCI_ANIM_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_OPEN_PARMSW MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSW PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSW LPMCI_ANIM_OPEN_PARMS;
#else
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_ANIM_OPEN_PARMS, FAR *LPMCI_ANIM_OPEN_PARMS;
#endif


/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, FAR *LPMCI_ANIM_PLAY_PARMS;


/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, FAR *LPMCI_ANIM_STEP_PARMS;


/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_ANIM_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR     lpstrText;
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, * LPMCI_ANIM_WINDOW_PARMSA;
typedef struct tagMCI_ANIM_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR    lpstrText;
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, * LPMCI_ANIM_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_ANIM_WINDOW_PARMSW MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSW PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSW LPMCI_ANIM_WINDOW_PARMS;
#else
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    WORD    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS, FAR * LPMCI_ANIM_WINDOW_PARMS;
#endif


/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS * PMCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;


/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L


/* parameter block for MCI_OPEN command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_OPEN_PARMSA {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
typedef struct tagMCI_OVLY_OPEN_PARMSW {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    LPCWSTR     lpstrDeviceType;
    LPCWSTR     lpstrElementName;
    LPCWSTR     lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_OPEN_PARMSW MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSW PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSW LPMCI_OVLY_OPEN_PARMS;
#else
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;
#endif // UNICODE

#else
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    MCIDEVICEID wDeviceID;
    WORD        wReserved0;
    LPCSTR      lpstrDeviceType;
    LPCSTR      lpstrElementName;
    LPCSTR      lpstrAlias;
    DWORD       dwStyle;
    HWND        hWndParent;
    WORD        wReserved1;
} MCI_OVLY_OPEN_PARMS, FAR *LPMCI_OVLY_OPEN_PARMS;
#endif


/* parameter block for MCI_WINDOW command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_WINDOW_PARMSA {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCSTR      lpstrText;
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, * LPMCI_OVLY_WINDOW_PARMSA;
typedef struct tagMCI_OVLY_WINDOW_PARMSW {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    nCmdShow;
    LPCWSTR     lpstrText;
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, * LPMCI_OVLY_WINDOW_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_WINDOW_PARMSW MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSW PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSW LPMCI_OVLY_WINDOW_PARMS;
#else
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    WORD    wReserved1;
    UINT    nCmdShow;
    WORD    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS, FAR * LPMCI_OVLY_WINDOW_PARMS;
#endif


/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, FAR * LPMCI_OVLY_RECT_PARMS;


/* parameter block for MCI_SAVE command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_SAVE_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, * LPMCI_OVLY_SAVE_PARMSA;
typedef struct tagMCI_OVLY_SAVE_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, * LPMCI_OVLY_SAVE_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_SAVE_PARMSW MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSW PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSW LPMCI_OVLY_SAVE_PARMS;
#else
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS, FAR * LPMCI_OVLY_SAVE_PARMS;
#endif


/* parameter block for MCI_LOAD command message */
#ifdef _WIN32

typedef struct tagMCI_OVLY_LOAD_PARMSA {
    DWORD   dwCallback;
    LPCSTR      lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, * LPMCI_OVLY_LOAD_PARMSA;
typedef struct tagMCI_OVLY_LOAD_PARMSW {
    DWORD   dwCallback;
    LPCWSTR     lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, * LPMCI_OVLY_LOAD_PARMSW;
#ifdef UNICODE
typedef MCI_OVLY_LOAD_PARMSW MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSW PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSW LPMCI_OVLY_LOAD_PARMS;
#else
typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;
#endif // UNICODE
#else
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS, FAR * LPMCI_OVLY_LOAD_PARMS;
#endif

#endif  /* ifndef _WIN32_VXD */
#endif  /* ifndef MMNOMCI */

/****************************************************************************

			DISPLAY Driver extensions

****************************************************************************/

#ifndef NEWTRANSPARENT
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef NEWTRANSPARENT */

/****************************************************************************

			DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

			ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  /* _INC_MMSYSP */       // ;internal
#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
****/

#ifndef _INC_MALLOC

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __based     _based
#define __cdecl     _cdecl
#define __far       _far
#define __huge      _huge
#define __near      _near
#define __segment   _segment
#endif 

/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY  (-1)
#define _HEAPOK     (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND    (-5)
#define _HEAPBADPTR (-6)
#define _FREEENTRY  0
#define _USEDENTRY  1

/* maximum heap request that can ever be honored */

#ifdef _WINDOWS
#define _HEAP_MAXREQ    0xFFE6
#else 
#define _HEAP_MAXREQ    0xFFE8
#endif 

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int __far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif 


/* external variable declarations */

extern unsigned int __near __cdecl _amblksiz;


/* based heap function prototypes */

void __based(void) * __cdecl _bcalloc(__segment, size_t, size_t);
void __based(void) * __cdecl _bexpand(__segment,
    void __based(void) *, size_t);
void __cdecl _bfree(__segment, void __based(void) *);
int __cdecl _bfreeseg(__segment);
int __cdecl _bheapadd(__segment, void __based(void) *, size_t);
int __cdecl _bheapchk(__segment);
int __cdecl _bheapmin(__segment);
__segment __cdecl _bheapseg(size_t);
int __cdecl _bheapset(__segment, unsigned int);
int __cdecl _bheapwalk(__segment, _HEAPINFO *);
void __based(void) * __cdecl _bmalloc(__segment, size_t);
size_t __cdecl _bmsize(__segment, void __based(void) *);
void __based(void) * __cdecl _brealloc(__segment,
    void __based(void) *, size_t);


/* function prototypes */

void * __cdecl _alloca(size_t);
void * __cdecl calloc(size_t, size_t);
void * __cdecl _expand(void *, size_t);
void __far * __cdecl _fcalloc(size_t, size_t);
void __far * __cdecl _fexpand(void __far *, size_t);
void __cdecl _ffree(void __far *);
int __cdecl _fheapchk(void);
int __cdecl _fheapmin(void);
int __cdecl _fheapset(unsigned int);
int __cdecl _fheapwalk(_HEAPINFO *);
void __far * __cdecl _fmalloc(size_t);
size_t __cdecl _fmsize(void __far *);
void __far * __cdecl _frealloc(void __far *, size_t);
unsigned int __cdecl _freect(size_t);
void __cdecl free(void *);
void __huge * __cdecl _halloc(long, size_t);
void __cdecl _hfree(void __huge *);
#ifndef _WINDOWS
int __cdecl _heapadd(void __far *, size_t);
int __cdecl _heapchk(void);
#endif 
int __cdecl _heapmin(void);
#ifndef _WINDOWS
int __cdecl _heapset(unsigned int);
int __cdecl _heapwalk(_HEAPINFO *);
#endif 
void * __cdecl malloc(size_t);
size_t __cdecl _memavl(void);
size_t __cdecl _memmax(void);
size_t __cdecl _msize(void *);
void __near * __cdecl _ncalloc(size_t, size_t);
void __near * __cdecl _nexpand(void __near *, size_t);
void __cdecl _nfree(void __near *);
#ifndef _WINDOWS
int __cdecl _nheapchk(void);
#endif 
int __cdecl _nheapmin(void);
#ifndef _WINDOWS
int __cdecl _nheapset(unsigned int);
int __cdecl _nheapwalk(_HEAPINFO *);
#endif 
void __near * __cdecl _nmalloc(size_t);
size_t __cdecl _nmsize(void __near *);
void __near * __cdecl _nrealloc(void __near *, size_t);
void * __cdecl realloc(void *, size_t);
size_t __cdecl _stackavail(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl alloca(size_t);
void __huge * __cdecl halloc(long, size_t);
void __cdecl hfree(void __huge *);
size_t __cdecl stackavail(void);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MALLOC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\print.h ===
/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*               Copyright (c) 1985-1992. Microsoft Corp.  All rights reserved.*
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER       - For inclusion with a printer driver
*  NOPQ              - Prevent inclusion of priority queue APIs
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef PRINTDRIVER

#define NORASTEROPS
#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI

#include <windows.h>

#undef NORASTEROPS
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

/* Spool routines for use by printer drivers */

DECLARE_HANDLE(HPJOB);

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

#endif /* !PRINTDRIVER */

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64

/* current version of specification */
#define DM_SPECVERSION 0x30A

/* field selection bits */
#define DM_ORIENTATION	    0x0000001L
#define DM_PAPERSIZE	    0x0000002L
#define DM_PAPERLENGTH	    0x0000004L
#define DM_PAPERWIDTH	    0x0000008L
#define DM_SCALE	    0x0000010L
#define DM_COPIES	    0x0000100L
#define DM_DEFAULTSOURCE    0x0000200L
#define DM_PRINTQUALITY     0x0000400L
#define DM_COLOR	    0x0000800L
#define DM_DUPLEX	    0x0001000L
#define DM_YRESOLUTION	    0x0002000L
#define DM_TTOPTION	    0x0004000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
/*  Warning: The PostScript driver mistakingly uses DMPAPER_ values between
 *  50 and 56.  Don't use this range when defining new paper sizes.
 */
#define DMPAPER_FIRST	    DMPAPER_LETTER
#define DMPAPER_LETTER      1           /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL 2           /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID     3           /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER      4           /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL       5           /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT   6           /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE   7		/* Executive 7 1/4 x 10 1/2 in	      */
#define DMPAPER_A3          8           /* A3 297 x 420 mm                    */
#define DMPAPER_A4          9           /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL     10          /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5          11          /* A5 148 x 210 mm                    */
#define DMPAPER_B4          12          /* B4 250 x 354                       */
#define DMPAPER_B5          13          /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO       14          /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO      15          /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14       16          /* 10x14 in                           */
#define DMPAPER_11X17       17          /* 11x17 in                           */
#define DMPAPER_NOTE        18          /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9       19          /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10      20          /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11      21          /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12      22          /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14      23          /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET      24          /* C size sheet                       */
#define DMPAPER_DSHEET      25          /* D size sheet                       */
#define DMPAPER_ESHEET      26          /* E size sheet                       */
#define DMPAPER_ENV_DL      27          /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5      28          /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3      29          /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4      30          /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6      31          /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65     32          /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4      33          /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5      34          /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6      35          /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY   36          /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH 37          /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US  39          /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */

#define DMPAPER_LAST	    DMPAPER_FANFOLD_LGL_GERMAN

#define DMPAPER_USER	    256

/* bin selections */
#define DMBIN_FIRST	    DMBIN_UPPER
#define DMBIN_UPPER	    1
#define DMBIN_ONLYONE	    1
#define DMBIN_LOWER	    2
#define DMBIN_MIDDLE	    3
#define DMBIN_MANUAL	    4
#define DMBIN_ENVELOPE	    5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO	    7
#define DMBIN_TRACTOR	    8
#define DMBIN_SMALLFMT	    9
#define DMBIN_LARGEFMT	    10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_LAST	    DMBIN_CASSETTE

#define DMBIN_USER	    256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT	    (-1)
#define DMRES_LOW	    (-2)
#define DMRES_MEDIUM	    (-3)
#define DMRES_HIGH	    (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR	    2

/* duplex enable */
#define DMDUP_SIMPLEX	 1
#define DMDUP_VERTICAL	 2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE	    1
#define DM_COPY 	    2
#define DM_PROMPT	    4
#define DM_MODIFY	    8

#define DM_IN_BUFFER	    DM_MODIFY
#define DM_IN_PROMPT	    DM_PROMPT
#define DM_OUT_BUFFER	    DM_COPY
#define DM_OUT_DEFAULT	    DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS	    1
#define DC_PAPERS	    2
#define DC_PAPERSIZE	    3
#define DC_MINEXTENT	    4
#define DC_MAXEXTENT	    5
#define DC_BINS 	    6
#define DC_DUPLEX	    7
#define DC_SIZE 	    8
#define DC_EXTRA	    9
#define DC_VERSION	    10
#define DC_DRIVER	    11
#define DC_BINNAMES	    12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE	    15
#define DC_PAPERNAMES	    16
#define DC_ORIENTATION	    17
#define DC_COPIES	    18

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP	    0x0000001L
#define DCTT_DOWNLOAD	    0x0000002L
#define DCTT_SUBDEV	    0x0000004L

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE	MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE	MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */
typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, DEVMODE FAR*,
                          LPSTR, LPSTR, DEVMODE FAR*, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, DEVMODE FAR*);

HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ostream class.
*   [AT&T C++]
*
****/

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class ostream : virtual public ios {

public:
    ostream(streambuf*);
    virtual ~ostream();

    ostream& flush();
    int  opfx();
    void osfx();

inline  ostream& operator<<(ostream& (*f)(ostream&));
inline  ostream& operator<<(ios& (*f)(ios&));
    ostream& operator<<(const char _HFAR_ *);
inline  ostream& operator<<(const unsigned char _HFAR_ *);
inline  ostream& operator<<(const signed char _HFAR_ *);
inline  ostream& operator<<(char);
    ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
    ostream& operator<<(short);
    ostream& operator<<(unsigned short);
    ostream& operator<<(int);
    ostream& operator<<(unsigned int);
    ostream& operator<<(long);
    ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
    ostream& operator<<(double);
    ostream& operator<<(long double);
    ostream& operator<<(const void _HFAR_ *);
    ostream& operator<<(streambuf*);
inline  ostream& put(char);
    ostream& put(unsigned char);
inline  ostream& put(signed char);
    ostream& write(const char _HFAR_ *,int);
inline  ostream& write(const unsigned char _HFAR_ *,int);
inline  ostream& write(const signed char _HFAR_ *,int);
    ostream& seekp(streampos);
    ostream& seekp(streamoff,ios::seek_dir);
    streampos tellp();

protected:
    ostream();
    ostream(const ostream&);    // treat as private
    ostream& operator=(streambuf*); // treat as private
    ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
    int do_opfx(int);       // not used
    void do_osfx();         // not used

private:
    ostream(ios&);
    ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
    int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }

inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }

inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }

inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }

inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }

inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }


class ostream_withassign : public ostream {
    public:
        ostream_withassign();
        ostream_withassign(streambuf* _is);
        ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

#ifndef _WINDLL
extern ostream_withassign cout;
extern ostream_withassign cerr;
extern ostream_withassign clog;
#endif 

inline ostream& flush(ostream& _outs) { return _outs.flush(); }
inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
inline ostream& ends(ostream& _outs) { return _outs << char('\0'); }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\msvideo.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO    50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#ifndef _RCINVOKED

// end_vfw32

#ifdef BUILDDLL                         /* ;Internal */
#undef WINAPI                           /* ;Internal */
#define WINAPI FAR PASCAL _loadds       /* ;Internal */
#endif                                  /* ;Internal */

// begin_vfw32

/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */

// end_vfw32

/****************************************************************************

   videoXXXX API's are only available on Win 3.x!  they are Not in Win32

****************************************************************************/

#if !defined _WIN32

/****************************************************************************

                        video APIs

****************************************************************************/


DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

#ifdef _WIN32
DWORD WINAPI videoConfigureStorageA(HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);

DWORD WINAPI videoConfigureStorageW(HVIDEO hVideo,
			LPWSTR lpstrIdent, DWORD dwFlags);
#ifdef UNICODE
#define videoConfigureStorage  videoConfigureStorageW
#else
#define videoConfigureStorage  videoConfigureStorageA
#endif // UNICODE
#else
DWORD WINAPI videoConfigureStorage(HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);
#define videoConfigureStorageA videoConfigureStorage
#endif
 
DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

#ifdef _WIN32
DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);

DWORD WINAPI videoGetErrorTextW(HVIDEO hVideo, UINT wError,
	        LPWSTR lpText, UINT wSize);
#ifdef UNICODE
#define videoGetErrorText  videoGetErrorTextW
#else
#define videoGetErrorText  videoGetErrorTextA
#endif 
#else
DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
#define videoGetErrorTextA videoGetErrorText
#endif 

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added post VFW1.1a
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR FAR * plpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr);


#endif // ! _WIN32

// begin_vfw32

/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif 

#define _INC_STDARG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif 

/* buffered I/O macros */

#define BUFSIZ  512
#ifdef _MT
#define _NFILE  40
#else 
#define _NFILE  20
#endif 
#define EOF (-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    };
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif 


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *  + 1 (in case _P_tmpdir does not end in "\\")
 *  + 6 (for the temp number string)
 *  + 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 128
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif 


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif 


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif 
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif 


#define _IOREAD     0x01
#define _IOWRT      0x02

#define _IOFBF      0x0
#define _IOLBF      0x40
#define _IONBF      0x04

#define _IOMYBUF    0x08
#define _IOEOF      0x10
#define _IOERR      0x20
#define _IOSTRG     0x40
#define _IORW       0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };
#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
    const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif 
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
    const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif 
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
    const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif 
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif 
#endif 
size_t __cdecl fwrite(const void *, size_t, size_t,
    FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif 
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
#ifndef _WINDLL
int __cdecl printf(const char *, ...);
#endif 
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif 
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif 
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif 
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
#ifndef _WINDLL
int __cdecl vprintf(const char *, va_list);
#endif 
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif 

/* macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
    : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()     getc(stdin)
#define putchar(_c)   putc((_c),stdout)
#endif 

#ifdef _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux    _stdaux
#define stdprn    _stdprn
#endif 

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif 
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif 
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place for other reasons.
*   [ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* exit() arg values */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif 
#define _ONEXIT_T_DEFINED
#endif 


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif 

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/* external variable declarations */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
extern int __far * __cdecl __far __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else 
extern int __near __cdecl volatile errno;   /* error value */
extern int __near __cdecl _doserrno;        /* OS system error value */
#endif 

extern char * __near __cdecl _sys_errlist[];    /* perror error message table */
extern int __near __cdecl _sys_nerr;        /* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ;     /* pointer to environment table */
extern int __near __cdecl _fmode;       /* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;        /* open file info mode (for spawn) */
#endif 

extern unsigned int __near __cdecl _psp;    /* Program Segment Prefix */

extern char __far * __near __cdecl _pgmptr; /* Pointer to Program name */

/* DOS and Windows major/minor version numbers */

extern unsigned int __near __cdecl _osver;
extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;
extern unsigned int __near __cdecl _winver;
extern unsigned char __near __cdecl _winmajor;
extern unsigned char __near __cdecl _winminor;

/* OS mode */

#define _DOS_MODE   0   /* DOS */
#define _OS2_MODE   1   /* OS/2 */
#define _WIN_MODE   2   /* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE  0   /* real mode */
#define _PROT_MODE  1   /* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

#ifdef _MT
double __pascal atof(const char *);
double __pascal strtod(const char *, char * *);
ldiv_t __pascal ldiv(long, long);
#else 
double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);
#endif 

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
    size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
    const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
    char *);
void __cdecl _splitpath(const char *, char *,
    char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
    int);
long double __cdecl _strtold(const char *,
    char * *);
unsigned long __cdecl strtoul(const char *,
    char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif 
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
    size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
    size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
    size_t);

#ifndef tolower
int __cdecl tolower(int);
#endif 

#ifndef toupper
int __cdecl toupper(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif 

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDLIB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the streambuf class.
*   [AT&T C++]
*
****/

#ifndef _INC_STREAMB
#define _INC_STREAMB


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

typedef long streampos, streamoff;

class streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char _HFAR_ *,int);
    inline int sgetn(char _HFAR_ *,int);

    virtual int sync();

//  enum seek_dir { beg=0, cur=1, end=2 };  // CONSIDER: needed ???

    virtual streambuf* setbuf(char _HFAR_ *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char _HFAR_ *,int);
    virtual int xsgetn(char _HFAR_ *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;    // pure virtual function

    virtual int pbackfail(int);

    void dbp();

protected:
    streambuf();
    streambuf(char _HFAR_ *,int);

    inline char _HFAR_ * base() const;
    inline char _HFAR_ * ebuf() const;
    inline char _HFAR_ * pbase() const;
    inline char _HFAR_ * pptr() const;
    inline char _HFAR_ * epptr() const;
    inline char _HFAR_ * eback() const;
    inline char _HFAR_ * gptr() const;
    inline char _HFAR_ * egptr() const;
    inline int blen() const;
    inline void setp(char _HFAR_ *,char _HFAR_ *);
    inline void setg(char _HFAR_ *,char _HFAR_ *,char _HFAR_ *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char _HFAR_ *,char _HFAR_ *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char _HFAR_ * _base;
    char _HFAR_ * _ebuf;
    char _HFAR_ * _pbase;
    char _HFAR_ * _pptr;
    char _HFAR_ * _epptr;
    char _HFAR_ * _eback;
    char _HFAR_ * _gptr;
    char _HFAR_ * _egptr;
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char _HFAR_ * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char _HFAR_ * _str,int _n) { return xsgetn(_str, _n); }

inline char _HFAR_ * streambuf::base() const { return _base; }
inline char _HFAR_ * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char _HFAR_ * streambuf::pbase() const { return _pbase; }
inline char _HFAR_ * streambuf::pptr() const { return _pptr; }
inline char _HFAR_ * streambuf::epptr() const { return _epptr; }
inline char _HFAR_ * streambuf::eback() const { return _eback; }
inline char _HFAR_ * streambuf::gptr() const { return _gptr; }
inline char _HFAR_ * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int n) { if (_egptr) _gptr += n; }
inline void streambuf::pbump(int n) { if (_epptr) _pptr += n; }
inline void streambuf::setg(char _HFAR_ * eb, char _HFAR_ * g, char _HFAR_ * eg) {_eback=eb; _gptr=g; _egptr=eg; x_lastc=EOF; }
inline void streambuf::setp(char _HFAR_ * p, char _HFAR_ * ep) {_pptr=_pbase=p; _epptr=ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int fUnbuf) { _fUnbuf = fUnbuf; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
****/

#ifndef _INC_STDDEF

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* define the NULL pointer value and the offsetof() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* offset of field m in a struct s */

#define offsetof(s,m)   (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


/* errno declaration */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 


#ifdef _MT
/* define pointer to thread id value */

extern int __far *_threadid;
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDDEF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the various declarations and definitions
*   for the time routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_TIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
    int tm_sec; /* seconds after the minute - [0,59] */
    int tm_min; /* minutes after the hour - [0,59] */
    int tm_hour;    /* hours since midnight - [0,23] */
    int tm_mday;    /* day of the month - [1,31] */
    int tm_mon; /* months since January - [0,11] */
    int tm_year;    /* years since 1900 */
    int tm_wday;    /* days since Sunday - [0,6] */
    int tm_yday;    /* days since January 1 - [0,365] */
    int tm_isdst;   /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif 


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int __near __cdecl _daylight;    /* non-zero if daylight savings time is used */
extern long __near __cdecl _timezone;   /* difference in seconds between GMT and local time */
extern char * __near __cdecl _tzname[2];/* standard/daylight savings time zone names */


/* function prototypes */

#ifdef _MT
double __pascal difftime(time_t, time_t);
#else 
double __cdecl difftime(time_t, time_t);
#endif 

char * __cdecl asctime(const struct tm *);
char * __cdecl ctime(const time_t *);
#ifndef _WINDLL
clock_t __cdecl clock(void);
#endif 
struct tm * __cdecl gmtime(const time_t *);
struct tm * __cdecl localtime(const time_t *);
time_t __cdecl mktime(struct tm *);
#ifndef _WINDLL
size_t __cdecl strftime(char *, size_t, const char *,
    const struct tm *);
#endif 
char * __cdecl _strdate(char *);
char * __cdecl _strtime(char *);
time_t __cdecl time(time_t *);
void __cdecl _tzset(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

extern int __near __cdecl daylight;
extern long __near __cdecl timezone;
extern char * __near __cdecl tzname[2];

void __cdecl tzset(void);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\tchar.h ===
/***
*tchar.h - definitions for generic international text functions (16-bit)
*
*   Copyright (c) 1991-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Definitions for generic international functions, mostly defines
*   which map string/formatted-io/ctype functions to char, wchar_t, or
*   MBCS versions.  To be used for compatibility between single-byte,
*   multi-byte and Unicode text models.
*
*   NOTE: This is a stripped-down version for use with 16-bit libraries.
*       It maps to SBCS only, not to MBCS or Unicode.
*
****/

#ifndef _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4505)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4505) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#define _TEOF       EOF

#define __T(x)      x

#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* ++++++++++++++++++++ SBCS FUNCTIONS ++++++++++++++++++++ */


/* Program */

#define _tmain      main
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif


/* Far functions */

#define _ftcscat    _fstrcat
#define _ftcschr    _fstrchr
#define _ftcscmp    _fstrcmp
#define _ftcscpy    _fstrcpy
#define _ftcscspn   _fstrcspn
#define _ftcslen    _fstrlen
#define _ftcsncat   _fstrncat
#define _ftcsncmp   _fstrncmp
#define _ftcsncpy   _fstrncpy
#define _ftcspbrk   _fstrpbrk
#define _ftcsrchr   _fstrrchr
#define _ftcsspn    _fstrspn
#define _ftcsstr    _fstrstr
#define _ftcstok    _fstrtok

#define _ftcsdup    _fstrdup
#define _ftcsicmp   _fstricmp
#define _ftcsnicmp  _fstrnicmp
#define _ftcsnset   _fstrnset
#define _ftcsrev    _fstrrev
#define _ftcsset    _fstrset

#define _ftcslwr    _fstrlwr
#define _ftcsupr    _fstrupr


/* Formatted i/o */

#define _tprintf    printf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _ftscanf    fscanf
#define _stscanf    sscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _gettc      getc
#define _gettchar   getchar
#define _getts      gets
#define _puttc      putc
#define _puttchar   putchar
#define _putts      puts
#define _ungettc    ungetc


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _tsetbuf    setbuf
#define _tsetvbuf   setvbuf
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _taccess    _access
#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindnext  _findnext
#define _tmktemp    _mktemp
#define _topen      _open
#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t


/* Stat functions */

#define _tstat      _stat


/* Setlocale functions */

#define _tsetlocale setlocale


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol


/* String functions */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcscoll    strcoll

#define _tcsdup     _strdup

#define _tcschr     strchr
#define _tcscmp     strcmp
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncmp    strncmp
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsicmp    _stricmp
#define _tcsnicmp   _strnicmp
#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsnccmp   strncmp
#define _tcsncicmp  _strnicmp
#define _tcsncset   _strnset


/* Ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef __cplusplus
}
#endif

#define _INC_TCHAR
#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 4.00                                                  *
*                                                                             *
*               Copyright (c) 1985-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x040A).  To exclude
*                   definitions introduced in version 4.1 (or above)
*                   #define WINVER 0x0300
*                   0x0310 or 0x0400 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
* NOIMT             Installable messge thunk APIs and definitions
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 4.0 */
#ifndef WINVER
#define WINVER  0x040A
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#define NOCOMM                      /* ;Internal */
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID        void

#define FAR         _far
#define NEAR        _near
#define PASCAL      _pascal
#define CDECL       _cdecl
#define CONST       const                           /* ;Internal */
                                                    /* ;Internal */
#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI      _loadds _far _pascal            /* ;Internal */
#define CALLBACK    _loadds _far _pascal            /* ;Internal */
/* Note that to use the BUILDDLL version of */      /* ;Internal */
/* WINCAPI, you must compile with -GD       */      /* ;Internal */
#define WINCAPI     _export _far _cdecl             /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI      _far _pascal
#define CALLBACK    _far _pascal
#define WINCAPI     _far _cdecl
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API         WINAPI                          /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int             BOOL;
#define FALSE           0
#define TRUE            1

typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef WORD            WCHAR;

typedef unsigned int    UINT;

#ifdef STRICT
typedef signed long     LONG;
#else
#define LONG            long
#endif

typedef short           SHORT;
typedef unsigned long   ULONG;

#define LOBYTE(w)       ((BYTE)(w))
#define HIBYTE(w)       ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)       ((WORD)(DWORD)(l))
#define HIWORD(l)       ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high)     ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT            WPARAM;
typedef LONG            LPARAM;
typedef LONG            LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL            0
#endif

typedef char NEAR*      PSTR;
typedef char NEAR*      NPSTR;

#define SZ char                         /* ;Internal */
                                        /* ;Internal */
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;

typedef BYTE NEAR*      PBYTE;
typedef BYTE FAR*       LPBYTE;
typedef const BYTE FAR* LPCBYTE;

typedef WCHAR FAR *     LPWSTR;
typedef const WCHAR FAR* LPCWSTR;

typedef int NEAR*       PINT;
typedef int FAR*        LPINT;

typedef BOOL NEAR*      PBOOL;
typedef BOOL FAR*       LPBOOL;


typedef WORD NEAR*      PWORD;
typedef WORD FAR*       LPWORD;

typedef long NEAR*      PLONG;
typedef long FAR*       LPLONG;

typedef DWORD NEAR*     PDWORD;
typedef DWORD FAR*      LPDWORD;

typedef void FAR*       LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*         PHANDLE;
typedef HANDLE NEAR*    SPHANDLE;
typedef HANDLE FAR*     LPHANDLE;

typedef HANDLE          HGLOBAL;
typedef HANDLE          HLOCAL;

typedef HANDLE          GLOBALHANDLE;
typedef HANDLE          LOCALHANDLE;

typedef UINT            ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */
typedef DWORD HKL;                                   

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

#if (WINVER >= 0x0400)
typedef struct tagOSVERSIONINFO {
     	DWORD dwOSVersionInfoSize;
     	DWORD dwMajorVersion;
     	DWORD dwMinorVersion;
     	DWORD dwBuildNumber;
     	DWORD dwPlatformId;
	char  szCSDVersion[128];
} OSVERSIONINFO, NEAR *POSVERSIONINFO, FAR *LPOSVERSIONINFO;

#define VER_PLATFORM_WIN32s    		0
#define VER_PLATFORM_WIN32_WINDOWS	1
#define VER_PLATFORM_WIN32_NT		2

BOOL WINAPI GetVersionEx(LPOSVERSIONINFO lpBuffer);

UINT    WINAPI GetProductName(LPSTR, UINT);
#endif  /* WINVER >= 0x0400 */

#if (WINVER >= 0x0400)
#define GFS_PHYSICALRAMSIZE   0x1793
#define GFS_NEARESTMEGRAMSIZE 0x1794
#endif  /* WINVER >= 0x0400 */
DWORD   WINAPI GetFreeSpace(UINT);

UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#if (WINVER < 0x030a)
#define WF_LARGEFRAME   0x0100
#define WF_SMALLFRAME   0x0200
#endif
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_DOSPAGING    0x1000
#define WF_HASCPUID     0x2000
#define WF_WINNT        0x4000
#define WF_WLO          0x8000
#define WF_CPUMASK      0xFC000000
#define WF_CPU_X86	0
#define WF_CPU_R4000	1
#define WF_CPU_ALPHA	2
#define WF_CPU_CLIPPER	3


LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING     0x8000
#define ERR_PARAM       0x4000

/* Internal error value masks */    /* ;Internal */
#define ERR_TYPE_MASK   0x0fff      /* ;Internal */
#define ERR_FLAGS_MASK  0xc000      /* ;Internal */
                                    /* ;Internal */
#define ERR_SIZE_MASK   0x3000
#define ERR_SIZE_SHIFT  12          /* ;Internal */
#define ERR_BYTE        0x1000
#define ERR_WORD        0x2000
#define ERR_DWORD       0x3000
                                                                        /* ;Internal */
// Error option flags (set by [kernel] ErrorOptions win.ini variable)   /* ;Internal */
                                                                        /* ;Internal */
#define ERO_PARAM_ERROR_BREAK   0x0001                                  /* ;Internal */
#define ERO_BUFFER_FILL         0x0002                                  /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE       0x6001
#define ERR_BAD_FLAGS       0x6002
#define ERR_BAD_INDEX       0x6003
#define ERR_BAD_DVALUE      0x7004
#define ERR_BAD_DFLAGS      0x7005
#define ERR_BAD_DINDEX      0x7006
#define ERR_BAD_PTR         0x7007
#define ERR_BAD_FUNC_PTR    0x7008
#define ERR_BAD_SELECTOR    0x6009
#define ERR_BAD_STRING_PTR  0x700a
#define ERR_BAD_HANDLE      0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069
#define ERR_BAD_HDCEMF          0x606A  /* ;Internal */
#define ERR_BAD_HEMF            0x606B  /* ;Internal */
                                        /* ;Internal */
/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
#if (WINVER >= 0x0400)
    WORD    chDefRIP;
#endif /* WINVER >= 0x0400 */
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS             0x0001
#define WDI_FILTER              0x0002
#define WDI_ALLOCBREAK          0x0004
#define WDI_DEFRIP              0x0008
#define WDI_VALID               0x00015  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP           0x0001
#define DBO_BUFFERFILL          0x0004
#define DBO_DISABLEGPTRAPPING   0x0010
#define DBO_CHECKFREE           0x0020

#define DBO_SILENT              0x8000

#define DBO_TRACEBREAK          0x2000
#define DBO_WARNINGBREAK        0x1000
#define DBO_NOERRORBREAK        0x0800
#define DBO_NOFATALBREAK        0x0400
#define DBO_INT3BREAK           0x0100

/* DebugOutput flags values */
#define DBF_TRACE               0x0000
#define DBF_WARNING             0x4000
#define DBF_ERROR               0x8000
#define DBF_FATAL               0xc000
#define DBF_SEVMASK             0xc000  /* ;Internal */
#define DBF_FILTERMASK          0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL              0x1000
#define DBF_KRN_MEMMAN          0x0001
#define DBF_KRN_LOADMODULE      0x0002
#define DBF_KRN_SEGMENTLOAD     0x0004
#define DBF_USER                0x0800
#define DBF_GDI                 0x0400
#define DBF_MMSYSTEM            0x0040
#define DBF_PENWIN              0x0020
#define DBF_APPLICATION         0x0008
#define DBF_DRIVER              0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42

#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM         0x43
#define EW_EXITANDEXECAPP       0x44   /* ;Internal */
BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

#define EWX_LOGOFF   0      // ;Internal 4.0
#define EWX_SHUTDOWN 1      // ;Internal 4.0
#define EWX_REBOOT   2      // ;Internal 4.0
#define EWX_FORCE    4      // ;Internal 4.0
#define EWX_POWEROFF 8      // ;Internal 4.0
#define EWX_REALLYLOGOFF 0x80000000   // ;Internal 4.0

#if (WINVER >= 0x0400)                              // ;Internal 
BOOL    SaveDesktopState(DWORD, DWORD, DWORD);      // ;Internal
#define SAVEDESKTOPSTATEN_EXITWINDOWS 1             // ;Internal
#define SAVEDESKTOPSTATEN_SHUTDOWN    2             // ;Internal
#define SAVEDESKTOPSTATEN_SUSPEND     3             // ;Internal
                                                    // ;Internal
#define SAVEDESKTOPSTATEF_NOPROMPT    1             // ;Internal
#endif /* WINVER >= 0x0400 */                       // ;Internal
                                                    // ;Internal
void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004          // ;Internal NT only
#define SEM_NOOPENFILEERRORBOX      0x8000

UINT    WINAPI SetErrorMode(UINT);

#if (WINVER >= 0x0400)
void    WINAPI SetLastError(DWORD);
DWORD   WINAPI GetLastError(void);
#endif /* WINVER >= 0x0400 */


/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);

#if (WINVER >= 0x0400)
void    WINAPI ProfStart32(void);
void    WINAPI ProfStop32(void);
void    WINAPI ProfClear32(void);
void    WINAPI ProfFlush32(void);
void    WINAPI ProfFinish32(void);
#endif /* WINVER >= 0x0400) */
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);     /* ;Internal */
                                            /* ;Internal */
HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

#if (WINVER >= 0x0400)					/* ;Internal */
BOOL    WINAPI GetModuleName(HINSTANCE, LPSTR, int);	/* ;Internal */
#endif /* WINVER >= 0x0400 */				/* ;Internal */
							/* ;Internal */
FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE NEAR *, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT    offSegment;
    UINT    cbSegment;
    UINT    flags;
    UINT    cbAlloc;
    HGLOBAL h;
    UINT    alignShift;
    UINT    reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL 0

/****** Task Management *****************************************************/

#endif /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);        // ;Internal
                                                // ;Internal
/* GetAppCompatFlags flag values */             // ;Internal
#define GACF_IGNORENODISCARD    0x00000001      // ;Internal
#define GACF_FORCETEXTBAND      0x00000002      // ;Internal
#define GACF_ONELANDGRXBAND     0x00000004      // ;Internal
#define GACF_DISABLEWIDEFONT    0x00000008      // ;Internal new bit for PSCRIPT
#define GACF_CALLTTDEVICE       0x00000010      // ;Internal
#define GACF_MULTIPLEBANDS      0x00000020      // ;Internal
#define GACF_ALWAYSSENDNCPAINT  0x00000040      // ;Internal
#define GACF_STUPIDPALETTEAPP   0x00000080      // ;Internal
#define GACF_MOREEXTRAWNDWORDS  0x00000100      // ;Internal
#define GACF_TTIGNORERASTERDUPE 0x00000200      // ;Internal
#define GACF_GLOBALHOOKSONLY16  0x00000400      // ;Internal
#define GACF_DELAYHWHNDSHAKECHK 0x00000800      // ;Internal
#define GACF_ENUMHELVNTMSRMN    0x00001000      // ;Internal
#define GACF_ENUMTTNOTDEVICE    0x00002000      // ;Internal
#define GACF_SUBTRACTCLIPSIBS   0x00004000      // ;Internal
#define GACF_FORCETTGRAPHICS    0x00008000      // ;Internal
#define GACF_NOHRGN1            0x00010000      // ;Internal
#define GACF_NCCALCSIZEONMOVE   0x00020000      // ;Internal
#define GACF_SENDMENUDBLCLK     0x00040000      // ;Internal not needed anymore
#define GACF_MODULESPECIFIC     0x00040000      // ;Internal replaces sendmenudblclk
#define GACF_30AVGWIDTH         0x00080000      // ;Internal
#define GACF_GETDEVCAPSNUMLIE   0x00100000      // ;Internal NT only
/* New flags for Win 4.0. */                    // ;Internal
#define GACF_IGNOREDIBWIDTH     0x00100000      // ;Internal re-use GACF_DEVCAPSNUMLIE
#define GACF_WINVER31           0x00200000      // ;Internal
#define GACF_INCREASESTACK      0x00400000      // ;Internal
#define GACF_HEAPSLACK		    0x00400000	    // ;Internal
#define GACF_FAFORCEDRAWBG      0x00400000      // ;Internal Used in FE only
#define GACF_FORCEWIN31DEVMODESIZE   0x00800000      // ;Internal (replaces PEEKMESSAGEIDLE)
#define GACF_31VALIDMASK        0xFFE484AF      // ;Internal
#define GACF_DISABLEFONTASSOC   0x01000000      // ;Internal Used in FE only
#define GACF_JAPANESCAPEMENT    0x01000000      // ;Internal Used in FE only
#define GACF_IGNOREFAULTS	    0x02000000      // ;Internal

#define GACF_DEQUOTIFYCMDLINE	0x02000000	// ;Internal
#define GACF_NOEMFSPOOLING      0x04000000      // ;Internal
#define GACF_RANDOM3XUI         0x08000000      // ;Internal
#define GACF_USEPRINTINGESCAPES 0x00000004      // ;Internal re-use GACF_ONELANDGRXBAND
#define GACF_FORCERASTERMODE    0x00008000      // ;Internal re-use GACF_FORCETTGRAPHICS
#define GACF_FORCEREGPASSTHRU   0x00008000      // ;Internal re-use GACF_FORCERASTERMODE
#define GACF_DONTJOURNALATTACH  0x10000000      // ;Internal
#define GACF_DISABLEDBCSPROPTT  0x20000000      // ;Internal Used in FE only
#define GACF_NOBRUSHCACHE       0x20000000      // ;Internal re-use GACF_DISABLEDBCSPROPTT 
#define GACF_55MSSYSTEMTIMER    0x20000000      // ;Internal re-use GACF_NOBRUSHCACHE since this is just used for some games and is system wide too
#define GACF_MIRRORREGFONTS     0x40000000      // ;Internal
#define GACF_UNUSED3            0x80000000      // ;Internal

/* Module Compatibility flag values */          // ;Internal
#define MCF_FIXEDSEGLOW         0x0001 // ;Internal Win31 behaviour for FIXED segs
#define MCF_MODPATCH            0x0002 // ;Internal has module patches
#define MCF_NODISCARD           0x0004 // ;Internal make all segments in the module not discardable

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED     0x4000
#define GMEM_LOCKCOUNT     0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);
#if (WINVER >= 0x0400)                      
UINT    WINAPI GlobalSmartPageLock(HGLOBAL);
UINT    WINAPI GlobalSmartPageUnlock(HGLOBAL);
#endif /* WINVER >= 0x0400 */		      

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)  /* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)  /* ;Internal */
                                                    /* ;Internal */
#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED     0x4000
#define LMEM_LOCKCOUNT     0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);
                                                                /* ;Internal */
/* LocalNotify callback */                                      /* ;Internal */
#ifdef STRICT                                                   /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*); /* ;Internal */
#else                                                           /* ;Internal */
typedef FARPROC LNOTIFYPROC;                                    /* ;Internal */
#endif                                                          /* ;Internal */
                                                                /* ;Internal */
#define LNOTIFY_OUTOFMEM    0                                   /* ;Internal */
#define LNOTIFY_MOVE        1                                   /* ;Internal */
#define LNOTIFY_DISCARD     2                                   /* ;Internal */
                                                                /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                    /* ;Internal */
                                                                /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

#if (WINVER >= 0x0400)
/* OpenFileEx() Structure */
typedef struct tagOFSTRUCTEX
{
    WORD nBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[260];
} OFSTRUCTEX;
typedef OFSTRUCTEX*       POFSTRUCTEX;
typedef OFSTRUCTEX NEAR* NPOFSTRUCTEX;
typedef OFSTRUCTEX FAR*  LPOFSTRUCTEX;
#endif  /* WINVER >= 0x0400 */

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400  /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400  /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
#if (WINVER >= 0x0400)
HFILE   WINAPI OpenFileEx(LPCSTR, OFSTRUCTEX FAR*, UINT);
#endif  /* WINVER >= 0x0400 */

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ                0
#define WRITE               1
#define READ_WRITE          2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long WINAPI _hread(HFILE, void _huge*, long);
long WINAPI _hwrite(HFILE, const void _huge*, long);
#endif /* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);      /* ;Internal */
                                            /* ;Internal */
#endif /* NOLFILEIO */

#if (WINVER >= 0x0400)
DWORD   WINAPI GetCurrentDirectory(DWORD, LPSTR);
BOOL    WINAPI SetCurrentDirectory(LPCSTR);

#define MAX_PATH 260

#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, NEAR *PFILETIME, FAR *LPFILETIME;

typedef struct _WIN32_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char   cFileName[ MAX_PATH ];
    char   cAlternateFileName[ 14 ];
} WIN32_FIND_DATA, NEAR *PWIN32_FIND_DATA, FAR *LPWIN32_FIND_DATA;

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100
#define FILE_ATTRIBUTE_ATOMIC_WRITE     0x00000200
#define FILE_ATTRIBUTE_XACTION_WRITE    0x00000400

DECLARE_HANDLE32(HFINDFILE);
#define INVALID_HFINDFILE       ((HFINDFILE)-1)

HFINDFILE WINAPI FindFirstFile(LPCSTR, LPWIN32_FIND_DATA);
BOOL      WINAPI FindNextFile(HFINDFILE, LPWIN32_FIND_DATA);
BOOL      WINAPI FindClose(HFINDFILE);

DWORD     WINAPI GetFileAttributes(LPCSTR);
BOOL      WINAPI SetFileAttributes(LPCSTR, DWORD);
BOOL      WINAPI GetDiskFreeSpace(LPCSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
BOOL      WINAPI CreateDirectory(LPCSTR, LPVOID);
BOOL      WINAPI RemoveDirectory(LPCSTR);
BOOL      WINAPI DeleteFile(LPCSTR);
#endif /* WINVER >= 0x0400 */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE     (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS          0x0000
#define WN_NOT_SUPPORTED    0x0001
#define WN_NET_ERROR        0x0002
#define WN_MORE_DATA        0x0003
#define WN_BAD_POINTER      0x0004
#define WN_BAD_VALUE        0x0005
#define WN_BAD_PASSWORD     0x0006
#define WN_ACCESS_DENIED    0x0007
#define WN_FUNCTION_BUSY    0x0008
#define WN_WINDOWS_ERROR    0x0009
#define WN_BAD_USER         0x000A
#define WN_OUT_OF_MEMORY    0x000B
#define WN_CANCEL           0x000C
#define WN_CONTINUE         0x000D

/* Connection errors */
#define WN_NOT_CONNECTED    0x0030
#define WN_OPEN_FILES       0x0031
#define WN_BAD_NETNAME      0x0032
#define WN_BAD_LOCALNAME    0x0033
#define WN_ALREADY_CONNECTED    0x0034
#define WN_DEVICE_ERROR         0x0035
#define WN_CONNECTION_CLOSED    0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)     GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR       MAKEINTRESOURCE(1)
#define RT_BITMAP       MAKEINTRESOURCE(2)
#define RT_ICON         MAKEINTRESOURCE(3)
#define RT_MENU         MAKEINTRESOURCE(4)
#define RT_DIALOG       MAKEINTRESOURCE(5)
#define RT_STRING       MAKEINTRESOURCE(6)
#define RT_FONTDIR      MAKEINTRESOURCE(7)
#define RT_FONT         MAKEINTRESOURCE(8)
#define RT_ACCELERATOR  MAKEINTRESOURCE(9)
#define RT_RCDATA       MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE MAKEINTRESOURCE(11)     // reserved: NT   ;Internal
#define RT_GROUP_CURSOR MAKEINTRESOURCE(12)
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype   ;Internal
#define RT_GROUP_ICON   MAKEINTRESOURCE(14)
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1    ;Internal
#define RT_VERSION      MAKEINTRESOURCE(16)     // reserved: NT   ;Internal
#define RT_DLGINCLUDE   MAKEINTRESOURCE(17)     // reserved: NT   ;Internal
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype ;Internal
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)
#define RT_LAST         MAKEINTRESOURCE(20)     // ;Internal
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX     ;Internal
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX     ;Internal

#endif  /* NORESOURCE */


#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_NWPEN           32631   // ;Internal 4.0
#define OCR_SIZE            32640   /* OBSOLETE; use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE; use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE; use OIC_WINLOGO */
#define OCR_NO              32648   
#define OCR_APPSTARTING	    32650   // ;Internal NT 4.0
#if (WINVER >= 0x0400)
#define OCR_HELP            32651   // ;Internal 4.0
#endif  /* WINVER >= 0x400 */

/* Default IDs to get original image from User */   // ;Internal
#define OCR_CONFIGURABLE_FIRST  100 // ;Internal
#define OCR_ARROW_DEFAULT       100 // ;Internal
#define OCR_IBEAM_DEFAULT       101 // ;Internal
#define OCR_WAIT_DEFAULT        102 // ;Internal
#define OCR_CROSS_DEFAULT       103 // ;Internal
#define OCR_UPARROW_DEFAULT     104 // ;Internal
#define OCR_SIZENWSE_DEFAULT    105 // ;Internal
#define OCR_SIZENESW_DEFAULT    106 // ;Internal
#define OCR_SIZEWE_DEFAULT      107 // ;Internal
#define OCR_SIZENS_DEFAULT      108 // ;Internal
#define OCR_SIZEALL_DEFAULT     109 // ;Internal
#define OCR_NO_DEFAULT          110 // ;Internal
#define OCR_APPSTARTING_DEFAULT 111 // ;Internal
#define OCR_HELP_DEFAULT        112 // ;Internal
#define OCR_NWPEN_DEFAULT       113 // ;Internal
#define OCR_ICON_DEFAULT        114 // ;Internal
#define OCR_CONFIGURABLE_LAST   OCR_ICON_DEFAULT   // ;Internal
#define COCR_CONFIGURABLE       (OCR_CONFIGURABLE_LAST-OCR_CONFIGURABLE_FIRST+1)    // ;Internal

#define OIC_SAMPLE              32512
#define OIC_ERROR               32513
#define OIC_QUES                32514
#define OIC_WARNING             32515
#define OIC_INFORMATION         32516
#define OIC_WINLOGO             32517   // ;Internal NT

#define OIC_HAND                OIC_ERROR
#define OIC_BANG                OIC_WARNING
#define OIC_NOTE                OIC_INFORMATION

/* Default IDs to get original image from User */   // ;Internal
#define OIC_CONFIGURABLE_FIRST  100 // ;Internal
#define OIC_APPLICATION_DEFAULT 100 // ;Internal
#define OIC_WARNING_DEFAULT     101 // ;Internal
#define OIC_QUESTION_DEFAULT    102 // ;Internal
#define OIC_ERROR_DEFAULT       103 // ;Internal
#define OIC_INFORMATION_DEFAULT 104 // ;Internal
#define OIC_WINLOGO_DEFAULT     105 // ;Internal
#define OIC_CONFIGURABLE_LAST   OIC_WINLOGO_DEFAULT // ;Internal
#define COIC_CONFIGURABLE       (OIC_CONFIGURABLE_LAST-OIC_CONFIGURABLE_FIRST+1)    // ;Internal

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#if (WINVER >= 0x0400)
BOOL    WINAPI GetPrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
BOOL    WINAPI WritePrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
UINT    WINAPI GetProfileSectionNames(LPSTR, UINT);
UINT    WINAPI GetPrivateProfileSectionNames(LPSTR, UINT, LPCSTR);
int     WINAPI GetPrivateProfileSection(LPCSTR, LPSTR, UINT, LPCSTR);
int     WINAPI GetProfileSection(LPCSTR, LPSTR, UINT);
BOOL    WINAPI WritePrivateProfileSection(LPCSTR, LPCSTR, LPCSTR);
BOOL    WINAPI WriteProfileSection(LPCSTR, LPCSTR);
#endif /* WINVER >= 0x0400 */

/****** Registration Database Support ***************************************/
/* return codes from Registration functions */
/* Retained for win 3.x compatibility  and not needed 4.0 onwards */
/* For 4.0 onwards you should be including winerror.h */

#if (WINVER < 0x0400)

#define ERROR_SUCCESS			0L
#define ERROR_BADDB                     1L
#define ERROR_BADKEY			2L
#define ERROR_CANTOPEN			3L
#define ERROR_CANTREAD			4L
#define ERROR_CANTWRITE			5L
#define ERROR_INSUFFICIENT_MEMORY	6L
#define ERROR_INVALID_PARAMETER         7L
#define	ERROR_ACCESS_DENIED		8L

#endif /* WINVER < 0x400 */

#define REG_SZ				0x0001

#if (WINVER >= 0x0400)
#define REG_BINARY			0x0003
#define REG_DWORD                       0x0004
#endif

typedef DWORD HKEY;
typedef HKEY FAR* LPHKEY;

#if (WINVER < 0x0400)		// Win 3.1 compatibility
#define HKEY_CLASSES_ROOT		(( HKEY) 0x1)
#else				// Win 4 upwards
#define HKEY_CLASSES_ROOT		(( HKEY) 0x80000000)
#define HKEY_CURRENT_USER		(( HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE		(( HKEY) 0x80000002)
#define HKEY_USERS			(( HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA		(( HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG		(( HKEY) 0x80000005)
#define HKEY_DYN_DATA			(( HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS		7
#endif

LONG    WINAPI RegOpenKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCreateKey(HKEY, LPCSTR, LPHKEY);
LONG    WINAPI RegCloseKey(HKEY);
LONG    WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG    WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG    WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG    WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

#if (WINVER >= 0x0400)
LONG    WINAPI RegDeleteValue(HKEY, LPCSTR);
LONG    WINAPI RegEnumValue(HKEY, DWORD, LPCSTR,
                         LONG FAR *, DWORD, LONG FAR *, LPBYTE,
                         LONG FAR *);
LONG    WINAPI RegQueryValueEx(HKEY, LPCSTR, LONG FAR *, LONG FAR *,
			    LPBYTE, LONG FAR *);
LONG    WINAPI RegSetValueEx(HKEY, LPCSTR, DWORD, DWORD, LPBYTE, DWORD);
LONG    WINAPI RegFlushKey(HKEY);
LONG	WINAPI RegSaveKey(HKEY, LPCSTR,LPVOID);
LONG	WINAPI RegLoadKey(HKEY, LPCSTR,LPCSTR);
LONG	WINAPI RegUnLoadKey(HKEY, LPCSTR);

#endif		// WINVER >= 0x0400

/****** International & Char Translation Support ****************************/

//                                                                  ;Internal
// BOOL WINAPI  CharToOem(LPCSTR, LPSTR);               /* NT */ ;Internal
// BOOL WINAPI  OemToChar(LPCSTR, LPSTR);               /* NT */ ;Internal
//                                                                  ;Internal
void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

//                                                                  ;Internal
// BOOL WINAPI  CharToOemBuff(LPCSTR, LPSTR, UINT);     /* NT */ ;Internal
// BOOL WINAPI  OemToCharBuff(LPCSTR, LPSTR, DWORD);    /* NT */ ;Internal
//                                                                  ;Internal
void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

//                                                                  ;Internal
// LPSTR WINAPI CharNext(LPCSTR);                       /* NT */ ;Internal
// LPSTR WINAPI CharPrev(LPCSTR, LPCSTR);               /* NT */ ;Internal
//                                                                  ;Internal
LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

//                                                                  ;Internal
// LPSTR WINAPI CharUpper(LPSTR);                       /* NT */ ;Internal
// LPSTR WINAPI CharLower(LPSTR);                       /* NT */ ;Internal
//                                                                  ;Internal
LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

//                                                                  ;Internal
// LPSTR WINAPI CharUpperBuff(LPSTR, WORD);             /* NT */ ;Internal
// LPSTR WINAPI CharLowerBuff(LPSTR, WORD);             /* NT */ ;Internal
//                                                                  ;Internal
UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */   // ;Internal
#define ORD_LANGDRIVER   1                  // ;Internal
                                            // ;Internal
#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, DWORD);
#if (WINVER >= 0x0400)
LPSTR   WINAPI lstrcatn(LPSTR, LPCSTR, int);
#endif /* WINVER >= 0x0400 */
#endif /* WINVER >= 0x030a */
#endif /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

#if (WINVER >= 0x0400)                                  /* ;Internal NT */
#define FORMAT_MESSAGE_ALLOCATE_BUFFER  0x00000100      /* ;Internal NT */
#define FORMAT_MESSAGE_IGNORE_INSERTS   0x00000200      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_STRING      0x00000400      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_HMODULE     0x00000800      /* ;Internal NT */
#define FORMAT_MESSAGE_FROM_SYSTEM      0x00001000      /* ;Internal NT */
//#define FORMAT_MESSAGE_ARGUMENT_ARRAY   0x00002000      /* ;Internal */
#define FORMAT_MESSAGE_MAX_WIDTH_MASK   0x000000FF      /* ;Internal NT */
#define FORMAT_MESSAGE_VALID            0x00003FFF      /* ;Internal */
                                                                                    /* ;Internal NT */
UINT FAR PASCAL FormatMessage(DWORD, LPVOID, UINT, UINT, LPSTR, UINT, LPDWORD);     /* ;Internal NT */
#endif /* WINVER >= 0x0400 */                           /* ;Internal NT */

/****** Keyboard Driver Functions *******************************************/


#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
UINT    WINAPI VkKeyScanEx(UINT,HKL);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
UINT    WINAPI MapVirtualKeyEx(UINT,UINT,HKL);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);
int     WINAPI ToAsciiEx(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags,HKL hkl);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;
typedef const RECT FAR * LPCRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;
typedef const POINT FAR * LPCPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Common structures for 4.X/Win32 GDI APIs */

typedef struct tagPOINTS
{
   SHORT    x;
   SHORT    y;

} POINTS;
typedef POINTS*       PPOINTS;
typedef POINTS NEAR*  NPPOINTS;
typedef POINTS FAR*   LPPOINTS;
typedef const POINTS FAR* LPCPOINTS;

typedef struct tagPOINTL
{
   LONG     x;
   LONG     y;

} POINTL;
typedef POINTL*       PPOINTL;
typedef POINTL NEAR*  NPPOINTL;
typedef POINTL FAR*   LPPOINTL;
typedef const POINTL FAR* LPCPOINTL;

typedef struct tagSIZEL
{
   LONG     cx;
   LONG     cy;

} SIZEL;
typedef SIZEL*       PSIZEL;
typedef SIZEL NEAR*  NPSIZEL;
typedef SIZEL FAR*   LPSIZEL;
typedef const SIZEL FAR* LPCSIZEL;

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
                       
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;
                                                               /* ;Internal */
typedef struct tagXFORM /* SDK transform of IEEE floats. */    /* ;Internal */
{                                                              /* ;Internal */
    float   eM11;                                              /* ;Internal */
    float   eM12;                                              /* ;Internal */
    float   eM21;                                              /* ;Internal */
    float   eM22;                                              /* ;Internal */
    float   eDx;                                               /* ;Internal */
    float   eDy;                                               /* ;Internal */
                                                               /* ;Internal */
} XFORM;                                                       /* ;Internal */
typedef XFORM*       PXFORM;                                   /* ;Internal */
typedef XFORM NEAR*  NPXFORM;                                  /* ;Internal */
typedef XFORM FAR*   LPXFORM;                                  /* ;Internal */
typedef const XFORM FAR* LPCXFORM;                             /* ;Internal */
                                                               /* ;Internal */
#endif /* WINVER >= 0x0400 */

#define MAKEPOINT(l)     (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, LPCRECT lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, LPRECT lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR   0x8000                              /* ;Internal */
                                                            /* ;Internal */
/* Internal SelectBitmap stuff */                           /* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/      /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90
#define CAPS1         94    // ;Internal

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100
#define CC_POLYBEZIER       0x0200     /* ;Internal */

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080
#define PC_POLYPOLYGON      0x0100
#define PC_PATHS            0x0200

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

/* CAPS1 */                         // ;Internal
#define C1_TRANSPARENT 	    0x0001  // ;Internal 
#define TC_TT_ABLE	        0x0002  // ;Internal
#define C1_TT_CR_ANY	    0x0004  // ;Internal
#define C1_EMF_COMPLIANT    0x0008  // ;Internal
#define C1_DIBENGINE	    0x0010  // ;Internal
#define C1_GAMMA_RAMP	    0x0020  // ;Internal
#define C1_DIC		        0x0040  // ;Internal
#define C1_REINIT_ABLE      0x0080  // ;Internal
#define C1_GLYPH_INDEX      0x0100  // ;Internal
#define C1_BIT_PACKED       0x0200  // ;Internal
#define C1_BYTE_PACKED      0x0400  // ;Internal
#define C1_COLORCURSOR      0x0800  // ;Internal
#define C1_CMYK_ABLE        0x1000  // ;Internal
#define C1_SLOW_CARD        0x2000  // ;Internal

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT         1
#define MM_LOMETRIC     2
#define MM_HIMETRIC     3
#define MM_LOENGLISH    4
#define MM_HIENGLISH    5
#define MM_TWIPS        6
#define MM_ISOTROPIC    7
#define MM_ANISOTROPIC  8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */
                                      /* ;Internal */
/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)      ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)  ((BYTE)(rgb))
#define GetGValue(rgb)  ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)  ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

HBRUSH   WINAPI GetSysColorBrush(int);
COLORREF WINAPI GetSysColor(int);
#ifdef tagWND   // ;Internal
BOOL     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*); // ;Internal
#else           // ;Internal
void     WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);
#endif          // ;Internal

#define COLOR_SCROLLBAR             0
#define COLOR_DESKTOP               1
#define COLOR_ACTIVECAPTION         2
#define COLOR_INACTIVECAPTION       3
#define COLOR_MENU                  4
#define COLOR_WINDOW                5
#define COLOR_WINDOWFRAME           6
#define COLOR_MENUTEXT              7
#define COLOR_WINDOWTEXT            8
#define COLOR_CAPTIONTEXT           9
#define COLOR_ACTIVEBORDER          10
#define COLOR_INACTIVEBORDER        11
#define COLOR_APPWORKSPACE          12
#define COLOR_HIGHLIGHT             13
#define COLOR_HIGHLIGHTTEXT         14
#define COLOR_3DFACE                15
#define COLOR_3DSHADOW              16
#define COLOR_GRAYTEXT              17
#define COLOR_BTNTEXT               18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT   19
#define COLOR_3DHILIGHT             20
#if (WINVER >= 0x0400)
#define COLOR_3DDKSHADOW            21
#define COLOR_3DLIGHT               22
#define COLOR_INFOTEXT              23
#define COLOR_INFOBK                24
#if (WINVER >= 0x40A)
#define COLOR_3DALTFACE             25
#define COLOR_HOTLIGHT              26
#define COLOR_ENDCOLORS             COLOR_HOTLIGHT   /* ;Internal */
#else                                          // ;Internal 4.1
#define COLOR_ENDCOLORS             COLOR_INFOBK   /* ;Internal */
#endif // (WINVER >= 0x40A)
#define COLOR_MAX                   (COLOR_ENDCOLORS+1) /* ;Internal */
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

#define COLOR_BACKGROUND            COLOR_DESKTOP
#define COLOR_BTNFACE               COLOR_3DFACE
#define COLOR_BTNSHADOW             COLOR_3DSHADOW
#define COLOR_BTNHIGHLIGHT          COLOR_3DHILIGHT

HANDLE WINAPI SetSysColorsTemp(COLORREF FAR *, HBRUSH FAR *, UINT); /* ;Internal */
#endif  /* NOCOLOR */

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN         1
#define OBJ_BRUSH       2

#if (WINVER >= 0x0400)

HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

#endif

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID        0
#define PS_DASH         1
#define PS_DOT          2
#define PS_DASHDOT      3
#define PS_DASHDOTDOT   4
#define PS_NULL         5
#define PS_INSIDEFRAME  6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN       6
#define BLACK_PEN       7
#define NULL_PEN        8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID        0
#define BS_NULL         1
#define BS_HOLLOW       BS_NULL
#define BS_HATCHED      2
#define BS_PATTERN      3
#define BS_INDEXED      4
#define BS_DIBPATTERN   5

/* Hatch Styles */
#define HS_HORIZONTAL   0
#define HS_VERTICAL     1
#define HS_FDIAGONAL    2
#define HS_BDIAGONAL    3
#define HS_CROSS        4
#define HS_DIAGCROSS    5
#define HS_API_MAX      6

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH        PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH    0
#define LTGRAY_BRUSH   1
#define GRAY_BRUSH     2
#define DKGRAY_BRUSH   3
#define BLACK_BRUSH    4
#define NULL_BRUSH     5
#define HOLLOW_BRUSH   NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(LPCPOINT, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(LPCPOINT, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR           0
#define NULLREGION      1
#define SIMPLEREGION    2
#define COMPLEXREGION   3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND         1
#define RGN_OR          2
#define RGN_XOR         3
#define RGN_DIFF        4
#define RGN_COPY        5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, LPRECT);

BOOL    WINAPI RectInRegion(HRGN, LPCRECT);
BOOL    WINAPI PtInRegion(HRGN, int, int);

#if (WINVER >= 0x0400)                                         /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
/* structures for ExtCreateRegion / GetRegionData APIs */      /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
typedef struct tagRGNDATAHEADER {                              /* ;Internal 4.0 */
   DWORD   dwSize;                                             /* ;Internal 4.0 */
   DWORD   iType;                                              /* ;Internal 4.0 */
   DWORD   nCount;                                             /* ;Internal 4.0 */
   DWORD   nRgnSize;                                           /* ;Internal 4.0 */
   RECTL   rcBound;                                            /* ;Internal 4.0 */
} RGNDATAHEADER;                                               /* ;Internal 4.0 */
typedef RGNDATAHEADER*       PRGNDATAHEADER;                   /* ;Internal 4.0 */
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;                  /* ;Internal 4.0 */
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;                  /* ;Internal 4.0 */
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;             /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
typedef struct tagRGNDATA {                                    /* ;Internal 4.0 */
   RGNDATAHEADER   rdh;                                        /* ;Internal 4.0 */
   char            Buffer[1];                                  /* ;Internal 4.0 */
} RGNDATA;                                                     /* ;Internal 4.0 */
typedef RGNDATA*       PRGNDATA;                               /* ;Internal 4.0 */
typedef RGNDATA NEAR*  NPRGNDATA;                              /* ;Internal 4.0 */
typedef RGNDATA FAR*   LPRGNDATA;                              /* ;Internal 4.0 */
typedef const RGNDATA FAR* LPCRGNDATA;                         /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
int     WINAPI ExtSelectClipRgn(HDC, HRGN, int);               /* ;Internal 4.0 */
DWORD   WINAPI GetRegionData(HRGN, DWORD, LPRGNDATA);          /* ;Internal 4.0 */
HRGN    WINAPI ExtCreateRegion(LPCXFORM, DWORD, LPCRGNDATA);   /* ;Internal 4.0 */
                                                               /* ;Internal 4.0 */
#endif   /* WINVER >= 0x0400 */                                /* ;Internal 4.0 */

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED 0x01 /* palette index used for animation */
#define PC_EXPLICIT 0x02 /* palette index is explicit to device */
#define PC_NOCOLLAPSE 0x04 /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, LPRECT);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, LPCRECT);

#if (WINVER >= 0x030a)                                                  /* ;Internal */
/* DC hook callback function */                                         /* ;Internal */
                                                                        /* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
                                                                        /* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);    /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);            /* ;Internal */
                                                                        /* ;Internal */
/* Callback reason code values */                                       /* ;Internal */
                                                                        /* ;Internal */
#define DCHC_INVALIDVISRGN  0x0001                                      /* ;Internal */
#define DCHC_DELETEDC       0x0002                                      /* ;Internal */
                                                                        /* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);                          /* ;Internal */
                                                                        /* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001                                    /* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002                                    /* ;Internal */
#endif  /* WINVER >= 0x030a */                                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, LPCPOINT, int);

#if (WINVER >= 0x0400)                                  /* ;Internal 4.0 */
BOOL    WINAPI PolyBezier(HDC, LPCPOINT, UINT);         /* ;Internal 4.0 */
BOOL    WINAPI PolyBezierTo(HDC, LPCPOINT, UINT);       /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI AbortPath(HDC);                          /* ;Internal 4.0 */
BOOL    WINAPI BeginPath(HDC);                          /* ;Internal 4.0 */
BOOL    WINAPI CloseFigure(HDC);                        /* ;Internal 4.0 */
BOOL    WINAPI EndPath(HDC);                            /* ;Internal 4.0 */
BOOL    WINAPI FillPath(HDC);                           /* ;Internal 4.0 */
BOOL    WINAPI FlattenPath(HDC);                        /* ;Internal 4.0 */
long    WINAPI GetPath(HDC, LPPOINTL, LPBYTE, long);    /* ;Internal 4.0 */
HRGN    WINAPI PathToRegion(HDC);                       /* ;Internal 4.0 */
BOOL    WINAPI SelectClipPath(HDC, int);                /* ;Internal 4.0 */
BOOL    WINAPI StrokeAndFillPath(HDC);                  /* ;Internal 4.0 */
BOOL    WINAPI StrokePath(HDC);                         /* ;Internal 4.0 */
BOOL    WINAPI WidenPath(HDC);                          /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
#define  PT_CLOSEFIGURE 0x01  /* GetPath byte flags */  /* ;Internal 4.0 */
#define  PT_LINETO      0x02                            /* ;Internal 4.0 */
#define  PT_BEZIERTO    0x04                            /* ;Internal 4.0 */
#define  PT_MOVETO      0x06                            /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                           /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, LPCPOINT, int);
BOOL    WINAPI PolyPolygon(HDC, LPCPOINT, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, LPCRECT, HBRUSH);
int     WINAPI FrameRect(HDC, LPCRECT, HBRUSH);
BOOL    WINAPI InvertRect(HDC, LPCRECT);

void    WINAPI DrawFocusRect(HDC, LPCRECT);
BOOL    WINAPI FastWindowFrame(HDC, LPCRECT, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, LPCRECT, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004
#define ETO_GLYPH_INDEX 0x0010
#define ETO_RTLREADING	0x0080

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_TOP              0x0000
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_EDITCONTROL      0x00002000
#define DT_PATH_ELLIPSIS    0x00004000  // ;Internal 4.0
#define DT_END_ELLIPSIS     0x00008000  // ;Internal 4.0
#define DT_MODIFYSTRING     0x00010000  // ;Internal 4.0
#define DT_RTLREADING       0x00020000  // ;Internal 4.0
#define DT_WORD_ELLIPSIS    0x00040000  // ;Internal 4.0
#define DT_VALID            0x0007ffff  // ;Internal: Union of all those above

int     WINAPI DrawText(HDC, LPCSTR, int, LPRECT, UINT);

#if (WINVER >= 0x0400)
typedef struct tagDRAWTEXTPARAMS
{
    DWORD   cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
}   DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;

int     WINAPI DrawTextEx(HDC, LPSTR, int, LPRECT, DWORD, LPDRAWTEXTPARAMS);
#endif /* WINVER >= 0x0400 */

#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

/* Monolithic state-drawing routine */

#if (WINVER >= 0x0400)
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_TEXTMAX     0x0002  /* ;Internal */
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004
#define DST_GLYPH       0x0005  /* ;Internal */
#define DST_TYPEMASK    0x0007  /* ;Internal */
#define DST_GRAYSTRING  0x0008  /* ;Internal */

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Old gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_DEFAULT     0x0040  // ;Internal BOGUS GOING AWAY
#define DSS_MONO        0x0080
#define DSS_RIGHT 		0x8000

#ifdef STRICT
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC, LPARAM, WPARAM, int, int);
#else
typedef FARPROC DRAWSTATEPROC;
#endif
BOOL    WINAPI DrawState(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#endif /* WINVER >= 0x0400 */

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP   0x0000
#define TA_UPDATECP     0x0001
#define TA_LEFT         0x0000
#define TA_RIGHT        0x0002
#define TA_CENTER       0x0006
#define TA_TOP          0x0000
#define TA_BOTTOM       0x0008
#define TA_BASELINE     0x0018
#define TA_RTLREADING   0x0100

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

/* Logical Font */
#define LF_FACESIZE     32

#ifndef NOGDIOBJ
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE     0
#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT        300
#define FW_NORMAL       400
#define FW_MEDIUM       500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_EXTRABOLD    800
#define FW_HEAVY        900

#define FW_ULTRALIGHT   FW_EXTRALIGHT
#define FW_REGULAR      FW_NORMAL
#define FW_DEMIBOLD     FW_SEMIBOLD
#define FW_ULTRABOLD    FW_EXTRABOLD
#define FW_BLACK        FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#if (WINVER >= 0x0400)
#define	MAC_CHARSET         77
#endif /* WINVER >= 0x0400 */
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define JOHAB_CHARSET       130
#define GB2312_CHARSET      134
#define CHINESEBIG5_CHARSET 136
#define GREEK_CHARSET		 161
#define TURKISH_CHARSET		 162
#define HEBREW_CHARSET		 177
#define ARABIC_CHARSET		 178
#define BALTIC_CHARSET      186
#define RUSSIAN_CHARSET		 204
#define THAI_CHARSET			 222
#define EASTEUROPE_CHARSET	 238
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2
#if (WINVER >= 0x400)
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
#endif  /* WINVER >= 0x400 */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02
#if (WINVER >= 0x400)
#define MONO_FONT           0x08
#endif

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16
#define DEFAULT_GUI_FONT    17

DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING    0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define GCP_DBCS           0x0001
#define GCP_REORDER        0x0002
#define GCP_USEKERNING     0x0008
#define GCP_GLYPHSHAPE     0x0010
#define GCP_LIGATE         0x0020
///#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC      0x0100
#define GCP_KASHIDA        0x0400
#define GCP_ERROR          0x8000
#define FLI_MASK           0x103B

#define GCP_JUSTIFY        0x00010000L
//#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS         0x00040000L
#define GCP_CLASSIN        0x00080000L	
#define GCP_MAXEXTENT      0x00100000L
#define GCP_JUSTIFYIN		 0x00200000L
#define GCP_DISPLAYZWG      0x00400000L
#define GCP_SYMSWAPOFF      0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN   0x04000000L
#define GCP_NUMERICSLOCAL   0x08000000L

#define GCPCLASS_LATIN                  1
#define GCPCLASS_HEBREW                 2
#define GCPCLASS_ARABIC                 2
#define GCPCLASS_NEUTRAL                3
#define GCPCLASS_LOCALNUMBER            4
#define GCPCLASS_LATINNUMBER            5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR  7
#define GCPCLASS_NUMERICSEPARATOR       8

#define GCPCLASS_PREBOUNDLTR		0x80
#define GCPCLASS_PREBOUNDRTL		0x40
#define GCPCLASS_POSTBOUNDLTR		0x20
#define GCPCLASS_POSTBOUNDRTL		0x10

#define GCPGLYPH_LINKBEFORE		0x8000
#define GCPGLYPH_LINKAFTER			0x4000

typedef struct 
	{
	DWORD 	lStructSize;
	LPSTR 	lpOutString;
	UINT FAR *lpOrder;
	int FAR  *lpDx;
	int FAR  *lpCaretPos; 
    LPSTR     lpClass;
	UINT FAR *lpGlyphs;
	UINT   	nGlyphs;    
	int		nMaxFit;
	} GCP_RESULTS, FAR* LPGCP_RESULTS;

DWORD WINAPI GetFontLanguageInfo( HDC );
DWORD WINAPI GetCharacterPlacement(HDC, LPCSTR, int, int, LPGCP_RESULTS, DWORD);
int     WINAPI GetTextFace(HDC, int, LPSTR);
int		WINAPI GetTextCharset(HDC);					 /* ;Internal 4.0 */

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif /* NOGDIOBJ */


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;


#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_VARIABLE_PITCH 0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08

/*
 * Yes, this looks bogus.  But it's because we got confused and named the
 * flag wrong.  LOGFONTs have an lfPitchAndFamily field, where FIXED_PITCH
 * is 0x01.  But TEXTMETRICs have a tmPitchAndFamily field, where
 * VARIABLE_PITCH is 0x01.  It's easy to confuse the two.  We're sorry.
*/
#define TMPF_FIXED_PITCH    TMPF_VARIABLE_PITCH

#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x0400)

#define PANOSE_COUNT               10
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9

#define PAN_CULTURE_LATIN           0

#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */

#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */

#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */

#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */

#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */

#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */

#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */

#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */

#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */

#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */

#endif   /* WINVER >= 0x0400 */

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* NOSCALABLEFONT */
#endif  /* WINVER >= 0x030a */


#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR 0x00000040L
#define NTM_BOLD 0x00000020L
#define NTM_ITALIC 0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
#if (WINVER >= 0x0400)
    char    elfScript[LF_FACESIZE];
#endif
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);
int     WINAPI EnumFontFamiliesEx(HDC, LPLOGFONT, FONTENUMPROC, LPARAM,DWORD);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);  /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2
#if (WINVER >= 0x0400)
#define	GGO_GRAY2_BITMAP   4
#define	GGO_GRAY4_BITMAP   5
#define	GGO_GRAY8_BITMAP   6
#endif /* WINVER >= 0x0400 */


#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE 0x0001
#define TT_ENABLED 0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB       0L
#define BI_RLE8      1L
#define BI_RLE4      2L
#define BI_BITFIELDS 3L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD      bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE      bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */                             /* ;Internal */
typedef struct tagPELARRAY                  /* ;Internal */
{                                           /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;                         /* ;Internal */
} PELARRAY;                                 /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */
                                            /* ;Internal */
HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

#if (WINVER >= 0x0400)                                                      /* ;Internal 4.0 */
HBITMAP WINAPI CreateDIBSection(HDC, CONST BITMAPINFO FAR*, UINT, LPVOID FAR*, DWORD, DWORD); /* ;Internal 4.0 */
UINT    WINAPI SetDIBColorTable(HDC, UINT, UINT, const RGBQUAD FAR *);      /* ;Internal 4.0 */
UINT    WINAPI GetDIBColorTable(HDC, UINT, UINT, LPRGBQUAD);                /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                                               /* ;Internal 4.0 */
                                                                            /* ;Internal 4.0 */
#ifdef tagWND       // ;Internal
HBITMAP WINAPI OwnerLoadBitmap(HINSTANCE, LPCSTR, HANDLE);  // ;Internal
#else               // ;Internal
HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);
#endif              // ;Internal

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATOR               0x00FA0089L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE 1
#define WHITEONBLACK 2
#define COLORONCOLOR 3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

//                                              ;Internal
// #define HALFTONE            4   /* NT */  ;Internal
// #define STRETCH_HALFSCANS   4   /* NT */  ;Internal
//                                              ;Internal

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR             0x0201
#define META_SETBKMODE              0x0102
#define META_SETMAPMODE             0x0103
#define META_SETROP2                0x0104
#define META_SETRELABS              0x0105
#define META_SETPOLYFILLMODE        0x0106
#define META_SETSTRETCHBLTMODE      0x0107
#define META_SETTEXTCHAREXTRA       0x0108
#define META_SETTEXTCOLOR           0x0209
#define META_SETTEXTJUSTIFICATION   0x020A
#define META_SETWINDOWORG           0x020B
#define META_SETWINDOWEXT           0x020C
#define META_SETVIEWPORTORG         0x020D
#define META_SETVIEWPORTEXT         0x020E
#define META_OFFSETWINDOWORG        0x020F
#define META_SCALEWINDOWEXT         0x0410
#define META_OFFSETVIEWPORTORG      0x0211
#define META_SCALEVIEWPORTEXT       0x0412
#define META_LINETO                 0x0213
#define META_MOVETO                 0x0214
#define META_EXCLUDECLIPRECT        0x0415
#define META_INTERSECTCLIPRECT      0x0416
#define META_ARC                    0x0817
#define META_ELLIPSE                0x0418
#define META_FLOODFILL              0x0419
#define META_PIE                    0x081A
#define META_RECTANGLE              0x041B
#define META_ROUNDRECT              0x061C
#define META_PATBLT                 0x061D
#define META_SAVEDC                 0x001E
#define META_SETPIXEL               0x041F
#define META_OFFSETCLIPRGN          0x0220
#define META_TEXTOUT                0x0521
#define META_BITBLT                 0x0922
#define META_STRETCHBLT             0x0B23
#define META_POLYGON                0x0324
#define META_POLYLINE               0x0325
#define META_ESCAPE                 0x0626
#define META_RESTOREDC              0x0127
#define META_FILLREGION             0x0228
#define META_FRAMEREGION            0x0429
#define META_INVERTREGION           0x012A
#define META_PAINTREGION            0x012B
#define META_SELECTCLIPREGION       0x012C
#define META_SELECTOBJECT           0x012D
#define META_SETTEXTALIGN           0x012E
#define META_DRAWTEXT               0x062F

#define META_CHORD                  0x0830
#define META_SETMAPPERFLAGS         0x0231
#define META_EXTTEXTOUT             0x0a32
#define META_SETDIBTODEV            0x0d33
#define META_SELECTPALETTE          0x0234
#define META_REALIZEPALETTE         0x0035
#define META_ANIMATEPALETTE         0x0436
#define META_SETPALENTRIES          0x0037
#define META_POLYPOLYGON            0x0538
#define META_RESIZEPALETTE          0x0139

#define META_DIBBITBLT              0x0940
#define META_DIBSTRETCHBLT          0x0b41
#define META_DIBCREATEPATTERNBRUSH  0x0142
#define META_STRETCHDIB             0x0f43

#define META_EXTFLOODFILL           0x0548

#define META_RESETDC                0x014C
#define META_STARTDOC               0x014D
#define META_STARTPAGE              0x004F
#define META_ENDPAGE                0x0050
#define META_ABORTDOC               0x0052
#define META_ENDDOC                 0x005E

#define META_DELETEOBJECT           0x01f0

#define META_CREATEPALETTE          0x00f7
#define META_CREATEBRUSH            0x00F8
#define META_CREATEPATTERNBRUSH     0x01F9
#define META_CREATEPENINDIRECT      0x02FA
#define META_CREATEFONTINDIRECT     0x02FB
#define META_CREATEBRUSHINDIRECT    0x02FC
#define META_CREATEBITMAPINDIRECT   0x02FD
#define META_CREATEBITMAP           0x06FE
#define META_CREATEREGION           0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Enhanced Metafile support *******************************************/               /* ;Internal 4.0 */
#if ((WINVER >= 0x0400) && !defined(NOGDI) && !defined(NOMETAFILE))                          /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef struct tagMRMETAFILE                                                                 /* ;Internal 4.0 */
{                                                                                            /* ;Internal 4.0 */
   DWORD    iType;                                                                           /* ;Internal 4.0 */
   DWORD    nSize;                                                                           /* ;Internal 4.0 */
   RECTL    rclBounds;                                                                       /* ;Internal 4.0 */
   RECTL    rclFrame;                                                                        /* ;Internal 4.0 */
   DWORD    dSignature;                                                                      /* ;Internal 4.0 */
   DWORD    nVersion;                                                                        /* ;Internal 4.0 */
   DWORD    nBytes;                                                                          /* ;Internal 4.0 */
   DWORD    nRecords;                                                                        /* ;Internal 4.0 */
   WORD     nHandles;                                                                        /* ;Internal 4.0 */
   WORD     sReserved;                                                                       /* ;Internal 4.0 */
   DWORD    nDescription;                                                                    /* ;Internal 4.0 */
   DWORD    offDescription;                                                                  /* ;Internal 4.0 */
   DWORD    nPalEntries;                                                                     /* ;Internal 4.0 */
   SIZEL    szlDevice;                                                                       /* ;Internal 4.0 */
   SIZEL    szlMillimeters;                                                                  /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
} MRMETAFILE, NEAR* PMRMETAFILE, FAR* LPMRMETAFILE;                                          /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef struct tagENHMETARECORD                                                              /* ;Internal 4.0 */
{                                                                                            /* ;Internal 4.0 */
    DWORD   iType;                                                                           /* ;Internal 4.0 */
    DWORD   nSize;                                                                           /* ;Internal 4.0 */
    DWORD   dParm[1];                                                                        /* ;Internal 4.0 */
} ENHMETARECORD, NEAR* PENHMETARECORD, FAR* LPENHMETARECORD;                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* MRMETAFILE constants */                                                                   /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#define ENHMETA_SIGNATURE        0x464D4520     /* Mandatory signature. */                   /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* Stock object flag used in the object handle index in the enhanced */                      /* ;Internal 4.0 */
/* metafile records. */                                                                      /* ;Internal 4.0 */
/* E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH) */                         /* ;Internal 4.0 */
/* represents the stock object BLACK_BRUSH. */                                               /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#define ENHMETA_STOCK_OBJECT    0x80000000L                                                  /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef HANDLE HENHMETAFILE;                                                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef LONG   INT32;   /* Signed or unsigned integers under NT which must */                /* ;Internal 4.0 */
typedef ULONG  UINT32;  /* always remain 32-bits under Chicago.            */                /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
typedef INT32 (CALLBACK* ENHMFENUMPROC)(HDC, LPHANDLETABLE, LPENHMETARECORD, INT32, LPARAM); /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
/* Enhanced metafile APIs */                                                                 /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
HENHMETAFILE  WINAPI CloseEnhMetaFile(HDC);                                                  /* ;Internal 4.0 */
HENHMETAFILE  WINAPI CopyEnhMetaFile(HENHMETAFILE, LPCSTR);                                  /* ;Internal 4.0 */
HDC   WINAPI CreateEnhMetaFile(HDC, LPCSTR, LPCRECTL, LPCSTR);                               /* ;Internal 4.0 */
BOOL  WINAPI DeleteEnhMetaFile(HENHMETAFILE);                                                /* ;Internal 4.0 */
BOOL  WINAPI EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC, LPVOID, LPCRECTL);            /* ;Internal 4.0 */
BOOL  WINAPI GdiComment(HDC, UINT32, LPBYTE);                                                /* ;Internal 4.0 */
HENHMETAFILE  WINAPI GetEnhMetaFile(LPCSTR);                                                 /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileBits(HENHMETAFILE, UINT32, LPBYTE);                              /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileDescription(HENHMETAFILE, UINT32, LPSTR);                        /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFileHeader(HENHMETAFILE, UINT32, LPMRMETAFILE);                      /* ;Internal 4.0 */
UINT32 WINAPI GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT32, LPPALETTEENTRY);            /* ;Internal 4.0 */
UINT32 WINAPI GetWinMetaFileBits(HENHMETAFILE, UINT32, LPBYTE, int, HDC);                    /* ;Internal 4.0 */
BOOL  WINAPI PlayEnhMetaFile(HDC, HENHMETAFILE, LPCRECTL);                                   /* ;Internal 4.0 */
BOOL  WINAPI PlayEnhMetaFileRecord(HDC, LPHANDLETABLE, LPENHMETARECORD, UINT32);             /* ;Internal 4.0 */
HENHMETAFILE  WINAPI SetEnhMetaFileBits(UINT32, LPCBYTE);                                    /* ;Internal 4.0 */
HENHMETAFILE  WINAPI SetWinMetaFileBits(UINT32, LPBYTE, HDC, LPMETAFILEPICT);                /* ;Internal 4.0 */
int   WINAPI SetMetaRgn(HDC);                                                                /* ;Internal 4.0 */
                                                                                             /* ;Internal 4.0 */
#endif   /* WINVER >= 0x0400 etc. */                                                         /* ;Internal 4.0 */
/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

int WINAPI SetAbortProc(HDC, ABORTPROC);

HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */

#endif  /* WINVER >= 0x030a */

typedef struct {
    short   cbSize;
    LPSTR   lpszDocName;
    LPSTR   lpszOutput;
    LPSTR   lpszDatatype;
    DWORD   fwType;
    }   DOCINFO, FAR * LPDOCINFO;

/* bit flags for DOCINFO.fwType */
#define DI_APPBANDING       0x0001
#define DI_ROPS_READ_DESTINATION   0x0002  // ;will use rops that read destination 
                                           // ;pixel values to print the doc. 
                                           // ;Ex: R2_XORPEN, PATINVERT (DPx).

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);
BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED      0x4000
#define SP_ERROR            (-1)
#define SP_APPABORT         (-2)
#define SP_USERABORT        (-3)
#define SP_OUTOFDISK        (-4)
#define SP_OUTOFMEMORY      (-5)

#define PR_JOBSTATUS        0x0000

#endif  /* NOGDI  */

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                1
#define ABORTDOC                2
#define NEXTBAND                3
#define SETCOLORTABLE           4
#define GETCOLORTABLE           5
#define FLUSHOUTPUT             6
#define DRAFTMODE               7
#define QUERYESCSUPPORT         8
#define SETABORTPROC            9
#define STARTDOC                10
#define ENDDOC                  11
#define GETPHYSPAGESIZE         12
#define GETPRINTINGOFFSET       13
#define GETSCALINGFACTOR        14
#define MFCOMMENT               15
#define GETPENWIDTH             16
#define SETCOPYCOUNT            17
#define SELECTPAPERSOURCE       18
#define DEVICEDATA              19
#define PASSTHROUGH             19
#define GETTECHNOLGY            20
#define GETTECHNOLOGY           20
#define SETLINECAP              21
#define SETLINEJOIN             22
#define SETMITERLIMIT           23
#define BANDINFO                24
#define DRAWPATTERNRECT         25
#define GETVECTORPENSIZE        26
#define GETVECTORBRUSHSIZE      27
#define ENABLEDUPLEX            28
#define GETSETPAPERBINS         29
#define GETSETPRINTORIENT       30
#define ENUMPAPERBINS           31
#define SETDIBSCALING           32
#define EPSPRINTING             33
#define ENUMPAPERMETRICS        34
#define GETSETPAPERMETRICS      35
#define POSTSCRIPT_DATA         37
#define POSTSCRIPT_IGNORE       38
#define MOUSETRAILS             39

#define GETEXTENDEDTEXTMETRICS  256
#define GETEXTENTTABLE          257
#define GETPAIRKERNTABLE        258
#define GETTRACKKERNTABLE       259
#define EXTTEXTOUT              512
#define GETFACENAME             513
#define ENABLERELATIVEWIDTHS    768
#define ENABLEPAIRKERNING       769
#define SETKERNTRACK            770
#define SETALLJUSTVALUES        771
#define SETCHARSET              772

#define STRETCHBLT              2048
#define GETSETSCREENPARAMS      3072
#define QUERYDIBSUPPORT         3073
#define QDI_SETDIBITS           0x0001
#define QDI_GETDIBITS           0x0002
#define QDI_DIBTOSCREEN         0x0004
#define QDI_STRETCHDIB          0x0008

#define BEGIN_PATH              4096
#define CLIP_TO_PATH            4097
#define END_PATH                4098
#define EXT_DEVICE_CAPS         4099
#define RESTORE_CTM             4100
#define SAVE_CTM                4101
#define SET_ARC_DIRECTION       4102
#define SET_BACKGROUND_COLOR    4103
#define SET_POLY_MODE           4104
#define SET_SCREEN_ANGLE        4105
#define SET_SPREAD              4106
#define TRANSFORM_CTM           4107
#define SET_CLIP_BOX            4108
#define SET_BOUNDS              4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                               // ;Internal
#define BASED __based32(__segname("_DATA")) // ;Internal
#ifdef DEBUG                                // ;Internal
#define HWND  HWND_16                       // ;Internal
#define HWNDC HWND_16                       // ;Internal
#else                                       // ;Internal
typedef struct tagWND BASED *HWND;          // ;Internal
typedef HWND HWNDC;                         // ;Internal
#endif                                      // ;Internal
typedef UINT HWND_16;                       // ;Internal
#else                                       // ;Internal
DECLARE_HANDLE(HWND);
#endif                                      // ;Internal

#ifndef NOUSER

#ifdef tagWND                       // ;Internal
#ifdef DEBUG                        // ;Internal
#define HMENU HMENU_16              // ;Internal
#else                               // ;Internal
typedef struct tagMENU FAR* HMENU;  // ;Internal
#endif                              // ;Internal
typedef UINT HMENU_16;              // ;Internal
#else                               // ;Internal
DECLARE_HANDLE(HMENU);
#endif                              // ;Internal

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;     /* HICONs & HCURSORs are polymorphic */


/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXFIXEDFRAME         7
#define SM_CYFIXEDFRAME         8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXSIZEFRAME          32
#define SM_CYSIZEFRAME          33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_SECURE               44
#endif  /* WINVER >= 0x030a */
                                    /* ;Internal 4.0 */
#if (WINVER >= 0x0400)              /* ;Internal 4.0 */
#define SM_CXEDGE               45  /* ;Internal 4.0 */
#define SM_CYEDGE               46  /* ;Internal 4.0 */
#define SM_CXMINSPACING         47  /* ;Internal 4.0 */
#define SM_CYMINSPACING         48  /* ;Internal 4.0 */
#define SM_CXSMICON             49  /* ;Internal 4.0 */
#define SM_CYSMICON             50  /* ;Internal 4.0 */
#define SM_CYSMCAPTION          51  /* ;Internal 4.0 */
#define SM_CXSMSIZE             52  /* ;Internal 4.0 */
#define SM_CYSMSIZE             53  /* ;Internal 4.0 */
#define SM_CXMENUSIZE           54  /* ;Internal 4.0 */
#define SM_CYMENUSIZE           55  /* ;Internal 4.0 */
#define SM_ARRANGE              56  /* ;Internal 4.0 */
#define SM_CXMINIMIZED          57  /* ;Internal 4.0 */
#define SM_CYMINIMIZED          58  /* ;Internal 4.0 */
#define SM_CXMAXTRACK           59  /* ;Internal 4.0 */
#define SM_CYMAXTRACK           60  /* ;Internal 4.0 */
#define SM_CXMAXIMIZED          61  /* ;Internal 4.0 */
#define SM_CYMAXIMIZED          62  /* ;Internal 4.0 */
#define SM_NETWORK              63  /* ;Internal 4.0 */
#define SM_CLEANBOOT		    67  /* ;Internal 4.0 */
#define SM_CXDRAG               68  /* ;Internal 4.0 */
#define SM_CYDRAG               69  /* ;Internal 4.0 */
#define SM_SHOWSOUNDS           70  /* ;Internal 4.0 */
#define SM_CXMENUCHECK          71  /* ;Internal 4.0 */
#define SM_CYMENUCHECK          72  /* ;Internal 4.0 */
#define SM_SLOWMACHINE          73  /* ;Internal 4.0 */
#define SM_MIDEASTENABLED       74  /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */      /* ;Internal 4.0 */
#if (WINVER >= 0x040A)              /* ;Internal 4.1 */
#define SM_XVIRTUALSCREEN       75  /* ;Internal 4.1 */
#define SM_YVIRTUALSCREEN       76  /* ;Internal 4.1 */
#define SM_CXVIRTUALSCREEN      77  /* ;Internal 4.1 */
#define SM_CYVIRTUALSCREEN      78  /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */       /* ;Internal 4.1 */

#define SM_CXDLGFRAME           SM_CXFIXEDFRAME
#define SM_CYDLGFRAME           SM_CYFIXEDFRAME
#define SM_CXFRAME              SM_CXSIZEFRAME
#define SM_CYFRAME              SM_CYSIZEFRAME

#define SM_CYCAPTIONICON        SM_CYSMICON     // ;Internal BOGUS TEMPORARY
#define SM_CYSMCAPTIONICON      SM_CYSMICON     // ;Internal BOGUS TEMPORARY
#define SM_CXWORKAREA           SM_CXSCREEN     // ;Internal BOGUS TEMPORARY
#define SM_CYWORKAREA           SM_CYSCREEN     // ;Internal BOGUS TEMPORARY
#define SM_XWORKAREA            SM_CXBORDER     // ;Internal BOGUS TEMPORARY
#define SM_YWORKAREA            SM_CYBORDER     // ;Internal BOGUS TEMPORARY

// WARNING: If you modify SM_CMETRICS or SM_MAX make sure you   ;Internal
// modify the corresponding values in user.inc, user.api,       ;Internal
// windows.inc and winuser.h                                    ;Internal
#define SM_MAX                  78                          //  ;Internal
#define SM_CMETRICS             79
#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define ARW_BOTTOMLEFT              0x0000      // ;Internal 4.0
#define ARW_BOTTOMRIGHT             0x0001      // ;Internal 4.0
#define ARW_TOPLEFT                 0x0002      // ;Internal 4.0
#define ARW_TOPRIGHT                0x0003      // ;Internal 4.0
#define ARW_STARTMASK               0x0003      // ;Internal 4.0
#define ARW_STARTRIGHT              0x0001      // ;Internal 4.0
#define ARW_STARTTOP                0x0002      // ;Internal 4.0
                                                // ;Internal 4.0
#define ARW_LEFT                    0x0000      // ;Internal 4.0
#define ARW_RIGHT                   0x0000      // ;Internal 4.0
#define ARW_UP                      0x0004      // ;Internal 4.0
#define ARW_DOWN                    0x0004      // ;Internal 4.0
#define ARW_HIDE                    0x0008      // ;Internal 4.0
#define ARW_VALID                   0x000F      // ;Internal 4.0
#define ARW_ARRANGEMASK             0x0007      // ;Internal 4.0
                                                // ;Internal 4.0
#define MMI_MINSIZE                 0           // ;Internal 4.0
#define MMI_MAXSIZE                 1           // ;Internal 4.0
#define MMI_MAXPOS                  2           // ;Internal 4.0
#define MMI_MINTRACK                3           // ;Internal 4.0
#define MMI_MAXTRACK                4           // ;Internal 4.0

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)

#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#if (WINVER >= 0x0400)                          // ;Internal 4.0
                                                // ;Internal 4.0
#ifndef NOGDI                                   // ;Internal 4.0
typedef struct tagCOMMONFONT                    // ;Internal 4.0
{                                               // ;Internal 4.0
    BYTE    lfItalic;                           // ;Internal 4.0
    BYTE    lfUnderline;                        // ;Internal 4.0
    BYTE    lfStrikeOut;                        // ;Internal 4.0
    BYTE    lfCharSet;                          // ;Internal 4.0
    BYTE    lfOutPrecision;                     // ;Internal 4.0
    BYTE    lfClipPrecision;                    // ;Internal 4.0
    BYTE    lfQuality;                          // ;Internal 4.0
    BYTE    lfPitchAndFamily;                   // ;Internal 4.0
    char    lfFaceName[LF_FACESIZE];            // ;Internal 4.0
} COMMONFONT, FAR *LPCOMMONFONT;                // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagLOGFONT_32                    // ;Internal 4.0
{                                               // ;Internal 4.0
    LONG    lfHeight;                           // ;Internal 4.0
    LONG    lfWidth;                            // ;Internal 4.0
    LONG    lfEscapement;                       // ;Internal 4.0
    LONG    lfOrientation;                      // ;Internal 4.0
    LONG    lfWeight;                           // ;Internal 4.0
    COMMONFONT  lfCommon;                       // ;Internal 4.0
} LOGFONT_32, *PLOGFONT_32, FAR *LPLOGFONT_32;  // ;Internal 4.0
                                                // ;Internal 4.0
#define METRICS_USEDEFAULT -1                   // ;Internal 4.0
typedef struct tagNONCLIENTMETRICS              // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iBorderWidth;                       // ;Internal 4.0
    LONG    iScrollWidth;                       // ;Internal 4.0
    LONG    iScrollHeight;                      // ;Internal 4.0
    LONG    iCaptionWidth;                      // ;Internal 4.0
    LONG    iCaptionHeight;                     // ;Internal 4.0
    LOGFONT_32  lfCaptionFont;                  // ;Internal 4.0
    LONG    iSmCaptionWidth;                    // ;Internal 4.0
    LONG    iSmCaptionHeight;                   // ;Internal 4.0
    LOGFONT_32  lfSmCaptionFont;                // ;Internal 4.0
    LONG    iMenuWidth;                         // ;Internal 4.0
    LONG    iMenuHeight;                        // ;Internal 4.0
    LOGFONT_32  lfMenuFont;                     // ;Internal 4.0
    LOGFONT_32  lfStatusFont;                   // ;Internal 4.0
    LOGFONT_32  lfMessageFont;                  // ;Internal 4.0
}   NONCLIENTMETRICS, FAR* LPNONCLIENTMETRICS;  // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagICONMETRICS                   // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iHorzSpacing;                       // ;Internal 4.0
    LONG    iVertSpacing;                       // ;Internal 4.0
    LONG    iTitleWrap;                         // ;Internal 4.0
    LOGFONT_32  lfFont;                         // ;Internal 4.0
}   ICONMETRICS, FAR *LPICONMETRICS;            // ;Internal 4.0
#endif /* NOGDI */                              // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagMINIMIZEDMETRICS              // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iWidth;                             // ;Internal 4.0
    LONG    iHorzGap;                           // ;Internal 4.0
    LONG    iVertGap;                           // ;Internal 4.0
    LONG    iArrange;                           // ;Internal 4.0
}   MINIMIZEDMETRICS, FAR *LPMINIMIZEDMETRICS;  // ;Internal 4.0
                                                // ;Internal 4.0
typedef struct tagANIMATIONINFO                 // ;Internal 4.0
{                                               // ;Internal 4.0
    DWORD   cbSize;                             // ;Internal 4.0
    LONG    iMinAnimate;                        // ;Internal 4.0
}   ANIMATIONINFO, FAR *LPANIMATIONINFO;        // ;Internal 4.0
                                                // ;Internal 4.0
#endif /* WINVER >= 0x0400 */                   // ;Internal 4.0
                                                // ;Internal 4.0
#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_TIMEOUTS                7       // ;Internal
#define SPI_KANJIMENU               8       // ;Internal
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_SETDRAGFULLWINDOWS      37      // ;Internal NT
#define SPI_GETDRAGFULLWINDOWS      38      // ;Internal NT
#define SPI_GETNONCLIENTMETRICS     41      // ;Internal 4.0
#define SPI_SETNONCLIENTMETRICS     42      // ;Internal 4.0
#define SPI_GETMINIMIZEDMETRICS     43      // ;Internal 4.0
#define SPI_SETMINIMIZEDMETRICS     44      // ;Internal 4.0
#define SPI_GETICONMETRICS          45      // ;Internal 4.0
#define SPI_SETICONMETRICS          46      // ;Internal 4.0
#define SPI_SETWORKAREA             47      // ;Internal 4.0
#define SPI_GETWORKAREA             48      // ;Internal 4.0
#define SPI_SETPENWINDOWS           49      // ;Internal 4.0
#define SPI_GETFILTERKEYS           50      // ;Internal 4.0
#define SPI_SETFILTERKEYS           51      // ;Internal 4.0
#define SPI_GETTOGGLEKEYS           52      // ;Internal 4.0
#define SPI_SETTOGGLEKEYS           53      // ;Internal 4.0
#define SPI_GETMOUSEKEYS            54      // ;Internal 4.0
#define SPI_SETMOUSEKEYS            55      // ;Internal 4.0
#define SPI_GETSHOWSOUNDS           56      // ;Internal 4.0
#define SPI_SETSHOWSOUNDS           57      // ;Internal 4.0
#define SPI_GETSTICKYKEYS           58      // ;Internal 4.0
#define SPI_SETSTICKYKEYS           59      // ;Internal 4.0
#define SPI_GETACCESSTIMEOUT        60      // ;Internal 4.0
#define SPI_SETACCESSTIMEOUT        61      // ;Internal 4.0
#define SPI_GETSERIALKEYS           62      // ;Internal 4.0
#define SPI_SETSERIALKEYS           63      // ;Internal 4.0
#define SPI_GETSOUNDSENTRY          64      // ;Internal 4.0
#define SPI_SETSOUNDSENTRY          65      // ;Internal 4.0
#define SPI_GETHIGHCONTRAST         66      // ;Internal 4.0
#define SPI_SETHIGHCONTRAST         67      // ;Internal 4.0
#define SPI_GETKEYBOARDPREF         68      // ;Internal 4.0
#define SPI_SETKEYBOARDPREF         69      // ;Internal 4.0
#define SPI_GETSCREENREADER         70      // ;Internal 4.0
#define SPI_SETSCREENREADER         71      // ;Internal 4.0
#define SPI_GETANIMATION            72      // ;Internal 4.0
#define SPI_SETANIMATION            73      // ;Internal 4.0
#define SPI_GETFONTSMOOTHING        74      // ;Internal 4.0
#define SPI_SETFONTSMOOTHING        75      // ;Internal 4.0
#define SPI_SETDRAGWIDTH            76      // ;Internal 4.0
#define SPI_SETDRAGHEIGHT           77      // ;Internal 4.0
#define SPI_SETHANDHELD             78      // ;Internal 4.0
#define SPI_GETLOWPOWERTIMEOUT	    79	    // ;Internal 4.0
#define SPI_GETPOWEROFFTIMEOUT	    80	    // ;Internal 4.0
#define SPI_SETLOWPOWERTIMEOUT	    81	    // ;Internal 4.0
#define SPI_SETPOWEROFFTIMEOUT	    82	    // ;Internal 4.0
#define SPI_GETLOWPOWERACTIVE	    83	    // ;Internal 4.0
#define SPI_GETPOWEROFFACTIVE	    84	    // ;Internal 4.0
#define SPI_SETLOWPOWERACTIVE	    85	    // ;Internal 4.0
#define SPI_SETPOWEROFFACTIVE	    86	    // ;Internal 4.0
#define SPI_SETCURSORS              87      // ;Internal 4.0
#define SPI_SETICONS                88      // ;Internal 4.0
#define SPI_GETDEFAULTINPUTLANG     89      // ;Internal 4.0
#define SPI_SETDEFAULTINPUTLANG     90	    // ;Internal 4.0
#define SPI_SETLANGTOGGLE           91      // ;Internal 4.0
#define SPI_GETWINDOWSEXTENSION     92      // ;Internal 4.0
#define SPI_SETMOUSETRAILS          93      // ;Internal 4.0
#define SPI_GETMOUSETRAILS          94      // ;Internal 4.0
#define SPI_GETSNAPTODEFBUTTON      95      // ;Internal NT
#define SPI_SETSNAPTODEFBUTTON      96      // ;internal NT
#define SPI_SCREENSAVERRUNNING      97      // ;Internal 4.0
#define SPI_MAX                     97      // ;Internal

#ifdef FE_IME                               // ;Internal 4.1
#define SPI_GETSHOWIMEUI            99      // ;Internal 4.1
#define SPI_SETSHOWIMEUI            100     // ;Internal 4.1
#undef  SPI_MAX                             // ;Internal 4.1
#define SPI_MAX                     100     // ;Internal 4.1
#endif // FE_IME                            // ;Internal 4.1

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDCHANGE             0x0002
#define SPIF_SENDWININICHANGE       SPIF_SENDCHANGE
#define SPIF_VALID                  0x0003  /* ;Internal */

typedef struct tagFILTERKEYS            // ;Internal 4.0
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iWaitMSec;                  // ;Internal 4.0 
    DWORD   iDelayMSec;                 // ;Internal 4.0 
    DWORD   iRepeatMSec;                // ;Internal 4.0 
    DWORD   iBounceMSec;                // ;Internal 4.0 
}   FILTERKEYS, FAR* LPFILTERKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define FKF_FILTERKEYSON    0x00000001  // ;Internal 4.0 
#define FKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define FKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define FKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define FKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define FKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define FKF_CLICKON         0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSTICKYKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
}   STICKYKEYS, FAR* LPSTICKYKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SKF_STICKYKEYSON    0x00000001  // ;Internal 4.0 
#define SKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define SKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define SKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define SKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define SKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define SKF_AUDIBLEFEEDBACK 0x00000040  // ;Internal 4.0 
#define SKF_TRISTATE        0x00000080  // ;Internal 4.0 
#define SKF_TWOKEYSOFF      0x00000100  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagMOUSEKEYS             // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iMaxSpeed;                  // ;Internal 4.0 
    DWORD   iTimeToMaxSpeed;            // ;Internal 4.0 
    DWORD   iCtrlSpeed;                 // ;Internal 4.0 
    DWORD   dwReserved1;                // ;Internal 4.0 
    DWORD   dwReserved2;                // ;Internal 4.0 
}   MOUSEKEYS, FAR* LPMOUSEKEYS;        // ;Internal 4.0 
                                        // ;Internal 4.0 
#define MKF_MOUSEKEYSON     0x00000001  // ;Internal 4.0 
#define MKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define MKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define MKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define MKF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define MKF_INDICATOR       0x00000020  // ;Internal 4.0 
#define MKF_NOMODIFIERS     0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagACCESSTIMEOUT         // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iTimeOutMSec;               // ;Internal 4.0 
}   ACCESSTIMEOUT, FAR* LPACCESSTIMEOUT;// ;Internal 4.0 
                                        // ;Internal 4.0 
#define ATF_TIMEOUTON       0x00000001  // ;Internal 4.0 
#define ATF_ONOFFFEEDBACK   0x00000002  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSOUNDSENTRY           // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    DWORD   iFSTextEffect;              // ;Internal 4.0 
    DWORD   iFSTextEffectMSec;          // ;Internal 4.0 
    DWORD   iFSTextEffectColorBits;     // ;Internal 4.0 
    DWORD   iFSGrafEffect;              // ;Internal 4.0 
    DWORD   iFSGrafEffectMSec;          // ;Internal 4.0 
    DWORD   iFSGrafEffectColor;         // ;Internal 4.0 
    DWORD   iWindowsEffect;             // ;Internal 4.0 
    DWORD   iWindowsEffectMSec;         // ;Internal 4.0 
    LPSTR   lpszWindowsEffectDLL;       // ;Internal 4.0 
    DWORD   iWindowsEffectOrdinal;      // ;Internal 4.0 
}   SOUNDSENTRY, FAR* LPSOUNDSENTRY;    // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSF_SOUNDSENTRYON   0x00000001  // ;Internal 4.0 
#define SSF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define SSF_INDICATOR       0x00000004  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSTF_NONE           0x00000001  // ;Internal 4.0 
#define SSTF_CHARS          0x00000002  // ;Internal 4.0 
#define SSTF_BORDER         0x00000004  // ;Internal 4.0 
#define SSTF_DISPLAY        0x00000008  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSGF_NONE           0x00000001  // ;Internal 4.0 
#define SSGF_DISPLAY        0x00000002  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SSWF_NONE           0x00000001  // ;Internal 4.0 
#define SSWF_TITLE          0x00000002  // ;Internal 4.0 
#define SSWF_WINDOW         0x00000004  // ;Internal 4.0 
#define SSWF_DISPLAY        0x00000008  // ;Internal 4.0 
#define SSWF_CUSTOM         0x00000010  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagTOGGLEKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
}   TOGGLEKEYS, FAR* LPTOGGLEKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define TKF_TOGGLEKEYSON    0x00000001  // ;Internal 4.0 
#define TKF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define TKF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define TKF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define TKF_HOTKEYSOUND     0x00000020  // ;Internal 4.0 
#define TKF_INDICATOR       0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagSERIALKEYS            // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    LPSTR   lpszActivePort;             // ;Internal 4.0 
    LPSTR   lpszPort;                   // ;Internal 4.0 
    DWORD   iBaudRate;                  // ;Internal 4.0 
    DWORD   iPortState;                 // ;Internal 4.0 
    DWORD   iActive;                    // ;Internal 4.0 
}   SERIALKEYS, FAR* LPSERIALKEYS;      // ;Internal 4.0 
                                        // ;Internal 4.0 
#define SERKF_SERIALKEYSON  0x00000001  // ;Internal 4.0 
#define SERKF_AVAILABLE     0x00000002  // ;Internal 4.0 
#define SERKF_INDICATOR     0x00000004  // ;Internal 4.0 
                                        // ;Internal 4.0 
typedef struct tagHIGHCONTRAST          // ;Internal 4.0 
{                                       // ;Internal 4.0 
    DWORD   cbSize;                     // ;Internal 4.0 
    DWORD   dwFlags;                    // ;Internal 4.0 
    LPSTR   lpszDefaultScheme;          // ;Internal 4.0 
}   HIGHCONTRAST, FAR* LPHIGHCONTRAST;  // ;Internal 4.0 
                                        // ;Internal 4.0 
#define HCF_HIGHCONTRASTON  0x00000001  // ;Internal 4.0 
#define HCF_AVAILABLE       0x00000002  // ;Internal 4.0 
#define HCF_HOTKEYACTIVE    0x00000004  // ;Internal 4.0 
#define HCF_CONFIRMHOTKEY   0x00000008  // ;Internal 4.0 
#define HCF_HOTKEYSOUND     0x00000010  // ;Internal 4.0 
#define HCF_INDICATOR       0x00000020  // ;Internal 4.0 
#define HCF_HOTKEYAVAILABLE 0x00000040  // ;Internal 4.0 
                                        // ;Internal 4.0
#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_EXCLUSIVE       0x80000000  // ;Internal
#define CDS_RESET	    0x40000000
#define CDS_SETRECT	    0x20000000
#define CDS_NORESET	    0x10000000
#define CDS_VALID	    0xF000000F	// ;Internal

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5

typedef struct tagDEVMODE FAR*LPDEVMODE;

LONG WINAPI ChangeDisplaySettings(LPDEVMODE lpDevMode, DWORD flags);

#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS      ((DWORD)-2)
BOOL WINAPI EnumDisplaySettings(
    LPCSTR      lpszDeviceName,
    DWORD       iModeNum,
    LPDEVMODE   lpDevMode);

#if (WINVER >= 0x40A)
LONG WINAPI ChangeDisplaySettingsEx(
    LPCSTR      lpszDeviceName,
    LPDEVMODE   lpDevMode,
#ifdef tagWND               /* ;Internal */
    HWND_16     hwnd,       /* ;Internal */
#else                       /* ;Internal */
    HWND        hwnd,
#endif                      /* ;Internal */
    DWORD       flags,
    LPVOID      lParam);

#endif  /* WINVER >=0x040A */

#endif  /* WINVER >=0x0400 */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(LPRECT, int, int, int, int);
void    WINAPI SetRectEmpty(LPRECT);

void    WINAPI CopyRect(LPRECT, LPCRECT);

BOOL    WINAPI IsRectEmpty(LPCRECT);

BOOL    WINAPI EqualRect(LPCRECT, LPCRECT);

BOOL    WINAPI IntersectRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI UnionRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI SubtractRect(LPRECT, LPCRECT, LPCRECT);

void    WINAPI OffsetRect(LPRECT, int, int);
void    WINAPI InflateRect(LPRECT, int, int);

BOOL    WINAPI PtInRect(LPCRECT, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
#ifdef tagWND           /* ;Internal */
    HWND_16 hwnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hwnd;
#endif                  /* ;Internal */
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;
} MSG, * PMSG, NEAR* NPMSG, FAR* LPMSG;

BOOL    WINAPI GetMessage(LPMSG, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(LPMSG, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002
#define PM_VALID        0x0003      /* ;Internal */

#ifdef tagWND   // ;Internal
BOOL    WINAPI WaitMessage(void);   // ;Internal
#else           // ;Internal
void    WINAPI WaitMessage(void);
#endif          // ;Internal

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#if (WINVER >= 0x0400)                      /* ;Internal 4.0 */
LPARAM  WINAPI SetMessageExtraInfo(LPARAM); /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */               /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040
#if (WINVER >= 0x40A)                               
#define QS_ALLPOSTMESSAGE 0x0100
#endif // (WINVER >= 0x40A)                         
// #define QS_HOTKEY       0x0080          // ;Internal NT
// #define QS_ALLINPUT     0x00ff          // ;Internal NT
#define QS_ALLINPUT     0x007f
#define QS_TRANSFER     0x4000          // ;Internal
#define QS_VALID        0x40FF          // ;Internal
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

#ifdef tagWND                                               /* ;Internal */
BOOL    WINAPI PostMessage(HWND_16, UINT, WPARAM, LPARAM);  /* ;Internal */
#else                                                       /* ;Internal */
BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
#endif                                                      /* ;Internal */

LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define SMTO_NORMAL         0x0000          // ;Internal NT
#define SMTO_BLOCK          0x0001          // ;Internal NT
#define SMTO_ABORTIFHUNG    0x0002          // ;Internal NT
#define SMTO_BROADCAST      0x0004          // ;Internal 4.0
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008      // ;Internal 4.0
#define SMTO_VALID          0x000F          // ;Internal NT
                                            // ;Internal NT
#ifdef tagWND                               // ;Internal NT
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND_16, UINT, DWORD, LRESULT);  /* ;Internal NT */
#else                                       // ;Internal NT
typedef VOID (CALLBACK* SENDASYNCPROC)(HWND, UINT, DWORD, LRESULT);     /* ;Internal NT */
#endif                                      // ;Internal NT
                                            // ;Internal 4.0
long  WINAPI  BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM); // ;Internal 4.0

#define BROADCAST_QUERY_DENY	0x424D5144	    // Return this value to deny a query.
                                            // ;Internal 4.0
#define BSM_ALLCOMPONENTS       0x00000000  // ;Internal 4.0
#define BSM_VXDS                0x00000001  // ;Internal 4.0
#define BSM_NETDRIVER           0x00000002  // ;Internal 4.0
#define BSM_INSTALLABLEDRIVERS  0x00000004  // ;Internal 4.0
#define BSM_APPLICATIONS        0x00000008  // ;Internal 4.0
                                            // ;Internal 4.0
#define BSF_QUERY               0x00000001  // ;Internal 4.0
#define BSF_IGNORECURRENTTASK   0x00000002  // ;Internal 4.0
#define BSF_FLUSHDISK           0x00000004  // ;Internal 4.0
#define BSF_NOHANG              0x00000008  // ;Internal 4.0
#define BSF_POSTMESSAGE         0x00000010  // ;Internal 4.0
#define BSF_FORCEIFHUNG         0x00000020  // ;Internal 4.0
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040  // ;Internal 4.0
#define BSF_SYSTEMSHUTDOWN      0x40000000  // ;Internal 4.0
#define BSF_MSGSRV32ISOK        0x80000000  // ;Internal 4.0
#define BSF_VALID               0xC000007F  // ;Internal 4.0
                                            // ;Internal 4.0
/* Flags for wParam of WM_DEVICECHANGE message */   // ;Internal 4.0
#define DBWF_LPARAMPOINTER	0x8000	        // ;Internal 4.0	
                                            // ;Internal 4.0    
typedef struct tagBROADCASTSYSMSG           // ;Internal 4.0
{                                           // ;Internal 4.0
/*  DWORD   cbSize; */          // ;Internal BOGUS
    UINT    uiMessage;                      // ;Internal 4.0                
    WPARAM  wParam;                         // ;Internal 4.0
    LPARAM  lParam;                         // ;Internal 4.0
} BROADCASTSYSMSG;                          // ;Internal 4.0
typedef BROADCASTSYSMSG  FAR *LPBROADCASTSYSMSG;    // ;Internal 4.0
                                            // ;Internal 4.0
#endif /* WINVER >= 0x0400 */               // ;Internal 4.0
                                                    /* ;Internal 4.0 */
#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

#ifdef tagWND   // ;Internal
BOOL    WINAPI ReplyMessage(LRESULT);   // ;Internal
#else           // ;Internal
void    WINAPI ReplyMessage(LRESULT);
#endif          // ;Internal
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST ((HWND)-1)


BOOL WINAPI CallMsgFilter(LPMSG, int);

#define WH_GETMESSAGE           3

#define WH_CALLWNDPROC          4
#define WH_CALLWNDPROCRET       12      // ;Internal 4.0
                                        // ;Internal
typedef struct tagCWPRETSTRUCT          // ;Internal 4.0
{                                       // ;Internal 4.0
    LRESULT lResult;                    // ;Internal 4.0
    WPARAM  wParamHi;                   // ;Internal 4.0
    LPARAM  lParam;                     // ;Internal 4.0
    WPARAM  wParamLo;                   // ;Internal 4.0
    UINT    message;                    // ;Internal 4.0
#ifdef tagWND                           // ;Internal
    HWND_16 hwnd;                       // ;Internal
#else                                   // ;Internal
    HWND    hwnd;                       // ;Internal 4.0
#endif                                  // ;Internal
} CWPRETSTRUCT, FAR * LPCWPRETSTRUCT;   // ;Internal 4.0

// #define WC_INIT              1       // ;Internal NT
// #define WC_SWP               2       // ;Internal NT
// #define WC_DEFWINDOWPROC     3       // ;Internal NT
// #define WC_MINMAX            4       // ;Internal NT
// #define WC_MOVE              5       // ;Internal NT
// #define WC_SIZE              6       // ;Internal NT
// #define WC_DRAWCAPTION       7       // ;Internal NT
                                        // ;Internal
#define WH_MSGFILTER            (-1)
#define WH_SYSMSGFILTER         6
#define WH_FOREGROUNDIDLE       11      // ;Internal NT

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX          0
#define MSGF_MESSAGEBOX         1       // ;Internal
#define MSGF_MENU               2
#define MSGF_MOVE               3
#define MSGF_SIZE               4
#define MSGF_SCROLLBAR          5
#define MSGF_NEXTWINDOW         6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7      // ;Internal
#define MSGF_MAINLOOP           8
#define MSGF_USER               4096
#endif  /* NOMSG */

/* Standard window messages */
/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_NULL                 0x0000
#define WM_CREATE               0x0001
#define WM_DESTROY              0x0002
#define WM_MOVE                 0x0003
#define WM_SIZEWAIT             0x0004      // ;Internal
#define WM_SIZE                 0x0005
#define WM_ACTIVATE             0x0006
#define WM_SETFOCUS             0x0007
#define WM_KILLFOCUS            0x0008
#define WM_SETVISIBLE           0x0009      // ;Internal
#define WM_ENABLE               0x000A
#define WM_SETREDRAW            0x000B
#define WM_SETTEXT              0x000C
#define WM_GETTEXT              0x000D
#define WM_GETTEXTLENGTH        0x000E
#define WM_PAINT                0x000F

#define WM_CLOSE                0x0010
#define WM_QUERYENDSESSION      0x0011
#define WM_QUIT                 0x0012
#define WM_QUERYOPEN            0x0013
#define WM_ERASEBKGND           0x0014
#define WM_SYSCOLORCHANGE       0x0015
#define WM_ENDSESSION           0x0016
#define WM_SYSTEMERROR          0x0017      // ;Internal
#define WM_SHOWWINDOW           0x0018
#define WM_CTLCOLOR             0x0019
#define WM_SETTINGCHANGE        0x001A
#define WM_WININICHANGE         WM_SETTINGCHANGE
#define WM_DEVMODECHANGE        0x001B
#define WM_ACTIVATEAPP          0x001C
#define WM_FONTCHANGE           0x001D
#define WM_TIMECHANGE           0x001E
#define WM_CANCELMODE           0x001F

#define WM_SETCURSOR            0x0020
#define WM_MOUSEACTIVATE        0x0021
#define WM_CHILDACTIVATE        0x0022
#define WM_QUEUESYNC            0x0023
#define WM_GETMINMAXINFO        0x0024
#define WM_LOGOFF               0x0025      // ;Internal NT
#define WM_PAINTICON            0x0026      // ;Internal
#define WM_ICONERASEBKGND       0x0027
#define WM_NEXTDLGCTL           0x0028
#define WM_ALTTABACTIVE         0x0029      // ;Internal
#define WM_SPOOLERSTATUS        0x002A
#define WM_DRAWITEM             0x002B
#define WM_MEASUREITEM          0x002C
#define WM_DELETEITEM           0x002D
#define WM_VKEYTOITEM           0x002E
#define WM_CHARTOITEM           0x002F

#define WM_SETFONT              0x0030
#define WM_GETFONT              0x0031
#define WM_SETHOTKEY            0x0032      // ;Internal
#define WM_GETHOTKEY            0x0033      // ;Internal
#define WM_FILESYSCHANGE        0x0034      // ;Internal
#define WM_SHELLNOTIFY          0x0034      // ;Internal
#define SHELLNOTIFY_DISKFULL    0x0001      // ;Internal
#define SHELLNOTIFY_OLELOADED   0x0002      // ;Internal
#define SHELLNOTIFY_OLEUNLOADED 0x0003      // ;Internal
#define SHELLNOTIFY_WALLPAPERCHANGED 0x0004 // ;Internal
#define SHELLNOTIFY_SWAPGROWFAILED 0x0005   // ;Internal
                                            // ;Internal
#define WM_ISACTIVEICON         0x0035      // ;Internal
#define WM_UNUSED0036           0x0036      // ;Internal
#define WM_QUERYDRAGICON        0x0037
#define WM_WINHELP		        0x0038	    // ;Internal 4.0
#define WM_COMPAREITEM          0x0039
#define WM_FULLSCREEN           0x003A      // ;Internal NT
#define WM_CLIENTSHUTDOWN       0x003B      // ;Internal NT
#define WM_DDEMLEVENT           0x003C      // ;Internal NT
                                            // ;Internal
#define WMOBJ_ID                0x0000      // ;Internal
#define WMOBJ_SAMETHREAD        0x8000      // ;Internal
#define WMOBJID_SELF            0x00000000  // ;Internal
                                            // ;Internal
#define WM_GETOBJECT            0x003D      // ;Internal

#define MM_CALCSCROLL           0x003F      // ;Internal NT

#define WM_TESTING              0x0040      // ;Internal
#define WM_COMPACTING           0x0041
#define WM_OTHERWINDOWCREATED   0x0042      // ;Internal NT
#define WM_OTHERWINDOWDESTROYED 0x0043      // ;Internal NT
#define WM_COMMNOTIFY           0x0044
#define WM_MEDIASTATUSCHANGE    0x0045      // ;Internal 4.0
#define WM_WINDOWPOSCHANGING    0x0046
#define WM_WINDOWPOSCHANGED     0x0047
#define WM_POWER                0x0048
#define WM_COPYGLOBALDATA       0x0049      // ;Internal NT
#define WM_COPYDATA             0x004A      // ;Internal NT
#define WM_CANCELJOURNAL        0x004B      // ;Internal NT
#define WM_LOGONNOTIFY          0x004C      // ;Internal NT
#define WM_KEYF1                0x004D      // ;Internal 4.0
#define WM_NOTIFY               0x004E
#define WM_ACCESS_WINDOW        0x004F      // ;Internal NT

#define WM_INPUTLANGCHANGEREQUEST     0x0050      // ;Internal 4.0
#define WM_INPUTLANGCHANGE      0x0051      // ;Internal 4.0
#define WM_TCARD		        0x0052
#define WM_HELP                 0x0053
#define WM_USERCHANGED		    0x0054
#define WM_NOTIFYFORMAT         0x0055      // ;Internal 4.0
#define NFR_ANSI                1           // ;Internal 4.0
#define NFR_UNICODE             2           // ;Internal 4.0
#define NF_QUERY                3           // ;Internal 4.0
#define NF_REQUERY              4           // ;Internal 4.0
                                            // ;Internal

#define WM_FINALDESTROY         0x0070      // ;Internal NT
#define WM_MEASUREITEM_CLIENTDATA   0x0071  // ;Internal NT
#define WM_CONTEXTMENU          0x007B
#define WM_STYLECHANGING        0x007C      // ;Internal 4.0
#define WM_STYLECHANGED         0x007D      // ;Internal 4.0
#define WM_DISPLAYCHANGE	    0x007E      // ;Internal 4.0
#define WM_GETICON              0x007F      // ;Internal 4.0

#define WM_SETICON              0x0080      // ;Internal 4.0
#define WM_NCCREATE             0x0081
#define WM_NCDESTROY            0x0082
#define WM_NCCALCSIZE           0x0083
#define WM_NCHITTEST            0x0084
#define WM_NCPAINT              0x0085
#define WM_NCACTIVATE           0x0086
#define WM_GETDLGCODE           0x0087
#define WM_SYNCPAINT            0x0088      // ;Internal
#define WM_SYNCTASK             0x0089      // ;Internal

#define WM_NCMOUSEMOVE          0x00A0
#define WM_NCLBUTTONDOWN        0x00A1
#define WM_NCLBUTTONUP          0x00A2
#define WM_NCLBUTTONDBLCLK      0x00A3
#define WM_NCRBUTTONDOWN        0x00A4
#define WM_NCRBUTTONUP          0x00A5
#define WM_NCRBUTTONDBLCLK      0x00A6
#define WM_NCMBUTTONDOWN        0x00A7
#define WM_NCMBUTTONUP          0x00A8
#define WM_NCMBUTTONDBLCLK      0x00A9

#define EM_FIRST_32             0x00B0      // ;Internal
// #define EM_GETSEL            0x00B0      // ;Internal NT
// #define EM_SETSEL            0x00B1      // ;Internal NT
// #define EM_GETRECT           0x00B2      // ;Internal NT
// #define EM_SETRECT           0x00B3      // ;Internal NT
// #define EM_SETRECTNP         0x00B4      // ;Internal NT
// #define EM_SCROLL            0x00B5      // ;Internal NT
// #define EM_LINESCROLL        0x00B6      // ;Internal NT
// #define EM_SCROLLCARET       0x00B7      // ;Internal NT
// #define EM_GETMODIFY         0x00B8      // ;Internal NT
// #define EM_SETMODIFY         0x00B9      // ;Internal NT
// #define EM_GETLINECOUNT      0x00BA      // ;Internal NT
// #define EM_LINEINDEX         0x00BB      // ;Internal NT
// #define EM_SETHANDLE         0x00BC      // ;Internal NT
// #define EM_GETHANDLE         0x00BD      // ;Internal NT
// #define EM_GETTHUMB          0x00BE      // ;Internal NT
// #define EM_LINELENGTH        0x00C1      // ;Internal NT
// #define EM_REPLACESEL        0x00C2      // ;Internal NT
// #define EM_SETFONT           0x00C3      // ;Internal NT
// #define EM_GETLINE           0x00C4      // ;Internal NT
// #define EM_LIMITTEXT         0x00C5      // ;Internal NT
// #define EM_CANUNDO           0x00C6      // ;Internal NT
// #define EM_UNDO              0x00C7      // ;Internal NT
// #define EM_FMTLINES          0x00C8      // ;Internal NT
// #define EM_LINEFROMCHAR      0x00C9      // ;Internal NT
// #define EM_SETWORDBREAK      0x00CA      // ;Internal NT
// #define EM_SETTABSTOPS       0x00CB      // ;Internal NT
// #define EM_SETPASSWORDCHAR   0x00CC      // ;Internal NT
// #define EM_EMPTYUNDOBUFFER   0x00CD      // ;Internal NT
// #define EM_GETFIRSTVISIBLELINE   0x00CE  // ;Internal NT
// #define EM_SETREADONLY       0x00CF      // ;Internal NT
// #define EM_SETWORDBREAKPROC  0x00D0      // ;Internal NT
// #define EM_GETWORDBREAKPROC  0x00D1      // ;Internal NT
// #define EM_GETPASSWORDCHAR   0x00D2      // ;Internal NT
// #define EM_SETMARGINS        0x00D3      // ;Internal NT 4.0
// #define EM_GETMARGINS        0x00D4      // ;Internal NT 4.0
// #define EM_POSFROMCHAR       0x00D5      // ;Internal NT 4.0
// #define EM_CHARFROMPOS       0x00D6      // ;Internal NT 4.0
#define EM_LAST_32              0x00D6      // ;Internal
                                            // ;Internal
#define SBM_FIRST_32            0x00E0      // ;Internal
// #define SBM_SETPOS           0x00E0      // ;Internal NT
// #define SBM_GETPOS           0x00E1      // ;Internal NT
// #define SBM_SETRANGE         0x00E2      // ;Internal NT
// #define SBM_GETRANGE         0x00E3      // ;Internal NT
// #define SBM_ENABLE_ARROWS    0x00E4      // ;Internal NT
// #define SBM_SETRANGEREDRAW   0x00E6      // ;Internal NT
// #define SBM_SETSCROLLINFO    0x00E9      // ;Internal NT 4.0
// #define SBM_GETSCROLLINFO    0x00EA      // ;Internal NT 4.0
#define SBM_LAST_32             0x00EA      // ;Internal
                                            // ;Internal
#define BM_FIRST_32             0x00F0      // ;Internal
// #define BM_GETCHECK          0x00F0      // ;Internal NT
// #define BM_SETCHECK          0x00F1      // ;Internal NT
// #define BM_GETSTATE          0x00F2      // ;Internal NT
// #define BM_SETSTATE          0x00F3      // ;Internal NT
// #define BM_SETSTYLE          0x00F4      // ;Internal NT
// #define BM_CLICK             0x00F5      // ;Internal NT
// #define BM_GETIMAGE          0x00F6      // ;Internal NT 4.0
// #define BM_SETIMAGE          0x00F7      // ;Internal NT 4.0
#define BM_LAST_32              0x00F7      // ;Internal

#define WM_KEYFIRST             0x0100
#define WM_KEYDOWN              0x0100
#define WM_KEYUP                0x0101
#define WM_CHAR                 0x0102
#define WM_DEADCHAR             0x0103
#define WM_SYSKEYDOWN           0x0104
#define WM_SYSKEYUP             0x0105
#define WM_SYSCHAR              0x0106
#define WM_SYSDEADCHAR          0x0107
#define WM_YOMICHAR             0x0108      /* ;Internal JAPAN */
#define WM_KEYLAST              0x0108
#define WM_CONVERTREQUEST       0x010A      /* ;Internal JAPAN */
#define WM_CONVERTRESULT        0x010B      /* ;Internal JAPAN */
#define WM_INTERIM              0x010C      /* ;Internal KOREA */

#define WM_INITDIALOG           0x0110
#define WM_COMMAND              0x0111
#define WM_SYSCOMMAND           0x0112
#define WM_TIMER                0x0113
#define WM_HSCROLL              0x0114
#define WM_VSCROLL              0x0115
#define WM_INITMENU             0x0116
#define WM_INITMENUPOPUP        0x0117
#define WM_SYSTIMER             0x0118      // ;Internal
#define WM_MENUSELECT           0x011F
#define WM_MENUCHAR             0x0120

#define WM_ENTERIDLE            0x0121
#if (WINVER >= 0x40A)                       // ;Internal 4.1
#define WM_MENURBUTTONUP        0x0122      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                 // ;Internal 4.1
                                            // ;Internal NT
#define WM_LBTRACKPOINT         0x0131      // ;Internal 
// #define WM_CTLCOLORFIRST     0x0132      // ;Internal NT
// #define WM_CTLCOLORMSGBOX    0x0132      // ;Internal NT
// #define WM_CTLCOLOREDIT      0x0133      // ;Internal NT
// #define WM_CTLCOLORLISTBOX   0x0134      // ;Internal NT
// #define WM_CTLCOLORBTN       0x0135      // ;Internal NT
// #define WM_CTLCOLORDLG       0x0136      // ;Internal NT
// #define WM_CTLCOLORSCROLLBAR 0x0137      // ;Internal NT
// #define WM_CTLCOLORSTATIC    0x0138      // ;Internal NT
// #define WM_CTLCOLORLAST      0x0138      // ;Internal NT
                                            // ;Internal NT
#define CB_FIRST_32             0x0140      // ;Internal
// #define CB_GETEDITSEL        0x0140      // ;Internal NT
// #define CB_LIMITTEXT         0x0141      // ;Internal NT
// #define CB_SETEDITSEL        0x0142      // ;Internal NT
// #define CB_ADDSTRING         0x0143      // ;Internal NT
// #define CB_DELETESTRING      0x0144      // ;Internal NT
// #define CB_DIR               0x0145      // ;Internal NT
// #define CB_GETCOUNT          0x0146      // ;Internal NT
// #define CB_GETCURSEL         0x0147      // ;Internal NT
// #define CB_GETLBTEXT         0x0148      // ;Internal NT
// #define CB_GETLBTEXTLEN      0x0149      // ;Internal NT
// #define CB_INSERTSTRING      0x014A      // ;Internal NT
// #define CB_RESETCONTENT      0x014B      // ;Internal NT
// #define CB_FINDSTRING        0x014C      // ;Internal NT
// #define CB_SELECTSTRING      0x014D      // ;Internal NT
// #define CB_SETCURSEL         0x014E      // ;Internal NT
// #define CB_SHOWDROPDOWN      0x014F      // ;Internal NT
                                            // ;Internal NT
// #define CB_GETITEMDATA       0x0150      // ;Internal NT
// #define CB_SETITEMDATA       0x0151      // ;Internal NT
// #define CB_GETDROPPEDCONTROLRECT 0x0152  // ;Internal NT
// #define CB_SETITEMHEIGHT     0x0153      // ;Internal NT
// #define CB_GETITEMHEIGHT     0x0154      // ;Internal NT
// #define CB_SETEXTENDEDUI     0x0155      // ;Internal NT
// #define CB_GETEXTENDEDUI     0x0156      // ;Internal NT
// #define CB_GETDROPPEDSTATE   0x0157      // ;Internal NT
// #define CB_FINDSTRINGEXACT   0x0158      // ;Internal NT
// #define CB_SETLOCALE         0x0159      // ;Internal NT
// #define CB_GETLOCALE         0x015A      // ;Internal NT
// #define CB_GETTOPINDEX       0x015B      // ;Internal NT 4.0
// #define CB_SETTOPINDEX       0x015C      // ;Internal NT 4.0
// #define CB_GETHORIZONTALEXTENT   0x015D  // ;Internal NT 4.0
// #define CB_SETHORIZONTALEXTENT   0x015E  // ;Internal NT 4.0
// #define CB_GETDROPPEDWIDTH   0x015F      // ;Internal NT 4.0
// #define CB_SETDROPPEDWIDTH   0x0160      // ;Internal NT 4.0
// #define CB_INITSTORAGE       0x0161      // ;Internal NT 4.0
#define CB_LAST_32              0x0161      // ;Internal
                                            // ;Internal
#define STM_FIRST_32            0x0170      // ;Internal
// #define STM_SETICON          0x0170      // ;Internal NT
// #define STM_GETICON          0x0171      // ;Internal NT
// #define STM_SETIMAGE         0x0172      // ;Internal NT 4.0
// #define STM_GETIMAGE         0x0173      // ;Internal NT 4.0
#define STM_LAST_32             0x0173      // ;Internal
                                            // ;Internal
#define LB_FIRST_32             0x0180      // ;Internal
// #define LB_ADDSTRING         0x0180      // ;Internal NT
// #define LB_INSERTSTRING      0x0181      // ;Internal NT
// #define LB_DELETESTRING      0x0182      // ;Internal NT
// #define LB_SELITEMRANGEEX    0x0183      // ;Internal NT
// #define LB_RESETCONTENT      0x0184      // ;Internal NT
// #define LB_SETSEL            0x0185      // ;Internal NT
// #define LB_SETCURSEL         0x0186      // ;Internal NT
// #define LB_GETSEL            0x0187      // ;Internal NT
// #define LB_GETCURSEL         0x0188      // ;Internal NT
// #define LB_GETTEXT           0x0189      // ;Internal NT
// #define LB_GETTEXTLEN        0x018A      // ;Internal NT
// #define LB_GETCOUNT          0x018B      // ;Internal NT
// #define LB_SELECTSTRING      0x018C      // ;Internal NT
// #define LB_DIR               0x018D      // ;Internal NT
// #define LB_GETTOPINDEX       0x018E      // ;Internal NT
// #define LB_FINDSTRING        0x018F      // ;Internal NT
                                            // ;Internal NT
// #define LB_GETSELCOUNT       0x0190      // ;Internal NT
// #define LB_GETSELITEMS       0x0191      // ;Internal NT
// #define LB_SETTABSTOPS       0x0192      // ;Internal NT
// #define LB_GETHORIZONTALEXTENT  0x0193   // ;Internal NT
// #define LB_SETHORIZONTALEXTENT  0x0194   // ;Internal NT
// #define LB_SETCOLUMNWIDTH    0x0195      // ;Internal NT
// #define LB_ADDFILE           0x0196      // ;Internal NT
// #define LB_SETTOPINDEX       0x0197      // ;Internal NT
// #define LB_GETITEMRECT       0x0198      // ;Internal NT
// #define LB_GETITEMDATA       0x0199      // ;Internal NT
// #define LB_SETITEMDATA       0x019A      // ;Internal NT
// #define LB_SELITEMRANGE      0x019B      // ;Internal NT
// #define LB_SETANCHORINDEX    0x019C      // ;Internal NT
// #define LB_GETANCHORINDEX    0x019D      // ;Internal NT
// #define LB_SETCARETINDEX     0x019E      // ;Internal NT
// #define LB_GETCARETINDEX     0x019F      // ;Internal NT
                                            // ;Internal NT
// #define LB_SETITEMHEIGHT     0x01A0      // ;Internal NT
// #define LB_GETITEMHEIGHT     0x01A1      // ;Internal NT
// #define LB_FINDSTRINGEXACT   0x01A2      // ;Internal NT
// #define LBCB_CARETON         0x01A3      // ;Internal NT
// #define LBCB_CARETOFF        0x01A4      // ;Internal NT
// #define LB_SETLOCALE         0x01A5      // ;Internal NT
// #define LB_GETLOCALE         0x01A6      // ;Internal NT
// #define LB_SETCOUNT          0x01A7      // ;Internal NT
// #define LB_INITSTORAGE       0x01A8      // ;Internal NT 4.0
// #define LB_ITEMFROMPOINT     0x01A9      // ;Internal NT 4.0
// #define LB_INSERTSTRINGUPPER 0x01AA      // ;Internal NT 4.0
// #define LB_INSERTSTRINGLOWER 0x01AB      // ;Internal NT 4.0
// #define LB_ADDSTRINGUPPER    0x01AC      // ;Internal NT 4.0
// #define LB_ADDSTRINGLOWER    0x01AD      // ;Internal NT 4.0
#define LB_LAST_32              0x01AD      // ;Internal
                                            // ;Internal
#define MN_FIRST_32             0x01E0      // ;Internal
// #define MN_SETHMENU          0x01E0      // ;Internal NT
// #define MN_GETHMENU          0x01E1      // ;Internal NT
// #define MN_SIZEWINDOW        0x01E2      // ;Internal NT
// #define MN_OPENHIERARCHY     0x01E3      // ;Internal NT
// #define MN_CLOSEHIERARCHY    0x01E4      // ;Internal NT
// #define MN_SELECTITEM        0x01E5      // ;Internal NT
// #define MN_CANCELMENUS       0x01E6      // ;Internal NT
// #define MN_SELECTFIRSTVALIDITEM  0x01E7  // ;Internal NT
// #define MN_GETPPOPUPMENU     0x01EA      // ;Internal NT
// #define MN_FINDMENUWINDOWFROMPOINT   0x01EB  // ;Internal NT
// #define MN_SHOWPOPUPWINDOW   0x01EC      // ;Internal NT
// #define MN_BUTTONDOWN        0x01ED      // ;Internal NT
// #define MN_MOUSEMOVE         0x01EE      // ;Internal NT
// #define MN_BUTTONUP          0x01EF      // ;Internal NT
// #define MN_SETTIMERTOOPENHIERARCHY   0x01F0  // ;Internal NT
// #define MN_DBLCLK            0x01F1      // ;Internal NT 4.0
#define MN_LAST_32              0x01E7      // ;Internal

#define WM_MOUSEFIRST           0x0200
#define WM_MOUSEMOVE            0x0200
#define WM_LBUTTONDOWN          0x0201
#define WM_LBUTTONUP            0x0202
#define WM_LBUTTONDBLCLK        0x0203
#define WM_RBUTTONDOWN          0x0204
#define WM_RBUTTONUP            0x0205
#define WM_RBUTTONDBLCLK        0x0206
#define WM_MBUTTONDOWN          0x0207
#define WM_MBUTTONUP            0x0208
#define WM_MBUTTONDBLCLK        0x0209
#define WM_MOUSELAST            0x0209

#define WM_PARENTNOTIFY         0x0210
#define WM_ENTERMENULOOP        0x0211      // ;Internal
#define WM_EXITMENULOOP         0x0212      // ;Internal
#define WM_NEXTMENU             0x0213      // ;Internal
#define WM_SIZING               0x0214      // ;Internal 4.0
#define WM_CAPTURECHANGED       0x0215      // ;Internal 4.0
#define WM_MOVING               0x0216      // ;Internal 4.0
#define WM_POWERBROADCAST	    0x0218	    // ;Internal 4.0
#define WM_DEVICECHANGE         0x0219      // ;Internal 4.0

#define WM_MDICREATE            0x0220
#define WM_MDIDESTROY           0x0221
#define WM_MDIACTIVATE          0x0222
#define WM_MDIRESTORE           0x0223
#define WM_MDINEXT              0x0224
#define WM_MDIMAXIMIZE          0x0225
#define WM_MDITILE              0x0226
#define WM_MDICASCADE           0x0227
#define WM_MDIICONARRANGE       0x0228
#define WM_MDIGETACTIVE         0x0229
#define WM_DROPOBJECT           0x022A      // ;Internal
#define WM_QUERYDROPOBJECT      0x022B      // ;Internal
#define WM_BEGINDRAG            0x022C      // ;Internal
#define WM_DRAGLOOP             0x022D      // ;Internal
#define WM_DRAGSELECT           0x022E      // ;Internal
#define WM_DRAGMOVE             0x022F      // ;Internal

#define WM_MDISETMENU           0x0230
#define WM_ENTERSIZEMOVE        0x0231      
#define WM_EXITSIZEMOVE         0x0232      
#define WM_DROPFILES            0x0233
#define WM_MDIREFRESHMENU       0x0234      // ;Internal NT
                                            // ;Internal JAPAN/KOREA
#define WM_KANJIFIRST           0x0280      // ;Internal JAPAN
#define WM_KANJILAST            0x029F      // ;Internal JAPAN
#define WM_HANGEULFIRST         0x0280      // ;Internal KOREA
#define WM_HANGEULLAST          0x029F      // ;Internal KOREA


#if (WINVER >= 0x40A)
#define WM_TRACKMOUSEEVENT_FIRST    0x02A0  // ;Internal
#define WM_NCMOUSEHOVER         0x02A0
#define WM_MOUSEHOVER           0x02A1
#define WM_NCMOUSELEAVE         0x02A2
#define WM_MOUSELEAVE           0x02A3
#define WM_TRACKMOUSEEVENT_LAST     0x02AF  // ;Internal
#endif // (WINVER >=0x40A)

#define WM_CUT                  0x0300
#define WM_COPY                 0x0301
#define WM_PASTE                0x0302
#define WM_CLEAR                0x0303
#define WM_UNDO                 0x0304
#define WM_RENDERFORMAT         0x0305
#define WM_RENDERALLFORMATS     0x0306
#define WM_DESTROYCLIPBOARD     0x0307
#define WM_DRAWCLIPBOARD        0x0308
#define WM_PAINTCLIPBOARD       0x0309
#define WM_SIZECLIPBOARD        0x030B
#define WM_VSCROLLCLIPBOARD     0x030A
#define WM_ASKCBFORMATNAME      0x030C
#define WM_CHANGECBCHAIN        0x030D
#define WM_HSCROLLCLIPBOARD     0x030E
#define WM_QUERYNEWPALETTE      0x030F

#define WM_PALETTEISCHANGING    0x0310
#define WM_PALETTEGONNACHANGE WM_PALETTEISCHANGING // ;Internal
#define WM_PALETTECHANGED       0x0311
#define WM_CHANGEPALETTE        WM_PALETTECHANGED // ;Internal
#define WM_HOTKEY               0x0312          // ;Internal NT
#define WM_SYSMENU              0x0313          // ;Internal
#define WM_HOOKMSG              0x0314          // ;Internal NT
#define WM_EXITPROCESS          0x0315          // ;Internal NT
#define WM_WAKETHREAD           0x0316          // ;Internal NT
#define WM_PRINT                0x0317
#define WM_PRINTCLIENT          0x0318

/* WinPad specific messages */
#define WM_HANDHELDFIRST        0x0358
#define WM_HANDHELDLAST         0x035F
                                                // ;Internal
/* Reserved for AFX */                          // ;Internal
#define WM_AFXFIRST             0x0360          // ;Internal
#define WM_AFXLAST              0x037F          // ;Internal

/* PenWindows specific messages */
#define WM_PENWINFIRST          0x0380
#define WM_PENWINLAST           0x038F

/* Coalescing messages */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      // ;Internal
#define WM_COALESCE_FIRST           0x0390
#define WM_COALESCE_LAST            0x039F
#define WM_INTERNAL_COALESCE_LAST   0x03B0      // ;Internal

/* Multimedia messages */                       /* ;Internal */
#define WM_MM_RESERVED_FIRST    0x03A0          /* ;Internal */
#define WM_MM_RESERVED_LAST     0x03DF          /* ;Internal */
                                                /* ;Internal */
/* DDE messages */                              /* ;Internal */
#define WM_INTERNAL_DDE_FIRST   0x03E0          /* ;Internal */
/* #define WM_DDE_INITIATE         0x03E0 */    /* ;Internal */
/* #define WM_DDE_TERMINATE        0x03E1 */    /* ;Internal */
/* #define WM_DDE_ADVISE           0x03E2 */    /* ;Internal */
/* #define WM_DDE_UNADVISE         0x03E3 */    /* ;Internal */
/* #define WM_DDE_ACK              0x03E4 */    /* ;Internal */
/* #define WM_DDE_DATA             0x03E5 */    /* ;Internal */
/* #define WM_DDE_REQUEST          0x03E6 */    /* ;Internal */
/* #define WM_DDE_POKE             0x03E7 */    /* ;Internal */
/* #define WM_DDE_EXECUTE          0x03E8 */    /* ;Internal */
#define WM_INTERNAL_DDE_LAST    0x03EF          /* ;Internal */
                                                /* ;Internal */
/* CBT messages */                              /* ;Internal */
#define WM_CBT_RESERVED_FIRST   0x03F0          /* ;Internal */
#define WM_CBT_RESERVED_LAST    0x03FF          /* ;Internal */
                                                /* ;Internal */
#define WM_USER                 0x0400

/* NOTE: All messages between WM_APP and 0xBFFF are for exclusive use by apps */
#define WM_APP                  0x8000

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)
/*  wParam for WM_SIZING message  */
#define WMSZ_KEYSIZE        0           // ;Internal
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#define WMSZ_MOVE           9           // ;Internal
#define WMSZ_KEYMOVE        10          // ;Internal
#define WMSZ_SIZEFIRST      WMSZ_LEFT   // ;Internal

#endif  /* WINVER >= 0x400 */

/****** Application termination *********************************************/

#ifdef tagWND   // ;Internal
BOOL    WINAPI PostQuitMessage(int);    // ;Internal
#else           // ;Internal
void    WINAPI PostQuitMessage(int);
#endif          // ;Internal

/****** Window class management *********************************************/

#ifdef tagWND                                                       /* ;Internal */
typedef LRESULT (CALLBACK* WNDPROC)(HWND_16, UINT, WPARAM, LPARAM); /* ;Internal */
#else                                                               /* ;Internal */
typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
#endif                                                              /* ;Internal */

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;
                                    /* ;Internal 4.0 */
typedef struct tagWNDCLASSEX        /* ;Internal 4.0 */
{                                   /* ;Internal 4.0 */
    DWORD       cbSize;             /* ;Internal 4.0 */
    DWORD       style;              /* ;Internal 4.0 */
    WNDPROC     lpfnWndProc;        /* ;Internal 4.0 */
    int         cbClsExtra;         /* ;Internal 4.0 */
    int         cbWndExtra;         /* ;Internal 4.0 */
    HINSTANCE   hInstance;          /* ;Internal 4.0 */
    HICON       hIcon;              /* ;Internal 4.0 */
    HCURSOR     hCursor;            /* ;Internal 4.0 */
    HBRUSH      hbrBackground;      /* ;Internal 4.0 */
    LPCSTR      lpszMenuName;       /* ;Internal 4.0 */
    LPCSTR      lpszClassName;      /* ;Internal 4.0 */
    HICON       hIconSm;            /* ;Internal 4.0 */
} WNDCLASSEX, FAR* LPWNDCLASSEX;    /* ;Internal 4.0 */

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
ATOM    WINAPI RegisterClassEx(const WNDCLASSEX FAR *);   /* ;Internal 4.0 */
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, LPWNDCLASS);
BOOL    WINAPI GetClassInfoEx(HINSTANCE, LPCSTR, LPWNDCLASSEX);   /* ;Internal 4.0 */
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008

#define CS_OEMCHARS         0x0010  // ;Internal
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_LVB              0x0400  // ;Internal
#define CS_SAVEBITS         0x0800

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#define CS_32BITCLASS       0x00008000  // ;Internal ONLY FOR USER.EXE
#define CS_SYSTEMCLASS      0x08000000  // ;Internal ONLY FOR USER.EXE
#define CS_SHORTCUT         0x10000000  // ;Internal ONLY FOR USER.EXE

#define CS_IME              0x00010000  // ;Internal for 4.0 IME.
#endif /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define GCW_HICONSM         (-34)           // ;Internal 4.0
#define GCL_STYLE           GCW_STYLE       // ;Internal 4.0
#endif  /* WINVER >= 0x0400 */              // ;Internal 4.0
#endif  /* WINVER >= 0x030a */
#endif /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED           0x00000000L
#define WS_POPUP                0x80000000L
#define WS_CHILD                0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS         0x04000000L
#define WS_CLIPCHILDREN         0x02000000L

/* Generic window states */
#define WS_VISIBLE              0x10000000L
#define WS_DISABLED             0x08000000L

/* Main window states */
#define WS_MINIMIZE             0x20000000L
#define WS_MAXIMIZE             0x01000000L

/* Main window styles */
#define WS_CAPTION              0x00C00000L     /* WS_BORDER | WS_DLGFRAME */
#define WS_BORDERMASK           0x00C00000L     // ;Internal
#define WS_BORDER               0x00800000L
#define WS_DLGFRAME             0x00400000L
#define WS_VSCROLL              0x00200000L
#define WS_HSCROLL              0x00100000L
#define WS_SYSMENU              0x00080000L
#define WS_THICKFRAME           0x00040000L
#define WS_MINIMIZEBOX          0x00020000L
#define WS_MAXIMIZEBOX          0x00010000L

/* Control window styles */
#define WS_GROUP                0x00020000L
#define WS_TABSTOP              0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW     (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW          (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW          (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_DRAGOBJECT        0x00000002L     // ;Internal
#define WS_EX_NOPARENTNOTIFY    0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
                                                // ;Internal 4.0
#if (WINVER >= 0x0400)                          // ;Internal 4.0
#define WS_EX_MDICHILD          0x00000040L     // ;Internal NT
#define WS_EX_TOOLWINDOW        0x00000080L     // ;Internal 4.0
#define WS_EX_WINDOWEDGE        0x00000100L     // ;Internal 4.0
#define WS_EX_CLIENTEDGE        0x00000200L     // ;Internal 4.0
#define WS_EX_EDGEMASK          (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)   // ;Internal 4.0
#define WS_EX_CONTEXTHELP       0x00000400L     // ;Internal 4.0
                                                // ;Internal 4.0
#define WS_EX_RIGHT             0x00001000L     // ;Internal 4.0
#define WS_EX_LEFT              0x00000000L     // ;Internal 4.0
#define WS_EX_RTLREADING        0x00002000L     // ;Internal 4.0
#define WS_EX_LTRREADING        0x00000000L     // ;Internal 4.0
#define WS_EX_LEFTSCROLLBAR     0x00004000L     // ;Internal 4.0
#define WS_EX_RIGHTSCROLLBAR    0x00000000L     // ;Internal 4.0
#define WS_EX_CONTROLPARENT     0x00010000L     // ;Internal 4.0
#define WS_EX_STATICEDGE        0x00020000L     // ;Internal 4.0
#define WS_EX_APPWINDOW         0x00040000L     // ;Internal 4.0
#define WS_EX_ANSICREATOR       0x80000000L     // ;Internal NT
                                                // ;Internal 4.0
#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)   // ;Internal 4.0
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)    // ;Internal 4.0
                                                // ;Internal 4.0
#endif // ;Internal WINVER >= 0x0400
#endif  /* WINVER >= 0x030a */

#define WS_EX_VALID             0x80077FFFL     /* ;Internal */
                                                /* ;Internal */
/* Obsolete style names */
#define WS_TILED                WS_OVERLAPPED
#define WS_ICONIC               WS_MINIMIZE
#define WS_SIZEBOX              WS_THICKFRAME
#define WS_TILEDWINDOW          WS_OVERLAPPEDWINDOW

#define WS_VALID                0xffff0000L     /* ;Internal */
                                                /* ;Internal */
#endif  /* NOWINSTYLES */

#if (WINVER >= 0x0400)                                      // ;Internal
/* WM_PRINT flags */                                        // ;Internal 4.0
#define PRF_CHECKVISIBLE    0x00000001L                     // ;Internal 4.0
#define PRF_NONCLIENT       0x00000002L                     // ;Internal 4.0
#define PRF_CLIENT          0x00000004L                     // ;Internal 4.0
#define PRF_ERASEBKGND      0x00000008L                     // ;Internal 4.0
#define PRF_CHILDREN        0x00000010L                     // ;Internal 4.0
#define PRF_OWNED           0x00000020L                     // ;Internal 4.0
                                                            // ;Internal 4.0
/* 3D border styles */                                      // ;Internal 4.0
#define BDR_RAISEDOUTER 0x0001                              // ;Internal 4.0
#define BDR_SUNKENOUTER 0x0002                              // ;Internal 4.0
#define BDR_RAISEDINNER 0x0004                              // ;Internal 4.0
#define BDR_SUNKENINNER 0x0008                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BDR_OUTER       0x0003                              // ;Internal 4.0
#define BDR_INNER       0x000c                              // ;Internal 4.0
#define BDR_RAISED      0x0005                              // ;Internal 4.0
#define BDR_SUNKEN      0x000a                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BDR_VALID       0x000F                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define EDGE_RAISED     (BDR_RAISEDOUTER | BDR_RAISEDINNER) // ;Internal 4.0
#define EDGE_SUNKEN     (BDR_SUNKENOUTER | BDR_SUNKENINNER) // ;Internal 4.0
#define EDGE_ETCHED     (BDR_SUNKENOUTER | BDR_RAISEDINNER) // ;Internal 4.0
#define EDGE_BUMP       (BDR_RAISEDOUTER | BDR_SUNKENINNER) // ;Internal 4.0
                                                            // ;Internal 4.0
/* Border flags */                                          // ;Internal 4.0
#define BF_LEFT         0x0001                              // ;Internal 4.0
#define BF_TOP          0x0002                              // ;Internal 4.0
#define BF_RIGHT        0x0004                              // ;Internal 4.0
#define BF_BOTTOM       0x0008                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_TOPLEFT      (BF_TOP | BF_LEFT)                  // ;Internal 4.0
#define BF_TOPRIGHT     (BF_TOP | BF_RIGHT)                 // ;Internal 4.0
#define BF_BOTTOMLEFT   (BF_BOTTOM | BF_LEFT)               // ;Internal 4.0
#define BF_BOTTOMRIGHT  (BF_BOTTOM | BF_RIGHT)              // ;Internal 4.0
#define BF_RECT         (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)  // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_DIAGONAL     0x0010                              // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_DIAGONAL_ENDTOPRIGHT     (BF_DIAGONAL | BF_TOP | BF_RIGHT)       // ;Internal 4.0
#define BF_DIAGONAL_ENDTOPLEFT      (BF_DIAGONAL | BF_TOP | BF_LEFT)        // ;Internal 4.0
#define BF_DIAGONAL_ENDBOTTOMLEFT   (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)     // ;Internal 4.0
#define BF_DIAGONAL_ENDBOTTOMRIGHT  (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)    // ;Internal 4.0
                                                            // ;Internal 4.0
#define BF_MIDDLE       0x0800                              // ;Internal 4.0
#define BF_SOFT         0x1000                              // ;Internal 4.0
#define BF_ADJUST       0x2000                              // ;Internal 4.0
#define BF_FLAT         0x4000                              // ;Internal 4.0
#define BF_MONO         0x8000                              // ;Internal 4.0
                                                            // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL WINAPI DrawEdge(HDC, LPRECT, UINT, UINT);              // ;Internal 4.0
                                                            // ;Internal 4.0
/* flags for DrawFrameControl */                            // ;Internal 4.0
#define DFC_CAPTION             1                           // ;Internal 4.0
#define DFC_MENU                2                           // ;Internal 4.0
#define DFC_SCROLL              3                           // ;Internal 4.0
#define DFC_BUTTON              4                           // ;Internal 4.0
#define DFC_CACHE               0xFFFF                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_CAPTIONCLOSE       0x0000                      // ;Internal 4.0
#define DFCS_CAPTIONMIN         0x0001                      // ;Internal 4.0
#define DFCS_CAPTIONMAX         0x0002                      // ;Internal 4.0
#define DFCS_CAPTIONRESTORE     0x0003                      // ;Internal 4.0
#define DFCS_CAPTIONHELP        0x0004                      // ;Internal 4.0
#define DFCS_INMENU             0x0040                      // ;Internal 4.0
#define DFCS_INSMALL            0x0080                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_MENUARROW          0x0000                      // ;Internal 4.0
#define DFCS_MENUCHECK          0x0001                      // ;Internal 4.0
#define DFCS_MENUBULLET         0x0002                      // ;Internal 4.0
#define DFCS_MENUARROWRIGHT     0x0004                      // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define DFCS_MENUARROWUP        0x0008                      // ;Internal 4.1
#define DFCS_MENUARROWDOWN      0x0010                      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                                 // ;Internal 4.1
                                                            // ;Internal 4.0
#define DFCS_SCROLLMIN          0x0000                      // ;Internal 4.0
#define DFCS_SCROLLVERT         0x0000                      // ;Internal 4.0
#define DFCS_SCROLLMAX          0x0001                      // ;Internal 4.0
#define DFCS_SCROLLHORZ         0x0002                      // ;Internal 4.0
#define DFCS_SCROLLLINE         0x0004                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_SCROLLUP           0x0000                      // ;Internal 4.0
#define DFCS_SCROLLDOWN         0x0001                      // ;Internal 4.0
#define DFCS_SCROLLLEFT         0x0002                      // ;Internal 4.0
#define DFCS_SCROLLRIGHT        0x0003                      // ;Internal 4.0
#define DFCS_SCROLLCOMBOBOX     0x0005                      // ;Internal 4.0
#define DFCS_SCROLLSIZEGRIP     0x0008                      // ;Internal 4.0
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010							// ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_BUTTONCHECK        0x0000                      // ;Internal 4.0
#define DFCS_BUTTONRADIOIMAGE   0x0001                      // ;Internal 4.0
#define DFCS_BUTTONRADIOMASK    0x0002                      // ;Internal 4.0
#define DFCS_BUTTONRADIO        0x0004                      // ;Internal 4.0
#define DFCS_BUTTON3STATE       0x0008                      // ;Internal 4.0
#define DFCS_BUTTONPUSH         0x0010                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_CACHEICON          0x0000                      // ;Internal 4.0
#define DFCS_CACHEBUTTONS       0x0001                      // ;Internal 4.0
                                                            // ;Internal 4.0
#define DFCS_INACTIVE           0x0100                      // ;Internal 4.0
#define DFCS_PUSHED             0x0200                      // ;Internal 4.0
#define DFCS_CHECKED            0x0400                      // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define DFCS_TRANSPARENT        0x0800                      // ;Internal 4.1
#define DFCS_HOT                0x1000                      // ;Internal 4.1
#endif // (WINVER >= 0x40A)                                 // ;Internal 4.1
#define DFCS_ADJUSTRECT         0x2000                      // ;Internal 4.0
#define DFCS_FLAT               0x4000                      // ;Internal 4.0
#define DFCS_MONO               0x8000                      // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL    WINAPI DrawFrameControl(HDC, LPRECT, UINT, UINT);   // ;Internal 4.0
                                                            // ;Internal 4.0
/* flags for DrawCaption */                                 // ;Internal 4.0
#define DC_ACTIVE           0x0001                          // ;Internal 4.0
#define DC_SMALLCAP         0x0002                          // ;Internal 4.0
#define DC_ICON             0x0004                          // ;Internal 4.0
#define DC_TEXT             0x0008                          // ;Internal 4.0
#define DC_INBUTTON         0x0010                          // ;Internal 4.0
#define DC_NOVISIBLE        0x0800                          // ;Internal
#define DC_BUTTONS          0x1000                          // ;Internal
#define DC_NOSENDMSG        0x2000                          // ;Internal
#define DC_CENTER           0x4000                          // ;Internal
#define DC_FRAME            0x8000                          // ;Internal
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)// ;Internal
#define DC_NC               (DC_CAPTION | DC_FRAME)         // ;Internal 
                                                            // ;Internal 4.0
BOOL    WINAPI DrawCaption(HWND, HDC, LPRECT, UINT);        // ;Internal 4.0
BOOL    WINAPI DrawCaptionTemp(HWND, HDC, LPRECT, HFONT, HICON, LPSTR, UINT); // ;Internal 4.0
                                                            // ;Internal 4.0
BOOL    WINAPI  PlaySoundEvent(int idSound);                // ;Internal
                                                            // ;Internal 4.0
#define IDANI_OPEN          1                               // ;Internal 4.0
#define IDANI_CLOSE         2                               // ;Internal 4.0
#define IDANI_CAPTION       3                               // ;Internal 4.0
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define IDANI_BORDER        4                               // ;Internal 4.1
#define IDANI_SLIDE         5                               // ;Internal 4.1
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1
BOOL    WINAPI  DrawAnimatedRects(HWND, int, LPCRECT, LPCRECT);   // ;Internal 4.0
#endif // WINVER >= VER40                                   // ;Internal


#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define PAS_IN          0x0001                              // ;Internal 4.1
#define PAS_OUT         0x0002                              // ;Internal 4.1
#define PAS_LEFT        0x0004                              // ;Internal 4.1
#define PAS_RIGHT       0x0008                              // ;Internal 4.1
#define PAS_UP          0x0010                              // ;Internal 4.1
#define PAS_DOWN        0x0020                              // ;Internal 4.1
#define PAS_HORZ        (PAS_LEFT | PAS_RIGHT)              // ;Internal
#define PAS_VERT        (PAS_UP | PAS_DOWN)                 // ;Internal 
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)
#if (WINVER >= 0x40A)                                       // ;Internal 4.1
#define HWND_MESSAGE        ((HWND)-3)
#endif // (WINVER >=0x40A)                                  // ;Internal 4.1

#ifdef tagWND                           // ;Internal
BOOL    WINAPI IsWindow(HWND_16);       // ;Internal
#else                                   // ;Internal
BOOL    WINAPI IsWindow(HWND);
#endif // tagWND                        // ;Internal

#ifdef tagWND                   /* ;Internal */
HWND_16  WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND_16, HMENU_16, HINSTANCE, void FAR*);          /* ;Internal */
HWND_16  WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND_16, HMENU_16, HINSTANCE, void FAR*); /* ;Internal */
#else                           /* ;Internal */
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
#endif                          /* ;Internal */

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
#ifdef tagWND                   /* ;Internal */
    HMENU_16  hMenu;            /* ;Internal */
    HWND_16   hwndParent;       /* ;Internal */
#else                           /* ;Internal */
    HMENU     hMenu;
    HWND      hwndParent;
#endif                          /* ;Internal */
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT, FAR * LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

#ifdef tagWND                           /* ;Internal */
HWND_16    WINAPI GetParent(HWND);      /* ;Internal */
HWND_16    WINAPI SetParent(HWND, HWND);/* ;Internal */
#else                                   /* ;Internal */
HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);
#endif                                  /* ;Internal */

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
BOOL    WINAPI ShowWindowAsync(HWND, int);  /* ;Internal 4.0 */
#endif                                  /* ;Internal 4.0 */

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           SW_SHOWNORMAL
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         SW_SHOWMAXIMIZED
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10      /* ;Internal NT */
#define SW_MAX              10      /* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         SW_HIDE
#define SHOW_OPENWINDOW     SW_SHOWNORMAL
#define SHOW_ICONWINDOW     SW_SHOWMINIMIZED
#define SHOW_FULLSCREEN     SW_SHOWMAXIMIZED
#define SHOW_OPENNOACTIVATE SW_SHOWNOACTIVATE

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif /* NOSHOWWINDOW */

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

/* Window text */
#ifdef tagWND   // ;Internal
BOOL    WINAPI SetWindowText(HWND, LPCSTR); // ;Internal
DWORD   WINAPI GetWindowTextLength(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowTextLength(HWND);
#endif          // ;Internal
int     WINAPI GetWindowText(HWND, LPSTR, int);

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC     (-4)
#define GWW_HINSTANCE   (-6)
#define GWW_HWNDPARENT  (-8)
#define GWW_ID          (-12)
#define GWL_STYLE       (-16)
#define GWL_EXSTYLE     (-20)
#define GWL_USERDATA    (-21)       /* ;Internal NT */
#endif  /* NOWINOFFSETS */
                                        /* ;Internal NT */
// BOOL WINAPI  IsWindowUnicode(HWND);  /* ;Internal NT */

#ifdef FE_IME                            // ;Internal IMM
#define SWIMC_SET             (0)        // ;internal IMM
#define SWIMC_RESET           (1)        // ;internal IMM
#define SWIMC_HIMC            (2)        // ;internal IMM
#define SWIMC_HSAVEDIMC       (3)        // ;internal IMM
#define SWIMC_RESETFORTHISIMC (4)        // ;internal IMM
#define SWIMC_SETNULLTOIMC    (5)        // ;internal IMM
#endif                                   // ;Internal IMM

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT     ((int)0x8000)

#ifdef tagWND       // ;Internal
BOOL    WINAPI GetClientRect(HWND, LPRECT);     // ;Internal
BOOL    WINAPI GetWindowRect(HWND, LPRECT);     // ;Internal
#else               // ;Internal
void    WINAPI GetClientRect(HWND, LPRECT);
void    WINAPI GetWindowRect(HWND, LPRECT);
#endif              // ;Internal

//  Multiple Monitor APIs                       // ;Internal
#if (WINVER >= 0x040A)                          // ;Internal
                                                // ;Internal
#ifdef tagWND                                   // ;Internal
#define HMONITOR    PMONITOR                    // ;Internal
#else                                           // ;Internal
DECLARE_HANDLE(HMONITOR);                       // ;Internal
#endif // tagWND                                // ;Internal
                                                // ;Internal
#define MONITOR_DEFAULTTONULL       0x0000      // ;Internal
#define MONITOR_DEFAULTTOPRIMARY    0x0001      // ;Internal
#define MONITOR_VALID               0x0001      // ;Internal
                                                // ;Internal
HMONITOR WINAPI MonitorFromPoint(POINT, UINT);  // ;Internal
HMONITOR WINAPI MonitorFromRect(LPCRECT, UINT); // ;Internal
HMONITOR WINAPI MonitorFromWindow(HWND, UINT);  // ;Internal
                                                // ;Internal
                                                // ;Internal
typedef struct tagMONITORINFO                   // ;Internal
{                                               // ;Internal
    DWORD   cbSize;                             // ;Internal
    RECT    rcMonitor;                          // ;Internal
    RECT    rcWork;                             // ;Internal
    UINT    BitCount;                           // ;Internal
    char    szDevice[32];                       // ;Internal
} MONITORINFO, FAR * LPMONITORINFO;             // ;Internal
                                                // ;Internal
BOOL WINAPI GetMonitorInfo(HMONITOR, LPMONITORINFO);    // ;Internal
                                                // ;Internal
                                                // ;Internal
typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM); // ;Internal
BOOL WINAPI EnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM); // ;Internal
#endif // WINVER >= 0x040A                      // ;Internal


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                                       // ;Internal
BOOL    WINAPI SetWindowPos(HWND, HWNDC, int, int, int, int, UINT); // ;Internal
#else                                                               // ;Internal
BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);
#endif                                                              // ;Internal
                                                                    // ;Internal
/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  // Client didn't resize         ;Internal
#define SWP_NOCLIENTMOVE    0x1000  // Client didn't move           ;Internal
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_ASYNCWINDOWPOS  0x4000  /* ;Internal NT BOGUS - make sure this is the same as NT! */
#define SWP_STATECHANGE     0x8000  /* ;Internal Force size, move messages */

/* Don't do any drawing or erasing */                       /* ;Internal */
#define SWP_DEFERDRAWING    SWP_DEFERERASE                  /* ;Internal */
                                                            /* ;Internal */
#define SWP_CHANGEMASK (SWP_NOSIZE | SWP_NOMOVE |           /* ;Internal */ \
                        SWP_NOZORDER | SWP_FRAMECHANGED |   /* ;Internal */ \
                        SWP_SHOWWINDOW | SWP_HIDEWINDOW |   /* ;Internal */ \
                        SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)/* ;Internal */
                                                            /* ;Internal */
#define SWP_NOCHANGE   (SWP_NOSIZE | SWP_NOMOVE |           /* ;Internal */ \
                        SWP_NOZORDER | SWP_NOCLIENTSIZE |   /* ;Internal */ \
                        SWP_NOCLIENTMOVE)                   /* ;Internal */
#define SWP_VALID       0x67ff                              /* ;Internal */
                                                            /* ;Internal */
/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST    /* ;Internal */


#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
#ifdef tagWND                                                               // ;Internal
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWNDC, int, int, int, int, UINT); // ;Internal
#else                                                                       // ;Internal
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
#endif                                                                      // ;Internal
BOOL    WINAPI EndDeferWindowPos(HDWP);
#if (WINVER >= 0x0400)                              // ;Internal
BOOL    WINAPI EndDeferWindowPosEx(HDWP, BOOL);     // ;Internal NT
#endif                                              // ;Internal

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwnd;               /* ;Internal */
    HWND_16 hwndInsertAfter;    /* ;Internal */
#else                           /* ;Internal */
    HWND    hwnd;
    HWND    hwndInsertAfter;
#endif                          /* ;Internal */
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(LPRECT, DWORD, BOOL);
#ifdef tagWND   // ;Internal
BOOL    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);  // ;Internal
#else           // ;Internal
void    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);
#endif          // ;Internal

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
#if (WINVER >= 0x40A)
    POINT ptMinSize;
#else
    POINT ptReserved;
#endif // (WINVER >= 0x40A)
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, FAR * LPMINMAXINFO;

BOOL    WINAPI FlashWindow(HWND, BOOL);

#ifdef tagWND   // ;Internal
BOOL    WINAPI ShowOwnedPopups(HWND, BOOL); // ;Internal
#else           // ;Internal
void    WINAPI ShowOwnedPopups(HWND, BOOL);
#endif          // ;Internal

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
#ifdef tagWND   // ;Internal
BOOL    WINAPI CloseWindow(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI CloseWindow(HWND);
#endif          // ;Internal
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

#ifdef tagWND   // ;Internal
BOOL    WINAPI ClientToScreen(HWND, LPPOINT);   // ;Internal
BOOL    WINAPI ScreenToClient(HWND, LPPOINT);   // ;Internal
#else           // ;Internal
void    WINAPI ClientToScreen(HWND, LPPOINT);
void    WINAPI ScreenToClient(HWND, LPPOINT);
#endif          // ;Internal

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                               /* ;Internal */
HWND_16    WINAPI WindowFromPoint(POINT);                   /* ;Internal */
HWND_16    WINAPI ChildWindowFromPoint(HWND, POINT);        /* ;Internal */
#else                                                       /* ;Internal */
HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);
#endif                                                      /* ;Internal */
                                                            /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                                      /* ;Internal 4.0 */
#define CWP_ALL             0x0000                          /* ;Internal 4.0 */
#define CWP_SKIPINVISIBLE   0x0001                          /* ;Internal 4.0 */
#define CWP_SKIPDISABLED    0x0002                          /* ;Internal 4.0 */
#define CWP_SKIPTRANSPARENT 0x0004                          /* ;Internal 4.0 */
#define CWP_VALID           0x0007                          /* ;Internal 4.0 */
                                                            /* ;Internal 4.0 */
#ifdef tagWND                                               /* ;Internal 4.0 */
HWND_16 WINAPI ChildWindowFromPointEx(HWND, POINT, UINT);   /* ;Internal 4.0 */
#else                                                       /* ;Internal 4.0 */
HWND    WINAPI ChildWindowFromPointEx(HWND, POINT, UINT);   /* ;Internal 4.0 */
#endif                                                      /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                               /* ;Internal 4.0 */

/****** Window query and enumeration ****************************************/

#ifdef tagWND                                               /* ;Internal */
HWND_16 WINAPI GetDesktopWindow(void);                      /* ;Internal */
HWND_16 WINAPI FindWindow(LPCSTR, LPCSTR);                  /* ;Internal */
HWND_16 WINAPI FindWindowEx(HWND, HWND, LPCSTR, LPCSTR);    /* ;Internal 4.0 */
HWND_16 WINAPI GetShellWindow(void);                        /* ;Internal 4.0 */
BOOL    WINAPI SetShellWindow(HWND_16);                     /* ;Internal 4.0 */
#else                                                       /* ;Internal */
HWND    WINAPI GetDesktopWindow(void);
HWND    WINAPI FindWindow(LPCSTR, LPCSTR);
HWND    WINAPI FindWindowEx(HWND, HWND, LPCSTR, LPCSTR);    /* ;Internal 4.0 */
HWND    WINAPI GetShellWindow(void);                        /* ;Internal 4.0 */
BOOL    WINAPI SetShellWindow(HWND);                        /* ;Internal 4.0 */
#endif                                                      /* ;Internal */

#ifdef STRICT
#ifdef tagWND                                               /* ;Internal */
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND_16, LPARAM);      /* ;Internal */
#else                                                       /* ;Internal */
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#endif                                                      /* ;Internal */
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);
#if (WINVER >= 0x0400)                                          // ;Internal 4.0
BOOL    WINAPI EnumWindowsEx(DWORD, HWND, WNDENUMPROC, LPARAM); // ;Internal 4.0
#endif                                                          // ;Internal 4.0


#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetTopWindow(HWND);              /* ;Internal */
HWND_16 WINAPI GetWindow(HWND, UINT);           /* ;Internal */
HWND_16 WINAPI GetNextWindow(HWND, UINT);       /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetTopWindow(HWND);
HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);
#endif                                          /* ;Internal */

/* GetWindow() constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5
#define GW_MAX              5 /* ;Internal */
                                                /* ;Internal */
#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetNextQueueWindow(HWND, int);   /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetNextQueueWindow(HWND, int);   /* ;Internal */
#endif                                          /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);
                                                /* ;Internal 4.0 */
#if (WINVER >= 0x400)                           /* ;Internal 4.0 */
BOOL    WINAPI SetPropEx(HWND, LPCSTR, DWORD);  /* ;Internal 4.0 */
DWORD   WINAPI GetPropEx(HWND, LPCSTR);         /* ;Internal 4.0 */
DWORD   WINAPI RemovePropEx(HWND, LPCSTR);      /* ;Internal 4.0 */
#endif    /* (WINVER >= 0x400) */               /* ;Internal 4.0 */

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND_16, LPCSTR, HANDLE); /* ;Internal */
#else                                                           /* ;Internal */
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#endif                                                          /* ;Internal */
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_NORESETATTRS    0x00000004L     // ;Internal
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L
#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L
#define DCX_EXCLUDEUPDATE   0x00000100L     // ;Internal
#define DCX_INTERSECTUPDATE 0x00000200L     // ;Internal
#define DCX_LOCKWINDOWUPDATE 0x00000400L
#define DCX_INVALID         0x00000800L     // ;Internal
#define DCX_INUSE           0x00001000L     // ;Internal
#define DCX_SAVEDRGNINVALID 0x00002000L     // ;Internal
#if (WINVER >= 0x040A)                      // ;Internal
#define DCX_MONITOR         0x00004000L     // ;Internal
#endif  // (WINVER >=0x040A)                // ;Internal
#define DCX_USESTYLE        0x00010000L
#define DCX_NEEDFONT        0x00020000L     // ;Internal OBSOLETE
#define DCX_NODELETERGN     0x00040000L     // ;Internal
#define DCX_NOCLIPCHILDREN  0x00080000L     // ;Internal
#define DCX_NORECOMPUTE     0x00100000L     // ;Internal
#define DCX_VALIDATE        0x00200000L     // ;Internal
                                            // ;Internal
#define DCX_MATCHMASK   (DCX_WINDOW | DCX_CLIPCHILDREN  |   /* ;Internal */ \
                        DCX_CACHE | DCX_CLIPSIBLINGS |      /* ;Internal */ \
                        DCX_LOCKWINDOWUPDATE)               /* ;Internal */
#define DCX_VALID           0x000104fbL                     /* ;Internal */
#endif  /* WINVER >= 0x030a */
                                    /* ;Internal NT */
#if (WINVER >= 0x0400)              /* ;Internal NT */
#ifdef tagWND                       /* ;Internal NT */
HWND_16 WINAPI WindowFromDC(HDC);   /* ;Internal NT */
#else                               /* ;Internal NT */
HWND    WINAPI WindowFromDC(HDC);   /* ;Internal NT */
#endif                              /* ;Internal NT */
#endif  /* WINVER >= 0x0400 */	    /* ;Internal NT */

/****** Window repainting ***************************************************/

// /* WM_SYNCTASK commands */       /* ;Internal NT */
// #define ST_BEGINSWP         0    /* ;Internal NT */
// #define ST_ENDSWP           1    /* ;Internal NT */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC  hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[16];
//  BYTE rgbReserved[32];        /* ;Internal NT */
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI  BeginPaint(HWND, LPPAINTSTRUCT);
#ifdef tagWND   // ;Internal
BOOL    WINAPI  EndPaint(HWND, const PAINTSTRUCT FAR*); // ;Internal
#else           // ;Internal
void    WINAPI  EndPaint(HWND, const PAINTSTRUCT FAR*);
#endif          // ;Internal

#ifdef tagWND   // ;Internal
BOOL    WINAPI  UpdateWindow(HWND); // ;Internal
#else           // ;Internal
void    WINAPI  UpdateWindow(HWND);
#endif          // ;Internal

int     WINAPI  ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, LPRECT, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

#ifdef tagWND   // ;Internal
BOOL    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);     // ;Internal
BOOL    WINAPI ValidateRect(HWND, LPCRECT);             // ;Internal
BOOL    WINAPI InvalidateRgn(HWND, HRGN, BOOL);         // ;Internal
BOOL    WINAPI ValidateRgn(HWND, HRGN);                 // ;Internal
#else           // ;Internal
void    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);
void    WINAPI ValidateRect(HWND, LPCRECT);
void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);
#endif          // ;Internal
int     WINAPI GetWindowRgn(HWND, HRGN);        // ;Internal 4.0
int     WINAPI SetWindowRgn(HWND, HRGN, BOOL);  // ;Internal 4.0

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, LPCRECT lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE      0x0001
#define RDW_INTERNALPAINT   0x0002
#define RDW_ERASE           0x0004
#define RDW_VALIDATE        0x0008

#define RDW_NOINTERNALPAINT 0x0010
#define RDW_NOERASE         0x0020
#define RDW_NOCHILDREN      0x0040
#define RDW_ALLCHILDREN     0x0080

#define RDW_UPDATENOW       0x0100
#define RDW_ERASENOW        0x0200
#define RDW_FRAME           0x0400
#define RDW_NOFRAME         0x0800
                                                                   // ;Internal
#define RDW_REDRAWWINDOW        0x1000  // ;Internal Called from RedrawWindow()
#define RDW_SUBTRACTSELF        0x2000  // ;Internal Subtract self from hrgn
#define RDW_COPYRGN             0x4000  // ;Internal Copy the passed-in region
#define RDW_IGNOREUPDATEDIRTY   0x8000  // ;Internal ignore WFUPDATEDIRTY

#define RDW_VALID           0x0fff                                  /* ;Internal */
#endif  /* WINVER >= 0x030a */
                                                        /* ;Internal 4.0 */
BOOL WINAPI PaintDesktop(HDC hdc);                      /* ;Internal 4.0 */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, LPCRECT, LPCRECT);
BOOL    WINAPI ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT);

#if (WINVER >= 0x030a)
int WINAPI ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT);

#define SW_SCROLLCHILDREN       0x0001
#define SW_INVALIDATE           0x0002
#define SW_ERASE                0x0004
#define SW_SCROLLWINDOW         0x8000  /* ;Internal */
#define SW_VALID                0x8007  /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400
                                            /* ;Internal */
#define WVR_MINVALID        WVR_ALIGNTOP    /* ;Internal */
#define WVR_MAXVALID        WVR_VALIDRECTS  /* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;


/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT          /* ;Internal */
#define HTSIZELAST          HTBOTTOMRIGHT   /* ;Internal */
#define HTOBJECT            19              // ;Internal 4.0
#define HTCLOSE             20              // ;Internal 4.0
#define HTHELP              21              // ;Internal 4.0
#define HTMAX               21              // ;Internal

//***** Drag-and-drop support *********************************    ;Internal
                                                                // ;Internal
// The rest of this section was formerly in userproc.h          // ;Internal
                                                                // ;Internal
typedef struct _dropstruct                                      // ;Internal
{                                                               // ;Internal
#ifdef tagWND                                                   // ;Internal
    HWND_16  hwndSource;                                        // ;Internal
    HWND_16  hwndSink;                                          // ;Internal
#else                                                           // ;Internal
    HWND hwndSource;                                            // ;Internal
    HWND hwndSink;                                              // ;Internal
#endif                                                          // ;Internal
    WORD  wFmt;                                                 // ;Internal
    DWORD dwData;                                               // ;Internal
    POINT ptDrop;                                               // ;Internal
    DWORD dwControlData;                                        // ;Internal
} DROPSTRUCT;                                                   // ;Internal
                                                                // ;Internal
typedef DROPSTRUCT FAR * LPDROPSTRUCT;                          // ;Internal
                                                                // ;Internal
#define DOF_EXECUTABLE      0x8001                              // ;Internal
#define DOF_DOCUMENT        0x8002                              // ;Internal
#define DOF_DIRECTORY       0x8003                              // ;Internal
#define DOF_MULTIPLE        0x8004                              // ;Internal
#define DOF_PROGMAN         0x0001                              // ;Internal
#define DOF_SHELLDATA       0x0002                              // ;Internal
                                                                // ;Internal
// special responses to WM_DROPOBJECT                           // ;Internal
// DO_DROPFILE  -> send a WM_DROPFILES message                  // ;Internal
//  DO_PRINTFILE -> print the files being dragged               // ;Internal
#define DO_DROPFILE         0x454C4946L                         // ;Internal
#define DO_PRINTFILE        0x544E5250L                         // ;Internal
                                                                // ;Internal
WORD API GetInternalWindowPos(HWND,LPRECT,LPPOINT);             // ;Internal
BOOL API SetInternalWindowPos(HWND,WORD,LPRECT,LPPOINT);        // ;Internal
                                                                // ;Internal
#ifdef tagWND                                                   // ;Internal
// DragObject goes through layer!                               // ;Internal
LRESULT API DragObject(HWND, HWND, WORD, DWORD, HANDLE);        // ;Internal
BOOL    API DragDetect(HWND_16, POINT);                         // ;Internal
                                                                // ;Internal
// FillWindow goes through layer!                               // ;Internal
void    CALLBACK FillWindow(HWND, HWND, HDC, HBRUSH);           // ;Internal
#else                                                           // ;Internal
// DragObject goes through layer!                               // ;Internal
LRESULT API DragObject(HWND, HWND, WORD, DWORD, HANDLE);        // ;Internal
BOOL    API DragDetect(HWND, POINT);                            // ;Internal
                                                                // ;Internal
void    CALLBACK FillWindow(HWND, HWND, HDC, HBRUSH);           // ;Internal
#endif                                                          // ;Internal
                                                                // ;Internal
/****** Window activation ***************************************************/

#ifdef tagWND                                       // ;Internal
HWND_16 WINAPI SetActiveWindow(HWND);               // ;Internal
HWND_16 WINAPI GetActiveWindow(void);               // ;Internal
HWND_16 WINAPI GetLastActivePopup(HWND);            // ;Internal
BOOL    WINAPI SetForegroundWindow(HWND);           // ;Internal NT
HWND_16 WINAPI GetForegroundWindow(void);           // ;Internal NT
#else                                               // ;Internal
HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);
HWND    WINAPI GetLastActivePopup(HWND);
#if (WINVER >= 0x0400)                              // ;Internal
BOOL WINAPI SetForegroundWindow(HWND);              // ;Internal NT
HWND WINAPI GetForegroundWindow(void);              // ;Internal NT
#endif                                              // ;Internal
#endif                                              // ;Internal

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

//***** Server *********************************************    ;Internal NT
//                                                              ;Internal NT
// /* Desktops */                                               ;Internal NT
// #define DESKTOP_ENUMWINDOWS      0x0001L                     ;Internal NT
// #define DESKTOP_CREATEWINDOW     0x0002L                     ;Internal NT
// #define DESKTOP_CREATEMENU       0x0004L                     ;Internal NT
// #define DESKTOP_HOOKCONTROL      0x0008L                     ;Internal NT
// #define DESKTOP_JOURNALRECORD    0x0010L                     ;Internal NT
// #define DESKTOP_JOURNALPLAYBACK  0x0020L                     ;Internal NT
// #define DESKTOP_ENUMERATE        0x0040L                     ;Internal NT
//                                                              ;Internal NT
// HDESK    WINAPI  GetThreadDesktop(DWORD idThread);           ;Internal NT
//                                                              ;Internal NT
// /* WinStations */                                            ;Internal NT
// #define WINSTA_ENUMDESKTOPS      0x0001L                     ;Internal NT
// #define WINSTA_READATTRIBUTES    0x0002L                     ;Internal NT
// #define WINSTA_ACCESSCLIPBOARD   0x0004L                     ;Internal NT
// #define WINSTA_CREATEDESKTOP     0x0008L                     ;Internal NT
// #define WINSTA_WRITEATTRIBUTES   0x0010L                     ;Internal NT
// #define WINSTA_ACCESSGLOBALATOMS 0x0020L                     ;Internal NT
// #define WINSTA_EXITWINDOWS       0x0040L                     ;Internal NT
// #define WINSTA_ENUMERATE         0x0100L                     ;Internal NT
// #define WINSTA_READSCREEN        0x0200L                     ;Internal NT
//                                                              ;Internal NT
// HWINSTA  WINAPI  GetProcessWindowStation();                  ;Internal NT
//                                                              ;Internal NT
// /* Security */                                               ;Internal NT
// #define WIN_ACCESSWINDOW         0x0001L                     ;Internal NT
// #define WIN_ENUMERATE            0x0002L                     ;Internal NT
// #define MENU_ACCESSMENU          0x0001L                     ;Internal NT
//                                                              ;Internal NT
// BOOL WINAPI  SetUserObjectSecurity(HANDLE,                   ;Internal NT
//              PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR);   ;Internal NT
// BOOL WINAPI  GetUserObjectSecurity(HANDLE,                   ;Internal NT
//              PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR,    ;Internal NT
//              DWORD, LPDWORD);                                ;Internal NT
// BOOL WINAPI  ImpersonateDDEClientWindow(HWND, HWND);         ;Internal NT
//                                                              ;Internal NT
/****** Keyboard input support **********************************************/

#ifdef tagWND                   /* ;Internal */
HWND_16 WINAPI SetFocus(HWND);  /* ;Internal */
HWND_16 WINAPI GetFocus(void);  /* ;Internal */
#else                           /* ;Internal */
HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);
#endif                          /* ;Internal */

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

#ifdef tagWND   // ;Internal
BOOL    WINAPI GetKeyboardState(LPBYTE);    // ;Internal
BOOL    WINAPI GetKeyboardState(LPBYTE);    // ;Internal
#else           // ;Internal
void    WINAPI GetKeyboardState(LPBYTE);
void    WINAPI SetKeyboardState(LPBYTE);
#endif          // ;Internalx

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED     0x0100
#define KF_DLGMODE      0x0800
#define KF_MENUMODE     0x1000
#define KF_ALTDOWN      0x2000
#define KF_REPEAT       0x4000
#define KF_UP           0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_KANA         0x15    /* ;Internal JAPAN */
#define VK_KANJI        0x19    /* ;Internal JAPAN */
#define VK_HANGEUL      0x15    /* ;Internal KOREA */
#define VK_JUNJA        0x17    /* ;Internal KOREA */
#define VK_HANJA        0x19    /* ;Internal KOREA */
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_LWIN         0x5B
#define VK_RWIN         0x5C
#define VK_APPS         0x5D
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '9' */

#endif  /* NOVIRTUALKEYCODES */
                                                        /* ;Internal */
BOOL WINAPI IsTwoByteCharPrefix(char);                  /* ;Internal */
                                                        /* ;Internal NT */
/* Keyboard Layout */                                /* ;Internal NT */
#define HKL_PREV             0                       /* ;Internal NT */
#define HKL_NEXT             1                       /* ;Internal NT */
                                                     /* ;Internal NT */
#define KLF_ACTIVATE         0x1                     /* ;Internal NT */
#define KLF_SUBSTITUTE_OK    0x2                     /* ;Internal NT */
#define KLF_UNLOADPREVIOUS   0x4                     /* ;Internal NT */
#define KLF_REORDER          0x8                     /* ;Internal NT */
                                                     /* ;Internal NT */
#define KLF_REPLACELANG		0x10					 /* ;Internal 4.0 */
#define KLF_NOTELLSHELL		0x80					 /* ;Internal 4.0 */

#define KL_NAMELENGTH        9                       /* ;Internal NT */
HKL  WINAPI  LoadKeyboardLayout(LPCSTR, UINT);       /* ;Internal NT */
HKL  WINAPI  GetKeyboardLayout(DWORD);               /* ;Internal 4.0 */
UINT WINAPI  GetKeyboardLayoutList(UINT, HKL FAR *); /* ;Internal 4.0 */
HKL WINAPI  ActivateKeyboardLayout(HKL, UINT);      /* ;Internal NT */
BOOL WINAPI  UnloadKeyboardLayout(HKL);              /* ;Internal NT */
BOOL WINAPI  GetKeyboardLayoutName(LPSTR);           /* ;Internal NT */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD     2

/****** Mouse input support *************************************************/

#ifdef tagWND   // ;Internal
HWND_16 WINAPI SetCapture(HWND);        // ;Internal
HWND_16 WINAPI GetCapture(void);        // ;Internal
BOOL    WINAPI ReleaseCapture(void);    // ;Internal
#else                                   // ;Internal
HWND    WINAPI SetCapture(HWND);
HWND    WINAPI GetCapture(void);
void    WINAPI ReleaseCapture(void);
#endif                                  // ;Internal

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON      0x0001
#define MK_RBUTTON      0x0002
#define MK_SHIFT        0x0004
#define MK_CONTROL      0x0008
#define MK_MBUTTON      0x0010
#endif  /* NOKEYSTATES */

#if (WINVER >= 0x40A)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_NONCLIENT   0x00000010
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL) // ;Internal

#define HOVER_DEFAULT   0xFFFFFFFF

typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
#ifdef tagWND           /* ;Internal */
    HWND_16 hwndTrack;  /* ;Internal */
#else                   /* ;Internal */
    HWND    hwndTrack;
#endif                  /* ;Internal */
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, FAR *LPTRACKMOUSEEVENT;

BOOL WINAPI TrackMouseEvent(LPTRACKMOUSEEVENT);

#endif /* !NOTRACKMOUSEEVENT */
#endif // (WINVER >=0x40A)

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
#ifdef tagWND           /* ;Internal */
    HWND_16 hwnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hwnd;
#endif                  /* ;Internal */
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif /* NOWH */

/****** Mode control ********************************************************/

#ifdef tagWND                           /* ;Internal */
HWND_16 WINAPI GetSysModalWindow(void); /* ;Internal */
HWND_16 WINAPI SetSysModalWindow(HWND); /* ;Internal */
#else                                   /* ;Internal */
HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);
#endif                                  /* ;Internal */


/****** Timer support *******************************************************/

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef void (CALLBACK* TIMERPROC)(HWND_16, UINT, UINT, DWORD); /* ;Internal */
#else                                                           /* ;Internal */
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#endif                                                          /* ;Internal */
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);
                                                                /* ;Internal */
WORD   FAR SetSystemTimer(HWND, int, int, TIMERPROC);           /* ;Internal */
BOOL   FAR KillSystemTimer(HWND, int);                          /* ;Internal */
HBRUSH CALLBACK GetControlBrush(HWND, HDC, UINT);               /* ;Internal */
void   CALLBACK PaintRect(HWND, HWND, HDC, HBRUSH, LPRECT);    /* ;Internal */
VOID   WINAPI   SwitchToThisWindow(HWND, BOOL);                      /* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);


#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, LPMSG);
#endif
                                                            /* ;Internal NT */
#define FVIRTKEY    0x01                                    /* ;Internal NT */
#define FNOINVERT   0x02                                    /* ;Internal NT */
#define FSHIFT      0x04                                    /* ;Internal NT */
#define FCONTROL    0x08                                    /* ;Internal NT */
#define FALT        0x10                                    /* ;Internal NT */
#define FLASTKEY    0x80                                    /* ;Internal NT */
                                                            /* ;Internal NT */
typedef struct tagACCEL                                     /* ;Internal NT */
{                                                           /* ;Internal NT */
    BYTE    fVirt;                                          /* ;Internal NT */
    WORD    key;                                            /* ;Internal NT */
    WORD    cmd;                                            /* ;Internal NT */
}                                                           /* ;Internal NT */
ACCEL, FAR* LPACCEL;                                        /* ;Internal NT */
                                                            /* ;Internal NT */
HACCEL  WINAPI CreateAcceleratorTable(LPACCEL, int);        /* ;Internal NT */
int     WINAPI CopyAcceleratorTable(HACCEL, LPACCEL, int);  /* ;Internal NT */
BOOL    WINAPI DestroyAcceleratorTable(HACCEL);             /* ;Internal NT */
                                                            /* ;Internal NT */
// #define IDHOT_SNAPWINDOW     (-1)                        /* ;Internal NT */
// #define IDHOT_SNAPDESKTOP    (-2)                        /* ;Internal NT */
                                                            /* ;Internal NT */
#ifdef tagWND                                               /* ;Internal NT */
BOOL WINAPI  RegisterHotKey(HWND_16, DWORD, UINT, UINT);    /* ;Internal NT */
BOOL WINAPI  UnregisterHotKey(HWND_16, DWORD);              /* ;Internal NT */
#else                                                       /* ;Internal NT */
BOOL WINAPI  RegisterHotKey(HWND, DWORD, UINT, UINT);       /* ;Internal NT */
BOOL WINAPI  UnregisterHotKey(HWND, DWORD);                 /* ;Internal NT */
#endif                                                      /* ;Internal NT */
#define MOD_ALT         0x0001                              /* ;Internal NT */
#define MOD_CONTROL     0x0002                              /* ;Internal NT */
#define MOD_SHIFT       0x0004                              /* ;Internal NT */
#define MOD_WIN         0x0008                              /* ;Internal NT */

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct tagMENUITEMTEMPLATEHEADER
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct tagMENUITEMTEMPLATE
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x0400)                                          // ;Internal 4.0
typedef struct tagMENUEXTEMPLATE                                // ;Internal 4.0
{                                                               // ;Internal 4.0
    WORD    wMenuVer;                                           // ;Internal 4.0
    WORD    dwHdrSize;                                          // ;Internal 4.0
} MENUEXTEMPLATE, FAR *LPMENUEXTEMPLATE;                        // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMENUEXHEADER                                  // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD   dwHelpID;                                           // ;Internal 4.0
} MENUEXHEADER, FAR *LPMENUEXHEADER;                            // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMENUEXITEMTEMPLATE                            // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD   fType;                                              // ;Internal 4.0
    DWORD   fState;                                             // ;Internal 4.0
    WORD    wID;                                                // ;Internal 4.0
    BYTE    bResInfo;                                           // ;Internal 4.0
} MENUEXITEMTEMPLATE, FAR *LPMENUEXITEMTEMPLATE;                // ;Internal 4.0
    /* Menu String */                                           // ;Internal 4.0
    /* if popup, MENUEXHEADER */                                // ;Internal 4.0
#endif                                                          // ;Internal 4.0
                                                                // ;Internal 4.0
#if (WINVER >= 0x030a)                                          // ;Internal
#ifdef tagWND                                                   // ;Internal
BOOL    WINAPI IsMenu(HMENU_16);                                // ;Internal
#else                                                           // ;Internal
BOOL    WINAPI IsMenu(HMENU);
#endif // tagWND                                                // ;Internal
#endif  /* WINVER >= 0x030a */                                  // ;Internal

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

#ifdef tagWND                                                               // ;Internal
DWORD    WINAPI GetMenu(HWND);                                              // ;Internal
HMENU_16 WINAPI GetSystemMenu(HWND, BOOL);                                  // ;Internal
HMENU_16 WINAPI GetSubMenu(HMENU, UINT);                                    // ;Internal
BOOL     WINAPI InsertMenu(HMENU_16, UINT, UINT, UINT, LPCSTR);             // ;Internal
BOOL     WINAPI AppendMenu(HMENU_16, UINT, UINT, LPCSTR);                   // ;Internal
BOOL     WINAPI ModifyMenu(HMENU_16, UINT, UINT, UINT, LPCSTR);             // ;Internal
BOOL     WINAPI ChangeMenu(HMENU_16, UINT, LPCSTR, UINT, UINT);             // ;Internal
BOOL     WINAPI SetMenuItemBitmaps(HMENU_16, UINT, UINT, HBITMAP, HBITMAP); // ;Internal
int      WINAPI GetMenuString(HMENU_16, UINT, LPSTR, int, UINT);            // ;Internal
#else                                                                       // ;Internal
HMENU   WINAPI GetMenu(HWND);
HMENU   WINAPI GetSystemMenu(HWND, BOOL);
HMENU   WINAPI GetSubMenu(HMENU, UINT);
BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);
BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
#endif // tagWND                                                            // ;Internal

BOOL    WINAPI DestroyMenu(HMENU);
BOOL    WINAPI SetMenu(HWND, HMENU);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */
#ifdef tagWND   // ;Internal
BOOL    WINAPI DrawMenuBar(HWND);   // ;Internal
#else           // ;Internal
void    WINAPI DrawMenuBar(HWND);
#endif          // ;Internal
int     WINAPI DrawMenuBarTemp(HWND, HDC, LPRECT, HMENU, HFONT);   // ;Internal
BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

#define MF_INSERT           0x0000  /* Obsolete -- only used by ChangeMenu */
#define MF_CHANGE           0x0080  /* Obsolete -- only used by ChangeMenu */
#define MF_APPEND           0x0100  /* Obsolete -- only used by ChangeMenu */
#define MF_DELETE           0x0200  /* Obsolete -- only used by ChangeMenu */
#define MF_REMOVE           0x1000  /* Obsolete -- only used by ChangeMenu */

#define MF_BYCOMMAND        0x0000  /* Obsolete -- only old APIs use these */
#define MF_BYPOSITION       0x0400  /* Obsolete -- only old APIs use these */
#define MF_USECHECKBITMAPS  0x0200  /* Obsolete -- replaced by MF_RADIOCHECK */
#define MF_HELP             0x4000  /* Obsolete -- use MF_RIGHTJUSTIFY */

#define MF_POPUP            0x0010  /* Obsolete -- replace by hSubMenu field */
#define MF_END              0x0080  /* Obsolete -- only used by old RES files */
#define MF_SYSMENU          0x2000  /* Passed back during WM_MENUSELECT */
#define MF_MOUSESELECT      0x8000  /* Passed back during WM_MENUSELECT */

#if (WINVER >= 0x40A)
#define MFT_STRING          0x0001  /* Obsolete -- use MIIM_STRING instead */
#else
#define MFT_STRING          0x0000
#endif
#define MFT_BITMAP          0x0004  /* Obsolete -- use MIIM_BITMAP instead */
#define MFT_MENUBARBREAK    0x0020
#define MFT_MENUBREAK       0x0040
#define MFT_OWNERDRAW       0x0100
#define MFT_RADIOCHECK      0x0200
#define MFT_SEPARATOR       0x0800
#define MFT_RIGHTORDER 	    0x2000
#define MFT_RIGHTJUSTIFY    0x4000
#define MFT_MASK            0x6B65		 // ;Internal

#define MFS_GRAYED          0x0003
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         0x0008
#define MFS_HILITE          0x0080
#define MFS_ENABLED         0x0000
#define MFS_UNCHECKED       0x0000
#define MFS_UNHILITE        0x0000
#if (WINVER >= 0x40A)                           // ;Internal 4.1
#define MFS_HOTTRACK        0x0100              // ;Internal 4.1
#endif // (WINVER >= 0x40A)                     // ;Internal 4.1
#define MFS_DEFAULT         0x1000
#define MFS_MASK            0x118B		 // ;Internal

#define MFR_POPUP           0x01
#define MFR_END             0x80

/* old names for menu types & states */
#define MF_SEPARATOR        MFT_SEPARATOR

#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_CHECKED          MFS_CHECKED
#define MF_ENABLED          MFS_ENABLED
#define MF_UNCHECKED        MFS_UNCHECKED
#define MF_UNHILITE         MFS_UNHILITE

#define MF_STRING           0x0000     /* Obsolete -- use MIIM_STRING instead */ 
#define MF_BITMAP           MFT_BITMAP /* Obsolete -- use MIIM_BITMAP instead */ 
#define MF_OWNERDRAW        MFT_OWNERDRAW

#define MF_MENUBARBREAK     MFT_MENUBARBREAK
#define MF_MENUBREAK        MFT_MENUBREAK

#define MF_HILITE           MFS_HILITE

#define MF_DEFAULT          MFS_DEFAULT
#define MF_RIGHTJUSTIFY     MFT_RIGHTJUSTIFY

#define MFT_OLDAPI_MASK     0x4B64  // ;Internal
#define MFS_OLDAPI_MASK     0x008B  // ;Internal
#define MFT_NONSTRING       0x0904  // MF_BITMAP | MF_OWNERDRAW | MF_SEPARATOR ;Internal
#define MFT_BREAK           0x0060  // MF_MENUBREAK | MF_MENUBARBREAK          ;Internal

#ifdef tagWND                                       // ;Internal
DWORD   WINAPI EnableMenuItem(HMENU, UINT, UINT);   // ;Internal
DWORD   WINAPI CheckMenuItem(HMENU, UINT, UINT);    // ;Internal
#else                                               // ;Internal
UINT    WINAPI EnableMenuItem(HMENU, UINT, UINT);
UINT    WINAPI CheckMenuItem(HMENU, UINT, UINT);
#endif                                              // ;Internal
BOOL    WINAPI CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);   // ;Internal 4.0

int     WINAPI GetMenuItemCount(HMENU);
#ifdef tagWND                                       // ;Internal
DWORD   WINAPI GetMenuItemID(HMENU, UINT);          // ;Internal
DWORD   WINAPI GetMenuState(HMENU, UINT, UINT);     // ;Internal
#else                                               // ;Internal
UINT    WINAPI GetMenuItemID(HMENU, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);
#endif                                              // ;Internal

DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT);

#if (WINVER >= 0x0400)                                  /* ;Internal 4.0 */
/* return codes for WM_MENUCHAR */                      /* ;Internal 4.0 */
#define MNC_IGNORE  0                                   /* ;Internal 4.0 */
#define MNC_CLOSE   1                                   /* ;Internal 4.0 */
#define MNC_EXECUTE 2                                   /* ;Internal 4.0 */
#define MNC_SELECT  3                                   /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
typedef struct tagTPMPARAMS                             /* ;Internal 4.0 */
{                                                       /* ;Internal 4.0 */
    DWORD   cbSize;                                     /* ;Internal 4.0 */
    RECT    rcExclude;                                  /* ;Internal 4.0 */
}                                                       /* ;Internal 4.0 */
TPMPARAMS, FAR *LPTPMPARAMS;                            /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);  /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */

#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
#define MNS_NOCHECK     0x00000001                      /* ;Internal 4.1 */
#define MNS_VALID       0x00000001                      // ;Internal
                                                        /* ;Internal 4.1 */
#define MIM_MAXHEIGHT   0x00000001                      /* ;Internal 4.1 */
#define MIM_BACKGROUND  0x00000002                      /* ;Internal 4.1 */
#define MIM_HELPID      0x00000004                      /* ;Internal 4.1 */
#define MIM_MENUDATA    0x00000008                      /* ;Internal 4.1 */
#define MIM_STYLE       0x00000010                      /* ;Internal 4.1 */
#define MIM_MASK        0x0000001F                      // ;Internal
                                                        /* ;Internal 4.1 */
typedef struct tagMENUINFO                              /* ;Internal 4.1 */
{                                                       /* ;Internal 4.1 */
    DWORD   cbSize;                                     /* ;Internal 4.1 */
    DWORD   fMask;                                      /* ;Internal 4.1 */
    DWORD   dwStyle;                                    /* ;Internal 4.1 */
    DWORD   cyMax;                                      /* ;Internal 4.1 */
    DWORD   hbrBack;                                    /* ;Internal 4.1 */
    DWORD   dwContextHelpID;                            /* ;Internal 4.1 */
    DWORD   dwMenuData;                                 /* ;Internal 4.1 */
}                                                       /* ;Internal 4.1 */
MENUINFO, FAR *LPMENUINFO;                              /* ;Internal 4.1 */
typedef const MENUINFO FAR *LPCMENUINFO;                /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
                                                        /* ;Internal 4.0 */
#define MIIM_STATE       0x00000001                     /* ;Internal 4.0 */
#define MIIM_ID          0x00000002                     /* ;Internal 4.0 */
#define MIIM_SUBMENU     0x00000004                     /* ;Internal 4.0 */
#define MIIM_CHECKMARKS  0x00000008                     /* ;Internal 4.0 */
#define MIIM_TYPE        0x00000010                     /* ;Internal 4.0 */
#define MIIM_DATA        0x00000020                     /* ;Internal 4.0 */
#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
#define MIIM_STRING      0x00000040                     /* ;Internal 4.1 */
#define MIIM_BITMAP      0x00000080                     /* ;Internal 4.1 */
#define MIIM_FTYPE       0x00000100                     /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
#define MIIM_MASK        0x000001FF                     // ;Internal

                                                        /* ;Internal 4.0 */
typedef struct tagMENUITEMINFO                          /* ;Internal 4.0 */
{                                                       /* ;Internal 4.0 */
    DWORD   cbSize;                                     /* ;Internal 4.0 */
    DWORD   fMask;                                      /* ;Internal 4.0 */
    UINT    fType;                                      /* ;Internal 4.0 */
    UINT    fState;                                     /* ;Internal 4.0 */
    UINT    wID;                                        /* ;Internal 4.0 */
#ifdef tagWND                                           /* ;Internal 4.0 */
    HMENU_16 hSubMenu;                                  /* ;Internal 4.0 */
#else                                                   /* ;Internal 4.0 */
    HMENU   hSubMenu;                                   /* ;Internal 4.0 */
#endif                                                  /* ;Internal 4.0 */
    HBITMAP hbmpChecked;                                /* ;Internal 4.0 */
    HBITMAP hbmpUnchecked;                              /* ;Internal 4.0 */
    DWORD   dwItemData;                                 /* ;Internal 4.0 */
    LPSTR   dwTypeData;                                 /* ;Internal 4.0 */
    UINT    cch;                                        /* ;Internal 4.0 */ 
#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
    HBITMAP hbmpItem;                                   /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
}                                                       /* ;Internal 4.0 */
MENUITEMINFO, FAR* LPMENUITEMINFO;                      /* ;Internal 4.0 */
typedef const MENUITEMINFO FAR * LPCMENUITEMINFO;       /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI InsertMenuItem (HMENU, UINT, BOOL, LPCMENUITEMINFO); /* ;Internal 4.0 */
BOOL    WINAPI GetMenuItemInfo(HMENU, UINT, BOOL, LPMENUITEMINFO);  /* ;Internal 4.0 */
BOOL    WINAPI SetMenuItemInfo(HMENU, UINT, BOOL, LPCMENUITEMINFO); /* ;Internal 4.0 */
#if (WINVER >= 0x40A)                                   /* ;Internal 4.1 */
BOOL    WINAPI GetMenuInfo(HMENU, LPMENUINFO);          /* ;Internal 4.1 */
BOOL    WINAPI SetMenuInfo(HMENU, LPCMENUINFO);         /* ;Internal 4.1 */
#endif // (WINVER >= 0x40A)                             /* ;Internal 4.1 */
                                                        /* ;Internal 4.0 */
#define GMDI_USEDISABLED    0x0001                      /* ;Internal 4.0 */
#define GMDI_GOINTOPOPUPS   0x0002                      /* ;Internal 4.0 */
DWORD   WINAPI GetMenuDefaultItem(HMENU, BOOL, UINT);   /* ;Internal 4.0 */
BOOL    WINAPI SetMenuDefaultItem(HMENU, UINT, BOOL);   /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
BOOL    WINAPI GetMenuItemRect(HWND, HMENU, UINT, LPRECT);    /* ;Internal 4.0 */
int     WINAPI MenuItemFromPoint(HWND, HMENU, POINT);         /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                           /* ;Internal 4.0 */
                                                        /* ;Internal 4.0 */
/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON      0x0000

#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON     0x0002
#define TPM_LEFTALIGN       0x0000
#define TPM_CENTERALIGN     0x0004
#define TPM_RIGHTALIGN      0x0008
                                                        // ;Internal
#if (WINVER >= 0x0400)                                  // ;Internal
#define TPM_TOPALIGN        0x0000                      // ;Internal 4.0
#define TPM_VCENTERALIGN    0x0010                      // ;Internal 4.0
#define TPM_BOTTOMALIGN     0x0020                      // ;Internal 4.0
                                                        // ;Internal 4.0
#define TPM_HORIZONTAL      0x0000                      // ;Internal 4.0
#define TPM_VERTICAL        0x0040                      // ;Internal 4.0
#define TPM_NONOTIFY        0x0080                      // ;Internal 4.0
#define TPM_RETURNCMD       0x0100                      // ;Internal 4.0
#define TPM_SYSMENU         0x0200                      // ;Internal
#if (WINVER >= 0x040A)                                  // ;Internal 4.1
#define TPM_RECURSE         0x0001                      // ;Internal 4.1
#endif /* WINVER >= 0x040A */                           // ;Internal 4.1
#endif /* WINVER >= 0x0400 */                           // ;Internal
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
#define SB_MSGCMD_MAX       8     /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
#define SB_MAX              3                               // ;Internal

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
#ifdef tagWND   // ;Internal
LONG    WINAPI GetScrollPos(HWND, int);                     // ;Internal
BOOL    WINAPI GetScrollRange(HWND, int, LPINT, LPINT);     // ;Internal
BOOL    WINAPI SetScrollRange(HWND, int, int, int, BOOL);   // ;Internal
BOOL    WINAPI ShowScrollBar(HWND, int, BOOL);              // ;Internal
#else           // ;Internal
int     WINAPI GetScrollPos(HWND, int);    
void    WINAPI GetScrollRange(HWND, int, LPINT, LPINT); 
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
#endif          // ;Internal
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT
#define ESB_MAX             0x0003                          // ;Internal
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH                // ;Internal
                                                            // ;Internal
#define SBM_FIRST_16        WM_USER                         // ;Internal
#define SBM_SETPOS          (WM_USER)                       // ;Internal
#define SBM_GETPOS          (WM_USER+1)                     // ;Internal
#define SBM_SETRANGE        (WM_USER+2)                     // ;Internal
#define SBM_GETRANGE        (WM_USER+3)                     // ;Internal
#define SBM_ENABLE_ARROWS   (WM_USER+4)                     // ;Internal
                                                            // ;Internal
#if (WINVER >= 0x0400)                                      // ;Internal 4.0
#define SBM_SETRANGEREDRAW  (WM_USER+6)                     // ;Internal 4.0
#define SBM_SETSCROLLINFO   (WM_USER+9)                     // ;Internal 4.0
#define SBM_GETSCROLLINFO   (WM_USER+10)                    // ;Internal 4.0
#define SBM_MSGMAX          (WM_USER+11)                    // ;Internal 4.0
                                                            // ;Internal 4.0
#define SIF_RANGE           0x0001                          // ;Internal 4.0
#define SIF_PAGE            0x0002                          // ;Internal 4.0
#define SIF_POS             0x0004                          // ;Internal 4.0
#define SIF_DISABLENOSCROLL 0x0008                          // ;Internal 4.0
#define SIF_TRACKPOS        0x0010                          // ;Internal 4.0
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)// ;Internal
#define SIF_RETURNOLDPOS    0x1000                          // ;Internal
#define SIF_NOSCROLL        0x2000                          // ;Internal
#define SIF_MASK            0x701F                          // ;Internal
                                                            // ;Internal 4.0
typedef struct tagSCROLLINFO                                // ;Internal 4.0
{                                                           // ;Internal 4.0
    DWORD   cbSize;                                         // ;Internal 4.0
    DWORD   fMask;                                          // ;Internal 4.0
    LONG    nMin;                                           // ;Internal 4.0
    LONG    nMax;                                           // ;Internal 4.0
    DWORD   nPage;                                          // ;Internal 4.0
    LONG    nPos;                                           // ;Internal 4.0
    LONG    nTrackPos;                                      // ;Internal 4.0
}                                                           // ;Internal 4.0
SCROLLINFO, FAR *LPSCROLLINFO;                              // ;Internal 4.0
typedef const SCROLLINFO FAR *LPCSCROLLINFO;                // ;Internal 4.0

                                                            // ;Internal 4.0
LONG WINAPI SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);  // ;Internal 4.0
BOOL WINAPI GetScrollInfo(HWND, int, LPSCROLLINFO);         // ;Internal 4.0
#endif /* WINVER >= 0x0400 */                               // ;Internal 4.0
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_FIRST            1
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13      // ;Internal NT
#define CF_ENHMETAFILE      14      // ;Internal NT
#define CF_HDROP            15      // ;Internal 4.0
#define CF_LOCALE           16      // ;Internal 4.0
#define CF_MAX              17      // ;Internal 4.0

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E  /* ;Internal NT */

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetOpenClipboardWindow(void);    /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetOpenClipboardWindow(void);
#endif                                          /* ;Internal */
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                   /* ;Internal */
HWND_16 WINAPI GetClipboardOwner(void);         /* ;Internal */
HWND_16 WINAPI SetClipboardViewer(HWND);        /* ;Internal */
HWND_16 WINAPI GetClipboardViewer(void);        /* ;Internal */
#else                                           /* ;Internal */
HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);
#endif                                          /* ;Internal */

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
#ifdef tagWND   // ;Internal
DWORD   WINAPI GetPriorityClipboardFormat(UINT FAR*, int);  // ;Internal
#else           // ;Internal
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);
#endif          // ;Internal

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

#endif  /* NOCLIPBOARD */
                                                /* ;Internal NT */
// /* LPARAM of WM_COPYDATA */                  /* ;Internal NT */
// typedef struct tagCOPYDATASTRUCT             /* ;Internal NT */
// {                                            /* ;Internal NT */
//    DWORD   dwData;                           /* ;Internal NT */
//    DWORD   cbData;                           /* ;Internal NT */
//    LPSTR   lpData;                           /* ;Internal NT */
// } COPYDATASTRUCT, FAR *LPCOPYDATASTRUCT;     /* ;Internal NT */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);
#ifdef tagWND   // ;Internal
BOOL    WINAPI ClipCursor(LPCRECT); // ;Internal
BOOL    WINAPI SetCursorPos(int, int);  // ;Internal
BOOL    WINAPI GetCursorPos(LPPOINT);   // ;Internal
#else           // ;Internal
void    WINAPI ClipCursor(LPCRECT);
void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(LPPOINT);
#endif          // ;Internal

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#ifdef tagWND   // ;Internal
BOOL    WINAPI GetClipCursor(LPRECT);   // ;Internal
#else           // ;Internal
void    WINAPI GetClipCursor(LPRECT);
#endif          // ;Internal
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW               MAKEINTRESOURCE(32512)
#define IDC_IBEAM               MAKEINTRESOURCE(32513)
#define IDC_WAIT                MAKEINTRESOURCE(32514)
#define IDC_CROSS               MAKEINTRESOURCE(32515)
#define IDC_UPARROW             MAKEINTRESOURCE(32516)
#define IDC_NWPEN               MAKEINTRESOURCE(32631)  // ;Internal
#define IDC_HUNG                MAKEINTRESOURCE(32632)  // ;Internal
#define IDC_SIZE                MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON                MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE            MAKEINTRESOURCE(32642)
#define IDC_SIZENESW            MAKEINTRESOURCE(32643)
#define IDC_SIZEWE              MAKEINTRESOURCE(32644)
#define IDC_SIZENS              MAKEINTRESOURCE(32645)
#define IDC_SIZEALL             MAKEINTRESOURCE(32646)
#define IDC_NO                  MAKEINTRESOURCE(32648)
#define IDC_APPSTARTING         MAKEINTRESOURCE(32650)  // ;Internal NT 4.0
#if (WINVER >= 0x0400)                                  // ;Internal 4.0
#define IDC_HELP                MAKEINTRESOURCE(32651)  // ;Internal 4.0
#endif  /* WINVER >= 0x400 */                           // ;Internal 4.0


/****** Icon support *********************************************************/


HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
                                                        /* ;Internal NT */
/* Icon/cursor information */                           /* ;Internal NT */
typedef struct tagICONINFO                              /* ;Internal NT */
{                                                       /* ;Internal NT */
    BOOL     fIcon;                                     /* ;Internal NT */
    int      xHotspot;                                  /* ;Internal NT */
    int      yHotspot;                                  /* ;Internal NT */
    HBITMAP  hbmMask;                                   /* ;Internal NT */
    HBITMAP  hbmColor;                                  /* ;Internal NT */
} ICONINFO, *PICONINFO, FAR *LPICONINFO;                /* ;Internal NT */
                                                        /* ;Internal NT */
HICON    WINAPI  CreateIconIndirect(const ICONINFO FAR *);  /* ;Internal NT */
BOOL     WINAPI  GetIconInfo(HICON, LPICONINFO);        /* ;Internal NT */
                                                        /* ;Internal 4.0 */
#define RES_ICON    1                                   /* ;Internal 4.0 */
#define RES_CURSOR  2                                   /* ;Internal 4.0 */

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;        /* RES_ICON or RES_CURSOR */
    WORD    ResCount;
} NEWHEADER, FAR *LPNEWHEADER;
                                                                            // ;Internal
#ifdef STRICT                                                               // ;Internal 
int WINAPI LookupIconIdFromDirectoryEx(LPNEWHEADER, BOOL, int, int, UINT);  // ;Internal 4.0 
#else                                                                       // ;Internal     
int WINAPI LookupIconIdFromDirectoryEx(LPVOID, BOOL, int, int, UINT);       // ;Internal 4.0 
#endif /* STRICT */                                                         // ;Internal   
                                                                            // ;Internal 4.0
HICON    WINAPI CreateIconFromResourceEx(LPVOID, DWORD, BOOL, DWORD,        // ;Internal 4.0
                UINT, UINT, UINT);                                          // ;Internal 4.0

#if (WINVER >= 0x0400)
/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
                                  
#define IMAGE_BITMAP        0           // ;Internal 4.0
#define IMAGE_ICON          1           // ;Internal 4.0
#define IMAGE_CURSOR        2           // ;Internal 4.0
#define IMAGE_ENHMETAFILE   3           // ;Internal 4.0
#define IMAGE_MAX           4           // ;Internal 4.0
                                        // ;Internal 4.0
HANDLE  WINAPI  LoadImage(HINSTANCE, LPCSTR, UINT, int, int, UINT); // ;Internal 4.0
HANDLE  WINAPI  CopyImage(HINSTANCE, HANDLE, UINT, int, int, UINT); // ;Internal 4.0
                                        // ;Internal 4.0
#define LR_DEFAULTCOLOR     0x0000      // ;Internal 4.0
#define LR_MONOCHROME       0x0001      // ;Internal 4.0
#define LR_COLOR            0x0002      // ;Internal 4.0
#define LR_COPYRETURNORG    0x0004      // ;Internal 4.0
#define LR_COPYDELETEORG    0x0008      // ;Internal 4.0
#define LR_LOADFROMFILE     0x0010      // ;Internal 4.0
#define LR_LOADTRANSPARENT  0x0020      // ;Internal 4.0
#define LR_DEFAULTSIZE      0x0040      // ;Internal 4.0
#define LR_VGACOLOR         0x0080      // ;Internal 4.0
#define LR_LOADMAP3DCOLORS  0x1000      // ;Internal 4.0
#define LR_CREATEDIBSECTION 0x2000      // ;Internal 4.0
#define LR_COPYFROMRESOURCE 0x4000      // ;Internal 4.0
#define LR_SHARED           0x8000      // ;Internal 4.0
                                        // ;Internal 4.0
#define DI_MASK             0x0001      // ;Internal 4.0
#define DI_IMAGE            0x0002      // ;Internal 4.0
#define DI_NORMAL           0x0003      // ;Internal 4.0
#define DI_COMPAT           0x0004      // ;Internal 4.0
#define DI_DEFAULTSIZE      0x0008      // ;Internal 4.0
                                        // ;Internal 4.0 
BOOL    WINAPI DrawIconEx(HDC hdc, int x, int y, HICON hIcon, int cx,   // ;Internal 4.0
    int cy, UINT istepIfAniCur, HBRUSH hbrFastDraw, UINT diFlags);      // ;Internal 4.0
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_ERROR           32513   /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        32514
#define IDI_WARNING         32515   /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     32516   /* ;win40: Name changed from IDI_ASTERISK */
#define IDI_WINLOGO         32517   /* ;Internal NT */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_ERROR           MAKEINTRESOURCE(32513)  /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_WARNING         MAKEINTRESOURCE(32515)  /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     MAKEINTRESOURCE(32516)  /* ;win40: Name changed from IDI_ASTERISK */
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)  /* ;Internal NT */
#endif /* RC_INVOKED */

#define IDI_HAND            IDI_ERROR
#define IDI_EXCLAMATION     IDI_WARNING
#define IDI_ASTERISK        IDI_INFORMATION

#endif  /* NOICONS */


/****** Caret support ********************************************************/

#ifdef tagWND       /* ;Internal */
BOOL    WINAPI CreateCaret(HWND, HBITMAP, int, int);    /* ;Internal */
BOOL    WINAPI DestroyCaret(void);                      /* ;Internal */
BOOL    WINAPI ShowCaret(HWND);                         /* ;Internal */
BOOL    WINAPI HideCaret(HWND);                         /* ;Internal */
BOOL    WINAPI SetCaretPos(int, int);                   /* ;Internal */
BOOL    WINAPI SetCaretBlinkTime(UINT);                 /* ;Internal */
BOOL    WINAPI GetCaretPos(LPPOINT);                    /* ;Internal */
#else               /* ;Internal */
void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);
void    WINAPI ShowCaret(HWND);
void    WINAPI HideCaret(HWND);
void    WINAPI SetCaretPos(int, int);
void    WINAPI SetCaretBlinkTime(UINT);
void    WINAPI GetCaretPos(LPPOINT);
#endif              /* ;Internal */
UINT    WINAPI GetCaretBlinkTime(void);

/****** WM_SYSCOMMAND support ***********************************************/

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#define SC_DEFAULT      0xF160  /* ;Internal 4.0 */
#define SC_MONITORPOWER 0xF170  /* ;Internal 4.0 */
#define SC_CONTEXTHELP  0xF180  /* ;Internal 4.0 */
#define SC_SEPARATOR    0xF00F  /* ;Internal 4.0 */

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
#ifdef tagWND                   /* ;Internal */
    HMENU_16  hWindowMenu;      /* ;Internal */
#else                           /* ;Internal */
    HMENU  hWindowMenu;
#endif                          /* ;Internal */
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#ifdef tagWND                                                      /* ;Internal */
LRESULT WINAPI DefFrameProc(HWND, HWND_16, UINT, WPARAM, LPARAM);  /* ;Internal */
#else                                                              /* ;Internal */
LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
#endif                                                             /* ;Internal */

LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, LPMSG);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);
BOOL    WINAPI TileChildWindows(HWND, UINT);
BOOL    WINAPI CascadeChildWindows(HWND, UINT);
                                                                /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                                          /* ;Internal 4.0 */
#ifdef tagWND                                                   /* ;Internal 4.0 */
typedef const HWND_16 FAR *LPHWND;                              /* ;Internal 4.0 */
#else                                                           /* ;Internal 4.0 */
typedef const HWND FAR *LPHWND;                                 /* ;Internal 4.0 */
#endif /* tagWND */                                             /* ;Internal 4.0 */
                                                                /* ;Internal 4.0 */
UINT WINAPI TileWindows   (HWND, UINT, LPCRECT, UINT, LPHWND);  /* ;Internal 4.0 */
UINT WINAPI CascadeWindows(HWND, UINT, LPCRECT, UINT, LPHWND);  /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                                   /* ;Internal 4.0 */
#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA 30

/* Dialog styles */
#define DS_ABSALIGN         0x0001L
#define DS_SYSMODAL         0x0002L
#define DS_LOCALEDIT        0x0020L
#define DS_SETFONT          0x0040L     
#define DS_MODALFRAME       0x0080L
#define DS_NOIDLEMSG        0x0100L
#define DS_SETFOREGROUND    0x0200L     // ;Internal NT
#define DS_VALID31          0x03e7L     // ;Internal
#if (WINVER >= 0x0400)                  // ;Internal
#define DS_3DLOOK           0x0004L     // ;Internal 4.0
#define DS_FIXEDSYS         0x0008L     // ;Internal 4.0
#define DS_NOFAILCREATE     0x0010L     // ;Internal 4.0
#define DS_CONTROL          0x0400L     // ;Internal 4.0
#define DS_RECURSE          DS_CONTROL  // ;Internal BOGUS GOING AWAY
#define DS_CENTER           0x0800L     // ;Internal 4.0
#define DS_CENTERMOUSE      0x1000L     // ;Internal 4.0
#define DS_CONTEXTHELP      0x2000L     // ;Internal 4.0
#define DS_COMMONDIALOG     0x4000L     // ;Internal
#define DS_VALID40          0x7FFFL     // ;Internal
#endif /* WINVER >= 0x0400 */           // ;Internal

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)
#define DM_REPOSITION       (WM_USER+2)     /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#if WINVER >= 0x0400                        /* ;Internal 4.0 */
#define PSM_PAGEINFO        (WM_USER+100)   /* ;Internal 4.0 */
#define PSM_SHEETINFO       (WM_USER+101)   /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#define PSI_SETACTIVE       0x0001L         /* ;Internal 4.0 */
#define PSI_KILLACTIVE      0x0002L         /* ;Internal 4.0 */
#define PSI_APPLY           0x0003L         /* ;Internal 4.0 */
#define PSI_RESET           0x0004L         /* ;Internal 4.0 */
#define PSI_HASHELP         0x0005L         /* ;Internal 4.0 */
#define PSI_HELP            0x0006L         /* ;Internal 4.0 */
                                            /* ;Internal 4.0 */
#define PSI_CHANGED         0x0001L         /* ;Internal 4.0 */
#define PSI_GUISTART        0x0002L         /* ;Internal 4.0 */
#define PSI_REBOOT          0x0003L         /* ;Internal 4.0 */
#define PSI_GETSIBLINGS     0x0004L         /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */               /* ;Internal 4.0 */

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#ifdef STRICT
#ifdef tagWND                                                   /* ;Internal */
typedef BOOL (CALLBACK* DLGPROC)(HWND_16, UINT, WPARAM, LPARAM);/* ;Internal */
#else                                                           /* ;Internal */
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#endif                                                          /* ;Internal */
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT       0
#define DWL_DLGPROC         4
#define DWL_USER            8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, LPMSG);
#endif

#ifdef tagWND                                                   /* ;Internal */
LRESULT WINAPI DefDlgProc(HWND_16, UINT, WPARAM, LPARAM);       /* ;Internal */
#else                                                           /* ;Internal */
LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);
#endif                                                          /* ;Internal */

#ifdef tagWND                                                                                   /* ;Internal */
HWND_16 WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);                                  /* ;Internal */
HWND_16 WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);                 /* ;Internal */
HWND_16 WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);                     /* ;Internal */
HWND_16 WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);    /* ;Internal */
#else                                                                                           /* ;Internal */
HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);
#endif                                                                                          /* ;Internal */

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
#ifdef tagWND                                                                       /* ;Internal */
long     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);           /* ;Internal */
long     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);  /* ;Internal */
#else                                                                               /* ;Internal */
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);
#endif                                                                              /* ;Internal */

void    WINAPI EndDialog(HWND, int);
BOOL    WINAPI EndDialog32(HWND, long);   /* ;Internal NT */

#ifdef tagWND                           /* ;Internal */
long    WINAPI GetDlgCtrlID(HWND);      /* ;Internal */
HWND_16 WINAPI GetDlgItem(HWND, int);   /* ;Internal */
#else                                   /* ;Internal */
int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
#endif                                  /* ;Internal */
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

#ifdef tagWND                                           /* ;Internal */
HWND_16 WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);   /* ;Internal */
HWND_16 WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);     /* ;Internal */
#else                                                   /* ;Internal */
HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);
#endif                                                  /* ;Internal */

#ifdef tagWND   // ;Internal
BOOL    WINAPI MapDialogRect(HWND, LPRECT);     // ;Internal
#else           // ;Internal
void    WINAPI MapDialogRect(HWND, LPRECT);
#endif          // ;Internal
DWORD   WINAPI GetDialogBaseUnits(void);

/* dialog codes */
#define DLGC_WANTARROWS         0x0001
#define DLGC_WANTTAB            0x0002
#define DLGC_WANTALLKEYS        0x0004
#define DLGC_WANTMESSAGE        0x0004
#define DLGC_HASSETSEL          0x0008
#define DLGC_DEFPUSHBUTTON      0x0010
#define DLGC_UNDEFPUSHBUTTON    0x0020
#define DLGC_RADIOBUTTON        0x0040
#define DLGC_WANTCHARS          0x0080
#define DLGC_STATIC             0x0100
#define DLGC_BUTTON             0x2000

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6
#define CTLCOLOR_MAX            7       // ;Internal

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
#if (WINVER >= 0x0400)          /* ;Internal 4.0 */
#define IDCLOSE         8       /* ;Internal 4.0 */
#define IDHELP          9       /* ;Internal 4.0 */
#define IDUSERICON      10      /* ;Internal 4.0 */
#endif                          /* ;Internal 4.0 */


//***** Control Notification support *********************  ;Internal 4.0
// should this be marked internal?                      //  ;Internal 4.0
typedef struct tagNMHDR
{
#ifdef tagWND
    HWND_16 hwndFrom;
#else
    HWND  hwndFrom;
#endif
    WORD  _wDummy1;						
    UINT  idFrom;
    WORD  _wDummy2;
    UINT  code;
    WORD  _wDummy3;
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

typedef struct tagSTYLESTRUCT                           // ;Internal 4.0
{                                                       // ;Internal 4.0
    /* Win4.0 fields */                                 // ;Internal 4.0
    DWORD   styleOld;                                   // ;Internal 4.0
    DWORD   styleNew;                                   // ;Internal 4.0 
}   STYLESTRUCT;                                        // ;Internal 4.0
typedef STYLESTRUCT FAR * LPSTYLESTRUCT;                // ;Internal 4.0
                                                        // ;Internal 4.0
/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU            1
#define ODT_LISTBOX         2
#define ODT_COMBOBOX        3
#define ODT_BUTTON          4
#define ODT_STATIC          5           /* ;Internal 4.0 */

/* Owner draw actions */
#define ODA_DRAWENTIRE      0x0001
#define ODA_SELECT          0x0002
#define ODA_FOCUS           0x0004

/* Owner draw state */
#define ODS_SELECTED        0x0001
#define ODS_GRAYED          0x0002
#define ODS_DISABLED        0x0004
#define ODS_CHECKED         0x0008
#define ODS_FOCUS           0x0010
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
#define ODS_DEFAULT         0x0020      /* ;Internal 4.0 */
#define ODS_COMBOBOXEDIT    0x1000      /* ;Internal 4.0 */
#define ODS_HOTTRACK        0x2000      /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */           /* ;Internal 4.0 */

/* LPARAM of WM_DRAWITEM is LPDRAWITEMSTRUCT */
typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
#ifdef tagWND                   /* ;Internal */
    HWND_16     hwndItem;       /* ;Internal */
#else                           /* ;Internal */
    HWND        hwndItem;
#endif                          /* ;Internal */
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

/* LPARAM of WM_MEASUREITEM is LPMEASUREITEMSTRUCT */
typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

/* LPARAM of WM_DELETEITEM is LPDELETEITEMSTRUCT */
typedef struct tagDELETEITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
#ifdef tagWND                   /* ;Internal */
    HWND_16     hwndItem;       /* ;Internal */
#else                           /* ;Internal */
    HWND        hwndItem;
#endif                          /* ;Internal */
    DWORD       itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

/* LPARAM of WM_COMPAREITEM is LPCOMPAREITEMSTRUCT */
typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwndItem;           /* ;Internal */
#else                           /* ;Internal */
    HWND hwndItem;
#endif                          /* ;Internal */
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL     // ;Internal
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_OWNERDRAW        0x0000000DL     // ;Internal 4.0
#define SS_BITMAP           0x0000000EL     // ;Internal 4.0
#define SS_ENHMETAFILE      0x0000000FL     // ;Internal 4.0
#define SS_ETCHEDHORZ       0x00000010L     // ;Internal 4.0
#define SS_ETCHEDVERT       0x00000011L     // ;Internal 4.0
#define SS_ETCHEDFRAME      0x00000012L     // ;Internal 4.0
#define SS_TYPEMASK         0x0000001FL     // ;Internal 4.0

#define SS_NOPREFIX         0x00000080L
#define SS_NOTIFY           0x00000100L     // ;Internal 4.0
#define SS_CENTERIMAGE      0x00000200L     // ;Internal 4.0
#define SS_RIGHTJUST        0x00000400L     // ;Internal 4.0
#define SS_REALSIZEIMAGE    0x00000800L     // ;Internal 4.0
#define SS_SUNKEN           0x00001000L     // ;Internal 4.0
#define SS_EDITCONTROL	    0x00002000L	    // ;Internal

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_FIRST_16        WM_USER         // ;Internal
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#if (WINVER >= 0x0400)                      // ;Internal 4.0
#define STM_SETIMAGE        (WM_USER+2)     // ;Internal 4.0
#define STM_GETIMAGE        (WM_USER+3)     // ;Internal 4.0
                                            // ;Internal 4.0
#define STN_CLICKED         0               // ;Internal 4.0
#define STN_DBLCLK          1               // ;Internal 4.0
#define STN_ENABLE          2               // ;Internal 4.0
#define STN_DISABLE         3               // ;Internal 4.0
#endif /* WINVER >= 0x0400 */               // ;Internal 4.0
#define STM_MSGMAX         (WM_USER+4)      // ;Internal 4.0
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL     // ;Internal
#define BS_OWNERDRAW        0x0000000BL
#define BS_TYPEMASK         0x0000000FL     // ;Internal

#define BS_TEXT             0x00000000L     // ;Internal 4.0
#define BS_RIGHTBUTTON      0x00000020L
#define BS_ICON             0x00000040L     // ;Internal 4.0
#define BS_BITMAP           0x00000080L     // ;Internal 4.0
#define BS_IMAGEMASK        0x000000C0L     // ;Internal 4.0
                                            // ;Internal 4.0
#define BS_LEFT             0x00000100L     // ;Internal 4.0
#define BS_RIGHT            0x00000200L     // ;Internal 4.0
#define BS_CENTER           0x00000300L     // ;Internal 4.0
#define BS_HORZMASK         0x00000300L     // ;Internal 4.0
#define BS_TOP              0x00000400L     // ;Internal 4.0
#define BS_BOTTOM           0x00000800L     // ;Internal 4.0
#define BS_VCENTER          0x00000C00L     // ;Internal 4.0
#define BS_VERTMASK         0x00000C00L     // ;Internal 4.0
#define BS_ALIGNMASK        0x00000F00L     // ;Internal 4.0
                                            // ;Internal 4.0
#define BS_PUSHLIKE         0x00001000L     // ;Internal 4.0
#define BS_MULTILINE        0x00002000L     // ;Internal 4.0
#define BS_NOTIFY           0x00004000L     // ;Internal 4.0
#define BS_FLAT             0x00008000L     // ;Internal 4.0

#define BS_LEFTTEXT         BS_RIGHTBUTTON

#ifndef NOWINMESSAGES
/* Button Control Messages  */
#define BM_FIRST_16         WM_USER         // ;Internal
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)
#define BM_CLICK            (WM_USER+5)
#define BM_GETIMAGE         (WM_USER+6)     // ;Internal 4.0
#define BM_SETIMAGE         (WM_USER+7)     // ;Internal 4.0
#define BM_MSGMAX           (WM_USER+8)     // ;Internal 4.0

#define BST_UNCHECKED       0x0000
#define BST_CHECKED         0x0001
#define BST_INDETERMINATE   0x0002
#define BST_CHECKMASK       0x0003  // ;Internal
#define BST_PUSHED          0x0004
#define BST_FOCUS           0x0008
#define BST_INCLICK         0x0010  // ;Internal -- inside click code
#define BST_CAPTURED        0x0020  // ;Internal -- we have mouse capture
#define BST_MOUSE           0x0040  // ;Internal -- mouse initiated
#define BST_DONTCLICK       0x0080  // ;Internal -- Don't check on get focus.
#define BST_INBMCLICK       0x0100  // ;Internal -- processing BM_CLICK message

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_PUSHED           2
#define BN_HILITE           BN_PUSHED
#define BN_UNPUSHED         3
#define BN_UNHILITE         BN_UNPUSHED
#define BN_DISABLE          4
#define BN_DBLCLK           5
#define BN_DOUBLECLICKED    BN_DBLCLK
#define BN_SETFOCUS         6               /* ;Internal 4.0 */
#define BN_KILLFOCUS        7               /* ;Internal 4.0 */
#endif /* NOWINMESSAGES */

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT                 0x0000L
#define ES_CENTER               0x0001L
#define ES_RIGHT                0x0002L
#define ES_MULTILINE            0x0004L
#define ES_UPPERCASE            0x0008L
#define ES_LOWERCASE            0x0010L
#define ES_PASSWORD             0x0020L
#define ES_AUTOVSCROLL          0x0040L
#define ES_AUTOHSCROLL          0x0080L
#define ES_NOHIDESEL            0x0100L
#define ES_COMBOBOX             0x0200L         /* ;Internal */
#define ES_OEMCONVERT           0x0400L
#if (WINVER >= 0x030a)
#define ES_READONLY             0x0800L
#define ES_WANTRETURN           0x1000L
#endif  /* WINVER >= 0x030a */
#if (WINVER >= 0x0400)
#define ES_NUMBER               0x2000L
#endif  /* WINVER >= 0x0400 */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_FIRST_16             WM_USER         // ;Internal
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_SCROLL               (WM_USER+5)     // ;Internal
#define EM_LINESCROLL           (WM_USER+6)
#define EM_SCROLLCARET          (WM_USER+7)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_GETTHUMB             (WM_USER+14)    // ;Internal
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_SETLIMITTEXT         (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)

#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
                                                /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define EM_SETMARGINS           (WM_USER+35)    /* ;Internal 4.0 */
#define EM_GETMARGINS           (WM_USER+36)    /* ;Internal 4.0 */
#define EM_GETLIMITTEXT         (WM_USER+37)    /* ;Internal 4.0 */
#define EM_POSFROMCHAR          (WM_USER+38)    /* ;Internal 4.0 */
#define EM_CHARFROMPOS          (WM_USER+39)    /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */                   /* ;Internal 4.0 */

#if (WINVER >= 0x040A)                          /* ;Internal 4.1 */
#define EM_SETIMESTATUS         (WM_USER+40)    /* ;Internal 4.1 */
#define EM_GETIMESTATUS         (WM_USER+41)    /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */                   /* ;Internal 4.1 */

#define EM_LIMITTEXT            EM_SETLIMITTEXT
#define EM_MSGMAX               (WM_USER+42)    // ;Internal 4.0

#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define EM_RESERVED1		    (WM_USER+0x40)  // ;Internal
#define EM_RESERVED2			(WM_USER+0x41)  // ;Internal
#define EM_RESERVED3			(WM_USER+0x42)  // ;Internal
#define EM_RESERVED4			(WM_USER+0x43)  // ;Internal
#define EM_RESERVED5			(WM_USER+0x44)  // ;Internal
#endif /* WINVER >= 0x0400 */                   /* ;Internal 4.0 */

#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT                 0
#define WB_RIGHT                1
#define WB_ISDELIMITER          2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS             0x0100
#define EN_KILLFOCUS            0x0200
#define EN_CHANGE               0x0300
#define EN_UPDATE               0x0400
#define EN_ERRSPACE             0x0500
#define EN_MAXTEXT              0x0501
#define EN_HSCROLL              0x0601
#define EN_VSCROLL              0x0602

#if (WINVER >= 0x0400)
#define  EN_ALIGN_LTR      (0x700)
#define  EN_ALIGN_RTL      (0x701)
#endif
                                        /* ;Internal 4.0 */
#if (WINVER >= 0x0400)                  /* ;Internal 4.0 */
#define  EC_LEFTMARGIN          0x0001  /* ;Internal 4.0 */
#define  EC_RIGHTMARGIN         0x0002  /* ;Internal 4.0 */
#define  EC_USEFONTINFO         0xffff  /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */           /* ;Internal 4.0 */

#if (WINVER >= 0x040A)                          /* ;Internal 4.1 */
/* wParam of EM_GET/SETIMESTATUS  */            /* ;Internal 4.1 */
#define EMSIS_COMPOSITIONSTRING        0x0001   /* ;Internal 4.1 */
#define EMSIS_GETLBBIT                 0x8001   /* ;Internal 4.1 */
                                                /* ;Internal 4.1 */
/* lParam for EMSIS_COMPOSITIONSTRING  */       /* ;Internal 4.1 */
#define EIMES_GETCOMPSTRATONCE         0x0001   /* ;Internal 4.1 */
#define EIMES_CANCELCOMPSTRINFOCUS     0x0002   /* ;Internal 4.1 */
#define EIMES_COMPLETECOMPSTRKILLFOCUS 0x0004   /* ;Internal 4.1 */
#endif /* WINVER >= 0x040A */                   /* ;Internal 4.1 */

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                0x0000L /* Type of scrollbar */
#define SBS_VERT                0x0001L /* Type of scrollbar */
#define SBS_TOPALIGN            0x0002L
#define SBS_LEFTALIGN           0x0002L
#define SBS_BOTTOMALIGN         0x0004L
#define SBS_RIGHTALIGN          0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX             0x0008L /* Type of scrollbar */
#define SBS_SIZEGRIP            0x0010L /* Type of scrollbar */

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY              0x0001L
#define LBS_SORT                0x0002L
#define LBS_NOREDRAW            0x0004L
#define LBS_MULTIPLESEL         0x0008L
#define LBS_OWNERDRAWFIXED      0x0010L
#define LBS_OWNERDRAWVARIABLE   0x0020L
#define LBS_HASSTRINGS          0x0040L
#define LBS_USETABSTOPS         0x0080L
#define LBS_NOINTEGRALHEIGHT    0x0100L
#define LBS_MULTICOLUMN         0x0200L
#define LBS_WANTKEYBOARDINPUT   0x0400L
#define LBS_EXTENDEDSEL         0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL     0x1000L
#define LBS_NODATA              0x2000L
#if (WINVER >= 0x0400)
#define LBS_NOSEL               0x4000L
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#define LBS_COMBOBOX            0x8000L         // ;Internal
#define LBS_STANDARD            (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_FIRST_16             (WM_USER+1)     // ;Internal
#define LB_ADDSTRING            (WM_USER+1)
#define LB_INSERTSTRING         (WM_USER+2)
#define LB_DELETESTRING         (WM_USER+3)
#define LB_SELITEMRANGEEX       (WM_USER+4)     // ;Internal 4.0 NT
#define LB_RESETCONTENT         (WM_USER+5)
#define LB_SETSEL               (WM_USER+6)
#define LB_SETCURSEL            (WM_USER+7)
#define LB_GETSEL               (WM_USER+8)
#define LB_GETCURSEL            (WM_USER+9)
#define LB_GETTEXT              (WM_USER+10)
#define LB_GETTEXTLEN           (WM_USER+11)
#define LB_GETCOUNT             (WM_USER+12)
#define LB_SELECTSTRING         (WM_USER+13)
#define LB_DIR                  (WM_USER+14)
#define LB_GETTOPINDEX          (WM_USER+15)
#define LB_FINDSTRING           (WM_USER+16)
#define LB_GETSELCOUNT          (WM_USER+17)
#define LB_GETSELITEMS          (WM_USER+18)
#define LB_SETTABSTOPS          (WM_USER+19)
#define LB_GETHORIZONTALEXTENT  (WM_USER+20)
#define LB_SETHORIZONTALEXTENT  (WM_USER+21)
#define LB_SETCOLUMNWIDTH       (WM_USER+22)
#define LB_ADDFILE              (WM_USER+23)    // ;Internal
#define LB_SETTOPINDEX          (WM_USER+24)
#define LB_GETITEMRECT          (WM_USER+25)
#define LB_GETITEMDATA          (WM_USER+26)
#define LB_SETITEMDATA          (WM_USER+27)
#define LB_SELITEMRANGE         (WM_USER+28)
#define LB_SETANCHORINDEX       (WM_USER+29)
#define LB_GETANCHORINDEX       (WM_USER+30)
#define LB_SETCARETINDEX        (WM_USER+31)
#define LB_GETCARETINDEX        (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT        (WM_USER+33)
#define LB_GETITEMHEIGHT        (WM_USER+34)
#define LB_FINDSTRINGEXACT      (WM_USER+35)
#define LBCB_CARETON            (WM_USER+36)    // ;Internal
#define LBCB_CARETOFF           (WM_USER+37)    // ;Internal
                                                // ;Internal NT
#define LB_SETLOCALE            (WM_USER+38)    // ;Internal NT
#define LB_GETLOCALE            (WM_USER+39)    // ;Internal NT
#define LB_SETCOUNT             (WM_USER+40)    // ;Internal NT
                                                // ;Internal
#if (WINVER >= 0x0400)                          // ;Internal 4.0
#define LB_FIRST_40             (WM_USER+41)    // ;Internal 4.0
#define LB_INITSTORAGE          (WM_USER+41)    // ;Internal 4.0
#define LB_ITEMFROMPOINT        (WM_USER+42)    // ;Internal 4.0
#define LB_INSERTSTRINGUPPER    (WM_USER+43)    // ;Internal 4.0
#define LB_INSERTSTRINGLOWER    (WM_USER+44)    // ;Internal 4.0
#define LB_ADDSTRINGUPPER       (WM_USER+45)    // ;Internal 4.0
#define LB_ADDSTRINGLOWER       (WM_USER+46)    // ;Internal 4.0
#endif  /* WINVER >= 0x0400 */                  // ;Internal 4.0
#endif  /* WINVER >= 0x030a */
                                                // ;Internal
#define LB_MSGMAX               (WM_USER+47)    // ;Internal

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE            (-2)
#define LBN_SELCHANGE           1
#define LBN_DBLCLK              2
#define LBN_SELCANCEL           3
#define LBN_SETFOCUS            4
#define LBN_KILLFOCUS           5

/* Listbox message return values */
#define LB_OKAY                 0
#define LB_ERR                  (-1)
#define LB_ERRSPACE             (-2)

#define LB_CTLCODE              0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE           0x0000
#define DDL_READONLY            0x0001
#define DDL_HIDDEN              0x0002
#define DDL_SYSTEM              0x0004
#define DDL_DIRECTORY           0x0010
#define DDL_ARCHIVE             0x0020

#define DDL_NOFILES             0x1000  /* ;Internal */
#define DDL_POSTMSGS            0x2000
#define DDL_DRIVES              0x4000
#define DDL_EXCLUSIVE           0x8000
#define DDL_VALID               0xf03f  /* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE              0x0001L
#define CBS_DROPDOWN            0x0002L
#define CBS_DROPDOWNLIST        0x0003L
#define CBS_OWNERDRAWFIXED      0x0010L
#define CBS_OWNERDRAWVARIABLE   0x0020L
#define CBS_AUTOHSCROLL         0x0040L
#define CBS_OEMCONVERT          0x0080L
#define CBS_SORT                0x0100L
#define CBS_HASSTRINGS          0x0200L
#define CBS_NOINTEGRALHEIGHT    0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL     0x0800L
#if (WINVER >= 0x0400)                      /* ;Internal 4.0 */
#define CBS_UPPERCASE           0x2000L     /* ;Internal 4.0 */
#define CBS_LOWERCASE           0x4000L     /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */              /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_FIRST_16             (WM_USER+0) // ;Internal
#define CB_GETEDITSEL           (WM_USER+0)
#define CB_LIMITTEXT            (WM_USER+1)
#define CB_SETEDITSEL           (WM_USER+2)
#define CB_ADDSTRING            (WM_USER+3)
#define CB_DELETESTRING         (WM_USER+4)
#define CB_DIR                  (WM_USER+5)
#define CB_GETCOUNT             (WM_USER+6)
#define CB_GETCURSEL            (WM_USER+7)
#define CB_GETLBTEXT            (WM_USER+8)
#define CB_GETLBTEXTLEN         (WM_USER+9)
#define CB_INSERTSTRING         (WM_USER+10)
#define CB_RESETCONTENT         (WM_USER+11)
#define CB_FINDSTRING           (WM_USER+12)
#define CB_SELECTSTRING         (WM_USER+13)
#define CB_SETCURSEL            (WM_USER+14)
#define CB_SHOWDROPDOWN         (WM_USER+15)
#define CB_GETITEMDATA          (WM_USER+16)
#define CB_SETITEMDATA          (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT        (WM_USER+19)
#define CB_GETITEMHEIGHT        (WM_USER+20)
#define CB_SETEXTENDEDUI        (WM_USER+21)
#define CB_GETEXTENDEDUI        (WM_USER+22)
#define CB_GETDROPPEDSTATE      (WM_USER+23)
#define CB_FINDSTRINGEXACT      (WM_USER+24)
                                                /* ;Internal NT */
#define CB_SETLOCALE            (WM_USER+25)    /* ;Internal NT */
#define CB_GETLOCALE            (WM_USER+26)    /* ;Internal NT */
#if (WINVER >= 0x0400)                          /* ;Internal 4.0 */
#define CB_FIRST_40             (WM_USER+27)    // ;Internal 4.0
#define CB_GETTOPINDEX          (WM_USER+27)    /* ;Internal 4.0 */
#define CB_SETTOPINDEX          (WM_USER+28)    /* ;Internal 4.0 */
#define CB_GETHORIZONTALEXTENT  (WM_USER+29)    /* ;Internal 4.0 */
#define CB_SETHORIZONTALEXTENT  (WM_USER+30)    /* ;Internal 4.0 */
#define CB_GETDROPPEDWIDTH      (WM_USER+31)    /* ;Internal 4.0 */
#define CB_SETDROPPEDWIDTH      (WM_USER+32)    /* ;Internal 4.0 */
#define CB_INITSTORAGE          (WM_USER+33)    /* ;Internal 4.0 */
#endif  /* WINVER >= 0x0400 */                  /* ;Internal 4.0 */
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX               (WM_USER+34)    // ;Internal 4.0

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE            (-1)
#define CBN_SELCHANGE           1
#define CBN_DBLCLK              2
#define CBN_SETFOCUS            3
#define CBN_KILLFOCUS           4
#define CBN_EDITCHANGE          5
#define CBN_EDITUPDATE          6
#define CBN_DROPDOWN            7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP             8
#define CBN_SELENDOK            9
#define CBN_SELENDCANCEL        10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY                 0
#define CB_ERR                  (-1)
#define CB_ERRSPACE             (-2)

#endif /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */
                                                                // ;Internal
#define WH_MIN                  (-1)                            // ;Internal
#define WH_MAX                  12                              // ;Internal
#define WH_MINHOOK              WH_MIN                          // ;Internal
#define WH_MAXHOOK              WH_MAX                          // ;Internal
#define WH_CHOOKS               (WH_MAXHOOK - WH_MINHOOK+1)     // ;Internal

/* Standard hook code */
#define HC_ACTION               0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN            (-3)
#define HC_LPLPFNNEXT           (-2)
#define HC_LPFNNEXT             (-1)

#endif /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE        0
#define HCBT_MINMAX          1
#define HCBT_QS              2
#define HCBT_CREATEWND       3
#define HCBT_DESTROYWND      4
#define HCBT_ACTIVATE        5
#define HCBT_CLICKSKIPPED    6
#define HCBT_KEYSKIPPED      7
#define HCBT_SYSCOMMAND      8
#define HCBT_SETFOCUS        9
#define HCBT_SETWINDOWTEXT  10

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    LPCREATESTRUCT lpcs;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hwndInsertAfter;    /* ;Internal */
#else                           /* ;Internal */
    HWND    hwndInsertAfter;
#endif                          /* ;Internal */
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
#ifdef tagWND                   /* ;Internal */
    HWND_16 hWndActive;         /* ;Internal */
#else                           /* ;Internal */
    HWND    hWndActive;
#endif                          /* ;Internal */
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
#ifdef tagWND           /* ;Internal */
    HWND_16 hWnd;       /* ;Internal */
#else                   /* ;Internal */
    HWND    hWnd;
#endif                  /* ;Internal */
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3
#if (WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED     4
#define HSHELL_GETMINRECT          5
#define HSHELL_REDRAW              6
#define HSHELL_TASKMAN             7
#define HSHELL_LANGUAGE            8 
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT        0x0001
#define HELP_QUIT           0x0002
#define HELP_INDEX          0x0003
#define HELP_CONTENTS       0x0003
#define HELP_HELPONHELP     0x0004
#define HELP_SETINDEX       0x0005
#define HELP_SETCONTENTS    0x0005
#define HELP_CONTEXTPOPUP   0x0008
#define HELP_FORCEFILE      0x0009
#define HELP_KEY            0x0101
#define HELP_COMMAND        0x0102
#define HELP_PARTIALKEY     0x0105
#define HELP_MULTIKEY       0x0201
#define HELP_SETWINPOS      0x0203

#if (WINVER >= 0x0400)

#define HELP_CONTEXTMENU    0x000a
#define HELP_FINDER         0x000b
#define HELP_WM_HELP        0x000c
#define HELP_SETPOPUP_POS   0x000d

#define HELP_TCARD          0x8000
#define HELP_TCARD_DATA     0x0010
#define HELP_TCARD_NEXT     0x0011
#define HELP_TCARD_OTHER_CALLER 0x0011

#endif  /* WINVER >= 0x0400 */

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

#if (WINVER >= 0x0400)
#define HELPINFO_WINDOW    0x0001
#define HELPINFO_MENUITEM  0x0002
typedef  struct  tagHELPINFO
{
    DWORD   cbSize;
    int     iContextType;
    int     iCtrlId;
    HANDLE  hItemHandle;
    DWORD   dwContextId;
    POINT   MousePos;
}
HELPINFO, FAR* LPHELPINFO;
                                                    /* ;Internal 4.0 */
BOOL  WINAPI  SetWindowContextHelpId(HWND, DWORD);  /* ;Internal 4.0 */
DWORD WINAPI  GetWindowContextHelpId(HWND);         /* ;Internal 4.0 */
BOOL  WINAPI  SetMenuContextHelpId(HMENU, DWORD);   /* ;Internal 4.0 */
DWORD WINAPI  GetMenuContextHelpId(HMENU);          /* ;Internal 4.0 */
#endif /* WINVER >= 0x0400 */


/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
#ifdef tagWND   // ;Internal
BOOL    WINAPI MessageBeep(UINT);   // ;Internal
#else           // ;Internal
void    WINAPI MessageBeep(UINT);
#endif          // ;Internal

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONERROR        0x0010      /* ;win40: Name changed from MB_ICONHAND */
#define MB_ICONQUESTION     0x0020
#define MB_ICONWARNING      0x0030      /* ;win40: Name changed from MB_ICONEXCLAMATION */
#define MB_ICONINFORMATION  0x0040      /* ;win40: Name changed from MB_ICONASTERISK */
#if (WINVER >= 0x400)                   /* ;Internal 4.0 */
#define MB_USERICON         0x0080      /* ;Internal 4.0 */
#endif                                  /* ;Internal 4.0 */
#define MB_ICONMASK         0x00F0

#define MB_ICONHAND         MB_ICONERROR
#define MB_ICONSTOP         MB_ICONERROR
#define MB_ICONEXCLAMATION  MB_ICONWARNING
#define MB_ICONASTERISK     MB_ICONINFORMATION

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#if (WINVER >= 0x0400)
#define MB_DEFBUTTON4       0x0300
#endif
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000
                                                                // ;Internal 4.0
#if (WINVER >= 0x0400)                                          // ;Internal 4.0
#define MB_HELP             0x4000                              // ;Internal 4.0
#define MB_RIGHT			0x00080000
#define MB_RTLREADING		0x00100000
#endif                                                          // ;Internal 4.0
#define MB_NOFOCUS          0x8000
                                                                // ;Internal 4.0
#define MB_TYPEMASK         0x000F                              // ;Internal 4.0
#define MB_ICONMASK         0x00F0                              // ;Internal 4.0
#define MB_DEFMASK          0x0F00                              // ;Internal 4.0
#define MB_MODEMASK         0x3000                              // ;Internal 4.0
#define MB_MISCMASK         0xC000                              // ;Internal 4.0
#define MB_VALID            0xb377                              // ;Internal 4.0
                                                                // ;Internal 4.0
#define MB_SETFOREGROUND    0x00010000                          // ;Internal NT
// #define MB_DEFAULT_DESKTOP_ONLY  0x00020000                  // ;Internal NT
#if (WINVER >= 0x0400)                                          // ;Internal NT
int WINAPI MessageBoxEx(HWND, LPCSTR, LPCSTR, DWORD, WORD);     // ;Internal NT
#endif // WINVER >= 0x0400                                      // ;Internal NT
                                                                // ;Internal 4.0
#if (WINVER >= 0x400)                                           // ;Internal 4.0
#define MB_TOPMOST          0x00040000                          // ;Internal 4.0
#define MBEX_VALIDL         0xf3f7                              // ;Internal 4.0
#define MBEX_VALIDH         1                                   // ;Internal 4.0
                                                                // ;Internal 4.0
typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo); // ;Internal 4.0
                                                                // ;Internal 4.0
typedef struct tagMSGBOXPARAMS                                  // ;Internal 4.0
{                                                               // ;Internal 4.0
    DWORD           cbSize;                                     // ;Internal 4.0
#ifdef tagWND                                                   // ;Internal 4.0
    HWND_16         hwndOwner;                                  // ;Internal 4.0
#else                                                           // ;Internal 4.0
    HWND            hwndOwner;                                  // ;Internal 4.0
#endif                                                          // ;Internal 4.0
    HINSTANCE       hInstance;                                  // ;Internal 4.0
    LPCSTR          lpszText;                                   // ;Internal 4.0
    LPCSTR          lpszCaption;                                // ;Internal 4.0
    DWORD           dwStyle;                                    // ;Internal 4.0
    LPCSTR          lpszIcon;                                   // ;Internal 4.0
    DWORD           dwContextHelpId;                            // ;Internal 4.0
    MSGBOXCALLBACK  lpfnMsgBoxCallback;                         // ;Internal 4.0
    DWORD	    dwLanguageId;				// ;Internal 4.0
}   MSGBOXPARAMS, FAR *LPMSGBOXPARAMS;                          // ;Internal 4.0
                                                                // ;Internal 4.0
int     WINAPI MessageBoxIndirect(LPMSGBOXPARAMS);              // ;Internal 4.0
#endif /* WINVER >=0x0400 */                                    // ;Internal 4.0
#endif  /* NOMB */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
LPINT   WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512     0
#define S_PERIOD1024    1
#define S_PERIOD2048    2
#define S_PERIODVOICE   3
#define S_WHITE512      4
#define S_WHITE1024     5
#define S_WHITE2048     6
#define S_WHITEVOICE    7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY    0
#define S_THRESHOLD     1
#define S_ALLTHRESHOLD  2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL        0
#define S_LEGATO        1
#define S_STACCATO      2

/* Error return values */
#define S_SERDVNA       (-1)
#define S_SEROFM        (-2)
#define S_SERMACT       (-3)
#define S_SERQFUL       (-4)
#define S_SERBDNT       (-5)
#define S_SERDLN        (-6)
#define S_SERDCC        (-7)
#define S_SERDTP        (-8)
#define S_SERDVL        (-9)
#define S_SERDMD        (-10)
#define S_SERDSH        (-11)
#define S_SERDPT        (-12)
#define S_SERDFQ        (-13)
#define S_SERDDR        (-14)
#define S_SERDSR        (-15)
#define S_SERDST        (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0
#define INFINITE        0xFFFF

/* Error Flags */
#define CE_RXOVER       0x0001
#define CE_OVERRUN      0x0002
#define CE_RXPARITY     0x0004
#define CE_FRAME        0x0008
#define CE_BREAK        0x0010
#define CE_CTSTO        0x0020
#define CE_DSRTO        0x0040
#define CE_RLSDTO       0x0080
#define CE_TXFULL       0x0100
#define CE_PTO          0x0200
#define CE_IOE          0x0400
#define CE_DNS          0x0800
#define CE_OOP          0x1000
#define CE_MODE         0x8000

#define IE_BADID        (-1)
#define IE_OPEN         (-2)
#define IE_NOPEN        (-3)
#define IE_MEMORY       (-4)
#define IE_DEFAULT      (-5)
#define IE_HARDWARE     (-10)
#define IE_BYTESIZE     (-11)
#define IE_BAUDRATE     (-12)

/* Events */
#define EV_RXCHAR       0x0001
#define EV_RXFLAG       0x0002
#define EV_TXEMPTY      0x0004
#define EV_CTS          0x0008
#define EV_DSR          0x0010
#define EV_RLSD         0x0020
#define EV_BREAK        0x0040
#define EV_ERR          0x0080
#define EV_RING         0x0100
#define EV_PERR         0x0200
#define EV_CTSS         0x0400
#define EV_DSRS         0x0800
#define EV_RLSDS        0x1000
#define EV_RingTe       0x2000
#define EV_RINGTE       EV_RingTe
#define EV_VALID        0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF         1
#define SETXON          2
#define SETRTS          3
#define CLRRTS          4
#define SETDTR          5
#define CLRDTR          6
#define RESETDEV        7

#define LPTx            0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT       8
#define GETMAXCOM       9
#define GETBASEIRQ      10

/* Comm Baud Rate indices */
#define CBR_110         0xFF10
#define CBR_300         0xFF11
#define CBR_600         0xFF12
#define CBR_1200        0xFF13
#define CBR_2400        0xFF14
#define CBR_4800        0xFF15
#define CBR_9600        0xFF16
#define CBR_14400       0xFF17
#define CBR_19200       0xFF18
#define CBR_38400       0xFF1B
#define CBR_56000       0xFF1F
#define CBR_128000      0xFF23
#define CBR_256000      0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE      0x0001
#define CN_TRANSMIT     0x0002
#define CN_EVENT        0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD            0x0001
#define DRV_ENABLE          0x0002
#define DRV_OPEN            0x0003
#define DRV_CLOSE           0x0004
#define DRV_DISABLE         0x0005
#define DRV_FREE            0x0006
#define DRV_CONFIGURE       0x0007
#define DRV_QUERYCONFIGURE  0x0008
#define DRV_INSTALL         0x0009
#define DRV_REMOVE          0x000A
#define DRV_EXITSESSION     0x000B
#define DRV_EXITAPPLICATION 0x000C
#define DRV_POWER           0x000F
#define DRV_NOTIFYMSG	      0x0010
/*#define DRV_QUERYENDSESSION 0x0010      */
/*#define DRV_EXITSESSIONCANCELLED 0x0011 */

#define DRV_RESERVED        0x0800
#define DRV_USER            0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL       0x0000
#define DRVCNF_OK           0x0001
#define DRVCNF_RESTART      0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002
#define GND_VALID               0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */

/****** Installable Message Thunk support ***********************************/

#if (WINVER > 0x030a)
#ifndef NOIMT

/* wReason codes */
#define IMT_REASON_ASYNC    0x00001
#define IMT_REASON_LS       0x00002
#define IMT_REASON_AFTER    0x00004

typedef struct tagIMTMSG
{
    HWND    hwnd;
    UINT    message;
    DWORD   wParam;
    LPARAM  lParam;
} IMTMSG, FAR* LPIMTMSG;

typedef struct tagIMTBUFFER
{
    DWORD   dwT1;
    DWORD   dwT2;
} IMTBUFFER, FAR* LPIMTBUFFER;

typedef BOOL (CALLBACK *IMTDISP)(WORD wReason, LPDWORD lpRetVal,
                                 LPIMTMSG lpMsg, LPIMTBUFFER lpBuffer);
BOOL WINAPI InstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                       WORD msgLo, WORD msgHi);
BOOL WINAPI UnInstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                         WORD msgLo, WORD msgHi);

#endif  /* !NOIMT */
#endif  /* WINVER > 0x030a */

#endif  /* NOUSER */

#if (WINVER >= 0x040A)                          // ;Internal 4.1
#define        MWMO_WAITALL    0x0001          // ;Internal 4.1
#define        MWMO_ALERTABLE  0x0002          // ;Internal 4.1
#endif  /* WINVER >= 0x040A */                  // ;Internal 4.1

DWORD WINAPI RegisterServiceProcess(DWORD dwProcessId, DWORD dwServiceType);
#define RSP_UNREGISTER_SERVICE	0x00000000
#define RSP_SIMPLE_SERVICE	0x00000001

VOID WINAPI RegisterNetworkCapabilities(DWORD dwBitsToSet, DWORD dwValues);
#define RNC_NETWORKS  		0x00000001

                                                                                    // ;Internal
VOID API RegisterSystemThread(DWORD flags, DWORD reserved);                         // ;Internal
#define RST_DONTATTACHQUEUE         0x00000001                                      // ;Internal
#define RST_DONTJOURNALATTACH       0x00000002                                      // ;Internal
#define RST_ALWAYSFOREGROUNDABLE    0x00000004                                      // ;Internal
#define RST_FAULTTHREAD             0x00000008                                      // ;Internal
                                                                                    // ;Internal
DWORD API EndTask(HWND hwnd, DWORD idProcess, LPSTR lpszCaption, DWORD dwFlags);    // ;Internal
                                                                                    // ;Internal
#define ET_ALLOWFORWAIT     0x00000001                                              // ;Internal
#define ET_TRYTOKILLNICELY  0x00000002                                              // ;Internal
#define ET_NOUI             0x00000004                                              // ;Internal
#define ET_NOWAIT           0x00000008                                              // ;Internal
                                                                                    // ;Internal
#define ET_VALID            0x0000000F                                              // ;Internal

BOOL API IsValidLocale(DWORD Lcid, DWORD dwFlags);	/* ;Internal */
#define LCID_INSTALLED	    0x00000001			/* ;Internal */

                                        /* ;Internal */
#ifndef NOWINDOWSX                      /* ;Internal */
#ifndef RC_INVOKED                      /* ;Internal */
#include <windowsx.h>                   /* ;Internal */
#ifndef STRICT                          /* ;Internal */
#undef  SelectFont                      /* ;Internal */
#endif  /* STRICT */                    /* ;Internal */
#endif  /* RC_INVOKED */                /* ;Internal */
#endif  /* NOWINDOWSX */                /* ;Internal */
                                        /* ;Internal */
#ifdef tagWND                           /* ;Internal */
#ifdef DEBUG                            /* ;Internal */
#undef HWND                             /* ;Internal */
#undef HWNDC                            /* ;Internal */
#undef HMENU                            /* ;Internal */
typedef struct tagWND  BASED    *HWND;  /* ;Internal */
typedef HWND HWNDC;                     /* ;Internal */
typedef struct tagMENU FAR      *HMENU; /* ;Internal */
#endif                                  /* ;Internal */
#endif /* tagWND */                     /* ;Internal */


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memcpy(void *, const void *,
    size_t);
void * __cdecl memmove(void *, const void *,
    size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
    size_t);
int __cdecl strncmp(const char *, const char *,
    size_t);
int __cdecl _strnicmp(const char *, const char *,
    size_t);
char * __cdecl strncpy(char *, const char *,
    size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
    const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
    const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
    size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
    size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STRING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\bstring.h ===
/*
 * BSTRING.H
 *
 * Defines a BSTRING C++ class that allows us to wrap the OLE BSTR (Basic
 * String) type, primarily to simplify the creation and freeing of these
 * objects.  This is intended to be a lightweight wrapper with minimal
 * overhead.
 *
 * If no input string is specified to the constructor or if the allocation
 * of the BSTR fails, then the <m_bstr> member is set to NULL.
 *
 * Note: The BSTRING class is not intended to allow managing multiple BSTR 
 * strings with a single object.
 *
 * Usage scenarios:
 *
 * 1) Create a BSTR from an existing string, have it automatically freed
 *    when done.
 *
 *		// Allocate BSTR using SysAllocString()
 *		BSTRING bstrComputerName(lpstrComputerName);
 *
 *		...
 *
 *		// Automatic, lightweight cast to BSTR
 *		SomeFunctionThatTakesABSTR(bstrComputerName);
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrComputerName ends.
 *
 * 2) Create a null BSTRING object, pass it to a function that returns an
 *	  allocated BSTR, then have it automatically freed when done.
 *
 *		// Create null BSTRING
 *		BSTRING bstrReturnedComputerName;
 *
 *		...
 *
 *		// Call a function that returns an allocated BSTR.
 *		SomeFunctionThatReturnsABSTR(bstrReturnedComputerName.GetLPBSTR());
 *
 *		...
 *
 *		// SysFreeString() gets called automatically when the scope of
 *		// bstrReturnedComputerName ends.
 *		
 * Author:
 *		dannygl, 29 Oct 96
 */

#if !defined(_BSTRING_H_)
#define _BSTRING_H_

#include <oleauto.h>
#include <confdbg.h>

class BSTRING
{
private:
	BSTR m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}

	// Get a BSTR pointer.
	//
	// This member function is intended for passing this object to
	// functions that allocate a BSTR, return a pointer to this BSTR,
	// and expect the caller to free the BSTR when done.  The BSTR is
	// freed when the BSTRING destructor gets called.
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		// SysAllocString returns NULL on failure
		m_bstr = SysAllocString(lpcwString);

		ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	ASSERT(NULL == m_bstr);

	return &m_bstr;
}

#endif // !defined(_BSTRING_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
* Version 3.10								      *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved.	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPPAINTSTRUCT)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(LPRECT)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(LPMDICREATESTRUCT)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam)
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(LPMSG)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))
#define ListBox_AddFile(hwndCtl, lpszFilename)      ((int)(DWORD)SendMessage((hwndCtl), LB_ADDFILE, 0, (LPARAM)(LPCSTR)(lpszFilename)))    /* ;Internal */

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), (LPARAM)(int)cyItem))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

/****** Alternate porting layer macros ***************************************/

/* USER MESSAGES: */

#define GET_WPARAM(wp, lp)                      (wp)
#define GET_LPARAM(wp, lp)                      (lp)

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
#define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      ((BOOL)HIWORD(lp))
#define GET_WM_ACTIVATE_HWND(wp, lp)            ((HWND)LOWORD(lp))
#define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      \
        (WPARAM)(s), (LPARAM)MAKELONG(hwnd, fmin)

#define GET_WM_CHARTOITEM_CHAR(wp, lp)          ((CHAR)wp)
#define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
#define GET_WM_CHARTOITEM_HWND(wp, lp)          LOWORD(lp)
#define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    \
        (WPARAM)ch, (LPARAM)MAKELONG(hwnd, pos)

#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(LOWORD(lp))
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd)    \
        (WPARAM)id, MAKELONG(hwnd, cmd)

#define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
#define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)(LOWORD(lp))
#define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
#define GET_WM_CTLCOLOR_MSG(type)               WM_CTLCOLOR
#define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type) \
        (WPARAM)(hdc), (LPARAM)MAKELONG(hwnd, type)


#define GET_WM_MENUSELECT_CMD(wp, lp)               (wp)
#define GET_WM_MENUSELECT_FLAGS(wp, lp)             (UINT)LOWORD(lp)
#define GET_WM_MENUSELECT_HMENU(wp, lp)             (HMENU)(HIWORD(lp))
#define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)  \
        (WPARAM)cmd, (LPARAM)MAKELONG(f, hmenu)

// Note: the following are for interpreting MDI child messages.
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (wp)
#define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
#define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)
// Note: the following is for sending to the MDI client window.
#define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA)\
        (WPARAM)(hwndA), 0

#define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   \
    (WPARAM)FALSE, (LPARAM)MAKELONG(hmenuF, hmenuW)

#define GET_WM_MENUCHAR_CHAR(wp, lp)                (CHAR)(wp)
#define GET_WM_MENUCHAR_HMENU(wp, lp)               (HMENU)HIWORD(lp)
#define GET_WM_MENUCHAR_FMENU(wp, lp)               (BOOL)LOWORD(lp)
#define GET_WM_MENUCHAR_MPS(ch, hmenu, f)    \
        (WPARAM)ch, (LPARAM)MAKELONG(f, hmenu)

#define GET_WM_PARENTNOTIFY_MSG(wp, lp)             (wp)
#define GET_WM_PARENTNOTIFY_ID(wp, lp)              HIWORD(lp)
#define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)       (HWND)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_X(wp, lp)               (int)LOWORD(lp)
#define GET_WM_PARENTNOTIFY_Y(wp, lp)               (int)HIWORD(lp)
#define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd) \
        (WPARAM)msg, (LPARAM)MAKELONG(hwnd, id)
#define GET_WM_PARENTNOTIFY2_MPS(msg, x, y) \
        (WPARAM)msg, (LPARAM)MAKELONG(x, y)

#define GET_WM_VKEYTOITEM_CODE(wp, lp)              (wp)
#define GET_WM_VKEYTOITEM_ITEM(wp, lp)              HIWORD(lp)
#define GET_WM_VKEYTOITEM_HWND(wp, lp)              (HWND)LOWORD(lp)
#define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) \
        (WPARAM)code, (LPARAM)MAKELONG(hwnd, item)

#define GET_EM_SETSEL_START(wp, lp)                 (int)LOWORD(lp)
#define GET_EM_SETSEL_END(wp, lp)                   (int)HIWORD(lp)
#define GET_EM_SETSEL_MPS(iStart, iEnd) \
        (WPARAM)TRUE, MAKELONG(iStart, iEnd)

#define GET_EM_LINESCROLL_MPS(vert, horz)     \
        (WPARAM)0, (LPARAM)MAKELONG(vert, horz)

#define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)       (HWND)LOWORD(lp)

#define GET_WM_HSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_HSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_HSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_HSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)

#define GET_WM_VSCROLL_CODE(wp, lp)                 (wp)
#define GET_WM_VSCROLL_POS(wp, lp)                  LOWORD(lp)
#define GET_WM_VSCROLL_HWND(wp, lp)                 (HWND)HIWORD(lp)
#define GET_WM_VSCROLL_MPS(code, pos, hwnd)    \
        (WPARAM)code, (LPARAM)MAKELONG(pos, hwnd)


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\dev\inc16\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
* Copyright (c) 1992-1994, Microsoft Corp.	All rights reserved	      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

#ifdef LIB

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

#endif /* LIB */

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\common.h ===
/*
 -  common.h
 -
 *      Microsoft Internet Phone
 *              Definitions that are common across the product
 *
 *              Revision History:
 *
 *              When            Who                                     What
 *              --------        ------------------  ---------------------------------------
 *              11.20.95        Yoram Yaacovi           Created
 */

#ifndef _COMMON_H
#define _COMMON_H
#include <windows.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

//
//  H.221 identification codes used by call control and nonstandard capability exchange
//
#define USA_H221_COUNTRY_CODE 0xB5
#define USA_H221_COUNTRY_EXTENSION 0x00
#define MICROSOFT_H_221_MFG_CODE 0x534C  //("first" byte 0x53, "second" byte 0x4C)


//Common Bandwidth declarations
// !!! The QoS will decrease these numbers by the LeaveUnused value.
// This value is currently hardcoded to be 30% 
#define BW_144KBS_BITS				14400	// QoS 30% markdown leads to a max bw usage of  10080 bits/second
#define BW_288KBS_BITS				28800	// QoS 30% markdown leads to a max bw usage of  20160 bits/second
#define BW_ISDN_BITS 				85000	// QoS 30% markdown leads to a max bw usage of  59500 bits/second

// LAN BANDWIDTH for slow pentiums
#define BW_SLOWLAN_BITS				621700	// QoS 30% markdown leads to a max bw usage of 435190 bits/second

// Pentiums faster than 400mhz can have this LAN setting
#define BW_FASTLAN_BITS				825000	// QoS 30% markdown leads to a max bw usage of 577500 bits/second



// For use as dimension for variable size arrays
#define VARIABLE_DIM				1


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End byte packing */

#endif  //#ifndef _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\confdbg.h ===
// confdbg.h -  Conferencing Debug Functions and Macros

/*
	The main macros are:

	ASSERT - display error if parameter evalulates to FALSE.
		e.g. ASSERT(x == y);

	ERROR_OUT - always print this error.  Messagebox is optional.
		e.g. ERROR_OUT(("Unable to FooBar!  Err=%d", dwErr));

	WARNING_OUT - warning message, not an error (App must call InitDebugModule)
		e.g. WARNING_OUT(("FooBar is not available. Using %s", szAlt));

	TRACE_OUT - debug message (App must call InitDebugModule)
		e.g. TRACE_OUT(("dwFoo=%d, dwBar=%d", dwFoo, dwBar));

	DBGMSG - debug message for a specific zone
		e.g. DBGMSG(ghZoneFoo, ZONE_BAR, ("Setting dwFoo=%d", dwFoo));


Important Functions:
	VOID DbgInit(HDBGZONE * phDbgZone, PTCHAR * psz, UINT cZone);
	VOID DbgDeInit(HDBGZONE * phDbgZone);
	VOID WINAPI DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
	PSTR WINAPI DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);

	Note: The strings in these functions, in particular the module and
	zone names, are always ANSI strings, even in Unicode components.  The
	input strings to DBGINIT should not be wrapped in TEXT macros.
*/

#ifndef _CONFDBG_H_
#define _CONFDBG_H_

#include <stock.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <pshpack8.h> /* Assume 8 byte packing throughout */

// deal with including "debug.h" before and after
#ifdef DEBUGMSG
#undef DEBUGMSG
#endif
#define _DEBUG_H

// MFC also defines this - use our version
#ifdef ASSERT
#undef ASSERT
#endif

#ifdef DEBUG
#ifndef NM_DEBUG
#define NM_DEBUG
#endif
#endif /* DEBUG */



// Special NetMeeting Debug definitions
#ifdef NM_DEBUG


//////////////////////////////////////
//Debug Zones

#define MAXNUM_OF_MODULES			64
#define MAXSIZE_OF_MODULENAME		32
#define MAXNUM_OF_ZONES				16
#define MAXSIZE_OF_ZONENAME			32

#define ZONEINFO_SIGN				0x12490000


// Zone information for a module
typedef struct _ZoneInfo
{
	ULONG	ulSignature;
	ULONG	ulRefCnt;
	ULONG	ulZoneMask; //the zone mask
	BOOL	bInUse;
	CHAR	pszModule[MAXSIZE_OF_MODULENAME];	//name against which the zones are registered
	CHAR	szZoneNames[MAXNUM_OF_ZONES][MAXSIZE_OF_ZONENAME]; //names of the zones
	CHAR	szFile[MAX_PATH];	                // output file, specific to this module
}ZONEINFO,*PZONEINFO;

// DBGZONEPARAM replaced by ZONEINFO
#define DBGZONEINFO ZONEINFO
#define PDBGZONEINFO PZONEINFO
	
typedef PVOID HDBGZONE;

// size of the memory mapped file
#define CBMMFDBG (sizeof(ZONEINFO) * MAXNUM_OF_MODULES + sizeof(NMDBG))

// General information at end of memory-mapped file (after all zone data)
typedef struct _NmDbg {
	BOOL  fOutputDebugString;  // OutputDebugString is enabled
	BOOL  fWinOutput;          // Window Output is enabled
	HWND  hwndCtrl;            // Window that handles output
	UINT  msgDisplay;          // Message to post to hwndCtrl
	BOOL  fFileOutput;         // File Output is enabled
	CHAR  szFile[MAX_PATH];    // File name for output
	UINT  uShowTime;           // Format date/time (see DBG_FMTTIME_*)
	BOOL  fShowThreadId;       // Dump ThreadId with each message
	BOOL  fShowModule;         // Dump Module:Zone with each message
} NMDBG;
typedef NMDBG * PNMDBG;

#define DBG_FMTTIME_NONE 0     // Do not format the time
#define DBG_FMTTIME_TICK 1     // Old format (tick count)
#define DBG_FMTTIME_FULL 2     // Full Year/Month/Day Hour:Min:Sec.ms
#define DBG_FMTTIME_DAY  3     // Hour:Minute:Second.ms

extern BOOL      WINAPI     NmDbgRegisterCtl(HWND hwnd, UINT uDisplayMsg);
extern BOOL      WINAPI     NmDbgDeregisterCtl(HWND hwnd);
extern BOOL      WINAPI     NmDbgSetLoggingOptions(HWND hwnd, UINT uOptions);
extern void      WINAPI     NmDbgFlushFileLog();
extern BOOL      WINAPI     NmDbgGetAllZoneParams(PDBGZONEINFO *plpZoneParam, UINT * puCnt);
extern BOOL      WINAPI     NmDbgFreeZoneParams(PDBGZONEINFO pZoneParam);

extern HDBGZONE  WINAPI     NmDbgCreateZone(LPSTR pszName);
extern VOID      WINAPI     NmDbgDeleteZone(LPSTR pszName, HDBGZONE hDbgZone);
extern BOOL      WINAPI     NmDbgSetZone(HDBGZONE hDbgZone,PDBGZONEINFO pZoneParam);
extern PNMDBG    WINAPI     GetPNmDbg(void);
extern VOID      WINAPI     NmDbgSetZoneFileName(HDBGZONE hDbgZone, LPCSTR pszFile);

extern PZONEINFO  FindZoneForModule(LPCSTR pszModule);
extern PZONEINFO  AllocZoneForModule(LPCSTR pszModule);
extern PZONEINFO  MapDebugZoneArea(void);
extern VOID       UnMapDebugZoneArea(void);

extern VOID       InitDbgZone(void);
extern VOID       DeInitDbgZone(void);
extern VOID       SetDbgFlags(void);



// Special reserved strings
#define SZ_DBG_MAPPED_ZONE TEXT("_NmDebugZoneMap")
#define SZ_DBG_FILE_MUTEX  TEXT("_NmDbgFileMutex")
#define SZ_DBG_ZONE_MUTEX  TEXT("_NmDbgZoneMutex")


#define GETZONEMASK(z)  ((z) ? (((PZONEINFO)(z))->ulZoneMask) : 0 )
#define IS_ZONE_ENABLED(z, f) ((((PZONEINFO)(z))->ulZoneMask) & (f))

// Macro to check if zone is enabled:  h = ghZone,  i = zone index
#define F_ZONE_ENABLED(h, i)  ((NULL != h) && IS_ZONE_ENABLED(h, (1 << i)))


// Standard Zones
#define ZONE_WARNING           0
#define ZONE_TRACE             1
#define ZONE_FUNCTION          2

#define ZONE_WARNING_FLAG   0x01
#define ZONE_TRACE_FLAG     0x02
#define ZONE_FUNCTION_FLAG  0x04


////////////////////////////////////////////
// Functions
VOID WINAPI     DbgPrintf(PCSTR pszPrefix, PCSTR pszFormat, va_list ap);
PSTR WINAPI     DbgZPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat,...);
PSTR WINAPI     DbgZVPrintf(HDBGZONE hZone, UINT iZone, PSTR pszFormat, va_list ap);

VOID  DbgInitEx(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZone, long ulZoneDefault);
VOID  DbgDeInit(HDBGZONE * phDbgZone);

INLINE VOID DbgInit(HDBGZONE * phDbgZone, PCHAR * psz, UINT cZones)
{
	DbgInitEx(phDbgZone, psz, cZones, 0);
}

PSTR PszPrintf(PCSTR pszFormat,...);

#endif /* NM_DEBUG */


////////////////////////////////////////////
// Main Macros
#ifdef DEBUG
#define DBGINIT(phZone, psz)  DbgInit(phZone, psz, (sizeof(psz)/sizeof(PCHAR))-1)
#define DBGDEINIT(phZone)     DbgDeInit(phZone)

#define ASSERT(exp)     (!(exp) ? ERROR_OUT(("ASSERT failed on %s line %u:\n\r"#exp, __FILE__, __LINE__)) : 0)


VOID WINAPI DbgZPrintError(PSTR pszFormat,...);
VOID WINAPI DbgZPrintWarning(PSTR pszFormat,...);
VOID WINAPI DbgZPrintTrace(PSTR pszFormat,...);
VOID WINAPI DbgZPrintFunction(PSTR pszFormat,...);

#define ERROR_OUT(s)   DbgZPrintError s
#define WARNING_OUT(s) DbgZPrintWarning s
#define TRACE_OUT(s)   DbgZPrintTrace s

#define DBGENTRY(s)        DbgZPrintFunction("Enter " #s);
#define DBGEXIT(s)         DbgZPrintFunction("Exit  " #s);
#define DBGEXIT_HR(s,hr)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetHRESULTString(hr));
#define DBGEXIT_BOOL(s,f)  DbgZPrintFunction("Exit  " #s "  (result=%s)", GetBOOLString(f));
#define DBGEXIT_INT(s,i)   DbgZPrintFunction("Exit  " #s "  (result=%s)", GetINTString(i));
#define DBGEXIT_ULONG(s,u) DbgZPrintFunction("Exit  " #s "  (result=%s)", GetULONGString((ULONG)u));


#define DBGMSG(z, i, s)                                             \
   {                                                                \
      if ((NULL != z) && (((PZONEINFO)(z))->ulZoneMask & (1<<i)) )  \
      {                                                             \
         LocalFree(DbgZPrintf(z, i, PszPrintf s));                  \
      }                                                             \
   }
// e.g. DBGMSG(ghZone, ZONE_FOO, ("bar=%d", dwBar))

#else
#define DBGINIT(phZone, psz)
#define DBGDEINIT(phZone)
#define ASSERT(exp)

#define ERROR_OUT(s)
#define WARNING_OUT(s)
#define TRACE_OUT(s)

#define DBGENTRY(s)
#define DBGEXIT(s)
#define DBGEXIT_HR(s,hr)
#define DBGEXIT_BOOL(s,f)
#define DBGEXIT_INT(s,i)
#define DBGEXIT_ULONG(s,u)

#ifndef DBGMSG
#define DBGMSG(z, f, s)
#endif

#endif /* DEBUG */


#include <poppack.h> /* End byte packing */

#ifdef __cplusplus
}
#endif

#endif /* _CONFDBG_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\confguid.h ===
//****************************************************************************
//
//  File:       confguid.h
//  Content:    This file contains the class GUID for Microsoft Conferencing.
//
//  Copyright (c) Microsoft Corporation 1995-1996
//
//****************************************************************************

#define H221USACode1    0xb5
#define H221USACode2    0x00
#define H221MFGCode1    0x53
#define H221MFGCode2    0x4c
#define H221GUIDID      0x01

#define H221GUIDKEY0    H221USACode1
#define H221GUIDKEY1    H221USACode2
#define H221GUIDKEY2    H221MFGCode1
#define H221GUIDKEY3    H221MFGCode2
#define H221GUIDKEY4    H221GUIDID

#define CB_H221_GUIDKEY    (5 + sizeof(GUID))


// Data conferencing flags:
#define CRPCF_JOIN			0x0001
#define CRPCF_NO_UI         0x0002
#define CRPCF_HOST          0x0004
#define CRPCF_SECURE        0x0008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\custring.h ===
#ifndef _CUSTRING_H_
#define _CUSTRING_H_

// Simple universal string class, where string can be converted 
// back and forth between Ansi and Unicode string and buffers
// allocated are destroyed in string class destructor.

class CUSTRING
{
public:
	CUSTRING(PCWSTR wszText = NULL);
	CUSTRING(PCSTR szText);
	~CUSTRING();
	operator PWSTR();
	operator PSTR();
	inline void GiveString(PCWSTR wszText);
	inline void GiveString(PCSTR szText);
	inline void AssignString(PCWSTR wszText);
	inline void AssignString(PCSTR szText);
protected:
	PWSTR	wszData;
	PSTR	szData;
	BOOL	bUnicodeNew;
	BOOL	bAnsiNew;
};


inline void CUSTRING::GiveString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
	bUnicodeNew = TRUE;
}

inline void CUSTRING::GiveString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
	bAnsiNew = TRUE;
}

inline void CUSTRING::AssignString(PCWSTR wszText)
{
	ASSERT(!wszData);
	wszData = (PWSTR)wszText;
}

inline void CUSTRING::AssignString(PCSTR szText)
{
	ASSERT(!szData);
	szData = (PSTR)szText;
}

#endif // ndef CUSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\databeam.h ===
/*
 * databeam.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 * Abstract:
 *      This file defines common extensions to the C++ language for
 *		use at DataBeam Corporation.
 *
 * Author:
 *		James P. Galvin, Jr.
 *		Brian L. Pulito
 *		Carolyn J. Holmes
 *		John B. O'Nan
 *
 *	Revision History
 *		08AUG94		blp		Added UniChar
 *		15JUL94		blp		Added lstrcmp
 */

#ifndef _DATABEAM_
#define _DATABEAM_

#	include <windows.h>

/*
 * The following two macros can be used to get the minimum or the maximum
 * of two numbers.
 */
#ifndef min
#	define	min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#	define	max(a,b)	(((a) > (b)) ? (a) : (b))
#endif


/*
 *	This typedef defines Boolean as an BOOL, rather than an enum.  The
 *	thinking is that this is more likely to be compatible with other
 *	uses of Boolean (if any), as well as with the use of "#define" to
 *	define TRUE and FALSE.
 */
#ifndef	DBBoolean
typedef	BOOL						DBBoolean;
typedef	BOOL *						PDBBoolean;
#endif

/*
 *	These defines set up values that would typically be used in conjunction
 *	with the type Boolean as defined above.
 */
#ifndef	OFF
#	define	OFF		0
#endif
#ifndef	ON
#	define	ON		1
#endif


/*
 * EOS can be used for the NUL byte at the end of a string.  Do not 
 * confuse this with the pointer constant "NULL".
 */
#define EOS     '\0'


/*
 *	The following is a list of the standard typedefs that will be used
 *	in all programs written at DataBeam.  Use of this list gives us full
 *	control over types for portability.  It also gives us a standard
 *	naming convention for all types.
 */
typedef	char						Char;
typedef	unsigned char				UChar;
typedef	char *						PChar;
typedef	const char *				PCChar;
typedef	unsigned char *				PUChar;
typedef	const unsigned char *		PCUChar;
typedef	char *						FPChar;
typedef	const char *				FPCChar;
typedef	unsigned char *				FPUChar;
typedef	const unsigned char *		FPCUChar;
typedef	char  *						HPChar;
typedef	const char *				HPCChar;
typedef	unsigned char *				HPUChar;
typedef	const unsigned char *		HPCUChar;

typedef	short						Short;
typedef	unsigned short				UShort;
typedef	short *						PShort;
typedef	const short *				PCShort;
typedef	unsigned short *			PUShort;
typedef	const unsigned short *		PCUShort;
typedef	short *						FPShort;
typedef	const short *				FPCShort;
typedef	unsigned short *			FPUShort;
typedef	const unsigned short *		FPCUShort;
typedef	short *						HPShort;
typedef	const short *				HPCShort;
typedef	unsigned short *			HPUShort;
typedef	const unsigned short *		HPCUShort;

typedef	int							Int;
typedef	unsigned int				UInt;
typedef	int *						PInt;
typedef	const int *					PCInt;
typedef	unsigned int *				PUInt;
typedef	const unsigned int *		PCUInt;
typedef	int *						FPInt;
typedef	const int *					FPCInt;
typedef	unsigned int *				FPUInt;
typedef	const unsigned int *		FPCUInt;
typedef	int *						HPInt;
typedef	const int *					HPCInt;
typedef	unsigned int *				HPUInt;
typedef	const unsigned int *		HPCUInt;

typedef	long						Long;
typedef	unsigned long				ULong;
typedef	long *						PLong;
typedef	const long *				PCLong;
typedef	unsigned long *				PULong;
typedef	const unsigned long *		PCULong;
typedef	long *						FPLong;
typedef	const long *				FPCLong;
typedef	unsigned long *				FPULong;
typedef	const unsigned long *		FPCULong;
typedef	long *						HPLong;
typedef	const long *				HPCLong;
typedef	unsigned long *				HPULong;
typedef	const unsigned long *		HPCULong;

#ifdef USE_FLOATING_POINT
typedef	float						Float;
typedef	float *						PFloat;
typedef	const float *				PCFloat;
typedef	float *						FPFloat;
typedef	const float *				FPCFloat;
typedef	float *						HPFloat;
typedef	const float *				HPCFloat;

typedef	double						Double;
typedef	double *					PDouble;
typedef	const double *				PCDouble;
typedef	double *					FPDouble;
typedef	const double *				FPCDouble;
typedef	double *					HPDouble;
typedef	const double *				HPCDouble;

typedef	long double					LDouble;
typedef	long double *				PLDouble;
typedef	const long double *			PCLDouble;
typedef	long double *				FPLDouble;
typedef	const long double *			FPCLDouble;
typedef	long double *				HPLDouble;
typedef	const long double *			HPCLDouble;
#endif

typedef	void						Void;
typedef	void *						PVoid;
typedef	const void *				PCVoid;
typedef	void *						FPVoid;
typedef	const void *				FPCVoid;
typedef	void *						HPVoid;
typedef	const void *				HPCVoid;

/*
 *	Temporary fix for compatibility with the Symantec compiler, which doesn't
 *	recognize wchar_t as a valid type.
 */
typedef	unsigned short				UniChar;
typedef	UniChar		*				PUniChar;
typedef	UniChar		*				FPUniChar;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\confreg.h ===
#ifndef _CONFREG_H_
#define _CONFREG_H_

// The Windows CurrentVersion key is used for obtaining the name that was
// was specified while installing Windows.  It is stored under HKEY_LOCAL_MACHINE:
#define WINDOWS_CUR_VER_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

#define REGVAL_REGISTERED_USER TEXT("RegisteredOwner")

#define MAX_DCL_NAME_LEN                48 /* REGVAL_ULS_NAME can't be larger than this */

////////////// Remote control service related keys and values ////////////////

#define WIN95_SERVICE_KEY				TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define WINNT_WINLOGON_KEY              TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WIN95_WINLOGON_KEY              TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define DESKTOP_KEY                     TEXT("Control Panel\\Desktop")

#define REMOTE_REG_PASSWORD				TEXT("FieldPos")

#define REGVAL_SCREENSAVER_GRACEPERIOD  TEXT("ScreenSaverGracePeriod")
#define REGVAL_WINNT_SCPW               TEXT("ScreenSaverIsSecure")
#define REGVAL_WIN95_SCPW               TEXT("ScreenSaveUsePassword")

/////////// NT service pack version registry keys and values (HKLM) /////////////
#define NT_WINDOWS_SYSTEM_INFO_KEY	    TEXT("System\\CurrentControlSet\\Control\\Windows")
#define REGVAL_NT_CSD_VERSION		    TEXT("CSDVersion")


/////////// System Information registry keys and values (HKLM) /////////////
#define WINDOWS_KEY            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define WINDOWS_NT_KEY         TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")

#endif  // ! _CONFREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\h\gcc.h ===
/*
 *	gcc.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the GCC DLL.  This file defines all
 *		macros, types, and functions needed to use the GCC DLL, allowing GCC
 *		services to be accessed from user applications. 
 *
 *		An application requests services from GCC by making direct
 *		calls into the DLL (this includes T.124 requests and responses).  GCC
 *		sends information back to the application through a callback (this
 *		includes T.124 indications and confirms).  The callback for the node
 *		controller is specified in the call GCCInitialize, and the callback
 *		for a particular application service access point is specified in the 
 *		call GCCRegisterSAP.
 *
 *		During initialization, GCC allocates a timer in order to give itself
 *		a heartbeat. If zero is passed in here the owner application (the node 
 *		controller) must take the responsibility to call GCCHeartbeat.  Almost 
 *		all work is done by GCC during these clocks ticks. It is during these 
 *		clock ticks that GCC checks with MCS to see if there is any work to be 
 *		done.  It is also during these clock ticks that callbacks are made to 
 *		the user applications.  GCC will NEVER invoke a user callback during a 
 *		user request (allowing the user applications to not worry about 
 *		re-entrancy).  Since timer events are processed during the message 
 *		loop, the developer should be aware that long periods of time away 
 *		from the message loop will result in GCC "freezing" up.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *			#include "gcc.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		blp
 *
 *	Caveats:
 *		none
 */
#ifndef	__GCC_H__
#define	__GCC_H__

#include "t120type.h"

/************************************************************************
*																		*
*					Generally Used Typedefs								*
*																		*
*************************************************************************/

#define NM_T120_VERSION_3		(MAKELONG(0, 3))	// NM 3.0

typedef struct tagOSTR
{
    ULONG       length;
    LPBYTE      value;
}
    OSTR, *LPOSTR;

/*
**	Typedef for a GCC hex string.  This typedef is used throughout GCC for
**	storing	variable length wide character strings with embedded NULLs.
*/
typedef struct
{
	UINT                hex_string_length;
	USHORT           *  hex_string;
}
    T120HexString, GCCHexString, *PGCCHexString;

/*
**	Typedef for a GCC long string.  This typedef is used in GCC for
**	storing	variable length strings of longs with embedded NULLs.
*/
typedef struct tagT120LongString
{
	ULONG               long_string_length;
	ULONG         *     long_string;
}
    T120LongString, GCCLongString, *PGCCLongString;


/*
 *	TransportAddress is passed in with the ConnectRequest() call.
 *	This address is always a pointer to an ascii string.
 *	The TransportAddress represents a remote location.  It is the TCP
 *	address of the remote machine.
 *
 */
typedef	LPSTR       TransportAddress, *PTransportAddress;


/*
**	Typedef for a GCC Character string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
*/
// lonchanc: we should simply use char.
typedef BYTE        GCCCharacter, *GCCCharacterString, **PGCCCharacterString;

/*
**	Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
**	A single character in this string is constrained to numeric values 
**	ranging from "0" to "9".
*/
typedef LPSTR       GCCNumericString, *PGCCNumericString;

/*
**	Typdef for GCC version which is used when registering the node controller
**	or an application.
*/
typedef	struct
{
	USHORT	major_version;
	USHORT	minor_version;
}
    GCCVersion, *PGCCVersion;



/* 
** Macros for values of Booleans passed through the GCC API.
*/
#define		CONFERENCE_IS_LOCKED					TRUE
#define		CONFERENCE_IS_NOT_LOCKED				FALSE
#define		CONFERENCE_IS_LISTED					TRUE
#define		CONFERENCE_IS_NOT_LISTED				FALSE
#define		CONFERENCE_IS_CONDUCTIBLE				TRUE
#define		CONFERENCE_IS_NOT_CONDUCTIBLE			FALSE
#define		PERMISSION_IS_GRANTED					TRUE
#define		PERMISSION_IS_NOT_GRANTED				FALSE
#define		TIME_IS_CONFERENCE_WIDE					TRUE
#define		TIME_IS_NOT_CONFERENCE_WIDE				FALSE
#define		APPLICATION_IS_ENROLLED_ACTIVELY		TRUE
#define		APPLICATION_IS_NOT_ENROLLED_ACTIVELY	FALSE
#define		APPLICATION_IS_CONDUCTING				TRUE
#define		APPLICATION_IS_NOT_CONDUCTING_CAPABLE	FALSE
#define		APPLICATION_IS_ENROLLED					TRUE
#define		APPLICATION_IS_NOT_ENROLLED				FALSE
#define		DELIVERY_IS_ENABLED						TRUE
#define		DELIVERY_IS_NOT_ENABLED					FALSE

/*
**	The following enum structure typedefs are used to define the GCC Object Key.
**	The GCC Object Key is used throughout GCC for things like the Application
**	keys and Capability IDs.
*/

typedef AppletKeyType               GCCObjectKeyType, *PGCCObjectKeyType;;
#define GCC_OBJECT_KEY              APPLET_OBJECT_KEY
#define GCC_H221_NONSTANDARD_KEY    APPLET_H221_NONSTD_KEY


typedef struct tagT120ObjectKey
{
    GCCObjectKeyType	key_type;
    GCCLongString		object_id;
    OSTR        		h221_non_standard_id;
}
    T120ObjectKey, GCCObjectKey, *PGCCObjectKey;

/*
**	GCCNonStandardParameter
**		This structure is used within the NetworkAddress typedef and
**		the NetworkService typedef defined below.
*/
typedef struct 
{
	GCCObjectKey		object_key;
	OSTR        		parameter_data;
}
    GCCNonStandardParameter, *PGCCNonStandardParameter;


/*
**	GCCConferenceName
**		This structure defines the conference name.  In a create request, the
**		conference name can include an optional unicode string but it must 
**		always include the simple numeric string.  In a join request, either
**		one can be specified.
*/
typedef struct
{
	GCCNumericString		numeric_string;
	LPWSTR					text_string;			/* optional */
}
    GCCConferenceName, GCCConfName, *PGCCConferenceName, *PGCCConfName;

/*
**	MCSChannelType
**		Should this be defined in MCATMCS?  It is used in a couple of places
**		below and is explicitly defined in the T.124 specification.
*/
typedef AppletChannelType               MCSChannelType, *PMCSChannelType;
#define MCS_STATIC_CHANNEL              APPLET_STATIC_CHANNEL
#define MCS_DYNAMIC_MULTICAST_CHANNEL   APPLET_DYNAMIC_MULTICAST_CHANNEL
#define MCS_DYNAMIC_PRIVATE_CHANNEL     APPLET_DYNAMIC_PRIVATE_CHANNEL
#define MCS_DYNAMIC_USER_ID_CHANNEL     APPLET_DYNAMIC_USER_ID_CHANNEL
#define MCS_NO_CHANNEL_TYPE_SPECIFIED   APPLET_NO_CHANNEL_TYPE_SPECIFIED

/*
**	GCCUserData
**		This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
	GCCObjectKey		key;
	LPOSTR          	octet_string;	/* optional */
}
    GCCUserData, *PGCCUserData;


/************************************************************************
*																		*
*					Node Controller Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCTerminationMethod
**		The termination method is used by GCC to determine
**		what action to take when all participants of a conference have
**		disconnected.  The conference can either be manually terminated
**		by the node controller or it can terminate itself automatically when 
**		all the participants have left the conference.
*/
typedef enum
{
	GCC_AUTOMATIC_TERMINATION_METHOD 		= 0, 
	GCC_MANUAL_TERMINATION_METHOD 	 		= 1
}
    GCCTerminationMethod, *PGCCTerminationMethod;

/*
**	GCCNodeType
**		GCC specified node types.  These node types dictate node controller	  
**		behavior under certain conditions.  See T.124 specification for
**		proper assignment based on the needs of the Node Controller.
*/
typedef enum
{
	GCC_TERMINAL							= 0,
	GCC_MULTIPORT_TERMINAL					= 1,
	GCC_MCU									= 2
}
    GCCNodeType, *PGCCNodeType;

/*
**	GCCNodeProperties
**		GCC specified node properties.  See T.124 specification for proper
**		assignment by the Node Controller.
*/
typedef enum
{
	GCC_PERIPHERAL_DEVICE					= 0,
	GCC_MANAGEMENT_DEVICE					= 1,
	GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE	= 2,
	GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT	= 3
}
    GCCNodeProperties, *PGCCNodeProperties;

/*
**	GCCPassword
**		This is the unique password specified by the convenor of the
**		conference that is used by the node controller to insure conference
**		security. This is also a unicode string.
*/
typedef	struct
{
	GCCNumericString	numeric_string;
	LPWSTR				text_string;	/* optional */
}
    GCCPassword, *PGCCPassword;

/*
**	GCCChallengeResponseItem
**		This structure defines what a challenge response should look like.
**		Note that either a password string or response data should be passed
**		but not both.
*/
typedef struct
{
    GCCPassword		*		password_string;
	USHORT      			number_of_response_data_members;
	GCCUserData		**		response_data_list;
}
    GCCChallengeResponseItem, *PGCCChallengeResponseItem;

typedef	enum
{
	GCC_IN_THE_CLEAR_ALGORITHM	= 0,
	GCC_NON_STANDARD_ALGORITHM	= 1
}
    GCCPasswordAlgorithmType, *PGCCPasswordAlgorithmType;

typedef struct 
{
    GCCPasswordAlgorithmType		password_algorithm_type;
	GCCNonStandardParameter	*		non_standard_algorithm;	/* optional */
}
    GCCChallengeResponseAlgorithm, *PGCCChallengeResponseAlgorithm;

typedef struct 
{
    GCCChallengeResponseAlgorithm	response_algorithm;
	USHORT      					number_of_challenge_data_members;
	GCCUserData				**		challenge_data_list;
}
    GCCChallengeItem, *PGCCChallengeItem;

typedef struct 
{
    GCCResponseTag			challenge_tag;
	USHORT      			number_of_challenge_items;
	GCCChallengeItem	**	challenge_item_list;
}
    GCCChallengeRequest, *PGCCChallengeRequest;

typedef struct 
{
    GCCResponseTag						challenge_tag;
    GCCChallengeResponseAlgorithm		response_algorithm;
    GCCChallengeResponseItem			response_item;
}
    GCCChallengeResponse, *PGCCChallengeResponse;


typedef	enum
{
	GCC_PASSWORD_IN_THE_CLEAR	= 0,
	GCC_PASSWORD_CHALLENGE 		= 1
}
    GCCPasswordChallengeType, *PGCCPasswordChallengeType;

typedef struct 
{
	GCCPasswordChallengeType	password_challenge_type;
	
	union 
    {
        GCCPassword			password_in_the_clear;
        
        struct 
        {
            GCCChallengeRequest		*	challenge_request;	/* optional */
            GCCChallengeResponse	*	challenge_response;	/* optional */
        } challenge_request_response;
    } u;
}
    GCCChallengeRequestResponse, *PGCCChallengeRequestResponse;

/*
**	GCCAsymmetryType
**		Used in queries to determine if the calling and called node are known
**		by both Node Controllers involved with the connection.
*/
typedef enum
{
	GCC_ASYMMETRY_CALLER				= 1,
	GCC_ASYMMETRY_CALLED				= 2,
	GCC_ASYMMETRY_UNKNOWN				= 3
}
    GCCAsymmetryType, *PGCCAsymmetryType;

/*
**	GCCAsymmetryIndicator
**		Defines how the Node Controller sees itself when making a Query
**		request or response.  The random number portion of this structure is
**		only used if the asymmetry_type is specified to be 
**		GCC_ASYMMETRY_UNKNOWN.
*/
typedef struct
{
	GCCAsymmetryType	asymmetry_type;
	unsigned long		random_number;		/* optional */
}
    GCCAsymmetryIndicator, *PGCCAsymmetryIndicator;

/*
**	GCCNetworkAddress
**		The following block of structures defines the Network Address as defined 
**		by T.124.  Most of these structures were taken almost verbatim from the
**		ASN.1 interface file.  Since I'm not really sure what most of this stuff
**		is for I really didn't know how to simplify it.
*/
typedef	struct 
{
    BOOL         speech;
    BOOL         voice_band;
    BOOL         digital_56k;
    BOOL         digital_64k;
    BOOL         digital_128k;
    BOOL         digital_192k;
    BOOL         digital_256k;
    BOOL         digital_320k;
    BOOL         digital_384k;
    BOOL         digital_512k;
    BOOL         digital_768k;
    BOOL         digital_1152k;
    BOOL         digital_1472k;
    BOOL         digital_1536k;
    BOOL         digital_1920k;
    BOOL         packet_mode;
    BOOL         frame_mode;
    BOOL         atm;
}
    GCCTransferModes, *PGCCTransferModes;

#define		MAXIMUM_DIAL_STRING_LENGTH		17
typedef char	GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct 
{
    USHORT                  length;
    USHORT          *       value;
}
    GCCExtraDialingString, *PGCCExtraDialingString;

typedef	struct 
{
    BOOL         telephony3kHz;
    BOOL         telephony7kHz;
    BOOL         videotelephony;
    BOOL         videoconference;
    BOOL         audiographic;
    BOOL         audiovisual;
    BOOL         multimedia;
}
    GCCHighLayerCompatibility, *PGCCHighLayerCompatibility;

typedef	struct 
{
    GCCTransferModes				transfer_modes;
    GCCDialingString   				international_number;
    GCCCharacterString				sub_address_string;  		/* optional */
    GCCExtraDialingString		*	extra_dialing_string;  		/* optional */
  	GCCHighLayerCompatibility 	*	high_layer_compatibility;	/* optional */
}
    GCCAggregatedChannelAddress, *PGCCAggregatedChannelAddress;

#define		MAXIMUM_NSAP_ADDRESS_SIZE		20
typedef struct 
{
    struct 
    {
        UINT    length;
        BYTE    value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;
   
	LPOSTR              transport_selector;				/* optional */
}
    GCCTransportConnectionAddress, *PGCCTransportConnectionAddress;

typedef enum
{
	GCC_AGGREGATED_CHANNEL_ADDRESS		= 1,
	GCC_TRANSPORT_CONNECTION_ADDRESS	= 2,
	GCC_NONSTANDARD_NETWORK_ADDRESS		= 3
}
    GCCNetworkAddressType, *PGCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    
    union 
    {
		GCCAggregatedChannelAddress		aggregated_channel_address;
		GCCTransportConnectionAddress	transport_connection_address;
        GCCNonStandardParameter			non_standard_network_address;
    } u;
}
    GCCNetworkAddress, *PGCCNetworkAddress;

/*
**	GCCNodeRecord
**		This structure defines a single conference roster record.  See the
**		T.124 specification for parameter definitions.
*/
typedef struct
{
	UserID					node_id;
	UserID					superior_node_id;
	GCCNodeType				node_type;
	GCCNodeProperties		node_properties;
	LPWSTR					node_name; 					/* optional */
	USHORT      			number_of_participants;
	LPWSTR			 	*	participant_name_list; 		/* optional */	
	LPWSTR					site_information; 			/* optional */
	UINT        			number_of_network_addresses;
	GCCNetworkAddress 	**	network_address_list;		/* optional */
	LPOSTR                  alternative_node_id;		/* optional */
	USHORT      			number_of_user_data_members;
	GCCUserData			**	user_data_list;				/* optional */
}
    GCCNodeRecord, *PGCCNodeRecord;

/*
**	GCCConferenceRoster
**		This structure hold a complete conference roster.  See the
**		T.124 specification for parameter definitions.
*/

typedef struct
{  
	USHORT  		instance_number;
	BOOL 			nodes_were_added;
	BOOL 			nodes_were_removed;
	USHORT			number_of_records;
	GCCNodeRecord		 **	node_record_list;
}
    GCCConferenceRoster, *PGCCConferenceRoster, GCCConfRoster, *PGCCConfRoster;

/*
**	GCCConferenceDescriptor
**		Definition for the conference descrip