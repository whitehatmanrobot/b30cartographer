== NULL);
            }
#endif

            if ((Connection->sp.CurrentSendMdl == NULL) ||
                (Connection->CurrentSendLength <= Connection->sp.MessageBytesSent)) {

                //
                // Yep. We know that we've exhausted the current request's buffer
                // here, so see if there's another request without EOF set that we
                // can build start throwing into this packet.
                //

                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                   NbfPrint0 ("PacketizeSend:  Used up entire request.\n");
                }

                if (!(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL)) {

                    //
                    // We are sending the last packet in a message.  Change
                    // the packet type and indicate in the connection object's
                    // send state that we are waiting for a DATA_ACK NetBIOS-
                    // level acknowlegement.
                    //

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint0 ("PacketizeSend:  Request has EOR, making pkt a DOL.\n");
                    }

                    //
                    // Keep track of how many consecutive sends we have done.
                    //

                    Connection->ConsecutiveSends++;
                    Connection->ConsecutiveReceives = 0;

                    //
                    // Change it to a DOL with piggyback ack allowed if wanted.
                    //

                    ASSERT (NbfHeader->Command == NBF_CMD_DATA_ONLY_LAST);
                    if (!(IRP_SEND_FLAGS(IrpSp) &
                                TDI_SEND_NO_RESPONSE_EXPECTED) &&
                            (Connection->ConsecutiveSends < 2)) {
                        if (NbfUsePiggybackAcks) {
                            NbfHeader->Data1 |= DOL_OPTIONS_ACK_W_DATA_ALLOWED;
                        }
                    }

                    Connection->SendState = CONNECTION_SENDSTATE_W_ACK;
                    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
                    ExitAfterSendOnePacket = TRUE;

                } else {

                    //
                    // We are sending the last packet in this request. If there
                    // are more requests in the connection's SendQueue, then
                    // advance complex send pointer to point to the next one
                    // in line.  Otherwise, if there aren't any more requests
                    // ready to packetize, then we enter the W_EOR state and
                    // stop packetizing. Note that we're waiting here for the TDI
                    // client to come up with data to send; we're just hanging out
                    // until then.
                    //
                    // DGB: Note that this will allow the last packet in the
                    // request to be smaller than the max packet length. This
                    // is not addressed anywhere that I can find in the NBF
                    // spec, and will be interesting to test against a non-NT
                    // NBF protocol.
                    //

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint0 ("PacketizeSend:  Request doesn't have EOR.\n");
                    }

                    NbfHeader->Command = NBF_CMD_DATA_FIRST_MIDDLE;

                    if (Connection->sp.CurrentSendIrp->Tail.Overlay.ListEntry.Flink == &Connection->SendQueue) {

                        Connection->SendState = CONNECTION_SENDSTATE_W_EOR;
                        Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
                        ExitAfterSendOnePacket = TRUE;

                    } else {

                        Connection->sp.CurrentSendIrp =
                            CONTAINING_RECORD (
                                Connection->sp.CurrentSendIrp->Tail.Overlay.ListEntry.Flink,
                                IRP,
                                Tail.Overlay.ListEntry);
                        Connection->sp.CurrentSendMdl =
                            Connection->sp.CurrentSendIrp->MdlAddress;
                        Connection->sp.SendByteOffset = 0;
                        Connection->CurrentSendLength +=
                            IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp));
                    }
                }

            } else {

                NbfHeader->Command = NBF_CMD_DATA_FIRST_MIDDLE;

            }

            //
            // Before we release the spinlock, see if we want to
            // piggyback an ack on here.
            //

            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {

                //
                // Turn off the flags. We don't take it off the queue,
                // that will be handled by the timer function.
                //

                Connection->DeferredFlags &=
                    ~(CONNECTION_FLAGS_DEFERRED_ACK | CONNECTION_FLAGS_DEFERRED_NOT_Q);

                ASSERT (DOL_OPTIONS_ACK_INCLUDED == DFM_OPTIONS_ACK_INCLUDED);

#if DBG
                if (NbfDebugPiggybackAcks) {
                    NbfPrint0("A");
                }
#endif

                //
                // TRANSMIT_CORR(NbfHeader) is already set correctly.
                //

                NbfHeader->Data1 |= DOL_OPTIONS_ACK_INCLUDED;

            } else {

                TRANSMIT_CORR(NbfHeader) = (USHORT)0;

            }

            //
            // To prevent a send "crossing" the receive and
            // causing a bogus piggyback ack timeout (this
            // only matters if a receive indication is in
            // progress).
            //

            Connection->CurrentReceiveAckQueueable = FALSE;

            SentPacket = TRUE;
            LastPacketLength =
                sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION) + PacketBytes;

            MacModifyHeader(
                 &DeviceContext->MacInfo,
                 Packet->Header,
                 LastPacketLength);

            Packet->NdisIFrameLength = LastPacketLength;

            ASSERT (Connection->LinkSpinLock == &Connection->Link->SpinLock);

            Status = SendOnePacket (Connection, Packet, FALSE, &LinkCheckpoint);

            if (Status == STATUS_LINK_FAILED) {

                //
                // If SendOnePacket failed due to the link being
                // dead, then we tear down the link.
                //

                FailSend (Connection, STATUS_LINK_FAILED, TRUE);                   // fail the send
                NbfDereferencePacket (Packet);            // remove creation hold.
                if (Direct) {
                    NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                }
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);

                return;

            } else {

                //
                // SendOnePacket returned success, so update our counters;
                //

                DeviceContext->TempIFrameBytesSent += PacketBytes;
                ++DeviceContext->TempIFramesSent;

                if ((Status == STATUS_SUCCESS) && LinkCheckpoint) {

                    //
                    // We are checkpointing; this means that SendOnePacket
                    // will already have set the state to W_LINK and turned
                    // off the PACKETIZE flag, so we should leave. When
                    // the checkpoint response is received, we will
                    // resume packetizing. We don't have to worry about
                    // doing all the other recovery stuff (resetting
                    // the piggyback ack flag, complex send pointer, etc.)
                    // because the send did in fact succeed.
                    //

                    if (Direct) {
#if DBG
                        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                        NbfDereferenceConnection ("Link checkpoint", Connection, CREF_PACKETIZE);
#endif
                    } else {
                        NbfDereferenceConnection ("Link checkpoint", Connection, CREF_PACKETIZE);
                    }
                    return;

                } else if (ExitAfterSendOnePacket ||
                           (Status == STATUS_MORE_PROCESSING_REQUIRED)) {

                    if (Direct) {
#if DBG
                        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
                        NbfDereferenceConnection ("Packetize done", Connection, CREF_PACKETIZE);
#endif
                    } else {
                        NbfDereferenceConnection ("Packetize done", Connection, CREF_PACKETIZE);
                    }
                    return;

                }
            }
        }

BufferChainFailure:;

        //
        // Note that we may have fallen out of the BuildBuffer... if above with
        // Status set to STATUS_INSUFFICIENT_RESOURCES. if we have, we'll just
        // stick this connection back onto the packetize queue and hope the
        // system gets more resources later.
        //


        if (!NT_SUCCESS (Status)) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint0 ("PacketizeSend:  SendOnePacket failed.\n");
            }

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            //
            // Indicate we're waiting on favorable link conditions.
            //

            Connection->SendState = CONNECTION_SENDSTATE_W_LINK;

            //
            // Clear the PACKETIZE flag, indicating that we're no longer
            // on the PacketizeQueue or actively packetizing.  The flag
            // was set by StartPacketizingConnection to indicate that
            // the connection was already on the PacketizeQueue.
            //

            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            //
            // If we are exiting and we sent a packet without
            // polling, we need to start T1.
            //

            if (Direct) {

                //
                // We have to do the CREF_SEND_IRP reference that is missing.
                //

#if DBG
                NbfReferenceConnection("TdiSend", Connection, CREF_SEND_IRP);
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);
#endif
            } else {
                NbfDereferenceConnection ("Send failed", Connection, CREF_PACKETIZE);
            }

            return;
        }

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // It is probable that a NetBIOS frame arrived while we released
        // the connection's spin lock, so our state has probably changed.
        // When we cycle around this loop again, we will have the lock
        // again, so we can test the connection's send state.
        //

    } while (Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE);

    //
    // Clear the PACKETIZE flag, indicating that we're no longer on the
    // PacketizeQueue or actively packetizing.  The flag was set by
    // StartPacketizingConnection to indicate that the connection was
    // already on the PacketizeQueue.
    //

    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);


    if (Direct) {
#if DBG
        NbfReferenceConnection ("Delayed request ref", Connection, CREF_SEND_IRP);
        NbfDereferenceConnection ("PacketizeSend done", Connection, CREF_PACKETIZE);
#endif
    } else {
        NbfDereferenceConnection ("PacketizeSend done", Connection, CREF_PACKETIZE);
    }

} /* PacketizeSend */


VOID
CompleteSend(
    PTP_CONNECTION Connection,
    IN USHORT Correlator
    )

/*++

Routine Description:

    This routine is called because the connection partner acknowleged
    an entire message at the NetBIOS Frames Protocol level, either through
    a DATA_ACK response, or a RECEIVE_OUTSTANDING, or RECEIVE_CONTINUE,
    or NO_RECEIVE response where the number of bytes specified exactly
    matches the number of bytes sent in the message.  Here we retire all
    of the TdiSends on the connection's SendQueue up to and including the
    one with the TDI_END_OF_RECORD bitflag set.  For each request, we
    complete the I/O.

    NOTE: This function is called with the connection spinlock
    held and returns with it held, but it may release it in the
    middle. THIS FUNCTION MUST BE CALLED AT DPC LEVEL.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Correlator - The correlator in the DATA_ACK or piggybacked ack.

    OldIrqlP - Returns the IRQL at which the connection spinlock
        was acquired.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY p;
    BOOLEAN EndOfRecord;
    KIRQL cancelIrql;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("CompleteSend: Entered for connection %lx.\n", Connection);
    }


    //
    // Make sure that the correlator is the expect one, and
    // that we are in a good state (don't worry about locking
    // since this is an unusual case anyway).
    //

    if (Correlator != Connection->NetbiosHeader.ResponseCorrelator) {
        NbfPrint0 ("NbfCompleteSend: ack ignored, wrong correlator\n");
        return;
    }

    if (Connection->SendState != CONNECTION_SENDSTATE_W_ACK) {
        NbfPrint0 ("NbfCompleteSend: ack not expected\n");
        return;
    }

    //
    // Pick off TP_REQUEST objects from the connection's SendQueue until
    // we find one with an END_OF_RECORD mark embedded in it.
    //

    while (!(IsListEmpty(&Connection->SendQueue))) {

        //
        // We know for a fact that we wouldn't be calling this routine if
        // we hadn't received an acknowlegement for an entire message,
        // since NBF doesn't provide stream mode sends.  Therefore, we
        // know that we will run into a request with the END_OF_RECORD
        // mark set BEFORE we will run out of requests on that queue,
        // so there is no reason to check to see if we ran off the end.
        // Note that it's possible that the send has been failed and the
        // connection not yet torn down; if this has happened, we could be
        // removing from an empty queue here. Make sure that doesn't happen.
        //

        p = RemoveHeadList(&Connection->SendQueue);

        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation (Irp);

        EndOfRecord = !(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = Irp;
        NbfCompletedSends[NbfCompletedSendsNext].Request = NULL;
        NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_SUCCESS;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif
#if DBG
        IF_NBFDBG (NBF_DEBUG_TRACKTDI) {
            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_SENDS) != 0){
                NbfPrint1 ("CompleteSend: Completing send request %lx\n", Irp);
                if (++Connection->DeferredPasses >= 4) {
                    Connection->DeferredFlags &= ~CONNECTION_FLAGS_DEFERRED_SENDS;
                    Connection->DeferredPasses = 0;
                }

            }

        }
#endif


        //
        // Complete the send. Note that this may not actually call
        // IoCompleteRequest for the Irp until sometime later, if the
        // in-progress LLC resending going on below us needs to complete.
        //

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        //
        // Since the irp is no longer on the send list, the cancel routine
        // cannot find it and will just return. We must grab the cancel
        // spinlock to lock out the cancel function while we null out
        // the Irp->CancelRoutine field.
        //

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        NbfCompleteSendIrp (
                Irp,
                STATUS_SUCCESS,
                IRP_SEND_LENGTH(IrpSp));

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        ++Connection->TransmittedTsdus;

        if (EndOfRecord) {
            break;
        }

    }

    //
    // We've finished processing the current send.  Update our state.
    //
    // Note: The connection spinlock is held here.
    //

    Connection->SendState = CONNECTION_SENDSTATE_IDLE;

    //
    // If there is another send pending on the connection, then initialize
    // it and start packetizing it.
    //

    if (!(IsListEmpty (&Connection->SendQueue))) {

        InitializeSend (Connection);

        //
        // This code is similar to calling StartPacketizingConnection
        // with the second parameter FALSE.
        //

        if ((!(Connection->Flags & CONNECTION_FLAGS_PACKETIZE)) &&
            (Connection->Flags & CONNECTION_FLAGS_READY)) {

            Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

            NbfReferenceConnection ("Packetize", Connection, CREF_PACKETIZE_QUEUE);

            ExInterlockedInsertTailList(
                &Connection->Provider->PacketizeQueue,
                &Connection->PacketizeLinkage,
                &Connection->Provider->SpinLock);

        }

    }

    //
    // NOTE: We return with the lock held.
    //

} /* CompleteSend */


VOID
FailSend(
    IN PTP_CONNECTION Connection,
    IN NTSTATUS RequestStatus,
    IN BOOLEAN StopConnection
    )

/*++

Routine Description:

    This routine is called because something on the link caused this send to be
    unable to complete. There are a number of possible reasons for this to have
    happened, but all will fail with the common error STATUS_LINK_FAILED.
    or NO_RECEIVE response where the number of bytes specified exactly
    Here we retire all of the TdiSends on the connection's SendQueue up to
    and including the current one, which is the one that failed.

    Later - Actually, a send failing is cause for the entire circuit to wave
    goodbye to this life. We now simply tear down the connection completly.
    Any future sends on this connection will be blown away.

    NOTE: THIS FUNCTION MUST BE CALLED WITH THE SPINLOCK HELD.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY p;
    BOOLEAN EndOfRecord;
    BOOLEAN GotCurrent = FALSE;
    KIRQL cancelIrql;


    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("FailSend: Entered for connection %lx.\n", Connection);
    }


    //
    // Pick off IRP objects from the connection's SendQueue until
    // we get to this one. If this one does NOT have an EOF mark set, we'll
    // need to keep going until we hit one that does have EOF set. Note that
    // this may  cause us to continue failing sends that have not yet been
    // queued. (We do all this because NBF does not provide stream mode sends.)
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
    NbfReferenceConnection ("Failing Send", Connection, CREF_COMPLETE_SEND);

    do {
        if (IsListEmpty (&Connection->SendQueue)) {

           //
           // got an empty list, so we've run out of send requests to fail
           // without running into an EOR. Set the connection flag that will
           // cause all further sends to be failed up to an EOR and get out
           // of here.
           //

           Connection->Flags |= CONNECTION_FLAGS_FAILING_TO_EOR;
           break;
        }
        p = RemoveHeadList (&Connection->SendQueue);
        Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation (Irp);

        if (Irp == Connection->sp.CurrentSendIrp) {
           GotCurrent = TRUE;
        }
        EndOfRecord = !(IRP_SEND_FLAGS(IrpSp) & TDI_SEND_PARTIAL);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = Irp;
        NbfCompletedSends[NbfCompletedSendsNext].Status = RequestStatus;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        //
        // The following dereference will complete the I/O, provided removes
        // the last reference on the request object.  The I/O will complete
        // with the status and information stored in the Irp.  Therefore,
        // we set those values here before the dereference.
        //

        NbfCompleteSendIrp (Irp, RequestStatus, 0);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        ++Connection->TransmissionErrors;

    } while (!EndOfRecord & !GotCurrent);

    //
    // We've finished processing the current send.  Update our state.
    //

    Connection->SendState = CONNECTION_SENDSTATE_IDLE;
    Connection->sp.CurrentSendIrp = NULL;

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    //
    // Blow away this connection; a failed send is a terrible thing to waste.
    // Note that we are not on any packetizing queues or similar things at this
    // point; we'll just disappear into the night.
    //

#if MAGIC
    if (NbfEnableMagic) {
        extern VOID NbfSendMagicBullet (PDEVICE_CONTEXT, PTP_LINK);
        NbfSendMagicBullet (Connection->Provider, Connection->Link);
    }
#endif

    if (StopConnection) {
#if DBG
        if (NbfDisconnectDebug) {
            STRING remoteName, localName;
            remoteName.Length = NETBIOS_NAME_LENGTH - 1;
            remoteName.Buffer = Connection->RemoteName;
            localName.Length = NETBIOS_NAME_LENGTH - 1;
            localName.Buffer = Connection->AddressFile->Address->NetworkName->NetbiosName;
            NbfPrint2( "FailSend stopping connection to %S from %S\n",
                &remoteName, &localName );
        }
#endif
        NbfStopConnection (Connection, STATUS_LINK_FAILED);
    }

#if DBG
    //DbgBreakPoint ();
#endif

    NbfDereferenceConnection ("FailSend", Connection, CREF_COMPLETE_SEND);

} /* FailSend */

#if DBG
//
// *** This is the original version of InitializeSend, which is now a macro.
//     It has been left here as the fully-commented version of the code.
//


VOID
InitializeSend(
    PTP_CONNECTION Connection
    )

/*++

Routine Description:

    This routine is called whenever the next send on a connection should
    be initialized; that is, all of the fields associated with the state
    of the current send are set to refer to the first send on the SendQueue.

    WARNING:  This routine is executed with the Connection lock acquired
    since it must be atomically executed with the caller's setup.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("InitializeSend: Entered for connection %lx.\n", Connection);
    }

    ASSERT (!IsListEmpty (&Connection->SendQueue));

    Connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;
    Connection->FirstSendIrp =
        CONTAINING_RECORD (Connection->SendQueue.Flink, IRP, Tail.Overlay.ListEntry);
    Connection->FirstSendMdl = Connection->FirstSendIrp->MdlAddress;
    Connection->FirstSendByteOffset = 0;
    Connection->sp.MessageBytesSent = 0;
    Connection->sp.CurrentSendIrp = Connection->FirstSendIrp;
    Connection->sp.CurrentSendMdl = Connection->FirstSendMdl;
    Connection->sp.SendByteOffset = Connection->FirstSendByteOffset;
    Connection->CurrentSendLength =
        IRP_SEND_LENGTH(IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp));
    Connection->StallCount = 0;
    Connection->StallBytesSent = 0;

    //
    // The send correlator isn't used for much; it is used so we
    // can distinguish which send a piggyback ack is acking.
    //

    if (Connection->NetbiosHeader.ResponseCorrelator == 0xffff) {
        Connection->NetbiosHeader.ResponseCorrelator = 1;
    } else {
        ++Connection->NetbiosHeader.ResponseCorrelator;
    }

} /* InitializeSend */
#endif


VOID
ReframeSend(
    PTP_CONNECTION Connection,
    ULONG BytesReceived
    )

/*++

Routine Description:

    This routine is called to reset the send state variables in the connection
    object to correctly point to the first byte of data to be transmitted.
    In essence, this is the byte-level acknowlegement processor at the NetBIOS
    level for this transport.

    This is not straightforward because potentially multiple send requests
    may be posted to the connection to comprise a single message.  When a
    send request has its TDI_END_OF_RECORD option bitflag set, then that
    send is the last one to be sent in a logical message.  Therefore, we
    assume that the multiple-send scenario is the general case.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    BytesReceived - Number of bytes received thus far.

Return Value:

    none.

--*/

{
    PIRP Irp;
    PMDL Mdl;
    ULONG Offset;
    ULONG BytesLeft;
    ULONG MdlBytes;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ReframeSend: Entered for connection %lx, Flags: %lx Current Mdl: %lx\n",
            Connection, Connection->Flags, Connection->sp.CurrentSendMdl);
    }

    //
    // The caller is responsible for restarting the packetization process
    // on this connection.  In some cases (i.e., NO_RECEIVE handler) we
    // don't want to start packetizing, so that's why we do it elsewhere.
    //

    //
    // Examine all of the send requests and associated MDL chains starting
    // with the first one at the head of the connection's SendQueue, advancing
    // our complex current send pointer through the requests and MDL chains
    // until we reach the byte count he's specified.
    //

    ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

    //
    // In the case where a local disconnect has been issued, and we get a frame
    // that causes us to reframe the send our FirstSendIrp and FirstMdl 
    // pointers are stale.  Catch this condition and prevent faults caused by
    // this.  A better fix would be to change the logic that switches the
    // connection sendstate from idle to W_LINK to not do that.  However, this
    // is a broader change than fixing it right here.
    //

    if (IsListEmpty(&Connection->SendQueue)) {
        RELEASE_DPC_SPIN_LOCK(Connection->LinkSpinLock);
        return;
    }

    BytesLeft = BytesReceived;
    Irp = Connection->FirstSendIrp;
    Mdl = Connection->FirstSendMdl;
    if (Mdl) {
        MdlBytes = MmGetMdlByteCount (Mdl);
    } else {
        MdlBytes = 0;      // zero-length send
    }
    Offset = Connection->FirstSendByteOffset;

#if DBG
    IF_NBFDBG (NBF_DEBUG_TRACKTDI) {
        NbfPrint3 ("ReFrameSend: Called with Connection %lx FirstSend %lx CurrentSend %lx\n",
            Connection, Connection->FirstSendIrp, Connection->sp.CurrentSendIrp);
        Connection->DeferredFlags |= CONNECTION_FLAGS_DEFERRED_SENDS;
        Connection->DeferredPasses = 0;
    }
#endif

    //
    // We loop through while we have acked bytes left to account for,
    // advancing our pointers and completing any sends that have been
    // completely acked.
    //

    while (BytesLeft != 0) {

        if (Mdl == NULL) {
            KIRQL cancelIrql;

            //
            // We have exhausted the MDL chain on this request, so it has
            // been implicitly acked.  That means we must complete the I/O
            // by dereferencing the request before we reframe further.
            //

            p = RemoveHeadList (&Connection->SendQueue);
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

            //
            // Since the irp is no longer on the list, the cancel routine
            // won't find it. Grab the cancel spinlock to synchronize
            // and complete the irp.
            //

            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(Irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);

            NbfCompleteSendIrp (Irp, STATUS_SUCCESS, Offset);

            //
            // Now continue with the next request in the list.
            //

            ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            p = Connection->SendQueue.Flink;
            if (p == &Connection->SendQueue) {

                ULONG DumpData[2];

                //
                // The byte acknowledgement was for more than the
                // total length of sends we have outstanding; to
                // avoid problems we tear down the connection.
                //
#if DBG
                NbfPrint2 ("NbfReframeSend: Got %d extra bytes acked on %lx\n",
                            BytesLeft, Connection);
                ASSERT (FALSE);
#endif
                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

                DumpData[0] = Offset;
                DumpData[1] = BytesLeft;

                NbfWriteGeneralErrorLog(
                    Connection->Provider,
                    EVENT_TRANSPORT_BAD_PROTOCOL,
                    1,
                    STATUS_INVALID_NETWORK_RESPONSE,
                    L"REFRAME",
                    2,
                    DumpData);

                NbfStopConnection (Connection, STATUS_INVALID_NETWORK_RESPONSE);

                return;

            }

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            Mdl = Irp->MdlAddress;
            MdlBytes = MmGetMdlByteCount (Mdl);
            Offset = 0;

        } else if (MdlBytes > (Offset + BytesLeft)) {

            //
            // This MDL has more data than we really need.  Just use
            // part of it.  Then get out, because we're done.
            //

            Offset += BytesLeft;
            BytesLeft = 0;
            break;

        } else {

            //
            // This MDL does not have enough data to satisfy the ACK, so
            // use as much data as it has, and cycle around again.
            //

            Offset = 0;
            BytesLeft -= MdlBytes;
            Mdl = Mdl->Next;

            if (Mdl != NULL) {
                MdlBytes = MmGetMdlByteCount (Mdl);
            }

        }
    }

    //
    // Tmp debugging; we want to see if we got byte acked
    // for the entire send. This will break if we have
    // non-EOR sends.
    //

#if DBG
    if (BytesReceived != 0) {
        ASSERTMSG ("NbfReframeSend: Byte ack for entire send\n",
                        Mdl != NULL);
    }
#endif

    //
    // We've acked some data, possibly on a byte or message boundary.
    // We must pretend we're sending a new message all over again,
    // starting with the byte immediately after the last one he acked.
    //

    Connection->FirstSendIrp = Irp;
    Connection->FirstSendMdl = Mdl;
    Connection->FirstSendByteOffset = Offset;

    //
    // Since we haven't started sending this new reframed message yet,
    // we set our idea of the current complex send pointer to the first
    // complex send pointer.
    //

    Connection->sp.MessageBytesSent = 0;
    Connection->sp.CurrentSendIrp = Irp;
    Connection->sp.CurrentSendMdl = Mdl;
    Connection->sp.SendByteOffset = Offset;
    Connection->CurrentSendLength -= BytesReceived;
    Connection->StallCount = 0;
    Connection->StallBytesSent = 0;

#if DBG
    IF_NBFDBG (NBF_DEBUG_TRACKTDI) {

    {
        PLIST_ENTRY p;
        NbfPrint0 ("ReFrameSend: Walking Send List:\n");

        for (
            p = Connection->SendQueue.Flink;
            p != &Connection->SendQueue;
            p=p->Flink                     ) {

            Irp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            NbfPrint1 ("              Irp %lx\n", Irp);
        }
    }}
#endif

    RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

} /* ReframeSend */


VOID
NbfCancelSend(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel a send.
    The send is found on the connection's send queue; if it is the
    current request it is cancelled and the connection is torn down,
    otherwise it is silently cancelled.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    KIRQL oldirql, oldirql1;
    PIO_STACK_LOCATION IrpSp;
    PTP_CONNECTION Connection;
    PIRP SendIrp;
    PLIST_ENTRY p;
    BOOLEAN Found;

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    ASSERT ((IrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
            (IrpSp->MinorFunction == TDI_SEND));

    Connection = IrpSp->FileObject->FsContext;

    //
    // Since this IRP is still in the cancellable state, we know
    // that the connection is still around (although it may be in
    // the process of being torn down).
    //


    //
    // See if this is the IRP for the current send request.
    //

    ACQUIRE_SPIN_LOCK (Connection->LinkSpinLock, &oldirql);
    NbfReferenceConnection ("Cancelling Send", Connection, CREF_COMPLETE_SEND);

    p = Connection->SendQueue.Flink;
    SendIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);

    if (SendIrp == Irp) {

        //
        // yes, it is the first one on the send queue, so
        // trash the send/connection.  The first send is a special case
        // there are multiple pointers to the send request.  Just stop the 
        // connection.
        //

        //        p = RemoveHeadList (&Connection->SendQueue);

#if DBG
        NbfCompletedSends[NbfCompletedSendsNext].Irp = SendIrp;
        NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_CANCELLED;
        NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

        //
        // Prevent anyone from getting in to packetize before we
        // call NbfStopConnection.
        //

        Connection->SendState = CONNECTION_SENDSTATE_IDLE;

        RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
        IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
        DbgPrint("NBF: Canceled in-progress send %lx on %lxn",
                SendIrp, Connection);
#endif

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

        //
        // The following dereference will complete the I/O, provided removes
        // the last reference on the request object.  The I/O will complete
        // with the status and information stored in the Irp.  Therefore,
        // we set those values here before the dereference.
        //

        // NbfCompleteSendIrp (SendIrp, STATUS_CANCELLED, 0);

        //
        // Since we are cancelling the current send, blow away
        // the connection.
        //

        NbfStopConnection (Connection, STATUS_CANCELLED);

        KeLowerIrql (oldirql1);

    } else {

        //
        // Scan through the list, looking for this IRP. If we
        // cancel anything up to the first EOR on the list
        // we still tear down the connection since this would
        // mess up our packetizing otherwise. We set CancelledFirstEor
        // to FALSE when we pass an IRP without SEND_PARTIAL.
        //
        // NO MATTER WHAT WE MUST SHUT DOWN THE CONNECTION!!!!

#if 0
        if (!(IRP_SEND_FLAGS(IoGetCurrentIrpStackLocation(SendIrp)) & TDI_SEND_PARTIAL)) {
            CancelledFirstEor = FALSE;
        } else {
            CancelledFirstEor = TRUE;
        }
#endif

        Found = FALSE;
        p = p->Flink;
        while (p != &Connection->SendQueue) {

            SendIrp = CONTAINING_RECORD (p, IRP, Tail.Overlay.ListEntry);
            if (SendIrp == Irp) {

                //
                // Found it, remove it from the list here.
                //

                RemoveEntryList (p);

                Found = TRUE;

#if DBG
                NbfCompletedSends[NbfCompletedSendsNext].Irp = SendIrp;
                NbfCompletedSends[NbfCompletedSendsNext].Status = STATUS_CANCELLED;
                NbfCompletedSendsNext = (NbfCompletedSendsNext++) % TRACK_TDI_LIMIT;
#endif

                RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
                IoReleaseCancelSpinLock (Irp->CancelIrql);

#if DBG
                DbgPrint("NBF: Canceled queued send %lx on %lx\n",
                        SendIrp, Connection);
#endif

                //
                // The following dereference will complete the I/O, provided removes
                // the last reference on the request object.  The I/O will complete
                // with the status and information stored in the Irp.  Therefore,
                // we set those values here before the dereference.
                //

                KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

                NbfCompleteSendIrp (SendIrp, STATUS_CANCELLED, 0);
                //
                // STOP THE CONNECTION NO MATTER WHAT!!!
                //
                NbfStopConnection (Connection, STATUS_CANCELLED);

                KeLowerIrql (oldirql1);
                break;

            } 
#if 0
            else {

                if (CancelledFirstEor && (!(IRP_SEND_FLAGS(IoGetCurrentIrpStackLocation(SendIrp)) & TDI_SEND_PARTIAL))) {
                    CancelledFirstEor = FALSE;
                }
            }
#endif

            p = p->Flink;

        }

        if (!Found) {

            //
            // We didn't find it!
            //

#if DBG
            DbgPrint("NBF: Tried to cancel send %lx on %lx, not found\n",
                    Irp, Connection);
#endif
            RELEASE_SPIN_LOCK (Connection->LinkSpinLock, oldirql);
            IoReleaseCancelSpinLock (Irp->CancelIrql);
        }

    }

    NbfDereferenceConnection ("Cancelling Send", Connection, CREF_COMPLETE_SEND);

}


BOOLEAN
ResendPacket (
    PTP_LINK Link,
    PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine resends a packet on the link. Since this is a resend, we
    are careful to not reset the state unless all resends have completed.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - pointer to packet to be resent.

Return Value:

    True if resending should continue; FALSE otherwise.

--*/

{
    BOOLEAN PollFinal;
    PDLC_I_FRAME DlcHeader;
    UINT DataLength;


    //

    DlcHeader = (PDLC_I_FRAME)&(Packet->Header[Link->HeaderLength]);

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ReSendPacket: %lx NdisPacket: %lx # %x\n",
                Packet, Packet->NdisPacket,
                DlcHeader->RcvSeq >>1);
        IF_NBFDBG (NBF_DEBUG_PKTCONTENTS) {
            {PUCHAR q;
            USHORT i;
            q = Packet->Header;
            for (i=0;i<20;i++) {
                NbfPrint1 (" %2x",q[i]);
            }
            NbfPrint0 ("\n");}
        }
    }

    DataLength = Packet->NdisIFrameLength;

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    Link->WindowErrors++;

    PollFinal = (BOOLEAN)((DlcHeader->RcvSeq & DLC_I_PF) != 0);

    StopT2 (Link);   // since this is potentially acking some frames

    if (Link->Provider->MacInfo.MediumAsync) {
        if (PollFinal) {
            ASSERT (Packet->Link != NULL);
            NbfReferenceLink ("ResendPacket", Link, LREF_START_T1);
        } else {
            StartT1 (Link, 0);
        }
    } else {
        StartT1 (Link, PollFinal ? DataLength : 0);  // restart transmission timer
    }

    //
    // Update the expected next receive in case it's changed
    //

    if (PollFinal) {

        DlcHeader->RcvSeq = DLC_I_PF;    // set the poll bit.
        Link->SendState = SEND_STATE_CHECKPOINTING;

        Link->ResendingPackets = FALSE;

    } else {

        DlcHeader->RcvSeq = 0;

    }

    //
    // DlcHeader->RcvSeq has Link->NextReceive inserted by NbfNdisSend.
    //

    NbfReferencePacket (Packet); // so we don't remove it in send completion

    NbfReferenceLink ("ResendPacket", Link, LREF_NDIS_SEND);

    ASSERT (Packet->PacketSent == TRUE);
    Packet->PacketSent = FALSE;

    //
    // Update our "bytes resent" counters.
    //

    DataLength -=
        Link->HeaderLength + sizeof(DLC_I_FRAME) + sizeof(NBF_HDR_CONNECTION);


    ADD_TO_LARGE_INTEGER(
        &Link->Provider->Statistics.DataFrameBytesResent,
        DataLength);
    ++Link->Provider->Statistics.DataFramesResent;


    //
    // Send the packet (this release the link spinlock).
    //

    NbfNdisSend (Link, Packet);

    ++Link->PacketsResent;

    NbfDereferenceLink ("ResendPacket", Link, LREF_NDIS_SEND);

    //
    // if this packet has  POLL set, stop the resending so the
    // link doesn't get all twisted up.
    //

    if (PollFinal) {

        //
        // so we're in the state of having sent a poll and not
        // sending anything else until we get a final. This avoids
        // overrunning the remote. Note that we leave the routine
        // with state LINK_SENDSTATE_REJECTING, which guarentees
        // we won't start any new sends until we traverse through
        // this routine again.
        //
        //

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ResendLlcPackets (
    PTP_LINK Link,
    UCHAR AckSequenceNumber,
    BOOLEAN Resend
    )

/*++

Routine Description:

    This routine advances the state of a data link connection by retiring
    all of the packets on the link's WackQ that have send sequence numbers
    logically less than that number specified as the AckSequenceNumber, and
    resending those above that number. The packets are disposed of by
    dereferencing them.  We cannot simply destroy them because this
    acknowlegement might arrive even before the Physical Provider has had a
    chance to issue a completion event for the associated I/O.

    NOTE: This function is called with the link spinlock held and
    returns with it held, but it may release it in between. THIS
    ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    AckSequenceNumber - An unsigned number specifing the sequence number of
        the first packet within the window that is NOT acknowleged.

    Resend - if TRUE, resend packets. If FALSE, just remove them from the
        wackq and get out.

Return Value:

    none.

--*/

{
    PTP_PACKET packet;
    PLIST_ENTRY p, p1;
    UCHAR packetSeq;
    BOOLEAN passedAck = FALSE;
    PDLC_I_FRAME DlcHeader;
    SCHAR Difference;
    BOOLEAN ReturnValue = FALSE;
//    NDIS_STATUS ndisStatus;

    //
    // Move through the queue, releasing those we've been acked for and resending
    // others above that.
    //

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint3 ("ResendLlcPackets:  Link %lx, Ack: %x, LinkLastAck: %x.\n",
            Link, AckSequenceNumber, Link->LastAckReceived);
        NbfPrint0 ("RLP: Walking WackQ, Packets:\n");
        p = Link->WackQ.Flink;              // p = ptr, 1st pkt's linkage.
        while (p != &Link->WackQ) {
            packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
            DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);
            NbfPrint4 ("RLP: Pkt: %lx # %x Flags: %d %d\n", packet,
            (UCHAR)(DlcHeader->SendSeq >> 1), packet->PacketSent, packet->PacketNoNdisBuffer);
            p = packet->Linkage.Flink;
        }
    }

    //
    // If somebody else is resending LLC packets (which means they
    // are in this function with Resend == TRUE), then ignore
    // this frame. This is because it may ack a frame that he
    // is in the middle of resending, which will cause problems.
    //
    // This isn't a great solution, we should keep track
    // of where the other guy is and avoid stepping on him. This
    // might mess up his walking of the queue however.
    //

    if (Link->ResendingPackets) {
        NbfPrint1("ResendLlcPackets: Someone else resending on %lx\n", Link);
        return TRUE;
    }

    //
    // We have already checked that AckSequenceNumber is reasonable.
    //

    Link->LastAckReceived = AckSequenceNumber;

    if (Resend) {

        //
        // Only one person can be resending or potentially resending
        // at one time.
        //

        Link->ResendingPackets = TRUE;
    }

    //
    // Resend as many packets as we have window to send. We spin through the
    // queue and remove those packets that have been acked or that are
    // sequence numbered logically below the current ack number. The flags
    // PACKET_FLAGS_RESEND and PACKET_FLAGS_SENT correspond to the three states
    // a packet on this queue can be in:
    //
    //  1) if _RESEND is set, the packet has not been acked
    //
    //  2) if _SENT is set, the packet send has completed (conversely, if NOT
    //      set, the packet has not yet been completely sent, thus it is
    //      unnecessary to resend it).
    //  3) if _RESEND and _SENT are both set, the packet has been sent and not
    //      acked and is grist for our mills.
    //  4) if neither is set, the world is coming to an end next Thursday.
    //

    p=Link->WackQ.Flink;
    while (p != &Link->WackQ) {
        packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
        DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);

        //
        // if both bits aren't set we can't do a thing with this packet, or,
        // for that matter, with the rest of the packet list. We can't
        // have reached the ack number yet, as these packets haven't even
        // completed sending.
        // (Later) actually, we can have reached passedAck, and if we did
        // we're in a world of hurt. We can't send more regular packets,
        // but we can't send any resend packets either. Force the link to
        // checkpoint and things will clear themselves up later.
        //

        if (!(packet->PacketSent)) {
            if (passedAck) {
                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                    NbfPrint2 ("ResendLLCPacket: Can't send WACKQ Packet RcvSeq %x %x \n",
                      DlcHeader->RcvSeq, DlcHeader->SendSeq);
                }

                if (Link->SendState != SEND_STATE_CHECKPOINTING) {

                    //
                    // Don't start checkpointing if we already are.
                    //

                    Link->SendState = SEND_STATE_CHECKPOINTING;
                    StopTi (Link);
                    StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));  // start checkpoint timeout.
                    Link->ResendingPackets = FALSE;

                    //
                    // Try this...in this case don't actually send
                    // an RR, since his response might put us right
                    // back here. When T1 expires we will recover.
                    //
                    // NbfSendRr (Link, TRUE, TRUE);

                } else {

                    Link->ResendingPackets = FALSE;

                }

                return TRUE;
            }

            //
            // Don't break, since passedAck is FALSE all we will
            // do in the next section is TpDereferencePacket, which
            // is correct.
            //
            // break;
        }

        //
        // This loop is somewhat schizo; at this point, if we've not yet reached
        // the ack number, we'll be ditching the packet. If we've gone through
        // the ack number, we'll be re-transmitting. Note that in the first
        // personality, we are always looking at the beginning of the list.
        //

        //
        // NOTE: Link spinlock is held here.
        //

        packetSeq = (UCHAR)(DlcHeader->SendSeq >> 1);
        if (!passedAck){

            //
            // Compute the signed difference here; see if
            // packetSeq is equal to or "greater than"
            // LastAckReceived.
            //

            Difference = packetSeq - Link->LastAckReceived;

            if (((Difference >= 0) && (Difference < 0x40)) ||
                (Difference < -0x40)) {

                //
                // We have found a packet on the queue that was
                // not acknowledged by LastAckReceived.
                //

                if (Link->SendState == SEND_STATE_CHECKPOINTING) {

                    //
                    // If we are checkpointing, we should not do any of
                    // the passedAck things (i.e. any of the things which
                    // potentially involve sending packets) - adb 7/30/91.
                    //

                    if (Resend) {
                        Link->ResendingPackets = FALSE;
                    }
                    return TRUE;
                }

                if (!Resend) {

                    //
                    // If we are not supposed to resend, then exit.
                    // Since there are still packets on the queue
                    // we restart T1.
                    //

                    StopTi (Link);
                    StartT1 (Link, 0);  // start checkpoint timeout.
                    return TRUE;
                }

                //
                // Lock out senders, so we maintain packet sequences properly
                //

                Link->SendState = SEND_STATE_REJECTING; // we're resending.

                passedAck = TRUE;

                //
                // Note that we don't advance the pointer to the next packet;
                // thus, we will resend this packet on the next pass through
                // the while loop (taking the passedAck branch).
                //

            } else {
                p1 = RemoveHeadList (&Link->WackQ);
                ASSERTMSG (" ResendLLCPacket: Packet not at queue head!\n", (p == p1));
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                ReturnValue = TRUE;
                NbfDereferencePacket (packet);

                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                p = Link->WackQ.Flink;
            }

        } else {
//            NbfPrint1 ("RLP: # %x\n",packetSeq);
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            //
            // If this call returns FALSE (because we checkpoint)
            // it clears ResendingPacket before it returns.
            //

            if (!ResendPacket (Link, packet)) {
                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
                return ReturnValue;
            }

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            p = p->Flink;
        }
    }

    //
    // NOTE: Link spinlock is held here.
    //

    if (passedAck) {

        //
        // If we exit through here with passedAck TRUE, it means that we
        // successfully called ResendPacket on every packet in the
        // WackQ, which means we did not resend a poll packet, so we
        // can start sending normally again. We have to clear
        // ResendingPackets here.
        //

        Link->SendState = SEND_STATE_READY;
        Link->ResendingPackets = FALSE;
        StartTi (Link);

    } else if (!Resend) {

        //
        // If Resend is FALSE (in which case passedAck will also be FALSE,
        // by the way), and the WackQ is empty, that means that we
        // successfully acknowledged all the packets on a non-final
        // frame. In this case T1 may be running, but in fact is not
        // needed since there are no sends outstanding.
        //

        if (Link->WackQ.Flink == &Link->WackQ) {
            StopT1 (Link);
        }
        Link->SendState = SEND_STATE_READY;
        StartTi (Link);

    } else {

        //
        // Resend is TRUE, but passedAck is FALSE; we came in
        // expecting to resend, but didn't. This means that
        // we have emptied the queue after receiving an
        // RR/f, i.e. this send window is done and we can
        // update our send window size, etc.
        //

        Link->ResendingPackets = FALSE;

        if (Link->Provider->MacInfo.MediumAsync) {
            return ReturnValue;
        }

        if (Link->WindowErrors > 0) {

            //
            // We had transmit errors on this window.
            //

            Link->PrevWindowSize = Link->SendWindowSize;

            //
            // We use 100 ms delay as the cutoff for a LAN.
            //

            if (Link->Delay < (100*MILLISECONDS)) {

                //
                // On a LAN, if we have a special case
                // if one packet was lost; this means the
                // final packet was retransmitted once. In
                // that case, we keep track of Consecutive
                // LastPacketLost, and if it reaches 2, then
                // we lock the send window at its current
                // value minus one.
                //

                if (Link->WindowErrors == 1) {

                    ++Link->ConsecutiveLastPacketLost;

                    if (Link->ConsecutiveLastPacketLost >= 2) {

                        //
                        // Freeze the window wherever it was.
                        //

                        if (Link->SendWindowSize > Link->Provider->MinimumSendWindowLimit) {
                            Link->MaxWindowSize = Link->SendWindowSize - 1;
                            Link->SendWindowSize = (UCHAR)Link->MaxWindowSize;
                        }

                    }

                    //
                    // Otherwise, we leave the window where it is.
                    //

                } else {

                    Link->ConsecutiveLastPacketLost = 0;
                    Link->SendWindowSize -= (UCHAR)Link->WindowErrors;

                }

            } else {

                //
                // On a WAN we cut the send window in half,
                // regardless of how many frames were retransmitted.
                //

                Link->SendWindowSize /= 2;
                Link->WindowsUntilIncrease = 1;   // in case Prev is also 1.
                Link->ConsecutiveLastPacketLost = 0;

            }

            if ((SCHAR)Link->SendWindowSize < 1) {
                Link->SendWindowSize = 1;
            }

            //
            // Reset our counters for the next window.
            //

            Link->WindowErrors = 0;

        } else {

            //
            // We have successfully sent a window of data, increase
            // the send window size unless we are at the limit.
            // We use 100 ms delay as the WAN/LAN cutoff.
            //

            if ((ULONG)Link->SendWindowSize < Link->MaxWindowSize) {

                if (Link->Delay < (100*MILLISECONDS)) {

                    //
                    // On a LAN, increase the send window by 1.
                    //
                    // Need to determine optimal window size.
                    //

                    Link->SendWindowSize++;

                } else {

                    //
                    // On a WAN, increase the send window by 1 until
                    // we hit PrevWindowSize, then do it more slowly.
                    //

                    if (Link->SendWindowSize < Link->PrevWindowSize) {

                        Link->SendWindowSize++;

                        //
                        // If we just increased it to the previous window
                        // size, prepare for the next time through here.
                        //

                        if (Link->SendWindowSize == Link->PrevWindowSize) {
                            Link->WindowsUntilIncrease = Link->SendWindowSize;
                        }

                    } else {

                        //
                        // We passed the previous size, so only update every
                        // WindowsUntilIncrease times.
                        //

                        if (--Link->WindowsUntilIncrease == 0) {

                            Link->SendWindowSize++;
                            Link->WindowsUntilIncrease = Link->SendWindowSize;

                        }
                    }
                }

                if ((ULONG)Link->SendWindowSize > Link->Provider->Statistics.MaximumSendWindow) {
                    Link->Provider->Statistics.MaximumSendWindow = Link->SendWindowSize;
                }

            }

            //
            // Clear this since we had no errors.
            //

            Link->ConsecutiveLastPacketLost = 0;

        }

    }

    return ReturnValue;

} /* ResendLlcPackets */


VOID
NbfSendCompletionHandler(
    IN NDIS_HANDLE ProtocolBindingContext,
    IN PNDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    This routine is called by the I/O system to indicate that a connection-
    oriented packet has been shipped and is no longer needed by the Physical
    Provider.

Arguments:

    NdisContext - the value associated with the adapter binding at adapter
                  open time (which adapter we're talking on).

    NdisPacket/RequestHandle - A pointer to the NDIS_PACKET that we sent.

    NdisStatus - the completion status of the send.

Return Value:

    none.

--*/

{
    PSEND_PACKET_TAG SendContext;
    PTP_PACKET Packet;
    KIRQL oldirql1;
    ProtocolBindingContext;  // avoid compiler warnings

#if DBG
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        NbfSendsCompletedAfterPendFail++;
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint2 ("NbfSendComplete: Entered for packet %lx, Status %s\n",
                NdisPacket, NbfGetNdisStatus (NdisStatus));
        }
    } else {
        NbfSendsCompletedAfterPendOk++;
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint2 ("NbfSendComplete: Entered for packet %lx, Status %s\n",
                NdisPacket, NbfGetNdisStatus (NdisStatus));
        }
    }
#endif

    SendContext = (PSEND_PACKET_TAG)&NdisPacket->ProtocolReserved[0];

    switch (SendContext->Type) {
    case TYPE_I_FRAME:

        //
        // Just dereference the packet.  There are a couple possibilities here.
        // First, the I/O completion might happen before an ACK is received,
        // in which case this will remove one of the references, but not both.
        // Second, the LLC ACK for this packet may have already been processed,
        // in which case this will destroy the packet.  Third, this packet may
        // be resent, either before or after this call, in which case the deref
        // won't destroy the packet.
        //
        // NbfDereferencePacket will call PacketizeSend if it determines that
        // there is at least one connection waiting to be packetized because
        // of out-of-resource conditions or because its window has been opened.
        //

        Packet = ((PTP_PACKET)SendContext->Frame);

        KeRaiseIrql (DISPATCH_LEVEL, &oldirql1);

        if (Packet->Provider->MacInfo.MediumAsync) {

            if (Packet->Link) {

                ASSERT (Packet->NdisIFrameLength > 0);

                ACQUIRE_DPC_SPIN_LOCK (&Packet->Link->SpinLock);
                StartT1 (Packet->Link, Packet->NdisIFrameLength);
                RELEASE_DPC_SPIN_LOCK (&Packet->Link->SpinLock);

                NbfDereferenceLink ("Send completed", Packet->Link, LREF_START_T1);
            }

            if (Packet->PacketizeConnection) {

                PTP_CONNECTION Connection = IRP_SEND_CONNECTION((PIO_STACK_LOCATION)(Packet->Owner));
                PDEVICE_CONTEXT DeviceContext = Packet->Provider;

                ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                if ((Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE) &&
                    (Connection->Flags & CONNECTION_FLAGS_READY)) {

                    ASSERT (Connection->Flags & CONNECTION_FLAGS_PACKETIZE);

                    ACQUIRE_DPC_SPIN_LOCK(&DeviceContext->SpinLock);

                    NbfReferenceConnection ("Delayed packetizing", Connection, CREF_PACKETIZE_QUEUE);
                    InsertTailList(&DeviceContext->PacketizeQueue, &Connection->PacketizeLinkage);

                    if (!DeviceContext->WanThreadQueued) {

                        DeviceContext->WanThreadQueued = TRUE;
                        ExQueueWorkItem(&DeviceContext->WanDelayedQueueItem, DelayedWorkQueue);

                    }

                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

                } else {

                    Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

                }

                RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
                NbfDereferenceConnection ("PacketizeConnection FALSE", Connection, CREF_TEMP);

                Packet->PacketizeConnection = FALSE;

            }
        }
#if DBG
        if (Packet->PacketSent) {
            DbgPrint ("NbfSendCompletionHandler: Packet %lx already completed\n", Packet);
            DbgBreakPoint();
        }
#endif
        Packet->PacketSent = TRUE;

        NbfDereferencePacket (Packet);

        KeLowerIrql (oldirql1);
        break;

    case TYPE_UI_FRAME:

        //
        // just destroy the frame; name stuff doesn't depend on having any
        // of the sent message left around after the send completed.
        //

        NbfDestroyConnectionlessFrame ((PDEVICE_CONTEXT)SendContext->Owner,
                         (PTP_UI_FRAME)SendContext->Frame);
        break;

    case TYPE_ADDRESS_FRAME:

        //
        // Addresses get their own frames; let the address know it's ok to
        // use the frame again.
        //

        NbfSendDatagramCompletion ((PTP_ADDRESS)SendContext->Owner,
            NdisPacket,
            NdisStatus );
        break;
    }

    return;

} /* NbfSendCompletionHandler */


NTSTATUS
SendOnePacket(
    IN PTP_CONNECTION Connection,
    IN PTP_PACKET Packet,
    IN BOOLEAN ForceAck,
    OUT PBOOLEAN LinkCheckpoint OPTIONAL
    )

/*++

Routine Description:

    This routine sends a connection-oriented packet by calling the NDIS
    Send service.  At least one event will occur following
    (or during) the Send request's processing.  (1) The Send request
    will complete through the I/O system, calling IoCompleteRequest.
    (2) The sequenced packet will be acknowleged at the LLC level, or it
    will be rejected and reset at the LLC level.  If the packet is resent,
    then it remains queued at the TP_LINK object.  If the packet is ACKed,
    then is removed from the link's WackQ and the Action field in the
    TP_PACKET structure dictates what operation to perform next.

    NOTE: This routine is called with the link spinlock held. THIS
    ROUTINE MUST BE CALLED AT DPC LEVEL.

    NOTE: This routine will now accept all frames unless the link
    is down. If the link cannot send, the packet will be queued and
    sent when possible.

Arguments:

    Connection - Pointer to a TP_CONNECTION object.

    Packet - Pointer to a TP_PACKET object.

    ForceAck - Boolean that, if true, indicates this packet should always have
            the Poll bit set; this force the other side to ack immediately,
            which is necessary for correct session teardown.

    LinkCheckpoint - If specified, will return TRUE if the link has
            just entered a checkpoint state. In this case the status
            will be STATUS_SUCCESS, but the connection should stop
            packetizing now (in fact, to close a window, the connection
            is put into the W_LINK state if this status will be
            returned, so he must stop because somebody else may
            already be doing it).

Return Value:

    STATUS_LINK_FAILED - the link is dead or not ready.
    STATUS_SUCCESS - the packet has been sent.
    STATUS_INSUFFICIENT_RESOURCES - the packet has been queued.

--*/

{
    PTP_LINK Link;
    PDLC_I_FRAME DlcHeader;
    PNDIS_BUFFER ndisBuffer;
    ULONG SendsOutstanding;
    BOOLEAN Poll = FALSE;
    NTSTATUS Status;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint3 ("SendOnePacket: Entered, connection %lx, packet %lx DnisPacket %lx.\n",
                    Connection, Packet, Packet->NdisPacket);
    }

    Link = Connection->Link;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        UINT PLength, PCount;
        UINT BLength;
        PVOID BAddr;
        NdisQueryPacket(Packet->NdisPacket, &PCount, NULL, &ndisBuffer, &PLength);
        NbfPrint3 ("Sending Data Packet: %lx, Length: %lx Pages: %lx\n",
            Packet->NdisPacket, PLength, PCount);
        while (ndisBuffer != NULL) {
            NdisQueryBuffer(ndisBuffer, &BAddr, &BLength);
            NbfPrint3 ("Sending Data Packet: Buffer %08lx Length %08lx Va %08lx\n",
                ndisBuffer, BLength, BAddr);
            NdisGetNextBuffer (ndisBuffer, &ndisBuffer);
        }
    }

    //
    // If the general state of the link is not READY, then we can't ship.
    // This failure can be expected under some conditions, and may not cause
    // failure of the send.
    //

    if (Link->State != LINK_STATE_READY) {
        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint1 ("SendOnePacket:  Link state is not READY (%ld).\n", Link->State);
        }

        //
        // determine what to do with this problem. If we shouldn't be sending
        // here, percolate an error upward.
        //

        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint3 ("SendOnePacket: Link Bad state, link: %lx Link Flags %lx Link State %lx\n",
                Link, Link->Flags, Link->State);
        }
        return STATUS_LINK_FAILED;
    }


    SendsOutstanding = (((ULONG)Link->NextSend+128L-(ULONG)Link->LastAckReceived)%128L);

    //
    // Format LLC header while we've got the spinlock to atomically update
    // the link's state information.
    //

    DlcHeader = (PDLC_I_FRAME)&(Packet->Header[Link->HeaderLength]);
    DlcHeader->SendSeq = (UCHAR)(Link->NextSend << 1);
    Link->NextSend = (UCHAR)((Link->NextSend + 1) & 0x7f);
    DlcHeader->RcvSeq = 0;   // Link->NextReceive is inserted by NbfNdisSend

    //
    // Before we release the spinlock, we append the packet to the
    // end of the link's WackQ, so that if an ACK arrives before the NdisSend
    // completes, it will be on the queue already. Also, mark the packet as
    // needing resend, which is canceled by AckLLCPackets, and used by
    // ResendLLCPackets. Thus, all packets will need to be resent until they
    // are acked.
    //

    ASSERT (Packet->PacketSent == FALSE);

    InsertTailList (&Link->WackQ, &Packet->Linkage);
    //SrvCheckListIntegrity( &Link->WackQ, 200 );


    //
    // If the send state is not READY, we can't ship.
    // This failure is mostly caused by flow control or retransmit in progress,
    // and is never cause for failure of the send.
    //

    if ((Link->SendState != SEND_STATE_READY) ||
        (Link->LinkBusy) ||
        (SendsOutstanding >= (ULONG)Link->SendWindowSize)) {

        if ((Link->SendWindowSize == 1) || ForceAck) {
            DlcHeader->RcvSeq |= DLC_I_PF;                  // set the poll bit.
            if (Link->Provider->MacInfo.MediumAsync) {
                Packet->Link = Link;
            }
        }

        Packet->PacketSent = TRUE;        // allows it to be resent.

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

#if DBG
        if (Link->SendState != SEND_STATE_READY) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint1 ("SendOnePacket:  Link send state not READY (%ld).\n", Link->SendState);
            }
        } else if (Link->LinkBusy) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                PANIC ("SendOnePacket:  Link is busy.\n");
            }
        } else if (SendsOutstanding >= (ULONG)Link->SendWindowSize) {
            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint3 ("SendOnePacket:  No link send window; N(S)=%ld,LAR=%ld,SW=%ld.\n",
                          Link->NextSend, Link->LastAckReceived, Link->SendWindowSize);
            }
        }
#endif

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reference the packet since it is given to the NDIS driver.
    //

#if DBG
    NbfReferencePacket (Packet);
#else
    ++Packet->ReferenceCount;     // OK since it is not queued anywhere.
#endif

    //
    // If this is the last I-frame in the window, then indicate that we
    // should checkpoint.  Also checkpoint if the sender is requesting
    // acknowledgement (currently on SendSessionEnd does this).
    // By default, this will also be a command frame.
    //

    if (((SendsOutstanding+1) >= (ULONG)Link->SendWindowSize) ||
            ForceAck) {
        Link->SendState = SEND_STATE_CHECKPOINTING;
        StopTi (Link);
        DlcHeader->RcvSeq |= DLC_I_PF;                  // set the poll bit.
        Poll = TRUE;

    }


    //
    // If we are polling, and the caller cares about it, then
    // we set LinkCheckpoint, and also set up the connection to
    // be waiting for resources. We do this now, before the send,
    // so that even if the ack is receive right away, we will
    // be in a good state. When we return LinkCheckpoint TRUE
    // the caller realizes that he no longer owns the right
    // to "packetize" and exits immediately.
    //
    // We also want to start our retransmission timer so, if this
    // packet gets dropped, we will know to retransmit it. The
    // exception is if LinkCheckpoint was specified, then we
    // only StartT1 of we are not polling (the caller will
    // ensure it is started if he exits before we poll).
    //

    if (ARGUMENT_PRESENT(LinkCheckpoint)) {

        if (Poll) {

            //
            // If the connection still has send state PACKETIZE,
            // then change it to W_LINK. If it is something else
            // (such as W_PACKET or W_ACK) then don't worry, when
            // that condition clears he will repacketize and the
            // link conditions will be re-examined. In all
            // case we turn off the PACKETIZE flag, because when
            // we return with LinkCheckpoint TRUE he will stop
            // packetizing, and to close the window we turn it
            // off now (before the NdisSend) rather than then.
            //

            ASSERT (Connection->LinkSpinLock == &Link->SpinLock);
            if (Connection->SendState == CONNECTION_SENDSTATE_PACKETIZE) {
                Connection->SendState = CONNECTION_SENDSTATE_W_LINK;
            }
            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;

            if (Link->Provider->MacInfo.MediumAsync) {
                Packet->Link = Link;
                NbfReferenceLink ("Send I-frame", Link, LREF_START_T1);
            } else {
                StartT1 (Link, Packet->NdisIFrameLength);
            }
            *LinkCheckpoint = TRUE;

        } else {

            StartT1 (Link, 0);
            *LinkCheckpoint = FALSE;

        }

    } else {

        //
        // If LinkCheckpoint is not true, then we are sending
        // an I-frame other than DFM/DOL. In this case, as
        // an optimization, we'll set W_LINK if a) we are
        // polling b) we are IDLE (to avoid messing up other
        // states such as W_ACK). This will avoid a window
        // where we don't go W_LINK until after the next
        // send tries to packetize and fails.
        //

        if (Poll) {

            ASSERT (Connection->LinkSpinLock == &Link->SpinLock);
            if (Connection->SendState == CONNECTION_SENDSTATE_IDLE) {
                Connection->SendState = CONNECTION_SENDSTATE_W_LINK;
            }

        }

        //
        // This is an optimization; we know that if LinkCheckpoint
        // is present than we are being called from PacketizeSend;
        // in this case the Link will have the LREF_CONNECTION
        // reference and the connection will have the CREF_PACKETIZE
        // reference, so we don't have to reference the link
        // again.
        //

        NbfReferenceLink ("SendOnePacket", Link, LREF_NDIS_SEND);


        //
        // Start the retransmission timer.
        //

        if (Link->Provider->MacInfo.MediumAsync) {
            if (Poll) {
                Packet->Link = Link;
                NbfReferenceLink ("ResendPacket", Link, LREF_START_T1);
            } else {
                StartT1 (Link, 0);
            }
        } else {
            StartT1 (Link, Poll ? Packet->NdisIFrameLength : 0);
        }

    }

    //
    // Since this I-frame contains an N(R), it is potentially ACKing some
    // previously received I-frames as reverse traffic.  So we stop our
    // delayed acknowlegement timer.
    //

    StopT2 (Link);

    if ((Link->Provider->MacInfo.MediumAsync) &&
        (ARGUMENT_PRESENT(LinkCheckpoint)) &&
        (Link->SendWindowSize >= 3) &&
        (!Poll) && (SendsOutstanding == (ULONG)(Link->SendWindowSize-2))) {

        Status = STATUS_MORE_PROCESSING_REQUIRED;

        Connection->Flags |= CONNECTION_FLAGS_PACKETIZE;
        NbfReferenceConnection ("PacketizeConnection TRUE", Connection, CREF_TEMP);
        Packet->PacketizeConnection = TRUE;

    } else {

        Status = STATUS_SUCCESS;
    }

    //
    // Send the packet; no locks held. Note that if the send fails, we will
    // NOT fail upward; we allow things to continue onward. This lets us retry
    // the send multiple times before we give out; additionally, it keeps us
    // from failing obscurely when sending control Iframes.
    //
    // NOTE: NbfNdisSend releases the link spinlock.
    //

    NbfNdisSend (Link, Packet);

    Link->PacketsSent++;

    //
    // Remove the reference made above if needed.
    //

    if (!ARGUMENT_PRESENT(LinkCheckpoint)) {
        NbfDereferenceLink ("SendOnePacket", Link, LREF_NDIS_SEND);
    }

    return Status;

} /* SendOnePacket */


VOID
SendControlPacket(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine sends a connection-oriented packet by calling the Physical
    Provider's Send service.  While SendOnePacket is used to send an I-
    frame, this routine is used to send one of the following: RR, RNR, REJ,
    SABME, UA, DISC, DM, FRMR, TEST, and XID.

    NOTE: This function is called with the link spinlock held,
    and returns with it released. IT MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - Pointer to a TP_PACKET object.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    USHORT i;
    PUCHAR p;
    PNDIS_BUFFER ndisBuffer;

    IF_NBFDBG (NBF_DEBUG_PACKET) {
        NbfPrint3 ("SendControlPacket: Entered for link %lx, packet %lx, NdisPacket %lx\n 00:",
                Link, Packet, Packet->NdisPacket);
        IF_NBFDBG (NBF_DEBUG_PKTCONTENTS) {
            UINT PLength, PCount;
            UINT BLength;
            PVOID BAddr;
            p = Packet->Header;
            for (i=0;i<20;i++) {
                NbfPrint1 (" %2x",p[i]);
            }
            NbfPrint0 ("\n");
            NdisQueryPacket(Packet->NdisPacket, &PCount, NULL, &ndisBuffer, &PLength);
            NbfPrint3 ("Sending Control Packet: %lx, Length: %lx Pages: %lx\n",
                Packet->NdisPacket, PLength, PCount);
            while (ndisBuffer != NULL) {
                NdisQueryBuffer (ndisBuffer, &BAddr, &BLength);
                NbfPrint3 ("Sending Control Packet: Buffer %08lx Length %08lx Va %08lx\n",
                    ndisBuffer, BLength, BAddr);
                NdisGetNextBuffer (ndisBuffer, &ndisBuffer);
            }
        }
    }

    ASSERT (Packet->PacketSent == FALSE);

    NbfReferenceLink ("SendControlPacket", Link, LREF_NDIS_SEND);

    //
    // Send the packet (we have the lock, NbfNdisSend released
    // it.
    //

    NbfNdisSend (Link, Packet);

    NbfDereferenceLink ("SendControlPacket", Link, LREF_NDIS_SEND);

} /* SendControlPacket */


VOID
NbfNdisSend(
    IN PTP_LINK Link,
    IN PTP_PACKET Packet
    )

/*++

Routine Description:

    This routine is used to ensure that receive sequence numbers on
    packets are numbered correctly. It is called in place of NdisSend
    and after assigning the receive sequence number it locks out other
    sends until the NdisSend call has returned (not necessarily completed),
    insuring that the packets with increasing receive sequence numbers
    are queue in the right order by the MAC.

    NOTE: This routine is called with the link spinlock held,
    and it returns with it released. THIS ROUTINE MUST BE CALLED
    AT DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

    Packet - Pointer to a TP_PACKET object.

Return Value:

    None.

--*/

{

    NDIS_STATUS NdisStatus;
    PLIST_ENTRY p;
    PDLC_S_FRAME DlcHeader;
    PNDIS_PACKET TmpNdisPacket;
    ULONG result;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (Link->Provider->UniProcessor) {

        //
        // On a uni-processor, we can send without fear of
        // being interrupted by an incoming packet.
        //

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

        DlcHeader = (PDLC_S_FRAME)&(Packet->Header[Link->HeaderLength]);

        if ((DlcHeader->Command & DLC_U_INDICATOR) != DLC_U_INDICATOR) {

            //
            // It's not a U-frame, so we assign RcvSeq.
            //

            DlcHeader->RcvSeq |= (UCHAR)(Link->NextReceive << 1);

        }

#if DBG
        NbfSendsIssued++;
#endif

        INCREMENT_COUNTER (Link->Provider, PacketsSent);

#if PKT_LOG
        // Log this packet in connection's sent packets' queue
        NbfLogSndPacket(Link, Packet);
#endif // PKT_LOG

        if (Link->Loopback) {

            //
            // This packet is sent to ourselves; we should loop it
            // back.
            //

            NbfInsertInLoopbackQueue(
                Link->Provider,
                Packet->NdisPacket,
                Link->LoopbackDestinationIndex
                );

            NdisStatus = NDIS_STATUS_PENDING;

        } else {

            if (Link->Provider->NdisBindingHandle) {
            
                NdisSend (
                    &NdisStatus,
                    Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket);
            }
            else {
                NdisStatus = STATUS_INVALID_DEVICE_STATE;
            }
        }

        IF_NBFDBG (NBF_DEBUG_SENDENG) {
            NbfPrint1 ("NbfNdisSend: NdisSend completed Status: %s.\n",
                      NbfGetNdisStatus(NdisStatus));
        }

        switch (NdisStatus) {

            case NDIS_STATUS_PENDING:
#if DBG
                NbfSendsPended++;
#endif
                break;

            case NDIS_STATUS_SUCCESS:
#if DBG
                NbfSendsCompletedInline++;
                NbfSendsCompletedOk++;
#endif
                NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket,
                    NDIS_STATUS_SUCCESS);
                break;

            default:
#if DBG
                NbfSendsCompletedInline++;
                NbfSendsCompletedFail++;
#endif
                NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                    Packet->NdisPacket,
                    NDIS_STATUS_SUCCESS);

                IF_NBFDBG (NBF_DEBUG_SENDENG) {
                    NbfPrint1 ("NbfNdisSend failed, status not Pending or Complete: %lx.\n",
                              NbfGetNdisStatus (NdisStatus));
                }
                break;

        }

    } else {

        //
        // If there is a send in progress, then queue this packet
        // and return.
        //

        if (Link->NdisSendsInProgress > 0) {

            p = (PLIST_ENTRY)(Packet->NdisPacket->MacReserved);
            InsertTailList (&Link->NdisSendQueue, p);
            ++Link->NdisSendsInProgress;
            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            return;

        }

        //
        // No send in progress. Set the flag to true, and fill in the
        // receive sequence field in the packet (note that the RcvSeq
        // field is in the same place for I- and S-frames.
        //

        Link->NdisSendsInProgress = 1;

        while (TRUE) {

            DlcHeader = (PDLC_S_FRAME)&(Packet->Header[Link->HeaderLength]);

            if ((DlcHeader->Command & DLC_U_INDICATOR) != DLC_U_INDICATOR) {

                //
                // It's not a U-frame, so we assign RcvSeq.
                //

                DlcHeader->RcvSeq |= (UCHAR)(Link->NextReceive << 1);

            }

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

#if DBG
            NbfSendsIssued++;
#endif

            INCREMENT_COUNTER (Link->Provider, PacketsSent);

#if PKT_LOG
            // Log this packet in connection's sent packets' queue
            NbfLogSndPacket(Link, Packet);
#endif // PKT_LOG

            if (Link->Loopback) {

                //
                // This packet is sent to ourselves; we should loop it
                // back.
                //

                NbfInsertInLoopbackQueue(
                    Link->Provider,
                    Packet->NdisPacket,
                    Link->LoopbackDestinationIndex
                    );

                NdisStatus = NDIS_STATUS_PENDING;

            } else {

                if (Link->Provider->NdisBindingHandle) {
                
                    NdisSend (
                        &NdisStatus,
                        Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket);
                }
                else {
                    NdisStatus = STATUS_INVALID_DEVICE_STATE;
                }
            }

            //
            // Take the ref count down, which may allow others
            // to come through.
            //

            result = ExInterlockedAddUlong(
                         &Link->NdisSendsInProgress,
                         (ULONG)-1,
                         &Link->SpinLock);

            IF_NBFDBG (NBF_DEBUG_SENDENG) {
                NbfPrint1 ("NbfNdisSend: NdisSend completed Status: %s.\n",
                          NbfGetNdisStatus(NdisStatus));
            }

            switch (NdisStatus) {

                case NDIS_STATUS_PENDING:
#if DBG
                    NbfSendsPended++;
#endif
                    break;

                case NDIS_STATUS_SUCCESS:
#if DBG
                    NbfSendsCompletedInline++;
                    NbfSendsCompletedOk++;
#endif
                    NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket,
                        NDIS_STATUS_SUCCESS);
                    break;

                default:
#if DBG
                    NbfSendsCompletedInline++;
                    NbfSendsCompletedFail++;
#endif
                    NbfSendCompletionHandler (Link->Provider->NdisBindingHandle,
                        Packet->NdisPacket,
                        NDIS_STATUS_SUCCESS);

                    IF_NBFDBG (NBF_DEBUG_SENDENG) {
                        NbfPrint1 ("NbfNdisSend failed, status not Pending or Complete: %lx.\n",
                                  NbfGetNdisStatus (NdisStatus));
                    }
                    break;

            }

            //
            // We have now sent a packet, see if any queued up while we
            // were doing it. If the count was zero after removing ours,
            // then anything else queued is being processed, so we can
            // exit.
            //

            if (result == 1) {
                return;
            }

            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

            p = RemoveHeadList(&Link->NdisSendQueue);

            //
            // If the refcount was not zero, then nobody else should
            // have taken packets off since they would have been
            // blocked by us. So, the queue should not be empty.
            //

            ASSERT (p != &Link->NdisSendQueue);

            //
            // Get back the TP_PACKET by using the Frame pointer in the
            // ProtocolReserved field of the NDIS_PACKET.
            //

            TmpNdisPacket = CONTAINING_RECORD (p, NDIS_PACKET, MacReserved[0]);
            Packet = (PTP_PACKET)(((PSEND_PACKET_TAG)(&TmpNdisPacket->ProtocolReserved[0]))->Frame);

        }   // while loop


        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

    }

}   /* NbfNdisSend */


VOID
RestartLinkTraffic(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine continues the activities of the connections on a link.

    NOTE: This function is called with the link spinlock held and
    it returns with it released. THIS FUNCTION MUST BE CALLED AT
    DPC LEVEL.

Arguments:

    Link - Pointer to a TP_LINK object.

Return Value:

    none.

--*/

{
    PTP_CONNECTION connection;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_SENDENG) {
        NbfPrint1 ("RestartLinkTraffic:  Entered for link %lx.\n", Link);
    }

    //
    // Link conditions may have cleared up.  Make all connections on this
    // link eligible for more packetization if they are in W_LINK state.
    //

    for (p = Link->ConnectionDatabase.Flink;
         p != &Link->ConnectionDatabase;
         p = p->Flink) {

        connection = CONTAINING_RECORD (p, TP_CONNECTION, LinkList);

        ASSERT (connection->LinkSpinLock == &Link->SpinLock);

        //
        // If we tried to send a plain-ole data frame DFM/DOL, but
        // link conditions were not satisfactory, then we changed
        // send state to W_LINK.  Check for that now, and possibly
        // start repacketizing.
        //

        if (connection->SendState == CONNECTION_SENDSTATE_W_LINK) {
            if (!(IsListEmpty (&connection->SendQueue))) {

                connection->SendState = CONNECTION_SENDSTATE_PACKETIZE;

                //
                // This is similar to calling StartPacketizingConnection
                // with the Immediate set to FALSE.
                //

                if (!(connection->Flags & CONNECTION_FLAGS_PACKETIZE) &&
                    (connection->Flags & CONNECTION_FLAGS_READY)) {

                    ASSERT (!(connection->Flags2 & CONNECTION_FLAGS2_STOPPING));
                    connection->Flags |= CONNECTION_FLAGS_PACKETIZE;

                    NbfReferenceConnection ("Packetize", connection, CREF_PACKETIZE_QUEUE);

                    ExInterlockedInsertTailList(
                        &connection->Provider->PacketizeQueue,
                        &connection->PacketizeLinkage,
                        &connection->Provider->SpinLock);

                }

            } else {
                connection->SendState = CONNECTION_SENDSTATE_IDLE;
            }
        }

    }

    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

} /* RestartLinkTraffic */


VOID
NbfProcessWanDelayedQueue(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This is the thread routine which restarts packetizing
    that has been delayed on WAN to allow RRs to come in.
    This is very similar to PacketizeConnections.

Arguments:

    Parameter - A pointer to the device context.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    PLIST_ENTRY p;
    PTP_CONNECTION Connection;
    KIRQL oldirql;

    DeviceContext = (PDEVICE_CONTEXT)Parameter;

    //
    // Packetize all waiting connections
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldirql);
    ASSERT (DeviceContext->WanThreadQueued);

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    while (!IsListEmpty(&DeviceContext->PacketizeQueue)) {

        p = RemoveHeadList(&DeviceContext->PacketizeQueue);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, PacketizeLinkage);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        if (Connection->SendState != CONNECTION_SENDSTATE_PACKETIZE) {
            Connection->Flags &= ~CONNECTION_FLAGS_PACKETIZE;
            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
            NbfDereferenceConnection ("No longer packetizing", Connection, CREF_PACKETIZE_QUEUE);
        } else {
            NbfReferenceSendIrp ("Packetize", IoGetCurrentIrpStackLocation(Connection->sp.CurrentSendIrp), RREF_PACKET);
            PacketizeSend (Connection, FALSE);     // releases the lock.
        }

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    }

    DeviceContext->WanThreadQueued = FALSE;

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    KeLowerIrql (oldirql);

}   /* NbfProcessWanDelayedQueue */


NTSTATUS
BuildBufferChainFromMdlChain (
    IN PDEVICE_CONTEXT DeviceContext,
    IN PMDL CurrentMdl,
    IN ULONG ByteOffset,
    IN ULONG DesiredLength,
    OUT PNDIS_BUFFER *Destination,
    OUT PMDL *NewCurrentMdl,
    OUT ULONG *NewByteOffset,
    OUT ULONG *TrueLength
    )

/*++

Routine Description:

    This routine is called to build an NDIS_BUFFER chain from a source Mdl chain and
    offset into it. We assume we don't know the length of the source Mdl chain,
    and we must allocate the NDIS_BUFFERs for the destination chain, which
    we do from the NDIS buffer pool.

    The NDIS_BUFFERs that are returned are mapped and locked. (Actually, the pages in
    them are in the same state as those in the source MDLs.)

    If the system runs out of memory while we are building the destination
    NDIS_BUFFER chain, we completely clean up the built chain and return with
    NewCurrentMdl and NewByteOffset set to the current values of CurrentMdl
    and ByteOffset. TrueLength is set to 0.

Environment:

    Kernel Mode, Source Mdls locked. It is recommended, although not required,
    that the source Mdls be mapped and locked prior to calling this routine.

Arguments:

    BufferPoolHandle - The buffer pool to allocate buffers from.

    CurrentMdl - Points to the start of the Mdl chain from which to draw the
    packet.

    ByteOffset - Offset within this MDL to start the packet at.

    DesiredLength - The number of bytes to insert into the packet.

    Destination - returned pointer to the NDIS_BUFFER chain describing the packet.

    NewCurrentMdl - returned pointer to the Mdl that would be used for the next
        byte of packet. NULL if the source Mdl chain was exhausted.

    NewByteOffset - returned offset into the NewCurrentMdl for the next byte of
        packet. NULL if the source Mdl chain was exhausted.

    TrueLength - The actual length of the returned NDIS_BUFFER Chain. If less than
        DesiredLength, the source Mdl chain was exhausted.

Return Value:

    STATUS_SUCCESS if the build of the returned NDIS_BUFFER chain succeeded (even if
    shorter than the desired chain).

    STATUS_INSUFFICIENT_RESOURCES if we ran out of NDIS_BUFFERs while building the
    destination chain.

--*/
{
    ULONG AvailableBytes;
    PMDL OldMdl;
    PNDIS_BUFFER NewNdisBuffer;
    NDIS_STATUS NdisStatus;

    //

    IF_NBFDBG (NBF_DEBUG_NDIS) {
        NbfPrint3 ("BuildBufferChain: Mdl: %lx Offset: %ld Length: %ld\n",
            CurrentMdl, ByteOffset, DesiredLength);
    }

    AvailableBytes = MmGetMdlByteCount (CurrentMdl) - ByteOffset;
    if (AvailableBytes > DesiredLength) {
        AvailableBytes = DesiredLength;
    }

    OldMdl = CurrentMdl;
    *NewCurrentMdl = OldMdl;
    *NewByteOffset = ByteOffset + AvailableBytes;
    *TrueLength = AvailableBytes;


    //
    // Build the first NDIS_BUFFER, which could conceivably be the only one...
    //

    NdisCopyBuffer(
        &NdisStatus,
        &NewNdisBuffer,
        DeviceContext->NdisBufferPool,
        OldMdl,
        ByteOffset,
        AvailableBytes);

        
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        *NewByteOffset = ByteOffset;
        *TrueLength = 0;
        *Destination = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Destination = NewNdisBuffer;


//    IF_NBFDBG (NBF_DEBUG_SENDENG) {
//        PVOID PAddr, UINT PLen;
//        NdisQueryBuffer (NewNdisBuffer, &PAddr, &PLen);
//        NbfPrint4 ("BuildBufferChain: (start)Built Mdl: %lx Length: %lx, Next: %lx Va: %lx\n",
//            NewNdisBuffer, PLen, NDIS_BUFFER_LINKAGE(NewNdisBuffer), PAddr);
//    }

    //
    // Was the first NDIS_BUFFER enough data, or are we out of Mdls?
    //

    if ((AvailableBytes == DesiredLength) || (OldMdl->Next == NULL)) {
        if (*NewByteOffset >= MmGetMdlByteCount (OldMdl)) {
            *NewCurrentMdl = OldMdl->Next;
            *NewByteOffset = 0;
        }
        return STATUS_SUCCESS;
    }

    //
    // Need more data, so follow the in Mdl chain to create a packet.
    //

    OldMdl = OldMdl->Next;
    *NewCurrentMdl = OldMdl;

    while (OldMdl != NULL) {
        AvailableBytes = DesiredLength - *TrueLength;
        if (AvailableBytes > MmGetMdlByteCount (OldMdl)) {
            AvailableBytes = MmGetMdlByteCount (OldMdl);
        }

        NdisCopyBuffer(
            &NdisStatus,
            &(NDIS_BUFFER_LINKAGE(NewNdisBuffer)),
            DeviceContext->NdisBufferPool,
            OldMdl,
            0,
            AvailableBytes);

        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            //
            // ran out of resources. put back what we've used in this call and
            // return the error.
            //

            while (*Destination != NULL) {
                NewNdisBuffer = NDIS_BUFFER_LINKAGE(*Destination);
                NdisFreeBuffer (*Destination);
                *Destination = NewNdisBuffer;
            }

            *NewByteOffset = ByteOffset;
            *TrueLength = 0;
            *NewCurrentMdl = CurrentMdl;

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NewNdisBuffer = NDIS_BUFFER_LINKAGE(NewNdisBuffer);

        *TrueLength += AvailableBytes;
        *NewByteOffset = AvailableBytes;

//        IF_NBFDBG (NBF_DEBUG_SENDENG) {
//            PVOID PAddr, UINT PLen;
//            NdisQueryBuffer (NewNdisBuffer, &PAddr, &PLen);
//            NbfPrint4 ("BuildBufferChain: (continue) Built Mdl: %lx Length: %lx, Next: %lx Va: %lx\n",
//                NewNdisBuffer, PLen, NDIS_BUFFER_LINKAGE(NewNdisBuffer), PAddr);
//        }

        if (*TrueLength == DesiredLength) {
            if (*NewByteOffset == MmGetMdlByteCount (OldMdl)) {
                *NewCurrentMdl = OldMdl->Next;
                *NewByteOffset = 0;
            }
            return STATUS_SUCCESS;
        }
        OldMdl = OldMdl->Next;
        *NewCurrentMdl = OldMdl;

    } // while (mdl chain exists)

    *NewCurrentMdl = NULL;
    *NewByteOffset = 0;
    return STATUS_SUCCESS;

} // BuildBufferChainFromMdlChain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbeui\sys\testnbf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    testtdi.c

Abstract:

    Kernel Mode test program for any Tdi network provider. This routine is an
    example of how to use the TDI interface at the kernel level.

Author:

    Dave Beaver (DBeaver) 5 June 1991

Revision History:

--*/

#include "nbf.h"
#include <ctype.h>

#define TRANSPORT_NAME L"\\Device\\Nbf"

PSZ ServerName = "DCTDISERVER     ";
PSZ ClientName = "DCTDICLIENT     ";
PSZ  AnyName  =  "*               ";

static PUCHAR TextBuffer;               // dynamically allocated non-paged buffer.
ULONG   c9_Xmt = 0xff;
ULONG   c9_Rcv = 0xff;
ULONG   c9_Iteration = 0xffffffff;

static ULONG TextBufferLength;          // size of the above in bytes.
#define BUFFER_SIZE 0xffff
PUCHAR RBuff;
PUCHAR XBuff;
UCHAR c9_ListBlock[512];
UCHAR c9_ConnBlock[512];

extern KEVENT TdiSendEvent;
extern KEVENT TdiReceiveEvent;
extern KEVENT TdiServerEvent;

ULONG ApcContext;

NTSTATUS
TSTRCVCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    DbgPrint ("TSTRCVCompletion event: %lx\n" , Context);
//    KeSetEvent ((PKEVENT)Context, 0, TRUE);
    return STATUS_MORE_PROCESSING_REQUIRED;
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

#define InitWaitObject(_event)\
    KeInitializeEvent (\
        _event,\
        SynchronizationEvent,\
        FALSE)

VOID
NbfTestTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
TtdiOpenAddress (
    IN PHANDLE FileHandle,
    IN PSZ Name
    );

NTSTATUS
TtdiOpenConnection (
    IN PHANDLE FileHandle,
    IN ULONG ConnectionContext
    );


NTSTATUS
TtdiOpenAddress (
    IN PHANDLE FileHandle,
    IN PSZ Name)
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTDI_ADDRESS_NETBIOS AddressName;
    PTRANSPORT_ADDRESS Address;
    PTA_ADDRESS AddressType;
    int i;

    DbgPrint ("TtdiOpenAddress: Opening ");
    DbgPrint (Name);
    DbgPrint (".\n");
    RtlInitUnicodeString (&NameString, TRANSPORT_NAME);
    InitializeObjectAttributes (
        &ObjectAttributes,
        &NameString,
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePool (NonPagedPool, 100);
    if (EaBuffer == NULL) {
        DbgBreakPoint ();
    }

    EaBuffer->NextEntryOffset =0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = sizeof (TDI_ADDRESS_NETBIOS);

    for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
        EaBuffer->EaName[i] = TdiTransportAddress[i];
    }

    Address = (PTRANSPORT_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
    Address->TAAddressCount = 1;

    AddressType = (PTA_ADDRESS)((PUCHAR)Address + sizeof (Address->TAAddressCount));

    AddressType->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    AddressType->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;

    AddressName = (PTDI_ADDRESS_NETBIOS)((PUCHAR)AddressType +
       sizeof (AddressType->AddressType) + sizeof (AddressType->AddressLength));
    AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    for (i=0;i<16;i++) {
        AddressName->NetbiosName[i] = Name[i];
    }

    Status = IoCreateFile (
                 FileHandle,
                 0, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 FO_SYNCHRONOUS_IO,     // file attributes.
                 0,
                 0,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 (PUCHAR)&AddressName->NetbiosName[i] - (PUCHAR)EaBuffer + 1,                   // ea length
                 CreateFileTypeNone,
                 (PVOID)NULL,
                 0 );                    // EA length.

    if (!NT_SUCCESS( Status )) {
        DbgPrint ("TtdiOpenAddress:  FAILURE, NtCreateFile returned status code=%lC.\n", Status);
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("TtdiOpenAddress:  FAILURE, IoStatusBlock.Status contains status code=%lC.\n", Status);
    }

    DbgPrint ("TtdiOpenAddress:  returning\n");

    return Status;
} /* TtdiOpenAddress */


NTSTATUS
TtdiOpenConnection (IN PHANDLE FileHandle, IN ULONG ConnectionContext)
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    int i;

    DbgPrint ("TtdiOpenConnection: Opening Context %lx...\n ",
        ConnectionContext);
    RtlInitUnicodeString (&NameString, TRANSPORT_NAME);
    InitializeObjectAttributes (
        &ObjectAttributes,
        &NameString,
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePool (NonPagedPool, 100);
    if (EaBuffer == NULL) {
        DbgBreakPoint ();
    }

    EaBuffer->NextEntryOffset =0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (ULONG);
    for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
        EaBuffer->EaName[i] = TdiConnectionContext[i];
    }

    RtlMoveMemory (
        &EaBuffer->EaName[EaBuffer->EaValueLength + 1],
        &ConnectionContext,
        sizeof (PVOID));

    Status = NtCreateFile (
                 FileHandle,
                 0,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 FO_SYNCHRONOUS_IO,     // file attributes.
                 0,
                 0,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 100);                    // EA length.

    if (!NT_SUCCESS( Status )) {
        DbgPrint ("TtdiOpenConnection:  FAILURE, NtCreateFile returned status code=%lC.\n", Status);
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("TtdiOpenConnection:  FAILURE, IoStatusBlock.Status contains status code=%lC.\n", Status);
    }

    DbgPrint ("TtdiOpenConnection:  returning\n");

    return Status;
} /* TtdiOpenEndpoint */

NTSTATUS
CloseAddress (IN HANDLE FileHandle)
{
    NTSTATUS Status;

    Status = NtClose (FileHandle);

    if (!(NT_SUCCESS( Status ))) {
        DbgPrint ("CloseAddress:  FAILURE, NtClose returned status code=%lC.\n", Status);
    } else {
        DbgPrint ("CloseAddress:  NT_SUCCESS.\n");
    }

    return Status;
} /* CloseAddress */


BOOLEAN
TtdiSend()
{
    USHORT i, Iteration, Increment;
    HANDLE RdrHandle, RdrConnectionHandle;
    KEVENT Event1;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL SendMdl, ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PUCHAR SendBuffer;
    ULONG SendBufferLength;
    PIRP Irp;

    Status = KeWaitForSingleObject (&TdiSendEvent, Suspended, KernelMode, FALSE, NULL);

    SendBufferLength = (ULONG)BUFFER_SIZE;
    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Send Test ******\n" );

    XBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (XBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for send buffer exiting\n");
        return FALSE;
    }
    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ClientName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&RdrHandle, AnyName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of client: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    //
    // Open the connection on the transport.
    //

    Status = TtdiOpenConnection (&RdrConnectionHandle, 1);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrConnectionHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &ConnectionObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);


    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    TdiBuildAssociateAddress (Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        RdrHandle);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Associate Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Send Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success AssociateAddress\n");
        }
    }

    //
    // Post a TdiConnect to the client endpoint.
    //

    RequestInformation.RemoteAddress = ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_CONNECT,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildConnect (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        0,
        &RequestInformation,
        &ReturnInformation);

    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Connect: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Send Test:  FAILED Iosb status Connect: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success Connect Iosb\n");
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Send Test:  Connect FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Send Test:  Success Connect Immediate\n");
        }
    }

    DbgPrint( "\n****** Send Test:  SUCCESSFUL TdiConnect:  ******\n");

    //
    // Send/receive 1 or  10 messages.
    //

    SendBuffer =  (PUCHAR)ExAllocatePool (NonPagedPool, SendBufferLength);
    if (SendBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    SendMdl = IoAllocateMdl (SendBuffer, SendBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (SendMdl);

    MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
    if (MessageBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (ReceiveMdl);

    //
    // Cycle the buffer length from 0 up through the maximum for Tdi. after a
    // couple of shots at the full range in one byte steps, increment by ever
    // increasing amounts to get to the max.
    //

    CurrentBufferLength = 0;
    Increment = 1;
    for (Iteration=1; Iteration<(USHORT)c9_Iteration; Iteration++) {
        CurrentBufferLength += Increment;
        if (CurrentBufferLength > MessageBufferLength) {
            CurrentBufferLength = 0;
            Increment = 1;
        }
        if (CurrentBufferLength > 7500) {
            Increment++;
        }
        if ((USHORT)((Iteration / 100) * 100) == Iteration) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
        }
        for (i=0; i<(USHORT)CurrentBufferLength; i++) {
            SendBuffer [i] = (UCHAR)(i + Iteration % 256 );
            MessageBuffer [i] = 0;            // zap this with something.
        }

        //
        // Now issue a send on the client side.
        //

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_SEND,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildSend (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            ReceiveMdl,
            0,
            CurrentBufferLength);

        InitWaitObject (&Event1);

        Status = IoCallDriver (DeviceObject, Irp);

//        IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Send Test:  FAILED Event1 Wait Send: %lC %d ******\n",
                    Status, Iteration );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Send Test:  FAILED Iosb status Send: %lC %d ******\n",
                    Status, Iteration );
                return FALSE;
            } else {
                DbgPrint ("********** Send Test:  Success SendIosb\n");
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Send Test:  Send FAILED  Status: %lC %d ******\n",
                Status, Iteration );
                return FALSE;
            } else {
                DbgPrint ("********** Send Test:  Success Send Immediate\n");
            }
        }

        if (Iosb1.Information != CurrentBufferLength) {
            DbgPrint ("SendTest: Bytes sent <> Send buffer size.\n");
            DbgPrint ("SendTest: BytesToSend=%ld.  BytesSent=%ld.\n",
                      CurrentBufferLength, Iosb1.Information);
        }

    }

    //
    // We're done with this endpoint.  Close it and get out.
    //

    Status = CloseAddress (RdrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on 2nd Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Send Test ******\n" );
    return TRUE;
} /* Send */


BOOLEAN
TtdiReceive()
{
    USHORT i, Iteration, Increment;
    SHORT j,k;
    HANDLE SvrHandle, SvrConnectionHandle;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL SendMdl, ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PUCHAR SendBuffer;
    ULONG SendBufferLength;
    PIRP Irp;
    KEVENT Event1;

    Status = KeWaitForSingleObject (&TdiReceiveEvent, Suspended, KernelMode, FALSE, NULL);

    SendBufferLength = (ULONG)BUFFER_SIZE;
    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Receive Test ******\n" );

    XBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (XBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for send buffer exiting\n");
        return FALSE;
    }
    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ClientName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&SvrHandle, ServerName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Address: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                SvrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Address: %lC ******\n", Status );
        return FALSE;
    }

    Status = TtdiOpenConnection (&SvrConnectionHandle, 2);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                SvrConnectionHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &ConnectionObject,
                NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on open of server Connection: %lC ******\n", Status );
        return FALSE;
    }

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );


    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    DbgPrint ("Build Irp %lx, Handle %lx \n",
            Irp, SvrHandle);

    TdiBuildAssociateAddress (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        SvrHandle);
    InitWaitObject (&Event1);

    {
        PULONG Temp=(PULONG)IoGetNextIrpStackLocation (Irp);
        DbgPrint ("Built IrpSp %lx %lx %lx %lx %lx \n", *(Temp++),  *(Temp++),
            *(Temp++), *(Temp++), *(Temp++));
    }

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Associate Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success AssociateAddress\n");
        }
    }

    RequestInformation.RemoteAddress = ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);

    //
    // Post a TdiListen to the server endpoint.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_LISTEN,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildListen (
        Irp,
        DeviceObject,
        ConnectionObject,
        TSTRCVCompletion,
        &Event1,
        0,
        &RequestInformation,
        &ReturnInformation);
    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Listen: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Listen Iosb status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success Listen IOSB\n");
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
            return FALSE;
        } else {
            DbgPrint ("********** Receive Test:  Success Listen Immediate\n");
        }
    }


    DbgPrint ("\n****** Receive Test: LISTEN just completed! ******\n");

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Irp = TdiBuildInternalDeviceControlIrp (
                TDI_ACCEPT,
                DeviceObject,
                ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildAccept (Irp, DeviceObject, ConnectionObject, NULL, NULL, &RequestInformation, NULL, 0);
    InitWaitObject (&Event1);

    Status = IoCallDriver (DeviceObject, Irp);

//    IoFreeIrp (Irp);

    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Accept: %lC ******\n", Status );
            return FALSE;
        }
        if (!NT_SUCCESS(Iosb1.Status)) {
            DbgPrint( "\n****** Receive Test:  FAILED Accept Iosb status: %lC ******\n", Status );
            return FALSE;
        }

    } else {
        if (!NT_SUCCESS (Status)) {
            DbgPrint( "\n****** Receive Test: Accept FAILED  Status: %lC ******\n", Status );
            return FALSE;
        }
    }

    //
    // We have the connection data now.  Sanity check it.
    //

    DbgPrint ("\n****** Receive Test:  LISTEN completed successfully! ******\n");

    //
    // Receive/receive 1 or  10 messages.
    //

    SendBuffer =  (PUCHAR)ExAllocatePool (NonPagedPool, SendBufferLength);
    if (SendBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    SendMdl = IoAllocateMdl (SendBuffer, SendBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (SendMdl);

    MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
    if (MessageBuffer == NULL) {
        DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
    }
    ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool (ReceiveMdl);

    //
    // Cycle the buffer length from 0 up through the maximum for Tdi. after a
    // couple of shots at the full range in one byte steps, increment by ever
    // increasing amounts to get to the max.
    //

    CurrentBufferLength = 0;
    Increment = 1;
    for (Iteration=1; Iteration<(USHORT)c9_Iteration; Iteration++) {
        CurrentBufferLength += Increment;
        if (CurrentBufferLength > MessageBufferLength) {
            CurrentBufferLength = 0;
            Increment = 1;
        }
        if (CurrentBufferLength > 7500) {
            Increment++;
        }
        if ((USHORT)((Iteration / 100) * 100) == Iteration) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
        }
        for (i=0; i<(USHORT)CurrentBufferLength; i++) {
            SendBuffer [i] = (UCHAR)(i + Iteration % 256 );
            MessageBuffer [i] = 0;            // zap this with something.
        }

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_RECEIVE,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildReceive (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            ReceiveMdl,
            MessageBufferLength);

        InitWaitObject (&Event1);

        Status = IoCallDriver (DeviceObject, Irp);

//        IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Receive: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Receive Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // The receive completed.  Make sure the data is correct.
        //

        if (Iosb1.Information != CurrentBufferLength) {
            DbgPrint ("Iteration #%d Buffer Length: %lx Buffer Start: %x\n",
                Iteration, CurrentBufferLength,Iteration % 256);
            DbgPrint ("ReceiveTest: Bytes received <> bytes sent.\n");
            DbgPrint ("ReceiveTest: BytesToSend=%ld.  BytesReceived=%ld.\n",
                      CurrentBufferLength, Iosb1.Information);
        }

        if (i == (USHORT)CurrentBufferLength) {
//                DbgPrint ("ReceiveTest: Message contains correct data.\n");
        } else {
            DbgPrint ("ReceiveTest: Message data corrupted at offset %lx of %lx.\n", (ULONG)i, (ULONG)SendBufferLength);
            DbgPrint ("ReceiveTest: Data around corrupted location:\n");
            for (j=-4;j<=3;j++) {
                DbgPrint ("%08lx  ", (ULONG) i+j*16);
                for (k=(SHORT)i+(j*(SHORT)16);k<(SHORT)i+((j+(SHORT)1)*(SHORT)16);k++) {
                    DbgPrint ("%02x",MessageBuffer [k]);
                }
                for (k=(SHORT)i+(j*(SHORT)16);k<(SHORT)i+((j+(SHORT)1)*(SHORT)16);k++) {
                    DbgPrint ("%c",MessageBuffer [k]);
                }
                DbgPrint ("\n");
            }
            DbgPrint ("ReceiveTest: End of Corrupt Data.\n");
        }
    }

    //
    // We're done with this endpoint.  Close it and get out.
    //

    Status = CloseAddress (SvrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Receive Test:  FAILED on 1st Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Receive Test ******\n" );
    return TRUE;
} /* Receive */

BOOLEAN
TtdiServer()
{
    USHORT i;
    HANDLE RdrHandle, SrvConnectionHandle;
    KEVENT Event1;
    PFILE_OBJECT AddressObject, ConnectionObject;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PMDL ReceiveMdl;
    IO_STATUS_BLOCK Iosb1;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TDI_CONNECTION_INFORMATION ReturnInformation;
    PTRANSPORT_ADDRESS ListenBlock;
    PTRANSPORT_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PUCHAR MessageBuffer;
    ULONG MessageBufferLength;
    ULONG CurrentBufferLength;
    PIRP Irp;

    Status = KeWaitForSingleObject (&TdiServerEvent, Suspended, KernelMode, FALSE, NULL);

    MessageBufferLength = (ULONG)BUFFER_SIZE;


    DbgPrint( "\n****** Start of Server Test ******\n" );

    RBuff = ExAllocatePool (NonPagedPool, BUFFER_SIZE);
    if (RBuff == (PVOID)NULL) {
        DbgPrint ("Unable to allocate nonpaged pool for receive buffer exiting\n");
        return FALSE;
    }

    ListenBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));
    ConnectBlock = ExAllocatePool (NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS));

    ListenBlock->TAAddressCount = 1;
    ListenBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ListenBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ListenBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = AnyName[i];
    }

    ConnectBlock->TAAddressCount = 1;
    ConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock->Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    for (i=0;i<16;i++) {
        temp->NetbiosName[i] = ServerName[i];
    }

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    Status = TtdiOpenAddress (&RdrHandle, ServerName);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Server Test:  FAILED on open of client: %lC ******\n", Status );
        return FALSE;
    }

    Status = ObReferenceObjectByHandle (
                RdrHandle,
                0L,
                NULL,
                KernelMode,
                (PVOID *) &AddressObject,
                NULL);

    //
    // Now loop forever trying to get a connection from a remote client to
    // this server. We will create connections until we run out of resources,
    // and we will echo the data we are sent back along the same connection.
    // Sends and Receives are always asynchronous, while listens are
    // synchronous.
    //

    while (TRUE) {

        //
        // Open the connection on the transport.
        //

        Status = TtdiOpenConnection (&SrvConnectionHandle, 1);
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Server Test:  FAILED on open of server Connection: %lC ******\n", Status );
            return FALSE;
        }

        Status = ObReferenceObjectByHandle (
                    SrvConnectionHandle,
                    0L,
                    NULL,
                    KernelMode,
                    (PVOID *) &ConnectionObject,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            DbgPrint( "\n****** Server Test:  FAILED on open of server Connection: %lC ******\n", Status );
            return FALSE;
        }

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        DeviceObject = IoGetRelatedDeviceObject( ConnectionObject );

        //
        // Now register the device handler for receives
        //

//        Irp = TdiBuildInternalDeviceControlIrp (
//                    TDI_SET_EVENT_HANDLER,
//                    DeviceObject,
//                    ConnectionObject,
//                    &Event1,
//                    &Iosb1);

//        TdiBuildSetEventHandler (Irp,
//            DeviceObject,
//            ConnectionObject,
//            TSTRCVCompletion,
//            &Event1,
//            TDI_RECEIVE_HANDLER,
//            TdiTestReceiveHandler,
//            ConnectionObject);

//        Status = IoCallDriver (DeviceObject, Irp);

//       if (Status == STATUS_PENDING) {
//            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
//            if (!NT_SUCCESS(Status)) {
//                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Register: %lC ******\n", Status );
//                return FALSE;
//            }
//            if (!NT_SUCCESS(Iosb1.Status)) {
//                DbgPrint( "\n****** Server Test:  FAILED Register Iosb status: %lC ******\n", Status );
//                return FALSE;
//            }
//
//        } else {
//            if (!NT_SUCCESS (Status)) {
//                DbgPrint( "\n****** Server Test:  RegisterHandler FAILED  Status: %lC ******\n", Status );
//                return FALSE;
//            }
//        }

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_ASSOCIATE_ADDRESS,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildAssociateAddress (Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            RdrHandle);

        Status = IoCallDriver (DeviceObject, Irp);

    //    IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Associate: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Associate Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Server Test:  AssociateAddress FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // Post a TdiListen to the server endpoint.
        //

        RequestInformation.RemoteAddress = ListenBlock;
        RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_LISTEN,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildListen (
            Irp,
            DeviceObject,
            ConnectionObject,
            TSTRCVCompletion,
            &Event1,
            0,
            &RequestInformation,
            NULL);

        Status = IoCallDriver (DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Event1 Wait Listen: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Server Test:  FAILED Listen Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Server Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        DbgPrint ("\n****** Server Test: LISTEN just completed! ******\n");

        //
        // accept the connection from the remote
        //

        KeInitializeEvent (
                    &Event1,
                    SynchronizationEvent,
                    FALSE);

        Irp = TdiBuildInternalDeviceControlIrp (
                    TDI_ACCEPT,
                    DeviceObject,
                    ConnectionObject,
                    &Event1,
                    &Iosb1);

        TdiBuildAccept (
            Irp,
            DeviceObject,
            ConnectionObject,
            NULL,
            NULL,
            &RequestInformation,
            NULL,
            0);

        Status = IoCallDriver (DeviceObject, Irp);

    //    IoFreeIrp (Irp);

        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Accept: %lC ******\n", Status );
                return FALSE;
            }
            if (!NT_SUCCESS(Iosb1.Status)) {
                DbgPrint( "\n****** Receive Test:  FAILED Accept Iosb status: %lC ******\n", Status );
                return FALSE;
            }

        } else {
            if (!NT_SUCCESS (Status)) {
                DbgPrint( "\n****** Accept Test: Listen FAILED  Status: %lC ******\n", Status );
                return FALSE;
            }
        }

        //
        // Get a buffer for the continued read/write loop.
        //

        MessageBuffer=(PUCHAR)ExAllocatePool (NonPagedPool, MessageBufferLength);
        if (MessageBuffer == NULL) {
            DbgPrint ("\n****** Send Test:  ExAllocatePool failed! ******\n");
        }
        ReceiveMdl = IoAllocateMdl (MessageBuffer, MessageBufferLength, FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool (ReceiveMdl);

        //
        // have a receive buffer, and a connection; go ahead and read and write
        // until the remote disconnects.
        //

        while (TRUE) {

            KeInitializeEvent (
                        &Event1,
                        SynchronizationEvent,
                        FALSE);

            Irp = TdiBuildInternalDeviceControlIrp (
                        TDI_RECEIVE,
                        DeviceObject,
                        ConnectionObject,
                        &Event1,
                        &Iosb1);

            TdiBuildReceive (Irp,
                DeviceObject,
                ConnectionObject,
                TSTRCVCompletion,
                &Event1,
                ReceiveMdl,
                MessageBufferLength);

            InitWaitObject (&Event1);

            Status = IoCallDriver (DeviceObject, Irp);

            if (Status == STATUS_PENDING) {
                Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Receive: %lC ******\n", Status );
                    return FALSE;
                }
                if (!NT_SUCCESS(Iosb1.Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Receive Iosb status: %lC ******\n", Status );
                    return FALSE;
                }

            } else {
                if (!NT_SUCCESS (Status)) {

                    //
                    // Check to see if the remote has disconnected, which is
                    // the only reason for us shutting down/
                    //

                    if (Status == STATUS_REMOTE_DISCONNECT) {

                        //
                        // We've been disconnected from; get out
                        //

                        NtClose (SrvConnectionHandle);
                        break;
                    }

                    DbgPrint( "\n****** Receive Test: Listen FAILED  Status: %lC ******\n", Status );
                    return FALSE;
                } else {

                    //
                    // successful return, what length is the data?
                    //

                    CurrentBufferLength = Iosb1.Information;
                }
            }

            //
            // send the data back
            //

            KeInitializeEvent (
                        &Event1,
                        SynchronizationEvent,
                        FALSE);

            Irp = TdiBuildInternalDeviceControlIrp (
                        TDI_SEND,
                        DeviceObject,
                        ConnectionObject,
                        &Event1,
                        &Iosb1);

            TdiBuildSend (Irp,
                DeviceObject,
                ConnectionObject,
                TSTRCVCompletion,
                &Event1,
                ReceiveMdl,
                0,
                CurrentBufferLength);

            Status = IoCallDriver (DeviceObject, Irp);

            if (Status == STATUS_PENDING) {
                Status = KeWaitForSingleObject (&Event1, Suspended, KernelMode, TRUE, NULL);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Event1 Wait Send: %lC ******\n", Status );
                    return FALSE;
                }
                if (!NT_SUCCESS(Iosb1.Status)) {
                    DbgPrint( "\n****** Receive Test:  FAILED Send Iosb status: %lC ******\n", Status );
                    return FALSE;
                }

            } else {
                if (!NT_SUCCESS (Status)) {

                    DbgPrint( "\n****** Receive Test: Send FAILED  Status: %lC ******\n", Status );
                    NtClose (SrvConnectionHandle);
                    break;

                }
            }
        } // end of receive/send while

        IoFreeMdl (ReceiveMdl);
        ExFreePool (MessageBuffer);

    }

    //
    // We're done with this address.  Close it and get out.
    //

    Status = CloseAddress (RdrHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrint( "\n****** Send Test:  FAILED on 2nd Close: %lC ******\n", Status );
        return FALSE;
    }

    DbgPrint( "\n****** End of Send Test ******\n" );
    return TRUE;
} /* Server */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbeui\sys\testtdi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tstrcv.c

Abstract:

    start receive side tests utility

Author:

    Dave Beaver (dbeaver) 24-Mar-1991

Revision History:

--*/

//
// download a ub board
//

typedef unsigned char	uchar_t;

#include <assert.h>
#include	<stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
//#include <windows.h>
#include <nbf.h>

#define TDIDEV	"\\Device\\Nbf"
char		Tdidevice[]	= TDIDEV;	/* default device */
char		*Tdidev	= Tdidevice;

HANDLE FileHandle;

VOID
usage(
    VOID
    );


NTSTATUS
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    STRING NameString;
    UNICODE_STRING unicodeString;
    PUCHAR buffer;
    ULONG IoControlCode;
    int n;
    CHAR c;

    for( n = 1; n < argc && argv[n][0] == '-' ; ++n ) {
        c = argv[n][1];

        switch( c )	{

        case 's':   // send test
            IoControlCode = IOCTL_TDI_SEND_TEST;
            break;

        case 'r':   // receive test
            IoControlCode = IOCTL_TDI_RECEIVE_TEST;

            break;

        case 'b':	/* both test */
            IoControlCode = IOCTL_TDI_SERVER_TEST;

        	   break;

        default:
        	   usage ();
        	   break;

        }
    }

    printf ("Opening TDI device: %s \n", Tdidev);
    RtlInitString (&NameString, Tdidev);
    Status = RtlAnsiStringToUnicodeString(
                 &unicodeString,
                 &NameString,
                 TRUE);

    buffer = (PUCHAR)malloc (100);

    Status = TdiOpenNetbiosAddress (&FileHandle, buffer, (PVOID)&NameString, NULL);

    RtlFreeUnicodeString(&unicodeString);
    free (buffer);

    if (!NT_SUCCESS( Status )) {
        printf ("FAILURE, Unable to open TDI driver %s, status: %lx.\n",
            Tdidev,Status);
        return (Status);
    }

    if (!(NT_SUCCESS( IoStatusBlock.Status ))) {
        printf ("FAILURE, Unable to open TDI driver %s, IoStatusBlock.Status: %lx.\n",
                Tdidev, IoStatusBlock.Status);
        return (IoStatusBlock.Status);
    }

    //
    // start the test
    //

    printf("Starting test.... ");
    Status = NtDeviceIoControlFile(
                  FileHandle,
                  NULL,
                  NULL,
                  NULL,
                  &IoStatusBlock,
                  IoControlCode,
                  NULL,
                  0,
                  NULL,
                  0);

    if (!NT_SUCCESS( Status )) {
         printf ("FAILURE, Unable to start test: %lx.\n", Status);
         return (Status);
    }

    if (!(NT_SUCCESS( IoStatusBlock.Status ))) {
         printf ("FAILURE, Unable to start test: %lx.\n", IoStatusBlock.Status);
         return (IoStatusBlock.Status);
    }

    NtClose (FileHandle);

    return STATUS_SUCCESS;

}


NTSTATUS
TdiOpenNetbiosAddress (
    IN OUT PHANDLE FileHandle,
    IN PUCHAR Buffer,
    IN PVOID DeviceName,
    IN PVOID Address)

/*++

Routine Description:

   Opens an address on the given file handle and device.

Arguments:

    FileHandle - the returned handle to the file object that is opened.

    Buffer - pointer to a buffer that the ea is to be built in. This buffer
        must be at least 40 bytes long.

    DeviceName - the Unicode string that points to the device object.

    Name - the address to be registered. If this pointer is NULL, the routine
        will attempt to open a "control channel" to the device; that is, it
        will attempt to open the file object with a null ea pointer, and if the
        transport provider allows for that, will return that handle.

Return Value:

    An informative error code if something goes wrong. STATUS_SUCCESS if the
    returned file handle is valid.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTRANSPORT_ADDRESS TAAddress;
    PTA_ADDRESS AddressType;
    PTDI_ADDRESS_NETBIOS AddressName;
    PSZ Name;
    ULONG Length;
    int i;

    if (Address != NULL) {
        Name = (PSZ)Address;
        try {
            Length = sizeof (FILE_FULL_EA_INFORMATION) +
                            sizeof (TRANSPORT_ADDRESS) +
                            sizeof (TDI_ADDRESS_NETBIOS);
            EaBuffer = (PFILE_FULL_EA_INFORMATION)Buffer;

            if (EaBuffer == NULL) {
                return STATUS_UNSUCCESSFUL;
            }

            EaBuffer->NextEntryOffset =0;
            EaBuffer->Flags = 0;
            EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
            EaBuffer->EaValueLength = sizeof (TDI_ADDRESS_NETBIOS) +
                                            sizeof (TRANSPORT_ADDRESS);

            for (i=0;i<(int)EaBuffer->EaNameLength;i++) {
                EaBuffer->EaName[i] = TdiTransportAddress[i];
            }

            TAAddress = (PTRANSPORT_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
            TAAddress->TAAddressCount = 1;

            AddressType = (PTA_ADDRESS)((PUCHAR)TAAddress + sizeof (TAAddress->TAAddressCount));

            AddressType->AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            AddressType->AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;

            AddressName = (PTDI_ADDRESS_NETBIOS)((PUCHAR)AddressType +
               sizeof (AddressType->AddressType) + sizeof (AddressType->AddressLength));
            AddressName->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

            for (i=0;i<16;i++) {
                AddressName->NetbiosName[i] = Name[i];
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Couldn't touch the passed parameters; just return an error
            // status.
            //

            return GetExceptionCode();
        }
    } else {
        EaBuffer = NULL;
        Length = 0;
    }

    InitializeObjectAttributes (
        &ObjectAttributes,
        DeviceName,
        0,
        NULL,
        NULL);

    Status = NtCreateFile (
                 FileHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 0,                     // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access.
                 FILE_CREATE,           // create disposition.
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 Length);                    // EA length.

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
    }

    return Status;
} /* TdiOpenNetbiosAddress */

VOID
usage(
    VOID
    )
{
	printf( "usage:  tsttdi [-r] [-s] -[b]\n");
	printf( "usage:  -r run receive test.\n" );
	printf( "usage:  -b run server test.\n" );
	printf( "usage:  -s run send test.\n" );
	printf( "\n" );
	exit( 1 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbeui\sys\timer.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code that implements the lightweight timer system
    for the NBF protocol provider.  This is not a general-purpose timer system;
    rather, it is specific to servicing LLC (802.2) links with three timers
    each.

    Services are provided in macro form (see NBFPROCS.H) to start and stop
    timers.  This module contains the code that gets control when the timer
    in the device context expires as a result of calling kernel services.
    The routine scans the device context's link database, looking for timers
    that have expired, and for those that have expired, their expiration
    routines are executed.

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

ULONG StartTimer = 0;
ULONG StartTimerSet = 0;
ULONG StartTimerT1 = 0;
ULONG StartTimerT2 = 0;
ULONG StartTimerDelayedAck = 0;
ULONG StartTimerLinkDeferredAdd = 0;
ULONG StartTimerLinkDeferredDelete = 0;


#if DBG
extern ULONG NbfDebugPiggybackAcks;
ULONG NbfDebugShortTimer = 0;
#endif

#if DBG
//
// These are temp, to track how the timers are working
//
ULONG TimerInsertsAtEnd = 0;
ULONG TimerInsertsEmpty = 0;
ULONG TimerInsertsInMiddle = 0;
#endif

//
// These are constants calculated by InitializeTimerSystem
// to be the indicated amound divided by the tick increment.
//

ULONG NbfTickIncrement = 0;
ULONG NbfTwentyMillisecondsTicks = 0;
ULONG NbfShortTimerDeltaTicks = 0;
ULONG NbfMaximumIntervalTicks = 0;     // usually 60 seconds in ticks

LARGE_INTEGER DueTimeDelta = { (ULONG)(-SHORT_TIMER_DELTA), -1 };

VOID
ExpireT2Timer(
    PTP_LINK Link
    );

VOID
StopStalledConnections(
    IN PDEVICE_CONTEXT DeviceContext
    );


ULONG
GetTimerInterval(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    GetTimerInterval returns the difference in time between the
    current time and Link->CurrentTimerStart (in ticks).
    We limit the interval to 60 seconds. A value of 0 may
    be returned which should be interpreted as 1/2.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    The interval.

--*/

{

    LARGE_INTEGER CurrentTick;
    LARGE_INTEGER Interval;


    //
    // Determine the current tick; the start tick has been saved
    // in Link->CurrentTimerStart.
    //

    KeQueryTickCount (&CurrentTick);

    //
    // Determine the difference between now and then.
    //

    Interval.QuadPart = CurrentTick.QuadPart -
	                        (Link->CurrentTimerStart).QuadPart;

    //
    // If the gap is too big, return 1 minute.
    //

    if (Interval.HighPart != 0 || (Interval.LowPart > NbfMaximumIntervalTicks)) {
        return NbfMaximumIntervalTicks;
    }

    return Interval.LowPart;

}   /* GetTimerInterval */


VOID
BackoffCurrentT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called if T1 expires and we are about to
    retransmit a poll frame. It backs off CurrentT1Timeout,
    up to a limit of 10 seconds.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //
    // do we need spinlock guarding for MP ?
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    ++Link->CurrentPollRetransmits;

    //
    // T1 backs off 1.5 times each time.
    //

    Link->CurrentT1Timeout += (Link->CurrentT1Timeout >> 1);

    //
    // Limit T1 to 10 seconds.
    //

    if (Link->CurrentT1Timeout > ((10 * SECONDS) / SHORT_TIMER_DELTA)) {
        Link->CurrentT1Timeout = (10 * SECONDS) / SHORT_TIMER_DELTA;
    }

}   /* BackoffCurrentT1Timeout */


VOID
UpdateBaseT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a response to a poll frame is
    received. StartT1 will have been called when the frame is
    sent. The routine updates the link's T1 timeout as well
    as delay and throughput.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{
    ULONG Delay;
    ULONG ShiftedTicksDelay;

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    Delay = GetTimerInterval (Link);

    if (Link->CurrentPollRetransmits == 0) {

        //
        // Convert the delay into NBF ticks, shifted by
        // DLC_TIMER_ACCURACY and also multiplied by 4.
        // We want to divide by SHORT_TIMER_DELTA, then
        // shift left by DLC_TIMER_ACCURACY+2. We divide
        // by NbfShortTimerDeltaTicks because the Delay
        // is returned in ticks.
        //
        // We treat a delay of 0 as 1/2, so we use 1
        // shifted left by (DLC_TIMER_ACCURACY+1).
        //

        if (Delay == 0) {

            ShiftedTicksDelay = (1 << (DLC_TIMER_ACCURACY + 1)) /
                                  NbfShortTimerDeltaTicks;

        } else {

            ShiftedTicksDelay = (Delay << (DLC_TIMER_ACCURACY + 2)) /
                                  NbfShortTimerDeltaTicks;

        }


        //
        // Use the timing information to update BaseT1Timeout,
        // if the last frame sent was large enough to matter
        // (we use half of the max frame size here). This is
        // so we don't shrink the timeout too much after sending
        // a short frame. However, we update even for small frames
        // if the last time we sent a poll we had to retransmit
        // it, since that means T1 is much too small and we should
        // increase it as much as we can. We also update for any
        // size frame if the new delay is bigger than the current
        // value, so we can ramp up quickly if needed.
        //

        if (ShiftedTicksDelay > Link->BaseT1Timeout) {

            //
            // If our new delay is more, than we weight it evenly
            // with the previous value.
            //

            Link->BaseT1Timeout = (Link->BaseT1Timeout +
                                   ShiftedTicksDelay) / 2;

        } else if (Link->CurrentT1Backoff) {

                //
                // If we got a retransmit last time, then weight
                // the new timer more heavily than usual.
                //

                Link->BaseT1Timeout = ((Link->BaseT1Timeout * 3) +
                                      ShiftedTicksDelay) / 4;

        } else if (Link->CurrentPollSize >= Link->BaseT1RecalcThreshhold) {

                //
                // Normally, the new timeout is 7/8 the previous value and
                // 1/8 the newly observed delay.
                //

                Link->BaseT1Timeout = ((Link->BaseT1Timeout * 7) +
                                      ShiftedTicksDelay) / 8;

        }

        //
        // Restrict the real timeout to a minimum based on
        // the link speed (always >= 400 ms).
        //

        if (Link->BaseT1Timeout < Link->MinimumBaseT1Timeout) {

            Link->BaseT1Timeout = Link->MinimumBaseT1Timeout;

        }


        //
        // Update link delay and throughput also. Remember
        // that a delay of 0 should be interpreted as 1/2.
        //

        UpdateDelayAndThroughput(
            Link,
            (Delay == 0) ?
                (NbfTickIncrement / 2) :
                (Delay * NbfTickIncrement));


        //
        // We had no retransmits last time, so go back to current base.
        //

        Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

        Link->CurrentT1Backoff = FALSE;

    } else {

        Link->CurrentT1Backoff = TRUE;

        if (!(Link->ThroughputAccurate)) {

            //
            // If we are just starting up, we have to update the
            // throughput even on a retransmit, so we get *some*
            // value there.
            //

            UpdateDelayAndThroughput(
                Link,
                (Delay == 0) ?
                    (NbfTickIncrement / 2) :
                    (Delay * NbfTickIncrement));

        }

    }

}   /* UpdateBaseT1Timeout */


VOID
CancelT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when we have not received any
    responses to a poll frame and are giving up rather
    than retransmitting.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/

{

    //
    // We must have previously sent a poll frame if we are
    // calling this.
    //
    // do we need spinlock guarding for MP ?
    //

    if (!Link->CurrentPollOutstanding) {
        return;
    }

    //
    // We are stopping a polling condition, so reset T1.
    //

    Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

    Link->CurrentT1Backoff = FALSE;

    //
    // Again, this isn't safe on MP (or UP, maybe).
    //

    Link->CurrentPollOutstanding = FALSE;

}   /* CancelT1Timeout */


VOID
UpdateDelayAndThroughput(
    IN PTP_LINK Link,
    IN ULONG TimerInterval
    )

/*++

Routine Description:

    This routine is called when a response packet used to time
    link delay has been received. It is assumed that StartT1
    or FakeStartT1 was called when the initial packet was sent.

    NOTE: For now, we also calculate throughput based on this.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

    TimerInterval - The link delay measured.

Return Value:

    None.

--*/

{

    ULONG PacketSize;


    if (Link->Delay == 0xffffffff) {

        //
        // If delay is unknown, use this.
        //

        Link->Delay = TimerInterval;

    } else if (Link->CurrentPollSize <= 64) {

        //
        // Otherwise, for small frames calculate the new
        // delay by averaging with the old one.
        //

        Link->Delay = (Link->Delay + TimerInterval) / 2;

    }


    //
    // Calculate the packet size times the number of time units
    // in 10 milliseconds, which will allow us to calculate
    // throughput in bytes/10ms (we later multiply by 100
    // to obtain the real throughput in bytes/s).
    //
    // Given the size of MILLISECONDS, this allows packets of up
    // to ~20K, so for bigger packets we just assume that (since
    // throughput won't be an issue there).
    //

    if (Link->CurrentPollSize > 20000) {
        PacketSize = 20000 * (10 * MILLISECONDS);
    } else {
        PacketSize = Link->CurrentPollSize * (10*MILLISECONDS);
    }

    //
    // If throughput is not accurate, then we will use this
    // packet only to calculate it. To avoid being confused
    // by very small packets, assume a minimum size of 64.
    //

    if ((!Link->ThroughputAccurate) && (PacketSize < (64*(10*MILLISECONDS)))) {
        PacketSize = 64 * (10*MILLISECONDS);
    }

    //
    // PacketSize is going to be divided by TimerInterval;
    // to prevent a zero throughput, we boost it up if needed.
    //

    if (PacketSize < TimerInterval) {
        PacketSize = TimerInterval;
    }


    if (Link->CurrentPollSize >= 512) {

        //
        // Calculate throughput here by removing the established delay
        // from the time.
        //

        if ((Link->Delay + (2*MILLISECONDS)) < TimerInterval) {

            //
            // If the current delay is less than the new timer
            // interval (plus 2 ms), then subtract it off for a
            // more accurate throughput calculation.
            //

            TimerInterval -= Link->Delay;

        }

        //
        // We assume by this point (sending a > 512-byte frame) we
        // already have something established as Link->Throughput.
        //

        if (!(Link->ThroughputAccurate)) {

            Link->Throughput.QuadPart =
                                UInt32x32To64((PacketSize / TimerInterval), 100);

            Link->ThroughputAccurate = TRUE;

#if 0
            NbfPrint2 ("INT: %ld.%1.1d us\n",
                TimerInterval / 10, TimerInterval % 10);
            NbfPrint4 ("D: %ld.%1.1d us  T: %ld  (%d)/s\n",
                Link->Delay / 10, Link->Delay % 10,
                Link->Throughput.LowPart, Link->CurrentPollSize);
#endif

        } else {

            LARGE_INTEGER TwiceThroughput;

            //
            // New throughput is the average of the old throughput, and
            // the current packet size divided by the delay just observed.
            // First we calculate the sum, then we shift right by one.
            //

            TwiceThroughput.QuadPart = Link->Throughput.QuadPart +
                                UInt32x32To64((PacketSize / TimerInterval), 100);

            Link->Throughput.QuadPart = TwiceThroughput.QuadPart >> 1;
        }

    } else if (!(Link->ThroughputAccurate)) {

        //
        // We don't have accurate throughput, so just get an estimate
        // by ignoring the delay on this small frame.
        //

        Link->Throughput.QuadPart =
                            UInt32x32To64((PacketSize / TimerInterval), 100);

    }

}   /* UpdateDelayAndThroughput */


VOID
FakeStartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    )

/*++

Routine Description:

    This routine is called before sending a packet that will be used
    to time link delay, but where StartT1 will not be started.
    It is assumed that FakeUpdateBaseT1Timeout will be called
    when the response is received. This is used for timing
    frames that have a known immediate response, but are not
    poll frames.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

    PacketSize - The size of the packet that was just sent.

Return Value:

    None.

--*/

{

    Link->CurrentPollSize = PacketSize;
    KeQueryTickCount(&Link->CurrentTimerStart);

}   /* FakeStartT1 */


VOID
FakeUpdateBaseT1Timeout(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a response to a frame is
    received, and we called FakeStartT1 when the initial
    frame was sent. This is used for timing frames that have
    a known immediate response, but are not poll frames.

    NOTE: This routine should be called with the link spinlock
    held.

Arguments:

    Link - Pointer to a transport link object.

Return Value:

    None.

--*/


{
    ULONG Delay;

    Delay = GetTimerInterval (Link);

    //
    // Convert the delay into NBF ticks, shifted by
    // DLC_TIMER_ACCURACY and also multiplied by 4.
    // We want to divide by SHORT_TIMER_DELTA, then
    // shift left by DLC_TIMER_ACCURACY+2. We divide
    // by NbfShortTimerDeltaTicks because the Delay
    // is returned in ticks. We treat a Delay of 0
    // as 1/2 and calculate ((1/2) << x) as (1 << (x-1)).
    //
    // This timeout is treated as the correct value.
    //

    if (Delay == 0) {

        Link->BaseT1Timeout = (1 << (DLC_TIMER_ACCURACY + 1)) /
                                 NbfShortTimerDeltaTicks;

    } else {

        Link->BaseT1Timeout = (Delay << (DLC_TIMER_ACCURACY + 2)) /
                                 NbfShortTimerDeltaTicks;

    }

    //
    // Restrict the real timeout to a minimum based on
    // the link speed (always >= 400 ms).
    //

    if (Link->BaseT1Timeout < Link->MinimumBaseT1Timeout) {
        Link->BaseT1Timeout = Link->MinimumBaseT1Timeout;
    }

    Link->CurrentT1Timeout = Link->BaseT1Timeout >> DLC_TIMER_ACCURACY;

    //
    // Update link delay and throughput also.
    //

    UpdateDelayAndThroughput(
        Link,
        (Delay == 0) ?
            (NbfTickIncrement / 2) :
            (Delay * NbfTickIncrement));

}   /* FakeUpdateBaseT1Timeout */


VOID
StartT1(
    IN PTP_LINK Link,
    IN ULONG PacketSize
    )

/*++

Routine Description:

    This routine starts the T1 timer for the given link. If the link was
    already on the list, it is moved to the tail. If not, it is inserted at
    tail.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

    PollPacketSize - If a poll packet was just sent it is its size;
        otherwise this will be 0 (when non-poll I-frames are sent).

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;

    if (PacketSize > 0) {

        //
        // If we are sending an initial poll frame, then do timing stuff.
        //

        Link->CurrentPollRetransmits = 0;
        Link->CurrentPollSize = PacketSize;
        Link->CurrentPollOutstanding = TRUE;
        KeQueryTickCount(&Link->CurrentTimerStart);

    } else {

        Link->CurrentPollOutstanding = FALSE;

    }


    //
    // Insert us in the queue if we aren't in it.
    //

    Link->T1 = DeviceContext->ShortAbsoluteTime+Link->CurrentT1Timeout;

    if (!Link->OnShortList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnShortList) {
            Link->OnShortList = TRUE;
            InsertTailList (&DeviceContext->ShortList, &Link->ShortList);
        }

        if (!DeviceContext->a.i.ShortListActive) {

            StartTimerT1++;
            NbfStartShortTimer (DeviceContext);
            DeviceContext->a.i.ShortListActive = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }

}


VOID
StartT2(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine adds the given link to the T2 queue and starts the timer.
    If the link is already on the queue, it is moved to the queue end.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;


    if (DeviceContext->MacInfo.MediumAsync) {

        //
        // On an async line, expire it as soon as possible.
        //

        Link->T2 = DeviceContext->ShortAbsoluteTime;

    } else {

        Link->T2 = DeviceContext->ShortAbsoluteTime+Link->T2Timeout;

    }


    if (!Link->OnShortList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnShortList) {
            Link->OnShortList = TRUE;
            InsertTailList (&DeviceContext->ShortList, &Link->ShortList);
        }

        if (!DeviceContext->a.i.ShortListActive) {

            StartTimerT2++;
            NbfStartShortTimer (DeviceContext);
            DeviceContext->a.i.ShortListActive = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }

}


VOID
StartTi(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine adds the given link to the Ti queue and starts the timer.
    As above, if the link is already on the queue it is moved to the queue end.

    NOTE: THIS ROUTINE MUST BE CALLED AT DPC LEVEL.

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    PDEVICE_CONTEXT DeviceContext = Link->Provider;


    //
    // On an easily disconnected link, with only server connections
    // on this link, we set a long Ti timeout, and when it
    // expires with no activity we start checkpointing, otherwise
    // we assume things are OK.
    //

    if (DeviceContext->EasilyDisconnected && Link->NumberOfConnectors == 0) {
        Link->Ti = DeviceContext->LongAbsoluteTime + (2 * Link->TiTimeout);
        Link->TiStartPacketsReceived = Link->PacketsReceived;
    } else {
        Link->Ti = DeviceContext->LongAbsoluteTime+Link->TiTimeout;
    }


    if (!Link->OnLongList) {

        ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        if (!Link->OnLongList) {
            Link->OnLongList = TRUE;
            InsertTailList (&DeviceContext->LongList, &Link->LongList);
        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
    }


}

#if DBG

VOID
StopT1(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    //
    // Again, this isn't safe on MP (or UP, maybe).
    //

    Link->CurrentPollOutstanding = FALSE;
    Link->T1 = 0;

}


VOID
StopT2(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    Link->ConsecutiveIFrames = 0;
    Link->T2 = 0;

}


VOID
StopTi(
    IN PTP_LINK Link
    )

/*++

Routine Description:

    This routine

Arguments:

    Link - pointer to the link of interest.

Return Value:

    None.

--*/

{
    Link->Ti = 0;
}
#endif


VOID
ExpireT1Timer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's T1 timer expires.  T1 is the
    retransmission timer, and is used to remember that a response is
    expected to any of the following:  (1) a checkpoint, (2) a transmitted
    I-frame, (3) a SABME, or (4) a DISC.  Cases 3 and 4 are actually
    special forms of a checkpoint, since they are sent by this protocol
    implementation with the poll bit set, effectively making them a
    checkpoint sequence.

Arguments:

    Link - Pointer to the TP_LINK object whose T1 timer has expired.

Return Value:

    none.

--*/

{
    PDLC_I_FRAME DlcHeader;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireT1Timer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    switch (Link->State) {

        case LINK_STATE_ADM:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: State=ADM, timeout not expected.\n");
            }
            break;

        case LINK_STATE_READY:

            //
            // We've sent an I-frame and haven't received an acknowlegement
            // yet, or we are checkpointing, and must retry the checkpoint.
            // Another possibility is that we're rejecting, and he hasn't
            // sent anything yet.
            //

            switch (Link->SendState) {

                case SEND_STATE_DOWN:

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link READY but SendState=DOWN.\n");
                    }
                    break;

                case SEND_STATE_READY:

                    //
                    // We sent an I-frame and didn't get an acknowlegement.
                    // Initiate a checkpoint sequence.
                    //

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        {PTP_PACKET packet;
                        PLIST_ENTRY p;
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=READY .\n");
                        NbfDumpLinkInfo (Link);
                        p=Link->WackQ.Flink;
                        NbfPrint0 ("ExpireT1Timer: Link WackQ entries:\n");
                        while (p != &Link->WackQ) {
                            packet = CONTAINING_RECORD (p, TP_PACKET, Linkage);
                            DlcHeader = (PDLC_I_FRAME)&(packet->Header[Link->HeaderLength]);
                            NbfPrint2 ("                 %08lx  %03d\n", p,
                                (DlcHeader->SendSeq >> 1));
                            p = p->Flink;
                        }}
                    }

                    Link->SendRetries = (UCHAR)Link->LlcRetries;
                    Link->SendState = SEND_STATE_CHECKPOINTING;
                    // Don't BackoffT1Timeout yet.
                    NbfSendRr (Link, TRUE, TRUE);// send RR-c/p, StartT1, release lock
                    break;

                case SEND_STATE_REJECTING:

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=REJECTING.\n");
                        NbfPrint0 ("so what do we do here?  consult the manual...\n");
                    }
                    Link->SendState = SEND_STATE_CHECKPOINTING;
//                    Link->SendRetries = Link->LlcRetries;
//                    break;  // DGB: doing nothing is obviously wrong, we've
//                            // gotten a T1 expiration during resend. Try
//                            // an RR to say hey.

                case SEND_STATE_CHECKPOINTING:

                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint0 ("ExpireT1Timer: Link State=READY, SendState=CHECKPOINTING.\n");
                        NbfDumpLinkInfo (Link);
                    }
                    if (--Link->SendRetries == 0) {

                        //
                        // We have not gotten any response to RR-p packets,
                        // initiate orderly link teardown.
                        //

                        CancelT1Timeout (Link);      // we are stopping a polling state

                        Link->State = LINK_STATE_W_DISC_RSP;        // we are awaiting a DISC/f.
                        Link->SendState = SEND_STATE_DOWN;
                        Link->ReceiveState = RECEIVE_STATE_DOWN;
                        Link->SendRetries = (UCHAR)Link->LlcRetries;

                        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

                        NbfStopLink (Link);

                        StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
                        NbfSendDisc (Link, TRUE);  // send DISC-c/p.

#if DBG
                        if (NbfDisconnectDebug) {
                            NbfPrint0( "ExpireT1Timer sending DISC (checkpoint failed)\n" );
                        }
#endif
                    } else {

                        BackoffCurrentT1Timeout (Link);
                        NbfSendRr (Link, TRUE, TRUE); // send RR-c/p, StartT1, release lock.

                    }
                    break;

                default:

                    RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                    IF_NBFDBG (NBF_DEBUG_TIMER) {
                        NbfPrint1 ("ExpireT1Timer: Link State=READY, SendState=%ld (UNKNOWN).\n",
                                  Link->SendState);
                    }
            }
            break;

        case LINK_STATE_CONNECTING:

            //
            // We sent a SABME-c/p and have not yet received UA-r/f.  This
            // means we must decrement the retry count and if it is not yet
            // zero, we issue another SABME command, because he has probably
            // dropped our first one.
            //

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);    // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no response to SABME)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in CONNECTING mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.
            } else {
                BackoffCurrentT1Timeout (Link);
                NbfSendSabme (Link, TRUE);  // send SABME/p, StartT1, release lock
            }
            break;

        case LINK_STATE_W_POLL:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: State=W_POLL, timeout not expected.\n");
            }
            break;

        case LINK_STATE_W_FINAL:

            //
            // We sent our initial RR-c/p and have not received his RR-r/f.
            // We have to restart the checkpoint, unless our retries have
            // run out, in which case we just abort the link.
            //

            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint0 ("ExpireT1Timer: Link State=W_FINAL.\n");
                NbfDumpLinkInfo (Link);
            }

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);    // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no final received)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_FINAL mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.

            } else {

                BackoffCurrentT1Timeout (Link);
                NbfSendRr (Link, TRUE, TRUE);    // send RR-c/p, StartT1, release lock

            }
            break;

        case LINK_STATE_W_DISC_RSP:

            //
            // We sent a DISC-c/p to disconnect this link and are awaiting
            // his response, either a UA-r/f or DM-r/f.  We have to issue
            // the DISC again, unless we've tried a few times, in which case
            // we just shut the link down.
            //

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint0 ("ExpireT1Timer: Link State=W_DISC_RESP.\n");
                NbfDumpLinkInfo (Link);
            }

            if (--Link->SendRetries == 0) {

                CancelT1Timeout (Link);      // we are stopping a polling state

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);         // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no response to DISC)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_DISC_RSP mode", Link, LREF_NOT_ADM);

                return;                         // skip extra spinlock release.

            } else {

                // we don't bother calling BackoffCurrentT1Timeout for DISCs.
                ++Link->CurrentPollRetransmits;
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));  // startup timer again.

                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfSendDisc (Link, TRUE);  // send DISC/p.

            }
            break;

        default:

            RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
            IF_NBFDBG (NBF_DEBUG_TIMER) {
                NbfPrint1 ("ExpireT1Timer: State=%ld (UNKNOWN), timeout not expected.\n",
                          Link->State);
            }
    }


} /* ExpireT1Timer */


VOID
ExpireT2Timer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's T2 timer expires.  T2 is the
    delayed acknowlegement timer in the LLC connection-oriented procedures.
    The T2 timer is started when a valid I-frame is received but not
    immediately acknowleged.  Then, if reverse I-frame traffic is sent,
    the timer is stopped, since the reverse traffic will acknowlege the
    received I-frames.  If no reverse I-frame traffic becomes available
    to send, then this timer fires, causing a RR-r/0 to be sent so as
    to acknowlege the received but as yet unacked I-frames.

Arguments:

    Link - Pointer to the TP_LINK object whose T2 timer has expired.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireT2Timer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    NbfSendRr (Link, FALSE, FALSE);      // send RR-r/f, release lock.

} /* ExpireT2Timer */


VOID
ExpireTiTimer(
    PTP_LINK Link
    )

/*++

Routine Description:

    This routine is called when a link's Ti timer expires.  Ti is the
    inactivity timer, and serves as a keep-alive on a link basis, to
    periodically perform some protocol exchange with the remote connection
    partner that will implicitly reveal whether the link is still active
    or not.  This implementation simply uses a checkpoint sequence, but
    some other protocols may choose to add protocol, including sending
    a NetBIOS SESSION_ALIVE frame.  If a checkpoint sequence is already
    in progress, then we do nothing.

    This timer expiration routine is self-perpetuating; that is, it starts
    itself after finishing its tasks every time.

Arguments:

    Link - Pointer to the TP_LINK object whose Ti timer has expired.

Return Value:

    none.

--*/

{
    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpireTiTimer:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

    if ((Link->State != LINK_STATE_ADM) &&
        (Link->State != LINK_STATE_W_DISC_RSP) &&
        (Link->SendState != SEND_STATE_CHECKPOINTING)) {

        IF_NBFDBG (NBF_DEBUG_TIMER) {
            NbfPrint0 ("ExpireTiTimer:  Entered.\n");
            NbfDumpLinkInfo (Link);
        }

        if (Link->Provider->EasilyDisconnected && Link->NumberOfConnectors == 0) {

            //
            // On an easily disconnected network with only server connections,
            // if there has been no activity in this timeout period then
            // we trash the connection.
            //

            if (Link->PacketsReceived == Link->TiStartPacketsReceived) {

                Link->State = LINK_STATE_ADM;
                NbfSendDm (Link, FALSE);   // send DM/0, release lock
#if DBG
                if (NbfDisconnectDebug) {
                    NbfPrint0( "ExpireT1Timer calling NbfStopLink (no final received)\n" );
                }
#endif
                NbfStopLink (Link);

                // moving to ADM, remove reference
                NbfDereferenceLinkSpecial("Expire T1 in W_FINAL mode", Link, LREF_NOT_ADM);

            } else {

                //
                // There was traffic, restart the timer.
                //

                StartTi (Link);
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            }

        } else {

#if 0
            if ((Link->SendState == SEND_STATE_READY) &&
                (Link->T1 == 0) &&
                (!IsListEmpty (&Link->WackQ))) {

                //
                // If we think the link is idle but there are packets
                // on the WackQ, the link is messed up, disconnect it.
                //

                NbfPrint1 ("NBF: Link %d hung at Ti expiration, recovering\n", Link);
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);

            } else {
#endif

                Link->SendState = SEND_STATE_CHECKPOINTING;
                Link->PacketsSent = 0;
                Link->PacketsResent = 0;
                Link->PacketsReceived = 0;
                NbfSendRr (Link, TRUE, TRUE);    // send RR-c/p, StartT1, release lock.

#if 0
            }
#endif

        }

    } else {

        Link->PacketsSent = 0;
        Link->PacketsResent = 0;
        Link->PacketsReceived = 0;

        RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
#if DBG
        if (Link->SendState == SEND_STATE_REJECTING) {
            NbfPrint0 ("ExpireTiTimer: link state == rejecting, shouldn't be\n");
        }
#endif

    }

#if 0
    //
    // Startup the inactivity timer again.
    //

    if (Link->State != LINK_STATE_ADM) {
        StartTi (Link);
    }
#endif

} /* ExpireTiTimer */

#if 0

VOID
ExpirePurgeTimer(
    PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine is called when the device context's periodic adaptive
    window algorithm timer expires.  The timer perpetuates itself on a
    regular basis.

Arguments:

    DeviceContext - Pointer to the device context whose purge timer has expired.

Return Value:

    none.

--*/

{
    PTP_LINK Link;
    PLIST_ENTRY p;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("ExpirePurgeTimer:  Entered.\n");
    }

    //
    // Scan through the link database on this device context and clear
    // their worst window size limit.  This will allow stuck links to
    // grow their window again even though they encountered temporary
    // congestion at the remote link station's adapter.
    //

    while (!IsListEmpty (&DeviceContext->PurgeList)) {
        p = RemoveHeadList (&DeviceContext->PurgeList);
        Link = CONTAINING_RECORD (p, TP_LINK, PurgeList);
        Link->WorstWindowSize = Link->MaxWindowSize;   // maximum window possible.

    }

    //
    // Restart purge timer.
    //

    DeviceContext->AdaptivePurge = DeviceContext->ShortAbsoluteTime + TIMER_PURGE_TICKS;


} /* ExpirePurgeTimer */
#endif


VOID
ScanShortTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any link-level timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    DeferredContext - Pointer to our DEVICE_CONTEXT object.

Return Value:

    none.

--*/

{
    PLIST_ENTRY p, nextp;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    PTP_CONNECTION Connection;
    BOOLEAN RestartTimer = FALSE;
    LARGE_INTEGER CurrentTick;
    LARGE_INTEGER TickDifference;
    ULONG TickDelta;


    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    DeviceContext = DeferredContext;

    IF_NBFDBG (NBF_DEBUG_TIMERDPC) {
        NbfPrint0 ("ScanShortTimersDpc:  Entered.\n");
    }

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    //
    // This prevents anybody from starting the timer while we
    // are in this routine (the main reason for this is that it
    // makes it easier to determine whether we should restart
    // it at the end of this routine).
    //

    DeviceContext->ProcessingShortTimer = TRUE;

    //
    // Advance the up-counter used to mark time in SHORT_TIMER_DELTA units.  If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //


    KeQueryTickCount (&CurrentTick);

    TickDifference.QuadPart = CurrentTick.QuadPart -
                          (DeviceContext->ShortTimerStart).QuadPart;

    TickDelta = TickDifference.LowPart / NbfShortTimerDeltaTicks;
    if (TickDelta == 0) {
        TickDelta = 1;
    }

    DeviceContext->ShortAbsoluteTime += TickDelta;

    if (DeviceContext->ShortAbsoluteTime >= 0xf0000000) {

        ULONG Timeout;

        DeviceContext->ShortAbsoluteTime -= 0xe0000000;

        p = DeviceContext->ShortList.Flink;
        while (p != &DeviceContext->ShortList) {

            Link = CONTAINING_RECORD (p, TP_LINK, ShortList);

            Timeout = Link->T1;
            if (Timeout) {
                Link->T1 = Timeout - 0xe0000000;
            }

            Timeout = Link->T2;
            if (Timeout) {
                Link->T2 = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }

    //
    // now, as the timers are started, links are added to the end of the
    // respective queue for that timer. since we know the additions are
    // done in an orderly fashion and are sequential, we must only traverse
    // a particular timer list to the first entry that is greater than our
    // timer. That entry and all further entries will not need service.
    // When a timer is cancelled, we remove the link from the list. With all
    // of this fooling around, we wind up only visiting those links that are
    // actually in danger of timing out, minimizing time in this routine.
    //

    // T1 timers first; this is the link-level response expected timer, and is
    // the shortest one.
    // T2 timers. This is the iframe response expected timer, and is typically
    // about 300 ms.

    p = DeviceContext->ShortList.Flink;
    while (p != &DeviceContext->ShortList) {

        Link = CONTAINING_RECORD (p, TP_LINK, ShortList);

        ASSERT (Link->OnShortList);

        //
        // To avoid problems with the refcount being 0, don't
        // do this if we are in ADM.
        //

        if (Link->State != LINK_STATE_ADM) {

            if (Link->T1 && (DeviceContext->ShortAbsoluteTime > Link->T1)) {

                Link->T1 = 0;
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                ExpireT1Timer (Link);       // no spinlocks held
                INCREMENT_COUNTER (DeviceContext, ResponseTimerExpirations);

                ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            }

            if (Link->T2 && (DeviceContext->ShortAbsoluteTime > Link->T2)) {

                Link->T2 = 0;
                RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                ExpireT2Timer (Link);       // no spinlocks held
                INCREMENT_COUNTER (DeviceContext, AckTimerExpirations);

                ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            }

        }

        if (!Link->OnShortList) {

            //
            // The link has been taken out of the list while
            // we were processing it. In this (rare) case we
            // stop processing the whole list, we'll get it
            // next time.
            //

#if DBG
            DbgPrint ("NBF: Stop processing ShortList, %lx removed\n", Link);
#endif
            break;

        }

        nextp = p->Flink;

        if ((Link->T1 == 0) && (Link->T2 == 0)) {
            Link->OnShortList = FALSE;
            RemoveEntryList(p);

            //
            // Do another check; that way if someone slipped in between
            // the check of Link->Tx and the OnShortList = FALSE and
            // therefore exited without inserting, we'll catch that here.
            //

            if ((Link->T1 != 0) || (Link->T2 != 0)) {
                InsertTailList(&DeviceContext->ShortList, &Link->ShortList);
                Link->OnShortList = TRUE;
            }

        }

        p = nextp;

    }

    //
    // If the list is empty note that, otherwise ShortListActive
    // remains TRUE.
    //

    if (IsListEmpty (&DeviceContext->ShortList)) {
        DeviceContext->a.i.ShortListActive = FALSE;
    }

    //
    // NOTE: DeviceContext->TimerSpinLock is held here.
    //


    //
    // Connection Data Ack timers. This queue is used to indicate
    // that a piggyback ack is pending for this connection. We walk
    // the queue, for each element we check if the connection has
    // been on the queue for NbfDeferredPasses times through
    // here. If so, we take it off and send an ack. Note that
    // we have to be very careful how we walk the queue, since
    // it may be changing while this is running.
    //
    // NOTE: There is no expiration time for connections on this
    // queue; it "expires" every time ScanShortTimersDpc runs.
    //


    for (p = DeviceContext->DataAckQueue.Flink;
         p != &DeviceContext->DataAckQueue;
         p = p->Flink) {

        Connection = CONTAINING_RECORD (p, TP_CONNECTION, DataAckLinkage);

        //
        // Skip this connection if it is not queued or it is
        // too recent to matter. We may skip incorrectly if
        // the connection is just being queued, but that is
        // OK, we will get it next time.
        //

        if (((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) == 0) &&
            ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_NOT_Q) == 0)) {
            continue;
        }

        TickDifference.QuadPart = CurrentTick.QuadPart -
                                      (Connection->ConnectStartTime).QuadPart;

        if ((TickDifference.HighPart == 0) &&
            (TickDifference.LowPart <= NbfTwentyMillisecondsTicks)) {
            continue;
        }

        NbfReferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        DeviceContext->DataAckQueueChanged = FALSE;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Check the correct connection flag, to ensure that a
        // send has not just taken him off the queue.
        //
        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        if (((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) &&
            ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_NOT_Q) == 0)) {

            //
            // Yes, we were waiting to piggyback an ack, but no send
            // has come along. Turn off the flags and send an ack.
            //
            // We have to ensure we nest the spin lock acquisition
            // correctly.
            //

            Connection->DeferredFlags &= ~CONNECTION_FLAGS_DEFERRED_ACK;

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

            INCREMENT_COUNTER (DeviceContext, PiggybackAckTimeouts);

#if DBG
            if (NbfDebugPiggybackAcks) {
                NbfPrint0("T");
            }
#endif

            NbfSendDataAck (Connection);

        } else {

            RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        }

        NbfDereferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // If the list has changed, then we need to stop processing
        // since p->Flink is not valid.
        //

        if (DeviceContext->DataAckQueueChanged) {
            break;
        }

    }

    if (IsListEmpty (&DeviceContext->DataAckQueue)) {
        DeviceContext->a.i.DataAckQueueActive = FALSE;
    }

#if 0

    //
    // NOTE: This is currently disabled, it may be reenabled
    // at some point - adamba 9/1/92
    //
    // If the adaptive purge timer has expired, then run the purge
    // algorithm on all affected links.
    //

    if (DeviceContext->ShortAbsoluteTime > DeviceContext->AdaptivePurge) {
        DeviceContext->AdaptivePurge = DeviceContext->ShortAbsoluteTime +
                                       TIMER_PURGE_TICKS;
        ExpirePurgeTimer (DeviceContext);
    }
#endif

    //
    // deferred processing. We will handle all link structure additions and
    // deletions here; we must be the exclusive user of the link tree to do
    // this. We verify that we are by examining the semaphore that tells us
    // how many readers of the tree are curretly processing it. If there are
    // any readers, we simply increment our "deferred processing locked out"
    // counter and do something else. If we defer too many times, we simply
    // bugcheck, as something is wrong somewhere in the system.
    //

    if (!IsListEmpty (&DeviceContext->LinkDeferred)) {
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // now do additions or deletions if we can.
        //

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);
        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        while (!IsListEmpty (&DeviceContext->LinkDeferred)) {
            p = RemoveHeadList (&DeviceContext->LinkDeferred);
            DeviceContext->DeferredNotSatisfied = 0;

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

            //
            // now do an addition or deletion if we can.
            //

            Link = CONTAINING_RECORD (p, TP_LINK, DeferredList);

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint4 ("ScanShortTimersDPC: link off deferred queue %lx %lx %lx Flags: %lx \n",
                    Link, DeviceContext->LinkDeferred.Flink,
                    DeviceContext->LinkDeferred.Blink, Link->DeferredFlags);
            }
            Link->DeferredList.Flink = Link->DeferredList.Blink =
                                                    &Link->DeferredList;

            if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_MASK) == 0) {
                // Tried to do an operation we don't understand; whine.

                IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                    NbfPrint2 ("ScanTimerDPC: Attempting deferred operation on nothing! \nScanTimerDPC: Link: %lx, DeviceContext->DeferredQueue: %lx\n",
                        Link, &DeviceContext->LinkDeferred);
                      DbgBreakPoint ();
                }
                InitializeListHead (&DeviceContext->LinkDeferred);
                // We could have a hosed deferred operations queue here;
                // take some time to figure out if it is ok.

            }

            if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_ADD) != 0) {

                Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_ADD;

                if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {

                    //
                    // It is being added and deleted; just destroy it.
                    //
                    Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_DELETE;
                    NbfDestroyLink (Link);

                    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                        NbfPrint1 ("ScanTimerDPC: deferred processing: Add AND Delete link: %lx\n",Link);
                    }

                } else  {

                    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
                    NbfAddLinkToTree (DeviceContext, Link);
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
                    IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                        NbfPrint1 ("ScanTimerDPC: deferred processing: Added link to tree: %lx\n",Link);
                    }

                }

            } else if ((Link->DeferredFlags & LINK_FLAGS_DEFERRED_DELETE) != 0) {
                Link->DeferredFlags &= ~LINK_FLAGS_DEFERRED_DELETE;
                NbfRemoveLinkFromTree (DeviceContext, Link);
                NbfDestroyLink (Link);

                IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                    NbfPrint1 ("ScanTimerDPC: deferred processing: returning link %lx to LinkPool.\n", Link);
                }

            }

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        }

        InitializeListHead (&DeviceContext->LinkDeferred);

        DeviceContext->a.i.LinkDeferredActive = FALSE;

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        RELEASE_DPC_SPIN_LOCK (&DeviceContext->LinkSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    }


    //
    // Update the real counters from the temp ones.
    //

    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DataFrameBytesSent,
        DeviceContext->TempIFrameBytesSent);
    DeviceContext->Statistics.DataFramesSent += DeviceContext->TempIFramesSent;

    DeviceContext->TempIFrameBytesSent = 0;
    DeviceContext->TempIFramesSent = 0;

    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DataFrameBytesReceived,
        DeviceContext->TempIFrameBytesReceived);
    DeviceContext->Statistics.DataFramesReceived += DeviceContext->TempIFramesReceived;

    DeviceContext->TempIFrameBytesReceived = 0;
    DeviceContext->TempIFramesReceived = 0;


    //
    // Determine if we have to restart the timer.
    //

    DeviceContext->ProcessingShortTimer = FALSE;

    if (DeviceContext->a.AnyActive &&
        (DeviceContext->State != DEVICECONTEXT_STATE_STOPPING)) {

        RestartTimer = TRUE;

    }


    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    if (RestartTimer) {

        //
        // Start up the timer again.  Note that because we start the timer
        // after doing work (above), the timer values will slip somewhat,
        // depending on the load on the protocol.  This is entirely acceptable
        // and will prevent us from using the timer DPC in two different
        // threads of execution.
        //

        KeQueryTickCount(&DeviceContext->ShortTimerStart);
        START_TIMER(DeviceContext, 
                    SHORT_TIMER,
                    &DeviceContext->ShortSystemTimer,
                    DueTimeDelta,
                    &DeviceContext->ShortTimerSystemDpc);
    } else {

#if DBG
        if (NbfDebugShortTimer) {
            DbgPrint("x");
        }
#endif
        NbfDereferenceDeviceContext ("Don't restart short timer", DeviceContext, DCREF_SCAN_TIMER);

    }

    LEAVE_TIMER(DeviceContext, SHORT_TIMER);

    LEAVE_NBF;
    return;

} /* ScanShortTimersDpc */


VOID
ScanLongTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at regular
    intervals to determine if any long timers have expired, and
    if they have, to execute their expiration routines.

Arguments:

    DeferredContext - Pointer to our DEVICE_CONTEXT object.

Return Value:

    none.

--*/

{
    LARGE_INTEGER DueTime;
    PLIST_ENTRY p, nextp;
    PDEVICE_CONTEXT DeviceContext;
    PTP_LINK Link;
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    DeviceContext = DeferredContext;

    IF_NBFDBG (NBF_DEBUG_TIMERDPC) {
        NbfPrint0 ("ScanLongTimersDpc:  Entered.\n");
    }
 
    //
    // Advance the up-counter used to mark time in LONG_TIMER_DELTA units.If we
    // advance it all the way to 0xf0000000, then reset it to 0x10000000.
    // We also run all the lists, decreasing all counters by 0xe0000000.
    //

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

    if (++DeviceContext->LongAbsoluteTime == 0xf0000000) {

        ULONG Timeout;

        DeviceContext->LongAbsoluteTime = 0x10000000;

        p = DeviceContext->LongList.Flink;
        while (p != &DeviceContext->LongList) {

            Link = CONTAINING_RECORD (p, TP_LINK, LongList);

            Timeout = Link->Ti;
            if (Timeout) {
                Link->Ti = Timeout - 0xe0000000;
            }

            p = p->Flink;
        }

    }

    //
    // now, as the timers are started, links are added to the end of the
    // respective queue for that timer. since we know the additions are
    // done in an orderly fashion and are sequential, we must only traverse
    // a particular timer list to the first entry that is greater than our
    // timer. That entry and all further entries will not need service.
    // When a timer is cancelled, we remove the link from the list. With all
    // of this fooling around, we wind up only visiting those links that are
    // actually in danger of timing out, minimizing time in this routine.
    //


    //
    // Ti timers. This is the inactivity timer for the link, used when no
    // activity has occurred on the link in some time. We only check this
    // every four expirations of the timer since the granularity is usually
    // in the 30 second range.
    // NOTE: DeviceContext->TimerSpinLock is held here.
    //

    if ((DeviceContext->LongAbsoluteTime % 4) == 0) {

        p = DeviceContext->LongList.Flink;
        while (p != &DeviceContext->LongList) {

            Link = CONTAINING_RECORD (p, TP_LINK, LongList);

            ASSERT (Link->OnLongList);

            //
            // To avoid problems with the refcount being 0, don't
            // do this if we are in ADM.
            //

#if DBG
            if (Link->SendState == SEND_STATE_REJECTING) {
                NbfPrint0 ("Timer: link state == rejecting, shouldn't be\n");
            }
#endif

            if (Link->State != LINK_STATE_ADM) {

                if (Link->Ti && (DeviceContext->LongAbsoluteTime > Link->Ti)) {

                    Link->Ti = 0;
                    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                    ExpireTiTimer (Link);       // no spinlocks held
                    ++DeviceContext->TiExpirations;

                    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

                }

            }

            if (!Link->OnLongList) {

                //
                // The link has been taken out of the list while
                // we were processing it. In this (rare) case we
                // stop processing the whole list, we'll get it
                // next time.
                //

#if DBG
                DbgPrint ("NBF: Stop processing LongList, %lx removed\n", Link);
#endif
                break;

            }

            nextp = p->Flink;

            if (Link->Ti == 0) {

                Link->OnLongList = FALSE;
                RemoveEntryList(p);

                if (Link->Ti != 0) {
                    InsertTailList(&DeviceContext->LongList, &Link->LongList);
                    Link->OnLongList = TRUE;
                }

            }

            p = nextp;

        }

    }


    //
    // Now scan the data ack queue, looking for connections with
    // no acks queued that we can get rid of.
    //
    // Note: The timer spinlock is held here.
    //

    p = DeviceContext->DataAckQueue.Flink;

    while (p != &DeviceContext->DataAckQueue && 
           !DeviceContext->DataAckQueueChanged) {

        Connection = CONTAINING_RECORD (DeviceContext->DataAckQueue.Flink, TP_CONNECTION, DataAckLinkage);

        if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {
            p = p->Flink;
            continue;
        }

        NbfReferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        ACQUIRE_DPC_SPIN_LOCK (Connection->LinkSpinLock);
        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Have to check again, because the connection might
        // just have been stopped.
        //

        if (Connection->OnDataAckQueue) {
            Connection->OnDataAckQueue = FALSE;

            RemoveEntryList (&Connection->DataAckLinkage);

            if ((Connection->DeferredFlags & CONNECTION_FLAGS_DEFERRED_ACK) != 0) {
                InsertTailList (&DeviceContext->DataAckQueue, &Connection->DataAckLinkage);
                Connection->OnDataAckQueue = TRUE;
            }

            DeviceContext->DataAckQueueChanged = TRUE;

        }

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);
        RELEASE_DPC_SPIN_LOCK (Connection->LinkSpinLock);

        NbfDereferenceConnection ("ScanShortTimersDpc", Connection, CREF_DATA_ACK_QUEUE);

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);

        //
        // Since we have changed the list, we can't tell if p->Flink
        // is valid, so break. The effect is that we gradually peel
        // connections off the queue.
        //

        break;

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->TimerSpinLock);


    //
    // See if we got any multicast traffic last time.
    //

    if (DeviceContext->MulticastPacketCount == 0) {

        ++DeviceContext->LongTimeoutsWithoutMulticast;

        if (DeviceContext->EasilyDisconnected &&
            (DeviceContext->LongTimeoutsWithoutMulticast > 5)) {

            PLIST_ENTRY p;
            PTP_ADDRESS address;

            //
            // We have had five timeouts in a row with no
            // traffic, mark all the addresses as needing
            // reregistration next time a connect is
            // done on them.
            //

            ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            for (p = DeviceContext->AddressDatabase.Flink;
                 p != &DeviceContext->AddressDatabase;
                 p = p->Flink) {

                address = CONTAINING_RECORD (p, TP_ADDRESS, Linkage);
                address->Flags |= ADDRESS_FLAGS_NEED_REREGISTER;

            }

            RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

            DeviceContext->LongTimeoutsWithoutMulticast = 0;

        }

    } else {

        DeviceContext->LongTimeoutsWithoutMulticast = 0;

    }

    DeviceContext->MulticastPacketCount = 0;


    //
    // Every thirty seconds, check for stalled connections
    //

    ++DeviceContext->StalledConnectionCount;

    if (DeviceContext->StalledConnectionCount ==
            (USHORT)((30 * SECONDS) / LONG_TIMER_DELTA)) {

        DeviceContext->StalledConnectionCount = 0;
        StopStalledConnections (DeviceContext);

    }


    //
    // Scan for any uncompleted receive IRPs, this may happen if
    // the cable is pulled and we don't get any more ReceiveComplete
    // indications.

    NbfReceiveComplete((NDIS_HANDLE)DeviceContext);


    //
    // Start up the timer again.  Note that because we start the timer
    // after doing work (above), the timer values will slip somewhat,
    // depending on the load on the protocol.  This is entirely acceptable
    // and will prevent us from using the timer DPC in two different
    // threads of execution.
    //

    if (DeviceContext->State != DEVICECONTEXT_STATE_STOPPING) {
        DueTime.HighPart = -1;
        DueTime.LowPart = (ULONG)-(LONG_TIMER_DELTA);          // delta time to next click.
        START_TIMER(DeviceContext, 
                    LONG_TIMER,
                    &DeviceContext->LongSystemTimer,
                    DueTime,
                    &DeviceContext->LongTimerSystemDpc);
    } else {
        NbfDereferenceDeviceContext ("Don't restart long timer", DeviceContext, DCREF_SCAN_TIMER);
    }

    LEAVE_TIMER(DeviceContext, LONG_TIMER);
    
    LEAVE_NBF;
    return;

} /* ScanLongTimersDpc */


VOID
StopStalledConnections(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine is called from ScanLongTimersDpc every 30 seconds.
    It checks for connections that have not made any progress in
    their sends in the last two minutes, and stops them.

Arguments:

    DeviceContext - The device context to check.

Return Value:

    none.

--*/

{

    PTP_ADDRESS Address, PrevAddress;
    PTP_CONNECTION Connection, StalledConnection;
    PLIST_ENTRY p, q;


    //
    // If we have crossed a thirty-second interval, then
    // check each address for connections that have not
    // made any progress in two minutes.
    //

    PrevAddress = NULL;

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    for (p = DeviceContext->AddressDatabase.Flink;
         p != &DeviceContext->AddressDatabase;
         p = p->Flink) {

        Address = CONTAINING_RECORD (
                    p,
                    TP_ADDRESS,
                    Linkage);

        if ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        //
        // By referencing the address, we ensure that it will stay
        // in the AddressDatabase, this its Flink will stay valid.
        //

        NbfReferenceAddress("checking for dead connections", Address, AREF_TIMER_SCAN);

        RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        if (PrevAddress) {
            NbfDereferenceAddress ("done checking", PrevAddress, AREF_TIMER_SCAN);
        }

        //
        // Scan this addresses connection database for connections
        // that have not made progress in the last two minutes; we
        // kill the first one we find.
        //

        StalledConnection = NULL;

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

        for (q = Address->ConnectionDatabase.Flink;
            q != &Address->ConnectionDatabase;
            q = q->Flink) {

            Connection = CONTAINING_RECORD (q, TP_CONNECTION, AddressList);

            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            if (!IsListEmpty (&Connection->SendQueue)) {

                //
                // If there is a connection on the queue...
                //

                if (Connection->StallBytesSent == Connection->sp.MessageBytesSent) {

                    //
                    // ...and it has not made any progress...
                    //

                    if (Connection->StallCount >= 4) {

                        //
                        // .. four times in a row, the connection is dead.
                        //

                        if (!StalledConnection) {
                            StalledConnection = Connection;
                            NbfReferenceConnection ("stalled", Connection, CREF_STALLED);
                        }
#if DBG
                        DbgPrint ("NBF: Found connection %lx [%d for %d] stalled on %lx\n",
                            Connection, Connection->StallBytesSent, Connection->StallCount, Address);
#endif

                    } else {

                        //
                        // If it is stuck, increment the count.
                        //

                        ++Connection->StallCount;

                    }

                } else {

                    Connection->StallBytesSent = Connection->sp.MessageBytesSent;

                }

            }

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);


        }

        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

        if (StalledConnection) {

            PTP_LINK Link = StalledConnection->Link;

#if DBG
            DbgPrint("NBF: Stopping stalled connection %lx, link %lx\n", StalledConnection, Link);
#endif

            FailSend (StalledConnection, STATUS_IO_TIMEOUT, TRUE);                   // fail the send
            ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);
            if (Link->State == LINK_STATE_READY) {
                CancelT1Timeout (Link);
                Link->State = LINK_STATE_W_DISC_RSP;
                Link->SendState = SEND_STATE_DOWN;
                Link->ReceiveState = RECEIVE_STATE_DOWN;
                Link->SendRetries = (UCHAR)Link->LlcRetries;
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);
                StartT1 (Link, Link->HeaderLength + sizeof(DLC_S_FRAME));   // retransmit timer.
                NbfSendDisc (Link, TRUE);  // send DISC-c/p.
            } else {
                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);
                NbfStopLink (Link);
            }

            NbfDereferenceConnection ("stalled", StalledConnection, CREF_STALLED);

        }

        ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

        PrevAddress = Address;

    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    if (PrevAddress) {
        NbfDereferenceAddress ("done checking", PrevAddress, AREF_TIMER_SCAN);
    }

}   /* StopStalledConnections */


VOID
NbfStartShortTimer(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine starts the short timer, if it is not already running.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{

    //
    // Start the timer unless it the DPC is already running (in
    // which case it will restart the timer itself if needed),
    // or some list is active (meaning the timer is already
    // queued up).
    //
    // We use a trick to check all four active lists at the
    // same time, but this depends on some alignment and
    // size assumptions.
    //

    ASSERT (sizeof(ULONG) >= 3 * sizeof(BOOLEAN));
    ASSERT ((PVOID)&DeviceContext->a.AnyActive ==
            (PVOID)&DeviceContext->a.i.ShortListActive);

    StartTimer++;

    if ((!DeviceContext->ProcessingShortTimer) &&
        (!(DeviceContext->a.AnyActive))) {

#if DBG
        if (NbfDebugShortTimer) {
            DbgPrint("X");
        }
#endif

        NbfReferenceDeviceContext ("Start short timer", DeviceContext, DCREF_SCAN_TIMER);

        KeQueryTickCount(&DeviceContext->ShortTimerStart);
        StartTimerSet++;
        START_TIMER(DeviceContext, 
                    SHORT_TIMER,
                    &DeviceContext->ShortSystemTimer,
                    DueTimeDelta,
                    &DeviceContext->ShortTimerSystemDpc);
    }

}   /* NbfStartShortTimer */


VOID
NbfInitializeTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine initializes the lightweight timer system for the transport
    provider.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{
    LARGE_INTEGER DueTime;

    IF_NBFDBG (NBF_DEBUG_TIMER) {
        NbfPrint0 ("NbfInitializeTimerSystem:  Entered.\n");
    }

    ASSERT(TIMERS_INITIALIZED(DeviceContext));
    
    //
    // Set these up.
    //

    NbfTickIncrement = KeQueryTimeIncrement();

    if (NbfTickIncrement > (20 * MILLISECONDS)) {
        NbfTwentyMillisecondsTicks = 1;
    } else {
        NbfTwentyMillisecondsTicks = (20 * MILLISECONDS) / NbfTickIncrement;
    }

    if (NbfTickIncrement > (SHORT_TIMER_DELTA)) {
        NbfShortTimerDeltaTicks = 1;
    } else {
        NbfShortTimerDeltaTicks = (SHORT_TIMER_DELTA) / NbfTickIncrement;
    }

    //
    // MaximumIntervalTicks represents 60 seconds, unless the value
    // when shifted out by the accuracy required is too big.
    //

    if ((((ULONG)0xffffffff) >> (DLC_TIMER_ACCURACY+2)) > ((60 * SECONDS) / NbfTickIncrement)) {
        NbfMaximumIntervalTicks = (60 * SECONDS) / NbfTickIncrement;
    } else {
        NbfMaximumIntervalTicks = ((ULONG)0xffffffff) >> (DLC_TIMER_ACCURACY + 2);
    }

    //
    // The AbsoluteTime cycles between 0x10000000 and 0xf0000000.
    //

    DeviceContext->ShortAbsoluteTime = 0x10000000;   // initialize our timer click up-counter.
    DeviceContext->LongAbsoluteTime = 0x10000000;   // initialize our timer click up-counter.

    DeviceContext->AdaptivePurge = TIMER_PURGE_TICKS;

    DeviceContext->MulticastPacketCount = 0;
    DeviceContext->LongTimeoutsWithoutMulticast = 0;

    KeInitializeDpc(
        &DeviceContext->ShortTimerSystemDpc,
        ScanShortTimersDpc,
        DeviceContext);

    KeInitializeDpc(
        &DeviceContext->LongTimerSystemDpc,
        ScanLongTimersDpc,
        DeviceContext);

    KeInitializeTimer (&DeviceContext->ShortSystemTimer);

    KeInitializeTimer (&DeviceContext->LongSystemTimer);

    DueTime.HighPart = -1;
    DueTime.LowPart = (ULONG)-(LONG_TIMER_DELTA);

    ENABLE_TIMERS(DeviceContext);

    //
    // One reference for the long timer.
    //

    NbfReferenceDeviceContext ("Long timer active", DeviceContext, DCREF_SCAN_TIMER);

    START_TIMER(DeviceContext, 
                LONG_TIMER,
                &DeviceContext->LongSystemTimer,
                DueTime,
                &DeviceContext->LongTimerSystemDpc);

} /* NbfInitializeTimerSystem */


VOID
NbfStopTimerSystem(
    IN PDEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine stops the lightweight timer system for the transport
    provider.

Arguments:

    DeviceContext - Pointer to our device context.

Return Value:

    none.

--*/

{

    //
    // If timers are currently executing timer code, then this
    // function blocks until they are done executing. Also
    // no new timers will be allowed to be queued after this.
    //
    
    {
        if (KeCancelTimer(&DeviceContext->LongSystemTimer)) {
            LEAVE_TIMER(DeviceContext, LONG_TIMER);
            NbfDereferenceDeviceContext ("Long timer cancelled", DeviceContext, DCREF_SCAN_TIMER);
        }

        if (KeCancelTimer(&DeviceContext->ShortSystemTimer)) {
            LEAVE_TIMER(DeviceContext, SHORT_TIMER);
            NbfDereferenceDeviceContext ("Short timer cancelled", DeviceContext, DCREF_SCAN_TIMER);
        }
    }

    DISABLE_TIMERS(DeviceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the user process and can ( when
    built in a debug kernel) will log to either the console or through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/


#if DBG

#include <netb.h>
#include <stdarg.h>
#include <stdio.h>

ULONG NbDllDebug = 0x0;
#define NB_DLL_DEBUG_NCB        0x00000001  // print all NCB's submitted
#define NB_DLL_DEBUG_NCB_BUFF   0x00000002  // print buffers for NCB's submitted

BOOL UseConsole = FALSE;
BOOL UseLogFile = TRUE;
HANDLE LogFile = INVALID_HANDLE_VALUE;
#define LOGNAME                 (LPTSTR) TEXT("netbios.log")

LONG NbMaxDump = 128;

//  Macro used in DisplayNcb
#define DISPLAY_COMMAND( cmd )              \
    case cmd: NbPrintf(( #cmd )); break;

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

VOID
DisplayNcb(
    IN PNCBI pncbi
    )
/*++

Routine Description:

    This routine displays on the standard output stream the contents
    of the Ncb.

Arguments:

    IN PNCBI - Supplies the NCB to be displayed.

Return Value:

    none.

--*/
{
    if ( (NbDllDebug & NB_DLL_DEBUG_NCB) == 0 ) {
        return;
    }

    NbPrintf(( "PNCB         %#010lx\n", pncbi));

    NbPrintf(( "ncb_command  %#04x ",  pncbi->ncb_command));
    switch ( pncbi->ncb_command & ~ASYNCH ) {
    DISPLAY_COMMAND( NCBCALL );
    DISPLAY_COMMAND( NCBLISTEN );
    DISPLAY_COMMAND( NCBHANGUP );
    DISPLAY_COMMAND( NCBSEND );
    DISPLAY_COMMAND( NCBRECV );
    DISPLAY_COMMAND( NCBRECVANY );
    DISPLAY_COMMAND( NCBCHAINSEND );
    DISPLAY_COMMAND( NCBDGSEND );
    DISPLAY_COMMAND( NCBDGRECV );
    DISPLAY_COMMAND( NCBDGSENDBC );
    DISPLAY_COMMAND( NCBDGRECVBC );
    DISPLAY_COMMAND( NCBADDNAME );
    DISPLAY_COMMAND( NCBDELNAME );
    DISPLAY_COMMAND( NCBRESET );
    DISPLAY_COMMAND( NCBASTAT );
    DISPLAY_COMMAND( NCBSSTAT );
    DISPLAY_COMMAND( NCBCANCEL );
    DISPLAY_COMMAND( NCBADDGRNAME );
    DISPLAY_COMMAND( NCBENUM );
    DISPLAY_COMMAND( NCBUNLINK );
    DISPLAY_COMMAND( NCBSENDNA );
    DISPLAY_COMMAND( NCBCHAINSENDNA );
    DISPLAY_COMMAND( NCBLANSTALERT );
    DISPLAY_COMMAND( NCBFINDNAME );

    //  Extensions
    DISPLAY_COMMAND( NCALLNIU );
    DISPLAY_COMMAND( NCBQUICKADDNAME );
    DISPLAY_COMMAND( NCBQUICKADDGRNAME );
    DISPLAY_COMMAND( NCBACTION );

    default: NbPrintf(( " Unknown type")); break;
    }
    if ( pncbi->ncb_command  & ASYNCH ) {
        NbPrintf(( " | ASYNCH"));
    }


    NbPrintf(( "\nncb_retcode  %#04x\n",  pncbi->ncb_retcode));
    NbPrintf(( "ncb_lsn      %#04x\n",  pncbi->ncb_lsn));
    NbPrintf(( "ncb_num      %#04x\n",  pncbi->ncb_num));

    NbPrintf(( "ncb_buffer   %#010lx\n",pncbi->ncb_buffer));
    NbPrintf(( "ncb_length   %#06x\n",  pncbi->ncb_length));

    NbPrintf(( "\nncb_callname and ncb->name\n"));
    FormattedDump( pncbi->cu.ncb_callname, NCBNAMSZ );
    FormattedDump( pncbi->ncb_name, NCBNAMSZ );

    if (((pncbi->ncb_command & ~ASYNCH) == NCBCHAINSEND) ||
        ((pncbi->ncb_command & ~ASYNCH) == NCBCHAINSENDNA)) {
        NbPrintf(( "ncb_length2  %#06x\n",  pncbi->cu.ncb_chain.ncb_length2));
        NbPrintf(( "ncb_buffer2  %#010lx\n",pncbi->cu.ncb_chain.ncb_buffer2));
    }

    NbPrintf(( "ncb_rto      %#04x\n",  pncbi->ncb_rto));
    NbPrintf(( "ncb_sto      %#04x\n",  pncbi->ncb_sto));
    NbPrintf(( "ncb_post     %lx\n",    pncbi->ncb_post));
    NbPrintf(( "ncb_lana_num %#04x\n",  pncbi->ncb_lana_num));
    NbPrintf(( "ncb_cmd_cplt %#04x\n",  pncbi->ncb_cmd_cplt));

    NbPrintf(( "ncb_reserve\n"));
    FormattedDump( ((PNCB)pncbi)->ncb_reserve, 14 );

    NbPrintf(( "ncb_next\n"));
    FormattedDump( (PCHAR)&pncbi->u.ncb_next, sizeof( LIST_ENTRY) );
    NbPrintf(( "ncb_iosb\n"));
    FormattedDump( (PCHAR)&pncbi->u.ncb_iosb, sizeof( IO_STATUS_BLOCK ) );
    NbPrintf(( "ncb_event %#04x\n",  pncbi->ncb_event));

    if ( (NbDllDebug & NB_DLL_DEBUG_NCB_BUFF) == 0 ) {
        NbPrintf(( "\n\n" ));
        return;
    }

    switch ( pncbi->ncb_command & ~ASYNCH ) {
    case NCBSEND:
    case NCBCHAINSEND:
    case NCBDGSEND:
    case NCBSENDNA:
    case NCBCHAINSENDNA:
        if ( pncbi->ncb_retcode == NRC_PENDING ) {

            //
            //  If pending then presumably we have not displayed the ncb
            //  before. After its been sent there isn't much point in displaying
            //  the buffer again.
            //

            NbPrintf(( "ncb_buffer contents:\n"));
            FormattedDump( pncbi->ncb_buffer, pncbi->ncb_length );
        }
        break;

    case NCBRECV:
    case NCBRECVANY:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBENUM:
    case NCBASTAT:
    case NCBSSTAT:
    case NCBFINDNAME:
        if ( pncbi->ncb_retcode != NRC_PENDING ) {
            //  Buffer has been loaded with data
            NbPrintf(( "ncb_buffer contents:\n"));
            FormattedDump( pncbi->ncb_buffer, pncbi->ncb_length );
        }
        break;

    case NCBCANCEL:
        //  Buffer has been loaded with the NCB to be cancelled
        NbPrintf(( "ncb_buffer contents:\n"));
        FormattedDump( pncbi->ncb_buffer, sizeof(NCB));
        break;
    }
    NbPrintf(( "\n\n" ));
}

VOID
NbPrint(
    char *Format,
    ...
    )
/*++

Routine Description:

    This routine is equivalent to printf with the output being directed to
    stdout.

Arguments:

    IN  char *Format - Supplies string to be output and describes following
        (optional) parameters.

Return Value:

    none.

--*/
{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    if ( NbDllDebug == 0 ) {
        return;
    }


    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    if ( UseConsole ) {
        DbgPrint( "%s", OutputBuffer );
    } else {
        length = strlen( OutputBuffer );
        if ( LogFile == INVALID_HANDLE_VALUE ) {
            if ( UseLogFile ) {
                LogFile = CreateFile( LOGNAME,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
                if ( LogFile == INVALID_HANDLE_VALUE ) {
                    // Could not access logfile so use stdout instead
                    UseLogFile = FALSE;
                    LogFile = GetStdHandle(STD_OUTPUT_HANDLE);
                }
            } else {
                // Use the applications stdout file.
                LogFile = GetStdHandle(STD_OUTPUT_HANDLE);
            }
        }

        WriteFile( LogFile , (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // NbPrint

void
FormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if ( len > NbMaxDump ) {
        len = NbMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NbPrintf (("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NbPrintf (("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\netb.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netbios.h

Abstract:

    This is the main include file for the component of netbios that runs
    in the user process.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nb30.h>
#include <nb30p.h>
#include <netbios.h>

//
//  Internal version of the ncb layout that uses the reserved area to hold
//  the list entry when passing ncb's to the worker thread and the IO status
//  block used when the ncb is passed to the netbios device driver.
//

#include <packon.h>

        struct _CHAIN_SEND {
            WORD ncb_length2;
            PUCHAR ncb_buffer2;
        };

#include <packoff.h>

//
//  Use packing to ensure that the cu union is not forced to word alignment.
//  All elements of this structure are naturally aligned.
//

typedef struct _NCBI {
    UCHAR   ncb_command;            /* command code                   */
    volatile UCHAR   ncb_retcode;   /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    union {
        UCHAR   ncb_callname[NCBNAMSZ];/* blank-padded name of remote */
        struct _CHAIN_SEND ncb_chain;
    } cu;
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * );
                                    /* POST routine address           */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    volatile UCHAR   ncb_cmd_cplt;  /* 0xff => commmand pending       */

    // Make driver specific use of the reserved area of the NCB.
    WORD    ncb_reserved;           /* return to natural alignment    */
    union {
        LIST_ENTRY      ncb_next;   /* queued to worker thread        */
        IO_STATUS_BLOCK ncb_iosb;   /* used for Nt I/O interface      */
    } u;

    HANDLE          ncb_event;      /* HANDLE to Win32 event          */
    } NCBI, *PNCBI;

C_ASSERT(FIELD_OFFSET(NCBI, cu) == FIELD_OFFSET(NCB, ncb_callname));
C_ASSERT(FIELD_OFFSET(NCBI, ncb_event) == FIELD_OFFSET(NCB, ncb_event));
C_ASSERT(FIELD_OFFSET(NCBI, ncb_name) == FIELD_OFFSET(NCB, ncb_name));


#if AUTO_RESET

typedef struct _RESET_LANA_NCB {
    LIST_ENTRY  leList;
    NCB         ResetNCB;
    } RESET_LANA_NCB, *PRESET_LANA_NCB;

#endif

VOID
QueueToWorker(
    IN PNCBI pncb
    );

DWORD
NetbiosWorker(
    IN LPVOID Parameter
    );

DWORD
NetbiosWaiter(
    IN LPVOID Parameter
    );
    
VOID
SendNcbToDriver(
    IN PNCBI pncb
    );

VOID
PostRoutineCaller(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    );

VOID
ChainSendPostRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    );

VOID
HangupConnection(
    PNCBI pUserNcb
    );



//
// debugging info for tracking the workqueue corruption
//

typedef struct _NCB_INFO {
    PNCBI   pNcbi;
    NCBI    Ncb;
    DWORD   dwTimeQueued;
    DWORD   dwQueuedByThread;
    DWORD   dwReserved;
} NCB_INFO, *PNCB_INFO;

extern NCB_INFO g_QueuedHistory[];
extern DWORD g_dwNextQHEntry;

extern NCB_INFO g_DeQueuedHistory[];
extern DWORD g_dwNextDQHEntry;

extern NCB_INFO g_SyncCmdsHistory[];
extern DWORD g_dwNextSCEntry;


#define ADD_NEW_ENTRY(Hist, Index, pNcb)                        \
{                                                               \
    (Hist)[(Index)].pNcbi = (pNcb);                              \
    (Hist)[(Index)].Ncb = *(pNcb);                              \
    (Hist)[(Index)].dwTimeQueued = GetTickCount();              \
    (Hist)[(Index)].dwQueuedByThread = GetCurrentThreadId();    \
    Index = ((Index) + 1) % 16;                                \
}

#define ADD_QUEUE_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_QueuedHistory, g_dwNextQHEntry, pNcb)

#define ADD_DEQUEUE_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_DeQueuedHistory, g_dwNextDQHEntry, pNcb)

#define ADD_SYNCCMD_ENTRY(pNcb)   \
            ADD_NEW_ENTRY(g_SyncCmdsHistory, g_dwNextSCEntry, pNcb)


#if DBG

VOID
DisplayNcb(
    IN PNCBI pncbi
    );

#define NbPrintf(String) NbPrint String;

VOID
NbPrint(
    char *Format,
    ...
    );

#else

//  Dispose of debug statements in non-debug builds.
#define DisplayNcb( pncb ) {};

#define NbPrintf( String ) {};

#endif
//  End of Debug related definitions

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbeui\sys\uframes.c ===
/*++

Copyright (c) 1989, 1990, 1991  Microsoft Corporation

Module Name:

    uframes.c

Abstract:

    This module contains a routine called NbfProcessUi, that gets control
    from routines in DLC.C when a DLC UI frame is received.  Here we
    decode the encapsulated connectionless NetBIOS frame and dispatch
    to the correct NetBIOS frame handler.

    The following frame types are cracked by routines in this module:

        o    NBF_CMD_ADD_GROUP_NAME_QUERY
        o    NBF_CMD_ADD_NAME_QUERY
        o    NBF_CMD_NAME_IN_CONFLICT
        o    NBF_CMD_STATUS_QUERY
        o    NBF_CMD_TERMINATE_TRACE
        o    NBF_CMD_DATAGRAM
        o    NBF_CMD_DATAGRAM_BROADCAST
        o    NBF_CMD_NAME_QUERY
        o    NBF_CMD_ADD_NAME_RESPONSE
        o    NBF_CMD_NAME_RECOGNIZED
        o    NBF_CMD_STATUS_RESPONSE
        o    NBF_CMD_TERMINATE_TRACE2

Author:

    David Beaver (dbeaver) 1-July-1991

Environment:

    Kernel mode, DISPATCH_LEVEL.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



VOID
NbfListenTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is executed as a DPC at DISPATCH_LEVEL when the timeout
    period for the session setup after listening a connection occurs. This
    will occur if the remote has discovered our name and we do not get a
    connection started within some reasonable period of time. In this
    routine we simply tear down the connection (and, most likely, the link
    associated with it).

Arguments:

    Dpc - Pointer to a system DPC object.

    DeferredContext - Pointer to the TP_CONNECTION block representing the
        request that has timed out.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    none.

--*/

{
    PTP_CONNECTION Connection;

    Dpc, SystemArgument1, SystemArgument2; // prevent compiler warnings

    ENTER_NBF;

    Connection = (PTP_CONNECTION)DeferredContext;

    //
    // If this connection is being run down, then we can't do anything.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
            ((Connection->Flags & CONNECTION_FLAGS_WAIT_SI) == 0)) {

        //
        // The connection is stopping, or the SESSION_INITIALIZE
        // has already been processed.
        //

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx stopping.\n",
                        Connection);
        }

        NbfDereferenceConnection ("Listen timeout, ignored", Connection, CREF_TIMER);
        LEAVE_NBF;
        return;
    }

    //
    // We connected to the link before sending the NAME_RECOGNIZED,
    // so we disconnect from it now.
    //

#if DBG
    if (NbfDisconnectDebug) {
        STRING remoteName, localName;
        remoteName.Length = NETBIOS_NAME_LENGTH - 1;
        remoteName.Buffer = Connection->RemoteName;
        localName.Length = NETBIOS_NAME_LENGTH - 1;
        localName.Buffer = Connection->AddressFile->Address->NetworkName->NetbiosName;
        NbfPrint2( "NbfListenTimeout disconnecting connection to %S from %S\n",
            &remoteName, &localName );
    }
#endif

    //
    // BUBGUG: This is really ugly and I doubt it is correct.
    //

    if ((Connection->Flags2 & CONNECTION_FLAGS2_ACCEPTED) != 0) {

        //
        // This connection is up, we stop it.
        //

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, accepted.\n",
                        Connection);
        }

        //
        // Set this so that the client will get a disconnect
        // indication.
        //

        Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
        NbfStopConnection (Connection, STATUS_IO_TIMEOUT);

    } else if (Connection->Link != (PTP_LINK)NULL) {

        //
        // This connection is from a listen...we want to
        // silently reset the listen.
        //

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, listen restarted.\n",
                        Connection);
        }

        Connection->Flags &= ~CONNECTION_FLAGS_WAIT_SI;
        Connection->Flags2 &= ~CONNECTION_FLAGS2_REMOTE_VALID;
        Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        NbfDereferenceConnection ("Timeout", Connection, CREF_LINK);
        (VOID)NbfDisconnectFromLink (Connection, FALSE);

    } else {

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("ListenTimeout: connection %lx, link down.\n",
                        Connection);
        }

    }


    NbfDereferenceConnection("Listen Timeout", Connection, CREF_TIMER);

    LEAVE_NBF;
    return;

} /* ListenTimeout */


NTSTATUS
ProcessAddGroupNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_GROUP_NAME_QUERY frame.  Because
    our caller has already verified that the destination name in the frame
    matches the transport address passed to us, we must simply transmit an
    ADD_NAME_RESPONSE frame and exit with STATUS_ABANDONED.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.
    When we return any other status code, including STATUS_ABANDONED, the
    caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_UI_FRAME RawFrame;  // ptr to allocated connectionless frame.
    UINT HeaderLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;

    UNREFERENCED_PARAMETER (SourceAddress);
    UNREFERENCED_PARAMETER (Address);

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessAddGroupNameQuery %lx: [%.16s].\n", Address, Header->DestinationName);
    }

    //
    // Allocate a UI frame from the pool.
    //

    if (NbfCreateConnectionlessFrame (DeviceContext, &RawFrame) != STATUS_SUCCESS) {
        return STATUS_ABANDONED;        // no resources to do this.
    }


    //
    // Build the MAC header. ADD_NAME_RESPONSE frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        ResponseSR,
        SourceRoutingLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructAddNameResponse (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NETBIOS_NAME_TYPE_GROUP,        // type of name is GROUP.
        RESPONSE_CORR(Header),          // correlator from rec'd frame.
        (PUCHAR)Header->SourceName);    // NetBIOS name being responded to.

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                    // no loopback.

    return STATUS_ABANDONED;            // don't forward frame to other addr's.
} /* ProcessAddGroupNameQuery */


NTSTATUS
ProcessAddNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_NAME_QUERY frame.  Because
    our caller has already verified that the destination name in the frame
    matches the transport address passed to us, we must simply transmit an
    ADD_NAME_RESPONSE frame and exit with STATUS_ABANDONED.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_UI_FRAME RawFrame;  // ptr to allocated connectionless frame.
    UINT HeaderLength;
    UCHAR TempSR[MAX_SOURCE_ROUTING];
    PUCHAR ResponseSR;

    Address, SourceAddress; // prevent compiler warnings

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessAddNameQuery %lx: [%.16s].\n", Address, Header->DestinationName);
    }

    //
    // Allocate a UI frame from the pool.
    //

    if (NbfCreateConnectionlessFrame (DeviceContext, &RawFrame) != STATUS_SUCCESS) {
        return STATUS_ABANDONED;        // no resources to do this.
    }


    //
    // Build the MAC header. ADD_NAME_RESPONSE frames go out as
    // non-broadcast source routing.
    //

    if (SourceRouting != NULL) {

        RtlCopyMemory(
            TempSR,
            SourceRouting,
            SourceRoutingLength);

        MacCreateNonBroadcastReplySR(
            &DeviceContext->MacInfo,
            TempSR,
            SourceRoutingLength,
            &ResponseSR);

    } else {

        ResponseSR = NULL;

    }

    MacConstructHeader (
        &DeviceContext->MacInfo,
        RawFrame->Header,
        SourceAddress->Address,
        DeviceContext->LocalAddress.Address,
        sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
        ResponseSR,
        SourceRoutingLength,
        &HeaderLength);


    //
    // Build the DLC UI frame header.
    //

    NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
    HeaderLength += sizeof(DLC_FRAME);


    //
    // Build the Netbios header.
    //

    ConstructAddNameResponse (
        (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
        NETBIOS_NAME_TYPE_UNIQUE,       // type of name is UNIQUE.
        RESPONSE_CORR(Header),          // correlator from received frame.
        (PUCHAR)Header->SourceName);    // NetBIOS name being responded to

    HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);


    //
    // Munge the packet length and send it.
    //

    NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

    NbfSendUIFrame (
        DeviceContext,
        RawFrame,
        FALSE);                    // no loopback.

    return STATUS_ABANDONED;            // don't forward frame to other addr's.
} /* ProcessAddNameQuery */


NTSTATUS
ProcessNameInConflict(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_IN_CONFLICT frame.
    Although we can't disrupt any traffic on this address, it is considered
    invalid and cannot be used for any new address files or new connections.
    Therefore, we just mark the address as invalid.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    DeviceContext, Header, SourceAddress; // prevent compiler warnings


    //
    // Ignore this if we are registering/deregistering (the name will
    // go away anyway) or if we have already marked this name as
    // in conflict and logged an error.
    //

    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameInConflict %lx: address marked [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;
    }

    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
        NbfPrint2 ("ProcessNameInConflict %lx: [%.16s].\n", Address, Header->SourceName);
    }

#if 0
    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    Address->Flags |= ADDRESS_FLAGS_CONFLICT;

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    DbgPrint ("NBF: Name-in-conflict on <%.16s> from ", Header->DestinationName);
    DbgPrint ("%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
        SourceAddress->Address[0],
        SourceAddress->Address[1],
        SourceAddress->Address[2],
        SourceAddress->Address[3],
        SourceAddress->Address[4],
        SourceAddress->Address[5]);
#endif

    NbfWriteGeneralErrorLog(
        Address->Provider,
        EVENT_TRANSPORT_BAD_PROTOCOL,
        2,
        STATUS_DUPLICATE_NAME,
        L"NAME_IN_CONFLICT",
        16/sizeof(ULONG),
        (PULONG)(Header->DestinationName));

    return STATUS_ABANDONED;

} /* ProcessNameInConflict */


NTSTATUS
NbfIndicateDatagram(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PUCHAR Dsdu,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine processes an incoming DATAGRAM or DATAGRAM_BROADCAST frame.
    BROADCAST and normal datagrams have the same receive logic, except
    for broadcast datagrams Address will be the broadcast address.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Dsdu - Pointer to a Mdl buffer that contains the received datagram.
        The first byte of information in the buffer is the first byte in
        the NetBIOS connectionless header, and it is already negotiated that
        the data link layer will provide at least the entire NetBIOS header
        as contiguous data.

    Length - The length of the MDL pointed to by Dsdu.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PLIST_ENTRY p, q;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG IndicateBytesCopied, MdlBytesCopied, BytesToCopy;
    TA_NETBIOS_ADDRESS SourceName;
    TA_NETBIOS_ADDRESS DestinationName;
    PTDI_CONNECTION_INFORMATION remoteInformation;
    ULONG returnLength;
    PTP_ADDRESS_FILE addressFile, prevaddressFile;
    PTDI_CONNECTION_INFORMATION DatagramInformation;
    TDI_ADDRESS_NETBIOS * DatagramAddress;
    PNBF_HDR_CONNECTIONLESS Header = (PNBF_HDR_CONNECTIONLESS)Dsdu;

    IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
        NbfPrint0 ("NbfIndicateDatagram:  Entered.\n");
    }

    //
    // If this datagram wasn't big enough for a transport header, then don't
    // let the caller look at any data.
    //

    if (Length < sizeof(NBF_HDR_CONNECTIONLESS)) {
        IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
            NbfPrint0 ("NbfIndicateDatagram: Short datagram abandoned.\n");
        }
        return STATUS_ABANDONED;
    }

    //
    // Update our statistics.
    //

    ++DeviceContext->Statistics.DatagramsReceived;
    ADD_TO_LARGE_INTEGER(
        &DeviceContext->Statistics.DatagramBytesReceived,
        Length - sizeof(NBF_HDR_CONNECTIONLESS));


    //
    // Call the client's ReceiveDatagram indication handler.  He may
    // want to accept the datagram that way.
    //

    TdiBuildNetbiosAddress ((PUCHAR)Header->SourceName, FALSE, &SourceName);
    TdiBuildNetbiosAddress ((PUCHAR)Header->DestinationName, FALSE, &DestinationName);


    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    //
    // Find the first open address file in the list.
    //

    p = Address->AddressFileDatabase.Flink;
    while (p != &Address->AddressFileDatabase) {
        addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
        if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
            p = p->Flink;
            continue;
        }
        NbfReferenceAddressFile(addressFile);
        break;
    }

    while (p != &Address->AddressFileDatabase) {

        //
        // do we have a datagram receive request outstanding? If so, we will
        // satisfy it first. We run through the receive datagram queue
        // until we find a datagram with no remote address or with
        // this sender's address as its remote address.
        //

        for (q = addressFile->ReceiveDatagramQueue.Flink;
            q != &addressFile->ReceiveDatagramQueue;
            q = q->Flink) {

            irp = CONTAINING_RECORD (q, IRP, Tail.Overlay.ListEntry);
            DatagramInformation = ((PTDI_REQUEST_KERNEL_RECEIVEDG)
                &((IoGetCurrentIrpStackLocation(irp))->
                    Parameters))->ReceiveDatagramInformation;

            if (DatagramInformation &&
                (DatagramInformation->RemoteAddress) &&
                (DatagramAddress = NbfParseTdiAddress(DatagramInformation->RemoteAddress, FALSE)) &&
                (!RtlEqualMemory(
                    Header->SourceName,
                    DatagramAddress->NetbiosName,
                    NETBIOS_NAME_LENGTH))) {
                continue;
            }
            break;
        }

        if (q != &addressFile->ReceiveDatagramQueue) {
            KIRQL  cancelIrql;


            RemoveEntryList (q);
            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
                NbfPrint0 ("NbfIndicateDatagram: Receive datagram request found, copying.\n");
            }

            //
            // Copy the actual user data.
            //

            MdlBytesCopied = 0;

            BytesToCopy = Length - sizeof(NBF_HDR_CONNECTIONLESS);

            if ((BytesToCopy > 0) && irp->MdlAddress) {
                status = TdiCopyBufferToMdl (
                             Dsdu,
                             sizeof(NBF_HDR_CONNECTIONLESS),       // offset
                             BytesToCopy,                          // length
                             irp->MdlAddress,
                             0,
                             &MdlBytesCopied);
            } else {
                status = STATUS_SUCCESS;
            }

            //
            // Copy the addressing information.
            //

            irpSp = IoGetCurrentIrpStackLocation (irp);
            remoteInformation =
                ((PTDI_REQUEST_KERNEL_RECEIVEDG)(&irpSp->Parameters))->
                                                        ReturnDatagramInformation;
            if (remoteInformation != NULL) {
                try {
                    if (remoteInformation->RemoteAddressLength != 0) {
                        if (remoteInformation->RemoteAddressLength >=
                                               sizeof (TA_NETBIOS_ADDRESS)) {

                            RtlCopyMemory (
                             (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                             &SourceName,
                             sizeof (TA_NETBIOS_ADDRESS));

                            returnLength = sizeof(TA_NETBIOS_ADDRESS);
                            remoteInformation->RemoteAddressLength = returnLength;

                        } else {

                            RtlCopyMemory (
                             (PTA_NETBIOS_ADDRESS)remoteInformation->RemoteAddress,
                             &SourceName,
                             remoteInformation->RemoteAddressLength);

                            returnLength = remoteInformation->RemoteAddressLength;
                            remoteInformation->RemoteAddressLength = returnLength;

                        }

                    } else {

                        returnLength = 0;
                    }

                    status = STATUS_SUCCESS;

                } except (EXCEPTION_EXECUTE_HANDLER) {

                    returnLength = 0;
                    status = GetExceptionCode ();

                }

            }

            IoAcquireCancelSpinLock(&cancelIrql);
            IoSetCancelRoutine(irp, NULL);
            IoReleaseCancelSpinLock(cancelIrql);
            irp->IoStatus.Information = MdlBytesCopied;
            irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (irp, IO_NETWORK_INCREMENT);

            NbfDereferenceAddress ("Receive DG done", Address, AREF_REQUEST);

        } else {

            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            //
            // no receive datagram requests; is there a kernel client?
            //

            if (addressFile->RegisteredReceiveDatagramHandler) {

                IndicateBytesCopied = 0;

                status = (*addressFile->ReceiveDatagramHandler)(
                             addressFile->ReceiveDatagramHandlerContext,
                             sizeof (TA_NETBIOS_ADDRESS),
                             &SourceName,
                             0,
                             NULL,
                             TDI_RECEIVE_COPY_LOOKAHEAD,
                             Length - sizeof(NBF_HDR_CONNECTIONLESS),  // indicated
                             Length - sizeof(NBF_HDR_CONNECTIONLESS),  // available
                             &IndicateBytesCopied,
                             Dsdu + sizeof(NBF_HDR_CONNECTIONLESS),
                             &irp);

                if (status == STATUS_SUCCESS) {

                    //
                    // The client accepted the datagram and so we're done.
                    //

                } else if (status == STATUS_DATA_NOT_ACCEPTED) {

                    //
                    // The client did not accept the datagram and we need to satisfy
                    // a TdiReceiveDatagram, if possible.
                    //

                    IF_NBFDBG (NBF_DEBUG_DATAGRAMS) {
                        NbfPrint0 ("NbfIndicateDatagram: Picking off a rcv datagram request from this address.\n");
                    }
                    status = STATUS_MORE_PROCESSING_REQUIRED;

                } else if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                    //
                    // The client returned an IRP that we should queue up to the
                    // address to satisfy the request.
                    //

                    irp->IoStatus.Status = STATUS_PENDING;  // init status information.
                    irp->IoStatus.Information = 0;
                    irpSp = IoGetCurrentIrpStackLocation (irp); // get current stack loctn.
                    if ((irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL) ||
                        (irpSp->MinorFunction != TDI_RECEIVE_DATAGRAM)) {
                        irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                        return status;
                    }

                    //
                    // Now copy the actual user data.
                    //

                    MdlBytesCopied = 0;

                    BytesToCopy = Length - sizeof(NBF_HDR_CONNECTIONLESS) - IndicateBytesCopied;

                    if ((BytesToCopy > 0) && irp->MdlAddress) {
                        status = TdiCopyBufferToMdl (
                                     Dsdu,
                                     sizeof(NBF_HDR_CONNECTIONLESS) + IndicateBytesCopied,
                                     BytesToCopy,
                                     irp->MdlAddress,
                                     0,
                                     &MdlBytesCopied);
                    } else {
                        status = STATUS_SUCCESS;
                    }

                    irp->IoStatus.Information = MdlBytesCopied;
                    irp->IoStatus.Status = status;
                    LEAVE_NBF;
                    IoCompleteRequest (irp, IO_NETWORK_INCREMENT);
                    ENTER_NBF;
                }
            }
        }

        //
        // Save this to dereference it later.
        //

        prevaddressFile = addressFile;

        //
        // Reference the next address file on the list, so it
        // stays around.
        //

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

        p = p->Flink;
        while (p != &Address->AddressFileDatabase) {
            addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
            if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                p = p->Flink;
                continue;
            }
            NbfReferenceAddressFile(addressFile);
            break;
        }

        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

        //
        // Now dereference the previous address file with
        // the lock released.
        //

        NbfDereferenceAddressFile (prevaddressFile);

        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    }    // end of while loop

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    return status;                      // to dispatcher.
} /* NbfIndicateDatagram */


NTSTATUS
ProcessNameQuery(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_QUERY frame.  There are two
    types of NAME_QUERY frames, with basically the same layout.  If the
    session number in the frame is 0, then the frame is really a request
    for information about the name, and not a request to establish a
    session.  If the session number is non-zero, then the frame is a
    connection request that we use to satisfy a listen.

    With the new version of TDI, we now indicate the user that a request
    for connection has been received, iff there is no outstanding listen.
    If this does occur, the user can return a connection that is to be used
    to accept the connection on.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_UI_FRAME RawFrame;
    PTP_CONNECTION Connection;
    PTP_LINK Link;
    UCHAR NameType;
    BOOLEAN ConnectIndicationBlocked = FALSE;
    PLIST_ENTRY p;
    UINT HeaderLength;
    PUCHAR GeneralSR;
    UINT GeneralSRLength;
    BOOLEAN UsedListeningConnection = FALSE;
    PTP_ADDRESS_FILE addressFile, prevaddressFile;
    PIRP acceptIrp;

    CONNECTION_CONTEXT connectionContext;
    TA_NETBIOS_ADDRESS RemoteAddress;

    //
    // If we are just registering or deregistering this address, then don't
    // allow state changes.  Just throw the packet away, and let the frame
    // distributor try the next address.
    //
    // Also drop it if the address is in conflict.
    //

    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameQuery %lx: address not stable [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_SUCCESS;
    }

    //
    // Process this differently depending on whether it is a find name
    // request or an incoming connection.
    //

    if (Header->Data2Low == 0) {

        //
        // This is a find-name request.  Respond with a NAME_RECOGNIZED frame.
        //
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameQuery %lx: find name [%.16s].\n", Address, Header->SourceName);
        }

        NbfSendNameRecognized(
            Address,
            0,                   // LSN 0 == FIND_NAME response
            Header,
            SourceAddress,
            SourceRouting,
            SourceRoutingLength);

        return STATUS_ABANDONED;        // don't allow multiple responses.

    } else { // (if Data2Low is non-zero)

        //
        // This is an incoming connection request.  If we have a listening
        // connection on this address, then continue with the connection setup.
        // If there is no outstanding listen, then indicate any kernel mode
        // clients that want to know about this frame. If a listen was posted,
        // then a connection has already been set up for it.  The LSN field of
        // the connection is set to 0, so we look for the first 0 LSN in the
        // database.
        //

        //
        // First, check if we already have an active connection with
        // this remote on this address. If so, we resend the NAME_RECOGNIZED
        // if we have not yet received the SESSION_INITIALIZE; otherwise
        // we ignore the frame.
        //

        //
        // If successful this adds a reference of type CREF_LISTENING.
        //

        if (Connection = NbfLookupRemoteName(Address, (PUCHAR)Header->SourceName, Header->Data2Low)) {

            //
            // We have an active connection on this guy, see if he
            // still appears to be waiting to a NAME_RECOGNIZED.
            //

            if (((Connection->Flags & CONNECTION_FLAGS_WAIT_SI) != 0) &&
                (Connection->Link != (PTP_LINK)NULL) &&
                (Connection->Link->State == LINK_STATE_ADM)) {

                //
                // Yes, he must have dropped a previous NAME_RECOGNIZED
                // so we send another one.
                //

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2("Dup NAME_QUERY found: %lx [%.16s]\n", Connection, Header->SourceName);
                }

                NbfSendNameRecognized(
                    Address,
                    Connection->Lsn,
                    Header,
                    SourceAddress,
                    SourceRouting,
                    SourceRoutingLength);

            } else {

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2("Dup NAME_QUERY ignored: %lx [%.16s]\n", Connection, Header->SourceName);
                }

            }

            NbfDereferenceConnection ("Lookup done", Connection, CREF_LISTENING);

            return STATUS_ABANDONED;

        }

        // If successful, this adds a reference which is removed before
        // this function returns.

        Connection = NbfLookupListeningConnection (Address, (PUCHAR)Header->SourceName);
        if (Connection == NULL) {

            //
            // not having a listening connection is not reason to bail out here.
            // we need to indicate to the user that a connect attempt occurred,
            // and see if there is a desire to use this connection. We
            // indicate in order to all address files that are
            // using this address.
            //
            // If we already have an indication pending on this address,
            // we ignore this frame (the NAME_QUERY may have come from
            // a different address, but we can't know that). Also, if
            // there is already an active connection on this remote
            // name, then we ignore the frame.
            //


            ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

            p = Address->AddressFileDatabase.Flink;
            while (p != &Address->AddressFileDatabase) {
                addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
                if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                    p = p->Flink;
                    continue;
                }
                NbfReferenceAddressFile(addressFile);
                break;
            }

            while (p != &Address->AddressFileDatabase) {

                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

                if ((addressFile->RegisteredConnectionHandler == TRUE) &&
                    (!addressFile->ConnectIndicationInProgress)) {


                    TdiBuildNetbiosAddress (
                        (PUCHAR)Header->SourceName,
                        FALSE,
                        &RemoteAddress);

                    addressFile->ConnectIndicationInProgress = TRUE;

                    //
                    // we have a connection handler, now indicate that a connection
                    // attempt occurred.
                    //

                    status = (addressFile->ConnectionHandler)(
                                 addressFile->ConnectionHandlerContext,
                                 sizeof (TA_NETBIOS_ADDRESS),
                                 &RemoteAddress,
                                 0,
                                 NULL,
                                 0,
                                 NULL,
                                 &connectionContext,
                                 &acceptIrp);

                    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                        //
                        // the user has connected a currently open connection, but
                        // we have to figure out which one it is.
                        //

                        //
                        // If successful this adds a reference of type LISTENING
                        // (the same what NbfLookupListeningConnection adds).
                        //

                        Connection = NbfLookupConnectionByContext (
                                        Address,
                                        connectionContext);

                        if (Connection == NULL) {

                            //
                            // We have to tell the client that
                            // his connection is bogus (or has this
                            // already happened??).
                            //

                            NbfPrint0("STATUS_MORE_PROCESSING, connection not found\n");
                            addressFile->ConnectIndicationInProgress = FALSE;
                            acceptIrp->IoStatus.Status = STATUS_INVALID_CONNECTION;
                            IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                            goto whileend;    // try next address file

                        } else {

                            if (Connection->AddressFile->Address != Address) {
                                addressFile->ConnectIndicationInProgress = FALSE;

                                NbfPrint0("STATUS_MORE_PROCESSING, address wrong\n");
                                NbfStopConnection (Connection, STATUS_INVALID_ADDRESS);
                                NbfDereferenceConnection("Bad Address", Connection, CREF_LISTENING);
                                Connection = NULL;
                                acceptIrp->IoStatus.Status = STATUS_INVALID_ADDRESS;
                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                goto whileend;    // try next address file
                            }

                            //
                            // OK, we have a valid connection. If the response to
                            // this connection was disconnect, we need to reject
                            // the connection request and return. If it was accept
                            // or not specified (to be done later), we simply
                            // fall through and continue processing on the U Frame.
                            //
                            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                            if ((Connection->Flags2 & CONNECTION_FLAGS2_DISCONNECT) != 0) {

//                                Connection->Flags2 &= ~CONNECTION_FLAGS2_DISCONNECT;
                                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                                NbfPrint0("STATUS_MORE_PROCESSING, disconnect\n");
                                addressFile->ConnectIndicationInProgress = FALSE;
                                NbfDereferenceConnection("Disconnecting", Connection, CREF_LISTENING);
                                Connection = NULL;
                                acceptIrp->IoStatus.Status = STATUS_INVALID_CONNECTION;
                                IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);

                                goto whileend;    // try next address file
                            }

                        }

                        //
                        // Make a note that we have to set
                        // addressFile->ConnectIndicationInProgress to
                        // FALSE once the address is safely stored
                        // in the connection.
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint4 ("ProcessNameQuery %lx: indicate DONE, context %lx conn %lx [%.16s].\n", Address, connectionContext, Connection, Header->SourceName);
                        }
                        IF_NBFDBG (NBF_DEBUG_SETUP) {
                            NbfPrint6 ("Link is %x-%x-%x-%x-%x-%x\n",
                                        SourceAddress->Address[0],
                                        SourceAddress->Address[1],
                                        SourceAddress->Address[2],
                                        SourceAddress->Address[3],
                                        SourceAddress->Address[4],
                                        SourceAddress->Address[5]);
                        }

                        //
                        // Set up our flags...we turn on REQ_COMPLETED
                        // so that disconnect will be indicated if the
                        // connection goes down before a session init
                        // is received.
                        //

                        Connection->Flags2 &= ~CONNECTION_FLAGS2_STOPPING;
                        Connection->Status = STATUS_PENDING;
                        Connection->Flags2 |= (CONNECTION_FLAGS2_ACCEPTED |
                                               CONNECTION_FLAGS2_REQ_COMPLETED);
                        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                        ConnectIndicationBlocked = TRUE;
                        NbfDereferenceAddressFile (addressFile);
                        acceptIrp->IoStatus.Status = STATUS_SUCCESS;
                        IoCompleteRequest (acceptIrp, IO_NETWORK_INCREMENT);
                        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);
                        break;    // exit the while

#if 0
                    } else if (status == STATUS_EVENT_PENDING) {

                        //
                        // user has returned a connectionContext, use that for further
                        // processing of the connection. First validate it so
                        // we can know we won't just start a connection and never
                        // finish.
                        //
                        //
                        // If successful this adds a reference of type LISTENING
                        // (the same what NbfLookupListeningConnection adds).
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint3 ("ProcessNameQuery %lx: indicate PENDING, context %lx [%.16s].\n", Address, connectionContext, Header->SourceName);
                        }


                        Connection = NbfLookupConnectionByContext (
                                        Address,
                                        connectionContext);

                        if (Connection == NULL) {

                            //
                            // We have to tell the client that
                            // his connection is bogus (or has this
                            // already happened??).
                            //

                            NbfPrint0("STATUS_MORE_PROCESSING, but connection not found\n");
                            addressFile->ConnectIndicationInProgress = FALSE;

                            goto whileend;    // try next address file.

                        } else {

                            if (Connection->AddressFile->Address != Address) {
                                addressFile->ConnectIndicationInProgress = FALSE;
                                NbfStopConnection (Connection, STATUS_INVALID_ADDRESS);
                                NbfDereferenceConnection("Bad Address", Connection, CREF_LISTENING);
                                Connection = NULL;

                                goto whileend;    // try next address file.
                            }

                        }

                        //
                        // Make a note that we have to set
                        // addressFile->ConnectionIndicatInProgress to
                        // FALSE once the address is safely stored
                        // in the connection.
                        //

                        ConnectIndicationBlocked = TRUE;
                        NbfDereferenceAddressFile (addressFile);
                        ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);
                        break;    // exit the while
#endif

                    } else if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        //
                        // we know the address, but can't create a connection to
                        // use on it. This gets passed to the network as a response
                        // saying I'm here, but can't help.
                        //

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint2 ("ProcessNameQuery %lx: indicate RESOURCES [%.16s].\n", Address, Header->SourceName);
                        }

                        addressFile->ConnectIndicationInProgress = FALSE;

                        //
                        // We should send a NR with LSN 0xff, indicating
                        // no resources, but LM 2.0 does not interpret
                        // that correctly. So, we send LSN 0 (no listens)
                        // instead.
                        //

                        NbfSendNameRecognized(
                            Address,
                            0,
                            Header,
                            SourceAddress,
                            SourceRouting,
                            SourceRoutingLength);

                        NbfDereferenceAddressFile (addressFile);
                        return STATUS_ABANDONED;

                    } else {

                        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                            NbfPrint2 ("ProcessNameQuery %lx: indicate invalid [%.16s].\n", Address, Header->SourceName);
                        }

                        addressFile->ConnectIndicationInProgress = FALSE;

                        goto whileend;    // try next address file

                    } // end status ifs

                } else {

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint2 ("ProcessNameQuery %lx: no handler [%.16s].\n", Address, Header->SourceName);
                    }

                    goto whileend;     // try next address file

                } // end no indication handler

whileend:
                //
                // Jumping here is like a continue, except that the
                // addressFile pointer is advanced correctly.
                //

                //
                // Save this to dereference it later.
                //

                prevaddressFile = addressFile;

                //
                // Reference the next address file on the list, so it
                // stays around.
                //

                ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

                p = p->Flink;
                while (p != &Address->AddressFileDatabase) {
                    addressFile = CONTAINING_RECORD (p, TP_ADDRESS_FILE, Linkage);
                    if (addressFile->State != ADDRESSFILE_STATE_OPEN) {
                        p = p->Flink;
                        continue;
                    }
                    NbfReferenceAddressFile(addressFile);
                    break;
                }

                RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

                //
                // Now dereference the previous address file with
                // the lock released.
                //

                NbfDereferenceAddressFile (prevaddressFile);

                ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

            } // end of loop through the address files.

            RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

            if (Connection == NULL) {

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint2 ("ProcessNameQuery %lx: no connection [%.16s].\n", Address, Header->SourceName);
                }

                //
                // We still did not find a connection after looping
                // through the address files.
                //

                NbfSendNameRecognized(
                    Address,
                    0,                   // LSN 0 == No listens
                    Header,
                    SourceAddress,
                    SourceRouting,
                    SourceRoutingLength);

                //
                // We used to return MORE_PROCESSING_REQUIRED, but
                // since we matched with this address, no other
                // address is going to match, so abandon it.
                //

                return STATUS_ABANDONED;

            }

        } else { // end connection == null

            UsedListeningConnection = TRUE;

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameQuery %lx: found listen %lx: [%.16s].\n", Address, Connection, Header->SourceName);
            }

        }


        //
        // At this point the connection has a reference of type
        // CREF_LISTENING. Allocate a UI frame from the pool.
        //

        status = NbfCreateConnectionlessFrame (DeviceContext, &RawFrame);
        if (!NT_SUCCESS (status)) {                // no resources to respond.
            PANIC ("ProcessNameQuery: Can't get UI Frame, dropping query\n");
            if (ConnectIndicationBlocked) {
                addressFile->ConnectIndicationInProgress = FALSE;
            }
            if (UsedListeningConnection) {
                Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;
            } else {
                Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;
                NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
            }
            NbfDereferenceConnection("Can't get UI Frame", Connection, CREF_LISTENING);
            return STATUS_ABANDONED;
        }

        //
        // Build the MAC header. NAME_RECOGNIZED frames go out as
        // general-route source routing.
        //

        MacReturnGeneralRouteSR(
            &DeviceContext->MacInfo,
            &GeneralSR,
            &GeneralSRLength);


        MacConstructHeader (
            &DeviceContext->MacInfo,
            RawFrame->Header,
            SourceAddress->Address,
            DeviceContext->LocalAddress.Address,
            sizeof (DLC_FRAME) + sizeof (NBF_HDR_CONNECTIONLESS),
            GeneralSR,
            GeneralSRLength,
            &HeaderLength);


        //
        // Build the DLC UI frame header.
        //

        NbfBuildUIFrameHeader(&RawFrame->Header[HeaderLength]);
        HeaderLength += sizeof(DLC_FRAME);


        //
        // Before we continue, store the remote guy's transport address
        // into the TdiListen's TRANSPORT_CONNECTION buffer.  This allows
        // the client to determine who called him.
        //

        Connection->CalledAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        TdiCopyLookaheadData(
            Connection->CalledAddress.NetbiosName,
            Header->SourceName,
            16,
            DeviceContext->MacInfo.CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

        RtlCopyMemory( Connection->RemoteName, Connection->CalledAddress.NetbiosName, 16 );
        Connection->Flags2 |= CONNECTION_FLAGS2_REMOTE_VALID;

        if (ConnectIndicationBlocked) {
            addressFile->ConnectIndicationInProgress = FALSE;
        }

        //
        // Now formulate a reply.
        //

        NameType = (UCHAR)((Address->Flags & ADDRESS_FLAGS_GROUP) ?
                            NETBIOS_NAME_TYPE_GROUP : NETBIOS_NAME_TYPE_UNIQUE);

        //
        // We have a listening connection on the address now. Create a link
        // for it to be associated with and make that link ready. Respond to
        // the sender with a name_recognized frame.  then we will receive our
        // first connection-oriented frame, SESSION_INITIALIZE, handled
        // in IFRAMES.C.  Then we respond with SESSION_CONFIRM, and then
        // the TdiListen completes.
        //

        // If successful, this adds a link reference which is removed
        // in NbfDisconnectFromLink. It does NOT add a link reference.

        status = NbfCreateLink (
                     DeviceContext,
                     SourceAddress,         // remote hardware address.
                     SourceRouting,
                     SourceRoutingLength,
                     LISTENER_LINK,         // for loopback link
                     &Link);                // resulting link.

        if (NT_SUCCESS (status)) {             // link established.

            ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            // If successful, this adds a connection reference
            // which is removed in NbfDisconnectFromLink

            if (((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) == 0) &&
                ((status = NbfConnectToLink (Link, Connection)) == STATUS_SUCCESS)) {

                Connection->Flags |= CONNECTION_FLAGS_WAIT_SI; // wait for SI.
                Connection->Retries = 1;
                Connection->Rsn = Header->Data2Low; // save remote LSN.
                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                NbfWaitLink (Link);          // start link going.

                ConstructNameRecognized (   // build a good response.
                    (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
                    NameType,               // type of local name.
                    Connection->Lsn,        // return our LSN.
                    RESPONSE_CORR(Header),  // new xmit corr.
                    0,                      // our response correlator (unused).
                    Header->DestinationName,// our NetBIOS name.
                    Header->SourceName);    // his NetBIOS name.


                HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);
                NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

                //
                // Now, to avoid problems with hanging listens, we'll start the
                // connection timer and give a limited period for the connection
                // to succeed. This avoids waiting forever for those first few
                // frames to be exchanged. When the timeout occurs, the
                // the dereference will cause the circuit to be torn down.
                //
                // The maximum delay we can accomodate on a link is
                // NameQueryRetries * NameQueryTimeout (assuming the
                // remote has the same timeous). There are three
                // exchanges of packets until the SESSION_INITIALIZE
                // shows up, to be safe we multiply by four.
                //

                NbfStartConnectionTimer(
                    Connection,
                    NbfListenTimeout,
                    4 * DeviceContext->NameQueryRetries * DeviceContext->NameQueryTimeout);

                NbfSendUIFrame (
                    DeviceContext,
                    RawFrame,
                    TRUE);            // loopback if needed.

                IF_NBFDBG (NBF_DEBUG_SETUP) {
                    NbfPrint2("Connection %lx on link %lx\n", Connection, Link);
                }

                NbfDereferenceConnection("ProcessNameQuery", Connection, CREF_LISTENING);
                return STATUS_ABANDONED;    // successful!
            }

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            //
            // We don't have a free LSN to allocate, so fall through to
            // report "no resources".
            //

            // We did a link reference since NbfCreateLink succeeded,
            // but since NbfConnectToLink failed we will never remove
            // that reference in NbfDisconnectFromLink, so do it here.

            NbfDereferenceLink ("No more LSNS", Link, LREF_CONNECTION);

            ASSERT (Connection->Lsn == 0);

        }

        //
        // If we fall through here, then we couldn't get resources to set
        // up this connection, so just send him a "no resources" reply.
        //

        if (UsedListeningConnection) {

            Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NQ;   // put this back.

        } else {

            Connection->Flags2 |= CONNECTION_FLAGS2_REQ_COMPLETED;
            NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);

        }

        //
        // We should send a NR with LSN 0xff, indicating
        // no resources, but LM 2.0 does not interpret
        // that correctly. So, we send LSN 0 (no listens)
        // instead.
        //

        ConstructNameRecognized (
            (PNBF_HDR_CONNECTIONLESS)&(RawFrame->Header[HeaderLength]),
            NameType,
            0,                                  // LSN=0 means no listens
            RESPONSE_CORR(Header),
            0,
            Header->DestinationName,            // our NetBIOS name.
            Header->SourceName);                // his NetBIOS name.

        HeaderLength += sizeof(NBF_HDR_CONNECTIONLESS);
        NbfSetNdisPacketLength(RawFrame->NdisPacket, HeaderLength);

        NbfSendUIFrame (
            DeviceContext,
            RawFrame,
            TRUE);                        // loopback if needed.

        NbfDereferenceConnection("ProcessNameQuery done", Connection, CREF_LISTENING);
    }

    return STATUS_ABANDONED;

} /* ProcessNameQuery */


NTSTATUS
ProcessAddNameResponse(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming ADD_NAME_RESPONSE frame.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    BOOLEAN SendNameInConflict = FALSE;
    UNREFERENCED_PARAMETER(DeviceContext);

    ACQUIRE_DPC_SPIN_LOCK (&Address->SpinLock);

    //
    // If we aren't trying to register this address, then the sender of
    // this frame is bogus.  We cannot allow our state to change based
    // on the reception of a random frame.
    //

    if (!(Address->Flags & ADDRESS_FLAGS_REGISTERING)) {
        RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);
        IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_UFRAMES) {
            NbfPrint2("ProcessAddNameResponse %lx: not registering [%.16s]\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;        // just destroy the packet.
    }

    //
    // Unfortunately, we are registering this address and another host
    // on the network is also attempting to register the same NetBIOS
    // name on the same network.  Because he got to us first, we cannot
    // register our name.  Thus, the address must die. We set this flag
    // and on the next timeout we will shut down.
    //

    Address->Flags |= ADDRESS_FLAGS_DUPLICATE_NAME;

    if (Header->Data2Low == NETBIOS_NAME_TYPE_UNIQUE) {

        //
        // If we have already gotten a response from someone saying
        // this address is uniquely owned, then make sure any future
        // responses come from the same MAC address.
        //

        if ((*((LONG UNALIGNED *)Address->UniqueResponseAddress) == 0) &&
            (*((SHORT UNALIGNED *)(&Address->UniqueResponseAddress[4])) == 0)) {

            RtlMoveMemory(Address->UniqueResponseAddress, SourceAddress->Address, 6);

        } else if (!RtlEqualMemory(
                       Address->UniqueResponseAddress,
                       SourceAddress->Address,
                       6)) {

            if (!Address->NameInConflictSent) {
                SendNameInConflict = TRUE;
            }

        }

    } else {

        //
        // For group names, make sure nobody else decided that it was
        // a unique address.
        //

        if ((*((LONG UNALIGNED *)Address->UniqueResponseAddress) != 0) ||
            (*((SHORT UNALIGNED *)(&Address->UniqueResponseAddress[4])) != 0)) {

            if (!Address->NameInConflictSent) {
                SendNameInConflict = TRUE;
            }

        }

    }

    RELEASE_DPC_SPIN_LOCK (&Address->SpinLock);

    if (SendNameInConflict) {

        Address->NameInConflictSent = TRUE;
        NbfSendNameInConflict(
            Address,
            (PUCHAR)Header->DestinationName);

    }


    IF_NBFDBG (NBF_DEBUG_ADDRESS | NBF_DEBUG_UFRAMES) {
        NbfPrint2("ProcessAddNameResponse %lx: stopping [%.16s]\n", Address, Header->SourceName);
    }

    return STATUS_ABANDONED;            // done with this frame.
} /* ProcessAddNameResponse */


NTSTATUS
ProcessNameRecognized(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PTP_ADDRESS Address,
    IN PNBF_HDR_CONNECTIONLESS Header,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength
    )

/*++

Routine Description:

    This routine processes an incoming NAME_RECOGNIZED frame.  This frame
    is received because we issued a NAME_QUERY frame to actively initiate
    a connection with a remote host.

    When we return STATUS_MORE_PROCESSING_REQUIRED, the caller of
    this routine will continue to call us for each address for the device
    context.  When we return STATUS_SUCCESS, the caller will switch to the
    next address.  When we return any other status code, including
    STATUS_ABANDONED, the caller will stop distributing the frame.

Arguments:

    DeviceContext - Pointer to our device context.

    Address - Pointer to the transport address object.

    Header - Pointer to the connectionless NetBIOS header of the frame.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    SourceRouting - Pointer to the source routing information in
        the frame.

    SourceRoutingLength - Length of the source routing information.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PTP_CONNECTION Connection;
    PTP_LINK Link;
    BOOLEAN TimerCancelled;


    if (Address->Flags & (ADDRESS_FLAGS_REGISTERING | ADDRESS_FLAGS_DEREGISTERING | ADDRESS_FLAGS_CONFLICT)) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameRecognized %lx: address not stable [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;        // invalid address state, drop packet.
    }

    //
    // Find names and connections both require a TP_CONNECTION to work.
    // In either case, the ConnectionId field of the TP_CONNECTION object
    // was sent as the response correlator in the NAME_QUERY frame, so
    // we should get the same correlator back in this frame in the
    // transmit correlator.  Because this number is unique across
    // all the connections on an address, we can determine if the frame
    // was for this address or not.
    //

    // this causes a reference which is removed before this function returns.

    Connection = NbfLookupConnectionById (
                    Address,
                    TRANSMIT_CORR(Header));

    //
    // has he been deleted while we were waiting?
    //

    if (Connection == NULL) {
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint2 ("ProcessNameRecognized %lx: no connection [%.16s].\n", Address, Header->SourceName);
        }
        return STATUS_ABANDONED;
    }

    //
    // This frame is a response to a NAME_QUERY frame that we previously
    // sent to him.  Either he's returning "insufficient resources",
    // indicating that a session cannot be established, or he's initiated
    // his side of the connection.
    //

    ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

    if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) != 0) {

        //
        // Connection is stopping, don't process this.
        //

        RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint3 ("ProcessNameRecognized %lx: connection %lx stopping [%.16s].\n", Address, Connection, Header->SourceName);
        }

        NbfDereferenceConnection("Name Recognized, stopping", Connection, CREF_BY_ID);

        return STATUS_ABANDONED;
    }

    if (Header->Data2Low == 0x00 ||
        (Header->Data2Low > 0x00 && (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR_FN))) {     // no listens, or FIND.NAME response.

        if (!(Connection->Flags2 & CONNECTION_FLAGS2_CONNECTOR)) {

            //
            // This is just a find name request, we are not trying to
            // establish a connection.  Currently, there is no reason
            // for this to occur, so just save some room to add this
            // extra feature later to support NETBIOS find name.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx not connector [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection("Unexpected FN Response", Connection, CREF_BY_ID);
            return STATUS_ABANDONED;            // we processed the frame.
        }

        //
        // We're setting up a session.  If we are waiting for the first NAME
        // RECOGNIZED, then setup the link and send the second NAME_QUERY.
        // If we're waiting for the second NAME_RECOGNIZED, then he didn't
        // have an LSN to finish the connection, so tear it down.
        //

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR_FN) {

            //
            // Now that we know the data link address of the remote host
            // we're connecting to, we need to create a TP_LINK object to
            // represent the data link between these two machines.  If there
            // is already a data link there, then the object will be reused.
            //

            Connection->Flags2 &= ~CONNECTION_FLAGS2_WAIT_NR_FN;

            if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                //
                // The Netbios address we are connecting to is a
                // unique name

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint3 ("ProcessNameRecognized %lx: connection %lx send 2nd NQ [%.16s].\n", Address, Connection, Header->SourceName);
                }


                // If successful, this adds a link reference which is removed
                // in NbfDisconnectFromLink

                status = NbfCreateLink (
                             DeviceContext,
                             SourceAddress,         // remote hardware address.
                             SourceRouting,
                             SourceRoutingLength,
                             CONNECTOR_LINK,        // for loopback link
                             &Link);                // resulting link.

                if (!NT_SUCCESS (status)) {            // no resources.
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("No Resources for link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                // If successful, this adds a connection reference which is
                // removed in NbfDisconnectFromLink. It does NOT add a link ref.

                if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
                    ((status = NbfConnectToLink (Link, Connection)) != STATUS_SUCCESS)) {

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    // Connection stopping or no LSN's available on this link.
                    // We did a link reference since NbfCreateLink succeeded,
                    // but since NbfConnectToLink failed we will never remove
                    // that reference in NbfDisconnectFromLink, so do it here.

                    NbfDereferenceLink ("Can't connect to link", Link, LREF_CONNECTION);       // most likely destroys this.

                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("Cant connect to link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                (VOID)InterlockedIncrement(&Link->NumberOfConnectors);

            } else {

                //
                // We are connecting to a group name; we have to
                // assign an LSN now, but we don't connect to
                // the link until we get a committed name response.
                //

                Connection->Flags2 |= CONNECTION_FLAGS2_GROUP_LSN;

                IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                    NbfPrint3 ("ProcessNameRecognized %lx: connection %lx send 2nd NQ GROUP [%.16s].\n", Address, Connection, Header->SourceName);
                }

                if (NbfAssignGroupLsn(Connection) != STATUS_SUCCESS) {

                    //
                    // Could not find an empty LSN; have to fail.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection("Can't get group LSN", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;

                }

            }


            //
            // Send the second NAME_QUERY frame, committing our LSN to
            // the remote guy.
            //

            Connection->Flags2 |= CONNECTION_FLAGS2_WAIT_NR;
            Connection->Retries = (USHORT)DeviceContext->NameQueryRetries;
            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            NbfStartConnectionTimer (
                Connection,
                ConnectionEstablishmentTimeout,
                DeviceContext->NameQueryTimeout);

            KeQueryTickCount (&Connection->ConnectStartTime);

            NbfSendNameQuery(
                Connection,
                TRUE);

            NbfDereferenceConnection ("Done with lookup", Connection, CREF_BY_ID); // release lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        } else if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            if (Connection->Link) {

                if (RtlEqualMemory(
                        Connection->Link->HardwareAddress.Address,
                        SourceAddress->Address,
                        6)) {

                    //
                    // Unfortunately, he's telling us that he doesn't have resources
                    // to allocate an LSN. We set a flag to record this and
                    // ignore the frame.
                    //

                    Connection->Flags2 |= CONNECTION_FLAGS2_NO_LISTEN;
                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint3 ("ProcessNameRecognized %lx: connection %lx no listens [%.16s].\n", Address, Connection, Header->SourceName);
                    }

                } else {

                    //
                    // This response comes from a different remote from the
                    // last one. For unique names this indicates a duplicate
                    // name on the network.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                        if (!Address->NameInConflictSent) {

                            Address->NameInConflictSent = TRUE;
                            NbfSendNameInConflict(
                                Address,
                                (PUCHAR)Header->SourceName);

                        }
                    }

                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint3 ("ProcessNameRecognized %lx: connection %lx name in conflict [%.16s].\n", Address, Connection, Header->SourceName);
                    }

                }

            } else {

                //
                // The response came back so fast the connection is
                // not stable, ignore it.
                //

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            NbfDereferenceConnection ("No remote resources", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        } else {

            //
            // Strange state.  This should never happen, because we should be
            // either waiting for a first or second name recognized frame.  It
            // is possible that the remote station received two frames because
            // of our retransmits, and so he responded to both.  Toss the frame.
            //

            if (Connection->Link) {

                if (!RtlEqualMemory(
                        Connection->Link->HardwareAddress.Address,
                        SourceAddress->Address,
                        6)) {

                    //
                    // This response comes from a different remote from the
                    // last one. For unique names this indicates a duplicate
                    // name on the network.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (Header->Data2High == NETBIOS_NAME_TYPE_UNIQUE) {

                        if (!Address->NameInConflictSent) {

                            Address->NameInConflictSent = TRUE;
                            NbfSendNameInConflict(
                                Address,
                                (PUCHAR)Header->SourceName);

                        }

                    }

                } else {

                    //
                    // This is the same remote, just ignore it.
                    //

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                }

            } else {

                //
                // The response came back so fast the connection is
                // not stable, ignore it.
                //

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }

    } else if (Header->Data2Low == 0xff) { // no resources to complete connection.

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            //
            // The recipient of our previously-sent NAME_QUERY frame that we sent
            // to actively establish a connection has unfortunately run out of
            // resources and cannot setup his side of the connection.  We have to
            // report "no resources" on the TdiConnect.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx no resources [%.16s].\n", Address, Connection, Header->SourceName);
            }

            IF_NBFDBG (NBF_DEBUG_TEARDOWN) {
                NbfPrint0 ("ProcessNameRecognized:  No resources.\n");
            }

            NbfStopConnection (Connection, STATUS_REMOTE_RESOURCES);
            NbfDereferenceConnection ("No Resources", Connection, CREF_BY_ID);   // release our lookup hold.
            return STATUS_ABANDONED;                // we processed the frame.

        } else {

            //
            // We don't have a committed NAME_QUERY out there, so
            // we ignore this frame.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected no resources [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }

    } else {    // Data2Low is in the range 0x01-0xfe

        if (Connection->Flags2 & CONNECTION_FLAGS2_WAIT_NR) {

            //
            // This is a successful response to a second NAME_QUERY we sent when
            // we started processing a TdiConnect request.  Clear the "waiting
            // for Name Recognized" bit in the connection flags so that the
            // connection timer doesn't blow us away when it times out.
            //
            //         What prevents the timeout routine from running while
            //         we're in here and destroying the connection/link by
            //         calling NbfStopConnection?
            //

            Connection->Flags2 &= ~CONNECTION_FLAGS2_WAIT_NR;

            //
            // Before we continue, store the remote guy's transport address
            // into the TdiConnect's TRANSPORT_CONNECTION buffer.  This allows
            // the client to determine who responded to his TdiConnect.
            //
            // this used to be done prior to sending the second
            // Name Query, but since I fixed the Buffer2 problem, meaning
            // that I really do overwrite the input buffer with the
            // output buffer, that was screwing up the second query.
            // Note that doing the copy after sending is probably unsafe
            // in the case where the second Name Recognized arrives
            // right away.
            //

            Connection->CalledAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            TdiCopyLookaheadData(
                Connection->CalledAddress.NetbiosName,
                Header->SourceName,
                16,
                DeviceContext->MacInfo.CopyLookahead ? TDI_RECEIVE_COPY_LOOKAHEAD : 0);

            RtlCopyMemory( Connection->RemoteName, Header->SourceName, 16 );

            Connection->Rsn = Header->Data2Low;     // save his remote LSN.

            //
            // Save the correlator from the NR for eventual use in the
            // SESSION_INITIALIZE frame.
            //

            Connection->NetbiosHeader.TransmitCorrelator = RESPONSE_CORR(Header);

            //
            // Cancel the timer; it would have no effect since WAIT_NR
            // is not set, but there is no need for it to run. We cancel
            // it with the lock held so it won't interfere with the
            // timer's use when a connection is closing.
            //

            TimerCancelled = KeCancelTimer (&Connection->Timer);

            if ((Connection->Flags2 & CONNECTION_FLAGS2_GROUP_LSN) != 0) {

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                //
                // The Netbios address we are connecting to is a
                // group name; we need to connect to the link
                // now that we have the committed session.
                //

                // If successful, this adds a link reference which is removed
                // in NbfDisconnectFromLink

                status = NbfCreateLink (
                             DeviceContext,
                             SourceAddress,         // remote hardware address.
                             SourceRouting,
                             SourceRoutingLength,
                             CONNECTOR_LINK,        // for loopback link
                             &Link);                // resulting link.

                if (!NT_SUCCESS (status)) {            // no resources.
                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("No Resources for link", Connection, CREF_BY_ID);

                    if (TimerCancelled) {
                        NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
                    }

                    return STATUS_ABANDONED;
                }

                ACQUIRE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                // If successful, this adds a connection reference which is
                // removed in NbfDisconnectFromLink. It does NOT add a link ref.

                if ((Connection->Flags2 & CONNECTION_FLAGS2_STOPPING) ||
                    ((status = NbfConnectToLink (Link, Connection)) != STATUS_SUCCESS)) {

                    RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                    if (TimerCancelled) {
                        NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
                    }

                    // Connection stopping or no LSN's available on this link.
                    // We did a link reference since NbfCreateLink succeeded,
                    // but since NbfConnectToLink failed we will never remove
                    // that reference in NbfDisconnectFromLink, so do it here.

                    NbfDereferenceLink ("Can't connect to link", Link, LREF_CONNECTION);       // most likely destroys this.

                    NbfStopConnection (Connection, STATUS_INSUFFICIENT_RESOURCES);
                    NbfDereferenceConnection ("Cant connect to link", Connection, CREF_BY_ID);
                    return STATUS_ABANDONED;
                }

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

                (VOID)InterlockedIncrement(&Link->NumberOfConnectors);

            } else {

                //
                // It's to a unique address, we set up the link
                // before we sent out the committed NAME_QUERY.
                //

                Link = Connection->Link;

                RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            }

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx session up! [%.16s].\n", Address, Connection, Header->SourceName);
            }

            //
            // When we sent the committed NAME_QUERY, we stored that
            // time in Connection->ConnectStartTime; we can now use
            // that for a rough estimate of the link delay, if this
            // is the first connection on the link. For async lines
            // we do not do this because the delay introduced by the
            // gateway messes up the timing.
            //

            if (!DeviceContext->MacInfo.MediumAsync) {

                ACQUIRE_DPC_SPIN_LOCK (&Link->SpinLock);

                if (Link->State == LINK_STATE_ADM) {

                    //
                    // HACK: Set the necessary variables in the link
                    // so that FakeUpdateBaseT1Timeout works. These
                    // variables are the same ones that FakeStartT1 sets.
                    //

                    Link->CurrentPollSize = Link->HeaderLength + sizeof(DLC_FRAME) + sizeof(NBF_HDR_CONNECTIONLESS);
                    Link->CurrentTimerStart = Connection->ConnectStartTime;
                    FakeUpdateBaseT1Timeout (Link);

                }

                RELEASE_DPC_SPIN_LOCK (&Link->SpinLock);

            }

            if (TimerCancelled) {
                NbfDereferenceConnection("NR received, cancel timer", Connection, CREF_TIMER);
            }

            NbfActivateLink (Connection->Link);      // start link going.

            //
            // We'll get control again in LINK.C when the data link has either
            // been established, denied, or destroyed.  This happens at I/O
            // completion time from NbfCreateLink's PdiConnect request.
            //

        } else {

            //
            // We don't have a committed NAME_QUERY out there, so
            // we ignore this frame.
            //

            RELEASE_DPC_C_SPIN_LOCK (&Connection->SpinLock);

            IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                NbfPrint3 ("ProcessNameRecognized %lx: connection %lx unexpected session up! [%.16s].\n", Address, Connection, Header->SourceName);
            }

            NbfDereferenceConnection ("Tossing second response Done with lookup", Connection, CREF_BY_ID); // release our lookup hold.
            return STATUS_ABANDONED;            // we processed the frame.

        }


    }

    NbfDereferenceConnection("ProcessNameRecognized lookup", Connection, CREF_BY_ID);
    return STATUS_ABANDONED;            // don't distribute packet.
} /* ProcessNameRecognized */


NTSTATUS
NbfProcessUi(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PHARDWARE_ADDRESS SourceAddress,
    IN PUCHAR Header,
    IN PUCHAR DlcHeader,
    IN ULONG DlcLength,
    IN PUCHAR SourceRouting,
    IN UINT SourceRoutingLength,
    OUT PTP_ADDRESS * DatagramAddress
    )

/*++

Routine Description:

    This routine receives control from the data link provider as an
    indication that a DLC UI-frame has been received on the data link.
    Here we dispatch to the correct UI-frame handler.

    Part of this routine's job is to optionally distribute the frame to
    every address that needs to look at it.
    We accomplish this by lock-stepping through the address database,
    and for each address that matches the address this frame is aimed at,
    calling the frame handler.

Arguments:

    DeviceContext - Pointer to our device context.

    SourceAddress - Pointer to the source hardware address in the received
        frame.

    Header - Points to the MAC header of the incoming packet.

    DlcHeader - Points to the DLC header of the incoming packet.

    DlcLength - Actual length in bytes of the packet, starting at the
        DlcHeader.

    SourceRouting - Source routing information in the MAC header.

    SourceRoutingLength - The length of SourceRouting.

    DatagramAddress - If this function returns STATUS_MORE_PROCESSING_
        REQUIRED, this will be the address the datagram should be
        indicated to.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PTP_ADDRESS Address;
    PNBF_HDR_CONNECTIONLESS UiFrame;
    NTSTATUS status;
    PLIST_ENTRY Flink;
    UCHAR MatchType;
    BOOLEAN MatchedAddress;
    PUCHAR MatchName;
    ULONG NetbiosLength = DlcLength - 3;

    UiFrame = (PNBF_HDR_CONNECTIONLESS)(DlcHeader + 3);

    //
    // Verify that this frame is long enough to examine and that it
    // has the proper signature.  We can't test the signature as a
    // 16-bit word as specified in the NetBIOS Formats and Protocols
    // manual because this is processor-dependent.
    //

    if ((NetbiosLength < sizeof (NBF_HDR_CONNECTIONLESS)) ||
        (HEADER_LENGTH(UiFrame) != sizeof (NBF_HDR_CONNECTIONLESS)) ||
        (HEADER_SIGNATURE(UiFrame) != NETBIOS_SIGNATURE)) {

        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint0 ("NbfProcessUi: Bad size or NetBIOS signature.\n");
        }
        return STATUS_ABANDONED;        // frame too small or too large.
    }

    //
    // If this frame has a correlator with the high bit on, it was due
    // to a FIND.NAME request; we don't handle those here since they
    // are not per-address.
    //

    if ((UiFrame->Command == NBF_CMD_NAME_RECOGNIZED) &&
        (TRANSMIT_CORR(UiFrame) & 0x8000)) {

        //
        // Make sure the frame is sent to our reserved address;
        // if not, drop it.
        //

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return NbfProcessQueryNameRecognized(
                       DeviceContext,
                       Header,
                       UiFrame);
        } else {

            return STATUS_ABANDONED;

        }
    }

    //
    // If this is a STATUS_RESPONSE, process that separately.
    //

    if (UiFrame->Command == NBF_CMD_STATUS_RESPONSE) {

        //
        // Make sure the frame is sent to our reserved address;
        // if not, drop it.
        //

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return STATUS_MORE_PROCESSING_REQUIRED;

        } else {

            return STATUS_ABANDONED;

        }
    }

    //
    // If this is a STATUS_QUERY, check if it is to our reserved
    // address. If so, we process it. If not, we fall through to
    // the normal checking. This ensures that queries to our
    // reserved address are always processed, even if nobody
    // has opened that address yet.
    //

    if (UiFrame->Command == NBF_CMD_STATUS_QUERY) {

        if (RtlEqualMemory(
                UiFrame->DestinationName,
                DeviceContext->ReservedNetBIOSAddress,
                NETBIOS_NAME_LENGTH)) {

            return NbfProcessStatusQuery(
                       DeviceContext,
                       NULL,
                       UiFrame,
                       SourceAddress,
                       SourceRouting,
                       SourceRoutingLength);

        }

    }

    //
    // We have a valid connectionless NetBIOS protocol frame that's not a
    // datagram, so deliver it to every address which matches the destination
    // name in the frame.  Some frames
    // (NAME_QUERY) cannot be delivered to multiple recipients.  Therefore,
    // if a frame handler returns STATUS_MORE_PROCESSING_REQUIRED, we continue
    // through the remaining addresses. Otherwise simply get out and assume
    // that the frame was eaten.  Thus, STATUS_SUCCESS means that the handler
    // ate the frame and that no other addresses can have it.
    //

    //
    // Determine what kind of lookup we want to do.
    //

    switch (UiFrame->Command) {

    case NBF_CMD_NAME_QUERY:
    case NBF_CMD_DATAGRAM:
    case NBF_CMD_DATAGRAM_BROADCAST:
    case NBF_CMD_ADD_NAME_QUERY:
    case NBF_CMD_STATUS_QUERY:
    case NBF_CMD_ADD_NAME_RESPONSE:
    case NBF_CMD_NAME_RECOGNIZED:

        MatchType = NETBIOS_NAME_TYPE_EITHER;
        break;

    case NBF_CMD_ADD_GROUP_NAME_QUERY:
    case NBF_CMD_NAME_IN_CONFLICT:

        MatchType = NETBIOS_NAME_TYPE_UNIQUE;
        break;

    default:
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            NbfPrint1 ("NbfProcessUi: Frame delivered; Unrecognized command %x.\n",
                UiFrame->Command);
        }
        return STATUS_SUCCESS;
        break;

    }

    if ((UiFrame->Command == NBF_CMD_ADD_GROUP_NAME_QUERY) ||
        (UiFrame->Command == NBF_CMD_ADD_NAME_QUERY)) {

        MatchName = (PUCHAR)UiFrame->SourceName;

    } else if (UiFrame->Command == NBF_CMD_DATAGRAM_BROADCAST) {

        MatchName = NULL;

    } else {

        MatchName = (PUCHAR)UiFrame->DestinationName;

    }

    if (MatchName && DeviceContext->AddressCounts[MatchName[0]] == 0) {
        status = STATUS_ABANDONED;
        goto RasIndication;
    }


    MatchedAddress = FALSE;

    ACQUIRE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    for (Flink = DeviceContext->AddressDatabase.Flink;
         Flink != &DeviceContext->AddressDatabase;
         Flink = Flink->Flink) {

        Address = CONTAINING_RECORD (
                    Flink,
                    TP_ADDRESS,
                    Linkage);

        if ((Address->Flags & ADDRESS_FLAGS_STOPPING) != 0) {
            continue;
        }

        if (NbfMatchNetbiosAddress (Address,
                                    MatchType,
                                    MatchName)) {

            NbfReferenceAddress ("UI Frame", Address, AREF_PROCESS_UI);   // prevent address from being destroyed.
            MatchedAddress = TRUE;
            break;

        }
    }

    RELEASE_DPC_SPIN_LOCK (&DeviceContext->SpinLock);

    if (MatchedAddress) {

        //
        // If the datagram's destination name does not match the address's
        // network name and TSAP components, then skip this address.  Some
        // frames have the source and destination names backwards for this
        // algorithm, so we account for that here.  Also, broadcast datagrams
        // have no destination name in the frame, but get delivered to every
        // address anyway.
        //

#if 0
        IF_NBFDBG (NBF_DEBUG_UFRAMES) {
            USHORT i;
            NbfPrint0 ("NbfProcessUi: SourceName: ");
            for (i=0;i<16;i++) {
                NbfPrint1 ("%c",UiFrame->SourceName[i]);
            }
            NbfPrint0 (" Destination Name:");
            for (i=0;i<16;i++) {
                NbfPrint1 ("%c",UiFrame->DestinationName[i]);
            }
            NbfPrint0 ("\n");
        }
#endif

        //
        // Deliver the frame to the current address.
        //

        switch (UiFrame->Command) {

        case NBF_CMD_NAME_QUERY:

            status = ProcessNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_DATAGRAM:
        case NBF_CMD_DATAGRAM_BROADCAST:

            //
            // Reference the datagram so it sticks around until the
            // ReceiveComplete, when it is processed.
            //

            if ((Address->Flags & ADDRESS_FLAGS_CONFLICT) == 0) {
                NbfReferenceAddress ("Datagram indicated", Address, AREF_PROCESS_DATAGRAM);
                *DatagramAddress = Address;
                status = STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                status = STATUS_ABANDONED;
            }
            break;

        case NBF_CMD_ADD_GROUP_NAME_QUERY:

            //
            // did this frame originate with us? If so, we don't want to
            // do any processing of it.
            //

            if (RtlEqualMemory (
                    SourceAddress,
                    DeviceContext->LocalAddress.Address,
                    DeviceContext->MacInfo.AddressLength)) {

                if ((Address->Flags & ADDRESS_FLAGS_REGISTERING) != 0) {
                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint0 ("NbfProcessUI: loopback AddGroupNameQuery dropped\n");
                    }
                    status = STATUS_ABANDONED;
                    break;
                }
            }

            status = ProcessAddGroupNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);
            break;

        case NBF_CMD_ADD_NAME_QUERY:

            //
            // did this frame originate with us? If so, we don't want to
            // do any processing of it.
            //

            if (RtlEqualMemory (
                    SourceAddress,
                    DeviceContext->LocalAddress.Address,
                    DeviceContext->MacInfo.AddressLength)) {

                if ((Address->Flags & ADDRESS_FLAGS_REGISTERING) != 0) {
                    IF_NBFDBG (NBF_DEBUG_UFRAMES) {
                        NbfPrint0 ("NbfProcessUI: loopback AddNameQuery dropped\n");
                    }
                    status = STATUS_ABANDONED;
                    break;
                }
            }

            status = ProcessAddNameQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);
            break;

        case NBF_CMD_NAME_IN_CONFLICT:

            status = ProcessNameInConflict (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_STATUS_QUERY:

            status = NbfProcessStatusQuery (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_ADD_NAME_RESPONSE:

            status = ProcessAddNameResponse (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        case NBF_CMD_NAME_RECOGNIZED:

            status = ProcessNameRecognized (
                         DeviceContext,
                         Address,
                         UiFrame,
                         SourceAddress,
                         SourceRouting,
                         SourceRoutingLength);

            break;

        default:

            ASSERT(FALSE);

        } /* switch on NetBIOS frame command code */

        NbfDereferenceAddress ("Done", Address, AREF_PROCESS_UI);     // done with previous address.

    } else {

        status = STATUS_ABANDONED;

    }


RasIndication:;

    //
    // Let the RAS clients have a crack at this if they want
    //

    if (DeviceContext->IndicationQueuesInUse) {

        //
        // If RAS has datagram indications posted, and this is a
        // datagram that nobody wanted, then receive it anyway.
        //

        if ((UiFrame->Command == NBF_CMD_DATAGRAM) &&
            (status == STATUS_ABANDONED)) {

            *DatagramAddress = NULL;
            status = STATUS_MORE_PROCESSING_REQUIRED;

        } else if ((UiFrame->Command == NBF_CMD_ADD_NAME_QUERY) ||
            (UiFrame->Command == NBF_CMD_ADD_GROUP_NAME_QUERY) ||
            (UiFrame->Command == NBF_CMD_NAME_QUERY)) {

            NbfActionQueryIndication(
                 DeviceContext,
                 UiFrame);

        }
    }


    return status;

} /* NbfProcessUi */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\tnetbios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetbios.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

    Jerome Nantel (w-jeromn) 23 August 1991

        Add Event Signaling testing

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_CONSOLE_APP
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "
#define TIMEOUT 60000   // Time out for wait, set at 1 minute
#define Hi  "Come here Dave, I need you"

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//  Hard code lana-num that is mapped to XNS

int Limit = 20;

VOID
usage (
    VOID
    )
{
    printf("usage: tnetbios [-n:lan number][-h][-e] <remote computername> <my computername>\n");
    printf("                 -n specifies the lan number (0 is the default)\n");
    printf("                 -h specifies that addresses are hexadecimal numbers \n");
    printf("                     rather than strings.\n");
    printf("                 -e test event signaling for ASYNC calls.  \n");
    printf("                 final two arguments are the remote and local computer names.\n");
}

int
main (argc, argv)
   int argc;
   char *argv[];
{
    NCB myncb;
    CHAR Buffer[128];
    CHAR Buffer2[128];
    int i,j;
    CHAR localName[16];
    CHAR remoteName[16];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    ULONG lanNumber=0;
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    BOOLEAN tevent=FALSE;
    UCHAR lsn;
    UCHAR name_number;
    HANDLE event;

    if ( argc < 3 || argc > 6) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            case 'e':
                tevent = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlen( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlen( argv[i] ));
            }

        }
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    if (tevent) {
        /* Testing event signaling to handle async calls */
        if (( event = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL ) {
            /* Could not get event handle.  Abort */
            printf("Could not test event signaling.\n");
            tevent=FALSE;
        }
    }

    printf( "Starting NetBios\n" );
    {
        LANA_ENUM Enum;
        ClearNcb( &myncb );
        myncb.ncb_command = NCBENUM;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_length = sizeof(Enum);
        myncb.ncb_buffer = &Enum;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            printf( " Enum Failed %x\n", myncb.ncb_retcode );
            return 1;
        }
    }

    //   Reset

    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 0;           // Request resources
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    myncb.ncb_callname[0] = 0;   // 16 sessions
    myncb.ncb_callname[1] = 0;   // 16 commands
    myncb.ncb_callname[2] = 0;   // 8 names
    Netbios( &myncb );

    //   Add name
    ClearNcb( &myncb );
    myncb.ncb_command = NCBADDNAME;
    RtlMoveMemory( myncb.ncb_name, localName, lstrlen(localName));
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );

    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( " Addname Failed %x\n", myncb.ncb_retcode );
        return 1;
    }
    name_number = myncb.ncb_num;

    {
        struct {
            ADAPTER_STATUS AdapterInfo;
            NAME_BUFFER Names[16];
        } AdapterStatus;
        //   Adapter Status
        ClearNcb( &myncb );
        myncb.ncb_command = NCBASTAT;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_length = sizeof( AdapterStatus );
        myncb.ncb_buffer = (CHAR *)&AdapterStatus;
        Netbios( &myncb );
    }
    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( " Adapter Status Failed %x\n", myncb.ncb_retcode );
        return 1;
    }

    for ( j = 0; j <= Limit; j++ ) {

        //   Call
        ClearNcb( &myncb );
        myncb.ncb_command = NCBCALL | ASYNCH;
        RtlMoveMemory( myncb.ncb_name, localName, lstrlen(localName ));
        RtlMoveMemory( myncb.ncb_callname, remoteName, lstrlen( remoteName ));
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_rto = myncb.ncb_rto = 0;//10;  10*500 milliseconds timeout
        myncb.ncb_num = name_number;
        if ( tevent ) myncb.ncb_event = event;
        while ( TRUE) {
            printf("\nStart NCB CALL ");
            Netbios( &myncb );
            printf( " Call returned " );
            if ( tevent ) {
            if ( WaitForSingleObject( event, TIMEOUT ) ) {
                // Wait timed out, no return
                printf("ERROR: Wait timed out, event not signaled.\n");
            }
            } else {
               while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
               printf( "." );
               Sleep(500);

               }
            }
            lsn = myncb.ncb_lsn;

            if ( myncb.ncb_retcode == NRC_GOODRET ) {
                // Success
                printf( " Call completed\n" );
                break;
            }
            printf( " Call completed with error %lx, retry\n", myncb.ncb_retcode );
        }

        for ( i = 0; i <=j ; i++ ) {

            //   Send
            ClearNcb( &myncb );
            myncb.ncb_command = NCBSEND;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Hi );
            myncb.ncb_buffer = Buffer;
            myncb.ncb_lsn = lsn;
            RtlMoveMemory( Buffer, Hi, sizeof( Hi ));
            Netbios( &myncb );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }

            //   Receive
            ClearNcb( &myncb );
            myncb.ncb_command = NCBRECV | ASYNCH;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Buffer2 );
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            if ( tevent ) myncb.ncb_event = event;
                Netbios( &myncb );
                printf( "R" );
            if ( tevent ) {
            if ( WaitForSingleObject( event, TIMEOUT ) ) {
                // Wait timed out, no return
                printf("ERROR: Wait timed out, event not signaled.\n");
            }
            } else {
               while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
               printf( "." );
               Sleep(500);

               }
            }
            printf( "r" );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
            // printf( ":%s\n", Buffer2);
        }

        //  Hangup
        ClearNcb( &myncb );
        myncb.ncb_command = NCBHANGUP;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_lsn = lsn;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 1;           // Free resources
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );
    printf( "Ending NetBios\n" );

    if (tevent ) {
      // Close handle
      CloseHandle( event );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\netbios.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    netbios.c

Abstract:

    This is the component of netbios that runs in the user process
    passing requests to \Device\Netbios.

Author:

    Colin Watson (ColinW) 15-Mar-91

Revision History:

    Ram Cherala (RamC) 31-Aug-95 Added a try/except around the code which
                                 calls the post routine in SendAddNcbToDriver
                                 function. Currently if there is an exception
                                 in the post routine this thread will die
                                 before it has a chance to call the
                                 "AddNameThreadExit" function to decrement
                                 the trhead count. This will result in not
                                 being able to shut down the machine without
                                 hitting the reset switch.
--*/

/*
Notes:

     +-----------+  +------------+   +------------+
     |           |  |            |   |            |
     | User      |  | User       |   | Worker     |
     | Thread 1  |  | Thread 2   |   | thread in  |
     |           |  |            |   | a Post Rtn.|
     +-----+-----+  +-----+------+   +------+-----+
           |Netbios(pncb);|Netbios(pncb);   |
           v              v                 |
     +-----+--------------+-----------------+------+
     |                          ----->    Worker   |    NETAPI.DLL
     |                         WorkQueue  thread   |
     |                          ----->             |
     +--------------------+------------------------+
                          |
                +---------+---------+
                |                   |
                | \Device\Netbios   |
                |                   |
                +-------------------+

The netbios Worker thread is created automatically by the Netbios call
when it determines that the user threads are calling Netbios() with
calls that use a callback routine (called a Post routine in the NetBIOS
specification).

When a worker thread has been created, all requests will be sent via
the WorkQueue to the worker thread for submission to \Device\Netbios.
This ensures that send requests go on the wire in the same
order as the send ncb's are presented. Because the IO system cancels all
a threads requests when it terminates, the use of the worker thread allows
such a request inside \Device\Netbios to complete normally.

All Post routines are executed by the Worker thread. This allows any Win32
synchronization mechanisms to be used between the Post routine and the
applications normal code.

The Worker thread terminates when the process exits or when it gets
an exception such as an access violation.

In addition. If the worker thread gets an addname it will create an
extra thread which will process the addname and then die. This solves
the problem that the netbios driver will block the users thread during an
addname (by calling NtCreateFile) even if the caller specified ASYNCH. The
same code is also used for ASTAT which also creates handles and can take a
long time now that we support remote adapter status.

*/

#include <netb.h>
#include <lmcons.h>
#include <netlib.h>

#if defined(UNICODE)
#define NETBIOS_SERVICE_NAME L"netbios"
#else
#define NETBIOS_SERVICE_NAME "netbios"
#endif

BOOL Initialized;

CRITICAL_SECTION Crit;      //  protects WorkQueue & initialization.

LIST_ENTRY WorkQueue;       //  queue to worker thread.

HANDLE Event;               //  doorbell used when WorkQueue added too.

HANDLE WorkerHandle;        //  Return value when worker thread created.
HANDLE WaiterHandle;        //  Return value when waiter thread created.

HANDLE NB;                  //  This processes handle to \Device\Netbios.

HANDLE ReservedEvent;       //  Used for synchronous calls
LONG   EventUse;            //  Prevents simultaneous use of ReservedEvent

HANDLE AddNameEvent;        //  Doorbell used when an AddName worker thread
                            //  exits.
volatile LONG   AddNameThreadCount;


//
// Event used to wait for STOP notification from the Kernel mode NETBIOS.SYS
//

HANDLE StopEvent;

IO_STATUS_BLOCK StopStatusBlock;


#if AUTO_RESET

//
// Event used to wait for RESET notification from the Kernel mode NETBIOS.SYS
// Adapters
//

CRITICAL_SECTION    ResetCS;        // protects access to LanaResetList

LIST_ENTRY          LanaResetList;

NCB                 OutputNCB;

HANDLE              LanaResetEvent; // Event signalled when a new adapter is
                                    // bound to netbios and it needs to be reset

IO_STATUS_BLOCK     ResetStatusBlock;

#endif

HMODULE             g_hModule;


//
// netbios command history
//

NCB_INFO g_QueuedHistory[16];
DWORD g_dwNextQHEntry = 0;

NCB_INFO g_DeQueuedHistory[16];
DWORD g_dwNextDQHEntry = 0;

NCB_INFO g_SyncCmdsHistory[16];
DWORD g_dwNextSCEntry = 0;




VOID
SpinUpAddnameThread(
    IN PNCBI pncb
    );

VOID
AddNameThreadExit(
    VOID
    );

DWORD
SendAddNcbToDriver(
    IN PVOID Context
    );

DWORD
StartNetBIOSDriver(
    VOID
    );

#if AUTO_RESET
VOID
ResetLanaAndPostListen(
);
#endif

NTSTATUS
StartNB(
    OUT OBJECT_ATTRIBUTES *pobjattr,
    IN UNICODE_STRING *punicode,
    OUT IO_STATUS_BLOCK *piosb
)
/*++

Routine Description:

    This routine is a worker function of Netbios. It will try to start NB
    service.

Arguments:
    OUT pobjattr - object attribute
    IN punicode - netbios file name
    OUT piosb - ioblock

Return Value:

    The function value is the status of the operation.

--*/
{
    //
    // Open a handle to \\Device\Netbios
    //

    InitializeObjectAttributes(
            pobjattr,                       // obj attr to initialize
            punicode,                       // string to use
            OBJ_CASE_INSENSITIVE,           // Attributes
            NULL,                           // Root directory
            NULL);                          // Security Descriptor

    return NtCreateFile(
                &NB,                        // ptr to handle
                GENERIC_READ                // desired...
                | GENERIC_WRITE,            // ...access
                pobjattr,                   // name & attributes
                piosb,                      // I/O status block.
                NULL,                       // alloc size.
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_DELETE           // share...
                | FILE_SHARE_READ
                | FILE_SHARE_WRITE,         // ...access
                FILE_OPEN_IF,               // create disposition
                0,                          // ...options
                NULL,                       // EA buffer
                0L );                       // Ea buffer len
}


unsigned char APIENTRY
Netbios(
    IN PNCB pncb
    )
/*++

Routine Description:

    This routine is the applications entry point into netapi.dll to support
    netbios 3.0 conformant applications.

Arguments:

    IN PNCB pncb- Supplies the NCB to be processed. Contents of the NCB and
        buffers pointed to by the NCB will be modified in conformance with
        the netbios 3.0 specification.

Return Value:

    The function value is the status of the operation.

Notes:

    The reserved field is used to hold the IO_STATUS_BLOCK.

    Even if the application specifies ASYNCH, the thread may get blocked
    for a period of time while we open transports, create worker threads
    etc.

--*/
{
    //
    //  pncbi saves doing lots of type casting. The internal form includes
    //  the use of the reserved fields.
    //

    PNCBI pncbi = (PNCBI) pncb;

    NTSTATUS ntStatus;

    BOOL    bPending = FALSE;



    if ( ((ULONG_PTR)pncbi & 3) != 0)
    {
        //
        //  NCB must be 32 bit aligned
        //

        pncbi->ncb_retcode = pncbi->ncb_cmd_cplt = NRC_BADDR;
        return NRC_BADDR;
    }


    //
    // using this field to fix bug # 293765
    //

    pncbi-> ncb_reserved = 0;


    //
    //  Conform to Netbios 3.0 specification by flagging request in progress
    //

    pncbi->ncb_retcode = pncbi->ncb_cmd_cplt = NRC_PENDING;

    DisplayNcb( pncbi );

    if ( !Initialized )
    {
        EnterCriticalSection( &Crit );

        //
        //  Check again to see if another thread got into the critical section
        //  and initialized the worker thread.
        //

        if ( !Initialized )
        {

            IO_STATUS_BLOCK iosb;
            OBJECT_ATTRIBUTES objattr;
            UNICODE_STRING unicode;

            HANDLE Threadid;
            BOOL Flag;


            //
            // 1. start netbios driver
            //

            //
            // Open handle to \\Device\Netbios
            //

            RtlInitUnicodeString( &unicode, NB_DEVICE_NAME);

            ntStatus = StartNB( &objattr, &unicode, &iosb );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                //
                // Load the driver
                //

                DWORD err = 0;

                err = StartNetBIOSDriver();

                if ( err )
                {
                    pncbi->ncb_retcode = NRC_OPENERR;
                    pncbi->ncb_cmd_cplt = NRC_OPENERR;

                    NbPrintf( ( "[NETAPI32] Failed to load driver : %lx\n",
                                 err ));

                    LeaveCriticalSection( &Crit );

                    return pncbi->ncb_cmd_cplt;
                }

                else
                {
                    //
                    // Driver loaded.
                    // Open handle to \\Device\Netbios
                    //

                    ntStatus = StartNB( &objattr, &unicode, &iosb );

                    if ( !NT_SUCCESS( ntStatus ) )
                    {
                        pncbi->ncb_retcode = NRC_OPENERR;
                        pncbi->ncb_cmd_cplt = NRC_OPENERR;

                        NbPrintf( ( "[NETAPI32] Failed to open handle : %X\n",
                                     ntStatus ));

                        LeaveCriticalSection( &Crit );

                        return pncbi->ncb_cmd_cplt;
                    }
                }
            }


            //
            // 2. create a reserved (reusable) event for internal use
            //

            ntStatus = NtCreateEvent(
                            &ReservedEvent, EVENT_ALL_ACCESS,
                            NULL, SynchronizationEvent, FALSE
                            );

            if ( !NT_SUCCESS( ntStatus) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Reserved Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }

            EventUse = 1;


            //
            //  Initialize shared datastructures
            //

            //
            // create a queue for work items to be queued to the Worker thread
            //

            InitializeListHead( &WorkQueue );


            //
            // 4. create an event to communicate with the Worker thread
            //

            ntStatus = NtCreateEvent(
                        &Event, EVENT_ALL_ACCESS,
                        NULL, SynchronizationEvent, FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


            //
            // 5.
            // create an event to synchronize ADD name operations with
            // Lana Reset operations.  Both these are performed in separate
            // threads and RESET operations are gated by the ADD names
            //

            ntStatus = NtCreateEvent(
                        &AddNameEvent, EVENT_ALL_ACCESS,
                        NULL, NotificationEvent, FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create AddName Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


            //
            // 6. Create an event to register for stop notification.
            //

            ntStatus = NtCreateEvent(
                        &StopEvent,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create StopEvent Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }


#if AUTO_RESET

            //
            // 7. Create an event to register for reset notification.
            //

            ntStatus = NtCreateEvent(
                        &LanaResetEvent,
                        EVENT_ALL_ACCESS,
                        NULL,
                        SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( ntStatus ) )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create StopEvent Event : %X\n",
                             ntStatus ) );

                LeaveCriticalSection( &Crit );

                NtClose( StopEvent );
                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }
#endif

            //
            // 8. create a worker thread to handle async. Netbios requests
            //

            {
                TCHAR   szFileName[MAX_PATH + 1];
                GetModuleFileName(g_hModule, szFileName,
                                  sizeof(szFileName) / sizeof(TCHAR));
                LoadLibrary(szFileName);
            }

            WaiterHandle = CreateThread(
                            NULL,   //  Standard thread attributes
                            0,      //  Use same size stack as users
                                    //  application
                            NetbiosWaiter,
                                    //  Routine to start in new thread
                            0,      //  Parameter to thread
                            0,      //  No special CreateFlags
                            (LPDWORD)&Threadid
                            );

            if ( WaiterHandle == NULL )
            {
                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create Waiter thread" ) );

                LeaveCriticalSection( &Crit );

                NtClose( StopEvent );
                NtClose( AddNameEvent );
                NtClose( Event );
                NtClose( ReservedEvent );
                NtClose( NB );
                NB = NULL;

                return pncbi->ncb_cmd_cplt;
            }

            NbPrintf( ( "Waiter handle: %lx, threadid %lx\n", WaiterHandle, Threadid ) );
        }

        Initialized = TRUE;

        LeaveCriticalSection( &Crit );

    }


    //
    // Verify that handle to \\Device\Netbios is still open.
    //

    if ( NB == NULL )
    {
        pncbi->ncb_retcode = NRC_OPENERR;
        pncbi->ncb_cmd_cplt = NRC_OPENERR;

        NbPrintf( ("[NETAPI32] Netbios service has been stopped\n") );

        return pncbi->ncb_cmd_cplt;
    }


    //
    // Disallow simultaneous use of both event and callback routine.
    // This will cut down the test cases by disallowing a weird feature.
    //

    if ( (  ( pncbi->ncb_command & ASYNCH) != 0) &&
            ( pncbi->ncb_event) &&
            ( pncbi->ncb_post ) )
    {
        pncbi->ncb_retcode = NRC_ILLCMD;
        pncbi->ncb_cmd_cplt = NRC_ILLCMD;

        NbPrintf( ( "[NETAPI32] Event and Post Routine specified\n" ) );

        return pncbi->ncb_cmd_cplt;
    }



    //
    // if synchronous command
    //

    if ( (pncb->ncb_command & ASYNCH) == 0 )
    {
        NTSTATUS Status;
        LONG EventOwned;


        // NbPrint( ("[NETAPI32] Synchronpus netbios call\n") );


        //
        //  Caller wants a synchronous call so ignore ncb_post and ncb_event.
        //
        //  We need an event so that we can pause if STATUS_PENDING is returned.
        //

        EventOwned = InterlockedDecrement( &EventUse );

        //
        //  If EventUse went from 1 to 0 then we obtained ReservedEvent
        //

        if ( EventOwned == 0)
        {
            pncbi->ncb_event = ReservedEvent;
        }
        else
        {
            InterlockedIncrement( &EventUse );

            Status = NtCreateEvent(
                        &pncbi->ncb_event, EVENT_ALL_ACCESS,
                        NULL, SynchronizationEvent,
                        FALSE
                        );

            if ( !NT_SUCCESS( Status ) )
            {
                //
                //  Failed to create event
                //

                pncbi->ncb_retcode = NRC_SYSTEM;
                pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                NbPrintf( ( "[NETAPI32] Failed to create event : %X\n", Status ) );

                return pncbi->ncb_cmd_cplt;
            }
        }


        pncbi-> ncb_post = NULL;

        //
        // Check if the worker thread has been created.  If it has queue workitem
        // to it.  Else use the caller's thread to execute synchronous NCB command
        //

        if ( WorkerHandle == NULL )
        {
            ADD_SYNCCMD_ENTRY(pncbi);

            //
            // Worker thread has not been created.  Execute in the context of
            // invoker's thread.
            //

            SendNcbToDriver( pncbi );
        }

        else
        {
            //
            // Queue Netbios command to worker thread and wait for APC to fire
            //

            QueueToWorker( pncbi );
        }


        do
        {
            ntStatus = NtWaitForSingleObject(
                            pncbi->ncb_event, TRUE, NULL
                            );

        } while ( ( ntStatus == STATUS_USER_APC ) ||
                  ( ntStatus == STATUS_ALERTED) );


        ASSERT( ntStatus == STATUS_SUCCESS );

        if ( !NT_SUCCESS(ntStatus) )
        {
            NbPrintf(( "[NETAPI32] NtWaitForSingleObject failed: %X\n", ntStatus ) );

            pncbi->ncb_retcode = NRC_SYSTEM;
            pncbi->ncb_cmd_cplt = NRC_SYSTEM;
        }


        //
        // release the local event used to wait for
        // completion of netbios command
        //

        if ( EventOwned == 0)
        {
            InterlockedIncrement( &EventUse );
        }
        else
        {
            NtClose( pncbi->ncb_event );
        }

        pncbi-> ncb_event = NULL;
    }

    else
    {
        //
        // Async netbios command.  Queue to worker thread
        //

        //
        // Check if worker exists.
        //

        if ( WorkerHandle == NULL )
        {
            EnterCriticalSection( &Crit );

            //
            // verify that worker thread has not been created by
            // while this thread was waiting in EnterCriticalSection
            //

            if ( WorkerHandle == NULL )
            {
               HANDLE Threadid;
               BOOL Flag;

               //
               // create a worker thread to handle async. Netbios requests
               //

               WorkerHandle = CreateThread(
                               NULL,   //  Standard thread attributes
                               0,      //  Use same size stack as users
                                       //  application
                               NetbiosWorker,
                                       //  Routine to start in new thread
                               0,      //  Parameter to thread
                               0,      //  No special CreateFlags
                               (LPDWORD)&Threadid
                               );

               if ( WorkerHandle == NULL )
               {
                   pncbi->ncb_retcode = NRC_SYSTEM;
                   pncbi->ncb_cmd_cplt = NRC_SYSTEM;

                   NbPrintf( ( "[NETAPI32] Failed to create Worker thread" ) );

                   LeaveCriticalSection( &Crit );

                   return pncbi->ncb_cmd_cplt;
               }

               Flag = SetThreadPriority(
                           WorkerHandle,
                           THREAD_PRIORITY_ABOVE_NORMAL
                           );

               ASSERT( Flag == TRUE );

               if ( Flag != TRUE )
               {
                   NbPrintf(
                    ("[NETAPI32] Worker SetThreadPriority: %lx\n", GetLastError() )
                    );
               }

               AddNameThreadCount = 0;

               NbPrintf( ( "Worker handle: %lx, threadid %lx\n", WorkerHandle, Threadid ) );
           }

           LeaveCriticalSection( &Crit );
       }

       // NbPrint( ("[NETAPI32] Asynchronpus netbios call\n") );

       bPending = TRUE;
       QueueToWorker( pncbi );
    }


    switch ( pncb->ncb_command & ~ASYNCH )
    {
    case NCBRECV:
    case NCBRECVANY:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBENUM:
    case NCBASTAT:
    case NCBSSTAT:
    case NCBCANCEL:
    case NCBCALL:
        DisplayNcb( pncbi );
    }


    if ( bPending )
    {
        return NRC_GOODRET;
    }
    else
    {
        return pncbi->ncb_cmd_cplt;
    }

} // NetBios



DWORD
StartNetBIOSDriver(
    VOID
)
/*++

Routine Description:

    Starts the netbios.sys driver using the service controller

Arguments:

    none

Returns:

    Error return from service controller.

++*/
{

    DWORD err = NO_ERROR;
    SC_HANDLE hSC;
    SC_HANDLE hSCService;


    hSC = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );

    if (hSC == NULL)
    {
        return(GetLastError());
    }

    hSCService = OpenService( hSC, NETBIOS_SERVICE_NAME, SERVICE_START );

    if (hSCService == NULL)
    {
        CloseServiceHandle(hSC);
        return(GetLastError());
    }

    if ( !StartService( hSCService, 0, NULL ) )
    {
        err = GetLastError();
    }
    CloseServiceHandle(hSCService);
    CloseServiceHandle(hSC);


    if ( err )
    {
        NbPrintf( ("[NETAPI32] LEAVING StartNetBIOSDriver, Error : %d\n", err) );
    }

    return(err);

}



VOID
QueueToWorker(
    IN PNCBI pncb
    )
/*++

Routine Description:

    This routine queues an ncb to the worker thread.

Arguments:

    IN PNCBI pncb - Supplies the NCB to be processed. Contents of the NCB and
        buffers pointed to by the NCB will be modified in conformance with
        the netbios 3.0 specification.

Return Value:

    The function value is the status of the operation.

--*/
{
    if ( pncb->ncb_event != NULL ) {
        NtResetEvent( pncb->ncb_event, NULL );
    }

    EnterCriticalSection( &Crit );

    if ( pncb-> ncb_reserved == 0 ) {
        InsertTailList( &WorkQueue, &pncb->u.ncb_next );
        pncb-> ncb_reserved = 1;

        //
        // Note queued distory
        //

        ADD_QUEUE_ENTRY(pncb);
    }

    LeaveCriticalSection( &Crit );

    //  Make sure the worker is awake to perform the request
    NtSetEvent(Event, NULL);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
NetbiosWorker(
    IN LPVOID Parameter
    )
/*++

Routine Description:

    This routine processes ASYNC requests made with the callback interface.
    The reasons for using a seperate thread are:

        1)  If a thread makes an async request and exits while the request
        is outstanding then the request will be cancelled by the IO system.

        2)  A seperate thread must be used so that the users POST routine
        can use normal synchronization APIs to access shared data structures.
        If the users thread is used then deadlock can and will happen.

    The POST routine operates in the context of the worker thread. There are
    no restrictions on what the POST routine can do. For example it can
    submit another ASYNCH request if desired. It will add it to the queue
    of work and set the event as normal.

    The worker thread will die when the process terminates.

Arguments:

    IN PULONG Parameter - supplies an unused parameter.

Return Value:

    none.

--*/
{
    NTSTATUS Status;


    while ( TRUE)
    {
        //
        //  Wait for a request to be placed onto the work queue.
        //

        //
        //  Must wait alertable so that the Apc (post) routine is called.
        //

        Status = NtWaitForSingleObject( Event, TRUE, NULL );

        if ( ( Status == STATUS_SUCCESS ) && ( NB != NULL ) )
        {
            EnterCriticalSection( &Crit );

            //
            // remove each Netbios request and forward it to the NETBIOS driver
            //

            while ( !IsListEmpty( &WorkQueue ) )
            {
                PLIST_ENTRY entry;
                PNCBI pncb;

                entry = RemoveHeadList(&WorkQueue);

                //
                //  Zero out reserved field again
                //

                entry->Flink = entry->Blink = 0;

                pncb = CONTAINING_RECORD( entry, NCBI, u.ncb_next );

                ADD_DEQUEUE_ENTRY(pncb);

                LeaveCriticalSection( &Crit );


                //  Give ncb to the driver specifying the callers APC routine

                if ( (pncb->ncb_command & ~ASYNCH) == NCBRESET )
                {
                    //
                    //  We may have threads adding names. Wait until
                    //  they are complete before submitting the reset.
                    //  Addnames and resets are rare so this should rarely
                    //  affect an application.
                    //

                    EnterCriticalSection( &Crit );

                    NtResetEvent( AddNameEvent, NULL );

                    while ( AddNameThreadCount != 0 )
                    {
                        LeaveCriticalSection( &Crit );

                        NtWaitForSingleObject( AddNameEvent, TRUE, NULL );

                        EnterCriticalSection( &Crit );

                        NtResetEvent( AddNameEvent, NULL );
                    }

                    LeaveCriticalSection( &Crit );
                }


                //
                //  SendNcbToDriver must not be in a critical section since the
                //  request may block if its a non ASYNCH request.
                //

                if (( (pncb->ncb_command & ~ASYNCH) != NCBADDNAME ) &&
                    ( (pncb->ncb_command & ~ASYNCH) != NCBADDGRNAME ) &&
                    ( (pncb->ncb_command & ~ASYNCH) != NCBASTAT ))
                {
                    SendNcbToDriver( pncb );
                }
                else
                {
                    SpinUpAddnameThread( pncb );
                }

                EnterCriticalSection( &Crit );

            }

            LeaveCriticalSection( &Crit );
        }
        else
        if ( NB == NULL )
        {

        }
    }

    return 0;

    UNREFERENCED_PARAMETER( Parameter );
}

DWORD
NetbiosWaiter(
    IN LPVOID Parameter
    )
/*++

Routine Description:

    This routine pends IOCTLs with the kernel mde component of Netbios and
    wait for them to complete.  The reason for a separate thread is that
    these IOCTLs cannot be pended in the context of the user threads as
    exiting the user thread will cause the IOCTL to get cancelled.

    In addition this thread is created at Netbios initialization (refer
    Netbios function) which could (and is) called from the DLL main of
    applications.  So the initialization code cannot wait for this thread
    to be created and initialized due to NT serialization of library
    loads and thread creation.

    To merge this thread with the Worker thread was deemed risky.  To do
    this the worker thread would execute all ASYNC requests and SYNC
    requests would be executed in the context of the user's thread.  This
    was a break from the the previous model where the once the Worker
    thread was created all requests (ASYNC and SYNC) would be executed
    in the context of the worker thread.  To preserve the previous mode
    of operation a separate wait thread was created.  **** There may be
    a better way to do this **** with only one thread but I am not sure.

Arguments:

    IN PULONG Parameter - supplies an unused parameter.

Return Value:

    none.

--*/
{

#if AUTO_RESET

#define POS_STOP            0
#define POS_RESET           1

#endif


    NTSTATUS Status;


    //
    // Send an IOCTL down to the kernel mode Netbios driver, to register
    // for stop notification.  This call should return STATUS_PENDING.
    // The event specified "StopEvent" will be signalled when the netbios
    // driver is being unloaded.
    //

    Status = NtDeviceIoControlFile(
                    NB,
                    StopEvent,
                    NULL, NULL,
                    &StopStatusBlock,
                    IOCTL_NB_REGISTER_STOP,
                    NULL, 0,
                    NULL, 0
                    );

    if ( ( Status != STATUS_PENDING ) &&
         ( Status != STATUS_SUCCESS ) )
    {
        NbPrintf(
            ("[NETAPI32] : Netbios IOCTL for STOP failed with status %lx\n", Status)
            );
    }


#if AUTO_RESET

    Status = NtDeviceIoControlFile(
                    NB,
                    LanaResetEvent,
                    NULL, NULL,
                    &ResetStatusBlock,
                    IOCTL_NB_REGISTER_RESET,
                    NULL, 0,
                    (PVOID) &OutputNCB, sizeof( NCB )
                    );

    if ( ( Status != STATUS_PENDING ) &&
         ( Status != STATUS_SUCCESS ) )
    {
        //
        // Failed to register reset notification.
        //

        NbPrintf(
            ("[NETAPI32] : Netbios : Failed to register Reset event\n" )
            );
    }

#endif


    while ( TRUE )
    {

#if AUTO_RESET

        HANDLE Events[] = {  StopEvent, LanaResetEvent };

        Status = NtWaitForMultipleObjects( 2, Events, WaitAny, TRUE, NULL );

        if ( Status == POS_STOP )
        {
            Status = NtClose( NB );
            InterlockedExchangePointer( (PVOID *) &NB, NULL );

            NbPrintf( ("[NETAPI32] Stop event signaled, Status : %lx\n", Status) );

        }

        else
        if ( ( Status == POS_RESET ) && (NB != NULL ) )
        {
            NbPrintf( ("[NETAPI32] Reset event signaled\n") );

            ResetLanaAndPostListen();
        }
#else

        Status = NtWaitForSingleObject( StopEvent, TRUE, NULL );

        if ( Status == STATUS_SUCCESS )
        {
            NbPrintf( ("[NETAPI32] Stop event signaled\n") );

            NtClose( NB );
            InterlockedExchangePointer( (PVOID *) &NB, NULL );
        }
#endif

    }

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

VOID
SendNcbToDriver(
    IN PNCBI pncb
    )
/*++

Routine Description:

    This routine determines the Device Ioctl code to be used to send the
    ncb to \Device\Netbios and then does the call to send the request
    to the driver.

Arguments:

    IN PNCBI pncb - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    NTSTATUS ntstatus;

    char * buffer;
    unsigned short length;

    //  Use NULL for the buffer if only the NCB is to be passed.

    switch ( pncb->ncb_command & ~ASYNCH ) {
    case NCBSEND:
    case NCBSENDNA:
    case NCBRECV:
    case NCBRECVANY:
    case NCBDGSEND:
    case NCBDGRECV:
    case NCBDGSENDBC:
    case NCBDGRECVBC:
    case NCBASTAT:
    case NCBFINDNAME:
    case NCBSSTAT:
    case NCBENUM:
    case NCBACTION:
        buffer = pncb->ncb_buffer;
        length = pncb->ncb_length;
        break;

    case NCBCANCEL:
        //  The second buffer points to the NCB to be cancelled.
        buffer = pncb->ncb_buffer;
        length = sizeof(NCB);
        NbPrintf(( "[NETAPI32] Attempting to cancel PNCB: %lx\n", buffer ));
        DisplayNcb( (PNCBI)buffer );
        break;

    case NCBCHAINSEND:
    case NCBCHAINSENDNA:
        {
            PUCHAR BigBuffer;   //  Points to the start of BigBuffer, not
                                //  the start of user data.
            PUCHAR FirstBuffer;

            //
            //  There is nowhere in the NCB to save the address of BigBuffer.
            //  The address is needed to free BigBuffer when the transfer is
            //  complete. At the start of BigBuffer, 4 bytes are used to store
            //  the user supplied ncb_buffer value which is restored later.
            //

            BigBuffer = RtlAllocateHeap(
                RtlProcessHeap(), 0,
                sizeof(pncb->ncb_buffer) +
                pncb->ncb_length +
                pncb->cu.ncb_chain.ncb_length2);

            if ( BigBuffer == NULL ) {

                NbPrintf(( "[NETAPI32] The Netbios BigBuffer Allocation failed: %lx\n",
                    pncb->ncb_length + pncb->cu.ncb_chain.ncb_length2));
                pncb->ncb_retcode = NRC_NORES;
                pncb->ncb_cmd_cplt = NRC_NORES;
                pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
                PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
                return;
            }

            NbPrintf(( "[NETAPI32] BigBuffer Allocation: %lx\n", BigBuffer));

            //  Save users buffer address.
            RtlMoveMemory(
                BigBuffer,
                &pncb->ncb_buffer,
                sizeof(pncb->ncb_buffer));

            FirstBuffer = pncb->ncb_buffer;

            pncb->ncb_buffer = BigBuffer;

            //  Copy the user data.
            try {

                RtlMoveMemory(
                    sizeof(pncb->ncb_buffer) + BigBuffer,
                    &FirstBuffer[0],
                    pncb->ncb_length);

                RtlMoveMemory(
                    sizeof(pncb->ncb_buffer) + BigBuffer + pncb->ncb_length,
                    &pncb->cu.ncb_chain.ncb_buffer2[0],
                    pncb->cu.ncb_chain.ncb_length2);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                pncb->ncb_retcode = NRC_BUFLEN;
                pncb->ncb_cmd_cplt = NRC_BUFLEN;
                pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
                ChainSendPostRoutine( pncb, &pncb->u.ncb_iosb, 0);
                return;
            }

            NbPrintf(( "[NETAPI32] Submit chain send pncb: %lx, event: %lx, post: %lx. \n",
                pncb,
                pncb->ncb_event,
                pncb->ncb_post));

            ntstatus = NtDeviceIoControlFile(
                NB,
                NULL,
                ChainSendPostRoutine,                   //  APC Routine
                pncb,                                   //  APC Context
                &pncb->u.ncb_iosb,                      //  IO Status block
                IOCTL_NB_NCB,
                pncb,                                   //  InputBuffer
                sizeof(NCB),
                sizeof(pncb->ncb_buffer) + BigBuffer,   //  Outputbuffer
                pncb->ncb_length + pncb->cu.ncb_chain.ncb_length2);

            if ((ntstatus != STATUS_SUCCESS) &&
                (ntstatus != STATUS_PENDING) &&
                (ntstatus != STATUS_HANGUP_REQUIRED)) {
                NbPrintf(( "[NETAPI32] The Netbios Chain Send failed: %X\n", ntstatus ));

                if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
                    pncb->ncb_retcode = NRC_BUFLEN;
                } else {
                    pncb->ncb_retcode = NRC_SYSTEM;
                }
                ChainSendPostRoutine( pncb, &pncb->u.ncb_iosb, 0);
            }

            NbPrintf(( "[NETAPI32] PNCB: %lx completed, status:%lx, ncb_retcode: %#04x\n",
                pncb,
                ntstatus,
                pncb->ncb_retcode ));

            return;
        }


#if AUTO_RESET

    //
    // added to fix bug : 170107
    //

    //
    // Remember the parameters used in reseting a LANA. LANAs need to
    // be automatically re-reset when they get unbound and bound back to
    // netbios.sys.  This happens in the case of TCPIP devices that renew
    // their IP addresses.
    //

    case NCBRESET :
    {
        PRESET_LANA_NCB prlnTmp;
        PLIST_ENTRY     ple, pleHead;

        buffer = NULL;
        length = 0;


        NbPrintf( (
            "[NETAPI32] : Netbios : reseting adapter %d\n",
            pncb-> ncb_lana_num
            ) );

        //
        // Add Reset NCB to global list
        //

        EnterCriticalSection( &ResetCS );

        //
        // check if already present
        //

        pleHead = &LanaResetList;

        for ( ple = pleHead-> Flink; ple != pleHead; ple = ple-> Flink )
        {
            prlnTmp = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

            if ( prlnTmp-> ResetNCB.ncb_lana_num == pncb-> ncb_lana_num )
            {
                break;
            }
        }


        if ( ple == pleHead )
        {
            //
            // NO reset was performed before for this LANA
            //

            //
            // allocate a NCB entry and copy the NCB used
            //

            prlnTmp = HeapAlloc(
                        GetProcessHeap(), 0, sizeof( RESET_LANA_NCB )
                        );

            if ( prlnTmp == NULL )
            {
                NbPrintf( (
                    "[NETAPI32] : Netbios : Failed to allocate RESET_LANA_NCB"
                    ) );

                LeaveCriticalSection( &ResetCS );

                break;
            }


            ZeroMemory( prlnTmp, sizeof( RESET_LANA_NCB ) );

            InitializeListHead( &prlnTmp-> leList );

            CopyMemory( &prlnTmp-> ResetNCB, pncb, FIELD_OFFSET( NCB, ncb_cmd_cplt ) );

            InsertTailList( &LanaResetList, &prlnTmp-> leList );
        }

        else
        {
            //
            // Lana was previously reset.  Overwrite old parameters.
            //

            CopyMemory( &prlnTmp-> ResetNCB, pncb, FIELD_OFFSET( NCB, ncb_cmd_cplt ) );
        }


        //
        // clear out event/post completion routine when saving the ResetNCB.
        // When this NCB is used to re-issue the reset command, there is no
        // post completion processing to be done.
        //

        prlnTmp-> ResetNCB.ncb_event = NULL;
        prlnTmp-> ResetNCB.ncb_post = NULL;

        //
        // when a reset is re-issued it will always a ASYNC command.
        //

        prlnTmp-> ResetNCB.ncb_command = pncb-> ncb_command | ASYNCH;


        LeaveCriticalSection( &ResetCS );

        break;
    }

#endif

    default:
        buffer = NULL;
        length = 0;
        break;
    }

    // NbPrintf(( "[NETAPI32] Submit pncb: %lx, event: %lx, post: %lx. \n",
    //    pncb,
    //    pncb->ncb_event,
    //    pncb->ncb_post));

    ntstatus = NtDeviceIoControlFile(
                    NB,
                    NULL,
                    PostRoutineCaller,  //  APC Routine
                    pncb,               //  APC Context
                    &pncb->u.ncb_iosb,  //  IO Status block
                    IOCTL_NB_NCB,
                    pncb,               //  InputBuffer
                    sizeof(NCB),
                    buffer,             //  Outputbuffer
                    length );

    if ((ntstatus != STATUS_SUCCESS) &&
        (ntstatus != STATUS_PENDING) &&
        (ntstatus != STATUS_HANGUP_REQUIRED)) {
        NbPrintf(( "[NETAPI32] The Netbios NtDeviceIoControlFile failed: %X\n", ntstatus ));

        NbPrintf(( "[NETAPI32] PNCB: %lx completed, status:%lx, ncb_retcode: %#04x,"
                   "ncb_cmd_cmplt: %#04x\n", pncb, ntstatus, pncb->ncb_retcode,
                   pncb-> ncb_cmd_cplt ));

        if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
            pncb->ncb_retcode = NRC_BUFLEN;
        } else {
            pncb->ncb_retcode = NRC_SYSTEM;
        }
        PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
    }

    return;

}

VOID
SpinUpAddnameThread(
    IN PNCBI pncb
    )
/*++

Routine Description:

    Spin up an another thread so that the worker thread does not block while
    the blocking fsctl is being processed.

Arguments:

    IN PNCBI pncb - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    HANDLE Threadid;
    HANDLE AddNameHandle;

    EnterCriticalSection( &Crit );
    AddNameThreadCount++;
    NtResetEvent( AddNameEvent, NULL );
    LeaveCriticalSection( &Crit );

    AddNameHandle = CreateThread(
                        NULL,   //  Standard thread attributes
                        0,      //  Use same size stack as users
                                //  application
                        SendAddNcbToDriver,
                                //  Routine to start in new thread
                        pncb,   //  Parameter to thread
                        0,      //  No special CreateFlags
                        (LPDWORD)&Threadid);

    if ( AddNameHandle == NULL ) {
        //
        //  Wait a couple of seconds just in case this is a burst
        //  of addnames and we have run out of resources creating
        //  threads. In a couple of seconds one of the other
        //  addname threads should complete.
        //

        Sleep(2000);

        AddNameHandle = CreateThread(
                        NULL,   //  Standard thread attributes
                        0,      //  Use same size stack as users
                                //  application
                        SendAddNcbToDriver,
                                //  Routine to start in new thread
                        pncb,   //  Parameter to thread
                        0,      //  No special CreateFlags
                        (LPDWORD)&Threadid);

        if ( AddNameHandle == NULL ) {

            //
            //  Retry failed. Lower the counts to their values prior to
            //  calling SpinUpAddNameThread
            //

            AddNameThreadExit();

            pncb->ncb_retcode = NRC_NORES;
            NbPrintf(( "[NETAPI32] Create Addname Worker Thread failed\n" ));
            pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
            PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
        } else {
            CloseHandle( AddNameHandle );
        }
    } else {
        CloseHandle( AddNameHandle );
    }
}

VOID
AddNameThreadExit(
    VOID
    )
/*++

Routine Description:

    Keep counts accurate so that any resets being processed by the main
    worker thread block appropriately.

Arguments:

    none.

Return Value:

    none.

--*/
{
    EnterCriticalSection( &Crit );
    AddNameThreadCount--;
    if (AddNameThreadCount == 0) {
        NtSetEvent(AddNameEvent, NULL);
    }
    LeaveCriticalSection( &Crit );
}

DWORD
SendAddNcbToDriver(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to post an addname or adapter status ensuring
    that the worker thread does not block.

Arguments:

    IN PVOID Context - supplies the NCB to be sent to the driver.

Return Value:

    None.

--*/
{
    PNCBI pncb = (PNCBI) Context;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    HANDLE LocalEvent;
    UCHAR  command;
    NTSTATUS ntstatus;
    char * buffer;
    unsigned short length;

    try {
        command = pncb->ncb_command;
        post = pncb->ncb_post;
        event = pncb->ncb_event;

        ntstatus = NtCreateEvent( &LocalEvent,
            EVENT_ALL_ACCESS,
            NULL,
            SynchronizationEvent,
            FALSE );

        if ( !NT_SUCCESS(ntstatus) ) {
            pncb->ncb_retcode = NRC_NORES;
            NbPrintf(( "[NETAPI32] Could not create event\n" ));
            pncb->u.ncb_iosb.Status = STATUS_SUCCESS;
            PostRoutineCaller( pncb, &pncb->u.ncb_iosb, 0);
            AddNameThreadExit();
            return 0;
        }

        //
        //  While the NCB is submitted the driver can modify the contents
        //  of the NCB. We will ensure that this thread waits until the addname
        //  completes before it exits.
        //

        pncb->ncb_command = pncb->ncb_command  & ~ASYNCH;

        if ( pncb->ncb_command == NCBASTAT ) {

            buffer = pncb->ncb_buffer;
            length = pncb->ncb_length;

        } else {

            ASSERT( (pncb->ncb_command == NCBADDNAME) ||
                    (pncb->ncb_command == NCBADDGRNAME) ||
                    (pncb->ncb_command == NCBASTAT) );

            buffer = NULL;
            length = 0;
        }

        ntstatus = NtDeviceIoControlFile(
                        NB,
                        LocalEvent,
                        NULL,               //  APC Routine
                        NULL,               //  APC Context
                        &pncb->u.ncb_iosb,  //  IO Status block
                        IOCTL_NB_NCB,
                        pncb,               //  InputBuffer
                        sizeof(NCB),
                        buffer,             //  Outputbuffer
                        length );

        if ((ntstatus != STATUS_SUCCESS) &&
            (ntstatus != STATUS_PENDING) &&
            (ntstatus != STATUS_HANGUP_REQUIRED)) {
            NbPrintf(( "[NETAPI32] The Netbios NtDeviceIoControlFile failed: %X\n", ntstatus ));

            if ( ntstatus == STATUS_ACCESS_VIOLATION ) {
                pncb->ncb_retcode = NRC_BUFLEN;
            } else {
                pncb->ncb_retcode = NRC_SYSTEM;
            }
        } else {
            do {
                ntstatus = NtWaitForSingleObject(
                              LocalEvent,
                              TRUE,
                              NULL );

            } while ( (ntstatus == STATUS_USER_APC) ||
                      (ntstatus == STATUS_ALERTED) );

            ASSERT(ntstatus == STATUS_SUCCESS);
        }

        pncb->ncb_command = command;

        //  Set the flag that indicates that the NCB is now completed.
        pncb->ncb_cmd_cplt = pncb->ncb_retcode;

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent( event, NULL );
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncb );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncb ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    NtClose( LocalEvent );

    AddNameThreadExit();

    ExitThread(0);
    return 0;
}


VOID
PostRoutineCaller(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    )
/*++

Routine Description:

    This routine is supplied by SendNcbToDriver to the Io system when
    a Post routine is to be called directly.

Arguments:

    IN PVOID Context - supplies the NCB post routine to be called.

    IN PIO_STATUS_BLOCK Status.

    IN ULONG Reserved.

Return Value:

    none.

--*/
{
    PNCBI pncbi = (PNCBI) Context;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    UCHAR  command;

    try {

        if ( Status->Status == STATUS_HANGUP_REQUIRED ) {
            HangupConnection( pncbi );
        }

        //
        //  Save the command, post routine and the handle to the event so that if the other thread is
        //  polling the cmd_cplt flag or the event awaiting completion and immediately trashes
        //  the NCB, we behave appropriately.
        //
        post = pncbi->ncb_post;
        event = pncbi->ncb_event;
        command = pncbi->ncb_command;

        //  Set the flag that indicates that the NCB is now completed.
        pncbi->ncb_cmd_cplt = pncbi->ncb_retcode;

        //
        // NCB may be queued again
        //

        EnterCriticalSection( &Crit );
        pncbi->ncb_reserved = 0;
        LeaveCriticalSection( &Crit );

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent( event, NULL );
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncbi );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncbi ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    UNREFERENCED_PARAMETER( Reserved );
}

VOID
ChainSendPostRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK Status,
    ULONG Reserved
    )
/*++

Routine Description:

    This routine is supplied by SendNcbToDriver to the Io system when
    a chain send ncb is being processed. When the send is complete,
    this routine deletes the BigBuffer used to hold the two parts of
    the chain send. It then calls a post routine if the user supplied one.

Arguments:

    IN PVOID Context - supplies the NCB post routine to be called.

    IN PIO_STATUS_BLOCK Status.

    IN ULONG Reserved.

Return Value:

    none.

--*/
{
    PNCBI pncbi = (PNCBI) Context;
    PUCHAR BigBuffer;
    void  (CALLBACK *post)( struct _NCB * );
    HANDLE event;
    UCHAR  command;

    BigBuffer = pncbi->ncb_buffer;

    try {

        //  Restore the users NCB contents.
        RtlMoveMemory(
            &pncbi->ncb_buffer,
            BigBuffer,
            sizeof(pncbi->ncb_buffer));

        NbPrintf(( "[NETAPI32] ChainSendPostRoutine PNCB: %lx, Status: %X\n", pncbi, Status->Status ));
        DisplayNcb( pncbi );

        if ( Status->Status == STATUS_HANGUP_REQUIRED ) {
            HangupConnection( pncbi );
        }

        //
        //  Save the command, post routine and the handle to the event so that if the other thread is
        //  polling the cmd_cplt flag or the event awaiting completion and immediately trashes
        //  the NCB, we behave appropriately.
        //
        post = pncbi->ncb_post;
        event = pncbi->ncb_event;
        command = pncbi->ncb_command;

        //  Set the flag that indicates that the NCB is now completed.
        pncbi->ncb_cmd_cplt = pncbi->ncb_retcode;

        //
        // NCB may be queued again
        //

        EnterCriticalSection( &Crit );
        pncbi->ncb_reserved = 0;
        LeaveCriticalSection( &Crit );

        //  Allow application/worker thread to proceed.
        if ( event != NULL ) {
            NtSetEvent(event, NULL);
        }

        //  If the user supplied a post routine then call it.
        if (( post != NULL ) &&
            ( (command & ASYNCH) != 0 )) {
            (*(post))( (PNCB)pncbi );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NbPrintf(( "[NETAPI32] Netbios: Access Violation post processing NCB %lx\n", pncbi ));
        NbPrintf(( "[NETAPI32] Netbios: Probable application error\n" ));
    }

    RtlFreeHeap( RtlProcessHeap(), 0, BigBuffer);


    UNREFERENCED_PARAMETER( Reserved );
}

VOID
HangupConnection(
    PNCBI pUserNcb
    )
/*++

Routine Description:

    This routine generates a hangup for the connection. This allows orderly
    cleanup of the connection block in the driver.

    The return value from the hangup is not used. If the hangup overlaps with
    a reset or a hangup then the hangup will have no effect.

    The user application is unaware that this operation is being performed.

Arguments:

    IN PNCBI pUserNcb - Identifies the connection to be hung up.

Return Value:

    none.

--*/
{
    NCBI ncbi;
    NTSTATUS Status;

    RtlZeroMemory( &ncbi, sizeof (NCB) );
    ncbi.ncb_command = NCBHANGUP;
    ncbi.ncb_lsn = pUserNcb->ncb_lsn;
    ncbi.ncb_lana_num = pUserNcb->ncb_lana_num;
    ncbi.ncb_retcode = ncbi.ncb_cmd_cplt = NRC_PENDING;

    Status = NtCreateEvent( &ncbi.ncb_event,
        EVENT_ALL_ACCESS,
        NULL,
        SynchronizationEvent,
        FALSE );

    if ( !NT_SUCCESS(Status) ) {
        //
        //  Failed to create event. Cleanup of the Cb will have to wait until
        //  the user decides to do another request or exits.
        //
        NbPrintf(( "[NETAPI32] Hangup Session PNCBI: %lx failed to create event!\n" ));
        return;
    }

    Status = NtDeviceIoControlFile(
        NB,
        ncbi.ncb_event,
        NULL,               //  APC Routine
        NULL,               //  APC Context
        &ncbi.u.ncb_iosb,   //  IO Status block
        IOCTL_NB_NCB,
        &ncbi,              //  InputBuffer
        sizeof(NCB),
        NULL,               //  Outputbuffer
        0 );

    //
    //  We must always wait to allow the Apc to fire
    //

    do {
        Status = NtWaitForSingleObject(
            ncbi.ncb_event,
            TRUE,
            NULL );

    } while ( (Status == STATUS_USER_APC) ||
              (Status == STATUS_ALERTED) );

    ASSERT(Status == STATUS_SUCCESS);

    if (! NT_SUCCESS(Status)) {
        NbPrintf(( "[NETAPI32] The Netbios NtWaitForSingleObject failed: %X\n", Status ));
    }

    NtClose( ncbi.ncb_event );

}

VOID
NetbiosInitialize(
    HMODULE hModule
    )
/*++

Routine Description:

    This routine is called each time a process that uses netapi.dll
    starts up.

Arguments:

    IN HMODULE hModule - Handle to module instance (netapi32.dll)

Return Value:

    none.

--*/
{

    Initialized = FALSE;
    WorkerHandle = NULL;
    InitializeCriticalSection( &Crit );

#if AUTO_RESET

    InitializeCriticalSection( &ResetCS );
    InitializeListHead( &LanaResetList );
    RtlZeroMemory( &OutputNCB, sizeof( NCB ) );

#endif

    g_hModule = hModule;

}

VOID
NetbiosDelete(
    VOID
    )
/*++

Routine Description:

    This routine is called each time a process that uses netapi.dll
    Exits. It resets all lana numbers that could have been used by this
    process. This will cause all Irp's in the system to be completed
    because all the Connection and Address handles will be closed tidily.

Arguments:

    none.

Return Value:

    none.

--*/
{

#if AUTO_RESET

    PLIST_ENTRY ple;
    PRESET_LANA_NCB prln;

    while ( !IsListEmpty( &LanaResetList ) )
    {
        ple = RemoveHeadList( &LanaResetList );

        prln = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

        HeapFree( GetProcessHeap(), 0, prln );
    }

    DeleteCriticalSection( &ResetCS );

#endif

    DeleteCriticalSection( &Crit );
    if ( Initialized == FALSE ) {
        //  This process did not use Netbios.
        return;
    }

    NtClose(NB);
}



#if AUTO_RESET

VOID
ResetLanaAndPostListen(
)
/*++

Routine Description:

    This routine is invoked in response to new LANA being indicated to
    NETBIOS.SYS.  When this occurs the IOCTL posted by this user-mode
    component of netbios (to listen for new LANA indications) is completed.
    In response the new LANA is reset if it had previously been reset.

    In addition the routine re-posts the listen to the kernel mode
    component of netbios (NETBIOS.SYS).  An exception to this is if
    the LANA number to be reset is 255 ( MAX_LANA + 1 ).  This is a
    special case that indicates the NETBIOS.SYS is stopping and listen
    should not be reposted in this case.


Arguments:

    none.

Return Value:

    none.

--*/
{

    NTSTATUS Status;
    PRESET_LANA_NCB prln;
    PLIST_ENTRY ple, pleHead;


    NbPrintf( ("[NETAPI32] : Netbios : Entered ResetLanaAndPostListen \n") );


    //
    // Check if the LANA number is valid.
    //

    if ( OutputNCB.ncb_lana_num != ( MAX_LANA + 1 ) )
    {
        EnterCriticalSection( &ResetCS );

        //
        // find which lana needs a reset
        //

        NbPrintf( (
            "[NETAPI32] : Netbios : Looking for Lana %d\n", OutputNCB.ncb_lana_num
            ) );


        pleHead = &LanaResetList;

        for ( ple = pleHead-> Flink; ple != pleHead; ple = ple-> Flink )
        {
            prln = CONTAINING_RECORD( ple, RESET_LANA_NCB, leList );

            if ( prln-> ResetNCB.ncb_lana_num == OutputNCB.ncb_lana_num )
            {
                //
                // found Lana that needs reseting
                //

                break;
            }
        }


        //
        // if found send reset
        //

        if ( ple != pleHead )
        {
            //
            // Send Reset to NETBIOS.SYS
            //

            QueueToWorker( (PNCBI) &prln-> ResetNCB );
        }

        else
        {
            NbPrintf( (
                "[NETAPI32] : Netbios : Lana %d not found\n",
                OutputNCB.ncb_lana_num
                ) );
        }

        LeaveCriticalSection( &ResetCS );

        OutputNCB.ncb_lana_num = 0;


        //
        // post listen again
        //

        Status = NtDeviceIoControlFile(
                        NB,
                        LanaResetEvent,
                        NULL, NULL,
                        &ResetStatusBlock,
                        IOCTL_NB_REGISTER_RESET,
                        NULL, 0,
                        (PVOID) &OutputNCB, sizeof( NCB )
                        );

        if ( ( Status != STATUS_PENDING ) &&
             ( Status != STATUS_SUCCESS ) )
        {
            //
            // Failed to register reset notification.
            //

            NbPrintf(
                ("[NETAPI32] : Netbios : Failed to register Reset event\n" )
                );
        }
    }

    else
    {
        NbPrintf( (
            "[NETAPI32] : Netbios : LANA 255 indicated, no Listen posted\n"
            ) )
    }

    NbPrintf( ("[NETAPI32] : Netbios : Leaving ResetLanaAndPostListen \n") );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the kernel and logs through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/


#if DBG

#include <nb.h>

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

LONG NetbiosMaxDump = 128;

//  Macro used in DisplayNcb
#define DISPLAY_COMMAND( cmd )              \
    case cmd: NbPrint(( #cmd )); break;

VOID
NbDisplayNcb(
    IN PDNCB pdncb
    )
/*++

Routine Description:

    This routine displays on the standard output stream the contents
    of the Ncb.

Arguments:

    IN PDNCB - Supplies the NCB to be displayed.

Return Value:

    none.

--*/
{

    NbPrint(( "PDNCB         %#010lx\n", pdncb));

    NbPrint(( "ncb_command  %#04x ",  pdncb->ncb_command));
    switch ( pdncb->ncb_command & ~ASYNCH ) {
    DISPLAY_COMMAND( NCBCALL );
    DISPLAY_COMMAND( NCBLISTEN );
    DISPLAY_COMMAND( NCBHANGUP );
    DISPLAY_COMMAND( NCBSEND );
    DISPLAY_COMMAND( NCBRECV );
    DISPLAY_COMMAND( NCBRECVANY );
    DISPLAY_COMMAND( NCBCHAINSEND );
    DISPLAY_COMMAND( NCBDGSEND );
    DISPLAY_COMMAND( NCBDGRECV );
    DISPLAY_COMMAND( NCBDGSENDBC );
    DISPLAY_COMMAND( NCBDGRECVBC );
    DISPLAY_COMMAND( NCBADDNAME );
    DISPLAY_COMMAND( NCBDELNAME );
    DISPLAY_COMMAND( NCBRESET );
    DISPLAY_COMMAND( NCBASTAT );
    DISPLAY_COMMAND( NCBSSTAT );
    DISPLAY_COMMAND( NCBCANCEL );
    DISPLAY_COMMAND( NCBADDGRNAME );
    DISPLAY_COMMAND( NCBENUM );
    DISPLAY_COMMAND( NCBUNLINK );
    DISPLAY_COMMAND( NCBSENDNA );
    DISPLAY_COMMAND( NCBCHAINSENDNA );
    DISPLAY_COMMAND( NCBLANSTALERT );
    DISPLAY_COMMAND( NCBFINDNAME );
    DISPLAY_COMMAND( NCBACTION );
    DISPLAY_COMMAND( NCBQUICKADDNAME );
    DISPLAY_COMMAND( NCBQUICKADDGRNAME );
    DISPLAY_COMMAND( NCALLNIU );
    case NCBADDRESERVED: NbPrint(( "Add reserved address(Internal)" )); break;
    case NCBADDBROADCAST: NbPrint(( "Add Broadcast address(Internal)" )); break;
    default: NbPrint(( " Unknown type")); break;
    }
    if ( pdncb->ncb_command  & ASYNCH ) {
        NbPrint(( " | ASYNCH"));
    }


    NbPrint(( "\nncb_retcode  %#04x\n",  pdncb->ncb_retcode));
    NbPrint(( "ncb_lsn      %#04x\n",  pdncb->ncb_lsn));
    NbPrint(( "ncb_num      %#04x\n",  pdncb->ncb_num));
    NbPrint(( "ncb_buffer   %#010lx\n",pdncb->ncb_buffer));
    NbPrint(( "ncb_length   %#06x\n",  pdncb->ncb_length));

    if ((( pdncb->ncb_command & ~ASYNCH ) == NCBCALL) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCALLNIU) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGSEND) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGRECV) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGSENDBC) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBDGRECVBC) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBADDNAME) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBADDGRNAME) ||
        (( pdncb->ncb_command & ~ASYNCH ) == NCBLISTEN)) {

        NbPrint(( "\nncb_callname and ncb->name\n"));
        NbFormattedDump( pdncb->ncb_callname, NCBNAMSZ );
        NbFormattedDump( pdncb->ncb_name, NCBNAMSZ );
        NbPrint(( "ncb_rto      %#04x\n",  pdncb->ncb_rto));
        NbPrint(( "ncb_sto      %#04x\n",  pdncb->ncb_sto));
    }

    NbPrint(( "ncb_post     %lx\n",    pdncb->ncb_post));
    NbPrint(( "ncb_lana_num %#04x\n",  pdncb->ncb_lana_num));
    NbPrint(( "ncb_cmd_cplt %#04x\n\n",  pdncb->ncb_cmd_cplt));

}


void
NbFormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if ( len > NetbiosMaxDump ) {
        len = NetbiosMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NbPrint( ("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NbPrint( ("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\tnetbl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetbios.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "

#define Hi  "Come here Dave, I need you"

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//  Hard code lana-num that is mapped to XNS

#define XNS 1
int Limit = 20;

VOID
usage (
    VOID
    )
{
    printf("usage: tnetbl [-n:lan number][-h] <remote computername> <my computername>\n");
    printf("               -n specifies the lan number (0 is the default)\n");
    printf("               -h specifies that addresses are hexadecimal numbers \n");
    printf("                   rather than strings.\n");
    printf("               final two arguments are the remote and local computer names.\n");
}

int
main (argc, argv)
   int argc;
   char *argv[];
{
    NCB myncb;
    CHAR Buffer2[128];
    int i,j;
    CHAR localName[16];
    CHAR remoteName[16];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    ULONG lanNumber=0;
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    UCHAR lsn;
    UCHAR name_number;
    USHORT length;

    if ( argc < 3 || argc > 5) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlen( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlen( argv[i] ));
            }

        }
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 0;           // Request resources
    myncb.ncb_lana_num = lanNumber;
    myncb.ncb_callname[0] = 0;   // 16 sessions
    myncb.ncb_callname[1] = 0;   // 16 commands
    myncb.ncb_callname[2] = 0;   // 8 names
    Netbios( &myncb );

    //   AddName
    ClearNcb( &myncb );
    myncb.ncb_command = NCBADDNAME;
    RtlMoveMemory( myncb.ncb_name, localName, 16);
    myncb.ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &myncb );

    if ( myncb.ncb_retcode != NRC_GOODRET ) {
        printf( "Addname returned an error %lx", myncb.ncb_retcode );
        return 1;
    }
    name_number = myncb.ncb_num;

    printf( "Starting Listen test\n" );

    for ( j = 0; j <= Limit; j++ ) {

        printf( "\nStarting Listen " );

        //   Listen
        ClearNcb( &myncb );
        myncb.ncb_command = NCBLISTEN | ASYNCH;
        RtlMoveMemory( myncb.ncb_name, localName, 16);
        RtlMoveMemory( myncb.ncb_callname, remoteName, 16);
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_rto = myncb.ncb_rto = 0; //10;  10*500 milliseconds timeout
        myncb.ncb_num = name_number;
        Netbios( &myncb );
        printf( "Listen returned " );
        while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
            printf( "." );
            Sleep(500);

        }
        printf( " Listen completed\n" );

        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }

        lsn = myncb.ncb_lsn;

        while ( 1 ) {

            //   Receive
            ClearNcb( &myncb );
            myncb.ncb_command = NCBRECV | ASYNCH;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = sizeof( Buffer2 );
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            Netbios( &myncb );
            printf( "R" );
            while ( myncb.ncb_cmd_cplt == NRC_PENDING ) {
//                printf( "." );
//                Sleep(250);

            }
            printf( "r" );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
            //printf( ":%s\n", Buffer2);
            length = myncb.ncb_length;

            //   Send
            ClearNcb( &myncb );
            myncb.ncb_command = NCBSEND;
            myncb.ncb_lana_num = (UCHAR)lanNumber;
            myncb.ncb_length = length;
            myncb.ncb_buffer = Buffer2;
            myncb.ncb_lsn = lsn;
            Netbios( &myncb );
            if ( myncb.ncb_retcode != NRC_GOODRET ) {
                break;
            }
        }

        //  Hangup
        ClearNcb( &myncb );
        myncb.ncb_command = NCBHANGUP;
        myncb.ncb_lana_num = (UCHAR)lanNumber;
        myncb.ncb_lsn = lsn;
        Netbios( &myncb );
        if ( myncb.ncb_retcode != NRC_GOODRET ) {
            break;
        }
    }

    //   Reset
    ClearNcb( &myncb );
    myncb.ncb_command = NCBRESET;
    myncb.ncb_lsn = 1;           // Free resources
    Netbios( &myncb );
    printf( "Ending NetBios\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\address.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    address object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//nclude <zwapi.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbAddName)
#pragma alloc_text(PAGE, NbOpenAddress)
#pragma alloc_text(PAGE, NbAddressClose)
#pragma alloc_text(PAGE, NbSetEventHandler)
#pragma alloc_text(PAGE, SubmitTdiRequest)
#pragma alloc_text(PAGE, NewAb)
#endif

NTSTATUS
NbAddName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to add a name to the name table so that the
    name is available for listens etc. If the name is already in the table
    then reject the request. If an error is found by NewAb then it is
    recorded directly in the NCB.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation. This is always
    STATUS_SUCCESS because the operations called by this routine are all
    synchronous. We must never return an error status since this would
    prevent the ncb from being copied back.

--*/

{

    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PSZ Name = pdncb->ncb_name;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint(( "\n** AAAAADDDDDDName *** pdncb %lx\n", pdncb ));
    }

    //
    //  NewAb is used in file.c to add the reserved name. Check here
    //  for an application using a special name.
    //

    if (( pdncb->ncb_name[0] == '*' ) ||
        ( pdncb->ncb_name[0] == '\0' )) {
        NCB_COMPLETE( pdncb, NRC_NOWILD );
    } else {
        NewAb( IrpSp, pdncb );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NbDeleteName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to delete a name. To perform this operation
    the AddressHandle to the transport is closed and the Address Block
    is deleted.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("[NETBIOS] NbDeleteName : FCB : %lx lana: %lx Address:\n", 
                   pfcb, pdncb->ncb_lana_num ));
        NbFormattedDump( (PUCHAR) pdncb->ncb_name, sizeof(NAME) );
    }

    if (( pdncb->ncb_name[0] == '*' ) ||
        ( pdncb->ncb_name[0] == '\0' )) {
        NCB_COMPLETE( pdncb, NRC_NOWILD );
        return STATUS_SUCCESS;
    }

    LOCK( pfcb, OldIrql );

    ppab = FindAb( pfcb, pdncb, FALSE );

    if ( ppab != NULL ) {

        if (( (*ppab)->NameNumber == 0) ||
            ( (*ppab)->NameNumber == MAXIMUM_ADDRESS)) {
                UNLOCK( pfcb, OldIrql );
                NCB_COMPLETE( pdncb, NRC_NAMERR );
        } else {

            if ( ((*ppab)->Status & 0x7) != REGISTERED) {
                    UNLOCK( pfcb, OldIrql );
                    NCB_COMPLETE( pdncb, NRC_TOOMANY ); // Try later.
            } else {
                if ( FindActiveSession( pfcb, pdncb, ppab ) == TRUE ) {
                    // When all the sessions close, the name will be deleted.
                    UNLOCK_SPINLOCK( pfcb, OldIrql );
                    CleanupAb( ppab, FALSE );
                    UNLOCK_RESOURCE( pfcb );
                    NCB_COMPLETE( pdncb, NRC_ACTSES );
                } else {
                    UNLOCK_SPINLOCK( pfcb, OldIrql );
                    CleanupAb( ppab, TRUE );
                    UNLOCK_RESOURCE( pfcb );
                    NCB_COMPLETE( pdncb, NRC_GOODRET );
                }
            }
        }
    } else {
        UNLOCK( pfcb, OldIrql );
        //  FindAb has already set the completion code.
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NbOpenAddress (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PUNICODE_STRING pusDeviceName,
    IN UCHAR LanNumber,
    IN PDNCB pdncb OPTIONAL
    )
/*++

Routine Description:

    This routine uses the transport to create an entry in the NetBIOS
    table with the value of "Name". It will re-use an existing entry if
    "Name" already exists.

    Note: This synchronous call may take a number of seconds. If this matters
    then the caller should specify ASYNCH and a post routine so that it is
    performed by the thread created by the netbios dll routines.

    If pdncb == NULL then a special handle is returned that is capable of
    administering the transport. For example to execute an ASTAT.

Arguments:

    FileHandle - Pointer to where the filehandle is to be returned.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - supplies the device names for the lana number.

    LanNumber - supplies the network adapter to be opened.

    pdncb - Pointer to either an NCB or NULL.

Return Value:

    The function value is the status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaLength;
    TA_NETBIOS_ADDRESS Address;
    ULONG ShareAccess;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();


    IF_NBDBG (NB_DEBUG_ADDRESS) {
        if ( pdncb ) {
            NbPrint( ("NbOpenAddress: Opening lana: %lx, Address:\n",
                LanNumber ));
            NbFormattedDump( pdncb->ncb_name, NCBNAMSZ );
            if ( pdncb->ncb_command == NCBADDBROADCAST ) {
                NbPrint (("NbOpenAddress: Opening Broadcast Address length: %x\n",
                    pdncb->ncb_length));
            }
        } else {
            NbPrint( ("NbOpenAddress: Opening lana: %lx Control Channel\n",
                LanNumber));
        }
    }

    InitializeObjectAttributes (
        &ObjectAttributes,
        pusDeviceName,
        0,
        NULL,
        NULL);

    if ( ARGUMENT_PRESENT( pdncb ) ) {

        EaLength =  FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TA_NETBIOS_ADDRESS); // EA length

        EaBuffer = (PFILE_FULL_EA_INFORMATION)
            ExAllocatePoolWithTag( NonPagedPool, EaLength, 'eSBN' );

        if (EaBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        EaBuffer->NextEntryOffset = 0;
        EaBuffer->Flags = 0;
        EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

        EaBuffer->EaValueLength = sizeof (TA_NETBIOS_ADDRESS);

        RtlMoveMemory( EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength + 1 );

        //
        // Create a copy of the NETBIOS address descriptor in a local
        // first, in order to avoid alignment problems.
        //

        Address.TAAddressCount = 1;
        Address.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;

        if ( pdncb->ncb_command == NCBADDBROADCAST ) {
            Address.Address[0].AddressLength = pdncb->ncb_length;
        } else {
            Address.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
        }

        if (((pdncb->ncb_command & ~ASYNCH) == NCBADDNAME) ||
            ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME)) {

            ShareAccess = 0;    //  Exclusive access


            if ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME) {
                Address.Address[0].Address[0].NetbiosNameType =
                    TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            } else {
                Address.Address[0].Address[0].NetbiosNameType =
                    TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            }

        } else {
            if ((pdncb->ncb_command & ~ASYNCH) == NCBADDRESERVED) {
                //
                //  NB30 non-conformance!
                //  We allow multiple applications to use name number 1. This is so that we can
                //  conveniently run multiple dos applications which all have address 1.
                //

                ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access
                Address.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            } else {
                //  Group names and Broadcast addresses.
                ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access

                if ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDGRNAME) {
                    Address.Address[0].Address[0].NetbiosNameType =
                        TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP;
                } else {
                    Address.Address[0].Address[0].NetbiosNameType =
                        TDI_ADDRESS_NETBIOS_TYPE_GROUP;
                }
            }
        }

        RtlMoveMemory(
            Address.Address[0].Address[0].NetbiosName,
            pdncb->ncb_name,
            NCBNAMSZ
            );

        RtlMoveMemory (
            &EaBuffer->EaName[EaBuffer->EaNameLength + 1],
            &Address,
            sizeof(TA_NETBIOS_ADDRESS)
            );

    } else {
        ShareAccess = FILE_SHARE_WRITE; //  Non-exclusive access
        EaBuffer = NULL;
        EaLength = 0;
    }

    if (PsGetCurrentProcess() != NbFspProcess) {
	
		KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }

    IF_NBDBG( NB_DEBUG_ADDRESS )
    {
        if ( ARGUMENT_PRESENT( pdncb ) )
        {
            NbPrint( ( 
                "NbOpenAddress : Create file invoked on lana for : %d\n",
                pdncb-> ncb_lana_num
                ) );
        
            NbFormattedDump( pdncb-> ncb_name, NCBNAMSZ );
        }
        
        else
        {
            NbPrint( ( 
                "NbOpenAddress : Create file invoked for \n"
                ) );
        
            NbPrint( ( "Control channel\n" ) );
        }
    }
    
    Status = ZwCreateFile (
                 FileHandle,
                 GENERIC_READ | GENERIC_WRITE, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // Allocation size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 ShareAccess,
                 FILE_CREATE,
                 0,                     // create options.
                 EaBuffer,
                 EaLength
                 );

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    //  Obtain a referenced pointer to the file object.
    if (NT_SUCCESS( Status )) {
        Status = ObReferenceObjectByHandle (
                                    *FileHandle,
                                    0,
                                    NULL,
                                    KernelMode,
                                    Object,
                                    NULL
                                    );

        if (!NT_SUCCESS(Status)) {
            NTSTATUS localstatus;

            IF_NBDBG( NB_DEBUG_ADDRESS )
            {
                if ( ARGUMENT_PRESENT( pdncb ) )
                {
                    NbPrint( ( 
                        "NbOpenAddress : error : file closed on lana %d for \n",
                        pdncb-> ncb_lana_num
                    ) );
            
                    NbFormattedDump( pdncb-> ncb_name, NCBNAMSZ );
                }
                else
                {
                    NbPrint( ( 
                        "NbOpenAddress : error : file closed on lana for \n"
                    ) );
                    
                    NbPrint( ( "Control channel\n" ) );
                }
            }
            
            localstatus = ZwClose( *FileHandle);

            ASSERT(NT_SUCCESS(localstatus));

            *FileHandle = NULL;
        }
    }

    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    if ( EaBuffer ) {
        ExFreePool( EaBuffer );
    }

    IF_NBDBG (NB_DEBUG_ADDRESS ) {
        NbPrint( ("NbOpenAddress Status:%X, IoStatus:%X.\n", Status, IoStatusBlock.Status));
    }

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS( Status )) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("NbOpenAddress:  FAILURE, status code=%X.\n", Status));
        }
        return Status;
    }

    return Status;
}

PAB
NewAb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    )

/*++

Routine Description:

Arguments:
`
    IrpSp - Pointer to current IRP stack frame.

    pdncb - Pointer to the ncb being processed.

Return Value:

    The new Cb.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PAB pab;
    PFCB pfcb = FileObject->FsContext2;
    PLANA_INFO plana;
    int index;
    ULONG NameLength;
    UNICODE_STRING  usDeviceName;
    HANDLE          hFileHandle = NULL;
    PFILE_OBJECT    pfoFileObject = NULL;
    

    PAGED_CODE();


    RtlInitUnicodeString( &usDeviceName, NULL);
    

    KeEnterCriticalRegion();
    
    //  Prevent resets while we add the name
    ExAcquireResourceSharedLite ( &pfcb->AddResource, TRUE );

    LOCK_RESOURCE( pfcb );

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("[NETBIOS] NewAb: FCB : %lx lana: %lx Address:\n", pfcb, 
                   pdncb->ncb_lana_num ));
        NbFormattedDump( (PUCHAR) pdncb->ncb_name, sizeof(NAME) );
    }

    if ( ( pfcb == NULL ) ||
         ( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].MaximumLength == 0 ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].Buffer == NULL ) ) {
        //  no such adapter
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }

    if ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) {
        //  adapter not installed
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }
    
    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    if ( pdncb->ncb_command == NCBADDRESERVED ) {
        index = 1;
        NameLength = NCBNAMSZ;
    } else {
        if ( pdncb->ncb_command == NCBADDBROADCAST ) {
            index = MAXIMUM_ADDRESS;
            NameLength = pdncb->ncb_length;
        } else {

            //
            //  Ensure that the user has not added too many names or attempted to
            //  add the same name twice. If not then scan the address table looking
            //  for the next available slot.
            //

            IF_NBDBG (NB_DEBUG_ADDRESS) {
                NbPrint( ("NewAb: AddressCount: %lx, MaximumAddress %lx\n",
                    plana->AddressCount,
                    plana->MaximumAddresses ));
            }

            //
            //  If the application has added the number of names requested
            //  or has filled the table, refuse the request.
            //

            if ( plana->MaximumAddresses == plana->AddressCount) {

                NCB_COMPLETE( pdncb, NRC_NAMTFUL );
                UNLOCK_RESOURCE( pfcb );
                ExReleaseResourceLite( &pfcb->AddResource );
                KeLeaveCriticalRegion();
                return NULL;
            }

            //
            //  Scan the name table and ensure that the name isn't already
            //  there.
            //

            if (( FindAb(pfcb, pdncb, FALSE) != NULL) ||
                ( pdncb->ncb_retcode != NRC_NOWILD)) {

                //
                //  error is set to DUPNAME iff FindAb found the name
                //  in all other cases FindAb sets the error code and sets
                //  returns the address block.
                //

                NCB_COMPLETE( pdncb, NRC_DUPNAME );
                UNLOCK_RESOURCE( pfcb );
                ExReleaseResourceLite( &pfcb->AddResource );
                KeLeaveCriticalRegion();
                return NULL;
            }

            //
            //  Find the appropriate name number to use.
            //

            index = plana->NextAddress;
            while ( plana->AddressBlocks[index] != NULL ) {
                index++;
                if ( index == MAXIMUM_ADDRESS ) {
                    index = 2;
                }
            }

            //  reset retcode so that NCB_COMPLETE will process the NCB.
            pdncb->ncb_retcode = NRC_PENDING;

            NameLength = NCBNAMSZ;
        }
    }

    if ( plana->AddressBlocks[index] != NULL ) {
        NCB_COMPLETE( pdncb, NRC_DUPNAME );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }
    pab = ExAllocatePoolWithTag (NonPagedPool, sizeof(AB), 'aSBN');

    if (pab==NULL) {
        NCB_COMPLETE( pdncb, NbMakeNbError( STATUS_INSUFFICIENT_RESOURCES ) );
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();
        return NULL;
    }

    pab->AddressHandle = NULL;
    pab->AddressObject = NULL;
    pab->DeviceObject = NULL;
    pab->NameNumber = (UCHAR)index;
    pab->pLana = plana;
    InitializeListHead(&pab->ReceiveAnyList);
    InitializeListHead(&pab->ReceiveDatagramList);
    InitializeListHead(&pab->ReceiveBroadcastDatagramList);
    pab->NameLength = (UCHAR)NameLength;
    RtlMoveMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ);

    if (((pdncb->ncb_command & ~ASYNCH) == NCBADDNAME) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBQUICKADDNAME)) {

        pab->Status = REGISTERING | UNIQUE_NAME;

    } else {

        pab->Status = REGISTERING | GROUP_NAME;

    }

    pab->CurrentUsers = 1;
    plana->AddressBlocks[index] = pab;
    pab->Signature = AB_SIGNATURE;


    if (( pdncb->ncb_command != NCBADDRESERVED ) &&
        ( pdncb->ncb_command != NCBADDBROADCAST )) {
        plana->AddressCount++;
        plana->NextAddress = index + 1;
        if ( plana->NextAddress == MAXIMUM_ADDRESS ) {
            plana->NextAddress = 2;
        }
    }


    Status = AllocateAndCopyUnicodeString( 
                &usDeviceName, &pfcb-> pDriverName[ pdncb-> ncb_lana_num ]
             );
    
    if ( !NT_SUCCESS( Status ) )
    {
        NCB_COMPLETE( pdncb, NRC_NORESOURCES);
        
        ExFreePool( pab );
        plana->AddressBlocks[index] = NULL;

        if (( pdncb->ncb_command != NCBADDRESERVED ) &&
            ( pdncb->ncb_command != NCBADDBROADCAST )) {

            plana->AddressCount--;
        }
        
        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();

        return NULL;
    }
    
    //  Unlock so other Ncb's can be processed while adding the name.

    UNLOCK_RESOURCE( pfcb );

    Status = NbOpenAddress (
                &hFileHandle,
                (PVOID *)&pfoFileObject,
                &usDeviceName,
                pdncb->ncb_lana_num,
                pdncb
                );
    
    LOCK_RESOURCE( pfcb );

    //
    // In the interval when no locks were held it is possible that
    // the Lana could have been unbound.  Verify that Lana is still
    // present before accessing it.
    //
    
    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint(( "\n  FAILED on open of %s  %X ******\n",
                pdncb->ncb_name,
                Status ));
        }

        if ( pfcb->ppLana[pdncb->ncb_lana_num] == plana )
        {
            //
            // Lana is still available.  Do normal error processing
            //
            
            NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
            
            ExFreePool( pab );
            plana->AddressBlocks[index] = NULL;

            if (( pdncb->ncb_command != NCBADDRESERVED ) &&
                ( pdncb->ncb_command != NCBADDBROADCAST )) {

                plana->AddressCount--;
            }
        }

        UNLOCK_RESOURCE( pfcb );
        ExReleaseResourceLite( &pfcb->AddResource );
        KeLeaveCriticalRegion();

        if ( usDeviceName.Buffer != NULL )
        {
            ExFreePool( usDeviceName.Buffer );
        }

        return NULL;
    }

    else
    {
        //
        // NbOpenAddress succeeded.  Make sure Lana is still there.
        //

        if ( plana == pfcb->ppLana[pdncb->ncb_lana_num] )
        {
            //
            // assume if lana is uncahnged pab points to a valid address
            // block entry.  Update the fields.
            //

            pab-> AddressHandle = hFileHandle;
            pab-> AddressObject = pfoFileObject;
        }

        else
        {
            //
            // Lana presumed to be removed on account of an unbind.
            //

            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            
            UNLOCK_RESOURCE( pfcb );

            ExReleaseResourceLite( &pfcb->AddResource );
            KeLeaveCriticalRegion();

            NbAddressClose( hFileHandle, (PVOID) pfoFileObject );

            if ( usDeviceName.Buffer != NULL )
            {
                ExFreePool( usDeviceName.Buffer );
            }

            return NULL;
        }
    }

    //  Inform the application of the address number.
    pdncb->ncb_num = (UCHAR) index;

    //
    //  Register the event handlers for this address.
    //

    //  Get the address of the device object for the endpoint.

    pab->DeviceObject = IoGetRelatedDeviceObject(pab->AddressObject);

    //
    //  No connections are made using the broadcast address so don't register disconnect or
    //  receive indication handlers. The ReceiveDatagram handler will get registered if the
    //  application requests a receive broadcast datagram. This will cut down the cpu load
    //  when the application is not interested in broadcasts. We always register the error
    //  indication handler on the broadcast address because it is the only address which is
    //  always open to the transport.
    //

    if ( pdncb->ncb_command != NCBADDBROADCAST ) {
        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_RECEIVE,
                                    (PVOID)NbTdiReceiveHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_DISCONNECT,
                                    (PVOID)NbTdiDisconnectHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_RECEIVE_DATAGRAM,
                                    (PVOID)NbTdiDatagramHandler,
                                    pab);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        pab->ReceiveDatagramRegistered = TRUE;
    } else {
        Status = NbSetEventHandler( pab->DeviceObject,
                                    pab->AddressObject,
                                    TDI_EVENT_ERROR,
                                    (PVOID)NbTdiErrorHandler,
                                    plana);

        ASSERT( NT_SUCCESS(Status) || (Status == STATUS_INVALID_DEVICE_STATE) || (Status == STATUS_INSUFFICIENT_RESOURCES));

        pab->ReceiveDatagramRegistered = FALSE;
    }

    pab->Status |= REGISTERED;

    UNLOCK_RESOURCE( pfcb );

    ExReleaseResourceLite( &pfcb->AddResource );
    KeLeaveCriticalRegion();

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }
    
    NCB_COMPLETE( pdncb, NRC_GOODRET );

    return pab;
}

VOID
CleanupAb(
    IN PPAB ppab,
    IN BOOLEAN CloseAddress
    )
/*++

Routine Description:

    This closes the handles in the Ab and deletes the Address Block.

    During this routine we need the spinlock held to prevent an indication accessing
    a Receive while we are cancelling it.

    Note: Resource must be held before calling this routine.

Arguments:

    pab - Address of the pointer to the Ab to be destroyed.

    CloseAddress - TRUE if Address block is to be destroyed immediately.

Return Value:

    nothing.

--*/

{

    PAB pab = *ppab;
    PAB pab255;
    PFCB pfcb = (*ppab)->pLana->pFcb;
    PLANA_INFO plana = (*ppab)->pLana;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PLIST_ENTRY ReceiveEntry;

    LOCK_SPINLOCK( pfcb, OldIrql );

    ASSERT( pab->Signature == AB_SIGNATURE );
    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("CleanupAb ppab: %lx, pab: %lx, CurrentUsers: %lx, State: %x\n",
            ppab,
            pab,
            pab->CurrentUsers,
            pab->Status));

        NbFormattedDump( (PUCHAR)&pab->Name, sizeof(NAME) );
    }

    if ( (pab->Status & 0x7) != DEREGISTERED ) {
        PDNCB pdncb;

        pab->Status |= DEREGISTERED;

        //
        //  This is the first time through so cancel all the receive datagram
        //  requests for this address.


        while ( (pdncb = DequeueRequest( &pab->ReceiveDatagramList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        while ( (pdncb = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        while ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            NCB_COMPLETE( pdncb, NRC_NAMERR );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
            LOCK_SPINLOCK( pfcb, OldIrql );
        }

        //  The IBM Mif081 test requires ReceiveBroadcast Any with this name to be cancelled.

        pab255 = plana->AddressBlocks[MAXIMUM_ADDRESS];

        //
        // check for null pointer.  Added to fix stress bug
        //
        //  V Raman
        //
        
        if ( pab255 != NULL )
        {
            ReceiveEntry = pab255->ReceiveBroadcastDatagramList.Flink;

            while ( ReceiveEntry != &pab255->ReceiveBroadcastDatagramList ) {
            
                PLIST_ENTRY NextReceiveEntry = ReceiveEntry->Flink;

                PDNCB pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

                if ( pab->NameNumber == pdncb->ncb_num ) {
                    PIRP Irp;

                    RemoveEntryList( &pdncb->ncb_next );

                    Irp = pdncb->irp;

                    IoAcquireCancelSpinLock(&Irp->CancelIrql);

                    //
                    //  Remove the cancel request for this IRP. If its cancelled then its
                    //  ok to just process it because we will be returning it to the caller.
                    //

                    Irp->Cancel = FALSE;

                    IoSetCancelRoutine(Irp, NULL);

                    IoReleaseCancelSpinLock(Irp->CancelIrql);

                    UNLOCK_SPINLOCK( pfcb, OldIrql );

                    NCB_COMPLETE( pdncb, NRC_NAMERR );

                    pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

                    NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );

                    LOCK_SPINLOCK( pfcb, OldIrql );

                }
                    
                ReceiveEntry = NextReceiveEntry;
            }
        }
        
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        CloseListens( pfcb, ppab );
        LOCK_SPINLOCK( pfcb, OldIrql );
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    if ( ( pab->AddressHandle != NULL ) &&
         (( CloseAddress == TRUE ) || ( pab->CurrentUsers == 1 )) ){

        IF_NBDBG( NB_DEBUG_ADDRESS )
        {
            NbPrint( (
            "CleanupAb : Close file invoked for \n"
            ) );

            NbFormattedDump( (PUCHAR) &pab-> Name, sizeof( NAME ) );
        }
            
        NbAddressClose( pab->AddressHandle, pab->AddressObject );

        pab->AddressHandle = NULL;
    }

    DEREFERENCE_AB(ppab);

}


VOID
NbAddressClose(
    IN HANDLE AddressHandle,
    IN PVOID Object
    )
/*++

Routine Description:

    Remove close the handle and dereference the address.

Arguments:

    AddressHandle

    Object

Return Value:

    None.

--*/
{
    NTSTATUS    localstatus;
    KAPC_STATE	ApcState;

    PAGED_CODE();

    ObDereferenceObject( Object );

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);
        localstatus = ZwClose( AddressHandle);
        ASSERT(NT_SUCCESS(localstatus));
        KeUnstackDetachProcess(&ApcState);
    } else {
        localstatus = ZwClose( AddressHandle);
        ASSERT(NT_SUCCESS(localstatus));
    }
}


PPAB
FindAb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IncrementUsers
    )
/*++

Routine Description:

    This routine uses the callers lana number and Name to find the Address
    Block that corresponds to the Ncb. Note, it returns the address of the
    relevant plana->AddressBlocks entry so that deletion of the address
    block is simpler.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Ab is chained onto.

    pdncb - Supplies the connection id from the applications point of view.

    IncrementUsers - TRUE iff performing a listen or call so increment CurrentUsers

Return Value:

    Address of the pointer to the address block or NULL.

--*/
{
    PLANA_INFO plana;
    PAB pab;
    int index;

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("FindAb pfcb: %lx, lana: %lx Failed, returning NULL\n",
                pfcb,
                pdncb->ncb_lana_num));
        }
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("FindAb pfcb: %lx, lana: %lx, lsn: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            pdncb->ncb_lsn));
    }

    for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
        pab = plana->AddressBlocks[index];
        if (( pab != NULL ) &&
            (RtlEqualMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ))) {

            ASSERT( pab->Signature == AB_SIGNATURE );

            IF_NBDBG (NB_DEBUG_ADDRESS) {
                NbPrint( ("ppab %lx, pab: %lx, state:%x\n",
                    &plana->AddressBlocks[index],
                    plana->AddressBlocks[index],
                    pab->Status));

                NbFormattedDump( (PUCHAR)&pab->Name, sizeof(NAME) );
            }

            if ( (pab->Status & 0x07) != REGISTERED ) {
                NCB_COMPLETE( pdncb, NRC_NOWILD );
                //
                //  The name is in a bad state. Tell NewAb not to add the name by
                //  returning non-null. Don't reference the AB.
                //
                if (( (pdncb->ncb_command & ~ ASYNCH) == NCBADDNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBQUICKADDNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBQUICKADDGRNAME ) ||
                    ( (pdncb->ncb_command & ~ ASYNCH) == NCBADDGRNAME )) {
                    return &plana->AddressBlocks[index];
                } else {
                    //  Not NewAb so return Null as usual.
                    return NULL;
                }
            }

            if ( IncrementUsers == TRUE ) {
                REFERENCE_AB(pab);
            }
            return &plana->AddressBlocks[index];
        }
    }

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("Failed return NULL\n"));
    }

    NCB_COMPLETE( pdncb, NRC_NOWILD );
    return NULL;
}

PPAB
FindAbUsingNum(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN UCHAR NameNumber
    )
/*++

Routine Description:

    This routine uses the callers lana number and name number to find the
    Address Block that corresponds to the Ncb.
    Note, it returns the address of the relevant plana->AddressBlocks entry
    so that deletion of the address block is simpler.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Ab is chained onto.

    pdncb - Supplies the applications NCB.

    NameNumber - Supplies the name number to look for. This is not equal to pdncb->ncb_num
        when manipulating broadcast datagrams.

Return Value:

    Address of the pointer to the address block or NULL.

--*/
{
    PLANA_INFO plana;

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        IF_NBDBG (NB_DEBUG_ADDRESS) {
            NbPrint( ("FindAbUsingNum pfcb: %lx, lana: %lx Failed, returning NULL\n",
                pfcb,
                pdncb->ncb_lana_num));
        }
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("FindAbUsingNum pfcb: %lx, lana: %lx, num: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            NameNumber));
    }

    if (( NameNumber < (UCHAR)MAXIMUM_ADDRESS ) &&
        ( plana->AddressBlocks[NameNumber] != NULL) &&
        (( plana->AddressBlocks[NameNumber]->Status & 0x7) == REGISTERED )) {
            return &plana->AddressBlocks[NameNumber];
    }

    //
    //  The user is allowed to receive any and receive broadcast
    //  datagrams on address 255.
    //

    if ((( NameNumber == MAXIMUM_ADDRESS ) &&
         ( plana->AddressBlocks[NameNumber] != NULL)) &&
        (( (pdncb->ncb_command & ~ASYNCH) == NCBRECVANY ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECVBC ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGSENDBC ) ||
         ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECV ))) {
            return &plana->AddressBlocks[NameNumber];
    }

    IF_NBDBG (NB_DEBUG_ADDRESS) {
        NbPrint( ("Failed return NULL\n"));
    }
    NCB_COMPLETE( pdncb, NRC_ILLNN );

    return NULL;
}

NTSTATUS
NbSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID Context - Supplies the PAB or PLANA_INFO associated with this event.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    PAGED_CODE();

    Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = SubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}


NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, NbCompletionEvent, &Event, TRUE, TRUE, TRUE);

    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject(&Event, // Object to wait on.
                                    Executive,  // Reason for waiting
                                    KernelMode, // Processor mode
                                    FALSE,      // Alertable
                                    NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            IoFreeIrp ( Irp );
            return Status;
        }

        Status = Irp->IoStatus.Status;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\devobj.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    devobj.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.

    The device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the provider, called the context.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, NbCreateDeviceContext)

#endif


NTSTATUS
NbCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    DeviceContext - Pointer to a pointer to a transport device context object.

    DeviceName - pointer to the name of the device this device object points to.

    RegistryPath - The name of the Netbios node in the registry.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_CONTEXT deviceContext;
    PAGED_CODE();


    //
    // Create the device object for NETBEUI.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof (DEVICE_CONTEXT) + RegistryPath->Length - sizeof (DEVICE_OBJECT),
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }
    //  DeviceContext contains:
    //      the device object
    //      Intialized
    //      RegistryPath

    deviceContext = (PDEVICE_CONTEXT)deviceObject;

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    //  Determine the IRP stack size that we should "export".
    //

    deviceObject->StackSize = GetIrpStackSize(
                                  RegistryPath,
                                  NB_DEFAULT_IO_STACKSIZE);

    deviceContext->RegistryPath.MaximumLength = RegistryPath->Length;
    deviceContext->RegistryPath.Buffer = (PWSTR)(deviceContext+1);
    RtlCopyUnicodeString( &deviceContext->RegistryPath, RegistryPath );

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction [IRP_MJ_CREATE] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = NbDispatch;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NbDispatch;

    DriverObject-> DriverUnload = NbDriverUnload;

    *DeviceContext = deviceContext;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\connect.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    connection block.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include <zwapi.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbCall)
#pragma alloc_text(PAGE, NbListen)
#pragma alloc_text(PAGE, NbCallCommon)
#pragma alloc_text(PAGE, NbOpenConnection)
#pragma alloc_text(PAGE, NewCb)
#pragma alloc_text(PAGE, CloseConnection)
#endif

LARGE_INTEGER Timeout = { 0xffffffff, 0xffffffff};

NTSTATUS
NbCall(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to make a VC.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbCall ****** pdncb %lx\n", pdncb ));
    }

    LOCK_RESOURCE( pfcb );

    ppcb = NbCallCommon( pdncb, IrpSp );

    if ( ppcb == NULL ) {
        //
        //  The error has been stored in the copy of the NCB. Return
        //  success so the NCB gets copied back.
        //
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;

    pcb->Status = CALL_PENDING;
    if (( pdncb->ncb_command & ~ASYNCH ) == NCBCALL ) {
        PTA_NETBIOS_ADDRESS pConnectBlock =
            ExAllocatePoolWithTag ( NonPagedPool, sizeof(TA_NETBIOS_ADDRESS), 'ySBN');
        PTDI_ADDRESS_NETBIOS temp;

        if ( pConnectBlock == NULL ) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        pConnectBlock->TAAddressCount = 1;
        pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
        pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
        temp = pConnectBlock->Address[0].Address;

        temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
        RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

        //
        //  Post a TdiConnect to the server. This may take a long time so return
        //  STATUS_PENDING so that the application thread gets free again if
        //  it specified ASYNC.
        //

        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);
        pdncb->Information.RemoteAddress = pConnectBlock;
    } else {
        //  XNS NETONE name call
        PTA_NETONE_ADDRESS pConnectBlock =
            ExAllocatePoolWithTag ( NonPagedPool, sizeof (TRANSPORT_ADDRESS) +
                                          sizeof (TDI_ADDRESS_NETONE), 'xSBN' );

        PTDI_ADDRESS_NETONE temp;

        if ( pConnectBlock == NULL ) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        pConnectBlock->TAAddressCount = 1;
        pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETONE;
        pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETONE);
        temp = pConnectBlock->Address[0].Address;

        temp->NetoneNameType = TDI_ADDRESS_NETONE_TYPE_UNIQUE;
        RtlMoveMemory( &temp->NetoneName[0], pdncb->ncb_callname, NCBNAMSZ );

        //
        //  Post a TdiConnect to the server. This may take a long time so return
        //  STATUS_PENDING so that the application thread gets free again if
        //  it specified ASYNC.
        //

        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETONE);
        pdncb->Information.RemoteAddress = pConnectBlock;
    }

    pdncb->ReturnInformation.RemoteAddress = NULL;
    pdncb->ReturnInformation.RemoteAddressLength = 0;

    pdncb->Information.UserDataLength = 0;
    pdncb->Information.OptionsLength = 0;

    TdiBuildConnect (Irp,
                     pcb->DeviceObject,
                     pcb->ConnectionObject,
                     NbCallCompletion,
                     pdncb,
                     &Timeout, // default timeout
                     &pdncb->Information,
                     NULL);

    IoMarkIrpPending( Irp );
    IoCallDriver (pcb->DeviceObject, Irp);

    //
    // The transport has extracted all information from RequestInformation so we can safely
    // exit the current scope.
    //

    UNLOCK_RESOURCE( pfcb );

    return STATUS_PENDING;

}

NTSTATUS
NbCallCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp after an attempt to perform a TdiConnect
    or TdiListen/TdiAccept has been returned by the transport.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    PFCB pfcb = IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext2;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbCallCompletion pdncb: %lx\n" , Context));
    }

    if ( pdncb->Information.RemoteAddress != NULL ) {
        ExFreePool( pdncb->Information.RemoteAddress );
        pdncb->Information.RemoteAddress = NULL;
    }

    if ( pdncb->ReturnInformation.RemoteAddress != NULL ) {
        ExFreePool( pdncb->ReturnInformation.RemoteAddress );
        pdncb->ReturnInformation.RemoteAddress = NULL;
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
    Status = Irp->IoStatus.Status;

    LOCK_SPINLOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE);

    if (( ppcb == NULL ) ||
        ( (*ppcb)->Status == HANGUP_PENDING )) {

        //
        //  The connection has been closed.
        //  Repair the Irp so that the NCB gets copied back.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_SUCCESS;

    } else {
        if ( NT_SUCCESS( Status ) ) {
            (*ppcb)->Status = SESSION_ESTABLISHED;
            NCB_COMPLETE( pdncb, NRC_GOODRET );

        } else {

            //
            //  We need to close down the connection but we are at DPC level
            //  so tell the dll to insert a hangup.
            //

            NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );
            (*ppcb)->Status = SESSION_ABORTED;

            //  repair the Irp so that the NCB gets copied back.
            Irp->IoStatus.Status = STATUS_HANGUP_REQUIRED;
            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            Status = STATUS_HANGUP_REQUIRED;
        }
    }
    if ( ppcb != NULL ) {
        (*ppcb)->UsersNcb = NULL;
    }
    UNLOCK_SPINLOCK( pfcb, OldIrql );

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbCallCompletion exit pdncb: %lx, Status %X\n", pdncb, Status ));
    }


    NbCheckAndCompleteIrp32(Irp);

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
NbListen(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to make a VC by waiting for a call.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    PTA_NETBIOS_ADDRESS pConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbListen ****** pdncb %lx\n", pdncb ));
    }

    LOCK_RESOURCE( pfcb );

    ppcb = NbCallCommon( pdncb, IrpSp );

    if ( ppcb == NULL ) {
        //
        //  The error has been stored in the copy of the NCB. Return
        //  success so the NCB gets copied back.
        //
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;

    pcb->Status = LISTEN_OUTSTANDING;

    //
    //  Build the listen. We either need to tell the transport which
    //  address we are prepared to accept a call from or we need to
    //  supply a buffer for the transport to tell us where the
    //  call came from.
    //

    pConnectBlock = ExAllocatePoolWithTag ( NonPagedPool, sizeof(TA_NETBIOS_ADDRESS), 'zSBN');

    if ( pConnectBlock == NULL ) {
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        UNLOCK_RESOURCE( pfcb );
        return STATUS_SUCCESS;
    }

    pConnectBlock->TAAddressCount = 1;
    pConnectBlock->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    temp = pConnectBlock->Address[0].Address;
    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    pConnectBlock->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);

    if ( pdncb->ncb_callname[0] == '*' ) {
        //  If the name starts with an asterisk then we accept anyone.
        pdncb->ReturnInformation.RemoteAddress = pConnectBlock;
        pdncb->ReturnInformation.RemoteAddressLength =
            sizeof (TRANSPORT_ADDRESS) + sizeof (TDI_ADDRESS_NETBIOS);

        pdncb->Information.RemoteAddress = NULL;
        pdncb->Information.RemoteAddressLength = 0;

    } else {

        RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

        pdncb->Information.RemoteAddress = pConnectBlock;
        pdncb->Information.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                sizeof (TDI_ADDRESS_NETBIOS);

        pdncb->ReturnInformation.RemoteAddress = NULL;
        pdncb->ReturnInformation.RemoteAddressLength = 0;
    }


    //
    //  Post a TdiListen to the server. This may take a long time so return
    //  STATUS_PENDING so that the application thread gets free again if
    //  it specified ASYNC.
    //

    TdiBuildListen (Irp,
                     pcb->DeviceObject,
                     pcb->ConnectionObject,
                     NbListenCompletion,
                     pdncb,
                     TDI_QUERY_ACCEPT,
                     &pdncb->Information,
                     ( pdncb->ncb_callname[0] == '*' )? &pdncb->ReturnInformation
                                                      : NULL
                     );

    IoMarkIrpPending( Irp );
    IoCallDriver (pcb->DeviceObject, Irp);

    UNLOCK_RESOURCE( pfcb );

    return STATUS_PENDING;

}

NTSTATUS
NbListenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when a TdiListen has been returned by the transport.
    We can either reject or accept the call depending on the remote address.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    PFCB pfcb = IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbListenCompletion pdncb: %lx status: %X\n" , Context, Irp->IoStatus.Status));
    }


    //
    // bug # : 73260
    //
    // Added check to see if Status is valid
    //
    
    if ( NT_SUCCESS( Irp-> IoStatus.Status ) )
    {
        if ( pdncb->Information.RemoteAddress != NULL ) {

            ExFreePool( pdncb->Information.RemoteAddress );
            pdncb->Information.RemoteAddress = NULL;

        } else {

            //
            //  This was a listen accepting a call from any address. Return
            //  the remote address.
            //
            PTA_NETBIOS_ADDRESS pConnectBlock;

            ASSERT( pdncb->ReturnInformation.RemoteAddress != NULL );

            pConnectBlock = pdncb->ReturnInformation.RemoteAddress;

            RtlMoveMemory(
                pdncb->ncb_callname,
                pConnectBlock->Address[0].Address->NetbiosName,
                NCBNAMSZ );

            ExFreePool( pdncb->ReturnInformation.RemoteAddress );
            pdncb->ReturnInformation.RemoteAddress = NULL;
        }
    } else {
        if ( pdncb->Information.RemoteAddress != NULL ) {
            ExFreePool( pdncb->Information.RemoteAddress );
            pdncb->Information.RemoteAddress = NULL;
        } else {
            ExFreePool( pdncb->ReturnInformation.RemoteAddress );
            pdncb->ReturnInformation.RemoteAddress = NULL;
        }
    }

    
    LOCK_SPINLOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE );

    if (( ppcb == NULL ) ||
        ( (*ppcb)->Status == HANGUP_PENDING )) {

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        //
        //  The connection has been closed.
        //  Repair the Irp so that the NCB gets copied back.
        //

        NCB_COMPLETE( pdncb, NRC_NAMERR );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_SUCCESS;

    } 

    //
    // bug # : 70837
    //
    // Added check for cancelled listens
    //
    
    else if ( ( (*ppcb)-> Status == SESSION_ABORTED ) ||
              ( !NT_SUCCESS( Irp-> IoStatus.Status ) ) )
    {
        UNLOCK_SPINLOCK( pfcb, OldIrql );

        if ( (*ppcb)-> Status == SESSION_ABORTED ) 
        {
            NCB_COMPLETE( pdncb, NRC_CMDCAN );
        }
        else
        {
            (*ppcb)-> Status = SESSION_ABORTED;
            NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );
        }

        //
        //  repair the Irp so that the NCB gets copied back.
        //  Tell the dll to hangup the connection.
        //

        Irp->IoStatus.Status = STATUS_HANGUP_REQUIRED;
        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        Status = STATUS_HANGUP_REQUIRED;
    }

    else
    {
        PDEVICE_OBJECT DeviceObject;

        
        pcb = *ppcb;

        DeviceObject = pcb-> DeviceObject;
        

        //  Tell application how many bytes were transferred
        pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

        RtlMoveMemory(
            &pcb->RemoteName,
            pdncb->ncb_callname,
            NCBNAMSZ );

        //
        //  Tell IopCompleteRequest how much to copy back when the request
        //  completes.
        //

        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        TdiBuildAccept (Irp,
                         pcb->DeviceObject,
                         pcb->ConnectionObject,
                         NbCallCompletion,
                         pdncb,
                         NULL,
                         NULL);
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        IoCallDriver (DeviceObject, Irp);

        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }


    IF_NBDBG (NB_DEBUG_COMPLETE | NB_DEBUG_CALL) {
        NbPrint( ("NbListenCompletion exit pdncb: %lx, Status: %X\n" , pdncb, Status));
    }

    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
        NbCheckAndCompleteIrp32(Irp);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    return Status;
    UNREFERENCED_PARAMETER( DeviceObject );
}

PPCB
NbCallCommon(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine contains the common components used in creating a
    connection either by a TdiListen or TdiCall.

Arguments:

    pdncb - Pointer to the NCB.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the address of the pointer in the ConnectionBlocks to
    the connection block for this call.


--*/

{
    PPCB ppcb = NULL;
    PCB pcb = NULL;
    PAB pab;
    PPAB ppab;
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PIRP IIrp;
    KEVENT Event1;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb1;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    //
    //  Initialize the lsn so that if we return an error and the application
    //  ignores it then we will not reuse a valid lsn.
    //
    pdncb->ncb_lsn = 0;

    ppcb = NewCb( IrpSp, pdncb );

    if ( ppcb == NULL ) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  FAILED on create Cb of %s\n", pdncb->ncb_name));
        }

        return NULL;    //  NewCb will have filled in the error code.
    }

    pcb = *ppcb;
    ppab = pcb->ppab;
    pab = *ppab;

    //
    // Create an event for the synchronous I/O requests that we'll be issuing.
    //

    KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

    //
    // Open the connection on the transport.
    //

    Status = NbOpenConnection (&pcb->ConnectionHandle, (PVOID*)&pcb->ConnectionObject, pfcb, ppcb, pdncb);
    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  FAILED on open of server Connection: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        return NULL;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "NbCallCommon: Associate address\n"));
    }

    pcb->DeviceObject = IoGetRelatedDeviceObject( pcb->ConnectionObject );

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }

    IIrp = TdiBuildInternalDeviceControlIrp (
                TDI_ASSOCIATE_ADDRESS,
                pcb->DeviceObject,
                pcb->ConnectionObject,
                &Event1,
                &Iosb1);

    TdiBuildAssociateAddress (
                IIrp,
                pcb->DeviceObject,
                pcb->ConnectionObject,
                NULL,
                NULL,
                pab->AddressHandle);

    Status = IoCallDriver (pcb->DeviceObject, IIrp);

    if (Status == STATUS_PENDING) {

        //
        // Wait for event to be signalled while ignoring alerts
        //
        
        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);
        
        if (!NT_SUCCESS(Status)) {
            IF_NBDBG (NB_DEBUG_CALL) {
                NbPrint(( "\n  FAILED Event1 Wait: %X ******\n", Status ));
            }
            NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
            if (ProcessAttached) {
                KeUnstackDetachProcess(&ApcState);
            }
            (*ppcb)->DisconnectReported = TRUE;
            CleanupCb( ppcb, NULL );
            return NULL;
        }
        Status = Iosb1.Status;
    }

    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint(( "\n  AssociateAddress FAILED  Status: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NbMakeNbError( Status ) );
        (*ppcb)->DisconnectReported = TRUE;
        CleanupCb( ppcb, NULL );
        return NULL;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "NbCallCommon: returning ppcb: %lx\n", ppcb ));
    }
    return ppcb;
}

NTSTATUS
NbHangup(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to hangup a VC. This cancels all receives
    and waits for all pending sends to complete before returning. This
    functionality is offered directly by the underlying TDI driver so
    NetBIOS just passes the Irp down to the transport.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Supplies Io request packet describing the Hangup NCB.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPCB ppcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    NTSTATUS Status;

    LOCK( pfcb, OldIrql );

    pdncb->pfcb = pfcb;
    pdncb->irp = Irp;
    ppcb = FindCb( pfcb, pdncb, FALSE );

    if ( ppcb == NULL ) {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;  //  Connection gone already
    }

    if ((*ppcb)->Status == SESSION_ESTABLISHED ) {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    } else {
        if (((*ppcb)->Status == SESSION_ABORTED ) ||
            ((*ppcb)->Status == HANGUP_PENDING )) {
            NCB_COMPLETE( pdncb, NRC_SCLOSED );
        } else {
            NCB_COMPLETE( pdncb, NRC_TOOMANY ); // try later
            UNLOCK( pfcb, OldIrql );;
            return STATUS_SUCCESS;
        }
    }

    (*ppcb)->Status = HANGUP_PENDING;
    (*ppcb)->DisconnectReported = TRUE;

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    Status = CleanupCb( ppcb, pdncb );

    UNLOCK_RESOURCE( pfcb );

    return Status;
}

NTSTATUS
NbOpenConnection (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PFCB pfcb,
    IN PVOID ConnectionContext,
    IN PDNCB pdncb
    )
/*++

Routine Description:

    Makes a call to a remote address.
Arguments:

    FileHandle - Pointer to where the handle to the Transport for this virtual
        connection should be stored.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - Supplies the fcb and therefore the DriverName for this lana.

    ConnectionContext -  Supplies the Cb to be used with this connection on
        all indications from the transport. Its actually the address of
        the pcb in the ConnectionBlocks array for this lana.

    pdncb - Supplies the ncb requesting the new virtual connection.

Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    KAPC_STATE	ApcState;
    BOOLEAN ProcessAttached = FALSE;

    PAGED_CODE();

    InitializeObjectAttributes (
        &ObjectAttributes,
        &pfcb->pDriverName[pdncb->ncb_lana_num],
        0,
        NULL,
        NULL);

    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePoolWithTag (NonPagedPool,
                    sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT), 'eSBN' );
    if (EaBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

    RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

    RtlMoveMemory (
        &EaBuffer->EaName[EaBuffer->EaNameLength + 1],
        &ConnectionContext,
        sizeof (CONNECTION_CONTEXT));

    if (PsGetCurrentProcess() != NbFspProcess) {
        KeStackAttachProcess(NbFspProcess, &ApcState);

        ProcessAttached = TRUE;
    }


    IF_NBDBG( NB_DEBUG_CALL )
    {
        NbPrint( (
            "NbOpenConnection: Create file invoked on %d for \n", 
            pdncb-> ncb_lana_num
            ) );

        NbFormattedDump( pdncb-> ncb_callname, NCBNAMSZ );
    }
    
    Status = ZwCreateFile (
                 FileHandle,
                 GENERIC_READ | GENERIC_WRITE,
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // block size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 0,
                 FILE_CREATE,
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                    sizeof(CONNECTION_CONTEXT) ); // EA length.

    ExFreePool( EaBuffer );

    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS( Status )) {
        Status = ObReferenceObjectByHandle (
                    *FileHandle,
                    0L,
                    NULL,
                    KernelMode,
                    Object,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            NTSTATUS localstatus;

            IF_NBDBG( NB_DEBUG_CALL )
            {
                NbPrint( (
                    "NbOpenConnection: error : Close file invoked for %d\n", 
                    pdncb-> ncb_lana_num 
                    ) );
            }
            
            localstatus = ZwClose( *FileHandle);

            ASSERT(NT_SUCCESS(localstatus));

            *FileHandle = NULL;
        }
    }


    if (ProcessAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("NbOpenConnection Status:%X, IoStatus:%X.\n", Status, IoStatusBlock.Status));
    }


    if (!NT_SUCCESS( Status )) {
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("NbOpenConnection:  FAILURE, status code=%X.\n", Status));
        }
        return Status;
    }

    return Status;
} /* NbOpenConnection */

PPCB
NewCb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    )
/*++

Routine Description:

Arguments:

    IrpSp - Pointer to current IRP stack frame.

    pdncb - Supplies the ncb requesting the new virtual connection.

Return Value:

    The address of the pointer to the new Cb in the ConnectionBlocks
    Array.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PCB pcb;
    PPCB ppcb = NULL;
    PFCB pfcb = FileObject->FsContext2;
    PLANA_INFO plana;
    int index;
    PPAB ppab;

    PAGED_CODE();

    if (pdncb->ncb_lana_num > pfcb->MaxLana ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        IF_NBDBG (NB_DEBUG_CALL) {
            if ( pfcb == NULL ) {
                NbPrint( ("NewCb pfcb==NULL\n"));
            } else {
                if ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) {
                    NbPrint( ("NewCb pfcb->ppLana[%x]==NULL\n",
                        pdncb->ncb_lana_num));
                } else {
                    NbPrint( ("NewCb pfcb->ppLana[%x]->Status = %x\n",
                        pdncb->ncb_lana_num,
                        pfcb->ppLana[pdncb->ncb_lana_num]->Status));
                }
            }
        }

        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }
    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    if ( plana->ConnectionCount == plana->MaximumConnection ) {
        NCB_COMPLETE( pdncb, NRC_LOCTFUL );
        return NULL;
    }

    ppab = FindAb( pfcb, pdncb, TRUE );

    if ( ppab == NULL ) {
        //
        //  This application is only allowed to use names that have been
        //  addnamed by this application or the special address 0.
        //
        return NULL;

    }

    //  FindAb has incremented the number of CurrentUsers for this address block.

    //
    //  Find the appropriate session number to use.
    //

    index = plana->NextConnection;
    while ( plana->ConnectionBlocks[index] != NULL ) {
        index++;
        if ( index > MAXIMUM_CONNECTION ) {
            index = 1;
        }
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("NewCb pfcb: %lx, plana: %lx, index: %lx, ppcb: %lx, pcb: %lx\n",
                pfcb,
                pdncb->ncb_lana_num,
                index,
                &plana->ConnectionBlocks[index],
                plana->ConnectionBlocks[index] ));
        }
    }

    plana->ConnectionCount++;
    plana->NextConnection = index + 1;
    if ( plana->NextConnection > MAXIMUM_CONNECTION ) {
        plana->NextConnection = 1;
    }

    //
    //  Fill in the LSN so that the application will be able
    //  to reference this connection in the future.
    //

    pdncb->ncb_lsn = (unsigned char)index;

    ppcb = &plana->ConnectionBlocks[index];

    *ppcb = pcb = ExAllocatePoolWithTag (NonPagedPool, sizeof(CB), 'cSBN');

    if (pcb==NULL) {

        DEREFERENCE_AB(ppab);
        NCB_COMPLETE( pdncb, NbMakeNbError( STATUS_INSUFFICIENT_RESOURCES ) );
        return NULL;
    }

    pcb->ppab = ppab;
    pcb->ConnectionHandle = NULL;
    pcb->ConnectionObject = NULL;
    pcb->DeviceObject = NULL;
    pcb->pLana = plana;
    pcb->ReceiveIndicated = 0;
    pcb->DisconnectReported = FALSE;
    InitializeListHead(&pcb->ReceiveList);
    InitializeListHead(&pcb->SendList);
    RtlMoveMemory( &pcb->RemoteName, pdncb->ncb_callname, NCBNAMSZ);
    pcb->Adapter = plana;
    pcb->SessionNumber = (UCHAR)index;
    pcb->ReceiveTimeout = pdncb->ncb_rto;
    pcb->SendTimeout = pdncb->ncb_sto;

    //
    //  Fill in the Users virtual address so we can cancel the Listen/Call
    //  if the user desires.
    //

    pcb->UsersNcb = pdncb->users_ncb;
    pcb->pdncbCall = pdncb;
    pcb->pdncbHangup = NULL;

    if (( pcb->ReceiveTimeout != 0 ) ||
        ( pcb->SendTimeout != 0 )) {
        NbStartTimer( pfcb );
    }

    pcb->Signature = CB_SIGNATURE;
    pcb->Status = 0;    //  An invalid value!

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("NewCb pfcb: %lx, ppcb: %lx, pcb= %lx, lsn %lx\n",
            pfcb,
            ppcb,
            pcb,
            index));
    }

    return ppcb;
} /* NewCb */

NTSTATUS
CleanupCb(
    IN PPCB ppcb,
    IN PDNCB pdncb OPTIONAL
    )
/*++

Routine Description:

    This closes the handles in the Cb and dereferences the objects.

    Note: Resource must be held before calling this routine.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

    pdncb - Optional Address of the Hangup DNCB.

Return Value:

    STATUS_PENDING if Hangup held due to an outstanding send. Otherwise STATUS_SUCCESS

--*/

{
    PCB pcb;
    PDNCB pdncbHangup;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PFCB pfcb;
    PDNCB pdncbtemp;
    PDNCB pdncbReceiveAny;

    if ( ppcb == NULL ) {
        ASSERT( FALSE );
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb ppcb: %lx, pdncb: %lx\n", ppcb, pdncb));
        }
        return STATUS_SUCCESS;
    }

    pcb = *ppcb;
    pfcb = pcb->pLana->pFcb;

    LOCK_SPINLOCK( pfcb, OldIrql );
    ppab = (*ppcb)->ppab;

    if ( pcb == NULL ) {
        ASSERT( FALSE );
        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb ppcb: %lx, pcb %lx, pdncb %lx\n", ppcb, pcb, pdncb));
        }
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }

    ASSERT( pcb->Signature == CB_SIGNATURE );

    //
    //  Set pcb->pdncbHangup to NULL. This prevents NbCompletionPDNCB from queueing a CleanupCb
    //  if we Close the connection and cause sends to get returned.
    //

    pdncbHangup = pcb->pdncbHangup;
    pcb->pdncbHangup = NULL;

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CleanupCb ppcb: %lx, pcb= %lx\n", ppcb, pcb));
    }

    //
    //  If this is a Hangup (only time pdncb != NULL
    //  and we do not have a hangup on this connection
    //  and there are outstanding sends then delay the hangup.
    //

    if (( pdncb != NULL ) &&
        ( pdncbHangup == NULL ) &&
        ( !IsListEmpty(&pcb->SendList) )) {

        ASSERT(( pdncb->ncb_command & ~ASYNCH ) == NCBHANGUP );

        //
        //  We must wait up to 20 seconds for the send to complete before removing the
        //  connection.
        //

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CleanupCb delaying Hangup, waiting for send to complete\n"));
        }

        pcb->pdncbHangup = pdncb;
        //  reset retcode so that NCB_COMPLETE will process the next NCB_COMPLETE.
        pcb->pdncbHangup->ncb_retcode = NRC_PENDING;
        pdncb->tick_count = 40;
        UNLOCK_SPINLOCK( pfcb, OldIrql );
        NbStartTimer( pfcb );
        return STATUS_PENDING;
    }

    pcb->Status = SESSION_ABORTED;

    //  Cancel all the receive requests for this connection.

    while ( (pdncbtemp = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

        NCB_COMPLETE( pdncbtemp, NRC_SCLOSED );

        pdncbtemp->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        NbCompleteRequest( pdncbtemp->irp, STATUS_SUCCESS );
        pcb->DisconnectReported = TRUE;

    }

    if (pcb->DisconnectReported == FALSE) {
        //
        //  If there is a receive any on the name associated with this connection then
        //  return one receive any to the application. If there are no receive any's then
        //  don't worry. The spec says to do this regardless of whether we have told
        //  the application that the connection is closed using a receive or send.
        //  Indeed the spec says to do this even if the application gave us a hangup!
        //

        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );

            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_SUCCESS );
            pcb->DisconnectReported = TRUE;

        } else {

            PAB pab255 = pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];
            //
            //  If there is a receive any for any name then
            //  return one receive any to the application. If there are no receive any
            //  any's then don't worry.
            //

            if ( (pdncbReceiveAny = DequeueRequest( &pab255->ReceiveAnyList)) != NULL ) {

                pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
                pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;
                NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );

                pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                NbCompleteRequest( pdncbReceiveAny->irp, STATUS_SUCCESS );
                pcb->DisconnectReported = TRUE;

            }
        }
    }


    UNLOCK_SPINLOCK( pfcb, OldIrql );

    CloseConnection( ppcb, 20000 );

    LOCK_SPINLOCK( pfcb, OldIrql );

    //
    //  Any sends will have been returned to the caller by now because of the NtClose on the
    //  ConnectionHandle. Tell the caller that the hangup is complete if we have a hangup.
    //

    if ( pdncbHangup != NULL ) {
        NCB_COMPLETE( pdncbHangup, NRC_GOODRET );
        pdncbHangup->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
        NbCompleteRequest( pdncbHangup->irp, STATUS_SUCCESS );
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CleanupCb pcb: %lx, ppab: %lx, AddressHandle: %lx\n",
            pcb,
            ppab,
            (*ppab)->AddressHandle));

        NbFormattedDump( (PUCHAR)&(*ppab)->Name, sizeof(NAME) );
    }

    //
    //  IBM test Mif081.c states that it is not necessary to report the disconnection
    //  of a session if the name has already been deleted.
    //

    if (( pcb->DisconnectReported == TRUE ) ||
        ( ((*ppab)->Status & 7 ) == DEREGISTERED )) {
        pcb->Adapter->ConnectionCount--;
        *ppcb = NULL;

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        DEREFERENCE_AB( ppab );
        ExFreePool( pcb );

    } else {
        UNLOCK_SPINLOCK( pfcb, OldIrql );
    }
    return STATUS_SUCCESS;
}

VOID
AbandonConnection(
    IN PPCB ppcb
    )
/*++

Routine Description:

    This routine examines the connection block and attempts to find a request to
    send a session abort status plus it completes the Irp with STATUS_HANGUP_REQUIRED.
    It always changes the status of the connection so that further requests are correctly
    rejected. Upon getting the STATUS_HANGUP_REQUIRED, the dll will submit a hangup NCB
    which will call CleanupCb.

    This round about method is used because of the restrictions caused by being at Dpc or Apc
    level and in the wrong context when the transport indicates that the connection is to
    be cleaned up.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

Return Value:

    None.

--*/

{
    PCB pcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PFCB pfcb;
    PPAB ppab;
    PDNCB pdncb;
    PDNCB pdncbReceiveAny;

    pcb = *ppcb;

    if (pcb != NULL)
    {
        pfcb = pcb->pLana->pFcb;

        LOCK_SPINLOCK( pfcb, OldIrql );

        ASSERT( pcb->Signature == CB_SIGNATURE );

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("AbandonConnection ppcb: %lx, pcb= %lx\n", ppcb, pcb));
        }
        pcb->Status = SESSION_ABORTED;

        while ( (pdncb = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncb, NRC_SCLOSED );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        if ( pcb->pdncbHangup != NULL ) {
            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pcb->pdncbHangup, NRC_SCLOSED );
            pcb->pdncbHangup->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pcb->pdncbHangup->irp, STATUS_HANGUP_REQUIRED );
            pcb->pdncbHangup = NULL;
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        //
        //  If there is a receive any on the name associated with this connection then
        //  return one receive any to the application.
        //

        ppab = (*ppcb)->ppab;
        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );
            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        //
        //  If there is a receive any any with the lana associated with this connection then
        //  return one receive any to the application. If there are no receive any's then
        //  don't worry.

        ppab = &pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];
        if ( (pdncbReceiveAny = DequeueRequest( &(*ppab)->ReceiveAnyList)) != NULL ) {

            pdncbReceiveAny->ncb_num = (*ppab)->NameNumber;
            pdncbReceiveAny->ncb_lsn = pcb->SessionNumber;

            pcb->DisconnectReported = TRUE;
            NCB_COMPLETE( pdncbReceiveAny, NRC_SCLOSED );
            pdncbReceiveAny->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncbReceiveAny->irp, STATUS_HANGUP_REQUIRED );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return;
        }

        UNLOCK_SPINLOCK( pfcb, OldIrql );
    }

    return;
}

VOID
CloseConnection(
    IN PPCB ppcb,
    IN DWORD dwTimeOutInMS
    )
/*++

Routine Description:

    This routine examines the connection block and attempts to close the connection
    handle to the transport. This will complete all outstanding requests.

    This routine assumes the spinlock is not held but the resource is.

Arguments:

    ppcb - Address of the pointer to the Cb containing handles and objects.

    dwTimeOutInMS - Timeout value in milliseconds for Disconnect 

Return Value:

    None.

--*/

{
    PCB pcb;
    NTSTATUS localstatus;

    PAGED_CODE();

    pcb = *ppcb;

    ASSERT( pcb->Signature == CB_SIGNATURE );

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("CloseConnection ppcb: %lx, pcb= %lx\n", ppcb, pcb));
    }

    if ( pcb->ConnectionHandle ) {
        HANDLE Handle;

        Handle = pcb->ConnectionHandle;
        pcb->ConnectionHandle = NULL;

        //
        //  If we have a connection, request an orderly disconnect.
        //

        if ( pcb->ConnectionObject != NULL ) {
            PIRP Irp;
            LARGE_INTEGER DisconnectTimeout;

            DisconnectTimeout.QuadPart = Int32x32To64( dwTimeOutInMS, -10000 );

            Irp = IoAllocateIrp( pcb->DeviceObject->StackSize, FALSE);

            //
            //  If we cannot allocate an Irp, the ZwClose will cause a disorderly
            //  disconnect.
            //

            if (Irp != NULL) {
                TdiBuildDisconnect(
                    Irp,
                    pcb->DeviceObject,
                    pcb->ConnectionObject,
                    NULL,
                    NULL,
                    &DisconnectTimeout,
                    TDI_DISCONNECT_RELEASE,
                    NULL,
                    NULL);

                SubmitTdiRequest(pcb->ConnectionObject, Irp);

                IoFreeIrp(Irp);
            }

            // Remove reference put on in NbOpenConnection

            ObDereferenceObject( pcb->ConnectionObject );

            pcb->DeviceObject = NULL;
            pcb->ConnectionObject = NULL;
        }

        IF_NBDBG( NB_DEBUG_CALL )
        {
            NbPrint( (
                "CloseConnection : Close file invoked for \n"
            ) );

            NbFormattedDump( (PUCHAR) &pcb-> RemoteName, sizeof( NAME ) );
        }
            

        if (PsGetCurrentProcess() != NbFspProcess) {
            KAPC_STATE	ApcState;

            KeStackAttachProcess(NbFspProcess, &ApcState);
            localstatus = ZwClose( Handle);
            ASSERT(NT_SUCCESS(localstatus));
            KeUnstackDetachProcess(&ApcState);
        } else {
            localstatus = ZwClose( Handle);
            ASSERT(NT_SUCCESS(localstatus));
        }
    }
    return;
}

PPCB
FindCb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IgnoreState
    )
/*++

Routine Description:

    This routine uses the callers lana number and LSN to find the Cb.

Arguments:

    pfcb - Supplies a pointer to the Fcb that Cb is chained onto.

    pdncb - Supplies the connection id from the applications point of view.

    IgnoreState - Return even if connection in error.

Return Value:

    The address of the pointer to the connection block or NULL.

--*/

{
    PPCB ppcb;
    UCHAR Status;

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("FindCb pfcb: %lx, lana: %lx, lsn: %lx\n",
            pfcb,
            pdncb->ncb_lana_num,
            pdncb->ncb_lsn));
    }

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    if (( pdncb->ncb_lsn > MAXIMUM_CONNECTION ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->ConnectionBlocks[pdncb->ncb_lsn] == NULL)) {

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( (" not found\n"));
        }

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return NULL;
    }

    ppcb = &(pfcb->ppLana[pdncb->ncb_lana_num]->ConnectionBlocks[pdncb->ncb_lsn]);
    Status = (*ppcb)->Status;

    //
    //  Hangup and session status can be requested whatever state the
    //  connections in. Call and Listen use FindCb only to find and modify
    //  the Status so they are allowed also.
    //

    if (( Status != SESSION_ESTABLISHED ) &&
        ( !IgnoreState )) {

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("FindCb Status %x\n", Status));
        }

        if (( pdncb->ncb_retcode == NRC_PENDING ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBHANGUP ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBSSTAT ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBCALL ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCALLNIU ) &&
            (( pdncb->ncb_command & ~ASYNCH) != NCBLISTEN )) {

            if ( Status == SESSION_ABORTED ) {

                (*ppcb)->DisconnectReported = TRUE;
                NCB_COMPLETE( pdncb, NRC_SCLOSED );

            } else {

                NCB_COMPLETE( pdncb, NRC_TOOMANY ); // Try again later

            }

            //
            //  On hangup we want to pass the connection back to give
            //  cleanupcb a chance to destroy the connection. For all
            //  other requests return NULL.
            //

            if (( pdncb->ncb_command & ~ASYNCH) != NCBHANGUP ) {
                return NULL;
            }

        }
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( (", ppcb= %lx\n", ppcb ));
    }

    ASSERT( (*ppcb)->Signature == CB_SIGNATURE );

    return ppcb;
}

BOOL
FindActiveSession(
    IN PFCB pfcb,
    IN PDNCB pdncb OPTIONAL,
    IN PPAB ppab
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pdncb - Supplies the ncb requesting the Delete Name.

    ppab - Supplies (indirectly) the TDI handle to scan for.

Return Value:

    TRUE iff there is an active session found using this handle.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana = (*ppab)->pLana;
    int index;

    if ( ARGUMENT_PRESENT(pdncb) ) {
        if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return FALSE;
        }

        if (( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return FALSE;
        }
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("FindActiveSession index:%x connections ppab: %lx = ppab: %lx state: %x\n",
                index,
                plana->ConnectionBlocks[index]->ppab,
                ppab,
                plana->ConnectionBlocks[index]->Status));
        }
        //  Look for active sessions on this address.
        if (( plana->ConnectionBlocks[index]->ppab == ppab ) &&
            ( plana->ConnectionBlocks[index]->Status == SESSION_ESTABLISHED )) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
CloseListens(
    IN PFCB pfcb,
    IN PPAB ppab
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    ppab - All listens using this address are to be closed.

Return Value:

    none.

--*/

{
    PLANA_INFO plana;
    int index;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = (*ppab)->pLana;
    LOCK_SPINLOCK( pfcb, OldIrql );

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        IF_NBDBG (NB_DEBUG_CALL) {
            NbPrint( ("CloseListen index:%x connections ppab: %lx = ppab: %lx state: %x\n",
                index,
                plana->ConnectionBlocks[index]->ppab,
                ppab,
                plana->ConnectionBlocks[index]->Status));
        }
        //  Look for a listen on this address.
        if (( plana->ConnectionBlocks[index]->ppab == ppab ) &&
            ( plana->ConnectionBlocks[index]->Status == LISTEN_OUTSTANDING )) {
            PDNCB pdncb = plana->ConnectionBlocks[index]->pdncbCall;
            NCB_COMPLETE( pdncb, NRC_NAMERR );
            plana->ConnectionBlocks[index]->DisconnectReported = TRUE;
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            CleanupCb( &plana->ConnectionBlocks[index], NULL);
            LOCK_SPINLOCK( pfcb, OldIrql );
        }
    }
    UNLOCK_SPINLOCK( pfcb, OldIrql );
}

PPCB
FindCallCb(
    IN PFCB pfcb,
    IN PNCB pncb,
    IN UCHAR ucLana
    )
/*++

Routine Description:

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pncb - Supplies the USERS VIRTUAL address CALL or LISTEN ncb to be
           cancelled.

Return Value:

    The address of the pointer to the connection block or NULL.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana;
    int index;

    if ( ucLana > pfcb->MaxLana ) {
        return NULL;
    }

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[ucLana] == NULL ) ||
        ( pfcb->ppLana[ucLana]->Status != NB_INITIALIZED)) {
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[ucLana];

    for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if (( plana->ConnectionBlocks[index] != NULL ) &&
            ( plana->ConnectionBlocks[index]->UsersNcb == pncb )) {
            return &plana->ConnectionBlocks[index];
        }
    }

    return NULL;
}

PPCB
FindReceiveIndicated(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    )
/*++

Routine Description:


    Find either a connection with a receive indicated or one that has been
    disconnected but not reported yet.

Arguments:

    pfcb - Supplies a pointer to the callers Fcb.

    pdncb - Supplies the ncb with the receive any.

    ppab - Supplies (indirectly) the TDI handle to scan for.

Return Value:

    PPCB - returns the connection with the indicated receive.

--*/

{
    PPCB ppcb = NULL;
    PLANA_INFO plana;
    int index;

    if (( pfcb == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return NULL;
    }

    ASSERT( pfcb->Signature == FCB_SIGNATURE );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    for ( index=0 ; index <= MAXIMUM_CONNECTION; index++ ) {

        if ( plana->ConnectionBlocks[index] == NULL ) {
            continue;
        }

        if ( pdncb->ncb_num == MAXIMUM_ADDRESS) {

            //  ReceiveAny on Any address
            if (( plana->ConnectionBlocks[index]->ReceiveIndicated != 0 ) ||
                (( plana->ConnectionBlocks[index]->Status == SESSION_ABORTED ) &&
                 ( plana->ConnectionBlocks[index]->DisconnectReported == FALSE ))) {
                PPAB ppab;

                pdncb->ncb_lsn = (UCHAR)index;
                ppab = plana->ConnectionBlocks[index]->ppab;
                pdncb->ncb_num = (*ppab)->NameNumber;
                return &plana->ConnectionBlocks[index];
            }
        } else {
            if ( plana->ConnectionBlocks[index]->ppab == ppab ) {
                //  This connection is using the correct address.
                if (( plana->ConnectionBlocks[index]->ReceiveIndicated != 0 ) ||
                    (( plana->ConnectionBlocks[index]->Status == SESSION_ABORTED ) &&
                     ( plana->ConnectionBlocks[index]->DisconnectReported == FALSE ))) {
                    pdncb->ncb_lsn = (UCHAR)index;
                    return &plana->ConnectionBlocks[index];
                }
            }
        }
    }

    return NULL;
}

NTSTATUS
NbTdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators
    )
/*++

Routine Description:

    This routine is called when a session is disconnected from a remote
    machine.

Arguments:

    IN PVOID EventContext,
    IN PCONNECTION_CONTEXT ConnectionContext,
    IN ULONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectIndicators

Return Value:

    NTSTATUS - Status of event indicator

--*/

{


    IF_NBDBG (NB_DEBUG_CALL) {
        PPCB ppcb = ConnectionContext;
        NbPrint( ("NbTdiDisconnectHandler ppcb: %lx, pcb %lx\n", ppcb, (*ppcb)));
    }

    AbandonConnection( (PPCB)ConnectionContext );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(EventContext);
    UNREFERENCED_PARAMETER(DisconnectDataLength);
    UNREFERENCED_PARAMETER(DisconnectData);
    UNREFERENCED_PARAMETER(DisconnectInformationLength);
    UNREFERENCED_PARAMETER(DisconnectInformation);
    UNREFERENCED_PARAMETER(DisconnectIndicators);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    translation between Netbios error codes and NTSTATUS codes.

Author:

    Colin Watson (ColinW) 28-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
struct {
    unsigned char NbError;
    NTSTATUS NtStatus;
} Nb_Error_Map[] = {
    { NRC_GOODRET         , STATUS_SUCCESS},
    { NRC_PENDING         , STATUS_PENDING},
    { NRC_ILLCMD          , STATUS_INVALID_DEVICE_REQUEST},
    { NRC_BUFLEN          , STATUS_INVALID_PARAMETER},
    { NRC_CMDTMO          , STATUS_IO_TIMEOUT},
    { NRC_INCOMP          , STATUS_BUFFER_OVERFLOW},
    { NRC_INCOMP          , STATUS_BUFFER_TOO_SMALL},
    { NRC_SNUMOUT         , STATUS_INVALID_HANDLE},
    { NRC_NORES           , STATUS_INSUFFICIENT_RESOURCES},
    { NRC_CMDCAN          , STATUS_CANCELLED},
    { NRC_INUSE           , STATUS_DUPLICATE_NAME},
    { NRC_NAMTFUL         , STATUS_TOO_MANY_NAMES},
    { NRC_LOCTFUL         , STATUS_TOO_MANY_SESSIONS},
    { NRC_REMTFUL         , STATUS_REMOTE_NOT_LISTENING},
    { NRC_NOCALL	  , STATUS_BAD_NETWORK_PATH},
    { NRC_NOCALL	  , STATUS_HOST_UNREACHABLE},
    { NRC_NOCALL          , STATUS_CONNECTION_REFUSED},
    { NRC_LOCKFAIL        , STATUS_WORKING_SET_QUOTA},
    { NRC_SABORT	  , STATUS_REMOTE_DISCONNECT},
    { NRC_SABORT	  , STATUS_CONNECTION_RESET},
    { NRC_SCLOSED         , STATUS_LOCAL_DISCONNECT},
    { NRC_SABORT          , STATUS_LINK_FAILED},
    { NRC_DUPNAME         , STATUS_SHARING_VIOLATION},
    { NRC_SYSTEM          , STATUS_UNSUCCESSFUL},
    { NRC_BUFLEN          , STATUS_ACCESS_VIOLATION},
    { NRC_ILLCMD          , STATUS_NONEXISTENT_EA_ENTRY}
};

#define NUM_NB_ERRORS sizeof(Nb_Error_Map) / sizeof(Nb_Error_Map[0])

unsigned char
NbMakeNbError(
    IN NTSTATUS Error
    )
/*++

Routine Description:

    This routine converts the NTSTATUS to and NBCB error.

Arguments:

    Error   -   Supplies the NTSTATUS to be converted.

Return Value:

    The mapped error.

--*/
{
    int i;

    for (i=0;i<NUM_NB_ERRORS;i++) {
        if (Nb_Error_Map[i].NtStatus == Error) {

            IF_NBDBG (NB_DEBUG_ERROR_MAP) {
                NbPrint( ("NbMakeNbError %X becomes  %x\n",
                Error,
                Nb_Error_Map[i].NbError));
            }

            return Nb_Error_Map[i].NbError;
        }
    }
    IF_NBDBG (NB_DEBUG_ERROR_MAP) {
        NbPrint( ("NbMakeNbError %X becomes  %x\n", Error, NRC_SYSTEM ));
    }

    return NRC_SYSTEM;

}

NTSTATUS
NbLanStatusAlert(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is used to save a lan_status_alert NCB for a
    particular network adapter.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PLANA_INFO plana;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint(( "\n****** Start of NbLanStatusAlert ****** pdncb %lx\n", pdncb ));
    }

    LOCK( pfcb, OldIrql );

    if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {

        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    if (( pfcb->ppLana[pdncb->ncb_lana_num] == (LANA_INFO *) NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbPrint( (" not found\n"));
        }

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return STATUS_SUCCESS;
    }

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    QueueRequest(&plana->LanAlertList, pdncb, Irp, pfcb, OldIrql, FALSE);

    return STATUS_PENDING;
}

VOID
CancelLanAlert(
    IN PFCB pfcb,
    IN PDNCB pdncb
    )
/*++

Routine Description:

    This routine is used to cancel a lan_status_alert NCB for a
    particular network adapter.

Arguments:

    pfcb - Supplies a pointer to the Fcb that the NCB refers to.

    pdncb - Pointer to the NCB.

Return Value:

    none.

--*/

{
    PLANA_INFO plana;
    PLIST_ENTRY Entry;
    PLIST_ENTRY NextEntry;

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint(( "\n****** Start of CancelLanAlert ****** pdncb %lx\n", pdncb ));
    }

    if ( pdncb->ncb_lana_num > pfcb->MaxLana ) {
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return;
    }

    if (( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {

        NCB_COMPLETE( pdncb, NRC_SNUMOUT );
        return;
    }

    plana = pfcb->ppLana[pdncb->ncb_lana_num];

    for (Entry = plana->LanAlertList.Flink ;
         Entry != &plana->LanAlertList ;
         Entry = NextEntry) {
        PDNCB pAnotherNcb;

        NextEntry = Entry->Flink;

        pAnotherNcb = CONTAINING_RECORD( Entry, DNCB, ncb_next);
        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbDisplayNcb( pAnotherNcb );
        }

        if ( (PUCHAR)pAnotherNcb->users_ncb == pdncb->ncb_buffer) {
            //  Found the request to cancel
            PIRP Irp;

            IF_NBDBG (NB_DEBUG_LANSTATUS) {
                NbPrint(( "Found request to cancel\n" ));
            }
            RemoveEntryList( &pAnotherNcb->ncb_next );

            Irp = pAnotherNcb->irp;

            IoAcquireCancelSpinLock(&Irp->CancelIrql);

            //
            //  Remove the cancel request for this IRP. If its cancelled then its
            //  ok to just process it because we will be returning it to the caller.
            //

            Irp->Cancel = FALSE;

            IoSetCancelRoutine(Irp, NULL);

            IoReleaseCancelSpinLock(Irp->CancelIrql);

            NCB_COMPLETE( pAnotherNcb, NRC_CMDCAN );

            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

            NbCompleteRequest( Irp, STATUS_SUCCESS );

            NCB_COMPLETE( pdncb, NRC_GOODRET );

            return;
        }
    }
    NCB_COMPLETE( pdncb, NRC_CANOCCR );

    return;
}

NTSTATUS
NbTdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is called on any error indications passed back from the
    transport. It implements LAN_STATUS_ALERT.

Arguments:

    IN PVOID Context - Supplies the pfcb for the address.

    IN NTSTATUS Status - Supplies the error.

Return Value:

    NTSTATUS - Status of event indication

--*/

{
    PLANA_INFO plana = (PLANA_INFO) Context;
    PDNCB pdncb;

    IF_NBDBG (NB_DEBUG_LANSTATUS) {
        NbPrint( ("NbTdiErrorHandler PLANA: %lx, Status %X\n", plana, Status));
    }

    ASSERT( plana->Signature == LANA_INFO_SIGNATURE);

    while ( (pdncb = DequeueRequest( &plana->LanAlertList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_LANSTATUS) {
            NbPrint( ("NbTdiErrorHandler complete pdncb: %lx\n", pdncb ));
        }

        NCB_COMPLETE( pdncb, NbMakeNbError( Status) );

        pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        NbCheckAndCompleteIrp32(pdncb->irp);

        NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\lib\tnetcall.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tnetcall.c

Abstract:

    This module contains code which exercises the NetBIOS dll and driver.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Application mode

Revision History:

    Dave Beaver (DBeaver) 10 August 1991

        Modify to support multiple LAN numbers

    Jerome Nantel (w-jeromn) 23 August 1991

        Add Event Signaling testing

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_CONSOLE_APP
#include <windows.h>

#include <nb30.h>
#include <stdio.h>

//              1234567890123456
#define SPACES "                "
#define TIMEOUT 60000   // Time out for wait, set at 1 minute
#define Hi  "Come here Dave, I need you"
#define SEND 1
#define RCV  0


NCB myncb[2];
CHAR Buffer[16384+1024];
CHAR Buffer2[16384+1024];
ULONG lanNumber=0;
UCHAR lsn;
HANDLE twoEvent[2];
int count;  // frame count
BOOLEAN verbose=FALSE;
BOOLEAN rxany=FALSE;
BOOLEAN rxanyany=FALSE;
BOOLEAN input=TRUE;
BOOLEAN output=TRUE;
int QuietCount = 50;
UCHAR name_number;

VOID
usage (
    VOID
    )
{
    printf("usage: tsrnetb -c|l [-[a|r]] [-[i|o]] [-n:lan number][-h] <remote computername> <my computername>\n");
    printf("                 -c specifies calling, -l specifies listener\n");
    printf("                 -a specifies rx any, any, -r specifies rx any\n");
    printf("                 -i specifies rx only, -o specifies tx only\n");
    printf("                 -d specifies delay with alerts on each tx/rx\n");
    printf("                 -n specifies the lan number (0 is the default)\n");
    printf("                 -h specifies that addresses are hexadecimal numbers \n");
    printf("                     rather than strings.\n");
    printf("                 -g use group name for the connection\n");
    printf("                 -v verbose\n");
    printf("                 -s silent\n");
    printf("                 -t token ring, lan status alert (names ignored)\n");
    printf("                 -q quiet (print r every 50 receives\n");
    printf("                 final two arguments are the remote and local computer names.\n");
}

VOID
ClearNcb( PNCB pncb ) {
    RtlZeroMemory( pncb , sizeof (NCB) );
    RtlMoveMemory( pncb->ncb_name,     SPACES, sizeof(SPACES)-1 );
    RtlMoveMemory( pncb->ncb_callname, SPACES, sizeof(SPACES)-1 );
}

VOID StartSend()
{

    ClearNcb( &(myncb[0]) );
    if ( output == FALSE ) {
        ResetEvent(twoEvent[SEND]);
        return;
    }
    myncb[0].ncb_command = NCBSEND | ASYNCH;
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_buffer = Buffer;
    myncb[0].ncb_lsn = lsn;
    myncb[0].ncb_event = twoEvent[SEND];
    RtlMoveMemory( Buffer, Hi, sizeof( Hi ));
    sprintf( Buffer, "%s %d\n", Hi, count );
    if ( verbose == TRUE ) {
        printf( "Tx: %s", Buffer );
    }
    count++;
    myncb[0].ncb_length = (WORD)sizeof(Buffer);
    Netbios( &(myncb[0]) );

}

VOID StartRcv()
{
    ClearNcb( &(myncb[1]) );
    if ( input == FALSE ) {
        ResetEvent(twoEvent[RCV]);
        return;
    }
    if ((rxany == FALSE) &&
        (rxanyany == FALSE)) {
        myncb[1].ncb_command = NCBRECV | ASYNCH;
    } else {
        myncb[1].ncb_command = NCBRECVANY | ASYNCH;
    }
    myncb[1].ncb_lana_num = (UCHAR)lanNumber;
    myncb[1].ncb_length = sizeof( Buffer2 );
    myncb[1].ncb_buffer = Buffer2;
    if ( rxany == FALSE ) {
        if ( rxanyany == FALSE ) {
            myncb[1].ncb_lsn = lsn;
        } else {
            myncb[1].ncb_num = 0xff;
        }
    } else{
            myncb[1].ncb_num = name_number;
    }
    myncb[1].ncb_lsn = lsn;
    myncb[1].ncb_event = twoEvent[RCV];
    Netbios( &(myncb[1]) );
}

int
_cdecl
main (argc, argv)
   int argc;
   char *argv[];
{

    int i,j;
    int rcvCount=0;
    CHAR localName[17];
    CHAR remoteName[17];
    CHAR localTemp[32];
    CHAR remoteTemp[32];
    BOOLEAN gotFirst=FALSE;
    BOOLEAN asHex=FALSE;
    BOOLEAN listen=FALSE;
    BOOLEAN quiet=FALSE;
    BOOLEAN delay=FALSE;
    BOOLEAN group=FALSE;
    BOOLEAN silent=FALSE;
    BOOLEAN lanalert=FALSE;
    DWORD tevent;
    BOOLEAN ttwo=FALSE;

    if ( argc < 4 || argc > 9) {
        usage ();
        return 1;
    }

    //
    // dbeaver: added switch to allow 32 byte hex string as name to facilitate
    // testing under unusual circumstances
    //

    for (j=1;j<16;j++ ) {
        localTemp[j] = ' ';
        remoteTemp[j] = ' ';
    }

    //
    // parse the switches
    //

    for (i=1;i<argc ;i++ ) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
            case 'n':
                if (!NT_SUCCESS(RtlCharToInteger (&argv[i][3], 10, &lanNumber))) {
                    usage ();
                    return 1;
                }
                break;

            case 'h':
                asHex = TRUE;
                break;
            case 'c':
                listen = FALSE;
                break;
            case 'a':
                rxany = TRUE;
                break;
            case 'r':
                rxanyany = TRUE;
                break;
            case 'i':
                output = FALSE;
                break;
            case 'o':
                input = FALSE;
                break;
            case 'd':
                delay = FALSE;
                break;
            case 'l':
                listen = TRUE;
                break;
            case 'q':
                quiet = TRUE;
                silent = TRUE;
                break;
            case 'g':
                group = TRUE;
                break;
            case 'v':
                verbose = TRUE;
                break;
            case 's':
                silent = TRUE;
                break;
            case 't':
                lanalert = TRUE;
                break;
            default:
                usage ();
                return 1;
                break;

            }

        } else {

            //
            // not a switch must be a name
            //

            if (gotFirst != TRUE) {
                RtlMoveMemory (remoteTemp, argv[i], lstrlenA( argv[i] ));
                gotFirst = TRUE;
            } else {
                RtlMoveMemory (localTemp, argv[i], lstrlenA( argv[i] ));
            }

        }
    }
    if ((rxany == TRUE) &&
        (rxanyany == TRUE)) {
        usage();
        return 1;
    }
    if ((input == FALSE) &&
        (output == FALSE)) {
        usage();
        return 1;
    }

    if (asHex) {
        RtlZeroMemory (localName, 16);
        RtlZeroMemory (remoteName, 16);

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&localTemp[j*2], 16, (PULONG)&localName[j]);
        }

        for (j=0;j<16 ;j+=4) {
            RtlCharToInteger (&remoteTemp[j*2], 16, (PULONG)&remoteName[j]);
        }

    } else {
          for (j=1;j<16;j++ ) {
              localName[j] = ' ';
              remoteName[j] = ' ';
          }

        RtlMoveMemory( localName, localTemp, 16);
        RtlMoveMemory( remoteName, remoteTemp, 16);
    }

    for ( i=0; i<2; i++ ) {
        if (( twoEvent[i] = CreateEvent( NULL, TRUE, FALSE, NULL )) == NULL ) {
            /* Could not get event handle.  Abort */
            printf("Could not test event signaling.\n");
            return 1;
        }
    }

    printf( "Starting NetBios\n" );

    //   Reset
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBRESET;
    myncb[0].ncb_lsn = 0;           // Request resources
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_callname[0] = 0;   // 16 sessions
    myncb[0].ncb_callname[1] = 0;   // 16 commands
    myncb[0].ncb_callname[2] = 0;   // 8 names
    myncb[0].ncb_callname[3] = 0;   // Don't want the reserved address
    Netbios( &(myncb[0]) );

    if ( lanalert == TRUE ) {
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBLANSTALERT;
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        Netbios( &(myncb[0]) );
        if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
            printf( " LanStatusAlert failed %x", myncb[1].ncb_retcode);
        }
        return 0;
    }

    //   Add name
    ClearNcb( &(myncb[0]) );
    if ( group == FALSE) {
        myncb[0].ncb_command = NCBADDNAME;
    } else {
        myncb[0].ncb_command = NCBADDGRNAME;
    }
    RtlMoveMemory( myncb[0].ncb_name, localName, 16);
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &(myncb[0]) );
    name_number = myncb[0].ncb_num;

    if ( listen == FALSE ) {
        //   Call
        printf( "\nStarting Call " );
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBCALL | ASYNCH;
        RtlMoveMemory( myncb[0].ncb_name, localName, 16);
        RtlMoveMemory( myncb[0].ncb_callname,remoteName, 16);
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        myncb[0].ncb_sto = myncb[0].ncb_rto = 120; // 120*500 milliseconds timeout
        myncb[0].ncb_num = name_number;
        myncb[0].ncb_event = twoEvent[0];
        while ( TRUE) {
            printf("\nStart NCB CALL ");
            Netbios( &(myncb[0]) );
            printf( " Call returned " );
            if ( myncb[0].ncb_cmd_cplt == NRC_PENDING ) {
                if ( WaitForSingleObject( twoEvent[0], TIMEOUT ) ) {
                    // Wait timed out, no return
                    printf("ERROR: Wait timed out, event not signaled.\n");
                }
            }
            printf( " Call completed\n" );
            lsn = myncb[0].ncb_lsn;

            if ( myncb[0].ncb_retcode == NRC_GOODRET ) {
                // Success
                break;
            }
            printf("Call completed with error %lx, retry", myncb[0].ncb_retcode );
            Sleep(5);
        }
    } else {
        printf( "\nStarting Listen " );

        //   Listen
        ClearNcb( &(myncb[0]) );
        myncb[0].ncb_command = NCBLISTEN | ASYNCH;
        RtlMoveMemory( myncb[0].ncb_name, localName, 16);
        RtlMoveMemory( myncb[0].ncb_callname, remoteName, 16);
        myncb[0].ncb_lana_num = (UCHAR)lanNumber;
        myncb[0].ncb_sto = myncb[0].ncb_rto = 120; // 120*500 milliseconds timeout
        myncb[0].ncb_num = name_number;
        Netbios( &(myncb[0]) );
        printf( "Listen returned " );
        while ( myncb[0].ncb_cmd_cplt == NRC_PENDING ) {
            printf( "." );
            Sleep(500);

        }
        printf( " Listen completed\n" );

        if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
            printf("ERROR: Could not establish session.\n");
            return 1;
        }

        lsn = myncb[0].ncb_lsn;

    }

    count = 0;
    StartSend();
    StartRcv();

    while ( TRUE ) {

        tevent = WaitForMultipleObjects(2, twoEvent, FALSE, TIMEOUT);

        switch ( tevent ) {
        case SEND :
            // Send completed, start a new one.
            if ( silent == FALSE ) {
                printf("S");
            }
            if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
                printf( "Send failed %x", myncb[0].ncb_retcode);
                goto Cleanup;
            }
            if ( delay == TRUE ) {
                //  Wait alertable - useful for debugging APC problems.
                NtWaitForSingleObject(
                    twoEvent[SEND],
                    TRUE,
                    NULL );
            }

            StartSend();
            break;

        case RCV :
            if ( silent == FALSE ) {
                printf("R");
            }
            if ( (quiet == TRUE) && (QuietCount-- == 0) ) {
                printf("R");
                QuietCount = 50;
            }
            if ( myncb[1].ncb_retcode != NRC_GOODRET ) {
                printf( " Receive failed %x", myncb[1].ncb_retcode);
                goto Cleanup;
            } else {
                if ( verbose == TRUE ) {
                    printf( "Rx: %s", Buffer2 );
                }
            }
            // Receive completed, start a new one.

            if ( delay == TRUE ) {
                //  Wait alertable
                NtWaitForSingleObject(
                    twoEvent[RCV],
                    TRUE,
                    NULL );
            }

            StartRcv();
            rcvCount++;
            break;

        default:
            printf("WARNING: Wait timed out, no event signaled.\n");
            break;
        }

    }
Cleanup:
    //  Hangup
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBHANGUP;
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    myncb[0].ncb_lsn = lsn;
    Netbios( &(myncb[0]) );
    if ( myncb[0].ncb_retcode != NRC_GOODRET ) {
        printf( " Hangup failed %x", myncb[1].ncb_retcode);
    }

    //   Reset
    ClearNcb( &(myncb[0]) );
    myncb[0].ncb_command = NCBRESET;
    myncb[0].ncb_lsn = 1;           // Free resources
    myncb[0].ncb_lana_num = (UCHAR)lanNumber;
    Netbios( &(myncb[0]) );
    printf( "Ending NetBios\n" );

    // Close handles
    CloseHandle( twoEvent[0] );
    CloseHandle( twoEvent[1] );

    return 0;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\file.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    file control block object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include "ntos.h"
//#include <zwapi.h>


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NewFcb)
#pragma alloc_text(PAGE, CleanupFcb)
#pragma alloc_text(PAGE, OpenLana)
#pragma alloc_text(PAGE, NbBindHandler)
#pragma alloc_text(PAGE, NbPowerHandler)
#pragma alloc_text(PAGE, NbTdiBindHandler)
#pragma alloc_text(PAGE, NbTdiUnbindHandler)
#endif


#if AUTO_RESET

VOID
NotifyUserModeNetbios(
    IN  PFCB_ENTRY      pfe
);
#endif


VOID
DumpDeviceList(
    IN      PFCB        pfcb
);


NTSTATUS
NewFcb(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called when the dll opens \Device\Netbios. It
    creates all the lana structures and adds the name for the "burnt
    in" prom address on each adapter. Note the similarity to the routine
    NbAstat when looking at this function.

Arguments:

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    //
    //  Allocate the user context and store it in the DeviceObject.
    //

    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFCB NewFcb = NULL;
    UCHAR ucIndex;
    NTSTATUS Status;
    PFCB_ENTRY pfe = NULL;
    BOOLEAN bCleanupResource = FALSE;


    PAGED_CODE();


    do
    {
        //
        // allocate FCB
        //
    
        NewFcb = ExAllocatePoolWithTag (NonPagedPool, sizeof(FCB), 'fSBN');
        FileObject->FsContext2 = NewFcb;

        if ( NewFcb == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate FCB\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory( NewFcb, sizeof( FCB ) );
        
        NewFcb->Signature = FCB_SIGNATURE;

        NewFcb->TimerRunning = FALSE;

        NewFcb-> RegistrySpace = NULL;


        //
        // Allocate for the LanaInfo array 
        //
    
        NewFcb->ppLana = ExAllocatePoolWithTag (
                            NonPagedPool,
                            sizeof(PLANA_INFO) * (MAX_LANA + 1),
                            'fSBN'
                            );

        if ( NewFcb->ppLana == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate Lana info list\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // Allocate for driver name list
        //
        
        NewFcb-> pDriverName = ExAllocatePoolWithTag (
                                    NonPagedPool,
                                    sizeof(UNICODE_STRING) * (MAX_LANA + 1),
                                    'fSBN'
                                    );

        if ( NewFcb-> pDriverName == NULL ) 
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate device name list\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // Initialize Lana info list, driver name list
        //
        
        for ( ucIndex = 0; ucIndex <= MAX_LANA; ucIndex++ ) 
        {
            NewFcb->ppLana[ ucIndex ] = NULL;
            RtlInitUnicodeString( &NewFcb-> pDriverName[ ucIndex ], NULL );
        }


        //
        // allocate and initialize FCB list entry
        //
    
        pfe = ExAllocatePoolWithTag( NonPagedPool, sizeof( FCB_ENTRY ), 'fSBN' );
    
        if ( pfe == NULL )
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate FCB list entry\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        InitializeListHead( &pfe-> leList );
        
#if AUTO_RESET

        InitializeListHead( &pfe-> leResetList );
        InitializeListHead( &pfe-> leResetIrp );
#endif

        pfe-> pfcb = NewFcb;
        pfe-> peProcess = PsGetCurrentProcess();


        //
        // Initialize locks
        //
    
        KeInitializeSpinLock( &NewFcb->SpinLock );
        ExInitializeResourceLite( &NewFcb->Resource );
        ExInitializeResourceLite( &NewFcb->AddResource );
        bCleanupResource = TRUE;
        

        //
        // allocate work item
        //
        
        NewFcb->WorkEntry = IoAllocateWorkItem( (PDEVICE_OBJECT)DeviceContext );

        if ( NewFcb->WorkEntry == NULL )
        {
            NbPrint( ( "Netbios : NewFcb : Failed to allocate work ite,\n" ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }


        //
        // retrieve global info
        //
    
        LOCK_GLOBAL();

        NewFcb-> MaxLana = g_ulMaxLana;

        RtlCopyMemory( &NewFcb-> LanaEnum, &g_leLanaEnum, sizeof( LANA_ENUM ) );


        //
        // copy all active device names
        //

        Status = STATUS_SUCCESS;
        
        for ( ucIndex = 0; ucIndex <= g_ulMaxLana; ucIndex++ )
        {
            if ( ( g_pusActiveDeviceList[ ucIndex ].MaximumLength != 0 ) &&
                 ( g_pusActiveDeviceList[ ucIndex ].Buffer != NULL ) ) 
            {
                Status = AllocateAndCopyUnicodeString( 
                            &NewFcb-> pDriverName[ ucIndex ],
                            &g_pusActiveDeviceList[ ucIndex ]
                            );

                if ( !NT_SUCCESS( Status ) )
                {
                    NbPrint( ( 
                        "Netbios : failed to allocate device name for lana %d\n",
                        ucIndex
                        ) );

                    break;
                }
            }
        }


        if ( !NT_SUCCESS( Status ) )
        {
            UNLOCK_GLOBAL();
            break;
        }

        
        //
        // Add FCB to global list of FCBs
        //

        InsertHeadList( &g_leFCBList, &pfe-> leList );
    
        UNLOCK_GLOBAL();

    
        IF_NBDBG (NB_DEBUG_FILE)
        {
            NbPrint(("Enumeration of transports completed:\n"));
            NbFormattedDump( (PUCHAR)&NewFcb->LanaEnum, sizeof(LANA_ENUM));
        }

        return STATUS_SUCCESS;

    } while ( FALSE );


    //
    // error condition.  cleanup all allocations.
    //

    if ( NewFcb != NULL )
    {
        //
        // free the list of driver names
        //
        
        if ( NewFcb-> pDriverName != NULL )
        {
            for ( ucIndex = 0; ucIndex <= MAX_LANA; ucIndex++ )
            {
                if ( NewFcb-> pDriverName[ ucIndex ].Buffer != NULL )
                {
                    ExFreePool( NewFcb-> pDriverName[ ucIndex ].Buffer );
                }
            }

            ExFreePool( NewFcb-> pDriverName );
        }


        //
        // free the lana list
        //
        
        if ( NewFcb-> ppLana != NULL )
        {
            ExFreePool( NewFcb-> ppLana );
        }


        //
        // Free the work item
        //

        if ( NewFcb->WorkEntry != NULL )
        {
            IoFreeWorkItem( NewFcb->WorkEntry );
        }
        

        //
        // Delete resources
        //
        
        if ( bCleanupResource )
        {
            ExDeleteResourceLite( &NewFcb-> Resource );
            
            ExDeleteResourceLite( &NewFcb-> AddResource );
        }

        //
        // free the FCB
        //
        
        ExFreePool( NewFcb );


        //
        // free the global FCB entry
        //

    }

    if ( pfe != NULL )
    {
        ExFreePool( pfe ) ;
    }
    
   
    FileObject->FsContext2 = NULL;
    
    return Status;
    
} /* NewFcb */



VOID
OpenLana(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called when an application resets an adapter allocating
    resources. It creates all the lana structure and adds the name for the
    "burnt in" prom address as well as finding the broadcast address.

    Note the similarity to the routine NbAstat when looking at this function.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    KEVENT Event1;
    PLANA_INFO plana;
    HANDLE TdiHandle;
    PFILE_OBJECT TdiObject;
    PDEVICE_OBJECT DeviceObject;
    PMDL SaveMdl;
    int temp;
    PRESET_PARAMETERS InParameters;
    PRESET_PARAMETERS OutParameters;
    UCHAR Sessions;
    UCHAR Commands;
    UCHAR Names;
    BOOLEAN Exclusive;

    UCHAR   ucInd = 0;
    
    UNICODE_STRING usDeviceName;

    
    //
    //  Ncb and associated buffer to be used in adapter status to get the
    //  prom address.
    //

    DNCB ncb;
    struct _AdapterStatus {
        ADAPTER_STATUS AdapterInformation;
        NAME_BUFFER Nb;
    } AdapterStatus;
    PMDL AdapterStatusMdl = NULL;

    struct _BroadcastName {
        TRANSPORT_ADDRESS Address;
        UCHAR Padding[NCBNAMSZ];
    } BroadcastName;
    PMDL BroadcastMdl = NULL;

    PAGED_CODE();


    RtlInitUnicodeString( &usDeviceName, NULL);

    
    LOCK_RESOURCE( pfcb );
    
    //
    // check lana specified is valid
    //
    
    if ( ( pdncb->ncb_lana_num > pfcb->MaxLana) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].MaximumLength == 0 ) ||
         ( pfcb-> pDriverName[ pdncb-> ncb_lana_num ].Buffer == NULL ) )
    {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return;
    }

    
    //
    // since no locks are held when invoking NbOpenAddress, no fields of 
    // pfcb should be passed to it.  This is because pfcb might be 
    // modified by a bind or unbind notification 
    //
    
    Status = AllocateAndCopyUnicodeString( 
                &usDeviceName, &pfcb-> pDriverName[ pdncb-> ncb_lana_num ]
                );

    if ( !NT_SUCCESS( Status ) ) 
    {
        NCB_COMPLETE( pdncb, NRC_NORES );
        UNLOCK_RESOURCE( pfcb );
        goto exit;
    }
                
    UNLOCK_RESOURCE( pfcb );
    


    //
    //  Calculate the lana limits from the users NCB.
    //

    InParameters = (PRESET_PARAMETERS)&pdncb->ncb_callname;
    OutParameters = (PRESET_PARAMETERS)&pdncb->ncb_name;

    if ( InParameters->sessions == 0 ) {
        Sessions = 16;
    } else {
        if ( InParameters->sessions > MAXIMUM_CONNECTION ) {
            Sessions = MAXIMUM_CONNECTION;
        } else {
            Sessions = InParameters->sessions;
        }
    }

    if ( InParameters->commands == 0 ) {
        Commands = 16;
    } else {
        Commands = InParameters->commands;
    }

    if ( InParameters->names == 0 ) {
        Names = 8;
    } else {
        if ( InParameters->names > MAXIMUM_ADDRESS-2 ) {
            Names = MAXIMUM_ADDRESS-2;
        } else {
            Names = InParameters->names;
        }
    }

    Exclusive = (BOOLEAN)(InParameters->name0_reserved != 0);

    //  Copy the parameters back into the NCB

    ASSERT( sizeof(RESET_PARAMETERS) == 16);
    RtlZeroMemory( OutParameters, sizeof( RESET_PARAMETERS ));

    OutParameters->sessions = Sessions;
    OutParameters->commands = Commands;
    OutParameters->names = Names;
    OutParameters->name0_reserved = (UCHAR)Exclusive;

    //  Set all the configuration limits to their maximum.

    OutParameters->load_sessions = 255;
    OutParameters->load_commands = 255;
    OutParameters->load_names = MAXIMUM_ADDRESS;
    OutParameters->load_stations = 255;
    OutParameters->load_remote_names = 255;

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Lana:%x Sessions:%x Names:%x Commands:%x Reserved:%x\n",
            pdncb->ncb_lana_num,
            Sessions,
            Names,
            Commands,
            Exclusive));
    }

    //
    //  Build the internal datastructures.
    //

    AdapterStatusMdl = IoAllocateMdl( &AdapterStatus,
        sizeof( AdapterStatus ),
        FALSE,  // Secondary Buffer
        FALSE,  // Charge Quota
        NULL);

    if ( AdapterStatusMdl == NULL ) {
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return;
    }

    BroadcastMdl = IoAllocateMdl( &BroadcastName,
        sizeof( BroadcastName ),
        FALSE,  // Secondary Buffer
        FALSE,  // Charge Quota
        NULL);

    if ( BroadcastMdl == NULL ) {
        IoFreeMdl( AdapterStatusMdl );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return;
    }

    MmBuildMdlForNonPagedPool (AdapterStatusMdl);

    MmBuildMdlForNonPagedPool (BroadcastMdl);

    KeInitializeEvent (
            &Event1,
            SynchronizationEvent,
            FALSE);

    //
    //  For each potential network, open the device driver and
    //  obtain the reserved name and the broadcast address.
    //


    //
    //  Open a handle for doing control functions
    //

    Status = NbOpenAddress ( 
                &TdiHandle, (PVOID*)&TdiObject, 
                &usDeviceName, pdncb->ncb_lana_num, NULL 
                );

    if (!NT_SUCCESS(Status)) {
        //  Adapter not installed
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        goto exit;
    }


    LOCK_RESOURCE( pfcb );

    //
    // verify that device still exists.  Here you cannot check the 
    // Lana info structure for the lana (correponding to the device),
    // since it is expected to be NULL.  Instead check that the device
    // name is valid.
    //

    if ( pfcb-> pDriverName[ pdncb->ncb_lana_num ].Buffer == NULL )
    {
        //
        // device presumed removed on account of unbind.
        //
        
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        UNLOCK_RESOURCE( pfcb );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }
    
    
    if ( pfcb->ppLana[pdncb->ncb_lana_num] != NULL ) {
        //  Attempting to open the lana twice in 2 threads.

        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_TOOMANY );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }

    
    plana = pfcb->ppLana[pdncb->ncb_lana_num] =
        ExAllocatePoolWithTag (NonPagedPool,
        sizeof(LANA_INFO), 'lSBN');

    if ( plana == (PLANA_INFO) NULL ) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        NbAddressClose( TdiHandle, TdiObject );
        goto exit;
    }

    plana->Signature = LANA_INFO_SIGNATURE;
    plana->Status = NB_INITIALIZING;
    plana->pFcb = pfcb;
    plana->ControlChannel = TdiHandle;

    for ( temp = 0; temp <= MAXIMUM_CONNECTION; temp++ ) {
        plana->ConnectionBlocks[temp] = NULL;
    }

    for ( temp = 0; temp <= MAXIMUM_ADDRESS; temp++ ) {
        plana->AddressBlocks[temp] = NULL;
    }

    InitializeListHead( &plana->LanAlertList);

    //  Record the user specified limits in the Lana datastructure.

    plana->NextConnection = 1;
    plana->ConnectionCount = 0;
    plana->MaximumConnection = Sessions;
    plana->NextAddress = 2;
    plana->AddressCount = 0;
    plana->MaximumAddresses = Names;

    DeviceObject = IoGetRelatedDeviceObject( TdiObject );
    plana->ControlFileObject = TdiObject;
    plana->ControlDeviceObject = DeviceObject;

    SaveMdl = Irp->MdlAddress;  // TdiBuildQuery modifies MdlAddress

    if ( Exclusive == TRUE ) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint(("Query adapter status\n" ));
        }
        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_ADAPTER_STATUS,
                AdapterStatusMdl);

        Status = IoCallDriver (DeviceObject, Irp);
        if ( Status == STATUS_PENDING ) {
            do {
                Status = KeWaitForSingleObject(
                            &Event1, Executive, KernelMode, TRUE, NULL
                            );
            } while (Status == STATUS_ALERTED);
            
            if (!NT_SUCCESS(Status)) {
                NbAddressClose( TdiHandle, TdiObject );
                ExFreePool( plana );
                pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
                UNLOCK_RESOURCE( pfcb );
                NCB_COMPLETE( pdncb, NRC_SYSTEM );
                goto exit;
            }
            Status = Irp->IoStatus.Status;
        }

        //
        //  The transport may have extra names added so the buffer may be too short.
        //  Ignore the too short problem since we will have all the data we require.
        //

        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Now discover the broadcast address.
    //

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Query broadcast address\n" ));
    }

    if (NT_SUCCESS(Status)) {
        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_BROADCAST_ADDRESS,
                BroadcastMdl);

        Status = IoCallDriver (DeviceObject, Irp);
        if ( Status == STATUS_PENDING ) {
            do {
                Status = KeWaitForSingleObject(
                            &Event1, Executive, KernelMode, TRUE, NULL
                            );
            } while ( Status == STATUS_ALERTED );
            
            if (!NT_SUCCESS(Status)) {
                NbAddressClose( TdiHandle, TdiObject );
                ExFreePool( plana );
                pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
                UNLOCK_RESOURCE( pfcb );
                NCB_COMPLETE( pdncb, NRC_SYSTEM );
                goto exit;
            }
            Status = Irp->IoStatus.Status;
        }
    }

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("Query broadcast address returned:\n" ));
        NbFormattedDump(
            (PUCHAR)&BroadcastName,
            sizeof(BroadcastName) );
    }

    //  Cleanup the callers Irp
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->MdlAddress = SaveMdl;


    if ( !NT_SUCCESS( Status )) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" Astat or query broadcast returned error: %lx\n", Status ));
        }

        NbAddressClose( TdiHandle, TdiObject );
        ExFreePool( plana );
        pfcb->ppLana[pdncb->ncb_lana_num] = NULL;
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        goto exit;
    }

    if ( Exclusive == TRUE) {
        int i;
        //
        //  Grab exclusive access to the reserved address
        //
        //
        //  We now have an adapter status structure containing the
        //  prom address. Move the address to where NewAb looks and
        //  pretend an addname has just been requested.
        //

        ncb.ncb_command = NCBADDRESERVED;
        ncb.ncb_lana_num = pdncb->ncb_lana_num;
        ncb.ncb_retcode = NRC_PENDING;

        for ( i=0; i<10 ; i++ ) {
            ncb.ncb_name[i] = '\0';
        }
        RtlMoveMemory( ncb.ncb_name+10,
            AdapterStatus.AdapterInformation.adapter_address,
            6);

        //
        // It appears that NewAb is called while holding pfcb-> Resource.
        //
        NewAb( IrpSp, &ncb );

        if ( ncb.ncb_retcode != NRC_GOODRET ) {
            IF_NBDBG (NB_DEBUG_FILE) {
                NbPrint((" Add of reserved name failed Lana:%x\n", pdncb->ncb_lana_num));
            }

            plana->Status = NB_ABANDONED;
            UNLOCK_RESOURCE( pfcb );
            CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            goto exit;
        }
    }


    //
    //  Add the broadcast address. Use a special command code
    //  to ensure address 255 is used.
    //

    ncb.ncb_length = BroadcastName.Address.Address[0].AddressLength;
    ncb.ncb_command = NCBADDBROADCAST;
    ncb.ncb_lana_num = pdncb->ncb_lana_num;
    ncb.ncb_retcode = NRC_PENDING;
    ncb.ncb_cmd_cplt = NRC_PENDING;
    RtlMoveMemory( ncb.ncb_name,
        ((PTDI_ADDRESS_NETBIOS)&BroadcastName.Address.Address[0].Address)->NetbiosName,
        NCBNAMSZ );


    //
    // It appears that NewAb is called while holding pfcb-> Resource.
    //
    NewAb( IrpSp, &ncb );

    if ( ncb.ncb_retcode != NRC_GOODRET ) {
        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" Add of broadcast name failed Lana:%x\n", pdncb->ncb_lana_num));
        }

        plana->Status = NB_ABANDONED;
        UNLOCK_RESOURCE( pfcb );
        CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        goto exit;
    }

    plana->Status = NB_INITIALIZED;
    NCB_COMPLETE( pdncb, NRC_GOODRET );
    UNLOCK_RESOURCE( pfcb );

exit:
    if ( AdapterStatusMdl != NULL ) 
    { 
        IoFreeMdl( AdapterStatusMdl );
    }
    
    if ( BroadcastMdl != NULL ) 
    {
        IoFreeMdl( BroadcastMdl );
    }

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }
    return;

}

VOID
CleanupFcb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB pfcb
    )
/*++

Routine Description:

    This deletes any Connection Blocks pointed to by the File Control Block
    and then deletes the File Control Block. This routine is only called
    when a close IRP has been received.

Arguments:

    IrpSp - Pointer to current IRP stack frame.

    pfcb - Pointer to the Fcb to be deallocated.

Return Value:

    nothing.

--*/

{
    NTSTATUS    nsStatus;
    ULONG lana_index;
    PLIST_ENTRY ple = NULL;
    PFCB_ENTRY pfe = NULL;


    
    PAGED_CODE();

    //
    //  To receive a Close Irp, the IO system has determined that there
    //  are no handles open in the driver. To avoid some race conditions
    //  in this area, we always have an Irp when queueing work to the Fsp.
    //  this prevents structures disappearing on the Fsp and also makes
    //  it easier to cleanup in this routine.
    //

    //
    //  for each network adapter that is allocated, close all addresses
    //  and connections, deleting any memory that is allocated.
    //

    IF_NBDBG (NB_DEBUG_FILE) {
        NbPrint(("CleanupFcb:%lx\n", pfcb ));
    }


    //
    // remove FCB pointer from the global list of FCB pointers
    //
    
    LOCK_GLOBAL();

    for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
    {
        pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

        if ( pfe-> pfcb == pfcb )
        {
            RemoveEntryList( ple );
            ExFreePool( pfe );

            IF_NBDBG (NB_DEBUG_CREATE_FILE)
            {
                NbPrint( ("Netbios FCB entry removed from global list\n" ) );
            }

            break;
        }
    }

    UNLOCK_GLOBAL();


    //
    // FCB pointed to by pfcb is now free from access by bind/unbind handlers.
    //
    
    LOCK_RESOURCE( pfcb );
    if ( pfcb->TimerRunning == TRUE ) {

        KEVENT TimerCancelled;

        KeInitializeEvent (
                &TimerCancelled,
                SynchronizationEvent,
                FALSE);

        pfcb->TimerCancelled = &TimerCancelled;
        pfcb->TimerRunning = FALSE;
        UNLOCK_RESOURCE( pfcb );

        if ( KeCancelTimer (&pfcb->Timer) == FALSE ) {

            //
            //  The timeout was in the Dpc queue. Wait for it to be
            //  processed before continuing.
            //

            do {
                nsStatus = KeWaitForSingleObject(
                            &TimerCancelled, Executive, KernelMode, 
                            TRUE, NULL
                            );
            } while (nsStatus == STATUS_ALERTED);
        }

    } else {
        UNLOCK_RESOURCE( pfcb );
    }

    for ( lana_index = 0; lana_index <= pfcb->MaxLana; lana_index++ ) {
        CleanupLana( pfcb, lana_index, TRUE);

        if ( pfcb-> pDriverName[ lana_index ].Buffer != NULL )
        {
            ExFreePool( pfcb-> pDriverName[ lana_index ].Buffer );
        }
    }

    ExDeleteResourceLite( &pfcb->Resource );
    ExDeleteResourceLite( &pfcb->AddResource );

    IrpSp->FileObject->FsContext2 = NULL;

    ExFreePool( pfcb-> pDriverName );
    ExFreePool( pfcb->ppLana );

    //
    // Free the work item
    //

    IoFreeWorkItem( pfcb->WorkEntry );
        

    ExFreePool( pfcb );
}


VOID
CleanupLana(
    IN PFCB pfcb,
    IN ULONG lana_index,
    IN BOOLEAN delete
    )
/*++

Routine Description:

    This routine completes all the requests on a particular adapter. It
    removes all connections and addresses.
Arguments:

    pfcb - Pointer to the Fcb to be deallocated.

    lana_index - supplies the adapter to be cleaned.

    delete - if TRUE the memory for the lana structure should be freed.

Return Value:

    nothing.

--*/

{
    PLANA_INFO plana;
    int index;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PDNCB pdncb;

    LOCK( pfcb, OldIrql );

    plana = pfcb->ppLana[lana_index];

    if ( plana != NULL ) {

        IF_NBDBG (NB_DEBUG_FILE) {
            NbPrint((" CleanupLana pfcb: %lx lana %lx\n", pfcb, lana_index ));
        }

        if (( plana->Status == NB_INITIALIZING ) ||
            ( plana->Status == NB_DELETING )) {
            //  Possibly trying to reset it twice?
            UNLOCK( pfcb, OldIrql );
            return;
        }
        plana->Status = NB_DELETING;

        //  Cleanup the control channel and abandon any tdi-action requests.


        if ( plana->ControlChannel != NULL ) {

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            IF_NBDBG( NB_DEBUG_CALL )
            {
                NbPrint( (
                "NbAddressClose : Close file invoked for %d\n",
                lana_index
                ) );

                NbPrint( ( "Control channel\n" ) );
            }
            
            NbAddressClose( plana->ControlChannel, plana->ControlFileObject );

            LOCK_SPINLOCK( pfcb, OldIrql );

            plana->ControlChannel = NULL;

        }

        while ( (pdncb = DequeueRequest( &plana->LanAlertList)) != NULL ) {

            //
            //  Any error will do since the user is closing \Device\Netbios
            //  and is therefore exiting.
            //

            NCB_COMPLETE( pdncb, NRC_SCLOSED );

            pdncb->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest( pdncb->irp, STATUS_SUCCESS );
        }


        for ( index = 0; index <= MAXIMUM_CONNECTION; index++) {
            if ( plana->ConnectionBlocks[index] != NULL ) {
                IF_NBDBG (NB_DEBUG_FILE) {
                    NbPrint(("Call CleanupCb Lana:%x Lsn: %x\n", lana_index, index ));
                }
                plana->ConnectionBlocks[index]->DisconnectReported = TRUE;
                UNLOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
                CleanupCb( &plana->ConnectionBlocks[index], NULL );
                LOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
            }
        }

        for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
            if ( plana->AddressBlocks[index] != NULL ) {
                IF_NBDBG (NB_DEBUG_FILE) {
                    NbPrint((" CleanupAb Lana:%x index: %x\n", lana_index, index ));
                }
                UNLOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
                CleanupAb( &plana->AddressBlocks[index], TRUE );
                LOCK_SPINLOCK( pfcb, OldIrql );    //  Allow NtClose in Cleanup routines.
            }
        }

        if ( delete == TRUE ) {
            pfcb->ppLana[lana_index] = NULL;
            ExFreePool( plana );
        }

    }

    UNLOCK( pfcb, OldIrql );
}



//----------------------------------------------------------------------------
// NbTdiBindHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------
VOID
NbBindHandler(
    IN      TDI_PNP_OPCODE      PnPOpcode,
    IN      PUNICODE_STRING     DeviceName,
    IN      PWSTR               MultiSZBindList
    )
{

    PWSTR   pwCur = NULL;

    if ( PnPOpcode == TDI_PNP_OP_ADD )
    {
        NbTdiBindHandler( DeviceName, MultiSZBindList );
    }

    else if ( PnPOpcode == TDI_PNP_OP_DEL )
    {
        NbTdiUnbindHandler( DeviceName );
    }

}

//----------------------------------------------------------------------------
// NbTdiPowerHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------

NTSTATUS
NbPowerHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PNET_PNP_EVENT      pnpeEvent,
    IN      PTDI_PNP_CONTEXT    ptpcContext1,
    IN      PTDI_PNP_CONTEXT    ptpcContext2
)
{
    return STATUS_SUCCESS;
}


//----------------------------------------------------------------------------
// NbTdiBindHandler
//
// Call back function that process a TDI bind notification that indicates
// a new device has been created.
//----------------------------------------------------------------------------

VOID
NbTdiBindHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PWSTR               pwszMultiSZBindList
    )
{

    NTSTATUS nsStatus;
    
    UCHAR       ucInd = 0, ucIndex = 0, ucNewLana = 0, ucLana = 0;
    BOOLEAN     bRes = FALSE;
    ULONG       ulMaxLana = 0;
    PWSTR       pwszBind = NULL;

    UNICODE_STRING  usCurDevice;
    
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    
    PLANA_MAP   pLanaMap = NULL; 

    PLIST_ENTRY ple = NULL;
    
    PFCB_ENTRY pfe = NULL;

    PFCB pfcb = NULL;
    
#if AUTO_RESET
    PRESET_LANA_ENTRY prle;
#endif
    

    PAGED_CODE();

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n++++ Netbios : TdiBindHandler : entered for device : %ls ++++\n",
            pusDeviceName-> Buffer 
            ) );
    }


    do
    {
        //
        // read the registry for the Lana Map
        //

        nsStatus = GetLanaMap( &g_usRegistryPath, &pkvfi );
        
        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : GetLanaMap failed with status %lx\n", nsStatus 
                ) );
            break;
        }

        pLanaMap = (PLANA_MAP) ( (PUCHAR) pkvfi + pkvfi-> DataOffset );
        

        //
        // get Max Lana
        //

        nsStatus = GetMaxLana( &g_usRegistryPath, &ulMaxLana );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : GetMaxLana failed with status %lx\n", nsStatus 
                ) );
            break;
        }

        
        //
        // figure out Lana for this device.  Verify that it is enumerated.
        //

        ucIndex = 0;
        
        pwszBind = pwszMultiSZBindList;

        while ( *pwszBind != 0 )
        {
            RtlInitUnicodeString( &usCurDevice, pwszBind );

            if ( !RtlCompareUnicodeString(
                    &usCurDevice,
                    pusDeviceName,
                    FALSE
                    ) )
            {
                //
                // new device found
                //

                bRes = TRUE;
                break;
            }

            ucIndex++;
            
            pwszBind += wcslen( pwszBind ) + 1;
        }


        //
        // if device was not found error out
        //

        if ( !bRes )
        {
            NbPrint( (
                "Netbios : device %ls not found in bind string\n",
                pusDeviceName-> Buffer
                ) );
            break;
        }


        //
        // verify lana number is valid
        //
        
        if ( pLanaMap[ ucIndex ].Lana > ulMaxLana )
        {
            NbPrint( (
                "Netbios : Device lana %d, Max Lana %d\n",
                pLanaMap[ ucIndex ].Lana, ulMaxLana
                ) );
            break;
        }


        //
        // open device to ensure that it works.
        //

        bRes = NbCheckLana ( pusDeviceName );

        if ( !bRes )
        {
            NbPrint( ( 
                "Netbios : NbCheckLana failed to open device %ls\n", 
                pusDeviceName-> Buffer 
                ) );
            break;
        }

      
        //
        // create a copy of this device name.
        //
        nsStatus = AllocateAndCopyUnicodeString( 
                        &usCurDevice,
                        pusDeviceName
                        );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( (
                "Netbios : Failed to allocate for global device name %x\n",
                nsStatus
                ) );
            break;
        }


        ucNewLana = pLanaMap[ ucIndex ].Lana;

        IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
        {
            NbPrint( ("Netbios : Lana for device is %d\n", ucNewLana ) );
        }
        
        //
        // update global info.
        //

        LOCK_GLOBAL();

        //
        //  verify that lana is not previously used.
        //
        if ( g_pusActiveDeviceList[ ucNewLana ].Buffer != NULL )
        {
            NbPrint( ( 
                "Netbios : Lana %d already in use by %ls\n",
                ucNewLana, g_pusActiveDeviceList[ ucNewLana ].Buffer
                ) );
                
            UNLOCK_GLOBAL();
			ExFreePool(usCurDevice.Buffer);
            break;
        }
        

        //
        //  update maxlana
        //  update lana enum if device is enumerated.
        //
        
        g_ulMaxLana = ulMaxLana;


        if ( pLanaMap[ ucIndex ].Enum )
        {
            g_leLanaEnum.lana[ g_leLanaEnum.length ] = ucNewLana;
            g_leLanaEnum.length++;
        }
        

        //
        //  add to active device list
        //
        RtlInitUnicodeString( 
            &g_pusActiveDeviceList[ ucNewLana ], usCurDevice.Buffer 
            );


        //
        //  for each FCB
        //      Acquire locks
        //      update MaxLana
        //      update LanaEnum
        //      update driver list
        //        

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            pfcb = pfe-> pfcb;
            
            LOCK_RESOURCE( pfcb );


            //
            // Add device name to list of drivers for this FCB.
            // If allocation fails for any FCB stop adding to any further
            // FCBs you are out of memory
            //

            nsStatus = AllocateAndCopyUnicodeString( 
                            &pfcb-> pDriverName[ ucNewLana ],
                            pusDeviceName
                            );

            if ( !NT_SUCCESS( nsStatus ) )
            {
                NbPrint( (
                    "Netbios : Failed to allocate for device name %x\n",
                    nsStatus
                    ) );
                    
                UNLOCK_RESOURCE( pfcb );

                break;
            }

            else
            {
                pfcb-> MaxLana = ulMaxLana;

                pfcb-> LanaEnum.lana[ pfcb-> LanaEnum.length ] = ucNewLana;

                pfcb-> LanaEnum.length++;
            }

            IF_NBDBG( NB_DEBUG_LIST_LANA )
            {
                DumpDeviceList( pfcb );
            }
        
            
            UNLOCK_RESOURCE( pfcb );


#if AUTO_RESET

            //
            // add this list of lana to be reset
            //

            prle = ExAllocatePoolWithTag( 
                        NonPagedPool, sizeof( RESET_LANA_ENTRY ), 'fSBN' 
                        );

            if ( prle == NULL )
            {
                NbPrint( ("Failed to allocate RESET_LANA_ENTRY\n") );
                continue;
            }

            InitializeListHead( &prle-> leList );
            prle-> ucLanaNum = ucNewLana;
            InsertTailList( &pfe-> leResetList, &prle-> leList );

            //
            // Notify the user mode apps that a new LANA has been added.
            //

            NotifyUserModeNetbios( pfe );
#endif
        }

        UNLOCK_GLOBAL();
            

    } while ( FALSE );


    //
    // deallocate LanaMap
    //

    if ( pkvfi != NULL )
    {
        ExFreePool( pkvfi );
    }

    
    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( (
            "\n---- Netbios : TdiBindHandler exited for device : %ls ----\n", 
            pusDeviceName-> Buffer
            ) );
    }

    return;
}



//----------------------------------------------------------------------------
// NbTdiUnbindHandler
//
// Call back function that process a TDI unbind notification that indicates
// a device has been removed.
//----------------------------------------------------------------------------

VOID
NbTdiUnbindHandler(
    IN      PUNICODE_STRING     pusDeviceName
    )
{

    UCHAR       ucLana = 0, ucInd = 0;
    ULONG       ulMaxLana;
    PLIST_ENTRY ple = NULL;
    PFCB_ENTRY  pfe = NULL;
    PFCB        pfcb = NULL;

    NTSTATUS    nsStatus;
    

    PAGED_CODE();

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n++++ Netbios : TdiUnbindHandler : entered for device : %ls ++++\n",
            pusDeviceName-> Buffer 
            ) );
    }


    do
    {
        //
        // Acquire Global lock
        //

        LOCK_GLOBAL();


        //
        // find device in global active device list and remove it.
        //

        for ( ucLana = 0; ucLana <= g_ulMaxLana; ucLana++ )
        {
            if ( g_pusActiveDeviceList[ ucLana ].Buffer == NULL )
            {
                continue;
            }
            
            if ( !RtlCompareUnicodeString(
                    &g_pusActiveDeviceList[ ucLana ],
                    pusDeviceName,
                    FALSE
                    ) )
            {
                ExFreePool( g_pusActiveDeviceList[ ucLana ].Buffer );
            
                RtlInitUnicodeString( &g_pusActiveDeviceList[ ucLana ], NULL );
            
                break;
            }
        }


        //
        // device was not found.  There is nothing more to be done.
        //
    
        if ( ucLana > g_ulMaxLana )
        {
            UNLOCK_GLOBAL();
            NbPrint( ( 
                "Netbios : device not found %ls\n", pusDeviceName-> Buffer
                ) );

            break;
        }
    

        //
        // Update Max Lana
        //

        nsStatus = GetMaxLana( &g_usRegistryPath, &g_ulMaxLana );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            UNLOCK_GLOBAL();
            NbPrint( (
                "Netbios : GetMaxLana failed with status %lx\n", nsStatus 
                ) );
            break;
        }
        

        //
        // update global Lana enum
        //

        for ( ucInd = 0; ucInd < g_leLanaEnum.length; ucInd++ )
        {
            if ( ucLana == g_leLanaEnum.lana[ ucInd ] )
            {
                break;
            }
        }


        if ( ucInd < g_leLanaEnum.length ) 
        {
            //
            // device present in Lana Enum.  Remove it
            // by sliding over the rest of the lana enum.
            //

            RtlCopyBytes( 
                &g_leLanaEnum.lana[ ucInd ],
                &g_leLanaEnum.lana[ ucInd + 1],
                g_leLanaEnum.length - ucInd - 1
                );

            g_leLanaEnum.length--;
        }

        
        //
        // Walk the list of FCB and remove this device from each FCB.
        // clean up for this resource.
        //

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = (PFCB_ENTRY) CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            pfcb = pfe-> pfcb;
            

            //
            // update max lana, lana enum.
            // delete device name and cleanup lana
            //
 
            LOCK_RESOURCE( pfcb );


            //
            // update global structures
            //
            
            pfcb-> MaxLana = g_ulMaxLana;

            RtlCopyMemory( &pfcb-> LanaEnum, &g_leLanaEnum, sizeof( LANA_ENUM ) );

        
            //
            // remove device from list of active device
            //
            
            if ( pfcb-> pDriverName[ ucLana ].Buffer != NULL )
            {
                ExFreePool( pfcb-> pDriverName[ ucLana ].Buffer );

                RtlInitUnicodeString( &pfcb-> pDriverName[ ucLana ], NULL );
            }

            IF_NBDBG( NB_DEBUG_LIST_LANA )
            {
                DumpDeviceList( pfcb );
            }
        

            //
            // clean up lana info for this device.
            //
            
            if ( pfcb-> ppLana[ ucLana ] != NULL )
            {
                UNLOCK_RESOURCE( pfcb );
                CleanupLana( pfcb, ucLana, TRUE );
            }

            else
            {
                UNLOCK_RESOURCE( pfcb );
            }
        }

        UNLOCK_GLOBAL();

    } while ( FALSE );


    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( (
            "\n---- Netbios : TdiUnbindHandler : exited for device : %ls ----\n", 
            pusDeviceName-> Buffer 
            ) );
    }

    return;    
}



#if AUTO_RESET

VOID
NotifyUserModeNetbios(
    IN  PFCB_ENTRY      pfe
)
/*++

Description :
    This routine notifies the mode component of NETBIOS in NETAPI32.DLL
    of new LANAs that have been bound to NETBIOS.  This is done by 
    completing IRPs that have been pended with the kernel mode component.

Arguements :
    pfe - Pointer to FCB entry.

Return Value :
    None

Environment :
    Called in the context of the TDI bind handler.  Assumes that the GLOBAL
    resource lock is held when invoking this call.
--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    PIRP pIrp;

    KIRQL irql;

    PLIST_ENTRY  ple, pleNode;

    PRESET_LANA_ENTRY   prle;
    
    PNCB pUsersNCB;

#if defined(_WIN64)
    PNCB32  pUsersNCB32;
#endif

    

    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( 
            ("\n++++ Netbios : ENTERED NotifyUserModeNetbios : %p ++++\n", pfe)
            );
    }

    
    //
    // Complete each of the pending IRPs to signal the reset lana event.
    // This causes netapi32.dll to reset the specified LANA
    //
    
    
    if ( !IsListEmpty( &pfe-> leResetIrp ) )
    {
        //
        // get the first LANA that needs resetting
        //

        ple = RemoveHeadList( &pfe-> leResetList );

        prle = CONTAINING_RECORD( ple, RESET_LANA_ENTRY, leList );


        //
        // Acquire the spin lock for the IRP
        //
        
        IoAcquireCancelSpinLock( &irql );

        pleNode = RemoveHeadList( &pfe-> leResetIrp );

        pIrp = CONTAINING_RECORD( pleNode, IRP, Tail.Overlay.ListEntry );

        IoSetCancelRoutine( pIrp, NULL );

        pIrp->IoStatus.Status       = STATUS_SUCCESS;

        //
        // Return the LANA number. 
        //
 #if defined(_WIN64)
        if (IoIs32bitProcess(pIrp)) {
            pIrp->IoStatus.Information  = sizeof( NCB32 );
            pUsersNCB32 = (PNCB32) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB32->ncb_lana_num = prle-> ucLanaNum;                                                                                                                                                                                                                                                                                                                                   
        }
        else
 #else
        {
            pIrp->IoStatus.Information  = sizeof( NCB );
            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB->ncb_lana_num = prle-> ucLanaNum;                                                                                                                                                                                                                                                                                                                                   
        }
 #endif
        
        
        IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
        {
            NbPrint( 
                ("\n++++ Netbios : IRP %p, LANA %d\n", pIrp, prle-> ucLanaNum)
                );

            NbPrint( 
                ("Output Buffer %p, System Buffer %p ++++\n", 
                 pIrp-> UserBuffer, pIrp-> AssociatedIrp.SystemBuffer )
                );
        }
        
        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock( irql );

        IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );
    }


    IF_NBDBG( NB_DEBUG_CREATE_FILE ) 
    {
        NbPrint( 
            ("\n++++ Netbios : EXITING NotifyUserModeNetbios : %p ++++\n", pfe)
            );
    }

}

#endif


VOID
DumpDeviceList(
    IN      PFCB        pfcb
)
{

    UCHAR ucInd = 0, ucInd1 = 0;

    
    //
    // for each Lana, print device name, lana, enumerated or not.
    //

    NbPrint( ( 
        "\n++++ Netbios : list of current devices ++++\n"
        ) );

    for ( ucInd = 0; ucInd <= pfcb-> MaxLana; ucInd++ )
    {
        if ( pfcb-> pDriverName[ucInd].Buffer == NULL )
        {
            continue;
        }

        NbPrint( ( "Lana : %d\t", ucInd ) );

        for ( ucInd1 = 0; ucInd1 < pfcb-> LanaEnum.length; ucInd1++ )
        {
            if ( pfcb-> LanaEnum.lana[ ucInd1 ] == ucInd )
            {
                break;
            }
        }

        if ( ucInd1 < pfcb-> LanaEnum.length )
        {
            NbPrint( ( "Enabled \t" ) );
        }
        else
        {
            NbPrint( ( "Disabled\t" ) );
        }

        NbPrint( ( "%ls\n", pfcb-> pDriverName[ ucInd ].Buffer ) );
    }

    NbPrint( ("++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nbconst.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbconst.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/


#ifndef _NBCONST_
#define _NBCONST_

//
// MAJOR PROTOCOL IDENTIFIERS THAT CHARACTERIZE THIS DRIVER.
//

#define MAXIMUM_LANA                254
#define MAXIMUM_CONNECTION          254
#define MAXIMUM_ADDRESS             255

//
//  Default number of I/O stack locations in a Netbios Irp.  This value
//  is used if the Netbios\Parameters\IrpStackSize registry value is
//  missing.
//

#define NB_DEFAULT_IO_STACKSIZE     4

//
//  private ncb_command values used to add special names. Applications
//  cannot use these. Used in file.c and address.c
//

#define NCBADDRESERVED              0x7f
#define NCBADDBROADCAST             0x7e

//
//  Signature values for the major netbios driver structures.
//

#define NB_SIGNATURE_BASE           0xB1050000

#define AB_SIGNATURE                (NB_SIGNATURE_BASE + 0x000000ab)
#define CB_SIGNATURE                (NB_SIGNATURE_BASE + 0x000000cb)
#define FCB_SIGNATURE               (NB_SIGNATURE_BASE + 0x00000001)
#define LANA_INFO_SIGNATURE         (NB_SIGNATURE_BASE + 0x00000002)

//
//  PLANA status values
//

#define NB_INITIALIZING             0x00000001
#define NB_INITIALIZED              0x00000002
#define NB_DELETING                 0x00000003
#define NB_ABANDONED                0x00000004

//
// NT uses a system time measured in 100 nanosecnd intervals. define convenient
// constants for setting the timer.
//

#define MICROSECONDS                10
#define MILLISECONDS                10000                   // MICROSECONDS*1000
#define SECONDS                     10000000                // MILLISECONDS*1000

//
//  Names used for registry access
//

#define REGISTRY_LINKAGE            L"Linkage"
#define REGISTRY_PARAMETERS         L"Parameters"
#define REGISTRY_BIND               L"Bind"
#define REGISTRY_LANA_MAP           L"LanaMap"
#define REGISTRY_MAX_LANA           L"MaxLana"
#define REGISTRY_IRP_STACK_SIZE     L"IrpStackSize"


#define NETBIOS                     L"Netbios"

//
// prefix for NBF deive names
//

#define NBF_DEVICE_NAME_PREFIX      L"\\DEVICE\\NBF_"

#endif // _NBCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nbdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbdebug.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/



#ifndef _NBPROCS_
#define _NBPROCS_

//
// DEBUGGING SUPPORT.  DBG is a macro that is turned on at compile time
// to enable debugging code in the system.  If this is turned on, then
// you can use the IF_NBDBG(flags) macro in the NB code to selectively
// enable a piece of debugging code in the driver.  This macro tests
// NbDebug, a global ULONG defined in NB.C.
//

#if DBG

#define NB_DEBUG_DISPATCH      0x00000001      // nb.c
#define NB_DEBUG_DEVOBJ        0x00000002      // devobj.c
#define NB_DEBUG_COMPLETE      0x00000004      // nb.c
#define NB_DEBUG_CALL          0x00000008      // nb.c
#define NB_DEBUG_ASTAT         0x00000010      // nb.c
#define NB_DEBUG_SEND          0x00000020      // nb.c
#define NB_DEBUG_ACTION        0x00000040      // nb.c
#define NB_DEBUG_FILE          0x00000080      // file.c
#define NB_DEBUG_APC           0x00000100      // apc.c
#define NB_DEBUG_ERROR_MAP     0x00000200      // error.c
#define NB_DEBUG_LANSTATUS     0x00000400      // error.c
#define NB_DEBUG_ADDRESS       0x00000800      // address.c
#define NB_DEBUG_RECEIVE       0x00001000      // receive.c
#define NB_DEBUG_IOCANCEL      0x00002000      // nb.c

#define NB_DEBUG_CREATE_FILE   0x00004000      // used in address.c and connect.c
#define NB_DEBUG_LIST_LANA     0x00008000

#define NB_DEBUG_DEVICE_CONTROL 0x00040000

//#define NB_DEBUG_LANA_ERROR    0x00010000
//#define NB_DEBUG_ADDRESS_COUNT 0x00020000

#define NB_DEBUG_NCBS          0x04000000      // Used by NCB_COMPLETE in nb.h
#define NB_DEBUG_LOCKS         0x20000000      // nb.h
#define NB_DEBUG_TIMER         0x40000000      // timer.c
#define NB_DEBUG_NCBSBRK       0x80000000      // Used by NCB_COMPLETE in nb.h

extern ULONG NbDebug;                          // in NB.C.

//
//  VOID
//  IF_NBDBG(
//      IN PSZ Message
//      );
//

#define IF_NBDBG(flags)                                     \
    if (NbDebug & (flags))

#define NbPrint(String) DbgPrint String

#define InternalError(String) {                                     \
    DbgPrint("[NETBIOS]: Internal error : File %s, Line %d\n",      \
              __FILE__, __LINE__);                                  \
    DbgPrint String;                                                \
}

#else

#define IF_NBDBG(flags)                                     \
    if (0)

#define NbPrint(String) { NOTHING;}

#define NbDisplayNcb(String) { NOTHING;}

#define NbFormattedDump(String, String1) { NOTHING;}

#define InternalError(String) {                             \
    KeBugCheck(FILE_SYSTEM);                                \
}

#endif

#endif // def _NBPROCS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nbprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nbprocs.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/


//
// address.c
//

NTSTATUS
NbSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    );

NTSTATUS
NbAddName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbDeleteName(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbOpenAddress (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PUNICODE_STRING pusDeviceName,
    IN UCHAR LanNumber,
    IN PDNCB pdncb OPTIONAL
    );

PAB
NewAb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PDNCB pdncb
    );

VOID
CleanupAb(
    IN PPAB ppab,
    IN BOOLEAN CloseAddress
    );

VOID
NbAddressClose(
    IN HANDLE AddressHandle,
    IN PVOID Object
    );

PPAB
FindAb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IncrementUsers
    );

PPAB
FindAbUsingNum(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN UCHAR NameNumber
    );

BOOL
FindActiveSession(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    );

VOID
CloseListens(
    IN PFCB pfcb,
    IN PPAB ppab
    );

NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    );

//
// connect.c
//

NTSTATUS
NbCall(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbCallCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbListen(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbListenCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbAcceptCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PPCB
NbCallCommon(
    IN PDNCB pdncb,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbHangup(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbOpenConnection (
    OUT PHANDLE FileHandle,
    OUT PVOID *Object,
    IN PFCB pfcb,
    IN PVOID ConnectionContext,
    IN PDNCB pdncb
    );

PPCB
NewCb(
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PDNCB pdncb
    );

NTSTATUS
CleanupCb(
    IN PPCB ppcb,
    IN PDNCB pdncb OPTIONAL
    );

VOID
AbandonConnection(
    IN PPCB ppcb
    );

VOID
CloseConnection(
    IN PPCB ppcb,
    IN DWORD dwTimeOutinMS
    );

PPCB
FindCb(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN BOOLEAN IgnoreState
    );

NTSTATUS
NbTdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators
    );

PPCB
FindCallCb(
    IN PFCB pfcb,
    IN PNCB pncb,
    IN UCHAR ucLana
    );

PPCB
FindReceiveIndicated(
    IN PFCB pfcb,
    IN PDNCB pdncb,
    IN PPAB ppab
    );

#if DBG

//
// debug.c
//

VOID
NbDisplayNcb(
    IN PDNCB pdncb
    );

VOID
NbFormattedDump(
    PCHAR far_p,
    LONG  len
    );

#endif

//
// devobj.c
//

NTSTATUS
NbCreateDeviceContext(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN OUT PDEVICE_CONTEXT *DeviceContext,
    IN PUNICODE_STRING RegistryPath
    );

//
// error.c
//

unsigned char
NbMakeNbError(
    IN NTSTATUS Error
    );

NTSTATUS
NbLanStatusAlert(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CancelLanAlert(
    IN PFCB pfcb,
    IN PDNCB pdncb
    );

NTSTATUS
NbTdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    );

//
// file.c
//

NTSTATUS
NewFcb(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CleanupFcb(
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB pfcb
    );

VOID
OpenLana(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CleanupLana(
    IN PFCB pfcb,
    IN ULONG lana_index,
    IN BOOLEAN delete
    );


VOID
NbBindHandler(
    IN      TDI_PNP_OPCODE      PnpOpcode,
    IN      PUNICODE_STRING     DeviceName,
    IN      PWSTR               MultiSzBindList
	);
	
NTSTATUS
NbPowerHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PNET_PNP_EVENT      pnpeEvent,
    IN      PTDI_PNP_CONTEXT    ptpcContext1,
    IN      PTDI_PNP_CONTEXT    ptpcContext2
);


VOID
NbTdiBindHandler(
    IN      PUNICODE_STRING     pusDeviceName,
    IN      PWSTR               pwszMultiSZBindList
    );
    
VOID
NbTdiUnbindHandler(
    IN      PUNICODE_STRING     pusDeviceName
    );


//
// nb.c
//

NTSTATUS
NbCompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbCompletionPDNCB(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbClose(
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
NbDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NbDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NbOpen(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
QueueRequest(
    IN PLIST_ENTRY List,
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PFCB pfcb,
    IN KIRQL OldIrql,
    IN BOOLEAN Head);

PDNCB
DequeueRequest(
    IN PLIST_ENTRY List
    );

NTSTATUS
AllocateAndCopyUnicodeString(
    IN  OUT PUNICODE_STRING     pusDest,
    IN      PUNICODE_STRING     pusSource
);


//
// receive.c
//

NTSTATUS
NbReceive(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length,
    IN BOOLEAN Locked,
    IN KIRQL LockedIrql
    );

NTSTATUS
NbReceiveAny(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbTdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

PIRP
BuildReceiveIrp (
    IN PCB pcb
    );

NTSTATUS
NbReceiveDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbTdiDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
//  registry.c
//

CCHAR
GetIrpStackSize(
    IN PUNICODE_STRING RegistryPath,
    IN CCHAR DefaultValue
    );

NTSTATUS
ReadRegistry(
    IN PUNICODE_STRING pucRegistryPath,
    IN PFCB NewFcb,
    IN BOOLEAN bCreateDevice
    );

NTSTATUS
GetLanaMap(
    IN      PUNICODE_STRING                 pusRegistryPath,
    IN  OUT PKEY_VALUE_FULL_INFORMATION *   ppkvfi
    );
    
NTSTATUS
GetMaxLana(
    IN      PUNICODE_STRING     pusRegistryPath,
    IN  OUT PULONG              pulMaxLana
    );

VOID
NbFreeRegistryInfo (
    IN PFCB pfcb
    );

BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    );

//
// send.c
//

NTSTATUS
NbSend(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbSendDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

//
// timer.c
//

VOID
NbStartTimer(
    IN PFCB pfcb
    );

VOID
NbTimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NbTimer(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    ) ;

#if defined(_WIN64)

//
// nb32.c
//
NTSTATUS
NbThunkNcb(
    IN PNCB32 Ncb32,
    OUT PDNCB Dncb);

NTSTATUS
NbCompleteIrp32(
    IN OUT PIRP Irp
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nb.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nb.h

Abstract:

    Private include file for the NB (NetBIOS) component of the NTOS project.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Revision History:

--*/

#ifndef _NB_
#define _NB_

#include <ntifs.h>

//#include <ntos.h>
#include <windef.h>
#include <status.h>
#include <tdikrnl.h>                       // Transport Driver Interface.
#include <nb30.h>
#include <nb30p.h>
#include <netpnp.h>

#include "nbconst.h"                    // private NETBEUI constants.
#include "nbtypes.h"                    // private NETBEUI types.
#include "nbdebug.h"                    // private NETBEUI debug defines.
#include "nbprocs.h"                    // private NETBEUI function prototypes.

#ifdef MEMPRINT
#include "memprint.h"                   // drt's memory debug print
#endif

extern PEPROCESS    NbFspProcess;


extern ULONG                g_ulMaxLana;

extern LANA_ENUM            g_leLanaEnum;

extern PUNICODE_STRING      g_pusActiveDeviceList;

extern HANDLE               g_hBindHandle;

extern UNICODE_STRING       g_usRegistryPath;

extern LIST_ENTRY           g_leFCBList;

extern ERESOURCE            g_erGlobalLock;



#if DBG
#define PAGED_DBG 1
#endif
#ifdef PAGED_DBG
#undef PAGED_CODE
#define PAGED_CODE() \
    struct { ULONG bogus; } ThisCodeCantBePaged; \
    ThisCodeCantBePaged; \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
        KdPrint(( "NETBIOS: Pageable code called at IRQL %d.  File %s, Line %d\n", KeGetCurrentIrql(), __FILE__, __LINE__ )); \
        ASSERT(FALSE); \
        }
#define PAGED_CODE_CHECK() if (ThisCodeCantBePaged) ;
extern ULONG ThisCodeCantBePaged;
#else
#define PAGED_CODE_CHECK()
#endif


#if PAGED_DBG
#define ACQUIRE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeAcquireSpinLock(a, b);                    \
    }
#define RELEASE_SPIN_LOCK(a, b) {               \
    PAGED_CODE_CHECK();                         \
    KeReleaseSpinLock(a, b);                    \
    }

#else
#define ACQUIRE_SPIN_LOCK(a, b) KeAcquireSpinLock(a, b)
#define RELEASE_SPIN_LOCK(a, b) KeReleaseSpinLock(a, b)
#endif



//
//  Macro for filling in the status for an NCB.
//

#define NCB_COMPLETE( _pdncb, _code ) {                                 \
    UCHAR _internal_copy = _code;                                       \
    IF_NBDBG (NB_DEBUG_COMPLETE) {                                      \
        NbPrint (("%s %d NCB_COMPLETE: %lx, %lx\n" ,                    \
         __FILE__, __LINE__, _pdncb, _internal_copy ));                 \
    }                                                                   \
    if (((PDNCB)_pdncb)->ncb_retcode  == NRC_PENDING) {                 \
        ((PDNCB)_pdncb)->ncb_retcode  = _internal_copy;                 \
    } else {                                                            \
        IF_NBDBG (NB_DEBUG_NCBS) {                                      \
            NbPrint((" Status already set!!!!!!!!\n"));                 \
            IF_NBDBG (NB_DEBUG_NCBSBRK) {                               \
                DbgBreakPoint();                                        \
            }                                                           \
        }                                                               \
    }                                                                   \
    IF_NBDBG (NB_DEBUG_NCBS) {                                          \
        NbDisplayNcb( (PDNCB)_pdncb );                                  \
    }                                                                   \
    IF_NBDBG (NB_DEBUG_COMPLETE)                                        \
    {                                                                   \
        if ( ( (_code) == NRC_BRIDGE ) ||                               \
             ( (_code) == NRC_ENVNOTDEF ) )                             \
        {                                                               \
            DbgPrint("\n[NETBIOS]: NCB_COMPLETE : File %s,"             \
                     " line %d\n", __FILE__, __LINE__);                 \
            DbgPrint("LANA %x, Command %x ",                            \
                     ((PDNCB)_pdncb)->ncb_lana_num,                     \
                     ((PDNCB)_pdncb)->ncb_command );                    \
            DbgPrint("Return %x, Cmplt %x\n",                           \
                      ((PDNCB)_pdncb)->ncb_retcode,                     \
                      ((PDNCB)_pdncb)->ncb_cmd_cplt );                  \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_name, 16 );           \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_callname, 16 );       \
        }                                                               \
        else if ( ( ( (_code) == NRC_DUPNAME ) ||                       \
                    ( (_code) == NRC_INUSE ) ) &&                       \
                  ( ((PDNCB)_pdncb)-> ncb_command != NCBADDGRNAME ) )   \
        {                                                               \
            DbgPrint("\n[NETBIOS]: NCB_COMPLETE : DUPNAME : File %s,"   \
                     "line %d\n", __FILE__, __LINE__);                  \
            DbgPrint("LANA %x, Command %x ",                            \
                     ((PDNCB)_pdncb)->ncb_lana_num,                     \
                     ((PDNCB)_pdncb)->ncb_command );                    \
            DbgPrint("Return %x, Cmplt %x\n",                           \
                     ((PDNCB)_pdncb)->ncb_retcode,                      \
                     ((PDNCB)_pdncb)->ncb_cmd_cplt );                   \
            NbFormattedDump( ((PDNCB)_pdncb)->ncb_name, 16 );           \
            if ( ((PDNCB)_pdncb)->ncb_name[15] == 0x3)                  \
            {                                                           \
                DbgPrint("Messenger Name, dup ok\n");                   \
            }                                                           \
            else                                                        \
            {                                                           \
                IF_NBDBG(NB_DEBUG_NCBSBRK) DbgBreakPoint();             \
            }                                                           \
        }                                                               \
    }                                                                   \
}


//++
//
//  VOID
//  NbCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--
#define NbCompleteRequest(IRP,STATUS) {                 \
    (IRP)->IoStatus.Status = (STATUS);                  \
    IoCompleteRequest( (IRP), IO_NETWORK_INCREMENT );   \
}


#if defined(_WIN64)
#define NbCheckAndCompleteIrp32(Irp)                    \
{                                                       \
    if (IoIs32bitProcess(Irp) == TRUE)                  \
    {                                                   \
        NbCompleteIrp32(Irp);                           \
    }                                                   \
}
#else
#define NbCheckAndCompleteIrp32(Irp)
#endif                
//
//  Normally the driver wants to prohibit other threads making
//  requests (using a resource) and also prevent indication routines
//  being called (using a spinlock).
//
//  To do this LOCK and UNLOCK are used. IO system calls cannot
//  be called with a spinlock held so sometimes the ordering becomes
//  LOCK, UNLOCK_SPINLOCK <do IO calls> UNLOCK_RESOURCE.
//

#define LOCK(PFCB, OLDIRQL)   {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint (("%s %d LOCK: %lx %lx %lx\n" ,                 \
         __FILE__, __LINE__, (PFCB) ));                         \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &(PFCB)->Resource, TRUE);   \
    ACQUIRE_SPIN_LOCK( &(PFCB)->SpinLock, &(OLDIRQL));          \
}

#define LOCK_RESOURCE(PFCB)   {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_RESOURCE: %lx, %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB)));                          \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &(PFCB)->Resource, TRUE);   \
}

#define LOCK_GLOBAL()   {                                       \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_GLOBAL: %lx, %lx\n" ,              \
         __FILE__, __LINE__));                                  \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &g_erGlobalLock, TRUE);     \
}

#define LOCK_STOP()   {                                         \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d LOCK_STOP: %lx, %lx\n" ,                \
         __FILE__, __LINE__));                                  \
    }                                                           \
    KeEnterCriticalRegion();                                    \
    ExAcquireResourceExclusiveLite( &g_erStopLock, TRUE);       \
}


#define LOCK_SPINLOCK(PFCB, OLDIRQL)   {                        \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d LOCK_SPINLOCK: %lx %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB)));                          \
    }                                                           \
    ACQUIRE_SPIN_LOCK( &(PFCB)->SpinLock, &(OLDIRQL));          \
}

#define UNLOCK(PFCB, OLDIRQL) {                                 \
    UNLOCK_SPINLOCK( PFCB, OLDIRQL );                           \
    UNLOCK_RESOURCE( PFCB );                                    \
}

#define UNLOCK_GLOBAL()   {                                     \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d UNLOCK_GLOBAL: %lx, %lx\n" ,            \
         __FILE__, __LINE__));                                  \
    }                                                           \
    ExReleaseResourceLite( &g_erGlobalLock );                   \
    KeLeaveCriticalRegion();                                    \
}


#define UNLOCK_STOP()   {                                       \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint(("%s %d UNLOCK_STOP: %lx, %lx\n" ,              \
         __FILE__, __LINE__));                                  \
    }                                                           \
    ExReleaseResourceLite( &g_erStopLock );                     \
    KeLeaveCriticalRegion();                                    \
}

#define UNLOCK_RESOURCE(PFCB) {                                 \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d RESOURCE: %lx, %lx %lx\n" ,            \
         __FILE__, __LINE__, (PFCB) ));                         \
    }                                                           \
    ExReleaseResourceLite( &(PFCB)->Resource );                 \
    KeLeaveCriticalRegion();                                    \
}

#define UNLOCK_SPINLOCK(PFCB, OLDIRQL) {                        \
    IF_NBDBG (NB_DEBUG_LOCKS) {                                 \
        NbPrint( ("%s %d SPINLOCK: %lx, %lx %lx %lx\n" ,        \
         __FILE__, __LINE__, (PFCB), (OLDIRQL)));               \
    }                                                           \
    RELEASE_SPIN_LOCK( &(PFCB)->SpinLock, (OLDIRQL) );          \
}


//  Assume resource held when modifying CurrentUsers
#define REFERENCE_AB(PAB) {                                     \
    (PAB)->CurrentUsers++;                                      \
    IF_NBDBG (NB_DEBUG_ADDRESS) {                               \
        NbPrint( ("ReferenceAb %s %d: %lx, NewCount:%lx\n",     \
            __FILE__, __LINE__,                                 \
            PAB,                                                \
            (PAB)->CurrentUsers));                              \
        NbFormattedDump( (PUCHAR)&(PAB)->Name, sizeof(NAME) );  \
    }                                                           \
}

//  Resource must be held before dereferencing the address block

#define DEREFERENCE_AB(PPAB) {                                  \
    IF_NBDBG (NB_DEBUG_ADDRESS) {                               \
        NbPrint( ("DereferenceAb %s %d: %lx, OldCount:%lx\n",   \
            __FILE__, __LINE__, *PPAB, (*PPAB)->CurrentUsers)); \
        NbFormattedDump( (PUCHAR)&(*PPAB)->Name, sizeof(NAME) );\
    }                                                           \
    (*PPAB)->CurrentUsers--;                                    \
    if ( (*PPAB)->CurrentUsers == 0 ) {                         \
        if ( (*PPAB)->AddressHandle != NULL ) {                 \
            IF_NBDBG (NB_DEBUG_ADDRESS) {                       \
                NbPrint( ("DereferenceAb: Closing: %lx\n",      \
                    (*PPAB)->AddressHandle));                   \
            }                                                   \
            NbAddressClose( (*PPAB)->AddressHandle,             \
                                 (*PPAB)->AddressObject );      \
            (*PPAB)->AddressHandle = NULL;                      \
        }                                                       \
        (*PPAB)->pLana->AddressCount--;                         \
        ExFreePool( *PPAB );                                    \
        *PPAB = NULL;                                           \
    }                                                           \
}



//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
      #define try_return(S)  { S; goto try_exit; }

#define NETBIOS_STOPPING    1
#define NETBIOS_RUNNING     2;


#endif // def _NB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nb.c

Abstract:

    This module contains code which defines the NetBIOS driver's
    device object.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"
//#include <zwapi.h>
//#include <ntos.h>

typedef ADAPTER_STATUS  UNALIGNED *PUADAPTER_STATUS;
typedef NAME_BUFFER     UNALIGNED *PUNAME_BUFFER;
typedef SESSION_HEADER  UNALIGNED *PUSESSION_HEADER;
typedef SESSION_BUFFER  UNALIGNED *PUSESSION_BUFFER;

#if DBG
ULONG NbDebug = 0;
#endif

#if PAGED_DBG
ULONG ThisCodeCantBePaged;
#endif

PEPROCESS NbFspProcess = NULL;

//
// for PNP the list of devices is not static and hence cannot be read
// from the registry.  A global list of active devices is maintained.
// This list is updated by the bind and unbind handlers.  In addition
// to the device list the MaxLana and the LanaEnum also need to be
// updated to reflect the presence/absence of devices.
//

ULONG               g_ulMaxLana;

LANA_ENUM           g_leLanaEnum;

PUNICODE_STRING     g_pusActiveDeviceList;

HANDLE              g_hBindHandle;

UNICODE_STRING      g_usRegistryPath;


//
// every load of the netapi32.dll results in an open call (IRP_MJ_CREATE)
// call to the netbios.sys driver.  Each open creates an FCB that contains
// a list of devices, MaxLana and a LanaEnum.  Each FCB needs to be updated
// to reflect the changes to the active device list.
//
// In addition the LanaInfo structure corresponding to a Lana that has
// been unbound needs to be cleaned up.
//

LIST_ENTRY          g_leFCBList;

ERESOURCE           g_erGlobalLock;


//
// Each application that uses the NETBIOS api (via the netapi32.dll),
// opens a handle to \\Device\Netbios.  This file handle is not closed
// until netapi32.dll is unloaded.
//
// In order to be able to unload netbios.sys these handles have to be
// closed. To force these handles to be closed, the NETAPI32.DLL now
// posts an IOCTL (IOCTL_NB_REGISTER) to listen for shutdown
// notifications.  The IRPs corresponding to these IOCTLs are pended,
//
// When the driver is being stopped (unloaded), the pended IRPs are
// completed indicating to netapi32 that it needs to close the open
// handles on \\Device\netbios.
//
// Once all the handles have been closed NETBIOS.SYS can be unloaded.
//

ERESOURCE           g_erStopLock;       // protects g_ulNumOpens and
                                        // g_dwnetbiosState

DWORD               g_dwNetbiosState;

ULONG               g_ulNumOpens;


LIST_ENTRY          g_leWaitList;

KEVENT              g_keAllHandlesClosed;



NTSTATUS
NbAstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

VOID
CopyAddresses(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbFindName(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbSstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

VOID
CopySessionStatus(
    IN PDNCB pdncb,
    IN PCB pcb,
    IN PUSESSION_HEADER pSessionHeader,
    IN PUSESSION_BUFFER* ppSessionBuffer,
    IN PULONG pLengthRemaining
    );

NTSTATUS
NbEnum(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    );

NTSTATUS
NbReset(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbAction(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
NbCancel(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    );


//
// Pnp Stop related functions
//

NTSTATUS
NbRegisterWait(
    IN      PIRP                pIrp
    );

VOID
CancelIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
NbStop(
    );


#if AUTO_RESET

NTSTATUS
NbRegisterReset(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
);

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, NbDispatch)
#pragma alloc_text(PAGE, NbDeviceControl)
#pragma alloc_text(PAGE, NbOpen)
#pragma alloc_text(PAGE, NbClose)
#pragma alloc_text(PAGE, NbAstat)
#pragma alloc_text(PAGE, NbEnum)
#pragma alloc_text(PAGE, NbReset)
#pragma alloc_text(PAGE, NbFindName)
#pragma alloc_text(PAGE, AllocateAndCopyUnicodeString)

#endif

NTSTATUS
NbCompletionEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the Netbios driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("NbCompletion event: %lx, Irp: %lx, DeviceObject: %lx\n",
            Context,
            Irp,
            DeviceObject));
    }

    KeSetEvent((PKEVENT )Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
FindNameCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the TDI Irp used to issue a Find Name to netbt.
    It's main job is to clear the MdlAddress field in the IRP since it was
    borrowed from the original user mode IRP.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - User supplied context arg (not used)

Return Value:

    STATUS_SUCCESS

--*/
{
    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("FindNameCompletion: Irp: %lx, DeviceObject: %lx\n",
            Irp,
            DeviceObject));
    }

    Irp->MdlAddress = NULL;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );
}

NTSTATUS
NbCompletionPDNCB(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by setting the length and status bytes
    in the NCB supplied in context.

    Send requests have additional processing to remove the send request from
    the connection block send list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    NTSTATUS Status = STATUS_SUCCESS;


    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint(("NbCompletionPDNCB pdncb: %lx, Command: %lx, Lana: %lx,"
            "Status: %lx, Length: %lx\n",
            Context,
            pdncb-> ncb_command,
            pdncb-> ncb_lana_num,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information));
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        NCB_COMPLETE( pdncb, NRC_GOODRET );

    } else {

        if (((pdncb->ncb_command & ~ASYNCH) == NCBRECV ) ||
            ((pdncb->ncb_command & ~ASYNCH) == NCBRECVANY )) {

            if ( Irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW ) {

                PIRP LocalIrp = NULL;
                KIRQL OldIrql;              //  Used when SpinLock held.
                PPCB ppcb;
                PDEVICE_OBJECT LocalDeviceObject;

                LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

                //
                //  The transport will not indicate again so we must put
                //  another receive down if we can.
                //  If an Irp cannot be built then BuildReceiveIrp will
                //  set ReceiveIndicated.
                //

                ppcb = FindCb( pdncb->pfcb, pdncb, FALSE );

                if ( ppcb != NULL ) {

                    LocalDeviceObject = (*ppcb)->DeviceObject;

                    LocalIrp = BuildReceiveIrp( *ppcb );


                }

                UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );

                if ( LocalIrp != NULL ) {
                    IoCallDriver (LocalDeviceObject, LocalIrp);
                }

            }

        }

        NCB_COMPLETE( pdncb, NbMakeNbError( Irp->IoStatus.Status ) );

    }

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

    //
    //  Remove the Send request from the send queue. We have to scan
    //  the queue because they may be completed out of order if a send
    //  is rejected because of resource limitations.
    //

    if (((pdncb->ncb_command & ~ASYNCH) == NCBSEND ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSEND ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBSENDNA ) ||
        ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSENDNA )) {
        PLIST_ENTRY SendEntry;
        PPCB ppcb;
        KIRQL OldIrql;                      //  Used when SpinLock held.

        LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

        ppcb = FindCb( pdncb->pfcb, pdncb, FALSE );

        //
        //  If the connection block still exists remove the send. If the connection
        //  has gone then we no longer need to worry about maintaining the list.
        //

        if ( ppcb != NULL ) {
            #if DBG
            BOOLEAN Found = FALSE;
            #endif
            PCB pcb = *ppcb;

            for (SendEntry = pcb->SendList.Flink ;
                 SendEntry != &pcb->SendList ;
                 SendEntry = SendEntry->Flink) {

                PDNCB pSend = CONTAINING_RECORD( SendEntry, DNCB, ncb_next);

                if ( pSend == pdncb ) {

                    #if DBG
                    Found = TRUE;
                    #endif

                    RemoveEntryList( &pdncb->ncb_next );
                    break;
                }

            }

            ASSERT( Found == TRUE);

            //
            //  If the session is being hung up then we may wish to cleanup the connection
            //  as well. STATUS_HANGUP_REQUIRED will cause the dll to manufacture
            //  another hangup. The manufactured hangup will complete along with
            //  pcb->pdncbHangup. This method is used to ensure that when a
            //  hangup is delayed by an outstanding send and the send finally
            //  completes, that the user hangup completes after all operations
            //  on the connection.
            //

            if (( IsListEmpty( &pcb->SendList) ) &&
                ( pcb->pdncbHangup != NULL )) {

                IF_NBDBG (NB_DEBUG_COMPLETE) {
                    NbPrint( ("NbCompletionPDNCB Hangup session: %lx\n", ppcb ));
                }

                Status = STATUS_HANGUP_REQUIRED;
            }
        }

        UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    Irp->IoStatus.Status = Status;

    NbCheckAndCompleteIrp32(Irp);

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine performs initialization of the NetBIOS driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of the Netbios node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PDEVICE_CONTEXT DeviceContext;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;
    //STRING AnsiNameString;


    //
    // bind handler info.
    //

    TDI_CLIENT_INTERFACE_INFO tcii;
    PWSTR wsClientName = NETBIOS;
    UNICODE_STRING usClientName;
    UCHAR ucInd = 0;



    PAGED_CODE();

    //

#ifdef MEMPRINT
    MemPrintInitialize ();
#endif

    //
    //  Create the device object for NETBIOS. For now, we simply create
    //  \Device\Netbios using a unicode string.
    //

    NbFspProcess = PsGetCurrentProcess();

    RtlInitUnicodeString( &UnicodeString, NB_DEVICE_NAME);

    status = NbCreateDeviceContext (DriverObject,
                 &UnicodeString,
                 &DeviceContext,
                 RegistryPath);

    if (!NT_SUCCESS (status)) {
        NbPrint( ("NbInitialize: Netbios failed to initialize\n"));
        return status;
    }

    //
    // PnP additions - V Raman
    //

    //
    // save registry path.
    //

    g_usRegistryPath.Buffer = (PWSTR) ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( WCHAR ) * (RegistryPath-> Length + 1),
                                'fSBN'
                                );

    if ( g_usRegistryPath.Buffer == NULL )
    {
        NbPrint( (
            "DriverEntry : Netbios failed to allocate memory for registry path\n"
            ) );
        return STATUS_NO_MEMORY;
    }


    g_usRegistryPath.MaximumLength =
        sizeof( WCHAR ) * (RegistryPath-> Length + 1);

    RtlCopyUnicodeString( &g_usRegistryPath, RegistryPath );


    //
    // Save lana information.
    //

    status = GetMaxLana( &g_usRegistryPath, &g_ulMaxLana );

    if ( !NT_SUCCESS( status ) )
    {
        ExFreePool( g_usRegistryPath.Buffer );
        return status;
    }


    //
    // On starup there are no devices and no Lanas enabled.
    //

    g_leLanaEnum.length = 0;

    g_pusActiveDeviceList = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( UNICODE_STRING ) * ( MAX_LANA + 1 ),
                                'fSBN'
                                );

    if ( g_pusActiveDeviceList == NULL )
    {
        ExFreePool( g_usRegistryPath.Buffer );

        NbPrint( (
            "DriverEntry : Netbios failed to allocate memory for device list\n"
            ) );

        return STATUS_NO_MEMORY;
    }

    for ( ucInd = 0; ucInd <= MAX_LANA; ucInd++ )
    {
        RtlInitUnicodeString( &g_pusActiveDeviceList[ ucInd ], NULL );
    }


    //
    // There are no FCBs.
    //

    InitializeListHead( &g_leFCBList );

    ExInitializeResourceLite( &g_erGlobalLock );



    InitializeListHead( &g_leWaitList );

    ExInitializeResourceLite( &g_erStopLock );

    KeInitializeEvent( &g_keAllHandlesClosed, SynchronizationEvent, FALSE );

    g_ulNumOpens = 0;

    g_dwNetbiosState = NETBIOS_RUNNING;


    DeviceContext->Initialized = TRUE;


    //
    // set up binding handlers
    //

    RtlZeroMemory( &tcii, sizeof( TDI_CLIENT_INTERFACE_INFO ) );

    tcii.TdiVersion = TDI_CURRENT_VERSION;

    RtlInitUnicodeString( &usClientName, wsClientName );
    tcii.ClientName = &usClientName;


    tcii.BindingHandler = NbBindHandler;
    tcii.PnPPowerHandler = NbPowerHandler;

    status = TdiRegisterPnPHandlers(
                &tcii,
                sizeof( TDI_CLIENT_INTERFACE_INFO ),
                &g_hBindHandle
                );

    if ( status != STATUS_SUCCESS )
    {
        //
        // failed to register bind/unbind handlers
        //

        NbPrint( (
            "Netbios : DriverEntry : failed to register Bind handlers %0x\n", status
            ) );

        g_hBindHandle = NULL;


        ExDeleteResourceLite( &g_erStopLock );


        ExDeleteResourceLite( &g_erGlobalLock );

        ExFreePool( g_pusActiveDeviceList );

        ExFreePool( g_usRegistryPath.Buffer );

        DeviceContext->Initialized = FALSE;

        return status;
    }


    IF_NBDBG (NB_DEBUG_DISPATCH) {
        NbPrint( ("NbInitialize: Netbios initialized.\n"));
    }

    return (status);
}


VOID
NbDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the unload routine for the NB device driver.
    In response to an unload request this function deletes the
    "\\device\netbios" created by DriverEntry.

Arguments:

    DriverObject - Pointer to the driver object created by the system

Return Value:

    None

--*/

{
    NTSTATUS    nsStatus;

    UCHAR       ucIndex = 0;


    nsStatus = TdiDeregisterPnPHandlers( g_hBindHandle );

    if ( !NT_SUCCESS( nsStatus ) )
    {
        NbPrint( (
            "Netbios : NbDriverUnload : Failed to de-register bind handler\n"
            ) );
    }


    //
    // all opens to Netbios have been closed.
    // All devices have been unbound
    //    remove all global resources
    //

    LOCK_GLOBAL();

    for ( ucIndex = 0; ucIndex < g_ulMaxLana; ucIndex++ )
    {
        if ( g_pusActiveDeviceList[ ucIndex ].Buffer != NULL )
        {
            ExFreePool ( g_pusActiveDeviceList[ ucIndex ].Buffer );
        }
    }

    ExDeleteResourceLite( &g_erStopLock );

    ExFreePool( g_pusActiveDeviceList );

    ExFreePool( g_usRegistryPath.Buffer );

    UNLOCK_GLOBAL();

    ExDeleteResourceLite( &g_erGlobalLock );

    IoDeleteDevice( DriverObject-> DeviceObject );
}



NTSTATUS
NbDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the NB device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_CONTEXT DeviceContext;

    PAGED_CODE();

    //
    // Check to see if NB has been initialized; if not, don't allow any use.
    //

    DeviceContext = (PDEVICE_CONTEXT)DeviceObject;
    if (!DeviceContext->Initialized) {
        NbCompleteRequest( Irp, STATUS_SUCCESS);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (IrpSp->MajorFunction) {

        //
        // The Create function opens a handle that can be used with fsctl's
        // to build all interesting operations.
        //

        case IRP_MJ_CREATE:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CREATE.\n"));
            }

            //
            // check if netbios is in the process of stopping
            //

            LOCK_STOP();

            if ( g_dwNetbiosState == NETBIOS_STOPPING )
            {
                //
                // fail the CREATE operation and quit
                //

                Status = STATUS_NO_SUCH_DEVICE;
                Irp->IoStatus.Information = 0;

                UNLOCK_STOP();
            }

            else
            {
                //
                // netbios is still running.  Increment count of
                // open handles
                //

                g_ulNumOpens++;

                IF_NBDBG (NB_DEBUG_DISPATCH)
                {
                    NbPrint( ( "[NETBIOS] : NbOpen OpenCount %d\n", g_ulNumOpens ) );
                }

                UNLOCK_STOP();

                Status = NbOpen ( DeviceContext, IrpSp );
                Irp->IoStatus.Information = FILE_OPENED;

                //
                // if NbOpen failed, decrement count and return error
                //

                if ( !NT_SUCCESS( Status ) )
                {
                    LOCK_STOP();

                    g_ulNumOpens--;

                    IF_NBDBG (NB_DEBUG_DISPATCH)
                    {
                        NbPrint( ( "[NETBIOS] : NbOpen Open Error %lx, numopens : %d\n", Status, g_ulNumOpens ) );
                    }

                    //
                    // check if netbios is in the process of being stopped
                    //

                    if ( ( g_ulNumOpens == 0 ) &&
                         ( g_dwNetbiosState == NETBIOS_STOPPING ) )
                    {
                        //
                        // signal the stopping thread
                        //

                        KeSetEvent( &g_keAllHandlesClosed, 0, FALSE );

                        IF_NBDBG (NB_DEBUG_DISPATCH)
                        {
                            NbPrint( ( "[NETBIOS] : NbOpen error %lx; ", Status ) );
                            NbPrint( ( "Set stop event\n" ) );
                        }
                    }

                    UNLOCK_STOP();
                }
            }
            break;

        //
        // The Close function closes a transport , terminates
        // all outstanding transport activity on the transport, and unbinds
        // the from its transport address, if any. If this
        // is the last transport endpoint bound to the address, then
        // the address is removed by the provider.
        //

        case IRP_MJ_CLOSE:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CLOSE.\n"));
            }


            Status = NbClose( IrpSp);

            if ( NT_SUCCESS( Status ) )
            {

                LOCK_STOP();

                g_ulNumOpens--;

                IF_NBDBG (NB_DEBUG_DISPATCH)
                {
                    NbPrint( ( "[NETBIOS] : NbClose OpenCount %d\n", g_ulNumOpens ) );
                }

                if ( ( g_ulNumOpens == 0 ) &&
                     ( g_dwNetbiosState == NETBIOS_STOPPING ) )
                {
                    //
                    // netbios is shutting down and this is the
                    // last open file handle, signal the stopping
                    // thread
                    //

                    KeSetEvent( &g_keAllHandlesClosed, 0, FALSE );

                    IF_NBDBG (NB_DEBUG_DISPATCH)
                    {
                        NbPrint( ( "[NETBIOS] : NbClose, Set stop event\n" ) );
                    }
                }

                UNLOCK_STOP();
            }

            break;

        //
        // The DeviceControl function is the main path to the transport
        // driver interface.  Every TDI request is assigned a minor
        // function code that is processed by this function.
        //

        case IRP_MJ_DEVICE_CONTROL:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_DEVICE_CONTROL, Irp: %lx.\n", Irp ));
            }

            Status = NbDeviceControl (DeviceObject, Irp, IrpSp);

            if ((Status != STATUS_PENDING) &&
                (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_NB_NCB)) {

                //
                // Bug # : 340042
                //
                // Set the IoStatus.Information field only for IOCTL_NB_NCB.
                // For other IOCTLs it is either irrelevant or the IOCTL processing
                // will set it itself
                //

                //
                //  Tell IopCompleteRequest how much to copy back when the
                //  request completes. We need to do this for cases where
                //  NbCompletionPDNCB is not used.
                //
                Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            }

#if DBG
            if ( (Status != STATUS_SUCCESS) &&
                 (Status != STATUS_PENDING ) &&
                 (Status != STATUS_HANGUP_REQUIRED )) {

               IF_NBDBG (NB_DEBUG_DISPATCH) {
                   NbPrint( ("NbDispatch: Invalid status: %X.\n", Status ));
                   ASSERT( FALSE );
               }
            }
#endif
            break;

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, ignore it. We will do all the work on the close Irp.
        //

        case IRP_MJ_CLEANUP:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: IRP_MJ_CLEANUP.\n"));
            }
            Status = STATUS_SUCCESS;
            break;

        default:
            IF_NBDBG (NB_DEBUG_DISPATCH) {
                NbPrint( ("NbDispatch: OTHER (DEFAULT).\n"));
            }
            Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status == STATUS_PENDING) {
        IF_NBDBG (NB_DEBUG_DISPATCH) {
            NbPrint( ("NbDispatch: request PENDING from handler.\n"));
        }
    } else {
        IF_NBDBG (NB_DEBUG_DISPATCH) {
            NbPrint( ("NbDispatch: request COMPLETED by handler.\n"));
        }

        /*
         * Thunk the NCB back to 32-bit compatible
         * structure if the caller is a 32-bit app.
         */
        NbCheckAndCompleteIrp32(Irp);

        NbCompleteRequest( Irp, Status);
    }

    return Status;
} /* NbDispatch */

NTSTATUS
NbDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine dispatches NetBios request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNCB pUsersNcb;
    PDNCB pdncb = NULL;
    PUCHAR Buffer2;
    ULONG Buffer2Length;
    ULONG RequestLength;
    BOOLEAN Is32bitProcess;

    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
        NbPrint( ("NbDeviceControl: Entered...\n"));
    }

    switch ( IrpSp->Parameters.DeviceIoControl.IoControlCode )
    {
        case IOCTL_NB_NCB :
            break;

        case IOCTL_NB_REGISTER_STOP :
            Status = NbRegisterWait( Irp );
            return Status;

        case IOCTL_NB_STOP :
            Status = NbStop();
            return Status;

#if AUTO_RESET
        case IOCTL_NB_REGISTER_RESET :
            Status = NbRegisterReset( Irp, IrpSp );
            return Status;
#endif

        default:
        {
            IF_NBDBG (NB_DEBUG_DEVICE_CONTROL)
            {
                NbPrint( ("NbDeviceControl: invalid request type.\n"));
            }

            return STATUS_INVALID_DEVICE_REQUEST;
        }

    }


    //
    //  Caller provided 2 buffers. The first is the NCB.
    //  The second is an optional buffer for send or receive data.
    //  Since the Netbios driver only operates in the context of the
    //  calling application, these buffers are directly accessable.
    //  however they can be deleted by the user so try-except clauses are
    //  required.
    //

    pUsersNcb = (PNCB)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    RequestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    Buffer2 = Irp->UserBuffer;
    Buffer2Length = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

#if defined(_WIN64)
    Is32bitProcess = IoIs32bitProcess(Irp);
    if (Is32bitProcess == TRUE) {
        if (RequestLength != sizeof( NCB32 )) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
#endif

    if ( RequestLength != sizeof( NCB ) ) {
        return STATUS_INVALID_PARAMETER;
    }
#if defined(_WIN64)
    }
#endif

    try {

        //
        // Probe the input buffer
        //

        if (ExGetPreviousMode() != KernelMode) {
            ProbeForWrite(pUsersNcb, RequestLength, 4);
        }

        //
        //  Create a copy of the NCB and convince the IO system to
        //  copy it back (and deallocate it) when the IRP completes.
        //

        Irp->AssociatedIrp.SystemBuffer =
            ExAllocatePoolWithTag( NonPagedPool, sizeof( DNCB ), 'nSBN' );

        if (Irp->AssociatedIrp.SystemBuffer == NULL) {
            //
            //  Since we cannot allocate the drivers copy of the NCB, we
            //  must turn around and use the original Ncb to return the error.
            //

#if defined(_WIN64)
            if (Is32bitProcess) {
                NCB32 *pUsersNcb32 = (PNCB32)
                                     IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                pUsersNcb32->ncb_retcode = NRC_NORES;
            } else {
#endif
                pUsersNcb->ncb_retcode  = NRC_NORES;

#if defined(_WIN64)
            }
#endif

            Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

            return STATUS_SUCCESS;
        }

        //
        // Tell the IO system where to copy the ncb back to during
        // IoCompleteRequest.
        //

        Irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER |
                        IRP_INPUT_OPERATION );

        Irp->UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;


        //  In the driver we should now use our copy of the NCB
        pdncb = Irp->AssociatedIrp.SystemBuffer;

#if defined(_WIN64)
        if (Is32bitProcess == TRUE) {
            RtlZeroMemory(pdncb, sizeof( DNCB ));
            NbThunkNcb((PNCB32)pUsersNcb, pdncb);
        } else {
#endif
        RtlMoveMemory( pdncb,
                       pUsersNcb,
                       FIELD_OFFSET( DNCB, ncb_cmd_cplt )+1 );

#if defined(_WIN64)
        }
#endif
        //
        //  Save the users virtual address for the NCB just in case the
        //  virtual address is supplied in an NCBCANCEL. This is the same
        //  as Irp->UserBuffer.
        //

        pdncb->users_ncb = pUsersNcb;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
            NbPrint( ("NbDeviceControl: Exception1 %X.\n", Status));
        }

        if (pdncb != NULL) {
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
        }

        return Status;
    }

    if ( Buffer2Length ) {

        //  Mdl will be freed by IopCompleteRequest.
        Irp->MdlAddress = IoAllocateMdl( Buffer2,
                                     Buffer2Length,
                                     FALSE,
                                     FALSE,
                                     Irp  );
        ASSERT( Irp->MdlAddress != NULL );


        //
        // Added by V Raman for bug fix : 127223
        //
        // Check if MDL allocate failed and return.
        //

        if ( Irp-> MdlAddress == NULL )
        {
            IF_NBDBG(NB_DEBUG_DEVICE_CONTROL)
                NbPrint( ("[NETBIOS] NbDeviceControl: Failed to allocate MDL") );

            NCB_COMPLETE( pdncb, NRC_NORES );
            return STATUS_SUCCESS;
        }


        try {
            MmProbeAndLockPages( Irp->MdlAddress,
                                Irp->RequestorMode,
                                (LOCK_OPERATION) IoModifyAccess);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
                NbPrint( ("NbDeviceControl: Exception2 %X.\n", Status));
                NbPrint( ("NbDeviceControl: IoContolCode: %lx, Fcb: %lx,"
                      " ncb_command %lx, Buffer2Length: %lx\n",
                        IrpSp->Parameters.DeviceIoControl.IoControlCode,
                        IrpSp->FileObject->FsContext2,
                        pdncb->ncb_command,
                        Buffer2Length));
            }
            if ( Irp->MdlAddress != NULL ) {
                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
            }
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
            return STATUS_SUCCESS;
        }
    } else {
        ASSERT( Irp->MdlAddress == NULL );
    }

    IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
        NbPrint( ("NbDeviceControl: Fcb: %lx, Ncb: %lx"
              " ncb_command %lx, ncb_lana_num: %lx\n",
                IrpSp->FileObject->FsContext2,
                pdncb,
                pdncb->ncb_command,
                pdncb->ncb_lana_num));
    }

    switch ( pdncb->ncb_command & ~ASYNCH ) {

    case NCBCALL:
    case NCALLNIU:
        Status = NbCall( pdncb, Irp, IrpSp );
        break;

    case NCBCANCEL:
        Status = NbCancel( pdncb, Irp, IrpSp );
        break;

    case NCBLISTEN:
        Status = NbListen( pdncb, Irp, IrpSp );
        break;

    case NCBHANGUP:
        Status = NbHangup( pdncb, Irp, IrpSp );
        break;

    case NCBASTAT:
        Status = NbAstat( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBFINDNAME:
        Status = NbFindName( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBSSTAT:
        Status = NbSstat( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBENUM:
        NbEnum( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBRECV:
        Status = NbReceive( pdncb, Irp, IrpSp, Buffer2Length, FALSE, 0 );
        break;

    case NCBRECVANY:
        Status = NbReceiveAny( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBDGRECV:
    case NCBDGRECVBC:
        Status = NbReceiveDatagram( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBSEND:
    case NCBSENDNA:
    case NCBCHAINSEND:
    case NCBCHAINSENDNA:
        Status = NbSend( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBDGSEND:
    case NCBDGSENDBC:
        Status = NbSendDatagram( pdncb, Irp, IrpSp, Buffer2Length );
        break;

    case NCBADDNAME:
    case NCBADDGRNAME:
    case NCBQUICKADDNAME:
    case NCBQUICKADDGRNAME:
        NbAddName( pdncb, IrpSp );
        break;

    case NCBDELNAME:
        NbDeleteName( pdncb, IrpSp );
        break;

    case NCBLANSTALERT:
        Status = NbLanStatusAlert( pdncb, Irp, IrpSp );
        break;

    case NCBRESET:
        Status = NbReset( pdncb, Irp, IrpSp );
        break;

    case NCBACTION:
        Status = NbAction( pdncb, Irp, IrpSp);
        break;

    //  The following are No-operations that return success for compatibility
    case NCBUNLINK:
    case NCBTRACE:
        NCB_COMPLETE( pdncb, NRC_GOODRET );
        break;

    default:
        NCB_COMPLETE( pdncb, NRC_ILLCMD );
        break;
    }

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );

} /* NbDeviceControl */

NTSTATUS
NbOpen(
    IN PDEVICE_CONTEXT DeviceContext,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

Arguments:

    DeviceContext - Includes the name of the netbios node in the registry.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PAGED_CODE();

    return NewFcb( DeviceContext, IrpSp );
} /* NbOpen */


NTSTATUS
NbClose(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to close an existing handle.  This
    involves running down all of the current and pending activity associated
    with the handle, and dereferencing structures as appropriate.

Arguments:

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    PAGED_CODE();

    if (pfcb!=NULL) {

        CleanupFcb( IrpSp, pfcb );

    }

    return STATUS_SUCCESS;
} /* NbClose */

NTSTATUS
NbAstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return the adapter status. It queries the
    transport for the main adapter status data such as number of FRMR frames
    received and then uses CopyAddresses to fill in the status for the names
    that THIS application has added.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TA_NETBIOS_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN ChangedMode=FALSE;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    UNICODE_STRING usDeviceName;


    PAGED_CODE();

    RtlInitUnicodeString( &usDeviceName, NULL );


    if ( Buffer2Length >= sizeof(ADAPTER_STATUS) ) {
        KEVENT Event1;
        NTSTATUS Status;
        HANDLE TdiHandle;
        PFILE_OBJECT TdiObject;
        PDEVICE_OBJECT DeviceObject;

        RtlInitUnicodeString( &usDeviceName, NULL );


        //
        // for PNP
        //

        LOCK_RESOURCE( pfcb );


        if ( ( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
             ( pfcb->pDriverName[pdncb->ncb_lana_num].MaximumLength == 0 ) ||
             ( pfcb->pDriverName[pdncb->ncb_lana_num].Buffer == NULL ) ) {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        if (( pfcb == NULL ) ||
            (pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
            (pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
            NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }

        Status = AllocateAndCopyUnicodeString(
                    &usDeviceName, &pfcb->pDriverName[pdncb->ncb_lana_num]
                    );

        if ( !NT_SUCCESS( Status ) )
        {
            NCB_COMPLETE( pdncb, NRC_NORESOURCES );
            UNLOCK_RESOURCE( pfcb );
            return STATUS_SUCCESS;
        }


        UNLOCK_RESOURCE( pfcb );


        //  NULL returns a handle for doing control functions
        Status = NbOpenAddress (
                    &TdiHandle, (PVOID*)&TdiObject, &usDeviceName,
                    pdncb->ncb_lana_num, NULL
                    );

        if (!NT_SUCCESS(Status)) {
            IF_NBDBG (NB_DEBUG_ASTAT) {
                NbPrint(( "\n  FAILED on open of Tdi: %X ******\n", Status ));
            }
            NCB_COMPLETE( pdncb, NRC_SYSTEM );

            ExFreePool( usDeviceName.Buffer );

            return STATUS_SUCCESS;
        }

        KeInitializeEvent (
                &Event1,
                SynchronizationEvent,
                FALSE);

        DeviceObject = IoGetRelatedDeviceObject( TdiObject );

        TdiBuildQueryInformation( Irp,
                DeviceObject,
                TdiObject,
                NbCompletionEvent,
                &Event1,
                TDI_QUERY_ADAPTER_STATUS,
                Irp->MdlAddress);

        if ( pdncb->ncb_callname[0] != '*') {
            //
            //  Remote Astat. The variables used to specify the remote adapter name
            //  are kept the same as those in connect.c to aid maintenance.
            //
            PIO_STACK_LOCATION NewIrpSp = IoGetNextIrpStackLocation (Irp);

            ConnectBlock.TAAddressCount = 1;
            ConnectBlock.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            ConnectBlock.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
            temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock.Address[0].Address;

            temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

            RequestInformation.RemoteAddress = &ConnectBlock;
            RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                                    sizeof (TDI_ADDRESS_NETBIOS);
            ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&NewIrpSp->Parameters)
                ->RequestConnectionInformation = &RequestInformation;

             PreviousMode = Irp->RequestorMode;
             Irp->RequestorMode = KernelMode;
             ChangedMode=TRUE;


        } else {

            //
            //  Avoid situation where adapter has more names added than the process and
            //  then extra names get added to the end of the buffer.
            //

            //
            //  Map the users buffer now so that the whole buffer is mapped (not
            //  just sizeof ADAPTER_STATUS).
            //

            if (Irp->MdlAddress) {
                if (MmGetSystemAddressForMdlSafe(
                        Irp->MdlAddress, NormalPagePriority
                        ) == NULL) {

                    IF_NBDBG (NB_DEBUG_ASTAT) {
                        NbPrint(( "\nFAILED on mapping MDL ******\n" ));
                    }
                    NCB_COMPLETE( pdncb, NRC_SYSTEM );
                    ExFreePool( usDeviceName.Buffer );
                    return STATUS_SUCCESS;
                }

            } else {

                ASSERT(FALSE);
            }

            Irp->MdlAddress->ByteCount = sizeof(ADAPTER_STATUS);

        }

        IoCallDriver (DeviceObject, Irp);

        if (ChangedMode) {
            Irp->RequestorMode = PreviousMode;
        }

        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);


        //
        //  Restore length now that the transport has filled in no more than
        //  is required of it.
        //

        if (Irp->MdlAddress) {
            Irp->MdlAddress->ByteCount = Buffer2Length;
        }

        NbAddressClose( TdiHandle, TdiObject );

        if (!NT_SUCCESS(Status)) {
            NCB_COMPLETE( pdncb, NRC_SYSTEM );
            ExFreePool( usDeviceName.Buffer );
            return Status;
        }

        Status = Irp->IoStatus.Status;
        if (( Status == STATUS_BUFFER_OVERFLOW ) &&
            ( pdncb->ncb_callname[0] == '*')) {
            //
            //  This is a local ASTAT. Don't worry if there was not enough room in the
            //  users buffer for all the addresses that the transport knows about. There
            //  only needs to be space for the names the user has added and we will check
            //  that later.
            //
            Status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(Status)) {

            pdncb->ncb_length = (WORD)Irp->IoStatus.Information;
            NCB_COMPLETE( pdncb, NbMakeNbError(Status) );

        } else {

            if (  pdncb->ncb_callname[0] == '*') {
                //
                //  Append the addresses and Netbios maintained counts.
                //

                CopyAddresses(
                     pdncb,
                     Irp,
                     IrpSp,
                     Buffer2Length);
                //  CopyAddresses completes the NCB appropriately.

            } else {

                pdncb->ncb_length = (WORD)Irp->IoStatus.Information;
                NCB_COMPLETE( pdncb, NRC_GOODRET );

            }
        }

    } else {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    }


    //
    //  Because the completion routine returned STATUS_MORE_PROCESSING_REQUIRED
    //  NbAstat must return a status other than STATUS_PENDING so that the
    //  users Irp gets completed.
    //

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }

    ASSERT( Status != STATUS_PENDING );

    return Status;

    UNREFERENCED_PARAMETER( IrpSp );
}

VOID
CopyAddresses(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to finish the adapter status.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    none.

--*/
{
    ULONG LengthRemaining = Buffer2Length - sizeof(ADAPTER_STATUS);

    PUADAPTER_STATUS pAdapter;
    PUNAME_BUFFER pNameArray;
    int NextEntry = 0;  // Used to walk pNameArray

    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PLANA_INFO plana;
    int index;          //  Used to access AddressBlocks
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    plana = pfcb->ppLana[pdncb->ncb_lana_num];
    if ((plana == NULL ) ||
        (plana->Status != NB_INITIALIZED)) {
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
        UNLOCK( pfcb, OldIrql );
        return;
    }

    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        pAdapter = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
        if (pAdapter == NULL) {
            NCB_COMPLETE( pdncb, NRC_NORES );
            UNLOCK( pfcb, OldIrql );
            return;
        }
    } else {

        ASSERT(FALSE);
		return;
    }

    pNameArray = (PUNAME_BUFFER)((PUCHAR)pAdapter + sizeof(ADAPTER_STATUS));

    pAdapter->rev_major = 0x03;
    pAdapter->rev_minor = 0x00;
    pAdapter->free_ncbs = 255;
    pAdapter->max_cfg_ncbs = 255;
    pAdapter->max_ncbs = 255;

    pAdapter->pending_sess = 0;
    for ( index = 0; index <= MAXIMUM_CONNECTION; index++ ) {
        if ( plana->ConnectionBlocks[index] != NULL) {
            pAdapter->pending_sess++;
        }
    }

    pAdapter->max_cfg_sess = (WORD)plana->MaximumConnection;
    pAdapter->max_sess = (WORD)plana->MaximumConnection;
    pAdapter->name_count = 0;

    //  Don't include the reserved address so start at index=2.
    for ( index = 2; index < MAXIMUM_ADDRESS; index++ ) {

        if ( plana->AddressBlocks[index] != NULL ) {

            if ( LengthRemaining >= sizeof(NAME_BUFFER) ) {

                RtlCopyMemory( (PUCHAR)&pNameArray[NextEntry],
                    &plana->AddressBlocks[index]->Name,
                    sizeof(NAME));
                pNameArray[NextEntry].name_num =
                    plana->AddressBlocks[index]->NameNumber;
                pNameArray[NextEntry].name_flags =
                    plana->AddressBlocks[index]->Status;

                LengthRemaining -= sizeof(NAME_BUFFER);
                NextEntry++;
                pAdapter->name_count++;

            } else {

                NCB_COMPLETE( pdncb, NRC_INCOMP );
                goto exit;

            }
        }
    }

    NCB_COMPLETE( pdncb, NRC_GOODRET );

exit:
    pdncb->ncb_length = (unsigned short)( sizeof(ADAPTER_STATUS) +
                                        ( sizeof(NAME_BUFFER) * NextEntry));
    UNLOCK( pfcb, OldIrql );
}

NTSTATUS
NbFindName(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return the result of a name query.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    TDI_CONNECTION_INFORMATION RequestInformation;
    TA_NETBIOS_ADDRESS ConnectBlock;
    PTDI_ADDRESS_NETBIOS temp;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    KEVENT Event1;
    HANDLE TdiHandle;
    PFILE_OBJECT TdiObject;
    PDEVICE_OBJECT DeviceObject;

    UNICODE_STRING usDeviceName;

    PIRP nbtIrp;
    PIO_STACK_LOCATION nbtIrpSp;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();


    if ((pfcb == NULL) || (Buffer2Length < (sizeof(FIND_NAME_HEADER) + sizeof(FIND_NAME_BUFFER)))) {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
        return STATUS_SUCCESS;
    }

    RtlInitUnicodeString( &usDeviceName, NULL );

    LOCK_RESOURCE( pfcb );

    if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
        ( pfcb == NULL ) ||
        (pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        (pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED)) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_ENVNOTDEF ); // need a reset
        return STATUS_SUCCESS;
    }

    if ( ( pfcb->pDriverName[pdncb->ncb_lana_num].MaximumLength == 0 ) ||
         ( pfcb->pDriverName[pdncb->ncb_lana_num].Buffer == NULL ) ) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    Status = AllocateAndCopyUnicodeString(
                &usDeviceName, &pfcb->pDriverName[pdncb->ncb_lana_num]
                );

    if ( !NT_SUCCESS( Status ) )
    {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_NORESOURCES );
        return STATUS_SUCCESS;
    }


    UNLOCK_RESOURCE( pfcb );


    // NULL returns a handle for doing control functions
    Status = NbOpenAddress (
                &TdiHandle, (PVOID*)&TdiObject, &usDeviceName,
                pdncb->ncb_lana_num, NULL
                );

    if (!NT_SUCCESS(Status)) {
        IF_NBDBG (NB_DEBUG_ASTAT) {
            NbPrint(( "\n  FAILED on open of Tdi: %X ******\n", Status ));
        }
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        ExFreePool( usDeviceName.Buffer );
        return STATUS_SUCCESS;
    }

    KeInitializeEvent (
            &Event1,
            SynchronizationEvent,
            FALSE);

    DeviceObject = IoGetRelatedDeviceObject( TdiObject );

    //
    // DDK sez we shouldn't hijack the user mode IRP. We create one of our own
    // to issue to Netbt for the query.
    //
    nbtIrp = TdiBuildInternalDeviceControlIrp(TdiBuildQueryInformation,
                                              DeviceObject,
                                              TdiObject,
                                              &Event1,
                                              &ioStatus);

    if ( nbtIrp == NULL ) {
        IF_NBDBG (NB_DEBUG_ASTAT) {
            NbPrint(( "\n  FAILED to allocate internal Irp for Tdi: %X ******\n", ioStatus.Status ));
        }
        NCB_COMPLETE( pdncb, NRC_SYSTEM );
        ExFreePool( usDeviceName.Buffer );
        return STATUS_SUCCESS;
    }

    IF_NBDBG (NB_DEBUG_ASTAT) {
        NbPrint(("NbFindName: Allocated IRP %08x for TdiBuildQueryInfo\n", nbtIrp ));
    }

    //
    // we use our own find name completion routine. We "borrow" the MDL from
    // the user mode IRP, hence it must be cleared from the TDI IRP before it
    // is completed. Findname's completion routine takes care of that detail.
    //
    TdiBuildQueryInformation( nbtIrp,
            DeviceObject,
            TdiObject,
            FindNameCompletion,
            0,
            TDI_QUERY_FIND_NAME,
            Irp->MdlAddress);

    nbtIrpSp = IoGetNextIrpStackLocation (nbtIrp);

    //
    //  The variables used to specify the remote adapter name
    //  are kept the same as those in connect.c to aid maintenance.
    //

    ConnectBlock.TAAddressCount = 1;
    ConnectBlock.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ConnectBlock.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);
    temp = (PTDI_ADDRESS_NETBIOS)ConnectBlock.Address[0].Address;

    temp->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    RtlMoveMemory( temp->NetbiosName, pdncb->ncb_callname, NCBNAMSZ );

    RequestInformation.RemoteAddress = &ConnectBlock;
    RequestInformation.RemoteAddressLength = sizeof (TRANSPORT_ADDRESS) +
                                            sizeof (TDI_ADDRESS_NETBIOS);
    ((PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&nbtIrpSp->Parameters)
        ->RequestConnectionInformation = &RequestInformation;

    Status = IoCallDriver (DeviceObject, nbtIrp);

    if ( Status == STATUS_PENDING ) {
        do {
            Status = KeWaitForSingleObject(
                        &Event1, Executive, KernelMode, TRUE, NULL
                        );
        } while (Status == STATUS_ALERTED);
    }

    NbAddressClose( TdiHandle, TdiObject );

    if (NT_SUCCESS(Status)) {
        Status = ioStatus.Status;
    }

    if (!NT_SUCCESS(Status)) {
        NCB_COMPLETE( pdncb, NbMakeNbError(Status) );
        Status = STATUS_SUCCESS;
    } else {
        pdncb->ncb_length = (WORD)ioStatus.Information;
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    //
    //  Because the completion routine returned STATUS_MORE_PROCESSING_REQUIRED
    //  NbFindName must return a status other than STATUS_PENDING so that the
    //  users Irp gets completed.
    //

    ASSERT( Status != STATUS_PENDING );

    if ( usDeviceName.Buffer != NULL )
    {
        ExFreePool( usDeviceName.Buffer );
    }

    return Status;
}

NTSTATUS
NbSstat(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to return session status. It uses only structures
    internal to this driver.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - User provided buffer length for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ( Buffer2Length >= sizeof(SESSION_HEADER) ) {

        PFCB pfcb = IrpSp->FileObject->FsContext2;
        PLANA_INFO plana;
        int index;
        PUSESSION_HEADER pSessionHeader = NULL;
        PUSESSION_BUFFER pSessionBuffer = NULL;
        ULONG LengthRemaining;
        PAB pab;
        KIRQL OldIrql;                      //  Used when SpinLock held.

        //
        //  Prevent indications from the transport, post routines being called
        //  and another thread making a request while manipulating the netbios
        //  data structures.
        //

        LOCK( pfcb, OldIrql );

        if (pdncb->ncb_lana_num > pfcb->MaxLana ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        if (( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == (LANA_INFO *) NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        plana = pfcb->ppLana[pdncb->ncb_lana_num];

        if ( pdncb->ncb_name[0] != '*') {
            PPAB ppab = FindAb(pfcb, pdncb, FALSE);
            if ( ppab == NULL) {
                UNLOCK( pfcb, OldIrql );
                pdncb->ncb_retcode = NRC_PENDING;
                NCB_COMPLETE( pdncb, NRC_NOWILD );
                return STATUS_SUCCESS;
            }
            pab = *ppab;
        }

        //
        //  Map the users buffer so we can poke around inside
        //

        if (Irp->MdlAddress) {
            pSessionHeader = MmGetSystemAddressForMdlSafe(
                                Irp->MdlAddress, NormalPagePriority);
        }

        if ((Irp->MdlAddress == NULL) ||
            (pSessionHeader == NULL)) {

            UNLOCK( pfcb, OldIrql );
            pdncb->ncb_retcode = NRC_PENDING;
            NCB_COMPLETE( pdncb, NRC_NORES );
            return STATUS_SUCCESS;
        }

        pSessionHeader->sess_name = 0;
        pSessionHeader->num_sess = 0;
        pSessionHeader->rcv_dg_outstanding = 0;
        pSessionHeader->rcv_any_outstanding = 0;

        if ( pdncb->ncb_name[0] == '*') {
            for ( index = 0; index <= MAXIMUM_ADDRESS; index++ ) {
                if ( plana->AddressBlocks[index] != NULL ) {
                    PLIST_ENTRY Entry;

                    pab = plana->AddressBlocks[index];

                    for (Entry = pab->ReceiveDatagramList.Flink ;
                        Entry != &pab->ReceiveDatagramList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_dg_outstanding++ ;
                    }
                    for (Entry = pab->ReceiveBroadcastDatagramList.Flink ;
                        Entry != &pab->ReceiveBroadcastDatagramList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_dg_outstanding++ ;
                    }
                    for (Entry = pab->ReceiveAnyList.Flink ;
                        Entry != &pab->ReceiveAnyList ;
                        Entry = Entry->Flink) {
                        pSessionHeader->rcv_any_outstanding++;
                    }
                }
            }

            pSessionHeader->sess_name = MAXIMUM_ADDRESS;

        } else {
            PLIST_ENTRY Entry;
            PAB pab255;

            //  Add entries for this name alone.
            for (Entry = pab->ReceiveDatagramList.Flink ;
                Entry != &pab->ReceiveDatagramList ;
                Entry = Entry->Flink) {
                pSessionHeader->rcv_dg_outstanding++ ;
            }
            pab255 = plana->AddressBlocks[MAXIMUM_ADDRESS];
            for (Entry = pab255->ReceiveBroadcastDatagramList.Flink ;
                Entry != &pab255->ReceiveBroadcastDatagramList ;
                Entry = Entry->Flink) {
                PDNCB pdncbEntry = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                if ( pdncbEntry->ncb_num == pab->NameNumber ) {
                    pSessionHeader->rcv_dg_outstanding++ ;
                }
            }
            for (Entry = pab->ReceiveAnyList.Flink ;
                Entry != &pab->ReceiveAnyList ;
                Entry = Entry->Flink) {
                pSessionHeader->rcv_any_outstanding++;
            }
            pSessionHeader->sess_name = pab->NameNumber;
        }

        LengthRemaining = Buffer2Length - sizeof(SESSION_HEADER);
        pSessionBuffer = (PUSESSION_BUFFER)( pSessionHeader+1 );

        for ( index=1 ; index <= MAXIMUM_CONNECTION; index++ ) {
            CopySessionStatus( pdncb,
                plana->ConnectionBlocks[index],
                pSessionHeader,
                &pSessionBuffer,
                &LengthRemaining);

        }

        /*        Undocumented Netbios 3.0 feature, returned length == requested
                  length and not the length of data returned. The following
                  expression gives the number of bytes actually used.
        pdncb->ncb_length = (USHORT)
                            (sizeof(SESSION_HEADER)+
                            (sizeof(SESSION_BUFFER) * pSessionHeader->num_sess));
        */

        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_GOODRET );

    } else {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( IrpSp );

}

VOID
CopySessionStatus(
    IN PDNCB pdncb,
    IN PCB pcb,
    IN PUSESSION_HEADER pSessionHeader,
    IN PUSESSION_BUFFER* ppSessionBuffer,
    IN PULONG pLengthRemaining
    )
/*++

Routine Description:

    This routine is called to determine if a session should be added
    to the callers buffer and if so it fills in the data. If there is an
    error it records the problem in the callers NCB.

Arguments:

    pdncb - Pointer to the NCB.

    pcb - Connection Block for a particular session

    pSessionHeader - Start of the callers buffer

    ppSessionBuffer - Next position to fill in inside the users buffer.

    pLengthRemaining - size in bytes remaining to be filled.

Return Value:

    none.

--*/
{
    PAB pab;
    PLIST_ENTRY Entry;

    if ( pcb == NULL ) {
        return;
    }

    pab = *(pcb->ppab);

    if (( pdncb->ncb_name[0] == '*') ||
        (RtlEqualMemory( &pab->Name, pdncb->ncb_name, NCBNAMSZ))) {

        pSessionHeader->num_sess++;

        if ( *pLengthRemaining < sizeof(SESSION_BUFFER) ) {
            NCB_COMPLETE( pdncb, NRC_INCOMP );
            return;
        }

        (*ppSessionBuffer)->lsn = pcb->SessionNumber;
        (*ppSessionBuffer)->state = pcb->Status;
        RtlMoveMemory((*ppSessionBuffer)->local_name, &pab->Name, NCBNAMSZ);
        RtlMoveMemory((*ppSessionBuffer)->remote_name, &pcb->RemoteName, NCBNAMSZ);

        (*ppSessionBuffer)->sends_outstanding = 0;
        (*ppSessionBuffer)->rcvs_outstanding = 0;

        for (Entry = pcb->SendList.Flink ;
             Entry != &pcb->SendList ;
             Entry = Entry->Flink) {
            (*ppSessionBuffer)->sends_outstanding++;
        }

        for (Entry = pcb->ReceiveList.Flink ;
             Entry != &pcb->ReceiveList ;
             Entry = Entry->Flink) {
            (*ppSessionBuffer)->rcvs_outstanding++;
        }

        *ppSessionBuffer +=1;
        *pLengthRemaining -= sizeof(SESSION_BUFFER);

    }

}

NTSTATUS
NbEnum(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to discover the available lana numbers.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Buffer2;
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    PAGED_CODE();

    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        Buffer2 = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                    NormalPagePriority);
        if (Buffer2 == NULL) {
            Buffer2Length = 0;
        }
    } else {

        //
        //  Either a zero byte read/write or the request only has an NCB.
        //

        Buffer2 = NULL;
        Buffer2Length = 0;
    }


    //
    // For PNP
    //

    LOCK_RESOURCE( pfcb );

    //  Copy over as much information as the user allows.

    if ( (ULONG)pfcb->LanaEnum.length + 1 > Buffer2Length ) {
        if ( Buffer2Length > 0 ) {
            RtlMoveMemory( Buffer2, &pfcb->LanaEnum, Buffer2Length);
        }
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
    } else {
        RtlMoveMemory(
            Buffer2,
            &pfcb->LanaEnum,
            (ULONG)pfcb->LanaEnum.length + 1 );

        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    UNLOCK_RESOURCE( pfcb );

    return Status;

}

NTSTATUS
NbReset(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to reset an adapter. Until an adapter is reset,
    no access to the lan is allowed.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;

    BOOLEAN bCleanupLana = FALSE;


    PAGED_CODE();

    IF_NBDBG (NB_DEBUG_FILE | NB_DEBUG_CREATE_FILE) {
        NbPrint(( "\n**** RRRRRRRRESETT ***** LANA : %x, pdncb %lx\n",
                   pdncb-> ncb_lana_num, pdncb ));
        NbPrint(( "FCB : %lx\n", pfcb ));
    }

    LOCK_RESOURCE( pfcb );

    // MaxLana is really the last assigned lana number hence > not >=
    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK_RESOURCE( pfcb );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    if ( pfcb->ppLana[pdncb->ncb_lana_num] != NULL ) {
        bCleanupLana = TRUE;
    }

    UNLOCK_RESOURCE( pfcb );


    //
    //  Wait till all addnames are completed and prevent any new
    //  ones while we reset the lana. Note We lock out addnames for all
    //  lanas. This is ok since addnames are pretty rare as are resets.
    //

    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite( &pfcb->AddResource, TRUE);

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\nNbReset have resource exclusive\n" ));
    }

    if ( bCleanupLana ) {
        CleanupLana( pfcb, pdncb->ncb_lana_num, TRUE);
    }

    if ( pdncb->ncb_lsn == 0 ) {
        //  Allocate resources
        OpenLana( pdncb, Irp, IrpSp );
    } else {
        NCB_COMPLETE( pdncb, NRC_GOODRET );
    }

    //  Allow more addnames
    ExReleaseResourceLite( &pfcb->AddResource );

    KeLeaveCriticalRegion();

    return STATUS_SUCCESS;
}

NTSTATUS
NbAction(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to access a transport specific extension. Netbios does not know
    anything about what the extension does.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbAction ****** pdncb %lx\n", pdncb ));
    }

    //
    //  The operation can only be performed on one handle so if the NCB specifies both
    //  a connection and an address then reject the request.
    //

    if (( pdncb->ncb_lsn != 0) &&
        ( pdncb->ncb_num != 0)) {
        NCB_COMPLETE( pdncb, NRC_ILLCMD );  //  No really good errorcode for this
        return STATUS_SUCCESS;
    }

    if ( pdncb->ncb_length < sizeof(ACTION_HEADER) ) {
        NCB_COMPLETE( pdncb, NRC_BUFLEN );
        return STATUS_SUCCESS;
    }

    if ( (ULONG_PTR)pdncb->ncb_buffer & 3 ) {
        NCB_COMPLETE( pdncb, NRC_BADDR ); // Buffer not word aligned
        return STATUS_SUCCESS;
    }

    LOCK( pfcb, OldIrql );

    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    if ( pdncb->ncb_lsn != 0) {
        //  Use handle associated with this connection
        PPCB ppcb;

        ppcb = FindCb( pfcb, pdncb, FALSE);

        if ( ppcb == NULL ) {
            //  FindCb has put the error in the NCB
            UNLOCK( pfcb, OldIrql );
            if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
                //  Tell dll to hangup the connection.
                return STATUS_HANGUP_REQUIRED;
            } else {
                return STATUS_SUCCESS;
            }
        }
        pcb = *ppcb;

        if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_SCLOSED );
            return STATUS_SUCCESS;
        }

        TdiBuildAction (Irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = pcb->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit connection: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;
    } else if ( pdncb->ncb_num != 0) {
        //  Use handle associated with this name
        PPAB ppab;
        PAB pab;

        ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num  );

        if ( ppab == NULL ) {
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }
        pab = *ppab;

        TdiBuildAction (Irp,
            pab->DeviceObject,
            pab->AddressObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = pab->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit address: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;

    } else {
        //  Use the control channel
        PLANA_INFO plana;

        if (( pdncb->ncb_lana_num > pfcb->MaxLana ) ||
            ( pfcb == NULL ) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num] == NULL) ||
            ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
            UNLOCK( pfcb, OldIrql );
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
            return STATUS_SUCCESS;
        }

        plana = pfcb->ppLana[pdncb->ncb_lana_num];

        TdiBuildAction (Irp,
            plana->ControlDeviceObject,
            plana->ControlFileObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress);

        DeviceObject = plana->ControlDeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoMarkIrpPending( Irp );
        IoCallDriver (DeviceObject, Irp);

        IF_NBDBG (NB_DEBUG_ACTION) {
            NbPrint(( "NB ACTION submit control: %X\n", Irp->IoStatus.Status  ));
        }

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //

        return STATUS_PENDING;
    }

}

NTSTATUS
NbCancel(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    This routine is called to cancel the ncb pointed to by NCB_BUFFER.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PDNCB target;   // Mapped in location of the USERS NCB. Not the drivers copy of the DNCB!
    BOOL SpinLockHeld;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint(( "\n****** Start of NbCancel ****** pdncb %lx\n", pdncb ));
    }


    LOCK( pfcb, OldIrql );
    SpinLockHeld = TRUE;

    if ( pdncb->ncb_lana_num > pfcb->MaxLana) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }


    if (( pfcb->ppLana[pdncb->ncb_lana_num] == NULL ) ||
        ( pfcb->ppLana[pdncb->ncb_lana_num]->Status != NB_INITIALIZED) ) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_BRIDGE );
        return STATUS_SUCCESS;
    }


    //
    //  Map the users buffer so we can poke around inside
    //

    if (Irp->MdlAddress) {
        target = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
    }

    if ((Irp->MdlAddress == NULL) ||
        (target == NULL )) {
        ASSERT(FALSE);
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_CANOCCR );
        return STATUS_SUCCESS;
    }

    IF_NBDBG (NB_DEBUG_CALL) {
        NbDisplayNcb( target );
    }

    try {
        if ( target->ncb_lana_num == pdncb->ncb_lana_num ) {
            switch ( target->ncb_command & ~ASYNCH ) {

            case NCBCALL:
            case NCALLNIU:
            case NCBLISTEN:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {

                    PPCB ppcb;
                    UCHAR ucLana;

                    UNLOCK_SPINLOCK(pfcb, OldIrql);
                    SpinLockHeld = FALSE;

                    //
                    // Probe the NCB buffer
                    //

                    if (ExGetPreviousMode() != KernelMode) {
                        ProbeForRead(pdncb->ncb_buffer, sizeof(NCB), 4);
                    }


                    //
                    // Get the Lana number for the NCB being cancelled
                    // This is to prevent dereferencing the user buffer
                    // once the spinlock has been taken (bug #340218)
                    //

                    ucLana = ((PNCB)(pdncb->ncb_buffer))->ncb_lana_num;

                    LOCK_SPINLOCK(pfcb, OldIrql);
                    SpinLockHeld = TRUE;

                    //
                    //  Search for the correct ppcb. We cannot use FindCb
                    //  because the I/O system will not copy back the ncb_lsn
                    //  field into target until the I/O request completes.
                    //

                    //
                    // Note : Though we are passing in the user buffer to
                    // the following routine, the buffer is never dereferenced
                    // in the routine.  It is passed in only for address comp.
                    // and should not result in a pagefault ever, (with the
                    // spinlock held)
                    //

                    ppcb = FindCallCb( pfcb, (PNCB)pdncb->ncb_buffer, ucLana);

                    if (( ppcb == NULL ) ||
                        ((*ppcb)->pdncbCall->ncb_cmd_cplt != NRC_PENDING ) ||
                        (( (*ppcb)->Status != CALL_PENDING ) &&
                         ( (*ppcb)->Status != LISTEN_OUTSTANDING ))) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                    } else {
                        NCB_COMPLETE( (*ppcb)->pdncbCall, NRC_CMDCAN );
                        SpinLockHeld = FALSE;
                        (*ppcb)->DisconnectReported = TRUE;
                        UNLOCK_SPINLOCK( pfcb, OldIrql );
                        CleanupCb( ppcb, NULL );
                        NCB_COMPLETE( pdncb, NRC_GOODRET );
                    }
                }
                break;

            case NCBHANGUP:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                        PPCB ppcb = FindCb( pfcb, target, FALSE );
                        if (( ppcb != NULL ) &&
                            ((*ppcb)->Status == HANGUP_PENDING )) {
                            PDNCB pdncbHangup;
                            //  Restore the session status and remove the hangup.
                            (*ppcb)->Status = SESSION_ESTABLISHED;
                            pdncbHangup = (*ppcb)->pdncbHangup;
                            (*ppcb)->pdncbHangup = NULL;
                            if ( pdncbHangup != NULL ) {
                                NCB_COMPLETE( pdncbHangup, NRC_CMDCAN );
                                pdncbHangup->irp->IoStatus.Information =
                                    FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                                NbCompleteRequest( pdncbHangup->irp ,STATUS_SUCCESS);
                            }
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                        } else {
                            //  Doesn't look like this is a real hangup so refuse.
                            NCB_COMPLETE( pdncb, NRC_CANCEL );
                        }
                }
                break;

            case NCBASTAT:
                NCB_COMPLETE( pdncb, NRC_CANOCCR );
                break;

            case NCBLANSTALERT:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    CancelLanAlert( pfcb, pdncb );
                }
                break;

            case NCBRECVANY:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, target->ncb_num );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveAnyList.Flink ;
                         Entry != &(*ppab)->ReceiveAnyList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            case NCBDGRECV:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, target->ncb_num );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveDatagramList.Flink ;
                         Entry != &(*ppab)->ReceiveDatagramList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            case NCBDGRECVBC:
                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPAB ppab;
                    PLIST_ENTRY Entry;

                    ppab = FindAbUsingNum( pfcb, target, MAXIMUM_ADDRESS );

                    if ( ppab == NULL ) {
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        break;
                    }

                    for (Entry = (*ppab)->ReceiveBroadcastDatagramList.Flink ;
                         Entry != &(*ppab)->ReceiveBroadcastDatagramList;
                         Entry = Entry->Flink) {

                        PDNCB pReceive = CONTAINING_RECORD( Entry, DNCB, ncb_next);

                        if ( pReceive->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                            PIRP Irp;

                            RemoveEntryList( &pReceive->ncb_next );

                            SpinLockHeld = FALSE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );

                            Irp = pReceive->irp;

                            IoAcquireCancelSpinLock(&Irp->CancelIrql);

                            //
                            //  Remove the cancel request for this IRP. If its cancelled then its
                            //  ok to just process it because we will be returning it to the caller.
                            //

                            Irp->Cancel = FALSE;

                            IoSetCancelRoutine(Irp, NULL);

                            IoReleaseCancelSpinLock(Irp->CancelIrql);

                            NCB_COMPLETE( pReceive, NRC_CMDCAN );
                            Irp->IoStatus.Status = STATUS_SUCCESS,
                            Irp->IoStatus.Information =
                                FIELD_OFFSET( DNCB, ncb_cmd_cplt );
                            NbCompleteRequest( Irp, STATUS_SUCCESS );

                            //  The receive is cancelled, complete the cancel
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                            break;
                        }

                    }

                    //  Command not in receive list!
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );

                }
                break;

            //  Session cancels close the connection.

            case NCBRECV:
            case NCBSEND:
            case NCBSENDNA:
            case NCBCHAINSEND:
            case NCBCHAINSENDNA:

                if ( target->ncb_cmd_cplt != NRC_PENDING ) {
                    NCB_COMPLETE( pdncb, NRC_CANOCCR );
                } else {
                    PPCB ppcb;
                    ppcb = FindCb( pfcb, target, FALSE);
                    if ( ppcb == NULL ) {
                        //  No such connection
                        NCB_COMPLETE( pdncb, NRC_CANOCCR );
                    } else {
                        PDNCB pTarget = NULL;
                        PLIST_ENTRY Entry;
                        if ((target->ncb_command & ~ASYNCH) == NCBRECV ) {
                            for (Entry = (*ppcb)->ReceiveList.Flink ;
                                 Entry != &(*ppcb)->ReceiveList;
                                 Entry = Entry->Flink) {

                                pTarget = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                                if ( pTarget->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                                    break;
                                }
                                pTarget = NULL;

                            }
                        } else {
                            for (Entry = (*ppcb)->SendList.Flink ;
                                 Entry != &(*ppcb)->SendList;
                                 Entry = Entry->Flink) {

                                pTarget = CONTAINING_RECORD( Entry, DNCB, ncb_next);
                                if ( pTarget->users_ncb == (PNCB)pdncb->ncb_buffer ) {
                                    break;
                                }
                                pTarget = NULL;
                            }
                        }

                        if ( pTarget != NULL ) {
                            //  pTarget points to the real Netbios drivers DNCB.
                            NCB_COMPLETE( pTarget, NRC_CMDCAN );
                            SpinLockHeld = FALSE;
                            (*ppcb)->DisconnectReported = TRUE;
                            UNLOCK_SPINLOCK( pfcb, OldIrql );
                            CleanupCb( ppcb, NULL );
                            NCB_COMPLETE( pdncb, NRC_GOODRET );
                        } else {
                            NCB_COMPLETE( pdncb, NRC_CANOCCR );
                        }
                    }
                }
                break;

            default:
                NCB_COMPLETE( pdncb, NRC_CANCEL );  // Invalid command to cancel
                break;

            }
        } else {
            NCB_COMPLETE( pdncb, NRC_BRIDGE );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        if ( SpinLockHeld == TRUE ) {
            UNLOCK( pfcb, OldIrql );
        } else {
            UNLOCK_RESOURCE( pfcb );
        }

        IF_NBDBG (NB_DEBUG_DEVICE_CONTROL) {
            NTSTATUS Status = GetExceptionCode();
            NbPrint( ("NbCancel: Exception1 %X.\n", Status));
        }

        NCB_COMPLETE( pdncb, NRC_INVADDRESS );
        return STATUS_SUCCESS;
    }

    if ( SpinLockHeld == TRUE ) {
        UNLOCK( pfcb, OldIrql );
    } else {
        UNLOCK_RESOURCE( pfcb );
    }

    NCB_COMPLETE( pdncb, NRC_GOODRET );

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER( Irp );
}

VOID
QueueRequest(
    IN PLIST_ENTRY List,
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PFCB pfcb,
    IN KIRQL OldIrql,
    IN BOOLEAN Head)
/*++

Routine Description:

    This routine is called to add a dncb to List.

    Note: QueueRequest UNLOCKS the fcb. This means the resource and
    spinlock are owned when this routine is called.

Arguments:

    List - List of pdncb's.

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    pfcb & OldIrql - Used to free locks

    Head - TRUE if pdncb should be inserted at head of list

Return Value:

    None.

--*/

{

    pdncb->irp = Irp;

    pdncb->pfcb = pfcb;

    IoMarkIrpPending( Irp );

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    if ( Head == FALSE ) {
        InsertTailList(List, &pdncb->ncb_next);
    } else {
        InsertHeadList(List, &pdncb->ncb_next);
    }

    if (Irp->Cancel) {

        //
        //  CancelRoutine will lock the resource & spinlock and try to find the
        //  request from scratch. It may fail to find the request if it has
        //  been picked up by an indication from the transport.
        //

        UNLOCK( pfcb, OldIrql );

        CancelRoutine (NULL, Irp);

    } else {

        IoSetCancelRoutine(Irp, CancelRoutine);

        IoReleaseCancelSpinLock (Irp->CancelIrql);

        UNLOCK( pfcb, OldIrql );
    }

}

PDNCB
DequeueRequest(
    IN PLIST_ENTRY List
    )
/*++

Routine Description:

    This routine is called to remove a dncb from List.

    Assume fcb spinlock held.

Arguments:

    List - List of pdncb's.

Return Value:

    PDNCB or NULL.

--*/
{
    PIRP Irp;
    PDNCB pdncb;
    PLIST_ENTRY ReceiveEntry;

    if (IsListEmpty(List)) {
        //
        //  There are no waiting request announcement FsControls, so
        //  return success.
        //

        return NULL;
    }

    ReceiveEntry = RemoveHeadList( List);

    pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

    Irp = pdncb->irp;

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    //
    //  Remove the cancel request for this IRP. If its cancelled then its
    //  ok to just process it because we will be returning it to the caller.
    //

    Irp->Cancel = FALSE;

    IoSetCancelRoutine(Irp, NULL);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    return pdncb;

}

VOID
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the IO system wants to cancel a queued
    request. The netbios driver queues LanAlerts, Receives and Receive
    Datagrams

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Ignored.
    IN PIRP Irp - Irp to cancel.

Return Value:

    None

--*/

{
    PFCB pfcb;
    PDNCB pdncb;
    DNCB LocalCopy;
    PLIST_ENTRY List = NULL;
    PPAB ppab;
    PPCB ppcb;
    PFILE_OBJECT FileObject;
    KIRQL OldIrql;

    //
    //  Clear the cancel routine from the IRP - It can't be cancelled anymore.
    //

    IoSetCancelRoutine(Irp, NULL);

    //
    //  Remove all the info from the pdncb that we will need to find the
    //  request. Once we release the cancel spinlock this request could be
    //  completed by another action so it is possible that we will not find
    //  the request to cancel.
    //

    pdncb = Irp->AssociatedIrp.SystemBuffer;

    RtlMoveMemory( &LocalCopy, pdncb, sizeof( DNCB ) );
    IF_NBDBG (NB_DEBUG_IOCANCEL) {
        NbPrint(( "IoCancel Irp %lx\n", Irp ));
        NbDisplayNcb(&LocalCopy);
    }

#if DBG
#ifdef _WIN64
    pdncb = (PDNCB)0xDEADBEEFDEADBEEF;
#else
    pdncb = (PDNCB)0xDEADBEEF;
#endif
#endif

    pfcb = LocalCopy.pfcb;

    //
    //  Reference the FileObject associated with this Irp. This will stop
    //  the callers handle to \device\netbios from closing and therefore
    //  the fcb will not get deleted while we try to lock the fcb.
    //
    FileObject = (IoGetCurrentIrpStackLocation (Irp))->FileObject;
    ObReferenceObject(FileObject);
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    LOCK( pfcb, OldIrql );
    //
    //  We now have exclusive access to all CB's and AB's with their associated
    //  lists.
    //

    switch ( LocalCopy.ncb_command & ~ASYNCH ) {
    case NCBRECV:

        ppcb = FindCb( pfcb, &LocalCopy, TRUE);
        if ( ppcb != NULL ) {
            List = &(*ppcb)->ReceiveList;
        }
        break;

    case NCBRECVANY:
        ppab = FindAbUsingNum( pfcb, &LocalCopy, LocalCopy.ncb_num );
        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveAnyList;
        }
        break;

    case NCBDGRECVBC:
        ppab = FindAbUsingNum( pfcb, &LocalCopy, MAXIMUM_ADDRESS  );

        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveBroadcastDatagramList;
        }
        break;

    case NCBDGRECV:

        ppab = FindAbUsingNum( pfcb, &LocalCopy, LocalCopy.ncb_num );

        if ( ppab != NULL ) {
            List = &(*ppab)->ReceiveDatagramList;
        }
        break;

    case NCBLANSTALERT:
        List = &(pfcb->ppLana[LocalCopy.ncb_lana_num]->LanAlertList);
        break;

    }


    if ( List != NULL ) {

        //
        //  We have a list to scan for canceled pdncb's
        //

        PLIST_ENTRY Entry;

RestartScan:

        for (Entry = List->Flink ;
             Entry != List ;
             Entry = Entry->Flink) {

            PDNCB p = CONTAINING_RECORD( Entry, DNCB, ncb_next);

            IoAcquireCancelSpinLock( &p->irp->CancelIrql );

            if ( p->irp->Cancel ) {

                RemoveEntryList( &p->ncb_next );

                NCB_COMPLETE( p, NRC_CMDCAN );

                p->irp->IoStatus.Status = STATUS_SUCCESS;
                p->irp->IoStatus.Information =
                    FIELD_OFFSET( DNCB, ncb_cmd_cplt );

                IoSetCancelRoutine( p->irp, NULL );

                IoReleaseCancelSpinLock( p->irp->CancelIrql );

                IoCompleteRequest( p->irp, IO_NETWORK_INCREMENT);
                goto RestartScan;
            }

            IoReleaseCancelSpinLock( p->irp->CancelIrql );
        }
    }

    UNLOCK( pfcb, OldIrql );
    ObDereferenceObject(FileObject);
}


NTSTATUS
AllocateAndCopyUnicodeString(
    IN  OUT PUNICODE_STRING     pusDest,
    IN      PUNICODE_STRING     pusSource
)

/*++

Routine Description :
    This function allocates and copies a unicode string.


Arguements :
    pusDest : Destination that the unicode string is to be copied

    pusSource : Source string that is to be copied


Return Value :
    STATUS_SUCCESS if function is successful.

    STATUS_NO_MEMORY if function fails to allocate buffer for the dest.

Environment :

--*/

{

    PAGED_CODE();


    pusDest-> Buffer = ExAllocatePoolWithTag(
                        NonPagedPool, pusSource-> MaximumLength, 'nSBN'
                        );

    if ( pusDest-> Buffer == NULL )
    {
        return STATUS_NO_MEMORY;
    }

    pusDest-> MaximumLength = pusSource-> MaximumLength;

    RtlCopyUnicodeString( pusDest, pusSource );

    return STATUS_SUCCESS;
}



NTSTATUS
NbRegisterWait(
    IN      PIRP                pIrp
)
/*++

Routine Description :
    This function marks the specified IRP as pending and inserts it into
    the global list of IRP that are waiting for stop notification.  These
    IRPs will be completed when netbios is being stopped.
    N.B : NbStop


Arguements :
    pIrp :  IRP that needs to be pending until netbios is being stopped


Return value :


Environment :
    This function is invoked in response to a IOCTL_NB_REGISTER sent down
    by a user mode component.  Acquires/releases the CancelSpinLock and
    g_keStopLock.

--*/
{

    KIRQL   irql;

    NTSTATUS status;


    LOCK_STOP();

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: ENTERED NbRegisterWait, Stop status %d, "
                  "Num Opens %d\n", g_dwNetbiosState, g_ulNumOpens ) );
    }


    if ( g_dwNetbiosState == NETBIOS_STOPPING )
    {
        //
        // Netbios is shutting down, complete this IRP, right away
        //

        status = STATUS_SUCCESS;
    }

    else
    {
        //
        // setup the cancellation routine and pend this IRP
        //

        IoAcquireCancelSpinLock( &irql );

        IoMarkIrpPending( pIrp );

        InsertTailList( &g_leWaitList, &(pIrp->Tail.Overlay.ListEntry) );

        IoSetCancelRoutine( pIrp, CancelIrp );

        IoReleaseCancelSpinLock( irql );

        status = STATUS_PENDING;
    }

    UNLOCK_STOP();

    return status;
}


VOID
CancelIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)

/*++

Routine Description :
    This function cancels an IRP that has been pended on behalf of a
    user mode process.  This is invoked when the user-mode process
    the had an open FileHandle to this device closes the handle.

Arguments :
    DeviceObject : DeviceObject correponding to the Filehandle that was closed

    Irp : Pended Irp that is being cancelled.

Return Value :


Environment :
    Invoked by the IO subsystem when an open Filehandle to \\Device\netbios is
    closed.  This is invoked while holding the CancelSpinLock.

--*/
{
    //
    // Mark this Irp as cancelled
    //

    Irp->IoStatus.Status        = STATUS_CANCELLED;
    Irp->IoStatus.Information   = 0;

    //
    // Take off our own list
    //

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // Release cancel spin lock which the IO system acquired
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
}



NTSTATUS
NbStop(
)

/*++

Routine Description :

    This function initiates the process of stopping the netbios driver.
    It does this by completing the pending stop-notification IRPs.  The
    user mode components (netapi32.dll) which have open file handles are
    expected to close these handles when the pending IRPs have been
    completed.  After completing the IRPs this function waits for
    all the open handles to be closed.

Arguments :

Return Value :
    STATUS_SUCCESS if all the handles were closed, STATUS_TIMEOUT if
    the wait timed out.

Environment :

    This function is invoked from Services.exe when the netbios driver
    is to be stopped.  This is special case behavior for netbios.
    This function acquires (and releases) the global lock g_erStopLock
    and the CancelSpinLock

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIRP pIrp;

    BOOLEAN bWait = FALSE ;

    DWORD dwTimeOut = 10000 * 1000 * 15;

    LARGE_INTEGER TimeOut;

    KIRQL irql;

    PLIST_ENTRY  pleNode;

#if AUTO_RESET

    PLIST_ENTRY ple;

    PFCB_ENTRY  pfe;

    PNCB        pUsersNCB;
#endif

    //
    // Acquire the lock protecting stop related data.
    //

    LOCK_STOP();

    //
    // Decrement Num Opens, since an extra open has been performed to
    // send the stop IOCTL
    //

    g_ulNumOpens--;


    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: ENTERED NbStop, Stop status %d, "
                  "Num Opens %d\n", g_dwNetbiosState, g_ulNumOpens ) );
    }

    //
    // set netbios state to stopping
    //

    g_dwNetbiosState = NETBIOS_STOPPING;

    if ( g_ulNumOpens )
    {
        //
        // if there are open file handles to \\Device\Netbios,
        // wait for them to close
        //

        bWait = TRUE;
    }


#if AUTO_RESET

    LOCK_GLOBAL();

#endif

    //
    // Complete each of the pending IRPs to signal the stop event.
    // This causes netapi32.dll to close the open handles
    //

    IoAcquireCancelSpinLock( &irql );

    while ( !IsListEmpty( &g_leWaitList ) )
    {
        pleNode = RemoveHeadList( &g_leWaitList );

        pIrp = CONTAINING_RECORD( pleNode, IRP, Tail.Overlay.ListEntry );

        IoSetCancelRoutine( pIrp, NULL );

        pIrp->IoStatus.Status       = STATUS_NO_SUCH_DEVICE;
        pIrp->IoStatus.Information  = 0;


        //
        // release lock to complete the IRP
        //

        IoReleaseCancelSpinLock( irql );

        IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );


        //
        // Reaquire the lock
        //

        IoAcquireCancelSpinLock(&irql);
    }

#if AUTO_RESET

    //
    // Complete IRPs that have been pended for notfication
    // of a new LANA (in case the LANA needs to be automatically
    // reset)
    //

    for ( pleNode = g_leFCBList.Flink;
          pleNode != &g_leFCBList;
          pleNode = pleNode-> Flink )
    {
        pfe = CONTAINING_RECORD( pleNode, FCB_ENTRY, leList );

        if ( !IsListEmpty( &pfe-> leResetIrp ) )
        {
            ple = RemoveHeadList( &pfe-> leResetIrp );

            pIrp = CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );

            IoSetCancelRoutine( pIrp, NULL );

            pIrp->IoStatus.Status       = STATUS_SUCCESS;

            pIrp->IoStatus.Information  = sizeof( NCB );


            //
            // Set the LANA to be reset to special value since NETBIOS
            // is stopping
            //

            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB->ncb_lana_num = MAX_LANA + 1;


            NbCheckAndCompleteIrp32(pIrp);
            //
            // release lock to complete the IRP
            //

            IoReleaseCancelSpinLock( irql );

            IoCompleteRequest( pIrp, IO_NETWORK_INCREMENT );


            //
            // Reaquire the lock
            //

            IoAcquireCancelSpinLock(&irql);
        }
    }

#endif

    IoReleaseCancelSpinLock( irql );


#if AUTO_RESET

    UNLOCK_GLOBAL();

#endif

    //
    // release stop lock
    //

    UNLOCK_STOP();


    //
    // if there are open file handles wait for them to stop
    //

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        NbPrint( ("[NETBIOS]: NbStop : Wait %d\n", bWait ) );
    }


    if ( bWait )
    {
        TimeOut.QuadPart = Int32x32To64( -1, dwTimeOut );

        do
        {
            ntStatus = KeWaitForSingleObject(
                            &g_keAllHandlesClosed, Executive, KernelMode,
                            TRUE, &TimeOut
                        );

        } while (ntStatus == STATUS_ALERTED);
    }

    IF_NBDBG( NB_DEBUG_DISPATCH )
    {
        LOCK_STOP();

        NbPrint( ("[NETBIOS]: LEAVING NbStop, Stop status %d, "
                  "Num Opens %d\n", ntStatus, g_ulNumOpens ) );

        UNLOCK_STOP();
    }

    return ntStatus;
}



#if AUTO_RESET

NTSTATUS
NbRegisterReset(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp

)
/*++

Routine Description :
    This function marks the specified IRP as pending and inserts it into
    the global FCB list.  This IRP will be completed when an adapter is bound
    to netbios, thereby notifying the user mode of a new adapter.

Arguements :
    pIrp :  IRP that needs to be pending until an adapater (LANA) is bound
            to netbios


Return value :


Environment :
    This function is invoked in response to a IOCTL_NB_REGISTER_RESET sent down
    by a user mode component.  Acquires/releases the CancelSpinLock and
    g_erGlobalLost.

--*/
{

    NTSTATUS            Status;

    PFCB                pfcb;

    PLIST_ENTRY         ple;

    PFCB_ENTRY          pfe;

    PRESET_LANA_ENTRY   prle;

    PNCB                pUsersNCB;

    KIRQL               irql;

    ULONG               RequiredLength;



    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( ("\n++++ Netbios : ENTERED NbRegisterReset : ++++\n") );
    }


    LOCK_STOP();

    do
    {
        //
        // Check if Netbios is stopping
        //

        if ( g_dwNetbiosState == NETBIOS_STOPPING )
        {
            NbPrint( ("[NETBIOS] : NbRegisterReset : Netbios is stopping\n") );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // Acquire the global lock
        //

        LOCK_GLOBAL();


        //
        // find the FCB for the user-mode application that sent down
        // the IOCTL
        //

        pfcb = pIrpSp-> FileObject-> FsContext2;

        for ( ple = g_leFCBList.Flink; ple != &g_leFCBList; ple = ple-> Flink )
        {
            pfe = CONTAINING_RECORD( ple, FCB_ENTRY, leList );

            if ( pfe-> pfcb == pfcb )
            {
                break;
            }
        }


        //
        // if the FCB is not found, print error and quit
        //

        if ( ple == &g_leFCBList )
        {
            UNLOCK_GLOBAL();

            NbPrint(
                ("[NETBIOS] : NbRegisterReset : FCB %p not found\n", pfcb )
                );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // Fix for bug 297936, buffer validation
        //
        RequiredLength = sizeof(NCB);
#if defined(_WIN64)
        if (IoIs32bitProcess(pIrp) == TRUE)
        {
            RequiredLength = sizeof(NCB32);
        }
#endif
        if (pIrpSp-> Parameters.DeviceIoControl.OutputBufferLength < RequiredLength)
        {
            UNLOCK_GLOBAL();

            NbPrint(
                ("[NETBIOS] : NbRegisterReset : Output buffer too small\n")
                );

            Status = STATUS_SUCCESS;

            break;
        }


        //
        // If there are outstanding LANA that are queued,
        // -    Remove the first one from the queue
        // -    Set the LANA in the output buffer for the IRP
        // -    complete the IRP
        //

        if ( !IsListEmpty( &pfe-> leResetList ) )
        {
            ple = RemoveHeadList( &pfe-> leResetList );

            prle = CONTAINING_RECORD( ple, RESET_LANA_ENTRY, leList );

            pUsersNCB = (PNCB) pIrp-> AssociatedIrp.SystemBuffer;
            pUsersNCB-> ncb_lana_num = prle-> ucLanaNum;
            pIrp->IoStatus.Information  = sizeof( NCB );

            ExFreePool( prle );

            Status = STATUS_SUCCESS;

            pIrp->IoStatus.Status = STATUS_SUCCESS;

            UNLOCK_GLOBAL();

            IF_NBDBG( NB_DEBUG_CREATE_FILE )
            {
                NbPrint( (
                    "FCB %p : Reset for LANA %d\n", pfcb,
                    pUsersNCB->ncb_lana_num
                    ) );
            }

            break;
        }


        //
        // No outstanding LANAs that need reseting
        // -    Acquire the Cancel spin lock
        // -    Set the Cancel Routine
        //

        IoAcquireCancelSpinLock( &irql );

        IoMarkIrpPending( pIrp );

        InsertTailList( &pfe-> leResetIrp, &(pIrp->Tail.Overlay.ListEntry) );

        IoSetCancelRoutine( pIrp, CancelIrp );

        IoReleaseCancelSpinLock( irql );

        Status = STATUS_PENDING;

        UNLOCK_GLOBAL();


    } while ( FALSE );


    UNLOCK_STOP();


    IF_NBDBG( NB_DEBUG_CREATE_FILE )
    {
        NbPrint( ("\n++++ Netbios : Exiting NbRegisterReset : %lx ++++\n", Status ) );
    }

    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nb32.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nb32.c

Abstract:

    This module contains routines to support thunking 32-bit NetBIOS IOCTLs
    on Win64.

Author:

    Samer Arafeh (SamerA) 11-June-2000

Environment:

    Kernel mode

Revision History:

--*/

#if defined(_WIN64)

#include "nb.h"



NTSTATUS
NbThunkNcb(
    IN PNCB32 Ncb32,
    OUT PDNCB Dncb)

/*++

Routine Description:

    This routine converts the input NCB structure received from the
    32-bit app, into a 64-bit compatible structure

Arguments:

    Ncb32 - Pointer to the NCB received from the 32-bit app.

    Dncb   - Pointer to the structure to receive the 64-bit NCB after
             thunking the 32-bit one.

Return Value:

    The function returns the status of the operation.

--*/
{
    Dncb->ncb_command  = Ncb32->ncb_command;
    Dncb->ncb_retcode  = Ncb32->ncb_retcode;
    Dncb->ncb_lsn      = Ncb32->ncb_lsn;
    Dncb->ncb_num      = Ncb32->ncb_num;
    Dncb->ncb_buffer   = (PUCHAR)Ncb32->ncb_buffer;
    Dncb->ncb_length   = Ncb32->ncb_length;
    
    RtlCopyMemory(Dncb->ncb_callname,
                  Ncb32->ncb_callname,
                  sizeof(Dncb->ncb_callname)) ;

    RtlCopyMemory(Dncb->ncb_name,
                  Ncb32->ncb_name,
                  sizeof(Dncb->ncb_name));

    Dncb->ncb_rto      = Ncb32->ncb_rto;
    Dncb->ncb_sto      = Ncb32->ncb_sto;
    Dncb->ncb_post     = (void (*)(struct _NCB *))
                         Ncb32->ncb_post;
    Dncb->ncb_lana_num = Ncb32->ncb_lana_num;
    Dncb->ncb_cmd_cplt = Ncb32->ncb_cmd_cplt;

    return STATUS_SUCCESS;
}


NTSTATUS
NbCompleteIrp32(
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine completes an NCB Irp if it has been received
    from a 32-bit appliation. The caller should verify that the Irp
    is coming from a 32-bit context.

Arguments:

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function returns the status of the operation.

--*/
{
    PDNCB Dncb;
    PNCB32 Ncb32;
    ULONG Count;

    
    //
    // Conver the 64-bit NCB to a 32-bit compatible NCB
    // before the IO MGR copies it back to the supplied 
    // user-mode buffer
    //
    if ((Irp->Flags & (IRP_BUFFERED_IO | IRP_INPUT_OPERATION)) == 
         (IRP_BUFFERED_IO | IRP_INPUT_OPERATION))
    {
        Dncb  = (PDNCB) Irp->AssociatedIrp.SystemBuffer;
        Ncb32 = (PNCB32) Dncb;

        if ((Irp->IoStatus.Information > 0) &&
            (!NT_ERROR(Irp->IoStatus.Status)) &&
            (InterlockedCompareExchange(&Dncb->Wow64Flags, TRUE, FALSE) == FALSE))
        {

            Ncb32->ncb_command  = Dncb->ncb_command;
            Ncb32->ncb_retcode  = Dncb->ncb_retcode;
            Ncb32->ncb_lsn      = Dncb->ncb_lsn;
            Ncb32->ncb_num      = Dncb->ncb_num;
            Ncb32->ncb_buffer   = (UCHAR * POINTER_32)PtrToUlong(Dncb->ncb_buffer);
            Ncb32->ncb_length   = Dncb->ncb_length;

            for (Count=0 ; Count<sizeof(Ncb32->ncb_callname) ; Count++)
            {
                Ncb32->ncb_callname[Count] = Dncb->ncb_callname[Count];
            }

            for (Count=0 ; Count<sizeof(Ncb32->ncb_name) ; Count++)
            {
                Ncb32->ncb_name[Count] = Dncb->ncb_name[Count];
            }

            Ncb32->ncb_rto      = Dncb->ncb_rto;
            Ncb32->ncb_sto      = Dncb->ncb_sto;
            Ncb32->ncb_post     = (void (* POINTER_32)(struct _NCB *))
                                   PtrToUlong(Dncb->ncb_post);
            Ncb32->ncb_lana_num = Dncb->ncb_lana_num;
            Ncb32->ncb_cmd_cplt = Dncb->ncb_cmd_cplt;

            Irp->IoStatus.Information = FIELD_OFFSET(NCB32, ncb_cmd_cplt);
        }
    }

    return STATUS_SUCCESS;
}



#endif  // (_WIN64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\nbtypes.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbtypes.h

Abstract:

    This module defines private data structures and types for the NT
    Netbios provider.

Author:

    Colin Watson (ColinW) 15-Mar-1991

Revision History:

--*/

#ifndef _NBTYPES_
#define _NBTYPES_

//
// Retrospective patches to netbios
//

//
// These function prototypes are declared here since they are present only
// "ntddk.h" but not in "ntifs.h", but Ke*tachProcess functions are declared only
// in "ntifs.h" and not in "ntddk.h".  The only way to get both seems to be
// this hack.  Appreciate any input on how to do this w/o re-declaring these
// functions here.
//

#ifndef _IO_

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );

#endif


//
// This structure defines a NETBIOS name as a character array for use when
// passing preformatted NETBIOS names between internal routines.  It is
// not a part of the external interface to the transport provider.
//

#define NETBIOS_NAME_SIZE 16

typedef struct _NAME {
    UCHAR InternalName[NETBIOS_NAME_SIZE];
} NAME, *PNAME;

//
// Drivers Network Control Block.
//  The NCB provided by the dll is copied into a DNCB structure. When the
//  NCB is completed, then the contents up to and including ncb_cmd_cplt
//  are copied back into the NCB provided by the application.
//

typedef struct _DNCB {

    //
    //  First part of the DNCB is identical to the Netbios 3.0 NCB without
    //  the reserved fields.
    //

    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (*ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */

    //  Start of variables that are private to the Netbios driver

    LIST_ENTRY ncb_next;            /* receive and send chain from CB */
    PIRP    irp;                    /* Irp used to provide NCB to the */
                                    /* driver                         */
    PNCB    users_ncb;              /* Users Virtual address          */
    struct _FCB* pfcb;              /* Send and Receive NCB's only    */

    UCHAR   tick_count;             /* used for ncb_rto/sto processing*/

    //  The following data structures are used for datagrams.
    TDI_CONNECTION_INFORMATION Information;
    TDI_CONNECTION_INFORMATION ReturnInformation; /* Who sent it?     */
    TA_NETBIOS_ADDRESS RemoteAddress;
    ULONG Wow64Flags;               /* Flags used to indeify whether this
                                       structure has been thunked if it
                                       came from 32-bit land */

} DNCB, *PDNCB;

#if defined(_WIN64)

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block. This is the same structure element-layout
 * as the one issued from 32-bit application.
 */
typedef struct _NCB32 {

    //
    //  First part of the DNCB is identical to the Netbios 3.0 NCB without
    //  the reserved fields.
    //

    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    UCHAR * POINTER_32  ncb_buffer; /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (* POINTER_32 ncb_post)( struct _NCB * ); /* POST routine address*/
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */

    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
    
    void * POINTER_32 ncb_event;    /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */

} NCB32, *PNCB32;

#endif

//
//  The following structure overlays ncb_callname when ncb_command is ncb_reset
//

typedef struct _RESET_PARAMETERS {
    UCHAR sessions;
    UCHAR commands;
    UCHAR names;
    UCHAR name0_reserved;
    UCHAR pad[4];
    UCHAR load_sessions;
    UCHAR load_commands;
    UCHAR load_names;
    UCHAR load_stations;
    UCHAR pad1[2];
    UCHAR load_remote_names;
    UCHAR pad2;
} RESET_PARAMETERS, *PRESET_PARAMETERS;

//
//  Address Block
//  pointed to by the Fcb for this application. One per name added due
//  to an AddName or AddGroupName
//

//  values for State field in the AB structure.

#define AB_UNIQUE  0
#define AB_GROUP   1

typedef struct _AB {
    ULONG Signature;

    //  Data items used to access transport when name was added
    HANDLE AddressHandle;
    PFILE_OBJECT AddressObject;         //  Pointer used in transport calls
    PDEVICE_OBJECT DeviceObject;        //  Pointer used in transport calls

    //  Data items used by the application to identify this Ab.
    UCHAR NameNumber;                   //  Index into AddressBlocks;
    UCHAR Status;
    UCHAR NameLength;                   //  Used when Name is for Broadcasts.
    NAME Name;                          //  our blank-padded netname
    ULONG CurrentUsers;                 //  1 for addname + n listens + m calls
    BOOL ReceiveDatagramRegistered;
    struct _LANA_INFO * pLana;
    LIST_ENTRY ReceiveAnyList;
    LIST_ENTRY ReceiveDatagramList;
    LIST_ENTRY ReceiveBroadcastDatagramList;

} AB, *PAB, **PPAB;

//
//  Connection Block
//  pointed to by the Fcb for this application. One per open connection
//  or listen.
//

typedef struct _CB {
    ULONG Signature;
    //  Data items used to access transport

    PPAB ppab;                          //  Associated address block
    HANDLE ConnectionHandle;
    PFILE_OBJECT ConnectionObject;      //  Pointer used in transport calls
    PDEVICE_OBJECT DeviceObject;        //  Pointer used in transport calls

    //  Structures used to process NCB's

    int ReceiveIndicated;
    BOOLEAN DisconnectReported;
    LIST_ENTRY ReceiveList;
    LIST_ENTRY SendList;
    NAME RemoteName;
    struct _LANA_INFO* Adapter;
    UCHAR SessionNumber;                //  Index into ConnectionBlocks;
    UCHAR Status;
    UCHAR ReceiveTimeout;               //  0 = no timeout, units=500ms
    UCHAR SendTimeout;                  //  0 = no timeout, units=500ms
    PNCB  UsersNcb;                     //  Users Virtual address used for
                                        //  the Listen or Call NCB.
    PDNCB pdncbCall;                    //  the Listen or Call DNCB.
    PDNCB pdncbHangup;

    struct _LANA_INFO * pLana;
} CB, *PCB, **PPCB;

//  Per network adapter information is held in the LAN Adapter structure

typedef struct _LANA_INFO {
    ULONG Signature;
    ULONG Status;
    PCB ConnectionBlocks[MAXIMUM_CONNECTION+1];
    PAB AddressBlocks[MAXIMUM_ADDRESS+1];   // Last entry is for broadcast name
    LIST_ENTRY LanAlertList;                // list of Alert PDNCBs

    HANDLE ControlChannel;
    PFILE_OBJECT ControlFileObject;
    PDEVICE_OBJECT ControlDeviceObject;

    //
    //  Addresses are allocated modulo 253. NextAddress is the next address to start
    //  looking for an unused name number. AddressCount is the number of names in use.
    //  MaximumAddress is tha limit set when the adapter was reset.
    //

    int NextAddress;
    int AddressCount;
    int MaximumAddresses;

    //
    //  Connections are allocated modulo 254. NextConnection is the next LSN to start
    //  looking for an unused number. ConnectionCount is the number of LSNs in use.
    //  MaximumConnection is tha limit set when the adapter was reset.
    //

    int NextConnection;
    int ConnectionCount;
    int MaximumConnection;

    struct _FCB* pFcb;

} LANA_INFO, *PLANA_INFO;


typedef struct _DEVICE_CONTEXT {
    DEVICE_OBJECT DeviceObject;         //  The IO systems device object.
    BOOLEAN Initialized;                //  TRUE iff NB init succeeded.
    UNICODE_STRING RegistryPath;        //  Netbios node in registry.
} DEVICE_CONTEXT, *PDEVICE_CONTEXT;


//
//  File Control Block
//  pointed to by FsContext2 in the FileObject associated with the
//  applications handle. LANA_INFO structures will be created as the
//  application supplies different ncb_lana numbers in NCBs. Initially
//  they are all NULL.
//

typedef struct _FCB {
    ULONG Signature;
    ERESOURCE Resource;                 //  Prevents two requests from
                                        //  corrupting the drivers data
                                        //  structures.
    KSPIN_LOCK SpinLock;                //  locks out indication routines.
    ERESOURCE AddResource;              //  Prevents a reset while an addname
                                        //  is in progress. Always acquire
                                        //  AddResource before Resource.
    ULONG MaxLana;
    PLANA_INFO *ppLana;
    LANA_ENUM LanaEnum;                 //  Win32 Netbios 3.0 structure.
    PUNICODE_STRING pDriverName;        // Device\Nbf\Elnkii1 etc
    PUCHAR RegistrySpace;               //  Registry.c workspace

    //  Timer related datastructures.

    PKEVENT TimerCancelled;             //  Used when exiting the driver.
    BOOLEAN TimerRunning;
    KTIMER Timer;                       // kernel timer for this request.
    KDPC Dpc;                           // DPC object for timeouts.

    PIO_WORKITEM WorkEntry;             // used for timeouts.

} FCB, *PFCB;


typedef struct _TA_ADDRESS_NETONE {
    int TAAddressCount;
    struct _NetoneAddr {
        USHORT AddressLength;       // length in bytes of this address == 22
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_NETONE
        TDI_ADDRESS_NETONE Address[1];
    } Address [1];
} TA_NETONE_ADDRESS, *PTA_NETONE_ADDRESS;

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;


//
// structure of each element in global list of FCBs
//

#if AUTO_RESET

typedef struct _FCB_ENTRY {
    LIST_ENTRY          leList;
    LIST_ENTRY          leResetList;
    PFCB                pfcb;
    PEPROCESS           peProcess;
    LIST_ENTRY          leResetIrp;

} FCB_ENTRY, *PFCB_ENTRY;


//
// structure with LANA number to be reset
//

typedef struct _RESET_LANA_ENTRY {
    LIST_ENTRY          leList;
    UCHAR               ucLanaNum;
} RESET_LANA_ENTRY, *PRESET_LANA_ENTRY;

#else

typedef struct _FCB_ENTRY {
    LIST_ENTRY          leList;
    PFCB                pfcb;
    PEPROCESS           peProcess;

} FCB_ENTRY, *PFCB_ENTRY;

#endif

#endif // def _NBTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\receive.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains code which processes all read NCB's including
    both session and datagram based transfers.

Author:

    Colin Watson (ColinW) 13-Mar-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

PDNCB
FindReceive (
    IN PCB pcb
    );

VOID
ReturnDatagram(
    IN PAB pab,
    IN PVOID SourceAddress,
    IN PDNCB pdncb,
    IN BOOL MultipleReceive
    );

NTSTATUS
NbCompletionBroadcast(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbReceive(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length,
    IN BOOLEAN Locked,
    IN KIRQL LockedIrql
    )
/*++

Routine Description:

    This routine is called to read a buffer of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

    Locked - TRUE if the spinlock is already held.

    LockedIrql - OldIrql if Locked == TRUE.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    NTSTATUS Status;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    if ( Locked != TRUE ) {
        LOCK( pfcb, OldIrql );
    } else {
        OldIrql = LockedIrql;
    }

    ppcb = FindCb( pfcb, pdncb, FALSE);

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    if ( ppcb == NULL ) {
        //  FindCb has put the error in the NCB

        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive on invalid connection\n" ));
        }

        if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
            //  Tell dll to hangup the connection.
            return STATUS_HANGUP_REQUIRED;
        } else {
            return STATUS_SUCCESS;
        }
    }
    pcb = *ppcb;
    pdncb->tick_count = pcb->ReceiveTimeout;

    if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {

        UNLOCK( pfcb, OldIrql );

        NCB_COMPLETE( pdncb, NRC_SCLOSED );
        return STATUS_SUCCESS;
    }

    if ( pcb->ReceiveIndicated == 0 ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive, queue receive pcb: %lx, pdncb: %lx\n", pcb, pdncb ));
        }

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&pcb->ReceiveList, pdncb, Irp, pfcb, OldIrql, FALSE);

    } else {
        PDEVICE_OBJECT DeviceObject;

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive, submit receive pcb: %lx, pdncb: %lx\n", pcb, pdncb ));
        }

        IoMarkIrpPending( Irp );

        pcb->ReceiveIndicated = 0;

        TdiBuildReceive (Irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            Irp->MdlAddress,
            0,
            Buffer2Length);

        //  Save the DeviceObject before pcb gets released by UNLOCK

        DeviceObject = pcb->DeviceObject;

        UNLOCK( pfcb, OldIrql );

        IoCallDriver (DeviceObject, Irp);

        //
        //  Transport will complete the request. Return pending so that
        //  netbios does not complete as well.
        //
    }

    Status = STATUS_PENDING;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive: %X, %X\n", Status, Irp->IoStatus.Status ));
    }

    return Status;
    UNREFERENCED_PARAMETER( Buffer2Length );
}

NTSTATUS
NbReceiveAny(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to read a buffer of data from any session on
    a particular address, provided there is not a read on that address
    already.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPCB ppcb;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num );

    if ( ppab == NULL ) {
        UNLOCK( pfcb, OldIrql );
        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive any on invalid connection\n" ));
        }
        return STATUS_SUCCESS;
    }

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    //
    //  If there is already a receive any on the address block then add
    //  this request to the tail of the queue. If the list is empty then
    //  look for a connection on this address flagged as having a receive
    //  indicated. Either queue the request if there are no indications or
    //  satisfy the indicated receive any with this request.
    //

    if ( !IsListEmpty( &(*ppab)->ReceiveAnyList )) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "NB receive any with receive any list non empty\n" ));
            ppcb = FindReceiveIndicated( pfcb, pdncb, ppab );
            if ( ppcb != NULL ) {
                NbPrint(( " ppcb: %lx has a receive indicated( %lx )!\n",
                    ppcb,
                    (*ppcb)->ReceiveIndicated));
                ASSERT( FALSE );
            }
        }

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&(*ppab)->ReceiveAnyList, pdncb, Irp, pfcb, OldIrql, FALSE);

        return STATUS_PENDING;
    }

    //
    //  Find either a connection with a receive indicated or one that has been
    //  disconnected but not reported yet.
    //

    ppcb = FindReceiveIndicated( pfcb, pdncb, ppab );

    if ( ppcb == NULL ) {
        //  No connections with receive indications set.

        //  Note: QueueRequest UNLOCKS the fcb.
        QueueRequest(&(*ppab)->ReceiveAnyList, pdncb, Irp, pfcb, OldIrql, FALSE);

        return STATUS_PENDING;
    } else {
        //  FindReceiveIndicated has set the LSN appropriately in the NCB

        //  Note : NbReceive will unlock the spinlock & resource
        return NbReceive( pdncb, Irp, IrpSp, Buffer2Length, TRUE, OldIrql );

    }
}

NTSTATUS
NbTdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an NCB arrives from the network, it will look for a
    connection for this address with an appropriate read outstanding.
    The connection that has the read associated with it is indicated by the
    context parameter.

    If it finds an appropriate read it processes the NCB.

Arguments:

    IN PVOID ReceiveEventContext - Context provided for this event - pab
    IN PVOID ConnectionContext  - Connection Context - pcb
    IN USHORT ReceiveFlags      - Flags describing the message
    IN ULONG BytesIndicated     - Number of bytes available at indication time
    IN ULONG BytesAvailable     - Number of bytes available to receive
    OUT PULONG BytesTaken       - Number of bytes consumed by redirector.
    IN PVOID Tsdu               - Data from remote machine.
    OUT PIRP *IoRequestPacket   - I/O request packet filled in if received data


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PCB pcb = *(PPCB)ConnectionContext;
    PAB pab = *(pcb->ppab);
    PFCB pfcb = pab->pLana->pFcb;
    PDNCB pdncb;

    *IoRequestPacket = NULL;

    LOCK_SPINLOCK( pfcb, OldIrql );

    if (( pcb == NULL ) ||
        ( pcb->Status != SESSION_ESTABLISHED )) {

        //
        //  The receive indication came in after we had an
        //  allocation error on the Irp to be used for orderly disconnect.
        //  If the Irp allocation fails then we should ignore receives
        //  since we are in the process of putting down a ZwClose on this
        //  connection.
        //

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_DATA_NOT_ACCEPTED;
    }


    pdncb = FindReceive( pcb );

    if ( pdncb == NULL ) {

        pcb->ReceiveIndicated = 1;

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_DATA_NOT_ACCEPTED;
    }

    pcb->ReceiveIndicated = 0;

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    //
    //  If this is the simple case where all the data required has been
    //  indicated and it all fits in the buffer then copy the packet
    //  contents directly into the users buffer rather than returning the
    //  Irp. This should always be faster than returning an Irp to the
    //  transport.
    //

    if (( BytesAvailable <= pdncb->ncb_length ) &&
        ( BytesAvailable == BytesIndicated ) &&
        ( ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE )) {

        PIRP Irp = pdncb->irp;

        if ( BytesAvailable != 0 ) {

            PUCHAR UsersBuffer = MmGetSystemAddressForMdlSafe(
                                    Irp->MdlAddress, NormalPagePriority);

            if (UsersBuffer == NULL) {
                pcb->ReceiveIndicated = 1;

                return STATUS_DATA_NOT_ACCEPTED;
            }
            
            TdiCopyLookaheadData(
                UsersBuffer,
                Tsdu,
                BytesAvailable,
                ReceiveFlags);
        }

        *BytesTaken = BytesAvailable;

        pdncb->ncb_length = (WORD)BytesAvailable;

        NCB_COMPLETE( pdncb, NRC_GOODRET );

        Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

        NbCompleteRequest(Irp,STATUS_SUCCESS);

        return STATUS_SUCCESS;

    } else {

        TdiBuildReceive (pdncb->irp,
            pcb->DeviceObject,
            pcb->ConnectionObject,
            NbCompletionPDNCB,
            pdncb,
            pdncb->irp->MdlAddress,
            0,
            pdncb->ncb_length);

        IoSetNextIrpStackLocation( pdncb->irp );

        *IoRequestPacket = pdncb->irp;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    UNREFERENCED_PARAMETER( ReceiveEventContext );
    UNREFERENCED_PARAMETER( Tsdu );
}

PIRP
BuildReceiveIrp (
    IN PCB pcb
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an NCB arrives from the network and also when
    a receive completes with STATUS_BUFFER_OVERFLOW.

    If no Irp is available then this routine sets ReceiveIndicated so
    that the next appropriate receive will be passed to the transport.

Arguments:

    IN PCB pcb - Supplies the connection which should put a receive Irp
                down if it has one available.

Return Value:

    PDNCB to be satisfied by this receive request

--*/
{
    PDNCB pdncb = FindReceive( pcb );

    if ( pdncb == NULL ) {

        pcb->ReceiveIndicated = 1;

        return NULL;
    }

    TdiBuildReceive (pdncb->irp,
        pcb->DeviceObject,
        pcb->ConnectionObject,
        NbCompletionPDNCB,
        pdncb,
        pdncb->irp->MdlAddress,
        0,
        pdncb->ncb_length);

    pcb->ReceiveIndicated = 0;

    return pdncb->irp;
}

PDNCB
FindReceive (
    IN PCB pcb
    )
/*++

Routine Description:

    It is called when an NCB arrives from the network and also when
    a receive completes with STATUS_BUFFER_OVERFLOW.

Arguments:

    IN PCB pcb - Supplies the connection which should put a receive Irp
                down if it has one available.

Return Value:

    PDNCB to be satisfied by this receive request

--*/

{
    PAB pab;
    PFCB pfcb;
    PDNCB pdncb;

    pab = *(pcb->ppab);
    pfcb = pab->pLana->pFcb;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "NB receive handler pcb: %lx\n", pcb ));
    }

    ASSERT( pcb->Signature == CB_SIGNATURE );

    //
    //  If there is a receive in the list then hand over the data.
    //


    if ( (pdncb = DequeueRequest( &pcb->ReceiveList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receive handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        return pdncb;
    }

    //
    //  No receives on this connection. Is there a receive any for this
    //  address?
    //

    ASSERT( pab != NULL );

    if ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receiveANY handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        pdncb->ncb_num = pab->NameNumber;
        pdncb->ncb_lsn = pcb->SessionNumber;

        return pdncb;
    }

    //
    //  No receives on this connection. Is there a receive any for any
    //  address on this adapter?
    //

    pab = pcb->Adapter->AddressBlocks[MAXIMUM_ADDRESS];

    ASSERT( pab != NULL );

    if ( (pdncb = DequeueRequest( &pab->ReceiveAnyList)) != NULL ) {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receiveANYANY handler pcb: %lx, ncb: %lx\n", pcb, pdncb ));
        }

        pdncb->ncb_num = pab->NameNumber;
        pdncb->ncb_lsn = pcb->SessionNumber;

        return pdncb;
    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the data yet.
    //

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive handler ignored receive, pcb: %lx\n", pcb ));
    }

    return NULL;
}

NTSTATUS
NbReceiveDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to read a buffer of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    NTSTATUS Status;
    PPAB ppab;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num  );

    if ( ppab == NULL ) {
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }

    //  Build the ReceiveInformation datastructure in the DNCB.


    if ( (pdncb->ncb_command & ~ASYNCH) == NCBDGRECVBC ) {
        //
        //  Receive broadcast commands can be requested on any valid
        //  name number but once accepted, they are treated seperately
        //  from the name. To implement this, the driver queues the
        //  receives on address 255.
        //

        ppab = FindAbUsingNum( pfcb, pdncb, MAXIMUM_ADDRESS  );

        if ((ppab == NULL) || (pdncb->ncb_num == MAXIMUM_ADDRESS) ) {

            NCB_COMPLETE( pdncb, NRC_ILLNN );
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB Bdatagram receive, queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                ppab, (*ppab), pdncb ));
        }

        if ( (*ppab)->ReceiveDatagramRegistered == FALSE) {

            (*ppab)->ReceiveDatagramRegistered = TRUE;
            UNLOCK_SPINLOCK( pfcb, OldIrql);

            Status = NbSetEventHandler( (*ppab)->DeviceObject,
                                        (*ppab)->AddressObject,
                                        TDI_EVENT_RECEIVE_DATAGRAM,
                                        (PVOID)NbTdiDatagramHandler,
                                        (*ppab));

            if (Status != STATUS_SUCCESS)
			{
				return(Status);
			}

            LOCK_SPINLOCK( pfcb, OldIrql);
        }

        //
        //  When one receive broadcast is received, we must satisfy all the receive
        //  broadcasts. To do this, the largest receive is placed at the head of the queue.
        //  When a datagram is received, this receive is given to the transport to fill in
        //  with data. In the completion routine this driver propogates the same data to
        //  the other receive datagram requests.
        //

        IoMarkIrpPending( Irp );

        if ( !IsListEmpty( &(*ppab)->ReceiveBroadcastDatagramList) ) {
            PDNCB pdncbHead = CONTAINING_RECORD( &(*ppab)->ReceiveBroadcastDatagramList.Flink , DNCB, ncb_next);
            if ( pdncb->ncb_length >= pdncbHead->ncb_length ) {
                IF_NBDBG (NB_DEBUG_RECEIVE) {
                    NbPrint(( "\n  NB Bdatagram receive, Head of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                        ppab, (*ppab), pdncb ));
                }
                //  Note: QueueRequest UNLOCKS the fcb.
                QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, TRUE);
            } else {
                IF_NBDBG (NB_DEBUG_RECEIVE) {
                    NbPrint(( "\n  NB Bdatagram receive, Tail of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                        ppab, (*ppab), pdncb ));
                }
                QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
            }

        } else {
            IF_NBDBG (NB_DEBUG_RECEIVE) {
                NbPrint(( "\n  NB Bdatagram receive, Tail2 of queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                    ppab, (*ppab), pdncb ));
            }
            QueueRequest(&(*ppab)->ReceiveBroadcastDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
        }

    } else {

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB datagram receive, queue ppab: %lx, pab: %lx, pdncb: %lx\n",
                ppab, (*ppab), pdncb ));
        }

        QueueRequest(&(*ppab)->ReceiveDatagramList, pdncb, Irp, pfcb, OldIrql, FALSE);
    }

    Status = STATUS_PENDING;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB datagram receive: %X, %X\n", Status, Irp->IoStatus.Status ));
    }

    return Status;
    UNREFERENCED_PARAMETER( Buffer2Length );
}

NTSTATUS
NbTdiDatagramHandler(
    IN PVOID TdiEventContext,       // the event context - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an NCB arrives from the network, it will look for a
    the address with an appropriate read datagram outstanding.
    The address that has the read associated with it is indicated by the
    context parameter.

    If it finds an appropriate read it processes the NCB.

Arguments:

    IN PVOID TdiEventContext - Context provided for this event - pab
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket       // TdiReceive IRP if MORE_PROCESSING_REQUIRED.


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    PAB pab = (PAB)TdiEventContext;
    PAB pab255;

    PDNCB pdncb;
    PFCB pfcb;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    pfcb = pab->pLana->pFcb;
    LOCK_SPINLOCK( pfcb, OldIrql );

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "NB receive datagram handler pfcb: %lx, pab: %lx\n", pfcb, pab ));
    }

    *IoRequestPacket = NULL;

    ASSERT( pab->Signature == AB_SIGNATURE );

    //  If its address 255 then we are receiving a broadcast datagram.

    if ( pab->NameNumber == MAXIMUM_ADDRESS ) {

        if ( (pdncb = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {

            ReturnDatagram(
                pab,
                SourceAddress,
                pdncb,
                !IsListEmpty( &pab->ReceiveBroadcastDatagramList));

            *IoRequestPacket = pdncb->irp;

            IoSetNextIrpStackLocation( pdncb->irp );
            UNLOCK_SPINLOCK( pfcb, OldIrql );
            return STATUS_MORE_PROCESSING_REQUIRED;

        }

        //
        //  Transport will complete the processing of the request, we don't
        //  want the datagram.
        //

        IF_NBDBG (NB_DEBUG_RECEIVE) {
            NbPrint(( "\n  NB receive BD handler ignored receive, pab: %lx\n", pab ));
        }

        UNLOCK_SPINLOCK( pfcb, OldIrql );
        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    //  Check the address block looking for a Receive Datagram.
    //

    if ( (pdncb = DequeueRequest( &pab->ReceiveDatagramList)) != NULL ) {

        ReturnDatagram(
            pab,
            SourceAddress,
            pdncb,
            FALSE);

        *IoRequestPacket = pdncb->irp;

        IoSetNextIrpStackLocation( pdncb->irp );

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    //  Check to see if there is a receive any datagram.
    //

    //  look at the list on address 255.

    pab255 = pab->pLana->AddressBlocks[MAXIMUM_ADDRESS];

    if ( (pdncb = DequeueRequest( &pab255->ReceiveDatagramList)) != NULL ) {

        ReturnDatagram(
            pab255,
            SourceAddress,
            pdncb,
            FALSE);

        pdncb->ncb_num = pab->NameNumber;

        *IoRequestPacket = pdncb->irp;

        IoSetNextIrpStackLocation( pdncb->irp );

        UNLOCK_SPINLOCK( pfcb, OldIrql );

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB receive datagram handler ignored receive, pab: %lx\n", pab ));
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );

    return STATUS_DATA_NOT_ACCEPTED;

    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( BytesTaken );
    UNREFERENCED_PARAMETER( Tsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( Options );
    UNREFERENCED_PARAMETER( ReceiveDatagramFlags );
}


VOID
ReturnDatagram(
    IN PAB pab,
    IN PVOID SourceAddress,
    IN PDNCB pdncb,
    IN BOOL MultipleReceive
    )
/*++

Routine Description:

    This routine is used to provide the Irp for a receive datagram to
    the transport.

Arguments:

    IN PAB pab  -   Supplies the address block associated with the NCB.
    IN PVOID SourceAddress - Supplies the sender of the datagram.
    IN PDNCB pdncb  -   Supplies the NCB to be satisfied.
    IN BOOL MultipleReceive - True if the special Receive Broadcast datagram completion
                handler is to be used.

Return Value:

    none.

--*/

{
    PIRP Irp = pdncb->irp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    IF_NBDBG (NB_DEBUG_RECEIVE) {
        NbPrint(( "\n  NB BDatagramreceive handler pab: %lx, ncb: %lx\n",
            pab, pdncb ));
    }

    //  Copy the name into the NCB for return to the application.
    RtlMoveMemory(
        pdncb->ncb_callname,
        ((PTA_NETBIOS_ADDRESS)SourceAddress)->Address[0].Address[0].NetbiosName,
        NCBNAMSZ
        );

    //  Tell TDI we do not want to specify any filters.
    pdncb->Information.RemoteAddress = 0;
    pdncb->Information.RemoteAddressLength = 0;
    pdncb->Information.UserData = NULL;
    pdncb->Information.UserDataLength = 0;
    pdncb->Information.Options = NULL;
    pdncb->Information.OptionsLength = 0;

    //  Tell TDI we do not want any more information on the remote name.
    pdncb->ReturnInformation.RemoteAddress = 0;
    pdncb->ReturnInformation.RemoteAddressLength = 0;
    pdncb->ReturnInformation.UserData = NULL;
    pdncb->ReturnInformation.UserDataLength = 0;
    pdncb->ReturnInformation.Options = NULL;
    pdncb->ReturnInformation.OptionsLength = 0;

    CompletionRoutine = ( MultipleReceive == FALSE ) ? NbCompletionPDNCB: NbCompletionBroadcast;

    ASSERT(Irp->MdlAddress != NULL);

    TdiBuildReceiveDatagram (Irp,
        pab->DeviceObject,
        pab->AddressObject,
        CompletionRoutine,
        pdncb,
        Irp->MdlAddress,
        pdncb->ncb_length,
        &pdncb->Information,
        &pdncb->ReturnInformation,
        0);

    return;
}


NTSTATUS
NbCompletionBroadcast(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine takes the completed datagram receive and copies the data in the buffer
    to all the other receive broadcast datagram requests.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the NCB associated with the Irp.

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PDNCB pdncb = (PDNCB) Context;
    KIRQL OldIrql;                      //  Used when SpinLock held.
    PUCHAR pData;
    UCHAR NcbStatus;
    PAB pab;
    PDNCB pdncbNext;

    IF_NBDBG (NB_DEBUG_COMPLETE) {
        NbPrint( ("NbCompletionBroadcast pdncb: %lx, Status: %X, Length %lx\n",
            Context,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information ));
    }

    //  Tell application how many bytes were transferred
    pdncb->ncb_length = (unsigned short)Irp->IoStatus.Information;

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {
        NcbStatus = NRC_GOODRET;
    } else {
        NcbStatus = NbMakeNbError( Irp->IoStatus.Status );
    }

    //
    //  Tell IopCompleteRequest how much to copy back when the request
    //  completes.
    //

    Irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );

    pData = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);

    if (pData != NULL) {
    
        LOCK_SPINLOCK( pdncb->pfcb, OldIrql );

        pab = *(FindAbUsingNum( pdncb->pfcb, pdncb, MAXIMUM_ADDRESS ));

        //
        //  For each request on the queue, copy the data, update the NCb and complete the IRP.
        //

        while ( (pdncbNext = DequeueRequest( &pab->ReceiveBroadcastDatagramList)) != NULL ) {
            PUCHAR pNextData;
            WORD Length;

            IF_NBDBG (NB_DEBUG_COMPLETE) {
                NbPrint( ("NbCompletionBroadcast pdncb: %lx, Length %lx\n",
                    pdncbNext,
                    Irp->IoStatus.Information ));
            }

            ASSERT(pdncbNext->irp->MdlAddress != NULL);

            if (pdncbNext->irp->MdlAddress != NULL ) {
                pNextData = MmGetSystemAddressForMdlSafe(
                                pdncbNext->irp->MdlAddress, NormalPagePriority
                                );
            }

            if ((pdncbNext->irp->MdlAddress == NULL) ||
                (pNextData == NULL)) {
                Length = 0;
            }

            else {
                Length = min( pdncb->ncb_length, pdncbNext->ncb_length);
                pdncbNext->ncb_length = Length;
                RtlMoveMemory( pNextData, pData, Length );
            }

            if (( Length != pdncb->ncb_length ) &&
                ( NcbStatus == NRC_GOODRET )) {
                if (Length == 0) {
                    NCB_COMPLETE( pdncbNext, NRC_NORES );
                }
                else {
                    NCB_COMPLETE( pdncbNext, NRC_INCOMP );
                }
            } else {
                NCB_COMPLETE( pdncbNext, NcbStatus );
            }
            pdncbNext->irp->IoStatus.Information = FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            NbCompleteRequest(pdncbNext->irp, STATUS_SUCCESS );

        }

        UNLOCK_SPINLOCK( pdncb->pfcb, OldIrql );
    }

    NCB_COMPLETE( pdncb, NcbStatus );
    
    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back the NCB into the users buffer.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\registry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This contains all routines necessary to load the lana number to device pathname
    mapping and the Lana Enum record.

Author:

    Colin Watson (colinw) 14-Mar-1992

Revision History:


Notes:
    The fcb holds an area for registry workspace. this is where the strings
    used to hold the DriverNames will be held in a single allocation.

    build with -DUTILITY to run as a test application.
--*/

#include "Nb.h"
//#include <zwapi.h>
//#include <stdlib.h>
#include <crt\stdlib.h>


#define DEFAULT_VALUE_SIZE 4096

#define ROUNDUP_TO_LONG(x) (((x) + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1))

#ifdef UTILITY
#define ZwClose NtClose
#define ZwCreateKey NtCreateKey
#define ZwOpenKey NtOpenKey
#define ZwQueryValueKey NtQueryValueKey
#define ExFreePool free
#endif

//
// Local functions used to access the registry.
//

NTSTATUS
NbOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE LinkageHandle,
    OUT PHANDLE ParametersHandle
    );

VOID
NbCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    );

NTSTATUS
NbReadLinkageInformation(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle,
    IN PFCB pfcb,
    IN BOOL bDeviceCreate
    );

ULONG
NbReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    );


//
// Local function used to determine is specified device is Pnp enabled
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, GetIrpStackSize)
#pragma alloc_text(PAGE, ReadRegistry)
#pragma alloc_text(PAGE, NbFreeRegistryInfo)
#pragma alloc_text(PAGE, NbOpenRegistry)
#pragma alloc_text(PAGE, NbCloseRegistry)
#pragma alloc_text(PAGE, NbReadLinkageInformation)
#pragma alloc_text(PAGE, NbReadSingleParameter)
#pragma alloc_text(PAGE, NbCheckLana)
#endif

CCHAR
GetIrpStackSize(
    IN PUNICODE_STRING RegistryPath,
    IN CCHAR DefaultValue
    )
/*++

Routine Description:

    This routine is called by NbCreateDeviceContext to get the IRP
    stack size to be "exported" by the NetBIOS device.

Arguments:

    RegistryPath - The name of Nb's node in the registry.
    DefaultValue - IRP stack size to be used if no registry value present.

Return Value:

    CCHAR - IRP stack size to be stored in the device object.

--*/
{
    HANDLE LinkageHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    ULONG stackSize;

    PAGED_CODE();

    Status = NbOpenRegistry (RegistryPath, &LinkageHandle, &ParametersHandle);

    if (Status != STATUS_SUCCESS) {
        return DefaultValue;
    }

    //
    // Read the stack size value from the registry.
    //

    stackSize = NbReadSingleParameter(
                    ParametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    DefaultValue );

    if ( stackSize > 255 ) {
        stackSize = 255;
    }

    NbCloseRegistry (LinkageHandle, ParametersHandle);

    return (CCHAR)stackSize;

}

NTSTATUS
ReadRegistry(
    IN PUNICODE_STRING pusRegistryPath,
    IN PFCB NewFcb,
    IN BOOLEAN bDeviceCreate
    )
/*++

Routine Description:

    This routine is called by Nb to get information from the registry,
    starting at RegistryPath to get the parameters.

Arguments:

    DeviceContext - Supplies RegistryPath. The name of Nb's node in the registry.
    NewFcb - Destination for the configuration information.

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    HANDLE LinkageHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;

    PAGED_CODE();

    NewFcb->RegistrySpace = NULL; //  No registry workspace.
    NewFcb->LanaEnum.length = 0;


    Status = NbOpenRegistry ( pusRegistryPath, &LinkageHandle, &ParametersHandle);

    if (Status != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Read in the NDIS binding information (if none is present
    // the array will be filled with all known drivers).
    //

    Status = NbReadLinkageInformation (
                LinkageHandle,
                ParametersHandle,
                NewFcb,
                bDeviceCreate);

    NbCloseRegistry (LinkageHandle, ParametersHandle);

    return Status;

}


//----------------------------------------------------------------------------
// GetLanaMap
//
// retrieves the lana map structure.
// Allocates the memory required for the lana map structure that must be 
// deallocated after use.
//----------------------------------------------------------------------------

NTSTATUS
GetLanaMap(
    IN      PUNICODE_STRING                     pusRegistryPath,
    IN  OUT PKEY_VALUE_FULL_INFORMATION *       ppkvfi
    )
{
    HANDLE hLinkage = NULL;
    HANDLE hParameters = NULL;
    NTSTATUS nsStatus;

    PKEY_VALUE_FULL_INFORMATION pkvfiValue = NULL;
    ULONG ulValueSize;

    PWSTR wsLanaMapName = REGISTRY_LANA_MAP;
    UNICODE_STRING usLanaMap;

    ULONG ulBytesWritten;



    PAGED_CODE();


    do
    {
        *ppkvfi = NULL;

        
        //
        // open registry keys
        //
        
        nsStatus = NbOpenRegistry ( pusRegistryPath, &hLinkage, &hParameters );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            break;
        }

        
        //
        // allocate for lana map.
        //
        
        pkvfiValue = ExAllocatePoolWithTag( 
                        PagedPool, MAXIMUM_LANA * sizeof( LANA_MAP ), 'rSBN' 
                        );

        if ( pkvfiValue == NULL )
        {
            nsStatus = STATUS_UNSUCCESSFUL;
            NbPrint( (
                "GetLanaMap : Allocation failed for %d bytes\n", DEFAULT_VALUE_SIZE
                 ) );
            break;
        }

        ulValueSize = MAXIMUM_LANA * sizeof( LANA_MAP );

        
        //
        // query "LanaMap" value
        //

        RtlInitUnicodeString (&usLanaMap, wsLanaMapName);

        nsStatus = ZwQueryValueKey(
                             hLinkage,
                             &usLanaMap,
                             KeyValueFullInformation,
                             pkvfiValue,
                             ulValueSize,
                             &ulBytesWritten
                             );

        if (!NT_SUCCESS(nsStatus)) 
        {
            NbPrint ( (
                "GetLanaMap : failed querying lana map key %x", nsStatus 
                ) );
            break;
        }

        if ( ulBytesWritten == 0 ) 
        {
            nsStatus = STATUS_UNSUCCESSFUL;
            NbPrint ( ("GetLanaMap : querying lana map key returned 0 bytes") );
            break;
        }


        *ppkvfi = pkvfiValue;

        NbCloseRegistry (hLinkage, hParameters);

        return nsStatus;
        
    } while (FALSE);


    if ( pkvfiValue != NULL )
    {
        ExFreePool( pkvfiValue );
    }
    
    NbCloseRegistry (hLinkage, hParameters);
    
    return nsStatus;
}

//----------------------------------------------------------------------------
// GetMaxLana
//
// retrieves the MaxLana value from the netbios parameters key.
//----------------------------------------------------------------------------

NTSTATUS
GetMaxLana(
    IN      PUNICODE_STRING     pusRegistryPath,
    IN  OUT PULONG              pulMaxLana
    )
{
    HANDLE hLinkage = NULL;
    HANDLE hParameters = NULL;
    NTSTATUS nsStatus;

    UCHAR ucBuffer[ 256 ];
    PKEY_VALUE_FULL_INFORMATION pkvfiValue = 
        (PKEY_VALUE_FULL_INFORMATION) ucBuffer;
    ULONG ulValueSize;
    

    PWSTR wsMaxLana = REGISTRY_MAX_LANA;
    UNICODE_STRING usMaxLana;

    ULONG ulBytesWritten;



    PAGED_CODE();

    do
    {
        *pulMaxLana = 0;

        
        //
        // open registry keys
        //
        
        nsStatus = NbOpenRegistry ( pusRegistryPath, &hLinkage, &hParameters );

        if ( !NT_SUCCESS( nsStatus ) )
        {
            NbPrint( ("GetMaxLana : Failed to open registry" ) );
            nsStatus = STATUS_UNSUCCESSFUL;
            break;
        }


        //
        // allocate for key value.
        //
        
        ulValueSize = sizeof( ucBuffer );

        
        //
        // query "MaxLana" value
        //

        RtlInitUnicodeString (&usMaxLana, wsMaxLana);

        nsStatus = ZwQueryValueKey(
                             hParameters,
                             &usMaxLana,
                             KeyValueFullInformation,
                             pkvfiValue,
                             ulValueSize,
                             &ulBytesWritten
                             );

        if (!NT_SUCCESS(nsStatus)) 
        {
            NbPrint ( (
                "GetMaxLana : failed querying lana map key %x", nsStatus 
                ) );
            break;
        }

        if ( ulBytesWritten == 0 ) 
        {
            NbPrint ( ("GetMaxLana : querying lana map key returned 0 bytes") );
            nsStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        *pulMaxLana = *( (PULONG) ( (PUCHAR) pkvfiValue + pkvfiValue-> DataOffset ) );
        
        NbCloseRegistry (hLinkage, hParameters);

        return nsStatus;
        
    } while ( FALSE );
    

    NbCloseRegistry (hLinkage, hParameters);
    
    return nsStatus;
}



VOID
NbFreeRegistryInfo (
    IN PFCB pfcb
    )

/*++

Routine Description:

    This routine is called by Nb to get free any storage that was allocated
    by NbConfigureTransport in producing the specified CONFIG_DATA structure.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if ( pfcb->RegistrySpace != NULL ) {
        ExFreePool( pfcb->RegistrySpace );
        pfcb->RegistrySpace = NULL;
    }

}

NTSTATUS
NbOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE LinkageHandle,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by Nb to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

    NOTE: If the key "ClearRegistry" exists in ntuser.cfg, then
    this routine will remove any existing registry values for Nb
    (but still create the tree if it doesn't exist) and return
    FALSE.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE NbConfigHandle;
    NTSTATUS Status;
    HANDLE LinkHandle;
    HANDLE ParamHandle;
    PWSTR LinkageString = REGISTRY_LINKAGE;
    PWSTR ParametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING LinkageKeyName;
    UNICODE_STRING ParametersKeyName;
    OBJECT_ATTRIBUTES TmpObjectAttributes;
    ULONG Disposition;

    PAGED_CODE();

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwCreateKey(
                 &NbConfigHandle,
                 KEY_WRITE,
                 &TmpObjectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &Disposition);     // disposition

    if (!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Open the Nb linkages key.
    //

    RtlInitUnicodeString (&LinkageKeyName, LinkageString);

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        &LinkageKeyName,            // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NbConfigHandle,            // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey(
                 &LinkHandle,
                 KEY_READ,
                 &TmpObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        ZwClose (NbConfigHandle);
        return Status;
    }


    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&ParametersKeyName, ParametersString);

    InitializeObjectAttributes(
        &TmpObjectAttributes,
        &ParametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NbConfigHandle,            // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey(
                 &ParamHandle,
                 KEY_READ,
                 &TmpObjectAttributes);
    if (!NT_SUCCESS(Status)) {

        ZwClose (LinkHandle);
        ZwClose (NbConfigHandle);
        return Status;
    }

    *LinkageHandle = LinkHandle;
    *ParametersHandle = ParamHandle;


    //
    // All keys successfully opened or created.
    //

    ZwClose (NbConfigHandle);
    return STATUS_SUCCESS;

}   /* NbOpenRegistry */

VOID
NbCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by Nb to close the registry. It closes
    the handles passed in and does any other work needed.

Arguments:

    LinkageHandle - The handle used to read linkage information.

    ParametersHandle - The handle used to read other parameters.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ZwClose (LinkageHandle);
    ZwClose (ParametersHandle);

}   /* NbCloseRegistry */

NTSTATUS
NbReadLinkageInformation(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle,
    IN PFCB pfcb,
    IN BOOL bCreateDevice
    )

/*++

Routine Description:

    This routine is called by Nb to read its linkage information
    from the registry. If there is none present, then ConfigData
    is filled with a list of all the adapters that are known
    to Nb.

Arguments:

    LinkageHandle - Supplies the Linkage key in netbios
    ParametersHandle

    pfcb - Describes Nb's current configuration.

Return Value:

    Status

--*/

{
    PWSTR BindName = REGISTRY_BIND;
    UNICODE_STRING BindString;
    NTSTATUS Status;

    PKEY_VALUE_FULL_INFORMATION Value = NULL;
    ULONG ValueSize;

    PWSTR LanaMapName = REGISTRY_LANA_MAP;
    UNICODE_STRING LanaMapString;
    PLANA_MAP pLanaMap;

    ULONG BytesWritten;
    UINT ConfigBindings = 0;
    PWSTR CurBindValue;
    UINT index;

    PAGED_CODE();

    pfcb->MaxLana = NbReadSingleParameter( ParametersHandle, REGISTRY_MAX_LANA, -1 );

    if (pfcb->MaxLana > MAXIMUM_LANA) {
        return STATUS_INVALID_PARAMETER;
    }

    NbPrint( (
        "Netbios : NbReadLinkageInformation : MaxLana = %d\n", 
        pfcb-> MaxLana 
        ) );

    //
    // Read the "Bind" key.
    //

    RtlInitUnicodeString (&BindString, BindName);

#ifdef UTILITY
    Value = malloc( DEFAULT_VALUE_SIZE);
#else
    Value = ExAllocatePoolWithTag(PagedPool, DEFAULT_VALUE_SIZE, 'rSBN');
#endif

    if ( Value == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ValueSize = DEFAULT_VALUE_SIZE;

    pfcb->RegistrySpace = NULL;

    try {

        Status = ZwQueryValueKey(
                             LinkageHandle,
                             &BindString,
                             KeyValueFullInformation,
                             Value,
                             ValueSize,
                             &BytesWritten
                             );

        if ( Status == STATUS_BUFFER_OVERFLOW) {

            ExFreePool( Value );

            //  Now request with exactly the right size
            ValueSize = BytesWritten;

#ifdef UTILITY
            Value = malloc( ValueSize);
#else
            Value = ExAllocatePoolWithTag(PagedPool, ValueSize, 'rSBN');
#endif

            if ( Value == NULL ) {
                try_return( Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            Status = ZwQueryValueKey(
                                 LinkageHandle,
                                 &BindString,
                                 KeyValueFullInformation,
                                 Value,
                                 ValueSize,
                                 &BytesWritten
                                );
        }

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        if ( BytesWritten == 0 ) {
            try_return( Status = STATUS_ILL_FORMED_SERVICE_ENTRY);
        }


        //
        // Alloc space for Registry stuff as well as pDriverName array.
        //
    #ifdef UTILITY
        pfcb->RegistrySpace = malloc(ROUNDUP_TO_LONG(BytesWritten - Value->DataOffset) +
            (sizeof(UNICODE_STRING) * (pfcb->MaxLana+1)));
    #else
        pfcb->RegistrySpace = ExAllocatePoolWithTag(PagedPool,
            ROUNDUP_TO_LONG(BytesWritten - Value->DataOffset) +
            (sizeof(UNICODE_STRING) * (pfcb->MaxLana+1)), 'rSBN');
    #endif

        if ( pfcb->RegistrySpace == NULL ) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlMoveMemory(pfcb->RegistrySpace,
                        (PUCHAR)Value + Value->DataOffset,
                        BytesWritten - Value->DataOffset);

        pfcb->pDriverName =
            (PUNICODE_STRING) ((PBYTE) pfcb->RegistrySpace +
            ROUNDUP_TO_LONG(BytesWritten-Value->DataOffset));

        //
        // Read the "LanaMap" key into Storage.
        //

        RtlInitUnicodeString (&LanaMapString, LanaMapName);

        Status = ZwQueryValueKey(
                             LinkageHandle,
                             &LanaMapString,
                             KeyValueFullInformation,
                             Value,
                             ValueSize,
                             &BytesWritten
                             );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        if ( BytesWritten == 0 ) {
            try_return( Status = STATUS_ILL_FORMED_SERVICE_ENTRY);
        }

        //  Point pLanaMap at the data from the registry.
        pLanaMap = (PLANA_MAP)((PUCHAR)Value + Value->DataOffset);

        //
        // For each binding, initialize the drivername string.
        //

        for ( index = 0 ; index <= pfcb->MaxLana ; index++ ) {
            //  Initialize unused drivernames to NULL name
            RtlInitUnicodeString (&pfcb->pDriverName[index], NULL);
        }

        CurBindValue = (PWCHAR)pfcb->RegistrySpace;

        
        IF_NBDBG( NB_DEBUG_FILE )
        {
    		NbPrint( ("NETBIOS: Enumerating lanas ...\n") );
        }
        
        while (*CurBindValue != 0) {

            if ((ConfigBindings > pfcb->MaxLana) ||
                (pLanaMap[ConfigBindings].Lana > pfcb->MaxLana)) {
                try_return( Status = STATUS_INVALID_PARAMETER);
            }

            RtlInitUnicodeString (
                &pfcb->pDriverName[pLanaMap[ConfigBindings].Lana],
               CurBindValue);

            //
            // Only non PNP devices are created here.  PnP devices 
            // are created as required in the bind handler in file.c
            //
            // V Raman
            //
            
            if ( bCreateDevice                                          &&
                 pLanaMap[ConfigBindings].Enum != FALSE ) {
                 
				if (NbCheckLana (
						&pfcb->pDriverName[pLanaMap[ConfigBindings].Lana])) 
				{
					//
					//  Record that the lana number is enabled
					//

					pfcb->LanaEnum.lana[pfcb->LanaEnum.length] =
						pLanaMap[ConfigBindings].Lana;
					pfcb->LanaEnum.length++;

                    IF_NBDBG( NB_DEBUG_FILE )
                    {
					    NbPrint( ("NETBIOS: Lana %d (%ls) added OK.\n",
						    pLanaMap[ConfigBindings].Lana, CurBindValue) );
					}
				}

				else
				{
    			    IF_NBDBG( NB_DEBUG_FILE )
	    		    {
		    			NbPrint( ("NETBIOS: Lana's %d %ls could not be opened.\n",
			    			pLanaMap[ConfigBindings].Lana, CurBindValue) );
			    	}
                }
            }
            
			else
			{
			    IF_NBDBG( NB_DEBUG_FILE )
			    {
				    NbPrint( ("NbReadLinkageInformation : Lana %d (%ls) is not enumerated.\n",
						pLanaMap[ConfigBindings].Lana, CurBindValue) );
			    }
            }

            ++ConfigBindings;

            //
            // Now advance the "Bind" value.
            //

            CurBindValue += wcslen(CurBindValue) + 1;

        }

        try_return( Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if ( !NT_SUCCESS(Status) ) {
            ExFreePool( pfcb->RegistrySpace );
            pfcb->RegistrySpace = NULL;
        }

        if ( Value != NULL ) {
            ExFreePool( Value );
        }
    }

    return Status;

}   /* NbReadLinkageInformation */

ULONG
NbReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by Nb to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    ULONG InformationBuffer[16];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION Information =
        (PKEY_VALUE_FULL_INFORMATION)InformationBuffer;
    UNICODE_STRING ValueKeyName;
    ULONG InformationLength;
    LONG ReturnValue;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString (&ValueKeyName, ValueName);

    Status = ZwQueryValueKey(
                 ParametersHandle,
                 &ValueKeyName,
                 KeyValueFullInformation,
                 (PVOID)Information,
                 sizeof (InformationBuffer),
                 &InformationLength);

    if ((Status == STATUS_SUCCESS) && (Information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&ReturnValue,
            ((PUCHAR)Information) + Information->DataOffset,
            sizeof(ULONG));

        if (ReturnValue < 0) {

            ReturnValue = DefaultValue;

        }

    } else {

        ReturnValue = DefaultValue;

    }

    return ReturnValue;

}   /* NbReadSingleParameter */


BOOLEAN
NbCheckLana (
	PUNICODE_STRING	DeviceName
    )
/*++

Routine Description:

    This routine uses the transport to create an entry in the NetBIOS
    table with the value of "Name". It will re-use an existing entry if
    "Name" already exists.

    Note: This synchronous call may take a number of seconds. If this matters
    then the caller should specify ASYNCH and a post routine so that it is
    performed by the thread created by the netbios dll routines.

    If pdncb == NULL then a special handle is returned that is capable of
    administering the transport. For example to execute an ASTAT.

Arguments:

    FileHandle - Pointer to where the filehandle is to be returned.

    *Object - Pointer to where the file object pointer is to be stored

    pfcb - supplies the device names for the lana number.

    LanNumber - supplies the network adapter to be opened.

    pdncb - Pointer to either an NCB or NULL.

Return Value:

    The function value is the status of the operation.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;

    PAGED_CODE();

    InitializeObjectAttributes (
        &ObjectAttributes,
        DeviceName,
        0,
        NULL,
        NULL);

    Status = ZwCreateFile (
                 &FileHandle,
                 GENERIC_READ | GENERIC_WRITE, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 NULL,                  // Allocation size (unused).
                 FILE_ATTRIBUTE_NORMAL, // file attributes.
                 FILE_SHARE_WRITE,
                 FILE_CREATE,
                 0,                     // create options.
                 NULL,
                 0
                 );


    if ( NT_SUCCESS( Status )) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS( Status )) {
        NTSTATUS localstatus;
		
        localstatus = ZwClose( FileHandle);

        ASSERT(NT_SUCCESS(localstatus));
		return TRUE;
	}
	else {

	    NbPrint( ( 
	        "NbCheckLana : Create file failed for %s with code %x iostatus %x\n",
	        DeviceName-> Buffer, Status, IoStatusBlock.Status
	        ) );
		return FALSE;
	}
}


#ifdef UTILITY
void
_cdecl
main (argc, argv)
   int argc;
   char *argv[];
{
    DEVICE_CONTEXT DeviceContext;
    FCB NewFcb;
    RtlInitUnicodeString(&DeviceContext.RegistryPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Netbios");
    ReadRegistry(
     &DeviceContext,
     &NewFcb
    );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\winsock\wshnetbs.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    WshNetbs.c

Abstract:

    This module contains necessary routines for the Netbios
    Windows Sockets Helper DLL.  This DLL provides the
    transport-specific support necessary for the Windows Sockets DLL to
    _access any Netbios transport.

Author:

    David Treadwell (davidtr)    19-Jul-1992

Revision History:

--*/

#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <tdi.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <wchar.h>

#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>

//
// Structure and variables to define the triples supported by Netbios.
// The first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE VcMappingTriples[] = { AF_NETBIOS, SOCK_SEQPACKET, 0 };

MAPPING_TRIPLE DgMappingTriples[] = { AF_NETBIOS, SOCK_DGRAM,     0 };

//
// Structure defined for holding transport (provider) information for
// each Netbios transport loaded on the machine.
//

typedef struct _WSHNETBS_PROVIDER_INFO {
    UCHAR Enum;
    UCHAR LanaNumber;
    INT ProtocolNumber;
    PWSTR ProviderName;
} WSHNETBS_PROVIDER_INFO, *PWSHNETBS_PROVIDER_INFO;

PWSHNETBS_PROVIDER_INFO ProviderInfo;
PVOID ProviderNames = NULL;
ULONG ProviderCount;

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;

PLANA_MAP LanaMap;

//
// Maintain all of the config parameters in one memory
// block so we can replace it when info changes.
//
typedef struct _WSHNETBS_CONFIG_INFO {
    LONG    ReferenceCount;     // Reference count to keep the info for
                                // the sockets that are already open
                                // until they are closed
    UCHAR   Blob[1];
} WSHNETBS_CONFIG_INFO, *PWSHNETBS_CONFIG_INFO;
PWSHNETBS_CONFIG_INFO ConfigInfo;
#define REFERENCE_CONFIG_INFO(_info)    \
    InterlockedIncrement (&_info->ReferenceCount)

#define DEREFERENCE_CONFIG_INFO(_info)                      \
    ASSERT (_info->ReferenceCount>0);                       \
    if (InterlockedDecrement (&_info->ReferenceCount)==0) { \
        RtlFreeHeap( RtlProcessHeap( ), 0, _info );         \
    }
//
// Synchronize changes in configuration info
//
RTL_CRITICAL_SECTION ConfigInfoLock;

//
// Registry key and event to monitor changes in configuration info.
//
HKEY    NetbiosKey = NULL;
LARGE_INTEGER NetbiosUpdateTime = {0,0};

//

//
// The socket context structure for this DLL.  Each open Netbios socket will
// have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHNETBS_SOCKET_CONTEXT {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
    PWSHNETBS_PROVIDER_INFO Provider;
    PWSHNETBS_CONFIG_INFO   ConfigInfo;
} WSHNETBS_SOCKET_CONTEXT, *PWSHNETBS_SOCKET_CONTEXT;

//
// The GUID identifying this provider.
//

GUID NetBIOSProviderGuid = { /* 8d5f1830-c273-11cf-95c8-00805f48a192 */
    0x8d5f1830,
    0xc273,
    0x11cf,
    {0x95, 0xc8, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
    };


INT
LoadProviderInfo (
    VOID
    );


BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{
    NTSTATUS    status;
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
        status = RtlInitializeCriticalSection (&ConfigInfoLock);
        if (!NT_SUCCESS (status)) {
            return FALSE;
        }
        //
        // Ignore error here, we'll retry if necessary.
        //
        LoadProviderInfo ();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:

        //
        // If the process is terminating, do not bother to do any
        // resource deallocation as the system will do it automatically.
        //

        if ( Context != NULL ) {
            return TRUE;
        }

        if ( ConfigInfo != NULL ) {
            DEREFERENCE_CONFIG_INFO (ConfigInfo);
            ConfigInfo = NULL;
        }
        if (NetbiosKey!=NULL) {
            RegCloseKey (NetbiosKey);
            NetbiosKey = NULL;
        }

        RtlDeleteCriticalSection (&ConfigInfoLock);


        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_NB *sockaddr = (PSOCKADDR_NB)Sockaddr;

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->snb_family != AF_NETBIOS ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_NB) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Netbios only supports "normal" addresses.
    //

    SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE and SO_DONTROUTE.  This routine is called by
    the winsock DLL when a level/option name combination is passed
    to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // No other options are supported for Netbios sockets.

    return WSAEINVAL;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  Netbios doesn't
    currently support the concept of a wildcard socket address.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wildcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PSOCKADDR_NB sockaddr = (PSOCKADDR_NB)Sockaddr;
    HANDLE providerHandle;
    TDI_REQUEST_QUERY_INFORMATION tdiQuery;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING providerName;
    PWSHNETBS_SOCKET_CONTEXT context = (PWSHNETBS_SOCKET_CONTEXT)HelperDllSocketContext;
    ADAPTER_STATUS adapterStatusInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // We're going to return a Netbios sockaddr with a unique name
    // which is the premanent name of the Lana.
    //

    sockaddr->snb_family = AF_NETBIOS;
    sockaddr->snb_type = NETBIOS_UNIQUE_NAME;

    sockaddr->snb_name[0] = '\0';
    sockaddr->snb_name[1] = '\0';
    sockaddr->snb_name[2] = '\0';
    sockaddr->snb_name[3] = '\0';
    sockaddr->snb_name[4] = '\0';
    sockaddr->snb_name[5] = '\0';
    sockaddr->snb_name[6] = '\0';
    sockaddr->snb_name[7] = '\0';
    sockaddr->snb_name[8] = '\0';
    sockaddr->snb_name[9] = '\0';

    *SockaddrLength = sizeof(SOCKADDR_NB);

    //
    // We'll do a query directly to the TDI provider to get the
    // permanent address for this Lana.  First open a control channel to
    // the provider.
    //

    RtlInitUnicodeString( &providerName, context->Provider->ProviderName );

    InitializeObjectAttributes(
        &objectAttributes,
        &providerName,
        OBJ_INHERIT | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a control channel to the provider.
    //

    status = NtCreateFile(
                 &providerHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,                                     // AllocationSize
                 0L,                                       // FileAttributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE,       // ShareAccess
                 FILE_OPEN_IF,                             // CreateDisposition
                 FILE_SYNCHRONOUS_IO_NONALERT,             // CreateOptions
                 NULL,
                 0
                 );
    if ( !NT_SUCCESS(status) ) {
        return WSAENOBUFS;
    }

    //
    // Do the actual query adapter status.
    //

    RtlZeroMemory( &tdiQuery, sizeof(tdiQuery) );

    tdiQuery.QueryType = TDI_QUERY_ADAPTER_STATUS;

    status = NtDeviceIoControlFile(
                 providerHandle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 IOCTL_TDI_QUERY_INFORMATION,
                 &tdiQuery,
                 sizeof(tdiQuery),
                 &adapterStatusInfo,
                 sizeof(adapterStatusInfo)
                 );
    if ( status != STATUS_SUCCESS && status != STATUS_BUFFER_OVERFLOW ) {
        NtClose( providerHandle );
        return WSAENOBUFS;
    }

    //
    // Close the handle to the provider, we're done with it.
    //

    NtClose( providerHandle );

    //
    // Copy the six bytes of adapter address to the end of the Netbios
    // name.
    //

    sockaddr->snb_name[10] = adapterStatusInfo.adapter_address[0];
    sockaddr->snb_name[11] = adapterStatusInfo.adapter_address[1];
    sockaddr->snb_name[12] = adapterStatusInfo.adapter_address[2];
    sockaddr->snb_name[13] = adapterStatusInfo.adapter_address[3];
    sockaddr->snb_name[14] = adapterStatusInfo.adapter_address[4];
    sockaddr->snb_name[15] = adapterStatusInfo.adapter_address[5];

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(VcMappingTriples) + sizeof(DgMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(VcMappingTriples) / sizeof(VcMappingTriples[0])
                     + sizeof(DgMappingTriples) / sizeof(DgMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory(
        Mapping->Mapping,
        VcMappingTriples,
        sizeof(VcMappingTriples)
        );
    RtlMoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(VcMappingTriples),
        DgMappingTriples,
        sizeof(DgMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context;
    ULONG i;
    BOOLEAN found = FALSE;
    INT error;

    //
    // Only sockets of types SOCK_SEQPACKET and SOCK_DGRAM are supported
    // by Netbios providers.
    //

    if ( *SocketType != SOCK_SEQPACKET && *SocketType != SOCK_DGRAM ) {
        return WSAESOCKTNOSUPPORT;
    }

    if ((error=LoadProviderInfo ())!=NO_ERROR) {
        if (error!=ERROR_NOT_ENOUGH_MEMORY)
            error = WSASYSCALLFAILURE;
        return error;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Treat 0x80000000 just like 0--EnumProtocols() returns 0x80000000
    // for lana 0 because GetAddressByName uses 0 as the protocol array
    // terminator.
    //

    if ( *Protocol == 0x80000000 ) {
        *Protocol = 0;
    }

    RtlEnterCriticalSection (&ConfigInfoLock);
    
    //
    // If the Protocol parameter is less than or equal to zero, then
    // it specifies a Lana number.  Otherwise, it specifies an actual
    // protocol number.  Loop through our array of providers looking
    // for one with a matching Lana or protocol value.
    //

    for ( i = 0; i < ProviderCount; i++ ) {

        if ( ( *Protocol <= 0 && -*Protocol == ProviderInfo[i].LanaNumber &&
                   ProviderInfo[i].Enum != 0 )

             ||

             (*Protocol == ProviderInfo[i].ProtocolNumber && *Protocol != 0) ) {

            REFERENCE_CONFIG_INFO (ConfigInfo);
            context->ConfigInfo = ConfigInfo;
            context->Provider = &ProviderInfo[i];
            found = TRUE;

            break;
        }
    }

    RtlLeaveCriticalSection (&ConfigInfoLock);

    //
    // If we didn't find a hit, fail.
    //

    if ( found ) {

        //
        // Indicate the name of the TDI device that will service this
        // socket.
        //

        RtlInitUnicodeString(
            TransportDeviceName,
            context->Provider->ProviderName
            );

        //
        // Initialize the context for the socket.
        //

        context->AddressFamily = *AddressFamily;
        context->SocketType = *SocketType;
        context->Protocol = *Protocol;
    

        //
        // Tell the Windows Sockets DLL which state transitions we're
        // interested in being notified of.  The only times we need to be
        // called is after a connect has completed so that we can turn on
        // the sending of keepalives if SO_KEEPALIVE was set before the
        // socket was connected, when the socket is closed so that we can
        // free context information, and when a connect fails so that we
        // can, if appropriate, dial in to the network that will support the
        // connect attempt.
        //

        *NotificationEvents = WSH_NOTIFY_CLOSE;

        //
        // Everything worked, return success.
        //

        *HelperDllSocketContext = context;
        return NO_ERROR;
    }


    RtlFreeHeap( RtlProcessHeap( ), 0, context );
    return WSAEPROTONOSUPPORT;
} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    //
    // We should only be called when the socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // Dereference config info and free the socket context.
        //

        DEREFERENCE_CONFIG_INFO (context->ConfigInfo);

        RtlFreeHeap( RtlProcessHeap( ), 0, HelperDllSocketContext );

    } else {

        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE and SO_DONTROUTE.  This routine is called by the
    winsock DLL when a level/option name combination is passed to
    setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHNETBS_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHNETBS_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHNETBS_SOCKET_CONTEXT parentContext;
            INT one = 1;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHNETBS_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            return NO_ERROR;
        }
    }

    //
    // No other options are supported for Netbios sockets.
    //

    return WSAEINVAL;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    DWORD bytesRequired;
    DWORD i;
    PPROTOCOL_INFO protocolInfo;
    PCHAR namePointer;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about NETBIOS protocol information.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    if (LoadProviderInfo ()!=NO_ERROR) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = 0;

    for ( i = 0; i < ProviderCount; i++ ) {
        bytesRequired += sizeof(PROTOCOL_INFO) * 2;
        bytesRequired +=
            ((wcslen( ProviderInfo[i].ProviderName ) + 1) * sizeof(WCHAR)) * 2;
    }

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in info for each Netbios provider.
    //

    namePointer = (PCHAR)lpProtocolBuffer + *lpdwBufferLength;
    protocolInfo = lpProtocolBuffer;

    for ( i = 0; i < ProviderCount * 2; i++ ) {

        protocolInfo[i].dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                           XP_GUARANTEED_ORDER |
                                           XP_MESSAGE_ORIENTED |
                                           XP_FRAGMENTATION;
        protocolInfo[i].iAddressFamily = AF_NETBIOS;
        protocolInfo[i].iMaxSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iMinSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iSocketType = SOCK_SEQPACKET;

        //
        // Return the lana number, but convert 0 to 0x80000000 so that
        // we do not confuse GetAddressByName.  That API uses 0 as the
        // protocol array terminator.
        //

        protocolInfo[i].iProtocol = -1*ProviderInfo[i/2].LanaNumber;
        if ( protocolInfo[i].iProtocol == 0 ) {
            protocolInfo[i].iProtocol = 0x80000000;
        }

        protocolInfo[i].dwMessageSize = 64000;


        namePointer =
         ( namePointer -
             ( (wcslen( ProviderInfo[i/2].ProviderName ) + 1) * sizeof(WCHAR) ) );
        protocolInfo[i].lpProtocol = (LPWSTR)namePointer;
        wcscpy( protocolInfo[i].lpProtocol, ProviderInfo[i/2].ProviderName );

        i++;
        protocolInfo[i].dwServiceFlags = XP_CONNECTIONLESS |
                                           XP_MESSAGE_ORIENTED |
                                           XP_SUPPORTS_BROADCAST |
                                           XP_FRAGMENTATION;
        protocolInfo[i].iAddressFamily = AF_NETBIOS;
        protocolInfo[i].iMaxSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iMinSockAddr = sizeof(SOCKADDR_NB);
        protocolInfo[i].iSocketType = SOCK_DGRAM;

        protocolInfo[i].iProtocol = -1*ProviderInfo[i/2].LanaNumber;
        if ( protocolInfo[i].iProtocol == 0 ) {
            protocolInfo[i].iProtocol = 0x80000000;
        }

        protocolInfo[i].dwMessageSize = 64000;

        namePointer =
         ( namePointer -
             ( (wcslen( ProviderInfo[i/2].ProviderName ) + 1) * sizeof(WCHAR) ) );
        protocolInfo[i].lpProtocol = (LPWSTR)namePointer;
        wcscpy( protocolInfo[i].lpProtocol, ProviderInfo[i/2].ProviderName );
    }

    *lpdwBufferLength = bytesRequired;

    return ProviderCount * 2;

} // WSHEnumProtocols


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"NetBIOS" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &NetBIOSProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


#define ALIGN_TO_MAX_NATURAL(_sz)  \
        (((_sz) + (MAX_NATURAL_ALIGNMENT-1)) & (~(MAX_NATURAL_ALIGNMENT-1)))
INT
LoadProviderInfo (
    VOID
    )
{
    INT error;
    HKEY netbiosKey = NULL;
    ULONG providerListLength;
    ULONG lanaMapLength;
    ULONG type;
    ULONG i;
    PWSTR currentProviderName;
    PWSHNETBS_CONFIG_INFO configInfo = NULL;
    PLANA_MAP lanaMap;
    PWSHNETBS_PROVIDER_INFO providerInfo;
    PVOID providerNames;
    ULONG providerCount;
    LARGE_INTEGER lastWriteTime;


    if (NetbiosKey==NULL) {
        //
        // Read the registry for information on all Netbios providers,
        // including Lana numbers, protocol numbers, and provider device
        // names.  First, open the Netbios key in the registry.
        //

        error = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"SYSTEM\\CurrentControlSet\\Services\\Netbios\\Linkage",
                    0,
                    MAXIMUM_ALLOWED,
                    &netbiosKey
                    );
        if ( error != NO_ERROR ) {
            goto error_exit;
        }
    }
    else {
        //
        // Key is already opened, use it.
        //
        netbiosKey = NetbiosKey;
    }

    //
    // Check if data has changed since last time we read it.
    //
    error = RegQueryInfoKey (
                netbiosKey,     // handle to key to query
                NULL,           // address of buffer for class string
                NULL,           // address of size of class string buffer
                NULL,           // reserved
                NULL,           // address of buffer for number of 
                                // subkeys
                NULL,           // address of buffer for longest subkey 
                                // name length
                NULL,           // address of buffer for longest class 
                                // string length
                NULL,           // address of buffer for number of value 
                                // entries
                NULL,           // address of buffer for longest 
                                // value name length
                NULL,           // address of buffer for longest value 
                                // data length  
                NULL,           // address of buffer for security 
                                // descriptor length
                (PFILETIME)&lastWriteTime 
                                // address of buffer for last write 
                                // time
                );
    if (error!=NO_ERROR) {
        goto error_exit;
    }

    if (NetbiosKey!=NULL && lastWriteTime.QuadPart==NetbiosUpdateTime.QuadPart) {
        return NO_ERROR;
    }

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //

    providerListLength = 0;

    error = RegQueryValueExW(
                netbiosKey,
                L"Bind",
                NULL,
                &type,
                NULL,
                &providerListLength
                );
    if ( error != ERROR_MORE_DATA && error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // If the list of providers is empty, then Netbios is installed
    // but has no bindings.  Special-case a quit right here, since
    // the LanaMap value in the registry may be non-empty.
    //

    if ( providerListLength <= sizeof(WCHAR) ) {
        goto error_exit;
    }

    error = RegQueryValueExW(
                netbiosKey,
                L"LanaMap",
                NULL,
                &type,
                NULL,
                &lanaMapLength
                );
    if ( error != ERROR_MORE_DATA && error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //

    providerCount = lanaMapLength / sizeof(LANA_MAP);

    //
    // Allocate enough memory to hold the blob.
    //

    configInfo = RtlAllocateHeap( RtlProcessHeap( ), 0,
                    ALIGN_TO_MAX_NATURAL(FIELD_OFFSET (WSHNETBS_CONFIG_INFO, Blob)) +
                    ALIGN_TO_MAX_NATURAL(providerListLength) + 
                    ALIGN_TO_MAX_NATURAL(lanaMapLength) +
                    providerCount * sizeof(WSHNETBS_PROVIDER_INFO)
                    );
    if ( configInfo == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    configInfo->ReferenceCount = 1;
    providerNames = (PVOID)((PUCHAR)configInfo + ALIGN_TO_MAX_NATURAL(FIELD_OFFSET (WSHNETBS_CONFIG_INFO, Blob)));
    lanaMap = (PVOID)((PUCHAR)providerNames + ALIGN_TO_MAX_NATURAL(providerListLength));
    providerInfo = (PVOID)((PUCHAR)lanaMap +  ALIGN_TO_MAX_NATURAL(lanaMapLength));


    //
    // Get the list of transports from the registry.
    //

    error = RegQueryValueExW(
                netbiosKey,
                L"Bind",
                NULL,
                &type,
                (PVOID)providerNames,
                &providerListLength
                );
    if ( error != NO_ERROR ) {
        goto error_exit;
    }

    error = RegQueryValueExW(
                netbiosKey,
                L"LanaMap",
                NULL,
                &type,
                (PVOID)lanaMap,
                &lanaMapLength
                );
    if ( error != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Fill in the array or provider information.
    //

    for ( currentProviderName = providerNames, i = 0;
          *currentProviderName != UNICODE_NULL && i < providerCount;
          currentProviderName += wcslen( currentProviderName ) + 1, i++ ) {

        providerInfo[i].Enum = lanaMap[i].Enum;
        providerInfo[i].LanaNumber = lanaMap[i].Lana;
        providerInfo[i].ProtocolNumber = lanaMap[i].Lana;
        providerInfo[i].ProviderName = currentProviderName;
    }

    if (i<providerCount) {
        error = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }


    RtlEnterCriticalSection (&ConfigInfoLock);
    if (ConfigInfo!=NULL) {
        DEREFERENCE_CONFIG_INFO (ConfigInfo);
    }
    if (NetbiosKey==NULL) {
        NetbiosKey = netbiosKey;
        netbiosKey = NULL;
    }

    NetbiosUpdateTime = lastWriteTime;
    ConfigInfo = configInfo;
    LanaMap = lanaMap;
    ProviderInfo = providerInfo;
    ProviderCount = providerCount;
    RtlLeaveCriticalSection (&ConfigInfoLock);

    if (netbiosKey!=NULL && netbiosKey!=NetbiosKey) {
        RegCloseKey (netbiosKey);
    }


    return NO_ERROR;

error_exit:

    if (netbiosKey!=NULL && netbiosKey!=NetbiosKey) {
        RegCloseKey (netbiosKey);
    }

    if ( configInfo != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, configInfo );
    }


    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\nbtinfo.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    NbtInfo.h

    This file contains the NBT Info APIs



    FILE HISTORY:
        Johnl       13-Dec-1993     Created

*/

#ifndef _NBTINFO_H_
#define _NBTINFO_H_

VOID AddrChngNotification( PVOID Context,
                           ULONG OldIpAddress,
                           ULONG NewIpAddress,
                           ULONG NewMask ) ;



#endif //!_NBTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\send.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    send.c

Abstract:

    This module contains code which processes all send NCB's including
    both session and datagram based transfers.

Author:

    Colin Watson (ColinW) 12-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

NTSTATUS
NbSend(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to send a buffer full of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PCB pcb;
    PPCB ppcb;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    LOCK( pfcb, OldIrql );

    ppcb = FindCb( pfcb, pdncb, FALSE);

    if ( ppcb == NULL ) {
        //  FindCb has put the error in the NCB
        UNLOCK( pfcb, OldIrql );
        if ( pdncb->ncb_retcode == NRC_SCLOSED ) {
            //  Tell dll to hangup the connection.
            return STATUS_HANGUP_REQUIRED;
        } else {
            return STATUS_SUCCESS;
        }
    }
    pcb = *ppcb;

    if ( (pcb->DeviceObject == NULL) || (pcb->ConnectionObject == NULL)) {
        UNLOCK( pfcb, OldIrql );
        NCB_COMPLETE( pdncb, NRC_SCLOSED );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    TdiBuildSend (Irp,
        pcb->DeviceObject,
        pcb->ConnectionObject,
        NbCompletionPDNCB,
        pdncb,
        Irp->MdlAddress,
        (((pdncb->ncb_command & ~ASYNCH) == NCBSENDNA ) ||
         ((pdncb->ncb_command & ~ASYNCH) == NCBCHAINSENDNA ))?
                TDI_SEND_NO_RESPONSE_EXPECTED : 0,
        Buffer2Length);

    DeviceObject = pcb->DeviceObject;

    InsertTailList(&pcb->SendList, &pdncb->ncb_next);
    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;
    pdncb->tick_count = pcb->SendTimeout;

    UNLOCK( pfcb, OldIrql );

    IoMarkIrpPending( Irp );
    IoCallDriver (DeviceObject, Irp);

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND submit: %X\n", Irp->IoStatus.Status  ));
    }

    //
    //  Transport will complete the request. Return pending so that
    //  netbios does not complete as well.
    //

    return STATUS_PENDING;

}

NTSTATUS
NbSendDatagram(
    IN PDNCB pdncb,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG Buffer2Length
    )
/*++

Routine Description:

    This routine is called to SendDatagram a buffer full of data.

Arguments:

    pdncb - Pointer to the NCB.

    Irp - Pointer to the request packet representing the I/O request.

    IrpSp - Pointer to current IRP stack frame.

    Buffer2Length - Length of user provided buffer for data.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFCB pfcb = IrpSp->FileObject->FsContext2;
    PPAB ppab;
    PAB pab;
    PDEVICE_OBJECT DeviceObject;
    KIRQL OldIrql;                      //  Used when SpinLock held.

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND Datagram submit, pdncb %lx\n", pdncb  ));
    }

    LOCK( pfcb, OldIrql );
    ppab = FindAbUsingNum( pfcb, pdncb, pdncb->ncb_num );

    if ( ppab == NULL ) {
        //  FindAb has put the error in the NCB
        UNLOCK( pfcb, OldIrql );
        return STATUS_SUCCESS;
    }
    pab = *ppab;

    pdncb->Information.RemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);
    pdncb->Information.RemoteAddress = &pdncb->RemoteAddress;

    pdncb->RemoteAddress.TAAddressCount = 1;
    pdncb->RemoteAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pdncb->RemoteAddress.Address[0].Address[0].NetbiosNameType =
        TDI_ADDRESS_TYPE_NETBIOS;

    if ( (pdncb->ncb_command & ~ASYNCH) == NCBDGSENDBC ) {
        PPAB ppab255 = FindAbUsingNum( pfcb, pdncb, MAXIMUM_ADDRESS );

        if ( ppab255 == NULL ) {
            //  FindAb has put the error in the NCB
            UNLOCK( pfcb, OldIrql );
            return STATUS_SUCCESS;
        }

        pdncb->RemoteAddress.Address[0].AddressLength = (*ppab255)->NameLength;

        RtlMoveMemory(
            pdncb->RemoteAddress.Address[0].Address[0].NetbiosName,
            &(*ppab255)->Name,
            (*ppab255)->NameLength
            );

    } else {

        pdncb->RemoteAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);

        RtlMoveMemory(
            pdncb->RemoteAddress.Address[0].Address[0].NetbiosName,
            pdncb->ncb_callname,
            NCBNAMSZ
            );
    }

    pdncb->Information.UserDataLength = 0;
    pdncb->Information.UserData = NULL;
    pdncb->Information.OptionsLength = 0;
    pdncb->Information.Options = NULL;

    TdiBuildSendDatagram (Irp,
        pab->DeviceObject,
        pab->AddressObject,
        NbCompletionPDNCB,
        pdncb,
        Irp->MdlAddress,
        Buffer2Length,
        &pdncb->Information);

    DeviceObject = pab->DeviceObject;
    pdncb->irp = Irp;
    pdncb->pfcb = pfcb;

    UNLOCK( pfcb, OldIrql );

    IoMarkIrpPending( Irp );
    IoCallDriver (DeviceObject, Irp);

    IF_NBDBG (NB_DEBUG_SEND) {
        NbPrint(( "NB SEND Datagram submit: %X\n", Irp->IoStatus.Status  ));
    }

    //
    //  Transport will complete the request. Return pending so that
    //  netbios does not complete as well.
    //

    return STATUS_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\sys\timer.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains code which implements the receive and send timeouts
    for each connection. Netbios timeouts are specified in 0.5 second units.

    For each application using Netbios there is a single timer started
    when the first connection specifies a non-zero rto or sto. This regular
    1 second pulse is used for all connections by this application. It
    is stopped when the application exits (and closes the connection to
    \Device\Netbios).

    If a send timesout the connection is disconnected as per Netbios 3.0.
    Individual receives can timeout without affecting the session.

Author:

    Colin Watson (ColinW) 15-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "nb.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, NbStartTimer)
#pragma alloc_text(PAGE, NbTimer)
#endif

VOID
RunTimerForLana(
    PFCB pfcb,
    PLANA_INFO plana,
    int index
    );

VOID
NbStartTimer(
    IN PFCB pfcb
    )
/*++

Routine Description:

    This routine starts the timer ticking for this FCB.

Arguments:

    pfcb - Pointer to our FCB.

Return Value:

    none.

--*/
{
    LARGE_INTEGER DueTime;

    PAGED_CODE();

    DueTime.QuadPart = Int32x32To64( 500, -MILLISECONDS );

    // This is the first connection with timeouts specified.

    //
    // set up the timer so that every 500 milliseconds we scan all the
    // connections for timed out receive and sends.
    //

    IF_NBDBG (NB_DEBUG_CALL) {
        NbPrint( ("Start the timer for fcb: %lx\n", pfcb));
    }

    if ( pfcb->TimerRunning == TRUE ) {
        return;
    }

    KeInitializeDpc (
        &pfcb->Dpc,
        NbTimerDPC,
        pfcb);

    KeInitializeTimer (&pfcb->Timer);

    pfcb->TimerRunning = TRUE;

    (VOID)KeSetTimer (
        &pfcb->Timer,
        DueTime,
        &pfcb->Dpc);
}

VOID
NbTimerDPC(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is called to search for timed out send and receive
    requests. This routine is called at raised Irql.

Arguments:

    Context - Pointer to our FCB.

Return Value:

    none.

--*/

{
    PFCB pfcb = (PFCB) Context;

    IoQueueWorkItem( 
        pfcb->WorkEntry, NbTimer, DelayedWorkQueue, pfcb
        );

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);
}

VOID
NbTimer(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
{
    ULONG lana_index;
    int index;
    PFCB pfcb = (PFCB) Context;

    LARGE_INTEGER DueTime;

    PAGED_CODE();

    //
    //  For each network adapter that is allocated, scan each connection.
    //


    LOCK_RESOURCE(pfcb);

    IF_NBDBG (NB_DEBUG_TIMER) {
        NbPrint((" NbTimeout\n" ));
    }

    if ( pfcb->TimerRunning != TRUE ) {

        //
        // Driver is being closed. We are trying to cancel the timer
        // but the dpc was already fired. Set the timer cancelled event
        //  to the signalled state and exit.
        //

        UNLOCK_RESOURCE(pfcb);
        KeSetEvent( pfcb->TimerCancelled, 0, FALSE);
        return;
    }

    for ( lana_index = 0; lana_index <= pfcb->MaxLana; lana_index++ ) {

        //  For each network.

        PLANA_INFO plana = pfcb->ppLana[lana_index];

        if (( plana != NULL ) &&
            ( plana->Status == NB_INITIALIZED)) {

            //  For each connection on that network.

            for ( index = 1; index <= MAXIMUM_CONNECTION; index++) {

                if ( plana->ConnectionBlocks[index] != NULL ) {

                    RunTimerForLana(pfcb, plana, index);
                }
            }
        }

    }

    DueTime.QuadPart = Int32x32To64( 500, -MILLISECONDS );

    (VOID)KeSetTimer (
            &pfcb->Timer,
            DueTime,
            &pfcb->Dpc);

    UNLOCK_RESOURCE(pfcb);
}

VOID
RunTimerForLana(
    PFCB pfcb,
    PLANA_INFO plana,
    int index
    )
{

    KIRQL OldIrql;          //  Used when SpinLock held.
    PPCB ppcb;
    PCB pcb;

    ppcb = &plana->ConnectionBlocks[index];
    pcb = *ppcb;

    if (( pcb->Status != SESSION_ESTABLISHED ) &&
        ( pcb->Status != HANGUP_PENDING )) {
            //  Only examine valid connections.
            return;
    }

    LOCK_SPINLOCK( pfcb, OldIrql );

    if (( pcb->ReceiveTimeout != 0 ) &&
        ( !IsListEmpty( &pcb->ReceiveList))) {
        PDNCB pdncb;
        PLIST_ENTRY ReceiveEntry = pcb->ReceiveList.Flink;

        pdncb = CONTAINING_RECORD( ReceiveEntry, DNCB, ncb_next);

        if ( pdncb->tick_count <= 1) {
            PIRP Irp = pdncb->irp;

            // Read request timed out.

            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout Read pncb: %lx\n", pdncb));
            }

            NCB_COMPLETE( pdncb, NRC_CMDTMO );

            RemoveEntryList( &pdncb->ncb_next );

            IoAcquireCancelSpinLock(&Irp->CancelIrql);

            //
            //  Remove the cancel request for this IRP. If its cancelled then its
            //  ok to just process it because we will be returning it to the caller.
            //

            Irp->Cancel = FALSE;

            IoSetCancelRoutine(Irp, NULL);

            IoReleaseCancelSpinLock(Irp->CancelIrql);

            //  repair the Irp so that the NCB gets copied back.
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information =
            FIELD_OFFSET( DNCB, ncb_cmd_cplt );
            IoCompleteRequest( Irp, IO_NETWORK_INCREMENT);

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Read pdncb: %lx, count: %x\n", pdncb, pdncb->tick_count));
            }
            pdncb->tick_count -= 1;
        }
    }

    if (( pcb->SendTimeout != 0 ) &&
        (!IsListEmpty( &pcb->SendList))) {
        PDNCB pdncb;
        PLIST_ENTRY SendEntry = pcb->SendList.Flink;

        pdncb = CONTAINING_RECORD( SendEntry, DNCB, ncb_next);
        if ( pdncb->tick_count <= 1) {
            // Send request timed out- hangup connection.

            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout send pncb: %lx\n", pdncb));
            }

            NCB_COMPLETE( pdncb, NRC_CMDTMO );

            pcb->Status = SESSION_ABORTED;

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            CloseConnection( ppcb, 1000 );

            //
            //  No need to worry about looking for a timed out hangup, the session
            //  will be closed as soon as the transport cancels the send.
            //

            return;

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Write pdncb: %lx, count: %x\n", pdncb, pdncb->tick_count));
            }
            pdncb->tick_count -= 1;
        }
    }

    if (( pcb->pdncbHangup != NULL ) &&
        ( pcb->Status == HANGUP_PENDING )) {
        if ( pcb->pdncbHangup->tick_count <= 1) {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Timeout send pncb: %lx\n", pcb->pdncbHangup));
            }

            NCB_COMPLETE( pcb->pdncbHangup, NRC_CMDTMO );

            UNLOCK_SPINLOCK( pfcb, OldIrql );

            AbandonConnection( ppcb );

            LOCK_SPINLOCK( pfcb, OldIrql );

        } else {
            IF_NBDBG (NB_DEBUG_TIMER) {
                NbPrint(("Tick Hangup pdncb: %lx, count: %x\n",
                                    pcb->pdncbHangup,
                                    pcb->pdncbHangup->tick_count));
            }
            pcb->pdncbHangup->tick_count -= 1;
        }
    }

    UNLOCK_SPINLOCK( pfcb, OldIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\debug.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Debug.h

Abstract:

    This file contains debug printing constants for NBT.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#ifndef _DEBUGNBT_H
#define _DEBUGNBT_H

//
// Debug support.. this macro defines a check on a global flag that
// selectively enables and disables debugging in different parts of NBT
// NbtDebug is a global ULONG declared in driver.c
//
#if DBG
extern ULONG    NbtDebug;
#endif // DBG

// Assert support

#if DBG
#undef ASSERT
#undef ASSERTMSG

#define ASSERT( exp )                   \
    if (!(exp)) {                       \
        DbgPrint( "Assertion \"%s\" failed at file %s, line %d\n", #exp, __FILE__, __LINE__ );  \
        if (NbtConfig.BreakOnAssert)    \
            DbgBreakPoint();            \
    }

#define ASSERTMSG( msg, exp )           \
    if (!exp) {                         \
        DbgPrint( "Message: %s\nAssertion \"%s\" failed at file %s, line %d\n", msg, #exp, __FILE__, __LINE__ );    \
        if (NbtConfig.BreakOnAssert)    \
            DbgBreakPoint();            \
    }

#endif

#if DBG
#define IF_DBG(flags)   if(NbtDebug & flags)

#define NBT_DEBUG_REGISTRY     0x00000001    // registry.c
#define NBT_DEBUG_DRIVER       0x00000002    // driver.c
#define NBT_DEBUG_NTUTIL       0x00000004    // ntutil.c
#define NBT_DEBUG_TDIADDR      0x00000008    // tdiaddr.c
#define NBT_DEBUG_TDICNCT      0x00000010    // tidaddr.c
#define NBT_DEBUG_NETBIOS_EX   0x00000020    // NETBIOS_EX address type debugging
#define NBT_DEBUG_NAME         0x00000040    // name.c
#define NBT_DEBUG_NTISOL       0x00000080    // ntisol.c
#define NBT_DEBUG_NBTUTILS     0x00000100    // nbtutils.c
#define NBT_DEBUG_NAMESRV      0x00000200    // namesrv.c
#define NBT_DEBUG_HNDLRS       0x00000400    // hndlrs.c
#define NBT_DEBUG_PROXY        0x00000800    // proxy.c
#define NBT_DEBUG_HASHTBL      0x00001000    // hashtbl.c
#define NBT_DEBUG_UDPSEND      0x00002000    // udpsend.c
#define NBT_DEBUG_TDIOUT       0x00004000    // tdiout.c
#define NBT_DEBUG_SEND         0x00008000    // sends
#define NBT_DEBUG_RCV          0x00010000    // rcvs
#define NBT_DEBUG_RCVIRP       0x00020000    // rcv irp processing
#define NBT_DEBUG_INDICATEBUFF 0x00040000    // tdihndlrs.c indicate buffer
#define NBT_DEBUG_REFRESH      0x00080000    // refresh logic
#define NBT_DEBUG_REF          0x00100000    // reference counts
#define NBT_DEBUG_DISCONNECT   0x00200000    // Disconnects
#define NBT_DEBUG_FILLIRP      0x00400000    // Filling the Irp(Rcv)
#define NBT_DEBUG_LMHOST       0x00800000    // Lmhost file stuff
#define NBT_DEBUG_FASTPATH     0x01000000    // Rcv code - fast path
#define NBT_DEBUG_WINS         0x02000000    // Wins Interface debug
#define NBT_DEBUG_PNP_POWER    0x04000000    // NT PNP debugging
#define NBT_DEBUG_HANDLES      0x08000000    // To debug Handle RefCount issues
#define NBT_DEBUG_TDIHNDLR     0x10000000    // tdihndlr.c
#define NBT_DEBUG_MEMFREE      0x20000000    // memory alloc/free
#define NBT_DEBUG_KDPRINTS     0x80000000    // KdPrint output

//----------------------------------------------------------------------------
//
// Remove Debug spew on Debug builds!
//
#ifndef VXD
#undef KdPrint
#define KdPrint(_x_)                            \
   if (NbtDebug & NBT_DEBUG_KDPRINTS)           \
   {                                            \
        DbgPrint _x_;                           \
   }
#endif  // !VXD
//----------------------------------------------------------------------------

#else
#define IF_DBG(flags)
#endif

/*
 * Software Tracing
 */
#define WPP_CONTROL_GUIDS   WPP_DEFINE_CONTROL_GUID(CtlGuid,(bca7bd7f,b0bf,4051,99f4,03cfe79664c1), \
        WPP_DEFINE_BIT(NBT_TRACE_PNP)                                       \
        WPP_DEFINE_BIT(NBT_TRACE_NAMESRV)                                   \
        WPP_DEFINE_BIT(NBT_TRACE_INBOUND)                                   \
        WPP_DEFINE_BIT(NBT_TRACE_OUTBOUND)                                  \
        WPP_DEFINE_BIT(NBT_TRACE_DISCONNECT)                                \
        WPP_DEFINE_BIT(NBT_TRACE_SEND)                                      \
        WPP_DEFINE_BIT(NBT_TRACE_RECV)                                      \
        WPP_DEFINE_BIT(NBT_TRACE_SENDDGRAM)                                 \
        WPP_DEFINE_BIT(NBT_TRACE_RECVDGRAM)                                 \
        WPP_DEFINE_BIT(NBT_TRACE_LOCALNAMES)                                \
        WPP_DEFINE_BIT(NBT_TRACE_REMOTECACHE)                               \
        WPP_DEFINE_BIT(NBT_TRACE_PROXY)                                     \
        WPP_DEFINE_BIT(NBT_TRACE_VERBOSE)                                   \
    )

/*
 * Software tracing is available only in checked build
 */
#if DBG
    #ifndef _NBT_WMI_SOFTWARE_TRACING_
        #define _NBT_WMI_SOFTWARE_TRACING_
    #endif
#else
    #ifdef _NBT_WMI_SOFTWARE_TRACING_
        #undef _NBT_WMI_SOFTWARE_TRACING_
    #endif
#endif

#ifndef _NBT_WMI_SOFTWARE_TRACING_
/*
 * Totally turn off software tracing
 */
#   define NbtTrace(l,m)
#   define WPP_ENABLED()            (0)
#   define WPP_LEVEL_ENABLED(LEVEL) (0)
#define WPP_LOGNBTNAME(x)
#else
int nbtlog_strnlen(char *p, int n);
static CHAR NBTLOGNAME=0;
#define WPP_LOGNBTNAME(x) \
    WPP_LOGPAIR(nbtlog_strnlen((char*)x,15),x) WPP_LOGPAIR(1,&NBTLOGNAME)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\ctemacro.h ===
//----------------------------------------------------------------------------
//
//  ctemacro.c
//
//  This file contains macros for the common transport environment - similar
//  to the way that ctestuff.c contains common procedures.
//
#ifndef _CTEMACRO_H_
#define _CTEMACRO_H_

#ifndef VXD
#define NT 1
#include <cxport.h>

#ifdef  _PNP_POWER_
#define _PNP_POWER_DBG_ 1
#endif  // _PNP_POWER_

char LastLockFile[255] ;
int  LastLockLine ;
char LastUnlockFile[255] ;
int LastUnlockLine ;
#endif


#ifdef VXD

#ifdef DEBUG
#define DBG_PRINT   1
#else
#endif  // DEBUG

#endif  // VXD

//----------------------------------------------------------------------------
#define IS_UNIQUE_ADDR(IpAddress) ((((PUCHAR)(&IpAddress))[3]) < ((UCHAR)0xe0))
//----------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// This HACK is being to avoid NetBT from logging Events whenever the Messenger
// name goes into conflict.  This is TEMPORARY ONLY, and the proper fix (post NT5)
// is:
// 1)   Change the Duplicate name error to a Warning
// 2)   Log the name + Device on which error occurred + IP address
//
#define IS_MESSENGER_NAME(_pName)   \
    (_pName[15] == 0x03)
//------------------------------------------------------------------------------


//  VOID
//  NTDereferenceObject(
//        PFILE_OBJECT   pFileObject
//        )

/*++
Routine Description:

    This routine dereferences an object.


--*/
#ifdef VXD
//
//  No equivalent for Vxd
//
#define NTDereferenceObject( fileobject )
#else //VXD
#define NTDereferenceObject( fileobject ) ObDereferenceObject( fileobject)
#endif

//----------------------------------------------------------------------------
//  VOID
//  CHECK_PTR(
//        PVOID   SpinLock,
//        )

/*++
Routine Description:

    This routine checks if a ptr points to freed memory


--*/

#if DBG
#define CHECK_PTR(_Ptr) \
    ASSERT(MmIsAddressValid(_Ptr));
#else

#define CHECK_PTR(_Ptr)
#endif


#ifndef VXD
/*++
    This macro verifies that an IRP passed to IoCallDriver() is
    set up to call the CompletionRoutine in all cases.
--*/
#if DBG
#define CHECK_COMPLETION(__pIrp)\
            {\
                PIO_STACK_LOCATION __pIrpSp = IoGetNextIrpStackLocation(__pIrp);\
                BOOL CompletionWillBeCalled =\
                    ( __pIrpSp->Control & ( SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL ) )\
                    == ( SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL );\
                ASSERT ( CompletionWillBeCalled );\
            }
#else   // DBG
#define CHECK_COMPLETION(__pIrp)
#endif  // DBG
#endif  // VXD

//
// Macros
//

//++
//
// LARGE_INTEGER
// CTEConvertMillisecondsTo100ns(
//     IN LARGE_INTEGER MsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     MsTime - Time in milliseconds.
//
// Return Value:
//
//     Time in hundreds of nanoseconds.
//
//--

#define CTEConvertMillisecondsTo100ns(MsTime) \
            RtlExtendedIntegerMultiply(MsTime, 10000)


//++
//
// LARGE_INTEGER
// CTEConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

    // Used in the conversion of 100ns times to milliseconds.
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#define SHIFT10000 13
extern LARGE_INTEGER Magic10000;

#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)

//----------------------------------------------------------------------------
//
//  CTELockHandle
//

#ifndef VXD

    //
    //  The Spinlock structure is different between the NT driver and the VXD
    //  driver.  This macro is defined in cxport.h when compiling as a VXD.
    //
    #define CTELockHandle               KIRQL
#endif

//----------------------------------------------------------------------------
//  VOID
//  CTESpinLock(
//        tCONNECTELE   Structure,
//        CTELockHandle OldIrqLevel
//        )

/*++
Routine Description:

    This Routine acquires a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/
#ifndef VXD
#if DBG
#define CTESpinLock(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    AcquireSpinLockDebug(&(DataStruct)->LockInfo,&OldIrqLevel,__LINE__); \
    strcpy( LastLockFile, __FILE__ ) ;                                    \
    LastLockLine = __LINE__ ;                                             \
}
#else
#define CTESpinLock(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    CTEGetLock(&(DataStruct)->LockInfo.SpinLock,&(OldIrqLevel));                       \
}
#endif
#else
#ifdef DEBUG

#define CTESpinLock(DataStruct,OldIrqLevel)                               \
{                                                                         \
    CTEGetLock( &(DataStruct)->LockInfo.SpinLock, &OldIrqLevel ) ;                 \
}

#else
#define CTESpinLock(DataStruct,OldIrqLevel)
#endif // !DEBUG
#endif


//----------------------------------------------------------------------------
//  VOID
//  CTESpinFree(
//        PVOID   SpinLock,
//        CTELockHandle OldIrqLevel
//        )
/*++
Routine Description:

    This Routine releases a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinFree(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    strcpy( LastUnlockFile, __FILE__ ) ;                                      \
    LastUnlockLine = __LINE__ ;                                               \
    FreeSpinLockDebug(&(DataStruct)->LockInfo,OldIrqLevel,__LINE__); \
}
#else
#define CTESpinFree(DataStruct,OldIrqLevel)                    \
{                                                              \
    CTEFreeLock((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock),(OldIrqLevel));  \
}
#endif
#else
#ifdef DEBUG

#define CTESpinFree(DataStruct,OldIrqLevel)                                   \
{                                                                             \
    CTEFreeLock( &(DataStruct)->LockInfo.SpinLock, OldIrqLevel ) ;                     \
}

#else
#define CTESpinFree(DataStruct,OldIrqLevel)
#endif
#endif
//----------------------------------------------------------------------------
//  VOID
//  CTESpinLockAtDpc(
//        tCONNECTELE   Structure
//        )

/*++
Routine Description:

    This Routine acquires a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinLockAtDpc(DataStruct)                                       \
{                                                                          \
    AcquireSpinLockAtDpcDebug(&(DataStruct)->LockInfo,__LINE__);                     \
    strcpy( LastLockFile, __FILE__ ) ;                                    \
    LastLockLine = __LINE__ ;                                             \
}
#else // DBG
#define CTESpinLockAtDpc(DataStruct)                                       \
{                                                                          \
    CTEGetLockAtDPC((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock), 0);               \
}
#endif // DBG
#else // VXD
#define CTESpinLockAtDpc(DataStruct)
#endif  // VXD


//----------------------------------------------------------------------------
//  VOID
//  CTESpinFreeAtDpc(
//        PVOID   SpinLock,
//        CTELockHandle OldIrqLevel
//        )
/*++
Routine Description:

    This Routine releases a spin lock.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#if DBG
#define CTESpinFreeAtDpc(DataStruct)                                        \
{                                                                           \
    strcpy( LastUnlockFile, __FILE__ ) ;                                    \
    LastUnlockLine = __LINE__ ;                                             \
    FreeSpinLockAtDpcDebug(&(DataStruct)->LockInfo,__LINE__);                        \
}
#else // DBG
#define CTESpinFreeAtDpc(DataStruct)                    \
{                                                              \
    CTEFreeLockFromDPC((PKSPIN_LOCK)(&(DataStruct)->LockInfo.SpinLock), 0);  \
}
#endif // DBG
#else  // VXD
#define CTESpinFreeAtDpc(DataStruct)
#endif // VXD


//----------------------------------------------------------------------------
//
//  VOID
//  CTEVerifyHandle(
//      IN  PVOID   pDataStruct,
//      IN  ULONG   Verifier,
//      IN  VOID    TypeofStruct,
//      OUT NTSTATUS *pRet
//        )
/*++
Routine Description:

    This Routine checks that a handle pts to a data structure with the
    correct verifier in it.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#if DBG
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)    \
{                                                                     \
        if ((_pDataStruct) &&                                         \
            ((((_TypeofStruct *)(_pDataStruct))->Verify) == (_Verifier)))    \
             *_ret=STATUS_SUCCESS;                                    \
        else                                                          \
        {                                                             \
            ASSERTMSG("Invalid Handle Passed to Nbt",0);              \
            return(STATUS_INVALID_HANDLE);                            \
        }                                                             \
}
#else
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)
#endif // DBG

#else
#define CTEVerifyHandle(_pDataStruct,_Verifier,_TypeofStruct,_ret)    \
{                                                                     \
    if ((((_TypeofStruct *)(_pDataStruct))->Verify) == (_Verifier))    \
         *_ret=STATUS_SUCCESS;                                    \
    else                                                          \
        return(STATUS_INVALID_HANDLE);                            \
}
#endif

#define NBT_VERIFY_HANDLE(s, V)                                           \
    ((s) && (s->Verify == V))

#define NBT_VERIFY_HANDLE2(s, V1, V2)                                      \
    ((s) && ((s->Verify == V1) || (s->Verify == V2)))


//----------------------------------------------------------------------------
//
//  VOID
//      CTEIoComplete( IN  CTE_IRP       * pIrp,
//                     IN  NTSTATUS        StatusCompletion,
//                     IN  ULONG           cbBytes
//                   );
//
/*++
Routine Description:

    Completes the requested IO packet.  For NT this involves calling the IO
    subsytem.  As a VxD, the Irp is a pointer to the NCB so we set the status
    variables appropriately and call the post routine if present.

Arguments:

    pIrp - Packet to complete
    StatusCompletion - Status of the completion
    cbBytes - Dependent on the type of IO

Return Value:

--*/
#ifndef VXD

#define PCTE_MDL PMDL
#define CTE_IRP  IRP
#define PCTE_IRP PIRP
#define CTE_ADDR_HANDLE PFILE_OBJECT

#define CTEIoComplete( pIrp, StatusCompletion, cbBytes )         \
    NTIoComplete( pIrp, StatusCompletion, cbBytes )

#else
#define PCTE_MDL        PVOID
#define CTE_IRP         NCB
#define PCTE_IRP        PNCB
#define PIRP            PNCB
#define CTE_ADDR_HANDLE PVOID
#define PFILE_OBJECT    CTE_ADDR_HANDLE

#define CTEIoComplete( pIrp, StatusCompletion, cbBytes )          \
    VxdIoComplete( pIrp, StatusCompletion, cbBytes )

#endif

//----------------------------------------------------------------------------
//
//  ULONG
//      CTEMemCmp( PVOID S1, PVOID S2, ULONG Length )
//
/*++
Routine Description:

    Compares two memory regions and returns the byte count at which the
    compare failed.  The return value will equal Length if the memory
    regions are identical.

Arguments:

    S1, S2 - Memory source 1 and 2 to compare
    Length - Count of bytes to compare

Return Value:

--*/
//
// CXPORT.H defines this macro differntly and they did it after we had
// it here, so undef their definition so we can use ours without getting
// warnings.
//
#undef CTEMemCmp

#ifndef VXD
#define CTEMemCmp( S1, S2, Length ) RtlCompareMemory( (S1), (S2), (Length) )
#else
//
//  Same thing as RtlCompareMemory except avoid standard call decoration
//
#define CTEMemCmp( S1, S2, Length ) VxdRtlCompareMemory( (S1), (S2), (Length) )
#endif

//----------------------------------------------------------------------------
//
//  LOGICAL
//      CTEMemEqu( PVOID S1, PVOID S2, ULONG Length )
//
/*++
Routine Description:

    Compares two memory regions and returns a value of TRUE is the regions
    match. Otherwise, FALSE is returned.

Arguments:

    S1, S2 - Memory source 1 and 2 to compare
    Length - Count of bytes to compare

Return Value:

--*/

#ifndef VXD
#define CTEMemEqu( S1, S2, Length ) RtlEqualMemory( (S1), (S2), (Length) )
#else
//
//  Same thing as RtlEqualMemory except avoid standard call decoration
//
#define CTEMemEqu( S1, S2, Length ) ( VxdRtlCompareMemory( (S1), (S2), (Length) ) == (Length) )
#endif

//----------------------------------------------------------------------------
//
//  Define away any try and except clauses when we are a VXD
//

#ifndef VXD
#define CTE_try     try
#define CTE_except  except
#else
#define CTE_try
#define CTE_except( x ) if ( 0 )
#endif

//
//  Misc. memory routines that get mapped when compiling as a VXD
//

#ifdef VXD
#define CTEZeroMemory( pDest, uLength )  CTEMemSet( pDest, 0, uLength )
#define CTEMemFree( p )                  CTEFreeMem( p )
#endif
//----------------------------------------------------------------------------
/*++
PVOID
CTEAllocMem(
        USHORT  Size
        )
Routine Description:

    This Routine allocates memory for NT drivers by calling ExAllocatePool
    It uses the definition of CTEAllocMem from cxport.h

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,' tbN')
#endif
#endif

#ifndef VXD
#ifdef POOL_TAGGING
#define NBT_TAG(x) (((x)<<24)|'\0tbN')
#define NBT_TAG2(x) ( ((x & 0xff)<<24) | ((x & 0xff00)<<8) | '\0bN' )
#define NbtAllocMem(size,__tag__) ExAllocatePoolWithTag(NonPagedPool,(size),(__tag__))
#else  // POOL_TAGGING
#define NBT_TAG(x) 0
#define NBT_TAG2(x) 0
#define NbtAllocMem(size,__tag__) ExAllocatePool(NonPagedPool,(size))
#endif // POOL_TAGGING
#else  // POOL_TAGGING
#define NBT_TAG(x) 0
#define NBT_TAG2(x) 0
#define NbtAllocMem(size,__tag__) CTEAllocMem((size))
#endif // VXD

#ifdef VXD
#ifdef DEBUG
#undef CTEAllocMem
#define CTEAllocMem DbgAllocMem
#undef CTEFreeMem
#define CTEFreeMem  DbgFreeMem
#undef CTEMemFree
#define CTEMemFree  DbgFreeMem
PVOID DbgAllocMem( DWORD ReqSize );
VOID DbgFreeMem( PVOID  pBufferToFree );
VOID DbgMemCopy( PVOID pDestBuf, PVOID pSrcBuf, ULONG Length );
#endif
#endif

//----------------------------------------------------------------------------
/*++
PVOID
CTEAllocInitMem(
        ULONG  Size
        )
Routine Description:

    This Routine allocates memory and if nbt is a Vxd and it's called during
    DeviceInit time, will refill the heap and retry the allocation before
    failing.

Arguments:

    Size - the number of bytes to allocate

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

#ifndef VXD
#define CTEAllocInitMem(Size)   \
     ExAllocatePool(NonPagedPool, Size)
#endif

//----------------------------------------------------------------------------
/*++
VOID
CTEMemFree(
        PVOID  pMem
        )
Routine Description:

    This Routine frees memory for NT drivers by calling ExFreePool

Arguments:

    pMem - ptr to memory

Return Value:

    NONE

--*/
#ifndef VXD
#define CTEMemFree(pMem)    \
{                             \
    IF_DBG(NBT_DEBUG_MEMFREE)     \
    KdPrint(("Nbt.CTEMemFree: pmemfree = %X,lin %d in file %s\n",pMem,__LINE__,__FILE__)); \
    CTEFreeMem(pMem);  \
}
#endif

//----------------------------------------------------------------------------
/*++
VOID
CTEZeroMemory(
        PVOID   pDest,
        ULONG   uLength
        )
Routine Description:

    This Routine sets memory to a single byte value

Arguments:

    pDest       - dest address
    uLength     - number to zero

Return Value:

    NONE

--*/

#ifndef VXD
#define CTEZeroMemory(pDest,uLength)   \
    RtlZeroMemory(pDest,uLength)
#endif

//----------------------------------------------------------------------------
/*++
NTSTATUS
CTEReadIniString(
        HANDLE    ParmHandle,
        LPTSTR    KeyName,
        LPTSTR  * ppStringBuff
        )
Routine Description:

    This routine retrieves a string from the users configuration profile

Arguments:

    ParmHandle   - Registry handle
    KeyName      - Name of value to retrieve
    ppStringBuff - Pointer to allocated buffer containing found string

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#define CTEReadIniString( ParmHandle, KeyName, ppStringBuff )   \
     NTReadIniString( ParmHandle, KeyName, ppStringBuff )
#else
#define CTEReadIniString( ParmHandle, KeyName, ppStringBuff )   \
     VxdReadIniString( KeyName, ppStringBuff )
#endif

//----------------------------------------------------------------------------
/*++
ULONG
CTEReadSingleHexParameter(
        HANDLE    ParmHandle,
        LPTSTR    KeyName,
        ULONG     Default,
        ULONG     Minimum
        )
Routine Description:

    This routine retrieves a value in hex from the .ini file or registry

Arguments:

    ParmHandle   - Registry handle
    KeyName      - Name of value to retrieve
    Default      - Default value if not present
    Minimum      - Minimum value if present

Return Value:

    NTSTATUS

--*/

#ifndef VXD
#define CTEReadSingleIntParameter( ParmHandle, KeyName, Default, Minimum ) \
    NbtReadSingleParameter( ParmHandle, KeyName, Default, Minimum )

#define CTEReadSingleHexParameter( ParmHandle, KeyName, Default, Minimum ) \
    NbtReadSingleParameter( ParmHandle, KeyName, Default, Minimum )
#else
#define CTEReadSingleIntParameter( ParmHandle, KeyName, Default, Minimum ) \
    GetProfileInt( ParmHandle, KeyName, Default, Minimum )

#define CTEReadSingleHexParameter( ParmHandle, KeyName, Default, Minimum ) \
    GetProfileHex( ParmHandle, KeyName, Default, Minimum )
#endif

//----------------------------------------------------------------------------
//
// NBT_REFERENCE_XXX(_pXXX)
//
/*++
Routine Description:

    Increments the reference count

Arguments:

    - the structure to be referenced

Return Value:
    None
--*/

//----------------------------------------------------------------------------
#define NBT_REFERENCE_CONNECTION( _pConnEle, _RefContext )               \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pConnEle=<%x:%d->%d>, <%d:%s>\n",     \
            _pConnEle,_pConnEle->RefCount,(_pConnEle->RefCount+1),__LINE__,__FILE__));  \
    ASSERT ((_pConnEle->Verify==NBT_VERIFY_CONNECTION) || (_pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN)); \
    InterlockedIncrement(&_pConnEle->RefCount);             \
    ASSERT (++_pConnEle->References[_RefContext]);          \
}

#define NBT_REFERENCE_LOWERCONN( _pLowerConn, _RefContext )              \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pLowerConn=<%x:%d->%d>, <%d:%s>\n",   \
            _pLowerConn,_pLowerConn->RefCount,(_pLowerConn->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (_pLowerConn->Verify == NBT_VERIFY_LOWERCONN);   \
    InterlockedIncrement(&_pLowerConn->RefCount);           \
    ASSERT (++_pLowerConn->References[_RefContext]);        \
}

#define NBT_REFERENCE_CLIENT( _pClient )                  \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pClient=<%x:%d->%d>, <%d:%s>\n",     \
            _pClient,_pClient->RefCount,(_pClient->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (NBT_VERIFY_HANDLE (_pClient, NBT_VERIFY_CLIENT));         \
    ASSERT (NBT_VERIFY_HANDLE (_pClient->pAddress, NBT_VERIFY_ADDRESS));         \
    InterlockedIncrement(&_pClient->RefCount);              \
}

#define NBT_REFERENCE_ADDRESS( _pAddrEle, _Context )        \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pAddrEle=<%x:%d->%d>, <%d:%s>\n",     \
            _pAddrEle,_pAddrEle->RefCount,(_pAddrEle->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (NBT_VERIFY_HANDLE (_pAddrEle, NBT_VERIFY_ADDRESS));       \
    InterlockedIncrement(&_pAddrEle->RefCount);             \
}

#define NBT_REFERENCE_NAMEADDR(_pNameAddr, _RefContext)     \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pNameAddr=<%x:%d->%d>, <%d:%s>\n",    \
            _pNameAddr,_pNameAddr->RefCount,(_pNameAddr->RefCount+1),__LINE__,__FILE__));    \
    ASSERT ((_pNameAddr->Verify == LOCAL_NAME) ||           \
            (_pNameAddr->Verify == REMOTE_NAME));           \
    InterlockedIncrement(&_pNameAddr->RefCount);            \
    ASSERT (++_pNameAddr->References[_RefContext]);         \
}

#define NBT_REFERENCE_TRACKER( _pTracker )                  \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t++pTracker=<%x:%d->%d>, <%d:%s>\n",     \
            _pTracker,_pTracker->RefCount,(_pTracker->RefCount+1),__LINE__,__FILE__));    \
    ASSERT (_pTracker->Verify == NBT_VERIFY_TRACKER);       \
    InterlockedIncrement(&_pTracker->RefCount);             \
}

//----------------------------------------------------------------------------
//
// NBT_DEREFERENCE_XXX(_pXXX)
//
/*++
Routine Description:

    Wrapper for the real Derefencing routine

Arguments:

    - the structure to be de-referenced

Return Value:
    None
--*/

//----------------------------------------------------------------------------
#define NBT_DEREFERENCE_LOWERCONN( _pLowerConn, _RefContext, fJointLockHeld )   \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pLowerConn=<%x:%d->%d>, <%d:%s>\n",   \
            _pLowerConn,_pLowerConn->RefCount,(_pLowerConn->RefCount-1),__LINE__,__FILE__));                \
    ASSERT (_pLowerConn->Verify == NBT_VERIFY_LOWERCONN);   \
    NbtDereferenceLowerConnection(_pLowerConn, _RefContext, fJointLockHeld);    \
}

#define NBT_SWAP_REFERENCE_LOWERCONN(_pLowerConn, _RefContextOld, _RefContextNew, _fLowerLockHeld)    \
{                                                           \
    CTELockHandle       OldIrqSwap;                         \
                                                            \
    if (!_fLowerLockHeld)                                   \
    {                                                       \
        CTESpinLock (_pLowerConn, OldIrqSwap);              \
    }                                                       \
    ASSERT (NBT_VERIFY_HANDLE (_pLowerConn, NBT_VERIFY_LOWERCONN));   \
    ASSERT (_pLowerConn->RefCount);                         \
    ASSERT (++_pLowerConn->References[_RefContextNew]);     \
    ASSERT (_pLowerConn->References[_RefContextOld]--);     \
    if (!_fLowerLockHeld)                                   \
    {                                                       \
        CTESpinFree (_pLowerConn, OldIrqSwap);              \
    }                                                       \
}

#define NBT_DEREFERENCE_NAMEADDR(_pNameAddr, _RefContext, _fLocked) \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pNameAddr=<%x:%d->%d>, <%d:%s>\n",    \
            _pNameAddr,_pNameAddr->RefCount,(_pNameAddr->RefCount-1),__LINE__,__FILE__));                   \
    ASSERT ((_pNameAddr->Verify==LOCAL_NAME) || (_pNameAddr->Verify==REMOTE_NAME));                         \
    NbtDereferenceName(_pNameAddr, _RefContext, _fLocked);  \
}

#define NBT_DEREFERENCE_TRACKER( _pTracker, _fLocked )      \
{                                                           \
    IF_DBG(NBT_DEBUG_REF)                                   \
        KdPrint(("\t--pTracker=<%x:%d->%d>, <%d:%s>\n",     \
            _pTracker,_pTracker->RefCount,(_pTracker->RefCount-1),__LINE__,__FILE__));                      \
    ASSERT (_pTracker->Verify == NBT_VERIFY_TRACKER);       \
    NbtDereferenceTracker(_pTracker, _fLocked);             \
}

#define NBT_DEREFERENCE_CONNECTION( _pConnEle, _RefContext )\
{                                                           \
    NbtDereferenceConnection(_pConnEle, _RefContext);       \
}

#define NBT_DEREFERENCE_CLIENT( _pClient )                  \
{                                                           \
    NbtDereferenceClient(_pClient);                         \
}

#define NBT_DEREFERENCE_ADDRESS( _pAddressEle, _Context )   \
{                                                           \
    NbtDereferenceAddress(_pAddressEle, _Context);          \
}

//----------------------------------------------------------------------------
//
// CTEExInitializeResource(Resource)
//
/*++
Routine Description:

    Initializes the Resource structure by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExInitializeResource( _Resource )            \
    ExInitializeResourceLite(_Resource)
#else
#define CTEExInitializeResource( _Resource )
#endif

//----------------------------------------------------------------------------
//
// CTEExAcquireResourceExclusive(Resource,Wait)
//
/*++
Routine Description:

    Acquires the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExAcquireResourceExclusive( _Resource, _Wait )   \
    KeEnterCriticalRegion();                                \
    ExAcquireResourceExclusiveLite(_Resource,_Wait);
#else
#define CTEExAcquireResourceExclusive( _Resource, _Wait )
#endif

//----------------------------------------------------------------------------
//
// CTEExReleaseResource(Resource)
//
/*++
Routine Description:

    Releases the Resource by calling an excutive support routine.

Arguments:


Return Value:

    None

--*/
#ifndef VXD
#define CTEExReleaseResource( _Resource )       \
    ExReleaseResourceLite(_Resource);               \
    KeLeaveCriticalRegion();
#else
#define CTEExReleaseResource( _Resource )

#endif

//----------------------------------------------------------------------------
//
// PUSH_LOCATION(Spot)
//
/*++
Routine Description:

    This macro is used for debugging the receive code.  It puts a byte value
    into a circular list of byte values so that previous history can be traced
    through the receive code.

Arguments:

    Spot    - the location to put in the list

Return Value:

    None

--*/
#if DBG
extern unsigned char  pLocBuff[256];
extern unsigned char  CurrLoc;
#define PUSH_LOCATION( _Spot) \
{                                  \
    if (++CurrLoc == 256)           \
    {                               \
        CurrLoc = 0;                \
    }                               \
    pLocBuff[CurrLoc] = _Spot;      \
}
#else
#define PUSH_LOCATION( _Spot )
#endif

#if DBG
extern unsigned char  Buff[256];
extern unsigned char  Loc;
#define LOCATION( _Spot) \
{                                  \
    if (++Loc == 256)           \
    {                               \
        Loc = 0;                \
    }                               \
    Buff[Loc] = _Spot;      \
}
#else
#define LOCATION( _Spot )
#endif

//----------------------------------------------------------------------------
//
// CTEQueueForNonDispProcessing( DelayedWorkerRoutine,
//                               pTracker,
//                               pClientContext,
//                               ClientCompletion,
//                               pDeviceContext,
//                               fJointLockHeld) ;
//
/*++
Routine Description:

    This macro queues a request for a callback that can't be performed in
    the current context (such as dispatch processing).

    In NT, this calls NTQueueToWorkerThread.

    As a VxD, we schedule an event that calls the specified routine.

Arguments:

    pTracker - pointer to a tDGRAM_SEND_TRACKING structure (or NULL).
    pClietContext - Context to pass to CallBackRoutine
    ClientCompletion -
    CallBackRoutine - Procedure to call at outside the current context

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEQueueForNonDispProcessing( DelayedWorkerRoutine,                 \
                                      pTracker,                             \
                                      pClientContext,                       \
                                      ClientCompletion,                     \
                                      pDeviceContext,                       \
                                      fJointLockHeld)                       \
    NTQueueToWorkerThread( DelayedWorkerRoutine, pTracker, pClientContext,  \
                           ClientCompletion, pDeviceContext, fJointLockHeld)
#else
#define CTEQueueForNonDispProcessing( DelayedWorkerRoutine,                 \
                                      pTracker,                             \
                                      pClientContext,                       \
                                      ClientCompletion,                     \
                                      pDeviceContext,                       \
                                      fJointLockHeld)                       \
    VxdScheduleDelayedCall( DelayedWorkerRoutine, pTracker, pClientContext, \
                            ClientCompletion, pDeviceContext, TRUE )


//  For Win98, we also need a function which schedules a call
//  outside of a critical section

#define CTEQueueForNonCritNonDispProcessing( DelayedWorkerRoutine           \
                                             pTracker,                      \
                                             pClientContext,                \
                                             ClientCompletion,              \
                                             pDeviceContext)                \
    VxdScheduleDelayedCall( DelayedWorkerRoutine, pTracker, pClientContext, \
                            ClientCompletion, pDeviceContext, FALSE )

#endif

//----------------------------------------------------------------------------
//
// CTESystemUpTime( OUT PTIME    pTime );
//
/*++
Routine Description:

    This macro returns the current system time in clock tics or whatever
    in the value pTime.  For NT this is a Large Integer.  For the VXD it is
    a ULONG.

Arguments:

    pTime

Return Value:

    NONE
--*/
#ifndef VXD
#define CTESystemTime   LARGE_INTEGER
#define CTEQuerySystemTime( _Time )    \
    KeQuerySystemTime( &(_Time) )

// the lower 4 bits appear to be zero always...!!
#define RandomizeFromTime( Time, Mod )  \
    ((Time.LowTime >> 8) % Mod)
#else
#define CTESystemTime    ULONG
#define CTEQuerySystemTime( _Time )    \
    _Time = CTESystemUpTime()
#define RandomizeFromTime( Time, Mod )  \
    ((Time >> 4) % Mod)
#endif

//----------------------------------------------------------------------------
//
// CTEPagedCode();
//
/*++
Routine Description:

    This macro is used in NT to check if the Irql is above zero. All
    coded that is pageable has this macro call to catch any code that might
    be marked as pageable when in fact it isn't.

Arguments:

    none

Return Value:

    NONE
--*/
#ifndef VXD
#define CTEPagedCode() PAGED_CODE()
#else
#define CTEPagedCode()
#ifdef CHICAGO
#ifdef DEBUG
#undef CTEPagedCode
#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#endif
#endif
#endif


//----------------------------------------------------------------------------
//
// CTEMakePageable(Page,Routine);
//
/*++
Routine Description:

    This macro is used in NT to activate teh alloc_text pragma, to put
    a procedure in the pageable code segment.

Arguments:

    none

Return Value:

    NONE
--*/
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#define INIT _ITEXT
// #define PAGE _PTEXT  "vmm.h" has a macro for this.  We override it later.
#endif // CHICAGO


//----------------------------------------------------------------------------
//
// NTSetCancelRoutine(pIrp,Routine);
//
/*++
Routine Description:

    This macro removes the call to set the cancel routine for an irp from the
    VXD environment.

Arguments:

    none

Return Value:

    NONE
--*/
#ifdef VXD
#define NTSetCancelRoutine(_pIrp,_CancelRoutine,_pDeviceContext)   (0)
#define NTCheckSetCancelRoutine(_pIrp,_CancelRoutine,_pDeviceContext) (0)
#define NTClearContextCancel(pWiContext) (0)
#endif

//----------------------------------------------------------------------------
//
// NbtLogEvent(LogEvent,status)
//
/*++
Routine Description:

    This macro removes the call to the log routine for the Vxd environment


Arguments:

    none

Return Value:

    NONE
--*/
#ifdef VXD
#define NbtLogEvent(LogEvent,status,Info)
#endif

//----------------------------------------------------------------------------
//
// CTEGetTimeout(_pTimeout);
//
/*++
Routine Description:

    This macro gets the timeout value for a connect attempt
    VXD environment.

Arguments:

    none

Return Value:

    NONE
--*/
#ifndef VXD
#define CTEGetTimeout(pTimeout,pRetTime) \
{                                       \
    LARGE_INTEGER   _Timeout;                \
    ULONG           Remainder;              \
    _Timeout.QuadPart = -(((PLARGE_INTEGER)pTimeout)->QuadPart); \
    _Timeout = RtlExtendedLargeIntegerDivide(_Timeout,MILLISEC_TO_100NS,&Remainder);\
    *pRetTime = (ULONG)_Timeout.LowPart; \
}
#else
//
//  VXD timeout is a pointer to a ULONG
//
#define CTEGetTimeout(_pTimeout, pRet ) (*pRet = ((ULONG) _pTimeout ? *((PULONG)_pTimeout) : 0 ))
#endif

//----------------------------------------------------------------------------
//
// CTEAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEAttachFsp(_pAttached, _Context)      \
{                                               \
    if (PsGetCurrentProcess() != NbtFspProcess) \
    {                                           \
        KeAttachProcess((PRKPROCESS)NbtFspProcess);\
        *_pAttached = TRUE;                     \
    }                                           \
    else                                        \
    {                                           \
        *_pAttached = FALSE;                    \
    }                                           \
}
#else
#define CTEAttachFsp( _pAttached, _Context )
#endif

//----------------------------------------------------------------------------
//
// CTEAttachFsp()
//
/*++
Routine Description:

    This macro attaches a process to the File System Process to be sure
    that handles are created and released in the same process

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEDetachFsp(_Attached, _Context)                 \
{                                               \
    if (_Attached)                              \
    {                                           \
        KeDetachProcess();                      \
    }                                           \
}
#else
#define CTEDetachFsp(_Attached, _Context)
#endif

//----------------------------------------------------------------------------
//
// CTEResetIrpPending(PIRP pIrp)
//
/*++
Routine Description:

    This macro resets the irp pending bit in an irp.

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
#ifndef VXD
#define CTEResetIrpPending(pIrp)      \
{                                               \
    PIO_STACK_LOCATION pIrpsp;                  \
    pIrpsp = IoGetCurrentIrpStackLocation(pIrp);\
    pIrpsp->Control &= ~SL_PENDING_RETURNED;    \
}
#else
#define CTEResetIrpPending( a )
#endif

//----------------------------------------------------------------------------
//
// ADD_TO_LIST(pListHead,pTracker)
//
/*++
Routine Description:

    This macro adds a tracker from the "used Tracker List"

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
//#if DBG
#define ADD_TO_LIST(pListHead,pLinkage)         \
{                                               \
    CTELockHandle       OldIrq;                 \
    CTESpinLock(&NbtConfig,OldIrq);             \
    InsertTailList((pListHead),pLinkage);       \
    CTESpinFree(&NbtConfig,OldIrq);             \
}
//#else
//#define ADD_TO_LIST( a,b )
//#endif
//----------------------------------------------------------------------------
//
// REMOVE_FROM_LIST(pLinkage)
//
/*++
Routine Description:

    This macro removes a tracker from the "used Tracker List"

Arguments:

Return Value:

    STATUS_SUCCESS if successful, error code otherwise

--*/
//#if DBG
#define REMOVE_FROM_LIST(pLinkage)              \
{                                               \
    CTELockHandle       OldIrq;                 \
    CTESpinLock(&NbtConfig,OldIrq);             \
    RemoveEntryList(pLinkage);                  \
    CTESpinFree(&NbtConfig,OldIrq);             \
}
//#else
//#define REMOVE_FROM_LIST( a )
//#endif
//----------------------------------------------------------------------------
//
// CTESaveClientSecurity(pClientEle)
//
/*++
Routine Description:

    This macro saves the client thread security context so that it can be used
    later to impersonate the client when a remote lmhosts file is openned.

Arguments:

Return Value:


--*/
#ifndef VXD
#define CTESaveClientSecurity(_pClientEle)                    \
    /*SaveClientSecurity(_pClientEle)*/
#else
#define CTESaveClientSecurity(_pClientEle)
#endif

//----------------------------------------------------------------------------
//
// IMPERSONATE_CLIENT(pClientSecurity)
//
/*++
Routine Description:

    This macro sets an excutive worker thread to impersonate a client
    thread so that remote lmhost files can be openned by that thread.

Arguments:

Return Value:


--*/
#ifndef VXD
#define IMPERSONATE_CLIENT(_pClientSecurity)                    \
        /*SeImpersonateClient((_pClientSecurity),NULL)*/
#else
#define IMPERSONATE_CLIENT(_pClientSecurity)
#endif
//----------------------------------------------------------------------------
//
// STOP_IMPERSONATE_CLIENT(pClientSecurity)
//
/*++
Routine Description:

    This macro sets an excutive worker thread NOT to impersonate a client.

Arguments:

Return Value:


--*/
#ifndef VXD
#define STOP_IMPERSONATE_CLIENT(_pClientSecurity)    \
    /*NtSetInformationThread(PsGetCurrentThread(),ThreadImpersonationToken,NULL,sizeof(HANDLE))*/
#else
#define STOP_IMPERSONATE_CLIENT(_pClientSecurity)
#endif

//----------------------------------------------------------------------------
//
// DELETE_CLIENT_SECURITY(pTracker)
//
/*++
Routine Description:

    This macro deletes a client security.

Arguments:

Return Value:


--*/
#ifndef VXD
#define DELETE_CLIENT_SECURITY(_pTracker)    \
    /*    NtDeleteClientSecurity(_pTracker)*/
#else
#define DELETE_CLIENT_SECURITY(_pTracker)
#endif


#ifdef VXD  // Taken from ntrtl.h (Vxd doesn't include NT Headers)

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
#endif // VXD


#endif // _CTEMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\nbtnt.h ===
//
//  NBTNT.H
//
//  This file contains common header definitions for NBT in the NT
//  environment
//
//

#ifndef _NBT_H
#define _NBT_H

#ifndef VXD
#include <ntosp.h>
#include <zwapi.h>
//#include <status.h>
//#include <ntstatus.h>
#include <tdikrnl.h>
#include <tdi.h>
#include <windef.h>
#include <stdio.h>
#include <nb30.h>

#else

#include <oscfgnbt.h>
#include <cxport.h>
#define  __int64 double
#include <windef.h>
#include <nb30.h>

//
//  These definitions work around NTisms found in various difficult to change
//  places.
//
typedef ULONG NTSTATUS ;
typedef PNCB  PIRP ;
typedef PVOID PDEVICE_OBJECT ;

#include <ctemacro.h>
#include <tdi.h>

//
//  These are needed because we include windef.h rather then
//  ntddk.h, which end up not being defined
//
#define STATUS_NETWORK_NAME_DELETED     ((NTSTATUS)0xC00000CAL)
#define STATUS_INVALID_BUFFER_SIZE      ((NTSTATUS)0xC0000206L)
#define STATUS_CONNECTION_DISCONNECTED  ((NTSTATUS)0xC000020CL)
#define STATUS_CANCELLED                ((NTSTATUS)0xC0000120L)
#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0xC0000001L)

#define STATUS_TOO_MANY_COMMANDS        ((NTSTATUS)0xC00000C1L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_SHARING_VIOLATION        ((NTSTATUS)0xC0000043L)
#define STATUS_DUPLICATE_NAME           ((NTSTATUS)0xC00000BDL)
#define STATUS_BAD_NETWORK_PATH         ((NTSTATUS)0xC00000BEL)
#define STATUS_REMOTE_NOT_LISTENING     ((NTSTATUS)0xC00000BCL)
#define STATUS_CONNECTION_REFUSED       ((NTSTATUS)0xC0000236L)
#define STATUS_INVALID_PARAMETER        ((NTSTATUS)0xC000000DL)
#define STATUS_UNEXPECTED_NETWORK_ERROR ((NTSTATUS)0xC00000C4L)
#define STATUS_NOT_SUPPORTED            ((NTSTATUS)0xC00000BBL)

#define STATUS_INVALID_HANDLE           ((NTSTATUS)0xC0000008L)
#define STATUS_INVALID_DEVICE_REQUEST   ((NTSTATUS)0xC0000010L)

#define STATUS_INVALID_PARAMETER_6      ((NTSTATUS)0xC00000F4L)

//
//  The following functions are used by NBT.  They are defined in the NT kernel
//  TDI stuff which we are trying to avoid.
//

typedef
NTSTATUS
(*PTDI_IND_CONNECT)(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext
    )
    ;

NTSTATUS
TdiDefaultConnectHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext
    );

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it. Note that
// this is a change from TDI V1, which indicated only when the remote caused
// a disconnection. Any non-directed disconnection will cause this indication.
//

typedef
NTSTATUS
(*PTDI_IND_DISCONNECT)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
TdiDefaultDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
// For NetBIOS-type providers, this indication is also delivered when a name
// in conflict or duplicate name occurs.
//

typedef
NTSTATUS
(*PTDI_IND_ERROR)(
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );

NTSTATUS
TdiDefaultErrorHandler (
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );

//
// TDI_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// TDI_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_DATAGRAM)(
    IN PVOID TdiEventContext,       // the event context
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN int SourceAddressLength,     // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN int OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_EXPEDITED)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvExpeditedHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PTDI_IND_SEND_POSSIBLE)(
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

NTSTATUS
TdiDefaultSendPossibleHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

#endif //VXD

#define FILE_DEVICE_NBT  0x32

#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

__inline long
htonl(long x)
{
	return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L) |
                        (((x) << 24) & 0xFF000000L));
}
#endif
#define ntohs(x)        htons(x)
#define ntohl(x)        htonl(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\nbtprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Nbtprocs.h

Abstract:

    This file contains the OS independent function prototypes.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:
        Johnl   05-Apr-1993     Hacked on to support VXD

--*/


#ifndef _NBTPROCS_H_
#define _NBTPROCS_H_

#include "types.h"

#ifndef VXD
    #include <ntprocs.h>
#else
    #include <vxdprocs.h>
#endif

//---------------------------------------------------------------------
//  FROM NAMESRV.C
//
NTSTATUS
NbtRegisterName(
    IN    enum eNbtLocation   Location,
    IN    ULONG               IpAddress,
    IN    PCHAR               pName,
    IN    tNAMEADDR           *pNameAddrIn,
    IN    tCLIENTELE          *pClientEle,
    IN    PVOID               pClientCompletion,
    IN    USHORT              uAddressType,
    IN    tDEVICECONTEXT      *pDeviceContext
    );

NTSTATUS
ReleaseNameOnNet(
    tNAMEADDR           *pNameAddr,
    PCHAR               pScope,
    PVOID               pClientCompletion,
    ULONG               NodeType,
    tDEVICECONTEXT      *pDeviceContext
    );

VOID
NameReleaseDone(
    PVOID               pContext,
    NTSTATUS            status
    );

NTSTATUS
RegOrQueryFromNet(
    IN  BOOL                fReg,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  PCHAR               pName,
    IN  PUCHAR              pScope
    );

NTSTATUS
QueryNameOnNet(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  USHORT                  uType,
    IN  tDGRAM_SEND_TRACKING    *pClientContextTracker,
    IN  PVOID                   pClientCompletion,
    IN  ULONG                   NodeType,
    IN  tNAMEADDR               *pNameAddrIn,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  CTELockHandle           *pJointLockOldIrq
    );

#ifdef MULTIPLE_WINS
NTSTATUS
ContinueQueryNameOnNet(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN PUCHAR                   pName,
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    QueryCompletion,
    IN OUT BOOLEAN              *pfNameReferenced
    );
#endif

VOID
CompleteClientReq(
    COMPLETIONCLIENT        pClientCompletion,
    tDGRAM_SEND_TRACKING    *pTracker,
    NTSTATUS                status
    );

VOID
NodeStatusTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RefreshRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
WakeupRefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
RemoteHashTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
SessionKeepAliveTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
IncrementNameStats(
    IN ULONG           StatType,
    IN BOOLEAN         IsNameServer
    );

VOID
SaveBcastNameResolved(
    IN PUCHAR          pName
    );

//---------------------------------------------------------------------
//  FROM NAME.C

VOID
FreeRcvBuffers(
    tCONNECTELE     *pConnEle,
    CTELockHandle   *pOldIrq
    );

NTSTATUS
NbtRegisterCompletion(
    IN  tCLIENTELE *pClientEle,
    IN  NTSTATUS    Status);

NTSTATUS
NbtOpenAddress(
    IN  TDI_REQUEST          *pRequest,
    IN  TA_ADDRESS           *pTaAddress,
    IN  tIPADDRESS           IpAddress,
    IN  PVOID                pSecurityDescriptor,
    IN  tDEVICECONTEXT       *pContext,
    IN  PVOID                pIrp);

NTSTATUS
NbtOpenConnection(
    IN  TDI_REQUEST         *pRequest,
    IN  CONNECTION_CONTEXT  pConnectionContext,
    IN  tDEVICECONTEXT      *pContext);

NTSTATUS
NbtOpenAndAssocConnection(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tCONNECTELE         *pConnEle,
    OUT tLOWERCONNECTION    **ppLowerConn,
    IN  UCHAR               Identifier
    );

NTSTATUS
NbtAssociateAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  tCLIENTELE          *pClientEle,
    IN  PVOID               pIrp);

NTSTATUS
NbtDisassociateAddress(
    IN  TDI_REQUEST         *pRequest
    );

NTSTATUS
NbtCloseAddress(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp);

NTSTATUS
NbtCleanUpAddress(
    IN  tCLIENTELE      *pClientEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtCloseConnection(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp);

NTSTATUS
NbtCleanUpConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    );

VOID
RelistConnection(
    IN  tCONNECTELE *pConnEle
        );

NTSTATUS
CleanupConnectingState(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  CTELockHandle   *OldIrq,
    IN  CTELockHandle   *OldIrq2
    );

NTSTATUS
NbtConnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

tNAMEADDR *
FindNameRemoteThenLocal(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    OUT PULONG                  plNameType
    );

VOID
SessionStartupContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
SessionStartupTimeoutCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    );

VOID
SessionStartupTimeout (
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
QueueCleanup(
    IN  tCONNECTELE     *pConnEle,
    IN  CTELockHandle   *pOldIrqJointLock,
    IN  CTELockHandle   *pOldIrqConnEle
    );

NTSTATUS
NbtDisconnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  ULONG                       Flags,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PTDI_CONNECTION_INFORMATION pReturnInfo,
    IN  PIRP                        pIrp);

NTSTATUS
NbtSend(
        IN  TDI_REQUEST     *pRequest,
        IN  USHORT          Flags,
        IN  ULONG           SendLength,
        OUT LONG            *pSentLength,
        IN  PVOID           *pBuffer,
        IN  tDEVICECONTEXT  *pContext,
        IN  PIRP            pIrp
        );

NTSTATUS
NbtSendDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pSendInfo,
        IN  LONG                        SendLength,
        IN  LONG                        *pSentLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        );

NTSTATUS
SendDgram(
        IN  tNAMEADDR               *pNameAddr,
        IN  tDGRAM_SEND_TRACKING    *pTracker
        );
NTSTATUS

BuildSendDgramHdr(
        IN  ULONG           SendLength,
        IN  tDEVICECONTEXT  *pDeviceContext,
        IN  PCHAR           pSourceName,
        IN  PCHAR           pDestinationName,
        IN  ULONG           NameLength,
        IN  PVOID           pBuffer,
        OUT tDGRAMHDR       **ppDgramHdr,
        OUT tDGRAM_SEND_TRACKING    **ppTracker
        );

VOID
NodeStatusDone(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

NTSTATUS
NbtSendNodeStatus(
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PCHAR                           pName,
    IN  PULONG                          pIpAddrsList,
    IN  PVOID                           ClientContext,
    IN  PVOID                           CompletionRoutine
    );

NTSTATUS
NbtQueryFindName(
    IN  PTDI_CONNECTION_INFORMATION     pInfo,
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PIRP                            pIrp,
    IN  BOOLEAN                         IsIoctl
    );

NTSTATUS
CopyFindNameData(
    IN  tNAMEADDR              *pNameAddr,
    IN  PIRP                   pIrp,
    IN  tDGRAM_SEND_TRACKING   *pTracker
    );

NTSTATUS
NbtListen(
    IN  TDI_REQUEST                 *pRequest,
    IN  ULONG                       Flags,
    IN  TDI_CONNECTION_INFORMATION  *pRequestConnectInfo,
    OUT TDI_CONNECTION_INFORMATION  *pReturnConnectInfo,
    IN  PVOID                       pIrp);

NTSTATUS
NbtAccept(
        IN  TDI_REQUEST                 *pRequest,
        IN  TDI_CONNECTION_INFORMATION  *pAcceptInfo,
        OUT TDI_CONNECTION_INFORMATION  *pReturnAcceptInfo,
        IN  PIRP                        pIrp);

NTSTATUS
NbtReceiveDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pReceiveInfo,
        IN  PTDI_CONNECTION_INFORMATION pReturnedInfo,
        IN  LONG                        ReceiveLength,
        IN  LONG                        *pReceivedLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        );

NTSTATUS
NbtSetEventHandler(
    tCLIENTELE  *pClientEle,
    int         EventType,
    PVOID       pEventHandler,
    PVOID       pEventContext
    );

NTSTATUS
NbtAddEntryToRemoteHashTable(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN USHORT           NameAddFlag,
    IN PUCHAR           Name,
    IN ULONG            IpAddress,
    IN ULONG            Ttl,
    IN UCHAR            name_flags
    );

NTSTATUS
NbtQueryAdapterStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppAdapterStatus,
    OUT PLONG           pSize,
    enum eNbtLocation   Location
    );

NTSTATUS
NbtQueryConnectionList(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppConnList,
    IN OUT PLONG         pSize
    );

VOID
DelayedNbtResyncRemoteCache(
    IN  PVOID                   Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    );

NTSTATUS
NbtQueryBcastVsWins(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppBuffer,
    IN OUT PLONG         pSize
    );

NTSTATUS
NbtNewDhcpAddress(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress,
    ULONG           SubnetMask);

VOID
FreeTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN ULONG                    Actions
    );

NTSTATUS
DatagramDistribution(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  tNAMEADDR               *pNameAddr
    );

VOID
DeleteAddressElement(
    IN  tADDRESSELE    *pAddress
    );

VOID
DeleteClientElement(
    IN  tCLIENTELE    *pClientEle
    );

VOID
ReleaseNameCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

NTSTATUS
DisconnectLower(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                state,
    IN  ULONG                Flags,
    IN  PVOID                Timeout,
    IN  BOOLEAN              Wait
    );

extern
USHORT
GetTransactId(
    );

NTSTATUS
NbtDeleteLowerConn(
    IN tLOWERCONNECTION   *pLowerConn
    );

tDEVICECONTEXT *
GetAndRefNextDeviceFromNameAddr(
    IN  tNAMEADDR               *pNameAddr
    );

tDEVICECONTEXT *
GetDeviceFromInterface(
    IN  tIPADDRESS      IpAddress,
    IN  BOOLEAN         fReferenceDevice
    );

VOID
NbtDereferenceName(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       RefContext,
    IN  BOOLEAN     fLocked
    );

VOID
NbtDereferenceLowerConnection(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               RefContext,
    IN  BOOLEAN             fJointLockHeld
    );

VOID
NbtDereferenceTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN BOOLEAN                  fLocked
    );

NTSTATUS
NbtDereferenceAddress(
    IN tADDRESSELE  *pAddressEle,
    IN ULONG        Context
    );

VOID
NbtDereferenceConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  ULONG           RefContext
    );

VOID
NbtDereferenceClient(
    IN tCLIENTELE   *pClientEle
    );

//---------------------------------------------------------------------
//
// FROM TDICNCT.C
//
NTSTATUS
NbtTdiOpenConnection (
    IN tLOWERCONNECTION     *pLowerConn,
    IN tDEVICECONTEXT       *pDeviceContext
    );

NTSTATUS
NbtTdiAssociateConnection(
    IN  PFILE_OBJECT        pFileObject,
    IN  HANDLE              Handle
    );

NTSTATUS
NbtTdiCloseConnection(
    IN tLOWERCONNECTION   *pLowerConn
    );

NTSTATUS
NbtTdiCloseAddress(
    IN tLOWERCONNECTION   *pLowerConn
    );


//---------------------------------------------------------------------
//
// FROM TDIADDR.C
//
NTSTATUS
NbtTdiOpenAddress (
    OUT PHANDLE             pFileHandle,
    OUT PDEVICE_OBJECT      *pDeviceObject,
    OUT PFILE_OBJECT        *pFileObject,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT               PortNumber,
    IN  ULONG               IpAddress,
    IN  ULONG               Flags
    );

NTSTATUS
NbtTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NbtTdiOpenControl (
    IN  tDEVICECONTEXT      *pDeviceContext
    );

//---------------------------------------------------------------------
//
// FROM NBTUTILS.C
//

BOOLEAN
IsEntryInList(
    PLIST_ENTRY     pEntryToFind,
    PLIST_ENTRY     pListToSearch
    );

void
FreeList(
    PLIST_ENTRY pHead,
    PLIST_ENTRY pFreeQ);

void
NbtFreeAddressObj(
    tADDRESSELE *pBlk);

void
NbtFreeClientObj(
    tCLIENTELE    *pBlk);

void
FreeConnectionObj(
    tCONNECTELE    *pBlk);

tCLIENTELE *
NbtAllocateClientBlock(
    tADDRESSELE     *pAddrEle,
    tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtAddPermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtAddPermanentNameNotFound(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

VOID
NbtRemovePermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
ConvertDottedDecimalToUlong(
    IN  PUCHAR               pInString,
    OUT PULONG               IpAddress);

NTSTATUS
NbtInitQ(
    PLIST_ENTRY pListHead,
    LONG        iSizeBuffer,
    LONG        iNumBuffers);

NTSTATUS
NbtInitTrackerQ(
    LONG        iNumBuffers
    );

tDGRAM_SEND_TRACKING *
NbtAllocTracker(
    IN  VOID
    );

NTSTATUS
NbtGetBuffer(
    PLIST_ENTRY         pListHead,
    PLIST_ENTRY         *ppListEntry,
    enum eBUFFER_TYPES  eBuffType);

NTSTATUS
NewInternalAddressFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );

VOID
DeleteInternalAddress(
    IN PTA_NETBT_INTERNAL_ADDRESS pNetBT
    );

NTSTATUS
GetNetBiosNameFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    );

NTSTATUS
ConvertToAscii(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PCHAR            *pScope,
    OUT PULONG           pNameSize
    );

PCHAR
ConvertToHalfAscii(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pScope,
    IN  ULONG            ScopeSize
    );

ULONG
Nbt_inet_addr(
    IN  PCHAR            pName,
    IN  ULONG            Flags
    );

NTSTATUS
BuildQueryResponse(
    IN   USHORT           sNameSize,
    IN   tNAMEHDR         *pNameHdr,
    IN   ULONG            uTtl,
    IN   ULONG            IpAddress,
    OUT  ULONG            uNumBytes,
    OUT  PVOID            pResponse,
    IN   PVOID            pName,
    IN   USHORT           NameType,
    IN   USHORT           RetCode
    );

NTSTATUS
GetTracker(
    OUT tDGRAM_SEND_TRACKING    **ppTracker,
    IN  enum eTRACKER_TYPE      TrackerType);

NTSTATUS
GetIrp(
    OUT PIRP *ppIrp);

ULONG
CountLocalNames(IN tNBTCONFIG  *pNbtConfig
    );

ULONG
CountUpperConnections(
    IN tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
DisableInboundConnections(
    IN   tDEVICECONTEXT *pDeviceContext
    );

ULONG
CloseLowerConnections(
    IN  PLIST_ENTRY  pLowerConnFreeHead
    );

NTSTATUS
ReRegisterLocalNames(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  BOOLEAN         fSendNameRelease
    );

VOID
NbtStopRefreshTimer(
    );

NTSTATUS
strnlen(
    PUCHAR  SrcString,
    LONG    MaxBufferLength,
    LONG    *pStringLen
    );

//---------------------------------------------------------------------
//
// FROM hndlrs.c
//

NTSTATUS
RcvHandlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer
    );

NTSTATUS
Inbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    );
NTSTATUS
Outbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer
    );
NTSTATUS
RejectAnyData(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );

VOID
RejectSession(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               StatusCode,
    IN  ULONG               SessionStatus,
    IN  BOOLEAN             SendNegativeSessionResponse
    );

VOID
GetIrpIfNotCancelled(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    );

NTSTATUS
FindSessionEndPoint(
    IN  VOID UNALIGNED  *pTsdu,
    IN  PVOID           ConnectionContext,
    IN  ULONG           BytesIndicated,
    OUT tCLIENTELE      **ppClientEle,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength
    );

VOID
SessionRetry(
    IN PVOID               pContext,
    IN PVOID               pContext2,
    IN tTIMERQENTRY        *pTimerQEntry
    );

tCONNECTELE *
SearchConnectionList(
    IN  tCLIENTELE           *pClientEle,
    IN  PVOID                pClientContext
    );

NTSTATUS
ConnectHndlrNotOs (
    IN PVOID                pConnectionContext,
    IN LONG                 RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    OUT CONNECTION_CONTEXT  *ppConnectionId
    );

NTSTATUS
DisconnectHndlrNotOs (
    PVOID           EventContext,
    PVOID           ConnectionContext,
    ULONG           DisconnectDataLength,
    PVOID           pDisconnectData,
    ULONG           DisconnectInformationLength,
    PVOID           pDisconnectInformation,
    ULONG           DisconnectIndicators
    );

NTSTATUS
DgramHndlrNotOs(
    IN  PVOID               ReceiveEventContext,
    IN  ULONG               SourceAddrLength,
    IN  PVOID               pSourceAddr,
    IN  ULONG               OptionsLength,
    IN  PVOID               pOptions,
    IN  ULONG               ReceiveDatagramFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              pBytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppRcvBuffer,
    OUT tCLIENTLIST         **ppAddressEle
    );

NTSTATUS
NameSrvHndlrNotOs (
    IN tDEVICECONTEXT     *pDeviceContext,
    IN PVOID              pSrcAddress,
    IN tNAMEHDR UNALIGNED *pNameSrv,
    IN ULONG              uNumBytes,
    IN BOOLEAN            fBroadcast
    );

//---------------------------------------------------------------------
//
// FROM proxy.c
//

NTSTATUS
ReleaseResponseFromNet(
    IN  tDEVICECONTEXT     *pDeviceContext,
    IN  PVOID              pSrcAddress,
    IN  tNAMEHDR UNALIGNED *pNameHdr,
    IN  LONG               NumBytes
    );

NTSTATUS
ProxyQueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

NTSTATUS
ProxyDoDgramDist(
    IN  tDGRAMHDR           UNALIGNED *pDgram,
    IN  DWORD               DgramLen,
    IN  tNAMEADDR           *pNameAddr,
    IN  tDEVICECONTEXT      *pDeviceContext
    );


VOID
ProxyTimerComplFn (
  IN PVOID            pContext,
  IN PVOID            pContext2,
  IN tTIMERQENTRY    *pTimerQEntry
 );

VOID
ProxyRespond (
    IN  tQUERYRESP      *pQuery,
    IN  PUCHAR          pName,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  tNAMEHDR        *pNameHdr,
    IN  ULONG           lNameSize,
    IN  ULONG           SrcAddress,
    IN  PTDI_ADDRESS_IP pAddressIp
 );

//---------------------------------------------------------------------
//
// FROM hashtbl.c
//
NTSTATUS
CreateHashTable(
    tHASHTABLE          **pHashTable,
    LONG                NumBuckets,
    enum eNbtLocation   LocalRemote
    );

#ifdef _PNP_POWER_
VOID
DestroyHashTables(
    );
#endif  // _PNP_POWER_

NTSTATUS
LockAndAddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    );


NTSTATUS
AddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    );

NTSTATUS
DeleteFromHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName
    );

tNAMEADDR *
LockAndFindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    );

tNAMEADDR *
FindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    );

NTSTATUS
ChgStateOfScopedNameInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    DWORD               NewState
    );

NTSTATUS
FindInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    tNAMEADDR           **pNameAddress
    );

NTSTATUS
FindNoScopeInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    tNAMEADDR           **pNameAddress
    );

NTSTATUS
UpdateHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               IpAddress,
    BOOLEAN             bGroup,
    tNAMEADDR           **ppNameAddr
    );

//---------------------------------------------------------------------
//
// FROM timer.c
//

NTSTATUS
InitTimerQ(
    IN  int     NumInQ
    );

#ifdef _PNP_POWER_
NTSTATUS
DestroyTimerQ(
    );
#endif  // _PNP_POWER_

NTSTATUS
InterlockedCallCompletion(
    IN  tTIMERQENTRY    *pTimer,
    IN  NTSTATUS        status
    );

NTSTATUS
StartTimer(
    IN  PVOID           CompletionRoutine,
    IN  ULONG           DeltaTime,
    IN  PVOID           Context,
    IN  PVOID           Context2,
    IN  PVOID           ContextClient,
    IN  PVOID           CompletionClient,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tTIMERQENTRY    **ppTimerEntry,
    IN  USHORT          Retries,
    BOOLEAN             fLocked);

NTSTATUS
StopTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    OUT COMPLETIONCLIENT *pClient,
    OUT PVOID            *ppContext
    );


VOID
DelayedNbtStartWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    );

VOID
DelayedNbtStopWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    );

//---------------------------------------------------------------------
//
// FROM udpsend.c
//

NTSTATUS
UdpSendQueryNs(
    PCHAR               pName,
    PCHAR               pScope
    );
NTSTATUS
UdpSendQueryBcast(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  tDGRAM_SEND_TRACKING    *pSentList
    );
NTSTATUS
UdpSendRegistrationNs(
    PCHAR               pName,
    PCHAR               pScope
    );

NTSTATUS
UdpSendNSBcast(
    IN tNAMEADDR             *pNameAddr,
    IN PCHAR                 pScope,
    IN tDGRAM_SEND_TRACKING  *pSentList,
    IN PVOID                 pCompletionRoutine,
    IN PVOID                 pClientContext,
    IN PVOID                 pClientCompletion,
    IN ULONG                 Retries,
    IN ULONG                 Timeout,
    IN enum eNSTYPE          eNsType,
	IN BOOL					 SendFlag
    );

VOID
NameDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    );

NTSTATUS
UdpSendResponse(
    IN  ULONG                   lNameSize,
    IN  tNAMEHDR   UNALIGNED    *pNameHdrIn,
    IN  tNAMEADDR               *pNameAddr,
    IN  PTDI_ADDRESS_IP         pDestIpAddress,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  ULONG                   Rcode,
    IN  enum eNSTYPE            NsType,
    IN  CTELockHandle           OldIrq
    );

NTSTATUS
UdpSendDatagram(
    IN  tDGRAM_SEND_TRACKING       *pDgramTracker,
    IN  ULONG                      IpAddress,
    IN  PVOID                      pCompletionRoutine,
    IN  PVOID                      CompletionContext,
    IN  USHORT                     Port,
    IN  ULONG                      Service
    );

PVOID
CreatePdu(
    IN  PCHAR       pName,
    IN  PCHAR       pScope,
    IN  ULONG       IpAddress,
    IN  USHORT      NameType,
    IN enum eNSTYPE eNsType,
    OUT PVOID       *pHdrs,
    OUT PULONG      pLength,
    IN  tDGRAM_SEND_TRACKING    *pTracker
    );

NTSTATUS
TcpSessionStart(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  ULONG                      IpAddress,
    IN  tDEVICECONTEXT             *pDeviceContext,
    IN  PVOID                      pCompletionRoutine,
    IN  ULONG                      Port
    );

NTSTATUS
TcpSendSessionResponse(
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  ULONG                      lStatusCode,
    IN  ULONG                      lSessionStatus
    );

NTSTATUS
TcpSendSession(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  tLOWERCONNECTION           *LowerConn,
    IN  PVOID                      pCompletionRoutine
    );

NTSTATUS
SendTcpDisconnect(
    IN  tLOWERCONNECTION       *pLowerConnId
    );

NTSTATUS
TcpDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  PVOID                      Timeout,
    IN  ULONG                      Flags,
    IN  BOOLEAN                    Wait
    );

VOID
FreeTrackerOnDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker
    );

VOID
QueryRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
DisconnectDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);


//---------------------------------------------------------------------
//
// FROM tdiout.c
//
NTSTATUS
TdiSendDatagram(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PTDI_CONNECTION_INFORMATION     pSendDgramInfo,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tDGRAM_SEND_TRACKING            *pDgramTracker
    );
PIRP
NTAllocateNbtIrp(
    IN PDEVICE_OBJECT   DeviceObject
    );
NTSTATUS
TdiConnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  ULONG_PTR                       lTimeout,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    OUT PVOID                           pIrp
    );
NTSTATUS
TdiSend(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  USHORT                          sFlags,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tBUFFER                         *pSendBuffer,
    IN  ULONG                           Flags
    );

NTSTATUS
TdiDisconnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PVOID                           lTimeout,
    IN  ULONG                           Flags,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PCTE_IRP                        pClientIrp,
    IN  BOOLEAN                         Wait
    );

//---------------------------------------------------------------------
//
// FROM inbound.c
//
NTSTATUS
QueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags,
    IN  BOOLEAN             fBroadcast
    );

NTSTATUS
RegResponseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

NTSTATUS
CheckRegistrationFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

NTSTATUS
NameReleaseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

NTSTATUS
WackFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    );

VOID
SetupRefreshTtl(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  tNAMEADDR           *pNameAddr,
    IN  LONG                lNameSize
    );

#ifdef MULTIPLE_WINS
BOOLEAN
IsNameServerForDevice(
    IN  ULONG               SrcAddress,
    IN  tDEVICECONTEXT      *pDevContext
    );
#endif

BOOLEAN
SrcIsNameServer(
    IN  ULONG                SrcAddress,
    IN  USHORT               SrcPort
    );

VOID
SwitchToBackup(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

BOOLEAN
SrcIsUs(
    IN  ULONG                SrcAddress
    );

NTSTATUS
FindOnPendingList(
    IN  PUCHAR                  pName,
    IN  tNAMEHDR UNALIGNED      *pNameHdr,
    IN  BOOLEAN                 DontCheckTransactionId,
    IN  ULONG                   BytesToCompare,
    OUT tNAMEADDR               **ppNameAddr
    );


//---------------------------------------------------------------------
//
// FROM init.c
//
NTSTATUS
InitNotOs(
    void
    ) ;

NTSTATUS
InitTimersNotOs(
    void
    );

NTSTATUS
StopInitTimers(
    void
    );

VOID
ReadParameters(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

VOID
ReadParameters2(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

//---------------------------------------------------------------------
//
// FROM parse.c
//
unsigned long
LmGetIpAddr (
    IN PUCHAR    path,
    IN PUCHAR    target,
    IN CHAR      RecurseDepth,
    OUT BOOLEAN  *bFindName
    );

VOID
RemovePreloads (
         );

VOID
SetNameState(
    IN tNAMEADDR    *pNameAddr,
    IN  PULONG      pIpList,
    IN  BOOLEAN     IpAddrResolved
    );

LONG
PrimeCache(
    IN  PUCHAR  path,
    IN  PUCHAR   ignored,
    IN  CHAR     RecurseDepth,
    OUT BOOLEAN *ignored2
    );

NTSTATUS
NtProcessLmHSvcIrp(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PVOID           *pBuffer,
    IN  LONG            Size,
    IN  PCTE_IRP        pIrp,
    IN  enum eNbtLmhRequestType RequestType
    );

VOID
NbtCompleteLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  ULONG                   *IpList,
    IN  enum eNbtLmhRequestType RequestType,
    IN  ULONG                   lNameLength,
    IN  PWSTR                   pwsName,
    IN  BOOLEAN                 IpAddrResolved
    );

NTSTATUS
NbtProcessLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  enum eNbtLmhRequestType RequestType
    );

VOID
StartLmHostTimer(
    NBT_WORK_ITEM_CONTEXT   *pContext,
    IN BOOLEAN              fLockedOnEntry
    );

NTSTATUS
LmHostQueueRequest(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  PVOID                   pDeviceContext
    );

VOID
TimeoutLmHRequests(
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  BOOLEAN             fLocked,
    IN  CTELockHandle       *pJointLockOldIrq
    );

tNAMEADDR *
FindInDomainList (
    IN PUCHAR           pName,
    IN PLIST_ENTRY      pDomainHead
    );

//---------------------------------------------------------------------
//
// Delayed (Non-Dpc) Worker routines:
//
typedef
VOID
(*PNBT_WORKER_THREAD_ROUTINE)(
    tDGRAM_SEND_TRACKING    *pTracker,
    PVOID                   pClientContext,
    PVOID                   ClientCompletion,
    tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\hndlrs.c
//
VOID
DelayedAllocLowerConn(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedAllocLowerConnSpecial(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedCleanupAfterDisconnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\Inbound.c
//
VOID
ExtractServerNameCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    );

VOID
CopyNodeStatusResponseCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    );

//
// In nbt\Name.c
//
VOID
DelayedReConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedSendDgramDist (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused1,
    IN  tDEVICECONTEXT          *Unused2
    );

VOID
DelayedWipeOutLowerconn(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\NameSrv.c
//
VOID
DelayedNextRefresh(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedRefreshBegin(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

VOID
DelayedSessionKeepAlive(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\NbtUtils.c
//
VOID
DelayedFreeAddrObj(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nbt\parse.c
//
VOID
DelayedScanLmHostFile (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

#ifndef VXD
//
// In nt\NtIsol.c
//
NTSTATUS
DelayedNbtProcessConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

//
// In nt\NtUtil.c
//
VOID
DelayedNbtDeleteDevice(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext
    );
#endif  // !VXD

#define MIN(x,y)    (((x) < (y)) ? (x) : (y))
#define MAX(x,y)    (((x) > (y)) ? (x) : (y))

int check_unicode_string(IN PUNICODE_STRING str);

NTSTATUS
PickBestAddress(
    IN  tNAMEADDR       *pNameAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tIPADDRESS      *pIpAddress
    );

#endif // _NBTPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\hosts.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lmhosts.h

Abstract:

    This is the header file for the lmhosts facility of the nbt driver.

Author:

    Eric Chin (ericc)           April 28, 1992

Revision History:

--*/
#ifndef _LMHOSTS_H_
#define _LMHOSTS_H_



//
// Configuration Defaults
//
// Only the first MAX_PARSE_BYTES of each line in the lmhosts file is
// examined.
//

#define DATABASEPATH                "\\SystemRoot\\nt\\system32\\drivers\\etc"

#define LMHOSTSFILE                 "lmhosts"           // name of lmhosts file

#define MAX_FILE_IO_THREADS         1                   // threads to read
                                                        //   lmhosts file
#ifdef VXD
#define DEF_PRELOAD                 100                 // Default entries to preload
#define MAX_PRELOAD                 500                 // Max cache entries to preload
#else
#define DEF_PRELOAD                 1000                // Default entries to preload
#define MAX_PRELOAD                 2000                // max cache entries to preload
#endif

#define MAX_MEMBERS_INTERNET_GROUP    50                // max size of internet group

//
// Reserved Keywords in the lmhosts File
//
#define BEG_ALT_TOKEN               "#BEGIN_ALTERNATE"  // alternate block
#define DOMAIN_TOKEN                "#DOM:"             // specifies LM domain
#define END_ALT_TOKEN               "#END_ALTERNATE"    // alternate block
#define INCLUDE_TOKEN               "#INCLUDE"          // include a file
#define PRELOAD_TOKEN               "#PRE"              // preload this entry
#define NOFNR_TOKEN                 "#NOFNR"            // no find name request


//
// Macro Definitions
//

//#define min(x, y)                   ((x) < (y) ? (x) : (y))



//
// Public Definitions
//
//
// For each file that is opened, a LM_FILE object is created.
//
typedef struct _LM_FILE
{
#ifndef VXD
    KSPIN_LOCK      f_lock;                     //  protects this object
    LONG            f_refcount;                 //  current no of references
#endif

    HANDLE          f_handle;                   //  handle from ZwOpenFile()
    LONG            f_lineno;                   //  current line number

#ifndef VXD
    LARGE_INTEGER   f_fileOffset;               //  current offset into file

    PUCHAR          f_current;                  //  buffer position to read
    PUCHAR          f_limit;                    //  last byte + 1 of buffer
    PUCHAR          f_buffer;                   //  start of buffer
#else
    PUCHAR          f_linebuffer;               //  line buffer
    PUCHAR          f_buffer;                   //  file buffer
    BOOL            f_EOF ;                     //  TRUE if EOF
    ULONG           f_CurPos ;                  //  Current Pos. in File Buffer
    ULONG           f_EndOfData ;               //  Last valid data in File Buffer
    PUCHAR          f_BackUp;                   //  copy here In case of #INCLUDE
#endif

} LM_FILE, *PLM_FILE;


//
// The LM_IPADDRESS_LIST object contains pertinent information about a
// group of ip addresses.
//
//
typedef struct _LM_IPADDRESS_LIST
{

    KSPIN_LOCK      i_rcntlock;                 // protects i_refcount
    LONG            i_refcount;                 // current no of references
    KSPIN_LOCK      i_lock;                     // only when adding to i_addrs[]
    int             i_maxaddrs;                 // max capacity of i_addrs[]
    int             i_numaddrs;                 // current no of ip addresses
    unsigned long   i_addrs[1];                 // the array of ip addresses

} LM_IPADDRESS_LIST, *PLM_IPADDRESS_LIST;


//
// An LM_PARSE_FUNCTION may be called recursively to handle #INCLUDE
// directives in an lmhosts file.
//
//
typedef unsigned long (* LM_PARSE_FUNCTION) (
    IN PUCHAR   path,                    // file to parse
    IN PUCHAR   target OPTIONAL,                  // NetBIOS name
    IN CHAR     RecurseLevel,                    // process #INCLUDE's ?
    OUT BOOLEAN *NoFindName                     // do not do find name
);


//
// The LM_WORK_ITEM object is the interface between lm_lookup() and
// LmFindName().
//
//
typedef struct _LM_WORK_ITEM
{                  // work for io thread(s)

    LIST_ENTRY      w_list;                     //  links to other items
//    mblk_t         *w_mp;                       //  STREAMS buffer

} LM_WORK_ITEM, *PLM_WORK_ITEM;



//
// Private Function Prototypes
//
int
LmAddToDomAddrList (
    IN PUCHAR name,
    IN unsigned long inaddr
    );

NTSTATUS
LmCloseFile (
    IN PLM_FILE handle
    );

NTSTATUS
LmCreateThreads (
    IN int nthreads
    );

NTSTATUS
LmDeleteAllDomAddrLists (
    VOID
    );

VOID
LmDerefDomAddrList(
    PLM_IPADDRESS_LIST arrayp
    );

char *
LmExpandName (
    OUT PUCHAR dest,
    IN PUCHAR source,
    IN UCHAR last
    );

PUCHAR
LmFgets (
    IN PLM_FILE pfile,
    OUT int *nbytes
    );

NTSTATUS
LmFindName (
    VOID
    );

PLM_IPADDRESS_LIST
LmGetDomAddrList (
    PUCHAR name
    );

unsigned long
LmGetIpAddr (
    IN PUCHAR path,
    IN PUCHAR target,
    IN CHAR   RecurseDepth,
    OUT BOOLEAN *NoFindName
    );

NTSTATUS
LmGetFullPath (
    IN PUCHAR  target,
    OUT PUCHAR *path
    );

unsigned long
LmInclude(
    IN PUCHAR            file,
    IN LM_PARSE_FUNCTION function,
    IN PUCHAR            argument,
    IN CHAR              RecurseDepth,
    OUT BOOLEAN          *NoFindName
    );

NTSTATUS
LmInitDomAddrLists (
    VOID
    );

VOID
LmLogOpenError (
    IN PUCHAR path,
    IN NTSTATUS unused
    );

VOID
LmLogSyntaxError (
    IN LONG lineno
    );

PLM_FILE
LmOpenFile (
    IN PUCHAR path
    );

int
LmPreloadEntry (
    IN PUCHAR name,
    IN unsigned long inaddr,
    IN unsigned int NoFNR
    );

BOOLEAN
LmPutCacheEntry (
//    IN mblk_t *mp,
    IN unsigned char *name,
    IN unsigned long inaddr,
    IN unsigned int ttl,
    IN LONG     nb_flags,
    IN unsigned int NoFNR
    );

NTSTATUS
LmTerminateThreads(
    VOID
    );

//
// Functions Imported from ..\common
//
extern unsigned long
inet_addr(
    IN char *cp
    );




#endif // _LMHOSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\vxddebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions.


    FILE HISTORY:
        KeithMo     20-Sep-1993 Created.
        MohsinA,    20-Nov-96.  Robust, added dangling else fix.
*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#ifdef DBG_PRINT
#include <stdarg.h>
#endif  // DBG_PRINT


#ifdef DEBUG

#define DBG_MEMALLOC_VERIFY  0x0BEEFCAFE

typedef struct {
    LIST_ENTRY    Linkage;          // to keep linked list of allocated blocks
    DWORD         Verify;           // our signature
    DWORD         ReqSize;          // original size as requested by caller
    DWORD         Owner[4];         // stack trace 4 deep (of ret.addrs)
} DbgMemBlkHdr;

LIST_ENTRY  DbgMemList;
ULONG       DbgLeakCheck;

//
//  Debug output control flags.
//

#define VXD_DEBUG_INIT                 0x00000001L
#define VXD_DEBUG_SOCKET               0x00000002L
#define VXD_DEBUG_MISC                 0x00000004L
#define VXD_DEBUG_BIND                 0x00000008L
#define VXD_DEBUG_ACCEPT               0x00000010L
#define VXD_DEBUG_CONNECT              0x00000020L
#define VXD_DEBUG_LISTEN               0x00000040L
#define VXD_DEBUG_RECV                 0x00000080L
#define VXD_DEBUG_SEND                 0x00000100L
#define VXD_DEBUG_SOCKOPT              0x00000200L
#define VXD_DEBUG_CONFIG               0x00000400L
#define VXD_DEBUG_CONNECT_EVENT        0x00000800L
#define VXD_DEBUG_DISCONNECT_EVENT     0x00001000L
#define VXD_DEBUG_ERROR_EVENT          0x00002000L
#define VXD_DEBUG_RECV_EVENT           0x00004000L
#define VXD_DEBUG_RECV_DATAGRAM_EVENT  0x00008000L
#define VXD_DEBUG_RECV_EXPEDITED_EVENT 0x00010000L

// #define VXD_DEBUG_                     0x00020000L
// #define VXD_DEBUG_                     0x00040000L
// #define VXD_DEBUG_                     0x00080000L
// #define VXD_DEBUG_                     0x00100000L
// #define VXD_DEBUG_                     0x00200000L
// #define VXD_DEBUG_                     0x00400000L
// #define VXD_DEBUG_                     0x00800000L
// #define VXD_DEBUG_                     0x01000000L
// #define VXD_DEBUG_                     0x02000000L
// #define VXD_DEBUG_                     0x04000000L
// #define VXD_DEBUG_                     0x08000000L
// #define VXD_DEBUG_                     0x10000000L
// #define VXD_DEBUG_                     0x20000000L
// #define VXD_DEBUG_                     0x40000000L

#define VXD_DEBUG_OUTPUT_TO_DEBUGGER   0x80000000L


//
//  Assert & require.
//

void VxdAssert( void          * pAssertion,
                void          * pFileName,
                unsigned long   nLineNumber );

#define VXD_ASSERT(exp) \
     if( !(exp) ){ VxdAssert( #exp, __FILE__, __LINE__ ); }else{}

#define VXD_REQUIRE VXD_ASSERT


#define DEBUG_BREAK     _asm int 3

#else   // !DEBUG =========================================================

//
//  Null assert & require.
//
#define VXD_ASSERT(exp)  /* Nothing */
#define VXD_REQUIRE(exp) ((void)(exp))

#define DEBUG_BREAK       /* Nothing */

#endif  // DEBUG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\timer.h ===
//
//
//  timer.h
//
//  This file contains the typedefinitions for the timer code


#ifndef __TIMERNBT_H
#define __TIMERNBT_H

// to convert a millisecond time to 100ns time
//
#define MILLISEC_TO_100NS       10000
// the completion routine that the client must define
typedef
    VOID
        (*COMPLETIONROUTINE)(
                IN  PVOID,      // context
                IN  PVOID,      // context2
                IN  PVOID);     // timerqentry
typedef
    VOID
        (*COMPLETIONCLIENT)(
                IN  PVOID,
                IN  NTSTATUS);

// Timer Queue Entry - this entry looks after a timer event.  It tracks who
// should be called when the timeout occurs, the time in the future of the
// timout, and a context value.
typedef struct
{
    LIST_ENTRY          Linkage;
    ULONG               Verify;
    USHORT              Retries;    // number of times to restart the timer
    BOOLEAN             fIsWakeupTimer;
    UCHAR               RefCount;   // to tell if the timer is expiring or not

    ULONG               DeltaTime;
    PVOID               *pDeviceContext;
    COMPLETIONROUTINE   TimeoutRoutine;
    PVOID               Context;

    PVOID               Context2;
    PVOID               ClientContext;
    COMPLETIONCLIENT    ClientCompletion;
    PVOID               pCacheEntry;        // entry in Remote or local cache

    HANDLE              WakeupTimerHandle;
    CTETimer            VxdTimer ;

    USHORT              Flags;      // to tell the timing system to restart the timer again
}tTIMERQENTRY;

// Flag bits for tTIMERQENTRY
#define TIMER_RESTART       0x0001
// to differentiate the broadcast timeouts from the timouts to the Name Service
#define TIMER_MNODEBCAST    0x0002
#define TIMER_DOING_EXPIRY  0x0004
#define TIMER_NOT_STARTED   0x0008
#define TIMER_RETIMED       0x0010  // timeout has changed, restart timer without any processing

// The timer Q itself
typedef struct
{
    LIST_ENTRY  ActiveHead;
    LIST_ENTRY  FreeHead;
    BOOLEAN     TimersInitialized;
} tTIMERQ;

//
// Function Prototype -  this function is only called locally to this file
//

//
//  TimerExpiry routine - Called by kernel upon timer expiration.  Note that
//      DeferredContext is the only argument used and must be named/used the
//      same between NT and WFW.
//
VOID
TimerExpiry(
#ifndef VXD
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
#else
    IN  CTEEvent * pCTEEvent,
    IN  PVOID      DeferredContext
#endif
    ) ;

//
//  ExpireTimer routine - Called to stop the current timer and call
//  the Timeout routine
//
VOID
ExpireTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    IN  CTELockHandle   *OldIrq1
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\ntprocs.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    NTProcs.c

Abstract:


    This file contains the function prototypes that are specific to the NT
    portion of the NBT driver.

Author:

    Johnl   29-Mar-1993     Created

Revision History:

--*/



#ifndef VXD

//---------------------------------------------------------------------
//
//  FROM DRIVER.C
//
NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             irp
    );

PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    );


USHORT
GetDriverName(
    IN  PFILE_OBJECT pfileobj,
    OUT PUNICODE_STRING name
    );

int
shortreply(
    IN PIRP     pIrp,
    IN int      status,
    IN int      nbytes
    );

//---------------------------------------------------------------------
//
//  FROM NTISOL.C
//
NTSTATUS
NTOpenControl(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTOpenAddr(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea);

NTSTATUS
NTOpenConnection(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea);

VOID
NTSetFileObjectContexts(
    IN  PIRP            pIrp,
    IN  PVOID           FsContext,
    IN  PVOID           FsContext2);

VOID
NTCompleteIOListen(
    IN  tCLIENTELE        *pClientEle,
    IN  NTSTATUS          Status);

VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength);

VOID
NTCompleteRegistration(
    IN  tCLIENTELE        *pClientEle,
    IN  NTSTATUS          Status);

NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCloseAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

VOID
NTClearFileObjectContext(
    IN  PIRP            pIrp
    );

NTSTATUS
NTCloseConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress);

NTSTATUS
NTCheckSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress);

NTSTATUS
NTCleanUpAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCleanUpConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

VOID
NbtCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelListen(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP Irp
    );

VOID
NbtCancelRcvDgram(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelDgramSend(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NTAccept(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTDisAssociateAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTConnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTDisconnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTListen(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);


NTSTATUS
NTQueryInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTReceive(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTReceiveDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSend(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetEventHandler(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTSetInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp);

NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP                   pIrp,
    IN  PVOID                  CancelRoutine,
    IN  tDEVICECONTEXT         *pDeviceContext
    );

NTSTATUS
NbtSetCancelRoutine(
    IN  PIRP                   pIrp,
    IN  PVOID                  CancelRoutine,
    IN  tDEVICECONTEXT         *pDeviceContext
    );

VOID
NbtCancelSession(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelWaitForLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NTSendSession(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  tLOWERCONNECTION      *pLowerConn,
    IN  PVOID                 pCompletion
    );

VOID
NTSendDgramNoWindup(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  ULONG                 IpAddress,
    IN  PVOID                 pCompletion);

NTSTATUS
NTQueueToWorkerThread(
    IN  PVOID                   DelayedWorkerRoutine,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 fJointLockHeld
    );

#ifdef _PNP_POWER_
VOID
NTExecuteWorker(
    IN  PVOID     pContextInfo
    );
#endif

VOID
SecurityDelete(
    IN  PVOID     pContext
    );

NTSTATUS
NbtSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN ULONG        ToiType,
    IN ULONG        InfoBufferValue
    );

NTSTATUS
DispatchIoctls(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp);

NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    );

VOID
NTClearContextCancel(
    IN NBT_WORK_ITEM_CONTEXT    *pContext
    );

VOID
NbtCancelFindName(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );


//---------------------------------------------------------------------
//
// FROM TDIADDR.C
//

NTSTATUS
NbtProcessIPRequest(
    IN ULONG        IPControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    );

//---------------------------------------------------------------------
//
// FROM NTUTIL.C
//

#ifdef _PNP_POWER_
NTSTATUS
NbtAllocAndInitDevice(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    );
#endif  // _PNP_POWER_

NTSTATUS
NbtCreateDeviceObject(
    PUNICODE_STRING     pBindName,
    PUNICODE_STRING     pExportName,
    tADDRARRAY          *pAddrs,
    tDEVICECONTEXT      **ppDeviceContext,
    enum eNbtDevice     DeviceType
    );

VOID
NbtDeleteDevice(
    IN  PVOID       pContext
    );

BOOLEAN
NBT_REFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    ULONG               ReferenceContext,
    IN BOOLEAN          fLocked
    );

VOID
NBT_DEREFERENCE_DEVICE(
    IN  tDEVICECONTEXT  *pDeviceContext,
    ULONG               ReferenceContext,
    IN BOOLEAN          fLocked
    );

tDEVICECONTEXT *
GetDeviceWithIPAddress(
    tIPADDRESS          IpAddress
    );

NTSTATUS
NbtProcessDhcpRequest(
    tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
ConvertToUlong(
    IN  PUNICODE_STRING      pucAddress,
    OUT ULONG                *pulValue);


NTSTATUS
NbtCreateAddressObjects(
    IN  ULONG                IpAddress,
    IN  ULONG                SubnetMask,
    OUT tDEVICECONTEXT       *pDeviceContext);

VOID
NbtGetMdl(
    PMDL    *ppMdl,
    enum eBUFFER_TYPES eBuffType);

NTSTATUS
NbtInitMdlQ(
    PSINGLE_LIST_ENTRY pListHead,
    enum eBUFFER_TYPES eBuffType);

NTSTATUS
NTZwCloseFile(
    IN  HANDLE      Handle
    );


NTSTATUS
NTReReadRegistry(
    IN  tDEVICECONTEXT  *pDeviceContext
    );

NTSTATUS
NbtInitIrpQ(
    PLIST_ENTRY pListHead,
    int iNumBuffers);

NTSTATUS
NbtLogEvent(
    IN ULONG             EventCode,
    IN NTSTATUS          Status,
    IN ULONG             Location
    );

VOID
DelayedNbtLogDuplicateNameEvent(
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  tDEVICECONTEXT          *pDeviceContext
    );

NTSTATUS
SaveClientSecurity(
    IN  tDGRAM_SEND_TRACKING      *pTracker
    );

VOID
NtDeleteClientSecurity(
    IN  tDGRAM_SEND_TRACKING    *pTracker
    );

VOID
LogLockOperation(
    char          operation,
    PKSPIN_LOCK   PSpinLock,
    KIRQL         OldIrql,
    KIRQL         NewIrql,
    char         *File,
    int           Line
    );
StrmpInitializeLockLog(
    VOID
    );
VOID
PadEntry(
    char *EntryPtr
    );

VOID
DelayedNbtCloseFileHandles(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    );

NTSTATUS
CloseAddressesWithTransport(
    IN  tDEVICECONTEXT  *pDeviceContext
        );

PVOID
CTEAllocMemDebug(
    IN  ULONG   Size,
    IN  PVOID   pBuffer,
    IN  UCHAR   *File,
    IN  ULONG   Line
    );

VOID
AcquireSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN PKIRQL          pOldIrq,
    IN INT             LineNumber
    );

VOID
FreeSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN KIRQL           OldIrq,
    IN INT             LineNumber
    );

VOID
AcquireSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    );

VOID
FreeSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    );

VOID
GetDgramMdl(
    OUT PMDL  *ppMdl
    );

NTSTATUS
NbtDestroyDevice(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN BOOLEAN          fWait
    );


//---------------------------------------------------------------------
//
// FROM REGISTRY.C
//
NTSTATUS
NbtReadRegistry(
    OUT tDEVICES        **ppBindDevices,
    OUT tDEVICES        **ppExportDevices,
    OUT tADDRARRAY      **ppAddrArray
    );

VOID
NbtReadRegistryCleanup(         // release resources allocated by NbtReadRegistry
    IN tDEVICES        **ppBindDevices,
    IN tDEVICES        **ppExportDevices,
    IN tADDRARRAY      **ppAddrArray
    );

NTSTATUS
ReadNameServerAddresses (
    IN  HANDLE      NbtConfigHandle,
    IN  tDEVICES    *BindDevices,
    IN  ULONG       NumberDevices,
    OUT tADDRARRAY  **ppAddrArray
    );

NTSTATUS
GetIPFromRegistry(
    IN  PUNICODE_STRING         pucBindDevice,
    OUT tIPADDRESS              *pIpAddresses,
    OUT tIPADDRESS              *pSubnetMask,
    IN  ULONG                   MaxIpAddresses,
    OUT ULONG                   *pNumIpAddresses,
    IN  enum eNbtIPAddressType  IPAddressType
    );

NTSTATUS
ReadElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    );

NTSTATUS
NTReadIniString (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       Key,
    OUT PUCHAR      *ppString
    );

ULONG
NbtReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

NTSTATUS
NTGetLmHostPath(
    OUT PUCHAR *ppPath
    );

NTSTATUS
NbtParseMultiSzEntries(
    IN  PWSTR       StartBindValue,
    IN  PWSTR       EndBindValue,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,
    OUT ULONG       *pNumDevices
    );

//---------------------------------------------------------------------
//
// FROM tdihndlr.c
//
NTSTATUS
Normal(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
FillIrp(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
IndicateBuffer(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
PartialRcv(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PVOID               *ppIrp
    );
NTSTATUS
TdiReceiveHandler (
    IN  PVOID           ReceiveEventContext,
    IN  PVOID           ConnectionContext,
    IN  USHORT          ReceiveFlags,
    IN  ULONG           BytesIndicated,
    IN  ULONG           BytesAvailable,
    OUT PULONG          BytesTaken,
    IN  PVOID           Tsdu,
    OUT PIRP            *IoRequestPacket
    );

NTSTATUS
PassRcvToTransport(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnectEle,
    IN PVOID                pIoRequestPacket,
    IN PULONG               pRcvLength
    );

NTSTATUS
CompletionRcv(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
NtBuildIrpForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    );

NTSTATUS
SetEventHandler (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PFILE_OBJECT         FileObject,
    IN ULONG                EventType,
    IN PVOID                EventHandler,
    IN PVOID                Context
    );

NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP         Irp
    );

NTSTATUS
TdiConnectHandler (
    IN PVOID                pConnectEventContext,
    IN int                  RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pConnectionContext,
    OUT PIRP                *ppAcceptIrp
    );

NTSTATUS
TdiDisconnectHandler (
    PVOID            EventContext,
    PVOID            ConnectionContext,
    ULONG            DisconnectDataLength,
    PVOID            DisconnectData,
    ULONG            DisconnectInformationLength,
    PVOID            DisconnectInformation,
    ULONG            DisconnectIndicators
    );
NTSTATUS
TdiRcvDatagramHandler(
    IN  PVOID                pDgramEventContext,
    IN  int                  SourceAddressLength,
    IN  PVOID                pSourceAddress,
    IN  int                  OptionsLength,
    IN  PVOID                pOptions,
    IN  ULONG                ReceiveDatagramFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN  PVOID                pTsdu,
    OUT PIRP                 *pIoRequestPacket
    );
NTSTATUS
TdiRcvNameSrvHandler(
    IN PVOID                 pDgramEventContext,
    IN int                   SourceAddressLength,
    IN PVOID                 pSourceAddress,
    IN int                   OptionsLength,
    IN PVOID                 pOptions,
    IN ULONG                 ReceiveDatagramFlags,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,
    OUT PIRP                 *pIoRequestPacket
    );
NTSTATUS
TdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    );

NTSTATUS
CompletionRcvDgram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
MakePartialMdl (
    IN tCONNECTELE      *pConnEle,
    IN PIRP             pIrp,
    IN ULONG            ToCopy
    );

NTSTATUS
OutOfRsrcKill(
    OUT tLOWERCONNECTION    *pLowerConn);

VOID
CopyToStartofIndicate (
    IN tLOWERCONNECTION       *pLowerConn,
    IN ULONG                  DataTaken
    );

//---------------------------------------------------------------------
//
// FROM tdicnct.c
//
NTSTATUS
CreateDeviceString(
    IN  PWSTR               AppendingString,
    IN OUT PUNICODE_STRING  pucDevice
    );


//---------------------------------------------------------------------
//
// FROM winsif.c
//
NTSTATUS
NTOpenWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tIPADDRESS      IpAddress
    );

NTSTATUS
NTCleanUpWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    );

NTSTATUS
NTCloseWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    );

NTSTATUS
RcvIrpFromWins (
    IN  PCTE_IRP        pIrp
    );

NTSTATUS
PassNamePduToWins (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes
    );

NTSTATUS
WinsSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  BOOLEAN         MustSend);

NTSTATUS
WinsRegisterName(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  tNAMEADDR      *pNameAddr,
    IN  PUCHAR         pScope,
    IN  enum eNSTYPE   eNsType
    );

NTSTATUS
WinsSetInformation(
    IN  tWINS_INFO      *pWins,
    IN  tWINS_SET_INFO  *pWinsSetInfo
    );

//---------------------------------------------------------------------
//
// FROM ntpnp.c
//
VOID
NbtNotifyTdiClients(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  enum eTDI_ACTION    Action
    );

#ifdef _NETBIOSLESS
tDEVICECONTEXT *
NbtCreateSmbDevice(
    );
#endif

NTSTATUS
NbtDeviceAdd(
    PUNICODE_STRING pucBindString
    );

NTSTATUS
NbtDeviceRemove(
    PUNICODE_STRING pucBindString
    );

VOID
TdiAddressArrival(
    IN  PTA_ADDRESS         Addr,
    IN  PUNICODE_STRING     pDeviceName,
    IN  PTDI_PNP_CONTEXT    Context
    );

VOID
TdiAddressDeletion(
    IN  PTA_ADDRESS         Addr,
    IN  PUNICODE_STRING     pDeviceName,
    IN  PTDI_PNP_CONTEXT    Context
    );

VOID
TdiBindHandler(
    IN  TDI_PNP_OPCODE      PnPOpcode,
    IN  PUNICODE_STRING     DeviceName,
    IN  PWSTR               MultiSZBindList
    );


NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     DeviceName,
    IN  PNET_PNP_EVENT      PnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    );

VOID
NbtPnPPowerComplete(
    IN PNET_PNP_EVENT  NetEvent,
    IN NTSTATUS        ProviderStatus
    );

NTSTATUS
CheckSetWakeupPattern(
    tDEVICECONTEXT  *pDeviceContext,
    PUCHAR          pName,
    BOOLEAN         RequestAdd
    );


NTSTATUS
NbtCreateNetBTDeviceObject(
    PDRIVER_OBJECT       DriverObject,
    tNBTCONFIG           *pConfig,
    PUNICODE_STRING      RegistryPath
    );

NTSTATUS
NbtNtPNPInit(
        VOID
    );

VOID
NbtFailedNtPNPInit(
        VOID
    );

NTSTATUS
NbtAddressAdd(
    IN  ULONG           IpAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PUNICODE_STRING pucBindString
    );

NTSTATUS
NbtAddNewInterface (
    IN  PIRP            pIrp,
    IN  PVOID           *pBuffer,
    IN  ULONG            Size
    );

VOID
NbtAddressDelete(
    ULONG   IpAddr
    );

tDEVICECONTEXT      *
NbtFindAndReferenceDevice(
    PUNICODE_STRING      pucBindName,
    BOOLEAN              fNameIsBindName
    );

#if FAST_DISP
NTSTATUS
NbtQueryIpHandler(
    IN  PFILE_OBJECT    FileObject,
    IN  ULONG           IOControlCode,
    OUT PVOID           *EntryPoint
    );
#endif

//---------------------------------------------------------------------
//
// FROM AutoDial.c
//
VOID
NbtAcdBind(
    );

VOID
NbtAcdUnbind(
    );

NTSTATUS
LookupDeviceInRegistry(
    IN PUNICODE_STRING pBindName,
    OUT tADDRARRAY* pAddrs,
    OUT PUNICODE_STRING pExportName);

void SetNodeType(void);

void NbtUpBootCounter(void);

void NbtDownBootCounter(void);

NTSTATUS
NbtSetSmbBindingInfo2(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  NETBT_SMB_BIND_REQUEST  *pSmbRequest
    );

#endif  // !VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\oscfgnbt.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

#ifndef OSCFG_INCLUDED
#define OSCFG_INCLUDED


#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#define net_long(_x)  _byteswap_ulong(_x)
#else
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))

//#define net_long(x) (((net_short((x)&0xffff)) << 16) | net_short((((x)&0xffff0000L)>>16)))
#define net_long(x) (((((ulong)(x))&0xffL)<<24) | \
                     ((((ulong)(x))&0xff00L)<<8) | \
                     ((((ulong)(x))&0xff0000L)>>8) | \
                     ((((ulong)(x))&0xff000000L)>>24))
#endif
#define MIN(a,b)    ((a) < (b) ? (a) : (b))
#define MAX(a,b)    ((a) > (b) ? (a) : (b))


#ifdef  VXD
/////////////////////////////////////////////////////////////////////////////
//
// VXD definitions
//
////////////////////////////////////////////////////////////////////////////

#include <stddef.h>

#ifndef CHICAGO

#pragma code_seg("_LTEXT", "LCODE")
#pragma data_seg("_LDATA", "LCODE")

//* pragma bodies for bracketing of initialization code.

#define BEGIN_INIT  code_seg("_ITEXT", "ICODE")
#define BEGIN_INIT_DATA data_seg("_IDATA", "ICODE")
#define END_INIT    code_seg()
#define END_INIT_DATA data_seg()

#else // CHICAGO

#define INNOCUOUS_PRAGMA warning(4:4206)   // Source File is empty

#define BEGIN_INIT      INNOCUOUS_PRAGMA
#define BEGIN_INIT_DATA INNOCUOUS_PRAGMA
#define END_INIT        INNOCUOUS_PRAGMA
#define END_INIT_DATA   INNOCUOUS_PRAGMA

#endif // CHICAGO

#else // VXD
#ifdef NT

//////////////////////////////////////////////////////////////////////////////
//
// NT definitions
//
//////////////////////////////////////////////////////////////////////////////

#include <ntos.h>
#include <zwapi.h>

#define BEGIN_INIT
#define END_INIT

#else // NT

/////////////////////////////////////////////////////////////////////////////
//
// Definitions for additional environments go here
//
/////////////////////////////////////////////////////////////////////////////

#error Environment specific definitions missing

#endif // NT

#endif  // VXD


#endif // OSCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\kdext\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#include <ntkdexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <..\..\inc\types.h>

PNTKD_OUTPUT_ROUTINE         lpOutputRoutine;
PNTKD_GET_EXPRESSION         lpGetExpressionRoutine;
PNTKD_GET_SYMBOL             lpGetSymbolRoutine;
PNTKD_READ_VIRTUAL_MEMORY    lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define MAX_LIST_ELEMENTS 4096
BYTE    DataBuffer[4096];

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 4096
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 4096
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
ULONG s_NoOfColumns = 1;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData(PVOID dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size )
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString(PUCHAR dwAddress, PSZ buf )
{
    do
    {
        if (!GetData (dwAddress, buf, 1))
        {
            return FALSE;
        }

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (LPVOID) puStr->Buffer,
                  UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (LPVOID) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}


/*
 * Get the ULONG value referenced by the pointer given to us
 */
VOID
Next3(
    PVOID   Ptr,
    PVOID   *pFLink,
    PVOID   *pBLink,
    PULONG_PTR pVerify
    )
{
    PVOID Buffer[4];

    GetData(Ptr, (PVOID) Buffer, sizeof(PVOID)*3);

    if (pFLink)
    {
        *pFLink = Buffer[0];
    }

    if (pBLink)
    {
        *pBLink = Buffer[1];
    }

    if (pVerify)
    {
        *pVerify = (ULONG_PTR) Buffer[2];
    }
}


/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
char *DotSeparator = ".";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

VOID
PrintStructFields(PVOID dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;
    int j;
    BYTE  ch;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        PRINTF( "(0x%-2X) ", pFieldDescriptors->Offset );

        switch( pFieldDescriptors->FieldType ) {
          case FieldTypeByte:
          case FieldTypeChar:
              PRINTF( "%-16d%s",
                  *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeBoolean:
              PRINTF( "%-16s%s",
                  *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                  NewLineForFields(i));
              break;

          case FieldTypeBool:
              PRINTF( "%-16s%s",
                  *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                  NewLineForFields(i));
              break;

          case FieldTypePointer:
              PRINTF( "%-16X%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeULongULong:
              PRINTF( "%d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset + sizeof(ULONG)),
                  FieldSeparator );
              PRINTF( "%d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeListEntry:

              if ( (PVOID)((PUCHAR)dwAddress + pFieldDescriptors->Offset) ==
                  *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset ))
              {
                  PRINTF( "%s", "List Empty\n" );
              }
              else
              {
                    PVOID  Address, StartAddress;
                    ULONG  Count = 0;
                    UCHAR  Greater = ' ';

                    StartAddress = (PVOID) (((PUCHAR)dwAddress) + pFieldDescriptors->Offset);
                    Address = *(PVOID *) (((PUCHAR)ptr) + pFieldDescriptors->Offset);

                    while ((Address != StartAddress) &&
                           (++Count < MAX_LIST_ELEMENTS))
                    {
                        Next3 (Address, &Address, NULL, NULL);
                    }

                    if (Address != StartAddress)
                    {
                        Greater = '>';
                    }

                  PRINTF( "%-8X%s",
                      *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset ),
                      FieldSeparator );
                  PRINTF( "%-8X, (%c %d Elements)%s",
                      *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset + sizeof(PVOID)),
                      Greater, Count,
                      NewLineForFields(i) );
              }
              break;

          // Ip address: 4 bytes long
          case FieldTypeIpAddr:
             PRINTF( "%X%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  FieldSeparator );
             PRINTF( "(%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 3),
                  DotSeparator );
             PRINTF( "%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 2 ),
                  DotSeparator );
             PRINTF( "%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 1 ),
                  DotSeparator );
             PRINTF( "%d)%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
             break;

          // Mac address: 6 bytes long
          case FieldTypeMacAddr:
             for (j=0; j<5; j++)
             {
                 PRINTF( "%X%s",
                     *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j),
                      FieldSeparator );
             }
             PRINTF( "%X%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 5),
                  NewLineForFields(i) );
             break;

          // Netbios name: 16 bytes long
          case FieldTypeNBName:
             //
             // if first byte is printable, print the first 15 bytes as characters
             // and 16th byte as a hex value.  otherwise, print all the 16 bytes
             // as hex values
             //
             ch = *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset);
             if (ch >= 0x20 && ch <= 0x7e)
             {
                 for (j=0; j<15; j++)
                 {
                     PRINTF( "%c", *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j));
                 }
                 PRINTF( "<%X>%s",
                     *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 15),
                      NewLineForFields(i) );
             }
             else
             {
                 for (j=0; j<16; j++)
                 {
                     PRINTF( "%.2X",
                         *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j));
                 }
                 PRINTF( "%s", NewLineForFields(i) );
             }
             break;

          case FieldTypeULong:
          case FieldTypeLong:
              PRINTF( "%-16d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeShort:
              PRINTF( "%-16X%s",
                  *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeUShort:
              PRINTF( "%-16X%s",
                  *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeUnicodeString:
              PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
              PRINTF( NewLine );
              break;

          case FieldTypeAnsiString:
              PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
              PRINTF( NewLine );
              break;

          case FieldTypeSymbol:
              {
                  UCHAR SymbolName[ 200 ];
                  ULONG Displacement;
                  PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                  lpGetSymbolRoutine( sym, SymbolName, &Displacement );
                  PRINTF( "%-16s%s",
                          SymbolName,
                          NewLineForFields(i) );
              }
              break;

          case FieldTypeEnum:
              {
                 ULONG EnumValue;
                 ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
                 // Get the associated numericla value.

                 EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

                 if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                      != NULL) {
                     //
                     // An auxilary textual description of the value is
                     // available. Display it instead of the numerical value.
                     //

                     LPSTR pEnumName = NULL;

                     while (pEnumValueDescr->EnumName != NULL) {
                         if (EnumValue == pEnumValueDescr->EnumValue) {
                             pEnumName = pEnumValueDescr->EnumName;
                             break;
                         }
                     }

                     if (pEnumName != NULL) {
                         PRINTF( "%-16s ", pEnumName );
                     } else {
                         PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                     }

                 } else {
                     //
                     // No auxilary information is associated with the ehumerated type
                     // print the numerical value.
                     //
                     PRINTF( "%-16d",EnumValue);
                 }
              }
              break;

          case FieldTypeStruct:
              PRINTF( "@%-15X%s",
                  ((PUCHAR)dwAddress + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeLargeInteger:
          case FieldTypeFileTime:
          default:
              ERROR( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
              break;
        }
    }
}

LPSTR LibCommands[] = {
    "columns <d> -- controls the number of columns in the display ",
    "logdump <Log Address>\n",
    "dump <Struct Type Name>@<address expr>, for eg: !netbtkd.dump tNBTCONFIG@xxxxxx ",
    "devices <netbt!NbtConfig>",
    "connections <netbt!NbtConfig>",
    "verifyll <ListHead> [<Verify>]",
    "cache [Local|Remote]",
    0
};

BOOL
help(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    int i;

    SETCALLBACKS();

    for( i=0; Extensions[i]; i++ )
        PRINTF( "   %s\n", Extensions[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    return TRUE;
}


BOOL
columns(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG NoOfColumns;
    int   i;

    SETCALLBACKS();

    sscanf(lpArgumentString,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return TRUE;
}



BOOL
globals(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PVOID dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    SETCALLBACKS();

    strcpy( buf, "srv!" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[4], GlobalBool[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) (buf);
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !GetData( dwAddress,&b, sizeof(b)) )
            return FALSE;

        PRINTF( "%s%-30s %10s%s",
            c&1 ? "    " : "",
            GlobalBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[4], GlobalShort[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) ( buf );
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !GetData( dwAddress,&s,sizeof(s)) )
            return FALSE;

        PRINTF( "%s%-30s %10d%s",
            c&1 ? "    " : "",
            GlobalShort[i],
            s,
            c&1 ? "\n" : "" );
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLong[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) ( buf );
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !GetData(dwAddress,&l, sizeof(l)) )
            return FALSE;

        PRINTF( "%s%-30s %10d%s",
            c&1 ? "    " : "",
            GlobalLong[i],
            l,
            c&1 ? "\n" : "" );
    }

    PRINTF( "\n" );

    return TRUE;
}


BOOL
version
(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
#if    VER_DEBUG
    char *kind = "checked";
#else
    char *kind = "free";
#endif

    SETCALLBACKS();

    PRINTF( "Redirector debugger Extension dll for %s build %u\n", kind, VER_PRODUCTBUILD );

    return TRUE;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@ "
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

BOOL
dump(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PVOID   dwAddress;

    SETCALLBACKS();

    if( lpArgumentString && *lpArgumentString ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = lpArgumentString;
        LPSTR lpArgs = strpbrk(lpArgumentString, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {

                dwAddress = (PVOID) (lpGetExpressionRoutine)( ++lpArgs );
                if (GetData(dwAddress,DataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        &DataBuffer,
                        Structs[Index].FieldDescriptors);
                    PRINTF(
                        "---------------- %s@%lx ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return TRUE;
}


BOOL
devices(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pHead;
    tDEVICECONTEXT      *pDeviceContext;
    STRUCT_DESCRIPTOR   *pStructs = Structs;
    ULONG               Index = 0;
    tNBTCONFIG          *ConfigPtr = (tNBTCONFIG *) lpArgumentString;
    tDEVICECONTEXT      **ppNbtSmbDevice;

    PVOID dwAddress;

    SETCALLBACKS();

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        ConfigPtr = (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    }
    else
    {
        ConfigPtr = (tNBTCONFIG *) lpGetExpressionRoutine (lpArgumentString);
    }
    ppNbtSmbDevice = (tDEVICECONTEXT **) lpGetExpressionRoutine ("netbt!pNbtSmbDevice");

    while (pStructs->StructName != 0)
    {
        if (!(_strnicmp("tDEVICECONTEXT", pStructs->StructName, 10)))
        {
            break;
        }
        Index++;
        pStructs++;
    }

    if (pStructs->StructName == 0)
    {
        PRINTF ("ERROR:  Could not find structure definition for <tDEVICECONTEXT>\n");
        return FALSE;
    }

    if (!GetData(ppNbtSmbDevice, DataBuffer, sizeof (tDEVICECONTEXT *)))
    {
        PRINTF ("ERROR:  Could not read pNbtSmbDevice ptr\n");
    }
    else if (!(pDeviceContext = *((tDEVICECONTEXT **) DataBuffer)))
    {
        PRINTF ("pNbtSmbDevice is NULL\n");
    }
    else if (!GetData(pDeviceContext, DataBuffer, Structs[Index].StructSize))
    {
        PRINTF ("ERROR:  Could not read pNbtSmbDevice data@ <%p>\n", pDeviceContext);
    }
    else
    {
        //
        // Dump this Device's Info
        //
        PRINTF("pNbtSmbDevice @ <%p>\n", pDeviceContext);
        PRINTF( "++++++++++++++++ %s @%lx ++++++++++++++++\n", Structs[Index].StructName, pDeviceContext);
        PrintStructFields( pDeviceContext, &DataBuffer, Structs[Index].FieldDescriptors);
        PRINTF("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    }

    pHead = &ConfigPtr->DeviceContexts;
    if (!GetData(ConfigPtr, DataBuffer, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", ConfigPtr);
        return FALSE;
    }

    //
    // Get the number of Devices attached
    //
    {
        PVOID StartAddress;
        PVOID Address;
        ULONG Count = 0;
        PVOID Buffer[4];
        UCHAR Greater = ' ';

        StartAddress = pHead;
        GetData( StartAddress, Buffer, sizeof(ULONG)*4 );
        Address = Buffer[0];

        while ((Address != StartAddress) &&
               (++Count < MAX_LIST_ELEMENTS))
        {
            GetData( Address, Buffer, sizeof(ULONG)*4 );
            Address = Buffer[0];
        }

        PRINTF( "Dumping <%d> Devices attached to NbtConfig@<%x>\n", Count, ConfigPtr);
    }

    ConfigPtr = (tNBTCONFIG *) DataBuffer;
    pEntry = ConfigPtr->DeviceContexts.Flink;

    while (pEntry != pHead)
    {
        pDeviceContext = (tDEVICECONTEXT *) CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        if (!GetData(pDeviceContext, DataBuffer, Structs[Index].StructSize))
        {
            PRINTF ("ERROR:  Could not read DeviceContext data @<%x>\n", pDeviceContext);
            return FALSE;
        }

        //
        // Dump this Device's Info
        //
        PRINTF( "++++++++++++++++ %s @%lx ++++++++++++++++\n", Structs[Index].StructName, pDeviceContext);
        PrintStructFields( pDeviceContext, &DataBuffer, Structs[Index].FieldDescriptors);

        //
        // Go to next device
        //
        pDeviceContext = (tDEVICECONTEXT *) DataBuffer;
        pEntry = pDeviceContext->Linkage.Flink;
    }

    return (TRUE);
}

BOOL
connections(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY         pEntry, pHead, pClientHead, pClientEntry, pConnHead, pConnEntry;
    tNBTCONFIG          *ConfigPtr;
    tADDRESSELE         *pAddressEle;
    tCLIENTELE          *pClient;
    tCONNECTELE         *pConnEle, *pSavConnEle;
    tNAMEADDR           *pNameAddr;
    tLISTENREQUESTS     *pListen;

    SETCALLBACKS();

    PRINTF ("Dumping information on all NetBT conections ...\n");

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        ConfigPtr    =   (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    }
    else
    {
        ConfigPtr = (tNBTCONFIG *) (lpGetExpressionRoutine) (lpArgumentString);
    }

    pHead = &ConfigPtr->AddressHead;
    if (!GetData(ConfigPtr, DataBuffer, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", ConfigPtr);
        return FALSE;
    }
    ConfigPtr = (tNBTCONFIG *) DataBuffer;
    Next3 (pHead, &pEntry, NULL, NULL);

    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        Next3 (&pAddressEle->pNameAddr, &pNameAddr, NULL, NULL);
        if (!GetData(pNameAddr, DataBuffer, sizeof(tNAMEADDR)))
        {
            PRINTF ("[1] Error reading pNameAddr data @<%x>", pNameAddr);
            return FALSE;
        }
        pNameAddr = (tNAMEADDR *) DataBuffer;
        PRINTF ("Address@<%x> ==> <%-16.16s:%x>\n", pAddressEle, pNameAddr->Name, pNameAddr->Name[15]);

        pClientHead = &pAddressEle->ClientHead;
        Next3 (pClientHead, &pClientEntry, NULL, NULL);
        while (pClientEntry != pClientHead)
        {
            pClient = CONTAINING_RECORD(pClientEntry,tCLIENTELE,Linkage);
            if (!GetData(pClient, DataBuffer, sizeof(tCLIENTELE)))
            {
                PRINTF ("Error reading pClientEle data @<%p>", pClient);
                continue;
            }

            PRINTF ("\tClient@<%p> ==> pDevice=<%p>\n", pClient, ((tCLIENTELE *)DataBuffer)->pDeviceContext);

            PRINTF ("\t\t(ConnectHead):\n");
            pConnHead = &pClient->ConnectHead;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tCONNECTELE)))
                {
                    PRINTF ("[2] Error reading pConnEle data @<%x>", pConnEle);
                    return FALSE;
                }
                pConnEle = (tCONNECTELE *) DataBuffer;
                PRINTF ("\t\t ** Connection@<%x> ==> <%-16.16s:%x>:\n",
                    pSavConnEle, pConnEle->RemoteName, pConnEle->RemoteName[15]);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            PRINTF ("\t\t(ConnectActive):\n");
            pConnHead = &pClient->ConnectActive;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tCONNECTELE)))
                {
                    PRINTF ("[3] Error reading pConnEle data @<%x>", pConnEle);
                    return FALSE;
                }
                pConnEle = (tCONNECTELE *) DataBuffer;
                PRINTF ("\t\t ** Connection@<%x> ==> <%-16.16s:%x>:\n",
                    pSavConnEle, pConnEle->RemoteName, pConnEle->RemoteName[15]);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            PRINTF ("\t\t(ListenHead):\n");
            pConnHead = &pClient->ListenHead;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tLISTENREQUESTS)))
                {
                    PRINTF ("[4] Error reading pListen data @<%x>", pSavConnEle);
                    return FALSE;
                }
                pListen = (tLISTENREQUESTS *) DataBuffer;
                PRINTF ("\t\t ** pListen@<%p> ==> pIrp=<%p>\n", pSavConnEle, pListen->pIrp);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            Next3 (pClientEntry, &pClientEntry, NULL, NULL);
        }
        Next3 (pEntry, &pEntry, NULL, NULL);
        PRINTF ("\n");
    }

    PRINTF( "---------------- Connections ----------------\n");

    return (TRUE);
}


BOOL
verifyll(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY pHead, pCurrentEntry, pNextEntry, pPreviousEntry;
    ULONG_PTR   VerifyRead, VerifyIn = 0;
    ULONG       Count = 0;
    BOOL        fVerifyIn = FALSE;
    BOOL        fListCorrupt = FALSE;

    SETCALLBACKS();

    PRINTF ("Verifying Linked list ...\n");

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        PRINTF ("Usage: !NetbtKd.VerifyLL <ListHead> [<Verify]>\n");
        return FALSE;
    }
    else
    {
        //
        // lpArgumentString = "<pHead> [<Verify>]"
        //
        LPSTR lpVerify;

        while (*lpArgumentString == ' ')
        {
            lpArgumentString++;
        }
        lpVerify = strpbrk(lpArgumentString, NAME_DELIMITERS);

        pHead = (PVOID) (lpGetExpressionRoutine) (lpArgumentString);
        if (lpVerify)
        {
            VerifyIn = (lpGetExpressionRoutine) (lpVerify);
            fVerifyIn = TRUE;
        }
    }

    PRINTF ("** ListHead@<%x>, fVerifyIn=<%x>, VerifyIn=<%x>:\n\n", pHead, fVerifyIn, VerifyIn);
    PRINTF ("Verifying Flinks ...");

    // Read in the data for the first FLink in the list!
    pPreviousEntry = pHead;
    Next3 (pHead, &pCurrentEntry, NULL, NULL);
    Next3 (pCurrentEntry, &pNextEntry, NULL, &VerifyRead);

    while ((pCurrentEntry != pHead) &&
           (++Count < MAX_LIST_ELEMENTS))
    {
        if ((fVerifyIn) &&
            (VerifyRead != VerifyIn))
        {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far, Previous=<%x>, Current=<%x>, Next=<%x>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        Next3 (pCurrentEntry, &pNextEntry, NULL, &VerifyRead);
    }

    if (!fListCorrupt)
    {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF ("Verifying Blinks ...");

    Count = 0;
    fListCorrupt = FALSE;
    // Read in the data for the first BLink in the list!
    pPreviousEntry = pHead;
    Next3 (pHead, NULL, &pCurrentEntry, NULL);
    Next3 (pCurrentEntry, NULL, &pNextEntry, &VerifyRead);

    while ((pCurrentEntry != pHead) &&
           (++Count < MAX_LIST_ELEMENTS))
    {
        if ((fVerifyIn) &&
            (VerifyRead != VerifyIn))
        {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far, Previous=<%x>, Current=<%x>, Next=<%x>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        Next3 (pCurrentEntry, NULL, &pNextEntry, &VerifyRead);
    }

    if (!fListCorrupt)
    {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF( "---------------- Verify LinkedList ----------------\n");

    return (TRUE);
}


BOOL
DumpCache(
    tHASHTABLE          *pHashTable,
    enum eNbtLocation   CacheType
    )
{
    LONG                    i, NumBuckets;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tHASHTABLE              HashTbl;
    tNAMEADDR               NameAddr, *pNameAddr;

    if (!GetData(pHashTable, &HashTbl, sizeof(tHASHTABLE)))
    {
        PRINTF ("ERROR:  Could not read %s HashTable data @<%x>\n",
            (CacheType == NBT_LOCAL ? "Local":"Remote"), pHashTable);
        return FALSE;
    }

    NumBuckets = HashTbl.lNumBuckets;
    PRINTF ("\nDumping %s Cache = <%d> buckets:\n",
        (CacheType == NBT_LOCAL ? "Local":"Remote"), NumBuckets);
    PRINTF ("[Bkt#]\t<Address>  => <Name              > |  IpAddr  | RefC |    State |       Ttl\n");
    PRINTF ("-----------------------------------------------------------------------------------\n");

    for (i=0; i < NumBuckets; i++)
    {
        pHead = &pHashTable->Bucket[i];
        Next3 (pHead, &pEntry, NULL, NULL);

        //
        // Go through each name in each bucket of the hashtable
        //
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            if (!GetData(pNameAddr, &NameAddr, sizeof(tNAMEADDR)))
            {
                PRINTF ("ERROR:  Could not read NameAddr data @<%x>\n", pNameAddr);
                return FALSE;
            }

            if ((NameAddr.Verify == LOCAL_NAME) || (NameAddr.Verify == REMOTE_NAME))
            {
                PRINTF ("[%d]\t<%x> => <%-15.15s:%2x> | %8x |    %d | %8x | %9d\n",
                    i, pNameAddr, NameAddr.Name, (NameAddr.Name[15]&0x000000ff), NameAddr.IpAddress, NameAddr.RefCount, NameAddr.NameTypeState, NameAddr.Ttl);
            }
            else
            {
                PRINTF ("ERROR:  Bad Name cache entry @ <%x>!\n", pNameAddr);
                return FALSE;
            }

            Next3 (pEntry, &pEntry, NULL, NULL);    // next hash table entry
        }
    }       // for ( .. pHashTable .. )
    return TRUE;           
}


BOOL
cache(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    tNBTCONFIG  NbtConfig, *pConfig;
    BOOL        fDumpLocal = TRUE;      // Dump both local and remote cache by default
    BOOL        fDumpRemote = TRUE;

    SETCALLBACKS();

    if (lpArgumentString && (*lpArgumentString ))
    {
        //
        // lpArgumentString = "[Local|Remote]"
        //
        while (*lpArgumentString == ' ')
        {
            lpArgumentString++;
        }

        if ((*lpArgumentString == 'l') || (*lpArgumentString == 'L'))
        {
            fDumpRemote  = FALSE;
        }
        else if ((*lpArgumentString == 'r') || (*lpArgumentString == 'R'))
        {
            fDumpLocal  = FALSE;
        }
    }

    pConfig = (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    if (!GetData(pConfig, &NbtConfig, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", pConfig);
        return FALSE;
    }

    if (fDumpLocal)
    {
        DumpCache (NbtConfig.pLocalHashTbl, NBT_LOCAL);
    }
    if (fDumpRemote)
    {
        DumpCache (NbtConfig.pRemoteHashTbl, NBT_REMOTE);
    }

    PRINTF( "---------------- Cache ----------------\n");

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\types.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Types.h

Abstract:


    This file contains the typedefs and constants for Nbt.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#ifndef _TYPES_H
#define _TYPES_H

#pragma warning( disable : 4103 )

#include "nbtnt.h"
#include "ctemacro.h"
#include "debug.h"
#include "timer.h"
#include <nbtioctl.h>

#ifndef VXD
#include <netevent.h>
#endif  // VXD

//
// The code enabled by the following change is blocked by
// a bug in the ObjectManager code
//
// #define HDL_FIX         1

//----------------------------------------------------------------------------

#ifndef VXD
//
// TDI Version information
//
#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0

typedef struct _NETBT_PNP_CONTEXT_
{
    TDI_PNP_CONTEXT TDIContext;
    PVOID           ContextData;
} NETBT_PNP_CONTEXT, *PNETBT_PNP_CONTEXT;
#endif  // VXD


#ifdef MULTIPLE_WINS
//
//  Define the maximum # of bad IP addresses to tolerate during connect attempts
//
#define MAX_FAILED_IP_ADDRESSES   10
#endif  // MULTIPLE_WINS

#define MAX_RECURSE_DEPTH   10

//
// a flag to tell the transport to reindicate remaining data
// currently not supported by the transport
//
#define TDI_RECEIVE_REINDICATE  0x00000200  // remaining TSDU should cause another indication to the client

//
// In debug builds, write flink and blink with invalid pointer values so that
// if an entry is removed twice from a list, we bugcheck right there, instead
// of being faced with a corrupted list some years later!
//
#if DBG
#undef RemoveEntryList
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_OrgEntry;\
    _EX_OrgEntry = (Entry);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_OrgEntry->Flink = (LIST_ENTRY *)__LINE__;\
    _EX_OrgEntry->Blink = (LIST_ENTRY *)__LINE__;\
    }
#endif

//
// Netbios name size restrictions
//
#define NETBIOS_NAME_SIZE       16
#define MAX_NBT_DGRAM_SIZE      512

//
// To distinguish NBNS server ipaddr from DNS server ipaddr in common routines
//
#define NBNS_MODE  1
#define DNS_MODE   2

// buffer size to start for registry reads
#define REGISTRY_BUFF_SIZE  512
//
// this is the amount of memory that nbt will allocate max for datagram
// sends, before it rejects datagram sends with insufficient resources, since
// nbt buffers datagram sends to allow them to complete quickly to the
// client. - 128k - it can be set via the registry using the Key
// MaxDgramBuffering
//
#define DEFAULT_DGRAM_BUFFERING  0x20000

//
// the hash bucket structure - number of buckets - these should be set by
// a value read from the registry (small/medium/large).  If the registry
// does not contain the values then these are used as defaults.
//
#define NUMBER_BUCKETS_LOCAL_HASH_TABLE    0x10
#define NUMBER_BUCKETS_REMOTE_HASH_TABLE   0x10
#define NUMBER_LOCAL_NAMES                 10
#define NUMBER_REMOTE_NAMES                10
#define TIMER_Q_SIZE                       20

#define MEDIUM_NUMBER_BUCKETS_LOCAL_HASH_TABLE    0x80
#define MEDIUM_NUMBER_BUCKETS_REMOTE_HASH_TABLE   0x80
#define MEDIUM_NUMBER_LOCAL_NAMES                 20
#define MEDIUM_NUMBER_REMOTE_NAMES                100
#define MEDIUM_TIMER_Q_SIZE                       1000

#define LARGE_NUMBER_BUCKETS_LOCAL_HASH_TABLE    255
#define LARGE_NUMBER_BUCKETS_REMOTE_HASH_TABLE   255
#define LARGE_NUMBER_LOCAL_NAMES                 0xFFFF
#define LARGE_NUMBER_REMOTE_NAMES                255
#define LARGE_TIMER_Q_SIZE                       0xFFFF

//
// max number of buffers of various types
//
#define NBT_INITIAL_NUM         2
#define NBT_NUM_DGRAM_TRACKERS  0xFFFF
#define MIN_NBT_NUM_INITIAL_CONNECTIONS     20
#define DEFAULT_NBT_NUM_INITIAL_CONNECTIONS 50
#ifndef VXD
#define NBT_NUM_IRPS            0xFFFF
#define NBT_NUM_SESSION_MDLS    0xFFFF
#define NBT_NUM_DGRAM_MDLS      0xFFFF
#else
#define NBT_NUM_SESSION_HDR     200
#define NBT_NUM_SEND_CONTEXT    200
#define NBT_NUM_RCV_CONTEXT     200
#endif  // !VXD

#define MEDIUM_NBT_NUM_DGRAM_TRACKERS  1000
#define MEDIUM_NBT_NUM_INITIAL_CONNECTIONS   100
#ifndef VXD
#define MEDIUM_NBT_NUM_IRPS            1000
#define MEDIUM_NBT_NUM_SESSION_MDLS    1000
#define MEDIUM_NBT_NUM_DGRAM_MDLS      1000
#else
#define MEDIUM_NBT_NUM_SESSION_HDR     1000
#define MEDIUM_NBT_NUM_SEND_CONTEXT    1000
#define MEDIUM_NBT_NUM_RCV_CONTEXT     1000
#endif  // !VXD

#define LARGE_NBT_NUM_DGRAM_TRACKERS  0xFFFF
#define LARGE_NBT_NUM_INITIAL_CONNECTIONS   500
#ifndef VXD
#define LARGE_NBT_NUM_IRPS            0xFFFF
#define LARGE_NBT_NUM_SESSION_MDLS    0xFFFF
#define LARGE_NBT_NUM_DGRAM_MDLS      0xFFFF
#else
#define LARGE_NBT_NUM_SESSION_HDR     0xFFFF
#define LARGE_NBT_NUM_SEND_CONTEXT    0xFFFF
#define LARGE_NBT_NUM_RCV_CONTEXT     0xFFFF
#endif  // !VXD

// ip loop back address - does not go out on wire
//

#define LOOP_BACK           0x7F000000 // in host order
#define INADDR_LOOPBACK     0x7f000001
#define NET_MASK    0xC0       // used to get network number from ip address

//
// Nbt must indicate at least 128 bytes to its client, so it needs to be
// able to buffer 128 bytes + the session header (4)
//
#define NBT_INDICATE_BUFFER_SIZE            132


#define IS_NEG_RESPONSE(OpcodeFlags)     (OpcodeFlags & FL_RCODE)
#define IS_POS_RESPONSE(OpcodeFlags)     (!(OpcodeFlags & FL_RCODE))

//
// where to locate or register a name - locally or on the network
//
enum eNbtLocation
{
    NBT_LOCAL,
    NBT_REMOTE,
    NBT_REMOTE_ALLOC_MEM
};

//
// Type of IP address to look for
//
enum eNbtIPAddressType
{
    NBT_IP_STATIC,
    NBT_IP_DHCP,
    NBT_IP_AUTOCONFIGURATION
};

//
// Type of Request to Resolve from LmhSvc Dll
//
enum eNbtLmhRequestType
{
    NBT_PING_IP_ADDRS,
    NBT_RESOLVE_WITH_DNS
};

#define STATIC_IPADDRESS_NAME           L"IPAddress"
#define STATIC_IPADDRESS_SUBNET         L"SubnetMask"

#define DHCP_IPADDRESS_NAME             L"DhcpIPAddress"
#define DHCP_IPADDRESS_SUBNET           L"DhcpSubnetMask"

#define DHCP_IPAUTOCONFIGURATION_NAME   L"IPAutoconfigurationAddress"
#define DHCP_IPAUTOCONFIGURATION_SUBNET L"IPAutoconfigurationMask"

#define SESSION_PORT                    L"SessionPort"
#define DATAGRAM_PORT                   L"DatagramPort"

//
// these are the names that NBT binds to, in TCP when it is opening address
// objects or creating connections.
//
#define NBT_TCP_BIND_NAME               L"\\Device\\Streams\\"
#define NBT_BIND                        L"Bind"
#define NBT_EXPORT                      L"Export"
#define NBT_PARAMETERS                  L"\\Parameters"
#define PWS_NAME_SERVER_LIST            L"NameServerList"
#define PWS_DHCP_NAME_SERVER_LIST       L"DhcpNameServerList"

#ifdef _NETBIOSLESS
#define PWS_NETBIOS_OPTIONS             L"NetbiosOptions"
#define PWS_DHCP_NETBIOS_OPTIONS        L"DhcpNetbiosOptions"
#endif  // _NETBIOSLESS
#define PWS_RAS_PROXY_FLAGS             L"RASFlags"
#define PWS_ENABLE_NAGLING              L"EnableNagling"

#define WC_WINS_DEVICE_BIND_NAME        L"\\Device\\NetBt_Wins_Bind"
#define WC_WINS_DEVICE_EXPORT_NAME      L"\\Device\\NetBt_Wins_Export"
#define WC_NETBT_PROVIDER_NAME          L"\\Device\\NetBT"
#define WC_NETBT_CLIENT_NAME            L"NetBt"

#define WC_SMB_DEVICE_BIND_NAME         L"\\Device\\Netbt_Smb_Bind"
#define WC_SMB_DEVICE_EXPORT_NAME       L"\\Device\\NetbiosSmb"    // Match what's in .INF file
#define WC_SMB_DEVICE_NAME              L"Smb"
#define WC_SMB_PARAMETERS_LOCATION      L"Parameters\\Smb"



//
// Special NetBIOS name suffixes
//
#define SPECIAL_GROUP_SUFFIX        0x1C                // for netlogon and the browser
#define SPECIAL_BROWSER_SUFFIX      0x1D                // for the browser
#define SPECIAL_MESSENGER_SUFFIX    0x03                // for the Messenger Service
#define SPECIAL_SERVER_SUFFIX       0x20                // for the Server
#define SPECIAL_WORKSTATION_SUFFIX  0x00                // for the Workstation


// these are bit mask values passed to freetracker in name.c to tell it what to do
// to free a tracker
//
#define FREE_HDR        0x0001
#define REMOVE_LIST     0x0002
#define RELINK_TRACKER  0x0004


#define NAME_RESOLVED_BY_IP         0x001
#define NAME_RESOLVED_BY_CLIENT     0x002
#define NAME_RESOLVED_BY_LMH_P      0x004
#define NAME_RESOLVED_BY_DNS        0x008
#define NAME_RESOLVED_BY_WINS       0x010
#define NAME_RESOLVED_BY_BCAST      0x020
#define NAME_RESOLVED_BY_LMH        0x040
#define NAME_RESOLVED_BY_DGRAM_IN   0x080
#define NAME_RESOLVED_BY_ADAP_STAT  0x100
#define NAME_ADD_INET_GROUP         0x200
#define NAME_ADD_IF_NOT_FOUND_ONLY  0x400

#define NAME_MULTIPLE_CACHES_ONLY   1
#define NAME_STRICT_CONNECT_ONLY    2

#define REMOTE_CACHE_INCREMENT      4

//
// Hash Table basic structure
//
typedef struct
{
    LONG                lNumBuckets;
    enum eNbtLocation   LocalRemote;    // type of data stored inhash table
    LIST_ENTRY          Bucket[1];  // array uTableSize long of hash buckets
} tHASHTABLE, *PHASHTABLE;



#define NBT_BROADCAST_NAME  "\x2a\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0"

enum eREF_NAME
{
    REF_NAME_LOCAL,
    REF_NAME_REMOTE,
    REF_NAME_SCOPE,
    REF_NAME_REGISTER,
    REF_NAME_RELEASE,
    REF_NAME_RELEASE_REFRESH,
    REF_NAME_PRELOADED,
    REF_NAME_LOG_EVENT,
    REF_NAME_FIND_NAME,
    REF_NAME_CONNECT,
    REF_NAME_SEND_DGRAM,
    REF_NAME_NODE_STATUS,
    REF_NAME_QUERY_ON_NET,
    REF_NAME_QUERY_RESPONSE,
    REF_NAME_DELETE_DEVICE,
    REF_NAME_AUTODIAL,
    REF_NAME_MAX
};

//
// the tNAMEADDR structure uses a bit mask to track which names are registered
// on which adapters.  To support up to 64 adapters on NT make this a ULONGLONG,
// On the VXD the largest Long is 32 bits (they don't support _int64), so the
// adapter limit is 32 for the VXD.
//
#ifndef VXD
#define CTEULONGLONG    ULONGLONG
#else
#define CTEULONGLONG    ULONG
#endif  // !VXD


typedef struct
{
    tIPADDRESS          IpAddress;          // Unique IP address
    tIPADDRESS          *pOrigIpAddrs;      // when address was cached
} tADDRESS_ENTRY;

typedef struct
{
    tIPADDRESS          IpAddress;  // Unique IP address
    ULONG               Interface;
    ULONG               Metric;
} tQUERY_ADDRS;


// the format of each element linked to the hash buckets
//
typedef struct _tNAMEADDR
{
    // Line # 1
    LIST_ENTRY          Linkage;    // used to link onto bucket chains
    ULONG               Verify;     // for debug to tell remote from local names
    ULONG               RefCount;   // if Greater than one, can't free memory

    // Line # 2
    tADDRESS_ENTRY      *pRemoteIpAddrs;    // remote addresses per interface
    tIPADDRESS          IpAddress;          // 4 byte IP address
    tIPADDRESS          *pLmhSvcGroupList;  // (NameTypeState == NAMETYPE_GROUP loaded from LmhSvc)
    tIPADDRESS          *pIpAddrsList;      // list of ipaddrs (internet grp names,multihomed dns hosts etc.)

    // Line # 3
    CHAR                Name[NETBIOS_NAME_SIZE]; // 16 byte NetBios name

    // Line # 4
    ULONG               TimeOutCount;  // Count to know when entry has timed out
    struct _TRACKER     *pTracker;  // contains tracker ptr during name resol. phase
    ULONG               NameTypeState; // group or unique name + state
    ULONG               Ttl;           // in milliseconds..ttl of name

    // Line # 5
    CTEULONGLONG        AdapterMask;   // bit mask of adapters name registered on (MH)
    CTEULONGLONG        RefreshMask;   // bit mask of adapters name refreshed

    // Line # 6
    CTEULONGLONG        ReleaseMask;   // bit mask of adapters name to be released
    CTEULONGLONG        ConflictMask;   // bit mask of adapters currently in conflict

    // Line # 7
    union
    {                                // A scope name does not have timers started against it!
        tTIMERQENTRY    *pTimer;    // ptr to active timer entry
        ULONG           ulScopeLength;
    };
    union
    {                                // for local names the scope is implied and is stored in NbtConfig
        struct _tNAMEADDR *pScope; // ptr to scope record in hash table (Remote names only)
        struct _Address   *pAddressEle;// or ptr to address element (Local names)
        struct
        {
            USHORT      MaxDomainAddrLength; // max # of ip addrs in Iplist for domain names from lmhosts
            USHORT      CurrentLength;       // current # of above
        };
    };
    USHORT              RemoteCacheLen;
    USHORT              NameAddFlags;
    BYTE                ProxyReqType;
    BOOLEAN             fPnode;         //indicates whether the node type is a Pnode
    BOOLEAN             fPreload;       // Needed temporarily when reading Domain name from LmHosts file

    UNICODE_STRING      FQDN;

    // Line # 8
    ULONG               NameFlags;

// #if DBG
    UCHAR               References[REF_NAME_MAX];
// #endif  // DBG
} tNAMEADDR;

#define NAME_REGISTERED_ON_SMBDEV   0x01

//
// these values can be checked with a bit check since they are mutually
// exclusive bits... uses the first nibble of the field
//
#define NAMETYPE_QUICK       0x0001 // set if name is Quick Unique or Quick Group
#define NAMETYPE_UNIQUE      0x0002
#define NAMETYPE_GROUP       0x0004
#define NAMETYPE_INET_GROUP  0x0008
#define NAMETYPE_SCOPE       0x1000
//
// values for NameTypeState.. the state of the name occupies the second nibble
// of the field
//
#define STATE_RESOLVED  0x0010  // name query completed
#define STATE_RELEASED  0x0020  // no longer active
#define STATE_CONFLICT  0x0040  // proxy name addition to the name table
#define STATE_RESOLVING 0x0080  // name is waiting for Query or Reg. to complete
#define NAME_TYPE_MASK  0x000F
#define NAME_STATE_MASK 0x00F0

#define REFRESH_FAILED  0x0100  // set if the name refresh response was received
#define PRELOADED       0x0800  // set if the entry is a preloaded entry - no timeout
#define REFRESH_MASK    0x0F00

#define LOCAL_NAME      0xDEAD0000
#define REMOTE_NAME     0xFACF0000

// the number of timeouts per refresh time.  The timer expires 8 times and
// refreshes every four (i.e. at twice the required refresh interval)
#define REFRESH_DIVISOR 0x0008

//
// two flags used in the NbtTdiOpenAddress procedure to decide which
// event handlers to setup
//
#define TCP_FLAG        0x00000001
#define SESSION_FLAG    0x00000002

//
// these defines allow the code to run as either a Bnode or a Pnode
// or a proxy
//
extern USHORT   RegistryNodeType;   // defined in Name.c
extern USHORT   NodeType;   // defined in Name.c
#define BNODE       0x0001
#define PNODE       0x0002
#define MNODE       0x0004
#define MSNODE      0x0008
#define NODE_MASK   0x000F
#define PROXY       0x0010
#define PROXY_REG   0x0020U  // Registration request
typedef enum {
    NO_PROXY,
    PROXY_WINS,
    PROXY_RAS
} tPROXY_TYPE;
#define PROXY_RAS_NONAMEQUERYFORWARDING     (0x1UL)

#define NAMEREQ_REGULAR             0
#define NAMEREQ_PROXY_QUERY         1       // Do negative name cache
#define NAMEREQ_PROXY_REGISTRATION  2       // Don't do negative name cache

#define DEFAULT_NODE_TYPE 0x1000


//
// Wide String defintions of values to read from the registry
//

//  NT wants Unicode, Vxd wants ANSI
#ifdef VXD
    #define __ANSI_IF_VXD(str)     str
#else
    #define __ANSI_IF_VXD(str)     L##str
#endif  // VXD
#define ANSI_IF_VXD( str ) __ANSI_IF_VXD( str )

#define WS_NUM_BCASTS                   ANSI_IF_VXD("BcastNameQueryCount")
#define WS_BCAST_TIMEOUT                ANSI_IF_VXD("BcastQueryTimeout")
#define WS_CACHE_TIMEOUT                ANSI_IF_VXD("CacheTimeout")
#define WS_NODE_TYPE                    ANSI_IF_VXD("NodeType")
#define WS_NS_PORT_NUM                  ANSI_IF_VXD("NameServerPort")
#define WS_NAMESRV_RETRIES              ANSI_IF_VXD("NameSrvQueryCount")
#define WS_NAMESRV_TIMEOUT              ANSI_IF_VXD("NameSrvQueryTimeout")
#define WS_NODE_SIZE                    ANSI_IF_VXD("Size/Small/Medium/Large")
#define WS_KEEP_ALIVE                   ANSI_IF_VXD("SessionKeepAlive")
#define WS_ALLONES_BCAST                ANSI_IF_VXD("BroadcastAddress")
#define NBT_SCOPEID                     ANSI_IF_VXD("ScopeId")
#define WS_RANDOM_ADAPTER               ANSI_IF_VXD("RandomAdapter")
#define WS_SINGLE_RESPONSE              ANSI_IF_VXD("SingleResponse")
#define WS_INITIAL_REFRESH              ANSI_IF_VXD("InitialRefreshT.O.")
#define WS_ENABLE_DNS                   ANSI_IF_VXD("EnableDns")
#define WS_TRY_ALL_ADDRS                ANSI_IF_VXD("TryAllIpAddrs")
#define WS_ENABLE_LMHOSTS               ANSI_IF_VXD("EnableLmhosts")
#define WS_LMHOSTS_TIMEOUT              ANSI_IF_VXD("LmhostsTimeout")
#define WS_SMB_DISABLE_NETBIOS_NAME_CACHE_LOOKUP    ANSI_IF_VXD("SmbDisableNetbiosNameCacheLookup")
#define WS_MAX_DGRAM_BUFFER             ANSI_IF_VXD("MaxDgramBuffering")
#define WS_ENABLE_PROXY_REG_CHECK       ANSI_IF_VXD("EnableProxyRegCheck")
#define WS_WINS_DOWN_TIMEOUT            ANSI_IF_VXD("WinsDownTimeout")
#define WS_MAX_CONNECTION_BACKLOG       ANSI_IF_VXD("MaxConnBacklog")
#define WS_CONNECTION_BACKLOG_INCREMENT ANSI_IF_VXD("BacklogIncrement")
#define WS_REFRESH_OPCODE               ANSI_IF_VXD("RefreshOpCode")
#define WS_TRANSPORT_BIND_NAME          ANSI_IF_VXD("TransportBindName")
#define WS_MAX_PRELOADS                 ANSI_IF_VXD("MaxPreloadEntries")
#define WS_USE_DNS_ONLY                 ANSI_IF_VXD("UseDnsOnlyForNameResolutions")
#define WS_NO_NAME_RELEASE              ANSI_IF_VXD("NoNameReleaseOnDemand")
#ifdef MULTIPLE_WINS
#define WS_TRY_ALL_NAME_SERVERS         ANSI_IF_VXD("TryAllNameServers")
#endif  // MULTIPLE_WINS
#define WS_MINIMUM_REFRESH_SLEEP_TIME   ANSI_IF_VXD("MinimumRefreshSleepTime")
#define WS_CACHE_PER_ADAPTER_ENABLED    ANSI_IF_VXD("CachePerAdapterEnabled")
#define WS_CONNECT_ON_REQUESTED_IF_ONLY ANSI_IF_VXD("ConnectOnRequestedInterfaceOnly")
#define WS_SEND_DGRAM_ON_REQUESTED_IF_ONLY ANSI_IF_VXD("SendDgramOnRequestedInterfaceOnly")
#define WS_MULTIPLE_CACHE_FLAGS         ANSI_IF_VXD("MultipleCacheFlags")
#define WS_SMB_DEVICE_ENABLED           ANSI_IF_VXD("SMBDeviceEnabled")
#define WS_MIN_FREE_INCOMING_CONNECTIONS ANSI_IF_VXD("MinFreeLowerConnections")
#define WS_BREAK_ON_ASSERT              ANSI_IF_VXD("BreakOnAssert")

#ifdef VXD
#define VXD_MIN_NAMETABLE_SIZE            1
#define VXD_DEF_NAMETABLE_SIZE           17
#define VXD_MIN_SESSIONTABLE_SIZE         1
#define VXD_DEF_SESSIONTABLE_SIZE       255

#define VXD_LANABASE_NAME               ANSI_IF_VXD("LANABASE")
#define WS_DNS_PORT_NUM                 ANSI_IF_VXD("DnsServerPort")
#define WS_LMHOSTS_FILE                 ANSI_IF_VXD("LmHostFile")
#define WS_DO_DNS_DEVOLUTIONS           ANSI_IF_VXD("VNbtDoDNSDevolutions")
#define VXD_NAMETABLE_SIZE_NAME         ANSI_IF_VXD("NameTableSize")
#define VXD_SESSIONTABLE_SIZE_NAME      ANSI_IF_VXD("SessionTableSize")

#ifdef CHICAGO
#define VXD_ANY_LANA                    0xff
#define VXD_DEF_LANABASE                VXD_ANY_LANA
#else
#define VXD_DEF_LANABASE                0
#endif  // CHICAGO

#endif  // VXD

#ifdef PROXY_NODE
#define IS_NOT_PROXY                    0
#define WS_IS_IT_A_PROXY                ANSI_IF_VXD("EnableProxy")
#define NODE_TYPE_MASK                  0x60    // Mask for NodeType in NBFLAGS byte of Query response
#define PNODE_VAL_IN_PKT                0x20    // A bit pattern of 01 in the NodeType fld
                                                // of the Query response pkt indicates a P node
#endif  // PROXY_NODE
#define NBT_PROXY_DBG(x)  KdPrint(x)

// Various Default values if the above values cannot be read from the
// registry
//
#define TWO_MINUTES                     2 * 60 * 1000
#define ONE_HOUR                        1 * 60 * 60 * 1000  // millisecs
#define DEFAULT_CACHE_TIMEOUT           360000    // 6 minutes in milliseconds
#define MIN_CACHE_TIMEOUT               60000     // 1 minutes in milliseconds
#define DEFAULT_MINIMUM_REFRESH_SLEEP_TIME  6 * 3600 * 1000  // 6 hours
#define REMOTE_HASH_TIMEOUT     2500     // 2.5 second timer
#define ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT 30000   // 30 seconds

#define     MAX_INBOUND_STATE_TIMEOUT   30000   // 30   seconds
#define     MED_INBOUND_STATE_TIMEOUT   15000   // 15   seconds
#define     MIN_INBOUND_STATE_TIMEOUT    7500   //  7.5 seconds

//
// timeouts - the defaults if the registry cannot be read.
//  (time is milliseconds)
// The retry counts are the actual number of transmissions, not the number
// of retries i.e. 3 means the first transmission and 2 retries. Except
// for Bnode name registration where 3 registrations and 1 over write request
// are sent.(effectively 4 are sent).
//
#define DEFAULT_NUMBER_RETRIES      3
#define DEFAULT_RETRY_TIMEOUT       1500
#define MIN_RETRY_TIMEOUT           100

//#define MIN_RETRY_TIMEOUT           100

// the broadcasts values below related to broadcast name service activity
#define DEFAULT_NUMBER_BROADCASTS   3
#define DEFAULT_BCAST_TIMEOUT       750
#define MIN_BCAST_TIMEOUT           100

#define DEFAULT_NODE_SIZE           1       // BNODE
#define SMALL                       1
#define MEDIUM                      2
#define LARGE                       3

#define DEFAULT_KEEP_ALIVE          0xFFFFFFFF // disabled by default
#define MIN_KEEP_ALIVE              60*1000    // 60 seconds in milliseconds
//
// The default is to use the subnet broadcast address for broadcasts rather
// than use 0xffffffff(i.e. when BroadcastAddress is not defined in the
// registery. If the registery variable BroadcastAddress is set to
// something that cannot be read for some reason, then the broadcast address
// gets set to this value.
//
#define DEFAULT_BCAST_ADDR          0xFFFFFFFF

// a TTL value to use as a default (for refreshing names with WINS)
//
#define DEFAULT_TTL                         5*60*1000

//
// Default TTL used for checking whether we need to switch back to the primary. currently 1 hour.
//
#define DEFAULT_SWITCH_TTL                  ONE_HOUR

//
// we refresh every 16 minutes / 8 - so no more than once every two
// minutes until we reach WINS and get a new value
//
#define NBT_INITIAL_REFRESH_TTL             16*60*1000 // milliseconds
#define MAX_REFRESH_CHECK_INTERVAL          600000  // 10 minutes in msec

// don't allow the refresh mechanism to run any faster than once per 5 minutes
#define NBT_MINIMUM_TTL                     5*60*1000  // Milliseconds
#define NBT_MAXIMUM_TTL                     0xFFFFFFFF // larges ULONG (approx 50 days)

//
// the Mininimum and default timeouts to stop talking to WINS in the event
// that we fail to reach it once.(i.e. temporarily stop using it)
//
#define DEFAULT_WINS_DOWN_TIMEOUT   15000 // 15 seconds
#define MIN_WINS_DOWN_TIMEOUT       1000  // 1 second

//
// Default max connections that can be in backlog
//
#define DEFAULT_CONN_BACKLOG   1000
#define MIN_CONN_BACKLOG   2
#define MAX_CONNECTION_BACKLOG  40000   // we allow only upto 40000 outstanding connections (~4MB)

//
// Default max lower connection increment
//
#define DEFAULT_CONN_BACKLOG_INCREMENT   3
#define MIN_CONN_BACKLOG_INCREMENT   3
#define MAX_CONNECTION_BACKLOG_INCREMENT  20   // we allow only upto 20 new ones at a time

// the minimum time to wait for a session setup pdu to complete - used to
// start a timer in name.c
#define NBT_SESSION_RETRY_TIMEOUT   10000     // 10 sec in milliseconds
//
// the number of times to attempt a session setup if the return code is
// Called Name Present but insufficient resources (0x83) - or if the
// destination does not have the name at all - in this case the session
// is just setup one more time, not 3 more times
//
#define NBT_SESSION_SETUP_COUNT       3
//
// the following two lines allow proxy code to be compiled OUT if PROXY is not
// defined
//
#define IF_PROXY(Node)    if ((Node) & PROXY)
#define END_PROXY

#define IF_DEF_PROXY \
#ifdef PROXY_NODE
#define END_DEF_PROXY \
#endif  // PROXY_NODE

// Status code specific to NBT that is used in the RcvHndlrNotOs to indicate
// that not enough data has been received, and more must be obtained.
//
#define STATUS_NEED_MORE_DATA   0xC0000999L

#ifndef VXD

//
// Logging definitions
//

#define LOGSIZE  10000
#define LOGWIDTH 32

typedef char STRM_RESOURCE_LOG[LOGSIZE+1][LOGWIDTH];

typedef struct {
    STRM_RESOURCE_LOG  Log;
    CHAR               Unused[3*LOGWIDTH];   // for overruns
    int                Index;
} STRM_PROCESSOR_LOG, *PSTRM_PROCESSOR_LOG;

/*
 *  Definitions for the error logging facility
 */

/*
 *  Maximum amount of data (binary dump data plus insertion strings) that
 *  can be added to an error log entry.
 */
#define MAX_ERROR_LOG_DATA_SIZE     \
    ( (ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) + 4) & 0xFFFFFFFC )

#endif  // !VXD

#define NBT_ADDRESS_TYPE        01
#define NBT_CONNECTION_TYPE     02
#define NBT_CONTROL_TYPE        03
#define NBT_WINS_TYPE           04


//
// Maximum ip addresses that can be in an internet group - used as a sanity
// check to prevent allocating hugh amounts of memory
//
#define NBT_MAX_INTERNET_GROUP_ADDRS    1000

// define buffer types so we will know when we have allocated the maximum
// allowed number of buffers - this enum serves as an array index into the
// config data
//
enum eBUFFER_TYPES
{
    eNBT_DGRAM_TRACKER,
    eNBT_TIMER_ENTRY,
#ifndef VXD
    eNBT_FREE_IRPS,
    eNBT_FREE_SESSION_MDLS,
    eNBT_DGRAM_MDLS,
#else
    eNBT_SESSION_HDR,
    eNBT_SEND_CONTEXT,
    eNBT_RCV_CONTEXT,
#endif  // !VXD
    eNBT_NUMBER_BUFFER_TYPES    // this type must be last on the list
};

//
// enumerate the types of name service broadcasts... either name registration
// or name query
//
enum eNSTYPE
{
    eNAME_QUERY,
    eDNS_NAME_QUERY,
    eDIRECT_DNS_NAME_QUERY,
    eNAME_QUERY_RESPONSE,
    eNAME_REGISTRATION,
    eNAME_REGISTRATION_OVERWRITE,
    eNAME_REGISTRATION_RESPONSE,
    eNAME_RELEASE,
    eNAME_REFRESH
};


#define DIRECT_DNS_NAME_QUERY_BASE 0x8000


#define NBT_G_REFRESHING_NOW        0x1
#define NBT_G_REFRESH_SLEEPING      0x2

#define NBT_D_REFRESHING_NOW        0x1
#define NBT_D_REFRESH_WAKING_UP     0x2


//
// Defines for the Verify elements of the handles passed to clients so that
// we can determine if we recieved the correct handle back from the client
// i.e. the Verify element must equal the correct define given here
//
#define NBT_VERIFY_ADDRESS           0x72646441 // Addr
#define NBT_VERIFY_LOWERCONN         0x43776f4c // LowC
#define NBT_VERIFY_CONNECTION        0x316e6f43 // Con1
#define NBT_VERIFY_CONNECTION_DOWN   0x326e6f43 // Con2
#define NBT_VERIFY_CLIENT            0x316e6c43 // Cln1
#define NBT_VERIFY_CLIENT_DOWN       0x326e6c43 // Cln2
#define NBT_VERIFY_DEVCONTEXT        0x43766544 // DevC
#define NBT_VERIFY_DEVCONTEXT_DOWN   0x32766544 // Dev2
#define NBT_VERIFY_CONTROL           0x6c727443 // Ctrl
#define NBT_VERIFY_TRACKER           0x6b617254 // Trak
#define NBT_VERIFY_TRACKER_DOWN      0x32617254 // Tra2
#define NBT_VERIFY_BLOCKING_NCB      0x0042434e // NCB
#define NBT_VERIFY_TIMER_ACTIVE      0x316d6954 // Tim1
#define NBT_VERIFY_TIMER_DOWN        0x326d6954 // Tim2
#define NBT_VERIFY_WINS_ACTIVE       0x736e6957 // Wins
#define NBT_VERIFY_WINS_DOWN         0x326e6957 // Win2

//
// Session Header types from the RFC's
//
#define NBT_SESSION_MESSAGE           0x00
#define NBT_SESSION_REQUEST           0x81
#define NBT_POSITIVE_SESSION_RESPONSE 0x82
#define NBT_NEGATIVE_SESSION_RESPONSE 0x83
#define NBT_RETARGET_SESSION_RESPONSE 0x84
#define NBT_SESSION_KEEP_ALIVE        0x85
#define NBT_SESSION_FLAGS             0x00  // flag byte of Session hdr = 0 always
#define SESSION_NOT_LISTENING_ON_CALLED_NAME    0x80
#define SESSION_NOT_LISTENING_FOR_CALLING_NAME  0x81
#define SESSION_CALLED_NAME_NOT_PRESENT         0x82
#define SESSION_CALLED_NAME_PRESENT_NO_RESRC    0x83
#define SESSION_UNSPECIFIED_ERROR               0x8F

//
// Address Info structure used to return buffer in TDI_QUERY_ADDRESS_INFO
//
#include <packon.h>
typedef struct
{
    ULONG               ActivityCount;
    TA_NETBIOS_ADDRESS  NetbiosAddress;

} tADDRESS_INFO;
#include <packoff.h>
//
// Name Registration error codes per the RFC
//
#define REGISTRATION_NO_ERROR       0x0
#define REGISTRATION_FORMAT_ERR     0x1
#define REGISTRATION_SERVER_ERR     0x2
#define REGISTRATION_UNSUPP_ERR     0x4
#define REGISTRATION_REFUSED_ERR    0x5
#define REGISTRATION_ACTIVE_ERR     0x6
#define REGISTRATION_CONFLICT_ERR   0x7

#define NBT_NAMESERVER_UDP_PORT     137 // port used by the Name Server
#define NBT_DNSSERVER_UDP_PORT       53 // port used by the DNS server
#define NBT_NAMESERVICE_UDP_PORT    137
#define NBT_DATAGRAM_UDP_PORT       138
#define NBT_SESSION_TCP_PORT        139
#ifdef _NETBIOSLESS
#define NBT_SMB_SESSION_TCP_PORT    445 // port used by rdr and srv
#define NBT_SMB_DATAGRAM_UDP_PORT   445 // port used by browser
#endif  // _NETBIOSLESS

#define IP_ANY_ADDRESS                0 // means broadcast IP address to IP
#define WINS_SIGNATURE             0xFF // put into QdCount to tell signal name reg from this node

#define MAX_IP_ADDRS                 10 // Temporary for now!
#ifdef MULTIPLE_WINS
#define MAX_NUM_OTHER_NAME_SERVERS   10 // # of Backup Name Server entries to keep in cache
#endif  // MULTIPLE_WINS

//
// whether an address is unique or a group address... these agree with the
// values in TDI.H for TDI_ADDRESS_NETBIOS_TYPE_UNIQUE etc.. but are easier to
// type!
//
enum eNbtAddrType
{
    NBT_UNIQUE,
    NBT_GROUP,
    NBT_QUICK_UNIQUE,   // these two imply that the name is registered on the
    NBT_QUICK_GROUP     // net when it is claimed
};


//
// this type defines the session hdr used to put session information
// into each client pdu sent
//
#include <packon.h>
typedef union
{
    union
    {
        struct
        {
            UCHAR   Type;
            UCHAR   Flags;
            USHORT  Length;
        };
        ULONG   UlongLength;
    };
#ifndef _WIN64

    //
    // (fcf) This isn't used anywhere as far as I can tell, but I want to wait
    // until post-beta2 to be safe.
    //

    PSINGLE_LIST_ENTRY  Next;
#endif  // _WIN64
} tSESSIONHDR;

// Session response PDU
typedef struct
{
    UCHAR   Type;
    UCHAR   Flags;
    USHORT  Length;
    UCHAR   ErrorCode;

} tSESSIONERROR;

// Session Retarget response PDU
typedef struct
{
    UCHAR   Type;
    UCHAR   Flags;
    USHORT  Length;
    ULONG   IpAddress;
    USHORT  Port;

} tSESSIONRETARGET;

// the structure for the netbios name itself, which includes a length
// byte at the start of it
typedef struct
{
    UCHAR   NameLength;
    CHAR    NetBiosName[1];

} tNETBIOS_NAME;

// session request packet...this is the first part of it. It still needs the
// calling netbios name to be appended on the end, but we can't do that
// until we know how long the Called Name is.
typedef struct
{
    tSESSIONHDR     Hdr;
    tNETBIOS_NAME   CalledName;

} tSESSIONREQ;

// the type definition to queue empty session header buffers in a LIST
typedef union
{
    tSESSIONHDR Hdr;
    LIST_ENTRY  Linkage;
} tSESSIONFREE;

// this type definition describes the NetBios Datagram header format on the
// wire
typedef union
{
    struct
    {
        UCHAR           MsgType;
        UCHAR           Flags;
        USHORT          DgramId;
        ULONG           SrcIpAddr;
        USHORT          SrcPort;
        USHORT          DgramLength;
        USHORT          PckOffset;
        tNETBIOS_NAME   SrcName;
    };
    LIST_ENTRY  Linkage;

} tDGRAMHDR;

typedef struct
{
    UCHAR           MsgType;
    UCHAR           Flags;
    USHORT          DgramId;
    ULONG           SrcIpAddr;
    USHORT          SrcPort;
    UCHAR           ErrorCode;

} tDGRAMERROR;

// define the header size since just taking the sizeof(tDGRAMHDR) will be 1 byte
// too large and if for any reason this data structure changes later, things
// fail to work for unknown reasons....  This size includes the Hdr + the
// two half ascii src and dest names + the length byte in each name + the
//  It does
// not include the scope.  That must be added separately(times 2).
#define DGRAM_HDR_SIZE  80
#define MAX_SCOPE_LENGTH    255
#define MAX_LABEL_LENGTH    63

// Name Service header
typedef struct
{
    USHORT          TransactId;
    USHORT          OpCodeFlags;
    UCHAR           Zero1;
    UCHAR           QdCount;
    UCHAR           Zero2;
    UCHAR           AnCount;
    UCHAR           Zero3;
    UCHAR           NsCount;
    UCHAR           Zero4;
    UCHAR           ArCount;
    tNETBIOS_NAME   NameRR;

} tNAMEHDR;

//
// the offset from the end of the question name to the field
// in a name registration pdu ( includes 1 for the length byte of the name
// since ConvertToAscii does not count that value
//
#define QUERY_NBFLAGS_OFFSET  10
#define NBFLAGS_OFFSET        16
#define IPADDRESS_OFFSET      18
#define PTR_OFFSET            4     // offset to PTR in Name registration pdu
#define NO_PTR_OFFSET         10    // offset to NbFlags after name
#define PTR_SIGNATURE         0xC0  // ptrs to names in pdus start with C

//
// Minimum Pdu lengths that will be accepted from the wire
//
#define DNS_MINIMUM_QUERYRESPONSE   34

#define NBT_MINIMUM_QUERY           50
#define NBT_MINIMUM_QUERYRESPONSE   56
#define NBT_MINIMUM_WACK            58
#define NBT_MINIMUM_REGRESPONSE     62
#define NBT_MINIMUM_REGREQUEST      68

#define NBT_NODE_NAME_SIZE          18
#define NBT_MINIMUM_RR_LENGTH       22

// the structure of a DNS label is the count of the number of bytes followed
// by the label itself.  Each part of a dot delimited name is a label.
// Fred.ms.com is 3 labels.- Actually 4 labels where the last one is zero
// length - hence all names end in a NULL
typedef struct
{
    UCHAR       uSizeLabel; // top two bits are set to 1 when next 14 bits point to actual label in msg.
    CHAR        pLabel[1];  // variable length of label -> 63 bytes

}   tDNS_LABEL;
// top two bits set to signify a ptr to a name follows in the next 14 bits
#define PTR_TO_NAME     0xC0

// question section for the resource record modifiers
typedef struct
{
    ULONG      QuestionTypeClass;
} tQUESTIONMODS;

#define QUEST_NBINTERNET  0x00200001  // combined type/class
#define QUEST_DNSINTERNET 0x00010001  // combined type/class for dns query
#define QUEST_NETBIOS     0x0020      // General name service Resource Record
#define QUEST_STATUS      0x0021      // Node Status resource Record
#define QUEST_CLASS       0x0001      // internet class

// Resource Record format - in the Name service packets
// General format RrType = 0x20
typedef struct
{
    tQUESTIONMODS   Question;
    tDNS_LABEL      RrName;
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    USHORT          Flags;
    ULONG           IpAddress;

}   tGENERALRR;
// Resource Record format - in the Name service packets
// General format RrType = 0x20
typedef struct
{
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    USHORT          Flags;
    ULONG           IpAddress;

}   tQUERYRESP;

// same as tQUERYRESP, except no Flags field
// DNS servers return only 4 bytes of data (ipaddress): no flags.
typedef struct
{
    USHORT          RrType;
    USHORT          RrClass;
    ULONG           Ttl;
    USHORT          Length;
    ULONG           IpAddress;

}   tDNS_QUERYRESP;

#define  DNS_CNAME   5

//
// the format of the tail of the node status response message
//
typedef struct
{
    UCHAR       Name[NETBIOS_NAME_SIZE];
    UCHAR       Flags;
    UCHAR       Resrved;

} tNODENAME;

typedef struct
// the statistics portion of the node status message
{
    UCHAR       UnitId[6];
    UCHAR       Jumpers;
    UCHAR       TestResult;
    USHORT      VersionNumber;
    USHORT      StatisticsPeriod;
    USHORT      NumberCrcs;
    USHORT      NumberAlignmentErrors;
    USHORT      NumberCollisions;
    USHORT      NumberSendAborts;
    ULONG       NumberSends;
    ULONG       NumberReceives;
    USHORT      NumberTransmits;
    USHORT      NumberNoResrcConditions;
    USHORT      NumberFreeCommandBlks;
    USHORT      TotalCommandBlocks;
    USHORT      MaxTotalCommandBlocks;
    USHORT      NumberPendingSessions;
    USHORT      MaxNumberPendingSessions;
    USHORT      MaxTotalSessionsPossible;
    USHORT      SessionDataPacketSize;

} tSTATISTICS;

typedef struct
{
    ULONG           RrTypeClass;
    ULONG           Ttl;
    USHORT          Length;
    UCHAR           NumNames;
    tNODENAME        NodeName[1];     // there are NumNames of these

}   tNODESTATUS;

typedef struct
{
    USHORT  NbFlags;
    ULONG   IpAddr;
} tADDSTRUCT;
#define tADDSTRUCT_SIZE 6


// Flags Definitions
#define FL_GROUP    0x8000
#define FL_BNODE    0x0000      // note that this has no bits set!!
#define FL_PNODE    0x2000
#define FL_MNODE    0x4000

//Redirect type Address record - RrType = 0x01
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Ttl;
    USHORT  DataLength;
    ULONG   IpAddress;

}   tIPADDRRR;

//Redirect type - Name Server Resource Record RrType = 0x02
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Ttl;
    USHORT  DataLength;
    CHAR    Name[1];        // name starts here for N bytes - till null

}   tREDIRECTRR;

//Null type- WACK-  RrType = 0x000A
typedef struct
{
    USHORT  RrType;
    USHORT  RrClass;
    ULONG   Zeroes;
    USHORT  Null;

}   tWACKRR;

// definitions of the bits in the OpCode portion of the OpCodeFlag word
// These definitions work on a 16 bit word rather than the 5 bit opcode and 7
// bit flag
#define NM_FLAGS_MASK     0x0078
#define OP_RESPONSE       0x0080
#define OP_QUERY          0x0000
#define OP_REGISTRATION   0x0028
#define OP_REGISTER_MULTI 0x0078    // new multihomed registration(Byte) op code
#define OP_RELEASE        0x0030
#define OP_WACK           0x0038
#define OP_REFRESH        0x0040
#define OP_REFRESH_UB     0x0048    // UB uses 9 instead of 8 (Ref. RFC 1002)
#define REFRESH_OPCODE    0x8
#define UB_REFRESH_OPCODE 0x9
#define FL_RCODE          0x0F00
#define FL_NAME_ACTIVE    0x0600    // WINS is reporting another name active
#define FL_NAME_CONFLICT  0x0700    // another node is reporting name active
#define FL_AUTHORITY      0x0004
#define FL_TRUNCFLAG      0x0002
#define FL_RECURDESIRE    0x0001
#define FL_RECURAVAIL     0x8000
#define FL_BROADCAST      0x1000
#define FL_BROADCAST_BYTE 0x10
// used to determine if the source is a Bnode for Datagram distribution
#define SOURCE_NODE_MASK 0xFC

// defines for the node status message
#define GROUP_STATUS        0x80
#define UNIQUE_STATUS       0x00
#define NODE_NAME_PERM      0x02
#define NODE_NAME_ACTIVE    0x04
#define NODE_NAME_CONFLICT  0x08
#define NODE_NAME_RELEASED  0x10
#define STATUS_BNODE        0x00
#define STATUS_PNODE        0x20
#define STATUS_MNODE        0x40


// Resource record defines - rrtype and rr class
#define RR_NETBIOS      0x0020
#define RR_INTERNET     0x0001

// Name Query Response Codes
#define QUERY_NOERROR   00
#define FORMAT_ERROR    01
#define SERVER_FAILURE  02
#define NAME_ERROR      03
#define UNSUPP_REQ      04
#define REFUSED_ERROR   05
#define ACTIVE_ERROR    06  // name is already active on another node
#define CONFLICT_ERROR  07  // unique name is owned by more than one node


typedef struct
{
    tDGRAMHDR   DgramHdr;
    CHAR    SrcName[NETBIOS_NAME_SIZE];
    CHAR    DestName[NETBIOS_NAME_SIZE];

} tDGRAM_NORMAL;

typedef struct
{
    tDGRAMHDR   DgramHdr;
    UCHAR       ErrorCode;

} tDGRAM_ERROR;

typedef struct
{
    tDGRAMHDR   DgramHdr;
    CHAR        DestName[NETBIOS_NAME_SIZE];

} tDGRAM_QUERY;

#include <packoff.h>


// the buffer type passed to the TDI routines so that the datagram or session
// header can be included too.
typedef struct
{
    ULONG               HdrLength;
    PVOID               pDgramHdr;
    ULONG               Length;
    PVOID               pBuffer;
} tBUFFER;

//
// This typedef is used by DgramHandlrNotOs to keep track of which client
// is receiving a datagram and which client's need to also get the
// datagram
typedef struct
{
    struct _Address       *pAddress;
    ULONG                 ReceiveDatagramFlags;
    PVOID                 pRemoteAddress;
    ULONG                 RemoteAddressLength;
    struct _Client        *pClientEle;
    BOOLEAN               fUsingClientBuffer;
    BOOLEAN               fProxy; //used by PROXY code for getting the
                                  //entire datagram. See
                                  //CompletionRcvDgram in tdihndlrs.c

} tCLIENTLIST;


typedef struct
{
    ULONG           RefCount;
    HANDLE          hNameServer;        // from ZwCreateFile
    PDEVICE_OBJECT  pNameServerDeviceObject;    // from pObject->DeviceObject
    CTE_ADDR_HANDLE pNameServerFileObject;  // from ObReferenceObjectByHandle(hNameServer)

    HANDLE          hDgram;
    PDEVICE_OBJECT  pDgramDeviceObject;
    CTE_ADDR_HANDLE pDgramFileObject;
}tFILE_OBJECTS;


// Enumerate the different types of trackers (depending on where it
// is allocated)
enum eTRACKER_TYPE
{
    NBT_TRACKER_PROXY_DGRAM_DIST,
    NBT_TRACKER_NODE_STATUS_RESPONSE,
    NBT_TRACKER_CONNECT,
    NBT_TRACKER_DISCONNECT_LOWER,
    NBT_TRACKER_BUILD_SEND_DGRAM,
    NBT_TRACKER_SEND_NODE_STATUS,
    NBT_TRACKER_QUERY_FIND_NAME,
    NBT_TRACKER_QUERY_NET,
    NBT_TRACKER_CONTINUE_QUERY_NET,
    NBT_TRACKER_REGISTER_NAME,
    NBT_TRACKER_RELEASE_NAME,
    NBT_TRACKER_REFRESH_NAME,
    NBT_TRACKER_KEEP_ALIVE,
    NBT_TRACKER_SEND_NSBCAST,
    NBT_TRACKER_SEND_RESPONSE_DGRAM,
    NBT_TRACKER_SEND_RESPONSE_SESSION,
    NBT_TRACKER_SEND_DISCONNECT,
    NBT_TRACKER_RELEASE_REFRESH,
    NBT_TRACKER_ADAPTER_STATUS,
    NBT_TRACKER_SEND_WINS_DGRAM,
    NBT_TRACKER_NUM_TRACKER_TYPES
};

// #if DBG
extern ULONG   TrackTrackers[];
extern ULONG   TrackerHighWaterMark[];
// #endif   // DBG


// Active Datagram Send List - a set of linked blocks that represent transactions
// passed to the Transport TDI for execution... these blocks could be waiting
// for name resolution or for the send to complete

typedef struct _TRACKER
{
    // Line 1
    LIST_ENTRY              Linkage;
    ULONG                   Verify;
    // The type of address dictates the course of action, e.g., TDI_ADDRESS_NETBIOS_EX
    // address avoids NETBIOS name registration. This encodes the desired address type
    // associated with the connection or specified for the connection.
    ULONG                   RefCount;

    // Line 2
    PCTE_IRP                pClientIrp;     // client's IRP
    struct _DeviceContext   *pDeviceContext;
    PCHAR                   pDestName;      // ptr to destination ASCII name
    tNAMEADDR               *pNameAddr;     // ptr to name addres rec in hash tbl

    // Line 3
    tBUFFER                 SendBuffer;     // send buffer and header to send

    // Line 4
    struct _TRACKER         *pTrackerWorker;
    union
    {
        struct _Client      *pClientEle;    // client element block
        struct _Connect     *pConnEle;      // connection element block
        tNAMEADDR           *p1CNameAddr;   // DomainNames 1C pNameAddr - used sending datagrams
    };
    PVOID                   pNodeStatus;    // node status response buffer
    PTDI_CONNECTION_INFORMATION pSendInfo;

    // Line 5
    union
    {
        PVOID               pTimeout;       // used for the TCP connect timeout -from union below
        USHORT              TransactionId;  // name queries and registrations: response has same transactionid
        ULONG               RCount;         // refcount used for datagram dist.
    };
    union
    {
        ULONG               AllocatedLength;// used in Sending Dgrams to count mem allocated
        ULONG               RefConn;        // used for NbtConnect
    };
    ULONG                   DestPort;       // used by ReTarget to specify the dest port
    USHORT                  IpListIndex;    // index into IpList for Group sends
    USHORT                  SavedListIndex; //last index sent when timer was started


    // Line 6
    //
    // when two name queries go to the same name, this is the
    // completion routine to call for this tracker queued to the first
    // tracker.
    //
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        CompletionRoutine;
    COMPLETIONCLIENT        ClientCompletion;
    PVOID                   ClientContext;

    // Line 7
#ifdef MULTIPLE_WINS
    ULONG                   ResolutionContextFlags;
    tIPADDRESS              *pFailedIpAddresses;    // List of failed IP addresses
    ULONG                   LastFailedIpIndex;
    USHORT                  NSOthersIndex;
    USHORT                  NSOthersLeft;
#endif  // MULTIPLE_WINS

    // Line 8
    tIPADDRESS              RemoteIpAddress;
    ULONG                   RemoteNameLength;
    PUCHAR                  pRemoteName;
    ULONG                   AddressType;

    // Line 9
    ULONG                   NumAddrs;
    PULONG                  IpList;
    ULONG                   Flags;
    ULONG                   NodeStatusLen;      // pNodeStatus buffer length

    // Line 10
    LIST_ENTRY              TrackerList;

#ifdef VXD
    PUCHAR                  pchDomainName;
#endif  // VXD

    tIPADDRESS              *pGroupList;   // (NameTypeState = NAMETYPE_GROUP)

    //
    // bug #95241, bug #20697
    // pwRemoteName is pRemoteName in UNICODE format.
    // pwDestName   is pDestName in UNICODE format.
    // If TDI_ADDRESS_TYPE_NETBIOS_WCHAR_EX is used, pwRemoteName will be setup, otherwise it is NULL
    //
    PWCHAR                  UnicodeRemoteName;
    ULONG                   UnicodeRemoteNameLength;
    enum eNameBufferType UNALIGNED  *pNameBufferType;
    UNICODE_STRING          ResolvedRemoteName;
    PWCHAR                  UnicodeDestName;

    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pNetbiosUnicodeEX;
    UNICODE_STRING          ucRemoteName;   // copy of pNetbiosUnicodeEX->RemoteName field
                                            // pNetbiosUnicodeEX->RemoteName may be overwritten by other drivers
                                            // for safety, we need to make sure the buffer is untouched before
                                            // we update it. Make a private copy here.

// #if DBG
    LIST_ENTRY              DebugLinkage;   // to keep track of used trackers
    enum eTrackerType       TrackerType;
// #endif  // DBG
} tDGRAM_SEND_TRACKING;

// this is the type of the procedure to call in the session receive handler
// as data arrives - a different procedure per state
typedef
    NTSTATUS
        (*tCURRENTSTATEPROC)(
                        PVOID                       ReceiveEventContext,
                        struct _LowerConnection     *pLowerConn,
                        USHORT                      RcvFlags,
                        ULONG                       BytesIndicated,
                        ULONG                       BytesAvailable,
                        PULONG                      pBytesTaken,
                        PVOID                       pTsdu,
                        PVOID                       *ppIrp);
#ifdef VXD
#define SetStateProc( pLower, StateProc )
#else
#define SetStateProc( pLower, StateProc )  ((pLower)->CurrentStateProc = (StateProc))
#endif  // VXD


// A Listen is attached to a client element attached address element when a
// client does a listen
typedef VOID    (*tRequestComplete)
                                (PVOID,
                      TDI_STATUS,
                      PVOID);

typedef struct
{
    LIST_ENTRY                  Linkage;
    PCTE_IRP                    pIrp;           // IRP ptr for NT only (may not be true)
    tRequestComplete            CompletionRoutine;
    PVOID                       pConnectEle;    // the connection that the Listen is active on
    PVOID                       Context;
    ULONG                       Flags;
    TDI_CONNECTION_INFORMATION  *pConnInfo;        // from a Listen
    TDI_CONNECTION_INFORMATION  *pReturnConnInfo;  // from a Listen

} tLISTENREQUESTS;

typedef struct
{
    LIST_ENTRY                  Linkage;
    PCTE_IRP                    pIrp;           // IRP ptr for NT only (may not be true)
    PVOID                       pRcvBuffer;
    ULONG                       RcvLength;
    PTDI_CONNECTION_INFORMATION ReceiveInfo;
    PTDI_CONNECTION_INFORMATION ReturnedInfo;

} tRCVELE;

//
// Values for the Flags element above
#define NBT_BROADCAST               0x0001
#define NBT_NAME_SERVER             0x0002
#define NBT_NAME_SERVER_BACKUP      0x0004
#ifdef MULTIPLE_WINS
#define NBT_NAME_SERVER_OTHERS      0x0008
#endif
#define NBT_NAME_SERVICE            0x0010 // two flags used by Tdiout to send dgrams
#define NBT_DATAGRAM_SERVICE        0x0020
#define TRACKER_CANCELLED           0x0040
#define NBT_DNS_SERVER              0x0080
#define NBT_DNS_SERVER_BACKUP       0x0100
#define WINS_NEG_RESPONSE           0x0200
#define REMOTE_ADAPTER_STAT_FLAG    0x1000
#define SESSION_SETUP_FLAG          0x2000
#define DGRAM_SEND_FLAG             0x4000
#define FIND_NAME_FLAG              0x8000
#define NO_DNS_RESOLUTION_FLAG     0x10000
#define NBT_USE_UNIQUE_ADDR        0x20000

#ifdef MULTIPLE_WINS
#define NAME_RESOLUTION_DONE        0x00FF    // Signal termination of Queries over wire
#endif  // MULTIPLE_WINS

//
// this flag indicates that a datagram send is still outstanding in the
// transport - it is set in the tracker flags field.
//
#define SEND_PENDING                0x0080


// Completion routine definition for calls to the Udp... routines.  This routine
// type is called by the tdiout.c completion routine (the Irp completion routine),
// so this is essentially the Nbt completion routine of the Irp.
typedef
    VOID
        (*NBT_COMPLETION)(
                IN  PVOID,      // context
                IN  NTSTATUS,   // status
                IN  ULONG);     // extra info


// Define datagram types
#define DIRECT_UNIQUE       0x10
#define DIRECT_GROUP        0x11
#define BROADCAST_DGRAM     0x12
#define ERROR_DGRAM         0x13
#define QUERY_REQUEST       0x14
#define POS_QUERY_RESPONSE  0x15
#define NEG_QUERY_RESPONSE  0x16

// define datagra flags byte values
#define FIRST_DGRAM 0x02
#define MORE_DGRAMS 0x01

// The type of Device we are bound to
enum eNbtDevice
{
    NBT_DEVICE_REGULAR,
#ifdef _NETBIOSLESS
    NBT_DEVICE_NETBIOSLESS,
#endif  // _NETBIOSLESS
    NBT_DEVICE_CLUSTER,
    NBT_DEVICE_WINS
};

#ifdef _NETBIOSLESS
#define IsDeviceNetbiosless( d ) (d->DeviceType == NBT_DEVICE_NETBIOSLESS)

// Flags for NetbiosOptions
#define NETBT_UNUSED 0
#define NETBT_MODE_NETBIOS_ENABLED 1
#define NETBT_MODE_NETBIOS_DISABLED 2
#endif  // _NETBIOSLESS

//
// The default disconnect timeout used in several places in name.c
//
#define DEFAULT_DISC_TIMEOUT    10  // seconds

//
// this is the value that the IpListIndex is set to when the last datagram
// has been sent.
//
#define LAST_DGRAM_DISTRIBUTION 0xFFFD
#define END_DGRAM_DISTRIBUTION  0xFFFE
// max 500 millisec timeout for ARP on dgram send before netbt sends the next
// datagram.
#define DGRAM_SEND_TIMEOUT      500

//
// These are other states for connections that are not explicitly used by
// NBT but are returned on the NbtQueryConnectionList call.
//
#define LISTENING   20;
#define UNBOUND     21;

// Lower Connection states that deal with receiving to the indicate buffer
#define NORMAL          0
#define INDICATE_BUFFER 1
#define FILL_IRP        2
#define PARTIAL_RCV     3

// Spin Lock Numbers.  Each structure is assigned a number so that locks are
// always acquired in the same order.  The CTESpinLock code checks the lock
// number before setting the spin lock and asserts if it is higher than
// the current one.  This prevents deadlocks.
#define JOINT_LOCK      0x0001
#define DEVICE_LOCK     0x0002
#define ADDRESS_LOCK    0x0004
#define CLIENT_LOCK     0x0008
#define CONNECT_LOCK    0x0010
#define LOWERCON_LOCK   0x0020
#define NBTCONFIG_LOCK  0x0040
#define WORKERQ_LOCK    0x0080

typedef struct
{
    DEFINE_LOCK_STRUCTURE( SpinLock )        // to lock access on an MP machine
#if DBG
    ULONG               LastLockLine;
    ULONG               LastReleaseLine;
    UCHAR               LockNumber;     // spin lock number for this struct
#endif  // DBG
} tNBT_LOCK_INFO;

// overall spin lock to coordinate access to timer entries and hash tables
// at the same time.  Always get the joint lock FIRST and then either the
// hash or timer lock.  Be sure not to get both hash and timer locks or
// dead lock could result
//
typedef struct
{
    tNBT_LOCK_INFO  LockInfo;
}tJOINTLOCK;

// these are two bits to indicated the state of a client element record
//
#define NBT_ACTIVE  1
#define NBT_DOWN    0

// This structure is used by the parse.c to hold on to an Irp from the
// lmhsvc.dll that is used for checking IP addr reachability or for doing
// DNS name queries.  It is also used for Handling LmHost queries.
//
typedef struct
{
    union
    {
        PCTE_IRP        QueryIrp;       // irp passed down from lmhsvc.dll
        tTIMERQENTRY    *pTimer;        // non null if the timer is running
    };
    LIST_ENTRY          ToResolve;      // linked list of names Q'd to resolve
    PVOID               Context;        // currently resolving name context block
    tIPADDR_BUFFER_DNS  *pIpAddrBuf;    // PlaceHolder for Mdl buffer location
    BOOLEAN             ResolvingNow;   // irp is in user mode doing a resolve
} tLMHSVC_REQUESTS;

#define DEFAULT_LMHOST_TIMEOUT      6000   // 6-12 to wait for lmhost or DNS query
#define MIN_LMHOST_TIMEOUT          1000    // 1  seconds min

//
// Lmhosts Domain Controller List - keeps a list of #DOM names that have
// been retrieved from the LMhosts file
//
typedef struct
{
    LIST_ENTRY  DomainList;

} tDOMAIN_LIST;
//
// The pIpList of a domain name starts with 6 ulongs of space
//
#define INITIAL_DOM_SIZE sizeof(tIPADDRESS)*6

#ifndef VXD
//
// This structure keeps track of the WINS recv Irp and any datagram
// queued to go up to WINS (name service datagrams)
//
typedef struct
{
    LIST_ENTRY      Linkage;
    ULONG           Verify;
    tIPADDRESS      IpAddress;

    LIST_ENTRY      RcvList;            // linked list of Datagrams Q'd to rcv
    LIST_ENTRY      SendList;           // Dgrams Q'd to be sent

    struct _DeviceContext  *pDeviceContext;    // the devicecontext used by wins for sends
    PCTE_IRP        RcvIrp;             // irp passed down from WINS for Rcv
    ULONG           RcvMemoryAllocated; // bytes buffered so far
    ULONG           RcvMemoryMax;       // max # of bytes to buffer on Rcv

    ULONG           SendMemoryAllocated;// bytes for buffering dgram sends
    ULONG           SendMemoryMax;      // max allowed for buffering dgram sends
    ULONG           WinsSignature;
} tWINS_INFO;

//
// Wins Rcv Buffer structure
//
typedef struct
{
    LIST_ENTRY      Linkage;
    ULONG           DgramLength;
    tREM_ADDRESS    Address;

} tWINSRCV_BUFFER;
#endif  // !VXD


// Connection Database...
// this tracks the connection to the transport and the address of the
// endpoint (Net Bios name) and a connection Context to return to the client
// on each Event (i.e. Receive event or Disconnect Event ).

// the possible states of the lower connection to the transport
enum eSTATE
{
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_RECONNECTING,       // waiting for the Worker thread to run NbtConnect again
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};

enum eREF_CONN
{
    REF_CONN_CREATE,
    REF_CONN_INBOUND,
    REF_CONN_SESSION,
    REF_CONN_CONNECT,
    REF_CONN_CLEANUP_ADDR,
    REF_CONN_SESSION_TIMEOUT,
    REF_CONN_MAX
};

typedef struct _Connect
{
    // Line # 1
    LIST_ENTRY                Linkage;       // ptrs to next in chain
    ULONG                     Verify;        // set to a known value to verify block
    LONG                      RefCount;      // number of active requests on the connection

    // Line # 2
    struct _LowerConnection   *pLowerConnId; // connection ID to transport
    struct _DeviceContext     *pDeviceContext;
    struct _Client            *pClientEle;   // ptr to client record
    enum eSTATE               state;

    // Line # 3
    UCHAR RemoteName[NETBIOS_NAME_SIZE];

    // Line # 4
    PCTE_IRP                  pIrp;          // IRP ptr for a send
    PCTE_IRP                  pIrpClose;     // IRP for an NtClose
    PCTE_IRP                  pIrpDisc;      // IRP for Disconnects when connection is still pending
    PCTE_IRP                  pIrpRcv;       // IRP that client has passed down for a session Rcv

    // Line # 5
#ifndef VXD
    PMDL                      pNextMdl;      // the next MDL in the chain to use as a basis for a partial MDL
    PMDL                      pNewMdl;       // keep extra MDL if needed to handle multichunk rcvs
    ULONG                     CurrentRcvLen; // #of bytes to recv for Irp
    ULONG                     FreeBytesInMdl;// tracks how full current Mdl is in the FILLIRP state.
#else
    UCHAR RTO ;                              // NB Receive timeout (in 1/2 sec)
    UCHAR STO ;                              // NB Send timeout
    USHORT Flags ;
#endif  // !VXD

    // Line # 6
    ULONG                     BytesInXport;  // number of bytes left in the transport
    ULONG                     BytesRcvd;     // number of bytes recvd so far
    ULONG                     ReceiveIndicated; // count of number of rcv indicates not handled yet
    ULONG                     OffsetFromStart;// the amount of the Mdl/NCB that has been filled

    // Line # 7
    ULONG                     TotalPcktLen;  // length of session packet
    ULONG                     AddressType;   // type of address over which the connection was established
    CONNECTION_CONTEXT        ConnectContext;// ret to client on each event
    UCHAR                     SessionSetupCount; // number of tries in case destination is in b/w listens
    UCHAR                     DiscFlag;       // disconnect was an abort or normal release (NbtDisconnect)?
    // The DNS status of the remote name is recorded in this field. It is set to
    // FALSE on creation of a tCONNECTELE instance and changed to TRUE if the
    // DNS resolution for the Remote Name fails. This is used to throttle back
    // subsequent requests for the same DNS name.
    BOOLEAN RemoteNameDoesNotExistInDNS;
    BOOLEAN                   Orig;           // originating connection? (if conn in freelist to be deleted)

    // Line # 8
    LIST_ENTRY                RcvHead;       // List of Rcv Buffers

    // Line # 9
    PFILE_OBJECT              pClientFileObject;    // so that Rdr can get a backptr from the connection
    tNBT_LOCK_INFO            LockInfo;     // spin lock info for this struct

    BOOLEAN                   JunkMsgFlag;
    // The NetBt Connection logic manages a pool of lower connection blocks. These
    // entries are replenished with every associate call made from the client.
    // The entries are removed with a fresh invocation to NbtConnectCommon.
    // Since it is conceivable that multiple invocations to NbtConnectCommon can be
    // made this state needs to be recorded in the connect element.
    BOOLEAN                   LowerConnBlockRemoved;
#ifdef RASAUTODIAL
    // this field is TRUE if an automatic connection is in progress
    // for this connection.  we use this to prevent an infinite
    // number of automatic connection attempts to the same address.
    BOOLEAN                   fAutoConnecting;
    // this field is TRUE if this connection has already been
    // autoconnected.
    BOOLEAN                   fAutoConnected;
#endif  // RASAUTODIAL
    BOOLEAN                   ConnectionCleanedUp;

// #if DBG
    UCHAR                       References[REF_CONN_MAX];
// #endif  // DBG
} tCONNECTELE;


// Placeholder for TCP Send routine if Fast Send is possible
typedef
NTSTATUS
(*PTCPSEND_DISPATCH) (
   IN PIRP Irp,
   IN PIO_STACK_LOCATION irpsp
   );



//
// Enumerate all the different contexts under which the LowerConnection
// is referenced
//
enum eREF_LOWERCONN
{
    REF_LOWC_CREATE,
    REF_LOWC_ASSOC_CONNECTION,
    REF_LOWC_CONNECTED,
    REF_LOWC_WAITING_INBOUND,
    REF_LOWC_DISABLE_INBOUND,
    REF_LOWC_KEEP_ALIVE,
    REF_LOWC_QUERY_DEVICE_REL,
    REF_LOWC_QUERY_INFO,
    REF_LOWC_SET_TCP_INFO,
    REF_LOWC_RCV_HANDLER,
    REF_LOWC_OUT_OF_RSRC,
    REF_LOWC_SEND,
    REF_LOWC_MAX
};


// a list of connections to the transport.  For each connection opened
// to the transport, the connection context is set to the address of this
// block so that when info comes in on the conection, the pUpperConnection
// ptr can be used to find the client connection
typedef struct _LowerConnection
{
    // Line # 1
    LIST_ENTRY              Linkage;
    ULONG                   Verify;
    LONG                    RefCount;           // the number of active users of record

    // Line # 2
    struct _Connect         *pUpperConnection;  // ptr to upper conn. to client
    struct _DeviceContext   *pDeviceContext;    // so we can put connection back on its free list at the end
    enum eSTATE             State;
    USHORT                  StateRcv;           // the receive state = Normal/UseIndic/FillIrp/PartialRcv
    BOOLEAN                 bOriginator;        // TRUE if the connection originated on this side
    BOOLEAN                 OutOfRsrcFlag;      // Set when connection is queued onto the OutOfRsrc list to
                                                // indicate to DeleteLowerConn not to remove from any list.
    // Line # 3
    PCTE_IRP                pIrp;               // Irp to complete after disconnect completes
    ULONG                   SrcIpAddr;
#ifndef VXD
    PMDL                    pIndicateMdl;       // This mdl holds up to 128 bytes as mandated by TDI
    PMDL                    pMdl;               // So that if we receive session PDU in several chunks,
#endif  // !VXD                                 // we can reset original Mdl

    // Line # 4
    // Contains Handle/Object of a TDI Connection for incoming connections
    CTE_ADDR_HANDLE         pFileObject;        // file object for the connection
    // Address object handles - used for outgoing connections only since
    // inbound connections are all bound to the same address object (port 139)
    //
    // The VXD uses only pAddrFileObject which contains the openned address
    // handle (used for compatibility with existing code).
    //
    CTE_ADDR_HANDLE         pAddrFileObject;    // file object for the address
#ifndef VXD
    HANDLE                  FileHandle;         // file handle for connection to transport
    HANDLE                  AddrFileHandle;     // file handle for the address

    // Line # 5
    // in the receive handler this procedure variable is used to point to the
    // procedure to call for the current state (Normal,FillIrp,IndicateBuff,RcvPartial)
    ULONGLONG               BytesRcvd;          // for query provider statistics
    ULONGLONG               BytesSent;

    // Line # 6
    tCURRENTSTATEPROC       CurrentStateProc;
    ULONG                   BytesInIndicate;    // the number of bytes in the indicate buffer
    ULONG                   TimeUnitsInLastState;
#else
    ULONG                   BytesRcvd;          // for query provider statistics
    ULONG                   BytesSent;
    tSESSIONHDR             Hdr ;   // VXD only has to worry about getting enough data for the session header
    LIST_ENTRY              PartialRcvList;     // When we go into partial rcv state, until NCB is submitted
    USHORT                  BytesInHdr;         //  Number of bytes in Hdr
    BOOLEAN                 fOnPartialRcvList;
#endif  // !VXD
    tNBT_LOCK_INFO          LockInfo;           // spin lock info for this struct
    // this flag is set true when executing the session Rcv Handler so we
    // can detect this state and not free ConnEle or LowerConn memory.
    BOOLEAN                 InRcvHandler;
    BOOLEAN                 SpecialAlloc;       // If this ws allocated to tackle TCP/IP SynAttack problem

    // Placeholder for TCP Send routine if Fast Send is possible
    PTCPSEND_DISPATCH       FastSend;

// #if DBG
    UCHAR               References[REF_LOWC_MAX];
// #endif  // DBG
} tLOWERCONNECTION;


#define NBT_DISASSOCIATE_CONNECTION(_pConnEle, _pLowerConn)     \
        _pConnEle->pLowerConnId = NULL;                         \
        _pLowerConn->pUpperConnection = NULL;

#define SET_STATE_UPPER(_C, _S)         \
    _C->state = _S;

#define SET_STATE_LOWER(_L, _S)         \
    _L->State = _S;                     \
    _L->TimeUnitsInLastState = 0;

#define SET_STATERCV_LOWER(_L, _S, _P)  \
    _L->StateRcv = _S;                  \
    SetStateProc(_L, _P);               \
    _L->TimeUnitsInLastState = 0;


// the Client list is just a list of linked blocks where the address of the
// block is the HANDLE returned to the client - The client block is linked onto
// the chain of clients that have opened the address.
typedef struct _Client
{
    // Line # 1
    LIST_ENTRY         Linkage;       // double linked list to next client
    ULONG              Verify;        // set to a known value to verify block
    LONG               RefCount;

    // Line # 2
    PCTE_IRP           pIrp;          // IRP ptr for NT only... during name registration
    struct _DeviceContext *pDeviceContext; // the device context associated with this connection
    struct _Address    *pAddress;     // ptr to address object that this client is Q'd on
    ULONG              AddressType;   // Stashed value of the original value stored in the address element.

    // Line # 3
    UCHAR              EndpointName[NETBIOS_NAME_SIZE];

    // Line # 4
    LIST_ENTRY         ConnectHead;   // list of connections
    LIST_ENTRY         ConnectActive; // list of connections that are in use

    // Line # 5
    LIST_ENTRY         RcvDgramHead;  // List of dgram buffers to recv into
    LIST_ENTRY         ListenHead;    // List of Active Listens

    // Line # 6
    LIST_ENTRY         SndDgrams;     // a doubly linked list of Dgrams to send
#ifdef VXD
    LIST_ENTRY         RcvAnyHead ;   // List of RCV_CONTEXT for NCB Receive any
    BOOL               fDeregistered; // TRUE if name has been deleted and we're waiting for sessions to close
#endif  // VXD
    PTDI_IND_CONNECT   evConnect;     // Client Event to call
    PVOID              ConEvContext;  // EVENT Context to pass to client

    // Line # 7
    PTDI_IND_RECEIVE   evReceive;
    PVOID              RcvEvContext;
    PTDI_IND_DISCONNECT evDisconnect;
    PVOID              DiscEvContext;

    // Line # 8
    PTDI_IND_ERROR     evError;
    PVOID              ErrorEvContext;
    PTDI_IND_RECEIVE_DATAGRAM  evRcvDgram;
    PVOID              RcvDgramEvContext;

    // Line # 9
    PTDI_IND_RECEIVE_EXPEDITED evRcvExpedited;
    PVOID              RcvExpedEvContext;
    PTDI_IND_SEND_POSSIBLE evSendPossible;
    PVOID              SendPossEvContext;

    // Line # 10
    tNBT_LOCK_INFO     LockInfo;     // spin lock info for this struct
    BOOLEAN            ExtendedAddress;
    BOOLEAN            WaitingForRegistration;  // If several clients register the same name at the same time
} tCLIENTELE;                                   // It is reset in RegisterCompletion.


enum eREF_FSP
{
    REF_FSP_CONN,
    REF_FSP_NEWADDR,
    REF_FSP_WAKEUP_TIMER_EXPIRY,
    REF_FSP_STOP_WAKEUP_TIMER,
    REF_FSP_START_WAKEUP_TIMER,
    REF_FSP_SET_TCP_INFO,
    REF_FSP_ADD_INTERFACE,
    REF_FSP_DEVICE_ADD,
    REF_FSP_CREATE_SMB_DEVICE,
    REF_FSP_CREATE_DEVICE,
    REF_FSP_DELETE_DEVICE,
    REF_FSP_CLOSE_FILE_HANDLES,
    REF_FSP_CLOSE_ADDRESSES,
    REF_FSP_CLOSE_FILE,
    REF_FSP_PROCESS_IP_REQUEST,
    REF_FSP_CLOSE_CONNECTION,
    REF_FSP_CLOSE_ADDRESS,
    REF_FSP_MAX
};


//
// Enumerate all the different places the Address can be referenced to
// keep track of RefCounts
//
enum eREF_ADDRESS
{
    REF_ADDR_NEW_CLIENT,
    REF_ADDR_REGISTER_NAME,
    REF_ADDR_REG_COMPLETION,
    REF_ADDR_REFRESH,
    REF_ADDR_DGRAM,
    REF_ADDR_MULTICLIENTS,
    REF_ADDR_DEL_DEVICE,
    REF_ADDR_MAX
};

// The Address List is a set of blocks that contain the netbios names active
// on the node.  Each time a connection request comes in or a datagram is
// received, the destination name must be found in the address list.
// There is one of these for each Netbios name in the system, although there
// can be more than one client attached to each of these.  In addition,
// a client can open the same name for several different adapters. In this case
// the nbt code first finds the ptr to this address element, and then it walks
// the client list to find a client with a "deviceContext" (ip address) that
// matches the adapter that the pdu came in on.
typedef struct _Address
{
    // Line # 1
    LIST_ENTRY         Linkage;         // link to next item in list
    ULONG              Verify;          // set to a known value to verify block
    LONG               RefCount;

    // Line # 2
    LIST_ENTRY         ClientHead;      // list of client records Q'd against address
    tNAMEADDR          *pNameAddr;      // ptr to entry in hash table
    ULONG              AddressType;     // Type of address specified in opening the connection object
                                        // when names are added in NbtOpenAddress

    // Line # 3
    USHORT             NameType;        // Group or Unique NAMETYPE_UNIQUE or group
    BOOLEAN            MultiClients;    // signals Dgram Rcv handler that more than one client exists - set
    tNBT_LOCK_INFO     LockInfo;        // spin lock info for this struct
#ifndef VXD
    SHARE_ACCESS       ShareAccess;     // Used for checking share access
    PSECURITY_DESCRIPTOR SecurityDescriptor; // used to hold ACLs on the address
#endif  // !VXD
} tADDRESSELE;


// this structure is used to store the addresses of the name servers
// for each adapter - it is used in Registry.c and Driver.c
//
typedef struct
{
    union
    {
        tIPADDRESS      AllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  NameServerAddress;
            tIPADDRESS  BackupServer;
            tIPADDRESS  Others[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };
    USHORT  NumOtherServers;
    USHORT  LastResponsive;
#ifdef _NETBIOSLESS
    BOOLEAN NetbiosEnabled;
#endif  // _NETBIOSLESS
    ULONG   RasProxyFlags;
    BOOLEAN EnableNagling;
}tADDRARRAY;

typedef struct
{
    UCHAR   Address[6];
}tMAC_ADDRESS;


typedef ULONG IPAddr;

// Placeholder for IP FastQuery routine to determine InterfaceContext + metric for dest addr
typedef
NTSTATUS
(*PIPFASTQUERY)(
    IN   IPAddr  Address,
    OUT  PULONG   pIndex,
    OUT  PULONG   pMetric
    );



//
// Enumerate all the different places the device can be referenced to
// keep track of RefCounts
//
enum eREF_DEVICE
{
    REF_DEV_DISPATCH,
    REF_DEV_WORKER,
    REF_DEV_TIMER,
    REF_DEV_LMH,
    REF_DEV_OUTBOUND,
    REF_DEV_DGRAM,
    REF_DEV_FIND_REF,
    REF_DEV_NAME_REL,
    REF_DEV_REREG,
    REF_DEV_GET_REF,
    REF_DEV_OUT_FROM_IP,
    REF_DEV_UDP_SEND,
    REF_DEV_WINS,
    REF_DEV_AUTODIAL,
    REF_DEV_CREATE,
    REF_DEV_SMB_BIND,
    REF_DEV_MAX
};


// this type is the device context which includes NBT specific data
// that is initialized when "DriverEntry" is called.
//

//
// The transport type is used to distinguish the additional transport types
// that can be supported, NETBT framing without NETBIOS name resolution/registration
// and NETBIOS over TCP. The transport type is stored as part of all the upper
// level data structures. This enables us to reuse NETBT code and expose multiple
// device objects at the top level. Currently these are not exposed. In preparation
// for exporting multiple transport device objects the DeviceContext has been
// reorganized.
// The elements that would be common to all the device objects have been gathered
// together in tCOMMONDEVICECONTEXT. This will include an enumerated type to
// distinguish between the various device objects in the future. Currently there is only
// one device context and the fields that belong to it are listed ...
//
// RegistrationHandle -- PNP power,
// enumerated type distinguishing the types.
//

typedef struct _DeviceContext
{
    // the I/O system's device object
    DEVICE_OBJECT   DeviceObject;
    ULONG           IsDestroyed;        // ulong since we use interlocked ops to manipulate it.
    enum eNbtDevice DeviceType;         // Whether it is a regular device or a "special" device

    // Line # 12 (0xc0)
    LIST_ENTRY      Linkage;            // For storage in the tNBTCONFIG structure
    ULONG           Verify;             // To verify that this is a device context record
    ULONG           RefCount;           // keep this device around until all names have been released

    // Line # 13 (0xd0)
    LIST_ENTRY      WaitingForInbound;  // list of pLowerConn's waiting for SessionSetup from remote
    LIST_ENTRY      UpConnectionInUse;  // connections that the clients have created

    // Line # 14 (0xe0)
    LIST_ENTRY      LowerConnection;    // Currently-used connections to the transport provider
    LIST_ENTRY      LowerConnFreeHead;  // Connected to transport but not currently to a client(upper) conn.
                                        // - ready to accept an incoming session

    // Line # 15 (0xf0)
    ULONG           NumWaitingForInbound;  // number of pLowerConn's waiting for SessionSetup from remote
    ULONG           NumQueuedForAlloc;
    ULONG           NumSpecialLowerConn;
    tCLIENTELE      *pPermClient;       // permanent name client record (in case we have to delete it later)

    // Line # 16 (0x100)
    UNICODE_STRING  BindName;           // name of the device to bind to - *TODO* remove from this struct.
    UNICODE_STRING  ExportName;         // name exported by this device

    // Line # 17 (0x110)
    tIPADDRESS      IpAddress;          // addresses that need to be opened with the transport
    tIPADDRESS      SubnetMask;
    tIPADDRESS      BroadcastAddress;
    tIPADDRESS      NetMask;            // mask for the network number

    // Line # 18 (0x120)
    union
    {
        tIPADDRESS      lAllNameServers[2+MAX_NUM_OTHER_NAME_SERVERS];
        struct
        {
            tIPADDRESS  lNameServerAddress; // the Ip Address of the Name Server
            tIPADDRESS  lBackupServer;
            tIPADDRESS  lOtherServers[MAX_NUM_OTHER_NAME_SERVERS];
        };
    };

    // Line # 21 (0x150)
    USHORT          lNumOtherServers;
    USHORT          lLastResponsive;
    ULONG           NumAdditionalIpAddresses;
    CTEULONGLONG    AdapterMask;        // bit mask for adapters 1->64 (1-32 for VXD)

    // Line # 22 (0x160)
    HANDLE          DeviceRegistrationHandle;       // Handle returned from TdiRegisterDeviceObject.
    HANDLE          NetAddressRegistrationHandle;   // Handle returned from TdiRegisterNetAddress.
    ULONG           InstanceNumber;
    ULONG           WakeupPatternRefCount;

    // Line # 23 (0x170)
    UCHAR           WakeupPatternName[NETBIOS_NAME_SIZE];

    // Line # 24 (0x180)
    tFILE_OBJECTS   *pFileObjects;      // Pointer to FileObjects on the Transport
    HANDLE          hSession;
    PDEVICE_OBJECT  pSessionDeviceObject;
    CTE_ADDR_HANDLE pSessionFileObject;


    // Line # 25 (0x190)
    // these are handles to the transport control object, so we can do things
    // like query provider info... *TODO* this info may not need to be kept
    // around... just set it up once and then drop it?
    HANDLE          hControl;
    PDEVICE_OBJECT  pControlDeviceObject;
    PFILE_OBJECT    pControlFileObject;
    KEVENT          DeviceCleanedupEvent;

    // Line # 26 (0x1a0)
    //
    ULONG           AdapterNumber;      // index of adapter in DeviceContexts list (starts from 1)
    ULONG           IPInterfaceContext; // Context value for IP adapter
    PTCPSEND_DISPATCH   pFastSend;      // function ptr for doing a FastSend into TcpIp
    PIPFASTQUERY    pFastQuery;         // function ptr for doing a FastQuery for interface + metric info
    ULONG           WOLProperties;      // Whether this Device supports WOL or not!

    // Handles for open addresses to the transport provider
    // The VXD uses only the p*FileObject fields which contain TDI Addresses or connection IDs
    //
    NETBT_PNP_CONTEXT Context1;                   // This is to store the Device Name to pass as the context
    NETBT_PNP_CONTEXT Context2;                   // This is to store the PDOContext passed to us from TCPIP
    // this is a bit mask, a bit shifted to the bit location corresponding
    // to this adapter number
    tMAC_ADDRESS    MacAddress;

    tNBT_LOCK_INFO  LockInfo;           // spin lock info for this struct
    BOOLEAN         RefreshToBackup;    // flag to say switch to backup nameserver
    BOOLEAN         SwitchedToBackup;   // flag to say whether we are on original Primary or Backup
    BOOLEAN         WinsIsDown;         // per Devcontext flag to tell us not to contact WINS for 15 sec.
    UCHAR           DeviceRefreshState; // Keep track of whether this is a new refresh of not

    ULONG           IpInterfaceFlags;   // From IOCTL_TCP_QUERY_INFORMATION_EX (has P2P and P2MP flags)
    ULONG           AssignedIpAddress;  // addresses that need to be opened with the transport
    BOOLEAN         NetbiosEnabled;     // Flag indicating device is currently active
    ULONG           RasProxyFlags;      // Flags for RAS proxy
    USHORT          SessionPort;        // Session port to use
    USHORT          NameServerPort;     // Name server port to use
    USHORT          DatagramPort;       // Datagram port to use
    CHAR            MessageEndpoint[NETBIOS_NAME_SIZE];       // Endpoint to use for message only

    ULONG           NumFreeLowerConnections;
    ULONG           TotalLowerConnections;
    ULONG           NumServers;
    BOOLEAN         EnableNagling;
    tIPADDRESS      AdditionalIpAddresses[MAX_IP_ADDRS];
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    enum eTDI_ACTION    DelayedNotification;
    KEVENT              DelayedNotificationCompleteEvent;
#endif

// #if DBG
    ULONG           ReferenceContexts[REF_DEV_MAX];
// #endif  // DBG
} tDEVICECONTEXT;


// this structure is necessary so that the NBT_WORK_ITEM_CONTEXT will have
// the same structure in the vxd and NT cases.
//
typedef struct
{
    LIST_ENTRY  List;
} VXD_WORK_ITEM;

//
// Work Item structure for work items put on the Kernel Excutive worker threads
//
typedef struct
{
#ifndef VXD
    WORK_QUEUE_ITEM         Item;   // Used by OS to queue these requests
#else
    VXD_WORK_ITEM           Item;
#endif  // !VXD
    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientContext;
    PVOID                   ClientCompletion;
    BOOLEAN                 TimedOut;
#ifdef _PNP_POWER_
    tDEVICECONTEXT          *pDeviceContext;
    LIST_ENTRY              NbtConfigLinkage;
    PVOID                   WorkerRoutine;
#endif  // _PNP_POWER_
} NBT_WORK_ITEM_CONTEXT;


#ifdef VXD

typedef void (*DCCallback)( PVOID pContext ) ;

typedef struct
{
    NBT_WORK_ITEM_CONTEXT  dc_WIC ;         // Must be first item in structure
    CTEEvent               dc_event ;
    DCCallback             dc_Callback ;
    struct _DeviceContext *pDeviceContext;
    LIST_ENTRY             Linkage;
} DELAYED_CALL_CONTEXT, *PDELAYED_CALL_CONTEXT ;

typedef struct
{
    LIST_ENTRY       Linkage;
    ULONG            Verify;
    NCB             *pNCB;
    CTEBlockStruc   *pWaitNCBBlock;
    BOOL             fNCBCompleted;
    BOOL             fBlocked;
} BLOCKING_NCB_CONTEXT, *PBLOCKING_NCB_CONTEXT;



typedef struct
{
    //
    // Book keeping.
    //
    LIST_ENTRY      Linkage;
    tTIMERQENTRY    *pTimer;    // ptr to active timer entry
    tDEVICECONTEXT  *pDeviceContext;
    //
    // Domain name for next query.
    //
    PUCHAR          pchDomainName;
    //
    // Flags to track progress.
    //
    USHORT          Flags;
    //
    // Transaction ID used in name query.
    //
    USHORT          TransactId;
    //
    // Client fields follow.
    //
    NCB             *pNCB;
    PUCHAR          pzDnsName;
    PULONG          pIpAddress;

} DNS_DIRECT_WORK_ITEM_CONTEXT, *PDNS_DIRECT_WORK_ITEM_CONTEXT;

typedef struct
{
    tDEVICECONTEXT  *pDeviceContext;
    TDI_CONNECTION_INFORMATION
                    SendInfo;
    TA_IP_ADDRESS   NameServerAddress;
    tBUFFER         SendBuffer;   // send buffer and header to send
    tNAMEHDR        NameHdr;
} DNS_DIRECT_SEND_CONTEXT, *PDNS_DIRECT_SEND_CONTEXT;

//
// Flag bits useful for DNS direct name queries.
//
#define DNS_DIRECT_CANCELLED        0x0001      // request cancelled
#define DNS_DIRECT_DNS_SERVER       0x0002      // going to main DNS
#define DNS_DIRECT_DNS_BACKUP       0x0004      // going to main DNS
#define DNS_DIRECT_TIMED_OUT        0x0008      // request timed out
#define DNS_DIRECT_NAME_HAS_DOTS    0x0010      // name has dots in it, could be fully formed
                                                // DNS specifier
#define DNS_DIRECT_ANSWERED         0x0020      // This query has been answered
#endif // VXD

#ifndef VXD
// configuration information is passed between the registry reading
// code and the driver entry code in this data structure
// see ntdef.h for this type....
typedef struct
{
    PKEY_VALUE_FULL_INFORMATION RegistryData;   // MULTI_SZ data read from the registry
    UNICODE_STRING              Names[1];       // array of strings initialized from RegistryData above
}tDEVICES;
#endif  // !VXD

// this is the control object for all of NBT that tracks a variety
// of counts etc.  There is a ptr to this in the GlobConfig structure
// below so that we can delete it later at clean up time
typedef struct
{
    // a value to verify that this is a device context record
    ULONG           Verify;

    // this is a LARGE structure of goodies that is returned to the client
    // when they do a QueryInformation on TDI_PROVIDER_INFO
    TDI_PROVIDER_INFO  ProviderInfo;
} tCONTROLOBJECT;

// Keep an Irp around for the out of resource case, so that we can still
// disconnection a connection with the transport
// Also, keep a KDPC handy so if we can use it in case lot of connections
// are to be killed in succession
//
typedef struct
{
    PIRP        pIrp;
    LIST_ENTRY  ConnectionHead;
#ifndef VXD
    PKDPC       pDpc;
#endif

} tOUTOF_RSRC;


// this type holds NBT configuration information... is globally available
// within NBT using NbtConfig.
typedef struct
{
    // Line # 1
    LIST_ENTRY  DeviceContexts;     // list of DeviceContexts, 1/network adapter(tDEVICECONTEXT)
    LIST_ENTRY  DevicesAwaitingDeletion;    // list of DeviceContexts waiting to be deleted

    // Line # 2
    tHASHTABLE  *pLocalHashTbl;     // hash table to keep track of local names
    tHASHTABLE  *pRemoteHashTbl;    // hash table to keep track of remote names
    LIST_ENTRY  DgramTrackerFreeQ;  // buffers to track Dgram sends...

    // Line # 3
    LIST_ENTRY  NodeStatusHead;     // list of node status messages being sent
    LIST_ENTRY  AddressHead;        // allocated addresses in a linked list

    // Line # 4
    LIST_ENTRY  PendingNameQueries;
    LIST_ENTRY  IrpFreeList;        // Irps needed at Dispatch level and can't create them at that level

#ifdef VXD
    LIST_ENTRY  DNSDirectNameQueries;
    LIST_ENTRY  SendTimeoutHead;    //  Tracks Send NCBs to check if they have timed out yet.
    LIST_ENTRY  SessionBufferFreeList; // Free eNBT_SESSION_HDR buffer list
    LIST_ENTRY  SendContextFreeList;// TDI_SEND_CONTEXT (not SEND_CONTEXT!) -- eNBT_SEND_CONTEXT
    LIST_ENTRY  RcvContextFreeList; // Free eNBT_RCV_CONTEXT buffer list
    LIST_ENTRY  DelayedEvents;      // all events scheduled for later (that apply to all device contexts)
    LIST_ENTRY  BlockingNcbs;
#else

    // Line # 5
    tCONTROLOBJECT      *pControlObj; // a ptr to keep track of the memory allocated to the control object
    PDRIVER_OBJECT      DriverObject;
    SINGLE_LIST_ENTRY   SessionMdlFreeSingleList; // MDLs for session sends to speed up sending session PDUs
    SINGLE_LIST_ENTRY   DgramMdlFreeSingleList; // MDLs for datagram sends to speed up sending

    // Line # 6
    UNICODE_STRING      pRegistry;  // ptr to registry Node for Netbt if DHCP requests come down later.
    PWSTR       pTcpBindName;       // a ptr to the name of the transport (i.e. \Device\Streams\")
#endif //VXD
    tTIMERQENTRY *pRefreshTimer;    // timer entry for refreshing names with WINS
    tTIMERQENTRY *pWakeupRefreshTimer;    // timer entry for Waking machine up from Hibernation!
    tTIMERQENTRY *pSessionKeepAliveTimer;
    tTIMERQENTRY *pRemoteHashTimer;

    // Line # 7
#ifdef _PNP_POWER_
    USHORT      uNumDevicesInRegistry;  // number of adapters counted in registry
#else
    USHORT      uNumDevices;            // number of adapters counted in registry
#endif  // _PNP_POWER_
    USHORT      iCurrentNumBuff[eNBT_NUMBER_BUFFER_TYPES];  // track how many buffers have been allocated
    USHORT      iMaxNumBuff[eNBT_NUMBER_BUFFER_TYPES];
    USHORT      iBufferSize[eNBT_NUMBER_BUFFER_TYPES];      // eNBT_NUMBER_BUFFER_TYPES == 5

    // Line # 9
    int         NumConnections;     // number of connections set in registry
    int         NumAddresses;       // number of addresses node supports set in reg.
    ULONG       InterfaceIndex;
#ifndef VXD
    // This structure keeps an Irp ready to disconnect a connection in the
    // event we run out of resources and cannot do anything else. It also allows
    // connections to Q up for disconnection.
    tOUTOF_RSRC OutOfRsrc;

    // used to hold Address exclusively while registering - when mucking with
    // ShareAccess and the security descriptors
    //
    ERESOURCE          Resource;
#endif  // !VXD

    USHORT      uNumLocalNames;         // size of remote hash table for Pnode
    USHORT      uNumRemoteNames;        // size of remote hash table for Proxy
    USHORT      uNumBucketsRemote;
    USHORT      uNumBucketsLocal;
    USHORT      TimerQSize;             // the number of timer Q blocks
    USHORT      AdapterCount;           // bindings/devices/local IP addresses in use

    LONG        uBcastTimeout;          // timeout between Broadcasts
    LONG        uRetryTimeout;          // timeout between retries

    CTEULONGLONG CurrentAdaptersMask;   // Bit mask of currently active adapters
    ULONG       CacheTimeStamp;
    USHORT      RemoteCacheLen;
    UCHAR       MultipleCacheFlags;
    BOOLEAN     CachePerAdapterEnabled; // Will try to resolve names on all interfaces
    BOOLEAN     ConnectOnRequestedInterfaceOnly;    // Strict source routing
    BOOLEAN     SendDgramOnRequestedInterfaceOnly;  // Strict source routing for sending datagram.
    BOOLEAN     SMBDeviceEnabled;       // Whether SMB device should be enabled or not

    USHORT      uNumRetries;            // number of times to send a dgram - NS as well as Dgram Queries
    USHORT      uNumBcasts;             // number of times to bcast name queries

    // the scope must begin with a length byte that gives the length of the next
    // label, and it must end with a NULL indicating the zero length root
    USHORT      ScopeLength;            // number of bytes in scope including the 0 on the end
    USHORT      SizeTransportAddress;   // number of bytes in transport addr (sizeof TDI_ADDRESS_IP for IP)
    PCHAR       pScope;                 // scope if ScopeLength > 0

    tNAMEADDR   *pBcastNetbiosName;     // a ptr to the netbios name record in the local hash table

    // the shortest Ttl of any name registered by this node and the name that
    // has the shortest Ttl
    ULONG       MinimumTtl;
    ULONG       RefreshDivisor;
    ULONG       RemoteHashTtl;
    ULONG       MinimumRefreshSleepTimeout;
    //
    // This is amount of time to stop talking to WINS when we fail to contact
    // it on a name registration. Nominally around 5 seconds - configurable.
    //
    ULONG       WinsDownTimeout;
    ULONG       InitialRefreshTimeout;  // to refresh names to WINS till we hear from WINS
    ULONG       KeepAliveTimeout;       // keep alive timeout for sessions
    ULONG       RegistryBcastAddr;

    ULONG       DhcpNumConnections;     // # connections to restore when the ip address becomes valid again.
    USHORT      CurrentHashBucket;

    USHORT      PduNodeType;     // node type that goes into NS pdus
    USHORT      TransactionId;   // for name service request, to number them

    USHORT      NameServerPort;  // UDP port to send queries/reg to (on the name server)
#ifdef VXD
    USHORT      DnsServerPort;   // UDP port to send DNS queries to (on the dns server)
#endif  // VXD
    USHORT      sTimeoutCount;   // current time segment we are on for refresh

    USHORT      LastSwitchTimeoutCount;  // Count to know when we last switched to primary

    // this spin lock is used to coordinate access to the timer Q and the
    // hash tables when either a timer is expiring or a name service PDU
    // has come in from the wire.  This lock must be acquired first, and
    // then the timer Q lock.
    tJOINTLOCK  JointLock;
    tNBT_LOCK_INFO  LockInfo;     // spin lock info for this struct
    USHORT      RemoteTimeoutCount; // how long to timeout remote hash entries

    // if 1, then use -1 for bcast addr - if 0 use subnet broadcast address
    BOOLEAN     UseRegistryBcastAddr;

    // the maximum amount of buffering that we will do for sent datagrams
    // This is also used by Wins to determine inbound and outbound buffer
    // limits.
    ULONG       MaxDgramBuffering;
    // this is the time that a name query can spend queued waiting for the
    // the worker thread to service it. - default is 30 seconds.
    ULONG       LmHostsTimeout;

    PUCHAR      pLmHosts;
    ULONG       PathLength;  // the length of the directory portion of pLmHosts
    CTESystemTime   LastForcedReleaseTime;
    CTESystemTime   LastOutOfRsrcLogTime;
#ifdef VXD
    PUCHAR      pHosts;      // path to the hosts file
    PUCHAR      pDomainSearchOrder; // primary domain: used during DNS resolution
    PUCHAR      pDNSDevolutions; // "other domains"

    ULONG       lRegistryDnsServerAddress;
    ULONG       lRegistryDnsBackupServer;

    USHORT      lRegistryMaxNames;
    USHORT      lRegistryMaxSessions;
#endif  // VXD

    BOOLEAN     MultiHomed;  // True if NBT is bound to more than one adapter
    BOOLEAN     SingleResponse; // if TRUE it means do NOT send all ip addresses on a name query request

     // if TRUE randomly select an IP addr on name query response rather than
     // return the address that the request came in on.
    BOOLEAN     SelectAdapter;

    // This boolean tells Nbt to attempt name resolutions with DNS
    BOOLEAN     ResolveWithDns;
    // This boolean tells Nbt not to use the cached entries for SMB device
    // if they are not resolved through DNS
    BOOLEAN     SmbDisableNetbiosNameCacheLookup;
    // Nbt tries all addresses of a multi-homed machine if this is TRUE (by default its TRUE).
    BOOLEAN     TryAllAddr;
    BOOLEAN     UseDnsOnly; // Flag to tell us not to use WINs for name Resolutions
    BOOLEAN     NoNameReleaseOnDemand; // Flag to tell us not to release any Name on demand
#ifdef MULTIPLE_WINS
    //  This boolean tells Nbt to try the list of other name servers in addition
    //  to the primary and secondary when doing name queries
    BOOLEAN     TryAllNameServers;
#endif  // MULTIPLE_WINS
    // This boolean tells Nbt to attempt name resolutions with LMhosts
    BOOLEAN     EnableLmHosts;
    // This allows a proxy to do name queries to WINS to check Bnode name
    // registrations.  By default this functionality is off since it could
    // be a RAS client who has changed its IP address and the proxy will
    // deny the new registration since it only does a query and not a
    // registration/challenge.
    //
    BOOLEAN     EnableProxyRegCheck;
    tPROXY_TYPE ProxyType;

    UCHAR       GlobalRefreshState; // Keep track of what RefreshState we are in
#ifdef VXD
    BOOLEAN     DoDNSDevolutions;
#endif  // VXD
    UCHAR       CurrProc;
    //
    // allow the refresh op code to be registry configured since UB uses
    // a different value than everyone else due to an ambiguity in the spec.
    // - we use 0x40 and they use 0x48 (8, or 9 in the RFC)
    //
    USHORT      OpRefresh;
    uint        MaxPreloadEntries;

    ULONG   MaxBackLog;
    ULONG   SpecialConnIncrement;
    ULONG   MinFreeLowerConnections;

    USHORT      DefaultSmbSessionPort;
    USHORT      DefaultSmbDatagramPort;

    ULONG           NumWorkerThreadsQueued;
    KEVENT          WorkerQLastEvent;
    ULONG           NumTimersRunning;
    KEVENT          TimerQLastEvent;
    KEVENT          WakeupTimerStartedEvent;
    tJOINTLOCK      WorkerQLock;
    LIST_ENTRY      WorkerQList;
    CTESystemTime   LastRefreshTime;
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    LONG        DhcpProcessingDelay;    // the delay (in ms) after a DHCP requests comes in
#endif
    ULONG           LoopbackIfContext;

    PWSTR           pServerBindings;
    PWSTR           pClientBindings;

    CTEULONGLONG    ServerMask;         // Bit mask of adapters on which server is currently active
    CTEULONGLONG    ClientMask;         // Bit mask of adapters on which client is currently active

    BOOLEAN     BreakOnAssert;      // To enable tests to run on checked builds
    //
    // Tdi registration / deregistration requests
    //
    BOOLEAN     Unloading;

#if DBG
    LIST_ENTRY      StaleRemoteNames;
#endif  // DBG
    //
    // Put all Debug Info at the end!
    //
#if DBG && !defined(VXD)
    // NBT's current lock level - an array entry for up to 32 processors
    ULONG       CurrentLockNumber[MAXIMUM_PROCESSORS];
    DEFINE_LOCK_STRUCTURE(DbgSpinLock)
#endif  // DBG && !defined(VXD)
} tNBTCONFIG;

extern tNBTCONFIG           *pNbtGlobConfig;
extern tNBTCONFIG           NbtConfig;
extern tNAMESTATS_INFO      NameStatsInfo;
extern tLMHSVC_REQUESTS     CheckAddr;
extern tLMHSVC_REQUESTS     DnsQueries;            // defined in parse.c
extern tLMHSVC_REQUESTS     LmHostQueries;         // defined in parse.c
extern tDOMAIN_LIST         DomainNames;
#ifndef VXD
extern tWINS_INFO           *pWinsInfo;
extern LIST_ENTRY           FreeWinsList;
#ifdef _PNP_POWER_
extern tDEVICECONTEXT       *pWinsDeviceContext;
#endif  // _PNP_POWER_
#ifdef _NETBIOSLESS
extern tDEVICECONTEXT       *pNbtSmbDevice;
#endif  // _NETBIOSLESS
extern PEPROCESS            NbtFspProcess;
#endif  // !VXD
extern ULONG                NbtMemoryAllocated;

#ifdef VXD
extern ULONG                DefaultDisconnectTimeout;
#else
extern LARGE_INTEGER        DefaultDisconnectTimeout;
#endif  // VXD
// ************** REMOVE LATER********************
extern BOOLEAN              StreamsStack;

//#if DBG
extern LIST_ENTRY           UsedTrackers;
extern LIST_ENTRY           UsedIrps;
//#endif  // DBG


#ifdef _PNP_POWER_

enum eTDI_ACTION
{
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    NBT_TDI_NOACTION,       // No delayed TDI notification for clients
    NBT_TDI_BUSY,           // The worker thread is busy in notifying the client
#endif
    NBT_TDI_REGISTER,       // Register the Device and Net Address
    NBT_TDI_DEREGISTER      // DeRegister the Net Address and Device respectively
};


#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    #define WS_DHCP_PROCESSING_DELAY        ANSI_IF_VXD("DhcpProcessingDelay")

    //
    // DHCP Processing Delay
    //
    #define MIN_DHCP_PROCESSING_DELAY               0           // millisecs
    #define DEFAULT_DHCP_PROCESSING_DELAY           75          // millisecs
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG


//
// IP, UDP, and NetBT headers copied from:
// ip.h, udp.h and types.h respectively
//
typedef struct _NETBT_WAKEUP_PATTERN_
{
    // * IP Header format *                                           ** Bit Mask **
    UCHAR           iph_verlen;         // Version and length.          **    0 **
    UCHAR           iph_tos;            // Type of service.             **    0 **
    USHORT          iph_length;         // Total length of datagram.    **   00 **
    USHORT          iph_id;             // Identification.              **   00 **
    USHORT          iph_offset;         // Flags and fragment offset.   **   00 **
                                                                    // 8 byte boundary
    UCHAR           iph_ttl;            // Time to live.                **    0 **
    UCHAR           iph_protocol;       // Protocol.                    **    1 **
    USHORT          iph_xsum;           // Header checksum.             **   00 **
    tIPADDRESS      iph_src;            // Source address.              ** 0000 **
                                                                    // 8 byte boundary
    tIPADDRESS      iph_dest;           // Destination address.         ** 0000 **

    // * UDP header *
    USHORT          udph_src;           // Source port.                 **   11 **
    USHORT          udph_dest;          // Destination port.            **   11 **
                                                                    // 8 byte boundary
    USHORT          udph_length;        // Length                       **   00 **
    USHORT          udph_xsum;          // Checksum.                    **   00 **

    // * NetBT header *
    USHORT          nbt_TransactId;     //                              **   00 **
    USHORT          nbt_OpCodeFlags;    // BCast Name Qeuries/Reg       **   01 **
                                                                    // 8 byte boundary
    UCHAR           nbt_Zero1;          //                              **    0 **
    UCHAR           nbt_QdCount;        //                              **    0 **
    UCHAR           nbt_Zero2;          //                              **    0 **
    UCHAR           nbt_AnCount;        //                              **    0 **
    UCHAR           nbt_Zero3;          //                              **    0 **
    UCHAR           nbt_NsCount;        //                              **    0 **
    UCHAR           nbt_Zero4;          //                              **    0 **
    UCHAR           nbt_ArCount;        //                              **    0 **
                                                                    // 8 byte boundary
    UCHAR           nbt_NameRR[1 + 2*NETBIOS_NAME_SIZE + 1];        //  **    1 <*> 34 **
} NETBT_WAKEUP_PATTERN, *PNETBT_WAKEUP_PATTERN;


#define NetBTPatternLen  (40 + (1+30))                              // Ignore 16th byte of name
// The mask bits are in the order of least significant to most sig!
#define NetBTPatternMask "\x00\x02\xF0\x80\x00\xFF\xFF\xFF\x7F\x00" // Extra ULONG precaution

#endif  // _PNP_POWER_

#define NBT_ALIGN(x,b)  (((x)+(b)-1) & (~((b)-1)))
#define NBT_DWORD_ALIGN(x)  NBT_ALIGN(x,4)

//
// The following structures needs to be mis-aligned and packed
//
#include <packon.h>

typedef UNALIGNED struct _TDI_ADDRESS_NETBT_INTERNAL {
    USHORT                  NameType;

    // Basically, NetBT support only two address types.
    // TDI_ADDRESS_TYPE_NETBIOS and TDI_ADDRESS_TYPE_NETBIOS_EX
    // TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX is mapped into TDI_ADDRESS_TYPE_NETBIOS_EX
    USHORT                  AddressType;

    // Don't use Rtl* routines below guys unless you're sure they are properly null-terminated!!!
    // Note: legacy NetBT address type ( may use fixed length string which is not null-terminated.
    //       The new TDI_ADDRESS_NETBIOS_UNICODE_EX address type is fully null-terminated.
    OEM_STRING              OEMEndpointName;
    OEM_STRING              OEMRemoteName;

    //
    // Point to the original UNICODE structure
    //
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pNetbiosUnicodeEX;
} TDI_ADDRESS_NETBT_INTERNAL, *PTDI_ADDRESS_NETBT_INTERNAL;

typedef UNALIGNED struct _TA_ADDRESS_NETBT_INTERNAL {
    LONG TAAddressCount;            // can only be ONE!!!
    struct _AddrNetBTInternal {
        USHORT AddressLength;       // length in bytes of this address == ??
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_NETBT_INTERNAL
        TDI_ADDRESS_NETBT_INTERNAL Address[1];
    } Address [1];
} TA_NETBT_INTERNAL_ADDRESS, *PTA_NETBT_INTERNAL_ADDRESS;
#include <packoff.h>

#endif  // _TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\inc\vxdprocs.h ===
/**********************************************************************/
/**           Microsoft Windows/NT               **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    vxdprocs.h

    This file contains VxD specific types/manifests for the NBT driver


    FILE HISTORY:
        Johnl   29-Mar-1993     Created
        MohsinA, 17-Nov-96.     Make it work on Memphis.
                                Enough confusion, added DEBUG_PRINT.

*/

#ifndef _VXDPROCS_H_
#define _VXDPROCS_H_

//--------------------------------------------------------------------
//
//  Define some ndis stuff here because tdivxd.h needs it however we can't
//  include ndis3\inc\ndis.h because it conflicts with ntconfig.h and we
//  can't take out ntconfig.h because it has definitions needed by other
//  header files...grrrr....
//

#ifdef CHICAGO
#ifndef NDIS_STDCALL
#define NDIS_STDCALL    1
#endif
#include <vmm.h>
#undef PAGE
#define PAGE _PTEXT
#endif

#ifdef NDIS_STDCALL
#define NDIS_API __stdcall
#else
#define NDIS_API
#endif

//
// Ndis Buffer
//

#define BUFFER_POOL_SIGN  (UINT)0X4C50424E  /* NBPL */
#define BUFFER_SIGN       (UINT)0x4655424e  /* NBUF */

typedef INT NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

struct _NDIS_BUFFER;
typedef struct _NDIS_BUFFER_POOL {
    UINT Signature;                     //character signature for debug "NBPL"
    NDIS_SPIN_LOCK SpinLock;            //to serialize access to the buffer pool
    struct _NDIS_BUFFER *FreeList;      //linked list of free slots in pool
    UINT BufferLength;                  //amount needed for each buffer descriptor
    UCHAR Buffer[1];                    //actual pool memory
    } NDIS_BUFFER_POOL, * PNDIS_BUFFER_POOL;

#ifdef NDIS_STDCALL
typedef struct _NDIS_BUFFER {
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
    UINT Signature;                     //character signature for debug "NBUF"
} NDIS_BUFFER, * PNDIS_BUFFER;

#else

typedef struct _NDIS_BUFFER {
    UINT Signature;                     //character signature for debug "NBUF"
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
} NDIS_BUFFER, * PNDIS_BUFFER;
#endif

#define NDIS_STATUS_SUCCESS         0   // Used by CTEinitBlockStruc macro

//
// Possible data types
//

typedef enum _NDIS_PARAMETER_TYPE {
    NdisParameterInteger,
    NdisParameterHexInteger,
    NdisParameterString,
    NdisParameterMultiString
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PUCHAR Buffer;
} STRING, *PSTRING;

typedef STRING NDIS_STRING, *PNDIS_STRING;
typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

//
// To store configuration information
//
typedef struct _NDIS_CONFIGURATION_PARAMETER {
    NDIS_PARAMETER_TYPE ParameterType;
    union {
    ULONG IntegerData;
    NDIS_STRING StringData;
    } ParameterData;
} NDIS_CONFIGURATION_PARAMETER, *PNDIS_CONFIGURATION_PARAMETER;

typedef ULONG NDIS_STATUS;
typedef NDIS_STATUS *PNDIS_STATUS;

VOID NDIS_API
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS    Status,
    OUT PNDIS_HANDLE    ConfigurationHandle,
    IN  PNDIS_STRING    ProtocolName
    );

VOID NDIS_API
NdisReadConfiguration(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_CONFIGURATION_PARAMETER *ParameterValue,
    IN NDIS_HANDLE ConfigurationHandle,
    IN PNDIS_STRING Parameter,
    IN NDIS_PARAMETER_TYPE ParameterType
    );

VOID NDIS_API
NdisCloseConfiguration(
    IN NDIS_HANDLE ConfigurationHandle
    );

//--------------------------------------------------------------------

#include <tdivxd.h>
#include <tdistat.h>

//--------------------------------------------------------------------
//
//  Initializes a TA_NETBIOS_ADDRESS structure
//
//     ptanb - Pointer to the TA_NETBIOS_ADDRESS
//     pName - Pointer to the netbios name this address structure represents
//
#define InitNBAddress( ptanb, pName )                                 \
{                                                                     \
    (ptanb)->TAAddressCount           = 1 ;                           \
    (ptanb)->Address[0].AddressLength = sizeof( TDI_ADDRESS_NETBIOS );\
    (ptanb)->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS ;    \
    (ptanb)->Address[0].Address[0].NetbiosNameType = 0 ;              \
    CTEMemCopy( (ptanb)->Address[0].Address[0].NetbiosName,           \
                pName,                                                \
                NCBNAMSZ ) ;                                          \
}

//
//  Initializes a TDI_CONNECTION_INFORMATION structure for Netbios
//
//      pConnInfo - Pointer to TDI_CONNECTION_INFORMATION structure
//      ptanb - same as for InitNBAddress
//      pName - same as for InitNBAddress
//
#define InitNBTDIConnectInfo( pConnInfo, ptanb, pName )               \
{                                                                     \
    InitNBAddress( ((PTA_NETBIOS_ADDRESS)ptanb), (pName) ) ;          \
    (pConnInfo)->RemoteAddressLength = sizeof( TA_NETBIOS_ADDRESS ) ; \
    (pConnInfo)->RemoteAddress       = (ptanb) ;                      \
}

//
//  Initializes an NDIS buffer (doesn't allocate memory)
//
//      pndisBuff - Pointer to NDIS buffer to initialize
//      pvData    - Pointer to buffer data
//      cbLen     - Length of user data (in bytes)
//      pndisBuffnext - Next NDIS buffer in chain (or NULL if last)
//
#define InitNDISBuff( pndisBuff, pvData, cbLen, pndisBuffNext )       \
{                                                                     \
    (pndisBuff)->Signature      = BUFFER_SIGN ;                       \
    (pndisBuff)->Next           = (pndisBuffNext) ;                   \
    (pndisBuff)->Length         = (cbLen) ;                           \
    (pndisBuff)->VirtualAddress = (pvData) ;                          \
    (pndisBuff)->Pool           = NULL ;                              \
}

//
//  Proper NCB error type
//
typedef uchar NCBERR ;

//
//  This is a private NCB command used for adding name number 0 to the
//  name table.  It is submitted directly by the Nbt driver during
//  initialization.  Note that if a client tries to submit an NCB with
//  this command we'll return illegal command.
//

#define NCBADD_PERMANENT_NAME       0xff

//
//  Last valid NCB session or name number
//

#define MAX_NCB_NUMS                254

//
//  When a send or receive tick count reaches this value, it's timed out
//

#define NCB_TIMED_OUT                 1

//
//  A timeout of this value means the NCB will never timeout
//

#define NCB_INFINITE_TIME_OUT         0

//--------------------------------------------------------------------
//
//  Receieve session data context, set in VxdReceive.
//  Allocated on the heap (too big for ncb_reserve).
//

#define RCVCONT_SIGN                    0x1900BEEF
typedef struct _RCV_CONTEXT
{
    union
    {
        LIST_ENTRY         ListEntry ;  // Used when NCB is put on RcvHead
        EventRcvBuffer     evrcvbuf ;   // Used for doing actual receive
                                        // (after removed from RcvHead)
    } ;
    UINT               Signature ;
    tLOWERCONNECTION * pLowerConnId ;   // Where data is arriving from
    NCB *              pNCB ;           // Pointer to NCB
    NDIS_BUFFER        ndisBuff ;       // Transport fills this buffer
    UCHAR              RTO ;            // 1/2 second ticks till timeout
    USHORT             usFlags;         // in case different from default
} RCV_CONTEXT, *PRCV_CONTEXT ;

//
//  Allocate, initialize and free a receive context structure
//

#define GetRcvContext( ppContext )                                        \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.RcvContextFreeList,       \
                       (PLIST_ENTRY*)ppContext,                           \
                       eNBT_RCV_CONTEXT ))

#define FreeRcvContext( pRcvContext )                          \
{                                                              \
    ASSERT( (pRcvContext)->Signature == RCVCONT_SIGN ) ;       \
    InsertTailList( &NbtConfig.RcvContextFreeList,             \
                    &(pRcvContext)->ListEntry ) ;              \
}

#define InitRcvContext(  pRcvCont, pRcvLowerConn, pRcvNCB ) \
{                                                        \
    pRcvCont->Signature   = RCVCONT_SIGN ;               \
    pRcvCont->pLowerConnId= pRcvLowerConn ;              \
    pRcvCont->pNCB        = pRcvNCB ;                    \
}

//--------------------------------------------------------------------
//
//  Send session data context, set in VxdSend.
//  Stored in ncb_reserve
//
typedef struct _SEND_CONTEXT
{
    LIST_ENTRY         ListEntry ;      // Kept on timeout queue
    tSESSIONHDR      * pHdr ;           // Allocated session header
    UCHAR              STO ;            // 1/2 second ticks till timeout
} SEND_CONTEXT, *PSEND_CONTEXT ;


#define GetSessionHdr( ppHdr )                                            \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.SessionBufferFreeList,    \
                                     (PLIST_ENTRY*)ppHdr,                 \
                                     eNBT_SESSION_HDR ))

#define FreeSessionHdr( pSessionHdr )                          \
{                                                              \
    InsertTailList( &NbtConfig.SessionBufferFreeList,          \
                    (PLIST_ENTRY) pSessionHdr ) ;              \
}

//--------------------------------------------------------------------
//
//  TDI Send context (used by TdiSend)
//
//  When handling the datagram completion routines, we need to set up
//  another completion routine.  We store the old completion routine
//  in this structure
//
typedef union _TDI_SEND_CONTEXT
{
    LIST_ENTRY     ListEntry ;         // Only used when on buffer free list

    struct
    {
        PVOID          NewContext ;
        NBT_COMPLETION OldRequestNotifyObject ;
        PVOID          OldContext ;
        NDIS_BUFFER    ndisHdr ;       // Generally NBT message
        NDIS_BUFFER    ndisData1 ;     // Data or SMB
        NDIS_BUFFER    ndisData2 ;     // Data if ndisData1 is an SMB
    } ;
} TDI_SEND_CONTEXT, * PTDI_SEND_CONTEXT ;

//
//  Allocates a TDI_SEND_CONTEXT
//
#define GetSendContext( ppContext )                                        \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.SendContextFreeList,       \
                       (PLIST_ENTRY*)ppContext,                            \
                       eNBT_SEND_CONTEXT ))

//
//  Frees a send context structure and its allocated memory
//
#define FreeSendContext( psendCont )                           \
{                                                              \
    InsertTailList( &NbtConfig.SendContextFreeList,            \
                    &(psendCont)->ListEntry ) ;                \
}

//--------------------------------------------------------------------
//
//  Lana related stuff
//

#define NBT_MAX_LANAS     8

typedef struct
{
    tDEVICECONTEXT * pDeviceContext ;   // Adapter for this Lana
} LANA_ENTRY, *PLANA_ENTRY ;

extern LANA_ENTRY LanaTable[NBT_MAX_LANAS] ;

//--------------------------------------------------------------------
//
//  Procedures in ncb.c
//
//
NCBERR MapTDIStatus2NCBErr( TDI_STATUS status ) ;

//
//  Get the correct adapter for this NCBs Lana
//
tDEVICECONTEXT *
GetDeviceContext(
	NCB * pNCB
	);

BOOL
NbtWouldLoopback(
	ULONG	IpAddr
	);

extern BOOL fNCBCompleted ;    // Wait NCB completed before returning to submitter
extern BOOL fWaitingForNCB ;   // We are blocked waiting for a Wait NCB to complete
extern CTEBlockStruc WaitNCBBlock ;  // Wait on this until signaled in completion
extern UCHAR LanaBase ;

#define IPINFO_BUFF_SIZE  (sizeof(IPInfo) + MAX_IP_NETS * sizeof(NetInfo))

//--------------------------------------------------------------------
//
//  externs from fileio.c
//
extern PUCHAR  pFileBuff;
extern PUCHAR  pFilePath;

//--------------------------------------------------------------------
//
//  TDI Dispatch table (exported from vtdi.386)
//
extern TDIDispatchTable * TdiDispatch ;

//
//  Wrappers for interfacing to the TDI Dispatch table
//
#define TdiVxdOpenAddress           TdiDispatch->TdiOpenAddressEntry
#define TdiVxdCloseAddress          TdiDispatch->TdiCloseAddressEntry
#define TdiVxdOpenConnection        TdiDispatch->TdiOpenConnectionEntry
#define TdiVxdCloseConnection       TdiDispatch->TdiCloseConnectionEntry
#define TdiVxdAssociateAddress      TdiDispatch->TdiAssociateAddressEntry
#define TdiVxdDisAssociateAddress   TdiDispatch->TdiDisAssociateAddressEntry
#define TdiVxdConnect               TdiDispatch->TdiConnectEntry
#define TdiVxdDisconnect            TdiDispatch->TdiDisconnectEntry
#define TdiVxdListen                TdiDispatch->TdiListenEntry
#define TdiVxdAccept                TdiDispatch->TdiAcceptEntry
#define TdiVxdReceive               TdiDispatch->TdiReceiveEntry
#define TdiVxdSend                  TdiDispatch->TdiSendEntry
#define TdiVxdSendDatagram          TdiDispatch->TdiSendDatagramEntry
#define TdiVxdReceiveDatagram       TdiDispatch->TdiReceiveDatagramEntry
#define TdiVxdSetEventHandler       TdiDispatch->TdiSetEventEntry
#define TdiVxdQueryInformationEx    TdiDispatch->TdiQueryInformationExEntry
#define TdiVxdSetInformationEx      TdiDispatch->TdiSetInformationExEntry

//--------------------------------------------------------------------
//
//  NTSTATUS to TDI_STATUS mappings.
//
//  Rather then convert from NTSTATUS to TDI_STATUS (then sometimes back to
//  NTSTATUS) we'll just use TDI_STATUS codes everywhere (and map to NCBERR
//  when returning codes to the Netbios interface).
//
#undef STATUS_SUCCESS
#undef STATUS_INSUFFICIENT_RESOURCES
#undef STATUS_ADDRESS_ALREADY_EXISTS
#undef STATUS_TOO_MANY_ADDRESSES
#undef STATUS_INVALID_ADDRESS
#undef STATUS_BUFFER_OVERFLOW
#undef STATUS_TRANSACTION_INVALID_TYPE
#undef STATUS_TRANSACTION_INVALID_ID
#undef STATUS_EVENT_DONE
#undef STATUS_TRANSACTION_TIMED_OUT
#undef STATUS_EVENT_PENDING
#undef STATUS_PENDING
#undef STATUS_BAD_NETWORK_NAME
#undef STATUS_REQUEST_NOT_ACCEPTED
#undef STATUS_INVALID_CONNECTION
#undef STATUS_DATA_NOT_ACCEPTED
#undef STATUS_MORE_PROCESSING_REQUIRED
#undef STATUS_IO_TIMEOUT
#undef STATUS_TIMEOUT
#undef STATUS_GRACEFUL_DISCONNECT
#undef STATUS_CONNECTION_RESET

#define STATUS_SUCCESS                    TDI_SUCCESS
//#define STATUS_UNSUCCESSFUL
#define STATUS_MORE_PROCESSING_REQUIRED   TDI_MORE_PROCESSING
#define STATUS_BAD_NETWORK_NAME           TDI_INVALID_CONNECTION
#define STATUS_DATA_NOT_ACCEPTED          TDI_NOT_ACCEPTED
//#define STATUS_REMOTE_NOT_LISTENING
//#define STATUS_DUPLICATE_NAME
//#define STATUS_INVALID_PARAMETER
//#define STATUS_OBJECT_NAME_COLLISION    Duplicate Name
//#define STATUS_SHARING_VIOLATION        Duplicate Name
#define STATUS_CONNECTION_INVALID         TDI_INVALID_CONNECTION
#define STATUS_INVALID_CONNECTION         TDI_INVALID_CONNECTION
#define STATUS_INSUFFICIENT_RESOURCES     TDI_NO_RESOURCES
#define STATUS_ADDRESS_ALREADY_EXISTS     TDI_ADDR_IN_USE
#define STATUS_TOO_MANY_ADDRESSES         TDI_NO_FREE_ADDR
#define STATUS_INVALID_ADDRESS            TDI_ADDR_INVALID
#define STATUS_BUFFER_OVERFLOW            TDI_BUFFER_OVERFLOW
#define STATUS_TRANSACTION_INVALID_TYPE   TDI_BAD_EVENT_TYPE
#define STATUS_TRANSACTION_INVALID_ID     TDI_BAD_OPTION     // ??
#define STATUS_EVENT_DONE                 TDI_EVENT_DONE
#define STATUS_TRANSACTION_TIMED_OUT      TDI_TIMED_OUT
#define STATUS_IO_TIMEOUT                 TDI_TIMED_OUT
#define STATUS_TIMEOUT                    TDI_TIMED_OUT
#define STATUS_EVENT_PENDING              TDI_PENDING
#define STATUS_PENDING                    TDI_PENDING
#define STATUS_GRACEFUL_DISCONNECT        TDI_GRACEFUL_DISC
#define STATUS_CONNECTION_RESET           TDI_CONNECTION_RESET
#define STATUS_INVALID_ADDRESS_COMPONENT  TDI_BAD_ADDR

//
//  This is the "Name deregistered but not deleted because of
//  active sessions" error code.
//
#define STATUS_NRC_ACTSES                 0xCA000001

//
//  The NT_SUCCESS macro looks at the high bytes of the errr code which isn't
//  appropriate for our mapping to TDI_STATUS error codes
//
#undef NT_SUCCESS
#define NT_SUCCESS(err)   ((err==TDI_SUCCESS)||(err==TDI_PENDING))

//--------------------------------------------------------------------
//
//  General porting macros
//
//
//--------------------------------------------------------------------

//
//  Note that the ExInterlocked* routines (in ntos\ex\i386) do a spinlock
//  for MP machines.  Since we aren't MP we shouldn't need the spin lock.
//  We shouldn't need to disable interrupts either.
//

#define ExInterlockedInsertTailList(list, entry, spinlock )     \
            InsertTailList( (list), (entry) )

#define ExInterlockedInsertHeadList(list, entry, spinlock )     \
            InsertHeadList( (list), (entry) )

//
//  These two definitions must be kept keep a couple of NT macros use
//  the ExInterlocked* macros
//

#ifdef InterlockedIncrement
#undef InterlockedIncrement
#endif

#ifdef InterlockedIncrementLong
#undef InterlockedIncrementLong
#endif

#define InterlockedIncrement(n)                  \
            CTEInterlockedIncrementLong( n )
#define InterlockedIncrementLong InterlockedIncrement

#ifdef InterlockedDecrement
#undef InterlockedDecrement
#endif

#ifdef InterlockedDecrementLong
#undef InterlockedDecrementLong
#endif

#define InterlockedDecrement(n)                  \
            CTEInterlockedDecrementLong( n )
#define InterlockedDecrementLong InterlockedDecrement

//--------------------------------------------------------------------
//
//  Debug helper macros
//

#undef  ASSERT
#undef  ASSERTMSG

#ifdef DEBUG
    #include <vxddebug.h>
#endif



#ifdef DBG_PRINT
//
//  Debug output Definitions and functions
//

    #define DBGFLAG_ERROR           (0x00000001)
    #define DBGFLAG_REG             (0x00000002)     // Informative Printouts
    #define DBGFLAG_ALL             (0x00000004)     // Everything else
    #define DBGFLAG_LMHOST          (0x00000008)
    #define DBGFLAG_KDPRINTS        (0x00000010)     // Jim's KdPrint output
    #define DBGFLAG_AUX_OUTPUT      (0x00000020)


    extern DWORD NbtDebug ;
    extern char  DBOut[4096] ;
    extern char  szOutput[1024];
    extern int   iCurPos ;
    extern BYTE  abVecTbl[256];

    void VxdPrintf                  ( char * pszFormat, ... );
    int  VxdSprintf                 ( char * pszStr, char * pszFmt, ... );
    void VxdDebugOutput             ( char * pszMessage );
    void NbtPrintDebug              ( char * ) ;

// ========================================================================

    #define VXD_PRINT(args)                     \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf args

    #define DEBUG_OUTPUT(x)                     \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdDebugOutput(x)

#undef KdPrint
#define KdPrint( s )                            \
   if ( NbtDebug & DBGFLAG_KDPRINTS )           \
   {                                            \
       VxdPrintf s ;                            \
   }else{}

// eg. DEBUG_PRINT(("Error %d, retry.\n", err ));
    #define DEBUG_PRINT( S )                    \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf S

// eg. PRINT_IPADDR( "Cannot find:", htonl(ipaddress) );
#define PRINT_IPADDR( S, IP )                   \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf( S "%d.%d.%d.%d\n",       \
                (IP>>0)&0xff,(IP>>8)&0xff,(IP>>16)&0xff,(IP>>24)&0xff )

// ========================================================================

#define DbgPrint( s )                           \
   if ( NbtDebug & DBGFLAG_ALL )                \
   {                                            \
      VxdSprintf( szOutput, s ) ;               \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

#define DbgPrintNum( n )                        \
   if ( NbtDebug & DBGFLAG_ALL )                \
   {                                            \
      VxdSprintf( szOutput, "%d", n ) ;         \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

// ========================================================================
//  Conditional print routines
//

#define CDbgPrint( flag, s )                    \
   if ( NbtDebug & (flag) )                     \
   {                                            \
      VxdSprintf( szOutput, s );                \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

#define CDbgPrintNum( flag, n )                 \
   if ( NbtDebug & (flag) )                     \
   {                                            \
      VxdSprintf( szOutput, "%d", n ) ;         \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

    extern void NbtCTEPrint( char * );

#else
    //
    //  No debug output.
    //

    #define IF_DEBUG(flag)                          if(0)
    #define VXD_PRINT(args)                     /* Nothing */
    #define DEBUG_OUTPUT(x)                     /* Nothing */

    #undef  KdPrint
    #define KdPrint( s )                        /* Nothing */

    #define DEBUG_PRINT( S )                    /* Nothing */
    #define PRINT_IPADDR( S, IP )               /* Nothing */

    #define DbgPrint( s )                       /* Nothing */
    #define DbgPrintNum( n )                    /* Nothing */
    #define CDbgPrint( flag, s )                /* Nothing */
    #define CDbgPrintNum( flag, n )             /* Nothing */

    #define NbtCTEPrint( s )                    /* Nothing */
#endif


#ifdef DEBUG

// ========================================================================

    #define DbgBreak()             _asm int 3
    #define ASSERT( exp )          VXD_ASSERT( exp )

    #define ASSERTMSG( msg, exp )  VXD_ASSERT( exp )

    //
    //  REQUIRE is an ASSERT that keeps the expression under non-debug
    //  builds
    //

    #define REQUIRE( exp )         ASSERT( exp )

#ifdef DBG_PRINT
    //
    //  Consistency checks of the interrupt vector table to help watch
    //  for NULL pointer writes
    //
    #define INIT_NULL_PTR_CHECK()  memcpy( abVecTbl, 0, sizeof( abVecTbl ))

    #define CHECK_MEM() if(sizeof(abVecTbl)                             \
       != VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl))){         \
    DEBUG_PRINT(("Vector table corrupt at %d\n",                        \
                 VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl) )));\
    _asm int 3                                                          \
    }else{}                                                             \
    CTECheckMem(__FILE__) ;
#else
    #define INIT_NULL_PTR_CHECK()   /* Nothing */
    #define CHECK_MEM()             /* Nothing */
#endif  // DBG_PRINT

#else

    #define DbgBreak()              /* Nothing */

    #define ASSERT( exp )           { ; }
    #define ASSERTMSG( msg, exp )   { ; }
    #define REQUIRE( exp )          { exp ; }

    #define INIT_NULL_PTR_CHECK()   /* Nothing */
    #define CHECK_MEM()             /* Nothing */
#endif

//---------------------------------------------------------------------
//
// FROM tdihndlr.c
//
TDI_STATUS
TdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Data,
    EventRcvBuffer * pevrcvbuf
    );

TDI_STATUS
ReceiveAnyHandler (                     //  Handles NCBRCVANY commands, is
    IN PVOID ReceiveEventContext,       //  called after all other receive
    IN PVOID ConnectionContext,         //  handlers
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Data,
    PVOID * ppBuffer                    // Pointer to ListEntry of RCV_CONTEXT
    ) ;

TDI_STATUS
VxdDisconnectHandler (                  //  Cleans up Netbios stuff for remote
    IN PVOID DisconnectEventContext,    //  disconnects
    IN PVOID ConnectionContext,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID pDisconnectInformation,
    IN ULONG DisconnectIndicators
    ) ;

VOID
CompletionRcv(
    IN PVOID pContext,
    IN uint tdistatus,
    IN uint BytesRcvd
    );

TDI_STATUS
TdiConnectHandler (
    IN PVOID    pConnectEventContext,
    IN int      RemoteAddressLength,
    IN PVOID    pRemoteAddress,
    IN int      UserDataLength,
    IN PVOID    pUserData,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN PVOID  * pAcceptingID,
    IN ConnectEventInfo * pEventInfo
    );

TDI_STATUS
TdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators      // Is this the Flags field?
    );

TDI_STATUS
TdiRcvDatagramHandler(
    IN PVOID    pDgramEventContext,
    IN int      SourceAddressLength,
    IN PVOID    pSourceAddress,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN UINT     ReceiveDatagramFlags,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable,
    OUT ULONG   *pBytesTaken,
    IN PVOID    pTsdu,
    OUT EventRcvBuffer * * ppBuffer //OUT PIRP    *pIoRequestPacket
    );
TDI_STATUS
TdiRcvNameSrvHandler(
    IN PVOID    pDgramEventContext,
    IN int      SourceAddressLength,
    IN PVOID    pSourceAddress,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN UINT     ReceiveDatagramFlags,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable,
    OUT ULONG   *pBytesTaken,
    IN PVOID    pTsdu,
    OUT EventRcvBuffer * * ppBuffer //OUT PIRP    *pIoRequestPacket
    );
TDI_STATUS
TdiErrorHandler (
    IN PVOID Context,
    IN ULONG Status
    );

VOID
CompletionRcvDgram(
    IN PVOID      Context,
    IN UINT       tdistatus,
    IN UINT       RcvdSize
    ) ;

//---------------------------------------------------------------------
//
// FROM init.c
//

PVOID
CTEAllocInitMem(
    IN ULONG cbBuff ) ;

NTSTATUS
VxdReadIniString(
    IN      LPTSTR   pchKeyName,
    IN OUT  LPTSTR * ppStringBuff
    ) ;

NTSTATUS CreateDeviceObject(
    IN  tNBTCONFIG  *pConfig,
    IN  ULONG        IpAddr,
    IN  ULONG        IpMask,
#ifdef MULTIPLE_WINS
    IN  PULONG       pIpNameServers,
#else
    IN  ULONG        IpNameServer,
    IN  ULONG        IpBackupServer,
#endif
    IN  ULONG        IpDnsServer,
    IN  ULONG        IpDnsBackupServer,
    IN  UCHAR        MacAddr[],
    IN  UCHAR        IpIndex
    ) ;

void GetNameServerAddress( ULONG   IpAddr,
#ifdef WINS_PER_ADAPTER
                           PULONG  pIpNameServer,
                           PNDIS_STRING AdapterName);
#else
                           PULONG  pIpNameServer);
#endif  // WINS_PER_ADAPTER

void GetDnsServerAddress( ULONG   IpAddr,
                          PULONG  pIpNameServer);

#ifdef MULTIPLE_WINS
#define COUNT_NS_ADDR     2+MAX_NUM_OTHER_NAME_SERVERS  // Maximum number of name server addresses
#else
#define COUNT_NS_ADDR     4   // Maximum number of name server addresses
#endif
//---------------------------------------------------------------------
//
// FROM vxdfile.asm
//

HANDLE
VxdFileOpen(
    IN char * pchFile ) ;

ULONG
VxdFileRead(
    IN HANDLE hFile,
    IN ULONG  BytesToRead,
    IN BYTE * pBuff ) ;

VOID
VxdFileClose(
    IN HANDLE hFile ) ;

PUCHAR
VxdWindowsPath(
    );

//---------------------------------------------------------------------
//
// FROM vnbtd.asm
//

ULONG
GetProfileHex(
    IN HANDLE ParametersHandle,     // Not used
    IN PCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

ULONG
GetProfileInt(
    IN HANDLE ParametersHandle,     // Not used
    IN PCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

TDI_STATUS DhcpQueryInfo( UINT Type, PVOID pBuff, UINT * pSize ) ;

//---------------------------------------------------------------------
//
// FROM tdiout.c
//
NTSTATUS VxdDisconnectWait( tLOWERCONNECTION * pLowerConn,
                            tDEVICECONTEXT   * pDeviceContext,
                            ULONG              Flags,
                            PVOID              Timeout) ;

NTSTATUS VxdScheduleDelayedCall( tDGRAM_SEND_TRACKING * pTracker,
                                 PVOID                  pClientContext,
                                 PVOID                  ClientCompletion,
                                 PVOID                  CallBackRoutine,
                                 tDEVICECONTEXT        *pDeviceContext,
                                 BOOLEAN                CallbackInCriticalSection );

//---------------------------------------------------------------------
//
// FROM timer.c
//
BOOL CheckForTimedoutNCBs( CTEEvent *pEvent, PVOID pCont ) ;
VOID StopTimeoutTimer( VOID );
NTSTATUS StartRefreshTimer( VOID );

//---------------------------------------------------------------------
//
// FROM tdicnct.c
//
NTSTATUS CloseAddress( HANDLE hAddress ) ;


//---------------------------------------------------------------------
//
// FROM wfw.c - Snowball specific routines
//
#ifndef CHICAGO

BOOL GetActiveLanasFromIP( VOID );

#endif //!CHICAGO


//---------------------------------------------------------------------
//
// FROM chic.c - Chicago specific routines
//
#ifdef CHICAGO

NTSTATUS DestroyDeviceObject(
    tNBTCONFIG  *pConfig,
    ULONG        IpAddr
    );

BOOL IPRegisterAddrChangeHandler( PVOID AddChangeHandler, BOOL );

TDI_STATUS IPNotification( ULONG    IpAddress,
                           ULONG    IpMask,
                           PVOID    pDevNode,
                           USHORT   IPContext,
#ifdef WINS_PER_ADAPTER
                           BOOL     fNew,
                           PNDIS_STRING AdapterName);
#else
                           BOOL     fNew);
#endif  // WINS_PER_ADAPTER

BOOL VxdInitLmHostsSupport( PUCHAR pchLmHostPath, USHORT ulPathSize );

VOID SaveNameDnsServerAddrs( VOID );
BOOL VxdOpenNdis( VOID );
VOID VxdCloseNdis( VOID );


VOID ReleaseNbtConfigMem( VOID );

NTSTATUS VxdUnload( LPSTR pchModuleName );

#endif //CHICAGO

//--------------------------------------------------------------------
//
//  Procedures in vxdisol.c
//
//
NCBERR   VxdOpenName( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCloseName( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCall( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdListen( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdDgramSend( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdDgramReceive( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdReceiveAny( tDEVICECONTEXT  *pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdReceive( tDEVICECONTEXT  * pDeviceContext, NCB * pNCB, BOOL fReceive ) ;
NCBERR   VxdHangup( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCancel( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdSend( tDEVICECONTEXT  * pDeviceContext, NCB * pNCB   ) ;
NCBERR   VxdSessionStatus( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
VOID     DelayedSessEstablish( PVOID pContext );


//--------------------------------------------------------------------
//
//  Procedures in dns.c
//
//
PCHAR
DnsStoreName(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pDomainName,
    IN  enum eNSTYPE     eNsType
    );

VOID
DnsExtractName(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PULONG           pNameSize
    );

VOID
ProcessDnsResponse(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

VOID
DnsCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

//
// These routines all have "Direct" at the end of the routine name
// because they are used exclusively for name queries to the DNS
// server to resolve DNS names and not NetBIOS names.
//

VOID
ProcessDnsResponseDirect(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

ULONG
DoDnsResolveDirect(
        PNCB pncb,
        PUCHAR pzDnsName,
        PULONG pIpAddressList
	);

BOOL
DoDnsCancelDirect(
        PNCB pncb
	);

VOID
DnsCompletionDirect(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

PDNS_DIRECT_WORK_ITEM_CONTEXT
FindContextDirect(
	USHORT	TransactionId
	);

VOID
DnsActualCompletionDirect(
    IN NBT_WORK_ITEM_CONTEXT * pnbtContext
    );

VOID
DnsUnlinkAndCompleteDirect(
    IN PDNS_DIRECT_WORK_ITEM_CONTEXT pContext
    );

NTSTATUS
UdpSendDNSBcastDirect(
	IN	PDNS_DIRECT_WORK_ITEM_CONTEXT	pContext,
	IN	ULONG							Retries,
	IN	ULONG							Timeout
	);

VOID
SendDNSBcastDoneDirect(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo
    );

PDNS_DIRECT_SEND_CONTEXT
CreateSendContextDirect(
    IN  PCHAR       pName,
    IN  PCHAR       pchDomainName,
    OUT PVOID       *pHdrs,
    OUT PULONG      pLength,
    IN  PDNS_DIRECT_WORK_ITEM_CONTEXT	pContext
    );

VOID
IpToAscii(
	IN	DWORD		IpAddress,
	IN OUT PCHAR	pzAscii
	);

//
//  Flag passed to TdiSend indicating we are dealing with a chain send
//  and not a normal send.
//
#define CHAIN_SEND_FLAG     0x80
typedef struct _tBUFFERCHAINSEND
{
    tBUFFER tBuff ;     // Must be first member of this structure!!
    PVOID   pBuffer2 ;
    ULONG   Length2 ;
} tBUFFERCHAINSEND ;


//
//  Flag for pConnectEle->Flags indicating whether the client has been
//  notified the session is dead (by completing an NCB with NRC_SCLOSED)
//
#define   NB_CLIENT_NOTIFIED    0x01


//
//  Translates the name number/logical session number to the appropriate
//  structure pointer
//
NCBERR   VxdFindClientElement( tDEVICECONTEXT * pDeviceContext,
                               UCHAR            ncbnum,
                               tCLIENTELE   * * ppClientEle,
                               enum CLIENT_TYPE Type ) ;
NCBERR   VxdFindConnectElement( tDEVICECONTEXT * pDeviceContext,
                                NCB            * pNCB,
                                tCONNECTELE  * * ppConnectEle ) ;
NCBERR   VxdFindLSN( tDEVICECONTEXT * pDeviceContext,
                     tCONNECTELE    * pConnectEle,
                     UCHAR          * plsn ) ;
NCBERR   VxdFindNameNum( tDEVICECONTEXT * pDeviceContext,
                         tADDRESSELE    * pAddressEle,
                         UCHAR          * pNum ) ;
//
//  Used by Register/Unregister for selecting either the name table or the
//  session table from the device context
//
typedef enum
{
    NB_NAME,
    NB_SESSION
} NB_TABLE_TYPE ;

BOOL NBRegister( tDEVICECONTEXT * pDeviceContext,
                 UCHAR          * pNCBNum,
                 PVOID            pElem,
                 NB_TABLE_TYPE    NbTable ) ;
BOOL NBUnregister( tDEVICECONTEXT * pDeviceContext,
                   UCHAR            NCBNum,
                   NB_TABLE_TYPE    NbTable ) ;

TDI_STATUS VxdCompleteSessionNcbs( tDEVICECONTEXT * pDeviceContext,
                                   tCONNECTELE    * pConnEle ) ;

NCBERR VxdCleanupAddress( tDEVICECONTEXT * pDeviceContext,
                          NCB            * pNCB,
                          tCLIENTELE     * pClientEle,
                          UCHAR            NameNum,
                          BOOL             fDeleteAddress ) ;

BOOL ActiveSessions( tCLIENTELE * pClientEle ) ;

//
//  This structure holds context information while we are waiting for
//  a session setup to complete (either listen or call)
//
//  It is stored in the ncb_reserve field of the NCB
//
typedef struct _SESS_SETUP_CONTEXT
{
    TDI_CONNECTION_INFORMATION * pRequestConnect ;  //
    TDI_CONNECTION_INFORMATION * pReturnConnect ;   // Name who answered the listen
    tCONNECTELE                * pConnEle ;
    UCHAR                        fIsWorldListen ;   // Listenning for '*'?
} SESS_SETUP_CONTEXT, *PSESS_SETUP_CONTEXT ;


void VxdTearDownSession( tDEVICECONTEXT      * pDevCont,
                         tCONNECTELE         * pConnEle,
                         PSESS_SETUP_CONTEXT   pCont,
                         NCB                 * pNCB ) ;

//
//  Finishes off a Netbios request (fill in NCB fields, call the post
//  routine etc.).  Is macroed as CTEIoComplete.
//

VOID
VxdIoComplete(
    PCTE_IRP pirp,
    NTSTATUS status,
    ULONG cbExtra
);

ULONG
_stdcall
VNBT_NCB_X(
    PNCB pNCB,
    PUCHAR pzDnsName,
    PULONG pIpAddress,
    PVOID pExtended,
    ULONG fFlag
);

ULONG
_stdcall
VNBT_LANA_MASK();

#endif //_VXDPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\kdext\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

#include <windef.h>

//
// The help strings printed out
//

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeULongULong,
    FieldTypeListEntry,
    FieldTypeIpAddr,
    FieldTypeMacAddr,
    FieldTypeNBName,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    USHORT           Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\nbtstat\makefile.inc ===
$(O)\nlstxt.mc: ..\..\tcpip\commands\common\common.mc localmsg.mc
    copy /a ..\..\tcpip\commands\common\common.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\nbtstat\nbtstat.c ===
/*++

Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    nbtinfo.c

Abstract:

    This module implements the statistics gathering and display for NBT.

Author:

    Jim Stewart                           November 18 22, 1993

Revision History:

    Shirish Koti   June 17, 1994    Modified to make code common between
                                    NT and VxD
    MohsinA,       06-Dec-96.       Synchronize stdout and stderr, messages.
                                    added nls_printf().
    MohsinA,       19-Mar-97.       Cleanup mutli adaptor fix (index).

Notes:

--*/

#include "nlstxt.h"
#ifdef CHICAGO_PRODUCT
#include "tdistat.h"
#endif  // CHICAGO_PRODUCT
#include "nbtstat.h"

#ifndef CHICAGO_PRODUCT
#include "nls.h"
#include "nhapi.h"
#endif  // !CHICAGO_PRODUCT

#if defined(DBG) || defined(DEBUG)
#define    DEBUG_PRINT(S) printf S
#else
#define    DEBUG_PRINT(S) /* nothing */
#endif

#if DBG
#define NT_DEBUG_PRINT(S) printf S
#else
#define NT_DEBUG_PRINT(S) /* nothing */
#endif


CHAR        pScope[MAX_NAME];

/**********************************************************************/

/*
 *  The following option combinations are possible:
 *
 *  (default)   Display active connections.
 *      -c  List NetBIOS remote name cache, showing dotted decimal ip addresses
 *      -N  List local NetBIOS names
 *      -n  List local NetBIOS names
 *      -R  Rsync Remote NetBIOS name cache
 *      -r  Names resolved via broadcast and via WINS
 *      -s  List Netbios Sessions converting IpAddresses through Hosts file
 *      -S  List Netbios Sessions with IP Addresses
 *      -RR Send Name Release packets to WINS and then, start Refresh
 *
 */


int display = CONNECTION;   /* things to display */


char        *state();
char        *type();
char        *name_type();
char        *status();
char        *expand();
int         usage(void);
char        *expand(char *stretch, int len, char *code);
char        *printable(char *string,char *strout);
BOOLEAN     IsInteger(char *string);

#define     BUFF_SIZE   650
ULONG       NumDevices = 0;
ULONG       NetbtIpAddress;

#ifndef CHICAGO_PRODUCT
CHAR        pDeviceInfo[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];
#else
ULONG       pDeviceInfo[NBT_MAXIMUM_BINDINGS+1] = {0};

#define VNBT_Device_ID      0x049B
HANDLE  gNbtVxdHandle;
#endif  // !CHICAGO_PRODUCT


#define dim(X) (sizeof(X)/sizeof((X)[0]))

LPSTR MapAdapterGuidToName(LPSTR AdapterNameM)
{
    static CHAR     AdapterFriendlyNameM[MAX_NAME + 1];
    ULONG           i;
    LPSTR           AdapterGuidM;
    GUID            Guid;
    UNICODE_STRING  AdapterGuidU;
    WCHAR           AdapterGuidW[MAX_NAME+1];
    WCHAR           AdapterFriendlyNameW[MAX_NAME+1];
    DWORD           Size = dim(AdapterFriendlyNameW);

    //
    //  Get the GUID out of the device name string
    //
    for (i = strlen(AdapterNameM); i != 0; i--)
    {
        if (AdapterNameM[i] == '{')
        {
            break;
        }
    }
    if (i == 0)
    {
        return AdapterNameM;
    }

    AdapterGuidM = &AdapterNameM[i];
    i = MultiByteToWideChar (CP_ACP, 0, AdapterGuidM, -1, AdapterGuidW, dim(AdapterGuidW));
    if (i <= 0)
    {
        return AdapterNameM;
    }

    RtlInitUnicodeString (&AdapterGuidU, AdapterGuidW);
    if (STATUS_SUCCESS != RtlGUIDFromString (&AdapterGuidU, &Guid))
    {
        return AdapterNameM;
    }

    if (NO_ERROR != NhGetInterfaceNameFromDeviceGuid (&Guid, AdapterFriendlyNameW, &Size, FALSE, TRUE))
    {
        return AdapterNameM;
    }

    WideCharToMultiByte (CP_ACP, 0, AdapterFriendlyNameW, -1, AdapterFriendlyNameM, sizeof(AdapterFriendlyNameM), NULL,NULL);

    return (AdapterFriendlyNameM);
}

// ========================================================================
#define LEN_DbgPrint 1000

void
nls_printf(
    char * format,
    ...
    )
{
    va_list ap;
    char    message[LEN_DbgPrint];
    int     message_len;

    va_start( ap, format );
    message_len = vsprintf( message, format, ap );
    va_end( ap );
    assert( message_len < LEN_DbgPrint );

    NlsPutMsg( STDOUT, IDS_PLAIN_STRING, message );
}

/*****************************  M A I N  ******************************/
__cdecl
main( int argc, char * argv[] )
{


    NTSTATUS    status;
    LONG        interval=-1;
    UCHAR       RemoteName[50];
    CHAR        HostAddr[20];
    PUCHAR      Addr;
    HANDLE      NbtHandle = 0;
    ULONG       index;

    DEBUG_PRINT(("FILE %s\nBuilt on %s at %s\n", __FILE__, __DATE__, __TIME__));

    //
    //  Process arguments to determine which statistics to gather.
    //  Optional parameter is interval between statistics updates.
    //  Default is to display statistics once only.
    //
    if (argc == 1)
    {
        exit(usage());
    }

    display = 0;
    while (--argc, *++argv)
    {
        if ((argv[0][0] == '-') || (argv[0][0] == '/'))     // process option string
        {
            register char   c, *p = *argv+1;
            int             arg_exhausted = 0;

            if (*p == '\0')
            {
                exit(usage());
            }

            //
            //  Loop along this set of flags.
            //
            while (!arg_exhausted && (c = *p++))
            {
                switch (c)
                {
                    case 'a':
                    case 'A':
                        display = ADAPTERSTATUS;

                        //
                        // "A" - this means the user has given us an IP address
                        // rather than a name to do an adapter status to.
                        //
                        if (c == 'A')
                        {
                            display = ADAPTERSTATUSIP;
                        }

                        RemoteName[0] = '\0';
                        if (--argc)
                        {
                            *++argv;
                            p = *argv;

                            if ((p) && (*p) && (strlen(p) < sizeof(RemoteName)))
                            {
                                strcpy(RemoteName,p);
                            }
                            else
                            {
                                DEBUG_PRINT(("invalid name or ip address\n"));
                                exit(usage());
                            }
                            arg_exhausted = TRUE;
                        }
                        else
                        {
                            DEBUG_PRINT(("Need name or ip address\n"));
                        }
                        break;

                    case 'c':
                        display = CACHE;
                        break;

                    case 'n':
                    case 'N':
                        display = NAMES;
                        break;

                    case 'r':
                        display = BCAST;

                        break;

                    case 'R':
                        if (*p == 'R')
                        {
                            p++;
                            display = NAME_RELEASE_REFRESH;
                        }
                        else
                        {
                            display = RESYNC;
                        }
                        break;

                    case 's':
                        display = CONNECTION;
                        break;

                    case 'S':
                        display = CONNECTION_WITH_IP;
                        break;

                    default:    /* unrecognized flag */
                        DEBUG_PRINT(("Unrecognized flag %s\n", argv[0] ));
                        exit(usage());
                }
            }
        }
        else if (IsInteger(*argv))
        {
            interval = (int) atoi( * argv );
        }
        else
        {
            DEBUG_PRINT(("invalid time interval\n"));
            exit(usage());
        }
    }   // while (argc ...)

    if ( display == 0 )
    {
        DEBUG_PRINT(("nothing to display?\n"));
        exit(usage());
    }

    // ====================================================================

    //
    // Get the list of interfaces to which NetBT is currently bound
    //
    status = GetInterfaceList ();
    if (!NT_SUCCESS(status))
    {
        NlsPutMsg(STDERR, IDS_FAILURE_NBT_DRIVER);
        exit(1);
    }

    if (0 == NumDevices)
    {
        NlsPutMsg(STDERR, IDS_FAILED_NBT_NO_DEVICES);
        exit(1);
    }

    //
    //  Loop forever, sleeping for "interval" seconds between cycles.
    //  If (interval < 0), return after one cycle.
    //
    //  Note that we're nice boys who close all devices while we're
    //  sleeping (after all, it is possible to say "netstat 5000"!).
    //  This probably doesn't help much, but it's a nice gesture...
    //
    do
    {
        for (index=0; index < NumDevices; index++)
        {
            //
            //  Open the device of the appropriate streams module to start with.
            //
            NbtHandle = OpenNbt (index);
            if (NbtHandle < 0)
            {
                if (!(display & (BCAST | RESYNC)))
                {
#ifndef CHICAGO_PRODUCT
                    nls_printf ("\tFailed to access NBT Device %s",
                             MapAdapterGuidToName (pDeviceInfo[index]));
#else
                    nls_printf ("\tFailed to access NBT Device, Lana # %d",
                             NbtHandle);
#endif  // CHICAGO_PRODUCT
                }

                //
                // Try the next binding!
                //
                continue;
            }

            GetIpAddress (NbtHandle,&NetbtIpAddress);
            Addr = (PUCHAR) &NetbtIpAddress;
            //
            // print out the Device name + Ip Address of this node
            //
            if (!(display & (BCAST | RESYNC | NAME_RELEASE_REFRESH)))
            {
#ifndef CHICAGO_PRODUCT
                nls_printf ("\n%s:\n", MapAdapterGuidToName (pDeviceInfo[index]));
#else
                nls_printf ("\nLana # %d:\n", pDeviceInfo[index]);
#endif  // CHICAGO_PRODUCT
                sprintf(HostAddr,"%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
                NlsPutMsg(STDOUT, IDS_STATUS_FIELDS, HostAddr, pScope);
            }

            switch (display)
            {
                case ADAPTERSTATUS:
                case ADAPTERSTATUSIP:

                    if (RemoteName[0] == '\0')
                    {
                        usage();
                        interval = -1;
                    }
                    else
                    {
                        status = AdapterStatusIpAddr (NbtHandle, RemoteName, display);
                    }

                    break;

                case BCAST:
                    status = GetBcastResolvedNames (NbtHandle);
                    break;

                case CACHE:
                case NAMES:
                    status = GetNames(NbtHandle, display);
                    break;

                case RESYNC:
                    status = Resync (NbtHandle);
                    break;

                case NAME_RELEASE_REFRESH:
                    status = ReleaseNamesThenRefresh (NbtHandle);
                    break;

                case CONNECTION:
                case CONNECTION_WITH_IP:

                    status = GetConnections (NbtHandle,display);
                    break;

                default:
                    usage();
                    interval = -1;

                    break;

            }   // switch

#ifndef CHICAGO_PRODUCT
            NtClose (NbtHandle);       // Close everything while we sleep.
#endif

            if (display & (BCAST | RESYNC | NAME_RELEASE_REFRESH))
            {
                if (NT_SUCCESS (status))
                {
                        break;               // break only for the case(s) above
                }
            }
        }   // for (index ...)


        //
        //  Go to sleep for the appropriate interval until the
        //  next round, or exit if this is a once-only job.
        //
        if (interval > 0)
        {
            Sleep (interval*1000);    // ms.
        }
    } while (interval > 0);

#ifdef CHICAGO_PRODUCT
    if (!CloseHandle (gNbtVxdHandle))
    {
        DEBUG_PRINT(("CloseHandle FAILed:  Handle=<%x>, Error=<%x>\n", gNbtVxdHandle, GetLastError()));
    }
#endif  // CHICAGO_PRODUCT

    return 0;
}

/*  =======================================================================
 *  IsInteger
 *
 *  ENTRY Parameter   - pointer to string
 *
 *  EXIT
 *
 *  RETURNS TRUE if Parameter is a valid integer
 *
 *  ASSUMES
 *
 */

BOOLEAN
IsInteger(
    char *Parameter
    )
{
    while (*Parameter != '\0')
    {
        if ((*Parameter < '0') || (*Parameter > '9'))
        {
            return (FALSE);
        }

        Parameter++;
    }

    return (TRUE);
}

/*  =======================================================================
 *  name_type()     --  describe NBT Name types
 *
 */

char *
name_type(int t)
{
    static int  first_time = 1;
    static char group[32];
    static char unique[32];

    if (first_time) {
        first_time = 0;
        NlsSPrintf(IDS_NAMETYPE_GROUP, group, sizeof(group)-1);
        NlsSPrintf(IDS_NAMETYPE_UNIQUE, unique, sizeof(unique)-1);
    }

    if (t & GROUP_NAME)    return group;
    else                   return unique;
}

/* ========================================================================
 *  NameStatus()        --  describe NBT Name status
 *
 */

char *
NameStatus(int s)
{
    switch(s & 0x0F)
    {
        case DUPLICATE_DEREG:   return("CONFLICT DEREGISTERED");
        case DUPLICATE:         return("CONFLICT");
        case REGISTERING:       return("REGISTERING");
        case DEREGISTERED:      return("DEREGISTERED");
        case REGISTERED:        return("REGISTERED");
        default:                return("?");
    }
}


/* ========================================================================
 *  usage()     --  print out a standard usage message
 */

int
usage(void)
{
    //fprintf(stderr, "%s", args);
    NlsPutMsg(STDERR, IDS_USAGE);
    return(2);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/

PCHAR
printable(
    IN PCHAR  string,
    IN PCHAR  StrOut
    )
{
    unsigned char *Out;
    unsigned char *cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++)
    {
        if (isprint(*cp))
        {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) // extended characters are ok
        {
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }

    //
    // Convert to Ansi since NlsPutMsg will convert back to Oem
    // Bug # 170935
    //
    OemToCharBuffA(StrOut, StrOut, NETBIOS_NAME_SIZE);
    return(StrOut);
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

--*/



NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )
{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;

    status = CALL_DRIVER(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (STATUS_SUCCESS == status)
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);
    return(status);
}


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.
    It either prints out the local name table or the remote (cache) table
    depending on whether WhichNames is NAMES or CACHE .

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetNames(
    IN HANDLE   fd,
    IN LONG     WhichNames
    )
{
    LONG                            Count;
    PVOID                           pBuffer;
    ULONG                           BufferSize=600;
    NTSTATUS                        status;
    tADAPTERSTATUS                  *pAdapterStatus;
    PUCHAR                          Addr;
    ULONG                           Ioctl;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    PVOID                           pInput;
    ULONG                           SizeInput;
    NAME_BUFFER UNALIGNED           *pNames;
    CHAR                            HostAddr[20];
    CHAR                            NameOut[NETBIOS_NAME_SIZE +4];


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;

    //
    // set the correct Ioctl for the call to NBT, to get either
    // the local name table or the remote name table
    //
    if (WhichNames == NAMES)
    {
#ifndef CHICAGO_PRODUCT
        Ioctl = IOCTL_TDI_QUERY_INFORMATION;
#else
        Ioctl = IOCTL_NETBT_GET_LOCAL_NAMES;
#endif
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
        pInput = &QueryInfo;
    }
    else
    {
        Ioctl = IOCTL_NETBT_GET_REMOTE_NAMES;
        SizeInput = 0;
        pInput = NULL;
    }

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             Ioctl,
                             pInput,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0xFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pBuffer);
        NlsPutMsg(STDOUT,IDS_NONAMES_INCACHE);
        return(status);
    }

    if (WhichNames & NAMES)
    {
        NlsPutMsg(STDOUT, IDS_NETBIOS_LOCAL_STATUS);
    }
    else
    {
        NlsPutMsg(STDOUT, IDS_NETBIOS_REMOTE_STATUS);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;
    while(Count--)
    {
        nls_printf("%-15.15s<%02.2X>  %-10s  ",
            printable(pNames->name,NameOut), pNames->name[NETBIOS_NAME_SIZE-1],name_type(pNames->name_flags));

        if (WhichNames == CACHE)
        {
            Addr = (PUCHAR) &((tREMOTE_CACHE *)pNames)->IpAddress;
            sprintf (HostAddr,"%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
            nls_printf("%-20.20s" "%-d", HostAddr, *(ULONG UNALIGNED *) &((tREMOTE_CACHE *)pNames)->Ttl);

            ((tREMOTE_CACHE *)pNames)++;
        }
        else
        {
            switch(pNames->name_flags & 0x0F)
            {
                case DUPLICATE_DEREG:
                   NlsPutMsg(STDOUT,IDS_CONFLICT_DEREGISTERED);
                   break;
                case DUPLICATE:
                   NlsPutMsg(STDOUT,IDS_CONFLICT);
                   break;
                case REGISTERING:
                   NlsPutMsg(STDOUT,IDS_REGISTERING);
                   break;
                case DEREGISTERED:
                   NlsPutMsg(STDOUT,IDS_DEREGISTERED);
                   break;
                case REGISTERED:
                   NlsPutMsg(STDOUT,IDS_REGISTERED);
                   break;
                default:
                   NlsPutMsg(STDOUT,IDS_DONT_KNOW);
            }

            pNames++;
        }

        NlsPutMsg(STDOUT, IDS_NEWLINE );
    }

    LocalFree(pBuffer);
    return(status);
}

//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure does an adapter status query to get the remote name table.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
AdapterStatusIpAddr(
    IN HANDLE   fd,
    IN PCHAR    RemoteNameA,
    IN LONG     Display
    )
{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    OEM_STRING                  OemName;
    WCHAR                       RemoteNameW[256];
    UCHAR                       RemoteNameOem[256];
    UNICODE_STRING              RemoteNameU;
    USHORT                      NameLength;
    PUCHAR                      pRemoteName = NULL;

    if (!NetbtIpAddress)
    {
        NlsPutMsg(STDOUT,IDS_MACHINE_NOT_FOUND);
        return(STATUS_BAD_NETWORK_PATH);
    }

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;
    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));
    if (Display == ADAPTERSTATUSIP)
    {
        //
        // Convert the remote name which is really a dotted decimal ip address
        // into a ulong
        //
        IpAddress = inet_addr(RemoteNameA);
        //
        // Don't allow zero for the address since it sends a broadcast and
        // every one responds
        //
        if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
        {
            NlsPutMsg(STDOUT, IDS_BAD_IPADDRESS, RemoteNameA);
            LocalFree(pBuffer);
            LocalFree(pIpAndNameInfo);
            return(STATUS_UNSUCCESSFUL);
        }
        pIpAndNameInfo->IpAddress = ntohl(IpAddress);

        pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
    }
    else
    {
        //
        // the remote name was supplied by the user, so blank pad to the
        // right and put a zero on the end to get the workstation name.
        //
        RtlFillMemory(&pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0],
                      NETBIOS_NAME_SIZE, ' ');
        NameLength = (USHORT)strlen(RemoteNameA);

#ifndef CHICAGO_PRODUCT
        //
        // Convert the name from ANSI to UpperCase OEM (max length = NETBIOS_NAME_SIZE)
        // Bug # 409792
        //
        MultiByteToWideChar (CP_ACP, 0, RemoteNameA, -1, RemoteNameW, 256);
        RemoteNameW[255] = UNICODE_NULL;  // for safety
        RtlInitUnicodeString (&RemoteNameU, RemoteNameW);
        OemName.MaximumLength = 255;
        OemName.Buffer        = RemoteNameOem;
        status = RtlUpcaseUnicodeStringToOemString (&OemName, &RemoteNameU, FALSE);
        if (NT_SUCCESS (status))
        {
            status = STATUS_BUFFER_OVERFLOW;
        }
        NameLength = min (OemName.Length, NETBIOS_NAME_SIZE);
        pRemoteName = RemoteNameOem;
#else
        //
        // Chicago does not appear to have Unicode support ?
        //
        for (i=0;i < (LONG) NameLength; i++)
        {
            RemoteNameA[i] = toupper (RemoteNameA[i]);
        }

        NameLength = min (NameLength, NETBIOS_NAME_SIZE);
        pRemoteName = RemoteNameA;
#endif  // !CHICAGO_PRODUCT

        RtlMoveMemory(&pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0],
                      pRemoteName,
                      NameLength);

        pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE-1] = 0;
    }

    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {

        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0xFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                LocalFree(pIpAndNameInfo);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((status != STATUS_SUCCESS) ||
        (pAdapterStatus->AdapterInfo.name_count == 0))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);
        NlsPutMsg(STDOUT,IDS_MACHINE_NOT_FOUND);
        return(status);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;


    //
    // put out a heading for the table of names
    //
    NlsPutMsg(STDOUT, IDS_REMOTE_NAMES);

    while(Count--)
    {
        CHAR    NameOut[NETBIOS_NAME_SIZE +4];

        nls_printf("%-15.15s<%02.2X>  %-10s  ",
                   printable(pNames->name,NameOut),
                   pNames->name[NETBIOS_NAME_SIZE-1],
                   name_type(pNames->name_flags)
        );


        switch(pNames->name_flags & 0x0F)
        {
        case DUPLICATE_DEREG:
           NlsPutMsg(STDOUT,IDS_CONFLICT_DEREGISTERED);
           break;
        case DUPLICATE:
           NlsPutMsg(STDOUT,IDS_CONFLICT);
           break;
        case REGISTERING:
           NlsPutMsg(STDOUT,IDS_REGISTERING);
           break;
        case DEREGISTERED:
           NlsPutMsg(STDOUT,IDS_DEREGISTERED);
           break;
        case REGISTERED:
           NlsPutMsg(STDOUT,IDS_REGISTERED);
           break;
        default:
           NlsPutMsg(STDOUT,IDS_DONT_KNOW);
        }
        pNames++;

        NlsPutMsg(STDOUT, IDS_NEWLINE );
    }

    //
    // Dump the MAC address
    //
    {
        PUCHAR   a;

        a = &pAdapterStatus->AdapterInfo.adapter_address[0];
        sprintf(MacAddress,"%02.2X-%02.2X-%02.2X-%02.2X-%02.2X-%02.2X",
                    a[0],a[1],a[2],a[3],a[4],a[5]);
    }

    NlsPutMsg(STDOUT, IDS_MAC_ADDRESS, MacAddress);

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);
    return(status);
}

//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure does gets the connection information from NBT.  If the
    Display value indicates CONNECTION_WITH_IP, then only the ip address
    of the destination is diplayed, otherwise the name of the destination
    host is displayed.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetConnections(
    IN HANDLE   fd,
    IN LONG     Display
    )
{
    LONG                        Count;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tCONNECTION_LIST            *pConList;
    tCONNECTIONS UNALIGNED      *pConns;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;
    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_GET_CONNECTIONS,
                             NULL,
                             0);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0xFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pConList = (tCONNECTION_LIST *)pBuffer;
    if ((status != STATUS_SUCCESS) ||
        ((Count = pConList->ConnectionCount) == 0) )
    {
        // printf(" ntstatus = %X\n",status);
        NlsPutMsg(STDOUT,IDS_NO_CONNECTIONS);

        LocalFree(pBuffer);
        return(status);
    }

    pConns = pConList->ConnList;
    //
    // put out a heading for the table of names
    //
    NlsPutMsg(STDOUT, IDS_NETBIOS_CONNECTION_STATUS);

    while(Count--)
    {
        CHAR    NameOut[NETBIOS_NAME_SIZE +4];

        if (pConns->LocalName[0])
        {
            if (pConns->LocalName[NETBIOS_NAME_SIZE-1] < ' ')
            {
                nls_printf("%-15.15s<%02.2X>  ",
                           printable(pConns->LocalName,NameOut),
                           pConns->LocalName[NETBIOS_NAME_SIZE-1]);

            }
            else
            {
                nls_printf("%-16.16s     ", printable(pConns->LocalName,NameOut));
            }

        }

        switch (*(ULONG UNALIGNED *) &pConns->State)
        {
        case NBT_RECONNECTING:
            NlsPutMsg(STDOUT,IDS_RECONNECTING);
            break;
        case NBT_IDLE:
            NlsPutMsg(STDOUT,IDS_IDLE);
            break;
        case NBT_ASSOCIATED:
            NlsPutMsg(STDOUT,IDS_ASSOCIATED);
            break;
        case NBT_CONNECTING:
            NlsPutMsg(STDOUT,IDS_CONNECTING);
            break;
        case NBT_SESSION_OUTBOUND:
            NlsPutMsg(STDOUT,IDS_OUTGOING);
            break;
        case NBT_SESSION_INBOUND:
            NlsPutMsg(STDOUT,IDS_INCOMING);
            break;
        case NBT_SESSION_WAITACCEPT:
            NlsPutMsg(STDOUT,IDS_ACCEPTING);
            break;
        case NBT_SESSION_UP:
            NlsPutMsg(STDOUT,IDS_CONNECTED);
            break;
        case NBT_DISCONNECTING:
            NlsPutMsg(STDOUT,IDS_DISCONNECTING);
            break;
        case NBT_DISCONNECTED:
            NlsPutMsg(STDOUT,IDS_DISCONNECTED);
            break;
        case LISTENING:
            NlsPutMsg(STDOUT,IDS_LISTENING);

            break;

        case UNBOUND:
        default:
            NlsPutMsg(STDOUT,IDS_UNBOUND);
            break;
        }

        if (*(ULONG UNALIGNED *) &pConns->SrcIpAddr)
        {

            if (pConns->Originator)
            {
                NlsPutMsg(STDOUT,IDS_NETBIOS_OUTBOUND);
            }
            else
            {
                NlsPutMsg(STDOUT,IDS_NETBIOS_INBOUND);
            }

            //
            // either display the IP address or the Remote host name
            //
            if (Display & CONNECTION_WITH_IP)
            {
                PUCHAR   in;
                UCHAR    AddrBuff[30];

                in = (PUCHAR)&pConns->SrcIpAddr;

                sprintf(AddrBuff,"%u.%u.%u.%u", (unsigned char) in[0],
                    (unsigned char) in[1], (unsigned char) in[2],
                        (unsigned char) in[3]);
                nls_printf("   %-19.19s",AddrBuff);

            }
            else
            {
                nls_printf("   %-15.15s<%02.2X>",
                           printable(pConns->RemoteName,NameOut),
                           pConns->RemoteName[NETBIOS_NAME_SIZE-1]);
            }

            PrintKorM ((PVOID) &pConns->BytesRcvd);
            PrintKorM ((PVOID) &pConns->BytesSent);
        }
        else
        {
            nls_printf("                         ");

        }


        NlsPutMsg(STDOUT, IDS_NEWLINE );
        pConns++;
    }

    LocalFree(pBuffer);
    return(status);

}

//------------------------------------------------------------------------
/*++

  Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

  Arguments:


  Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
Resync(
    IN HANDLE   fd
    )
{
    NTSTATUS    status;
    CHAR        Buffer;

    status = CALL_DRIVER(fd,
                         &Buffer,
                         1,
                         IOCTL_NETBT_PURGE_CACHE,
                         NULL,
                         0);

    if (status == STATUS_SUCCESS)
    {
        NlsPutMsg(STDOUT,IDS_RESYNC_OK);
    }
    else
    {
        NlsPutMsg(STDOUT,IDS_RESYNC_FAILED);
    }
    return(status);
}

//-----------------------------------------------------------------------
/*++

  Routine Description:

    This procedure tells NBT to release all of its names on this Device and
    then Refresh them.

  Arguments:


  Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
ReleaseNamesThenRefresh(
    IN HANDLE   fd
    )
{
    NTSTATUS    status;
    CHAR        Buffer;

    status = CALL_DRIVER(fd,
                         &Buffer,
                         1,
                         IOCTL_NETBT_NAME_RELEASE_REFRESH,
                         NULL,
                         0);

    if (STATUS_SUCCESS == status)
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_OK);
    }
    else if (status == STATUS_IO_TIMEOUT)
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_TIMEOUT);
        status = STATUS_SUCCESS;
    }
    else
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_ERROR);
    }

    return(status);
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetBcastResolvedNames(
    IN HANDLE   fd
    )
{
    NTSTATUS        status;
    tNAMESTATS_INFO Stats;
    tNAME           *pName;
    LONG            Count;
    UCHAR           Value[60];

    status = CALL_DRIVER(fd,
                         &Stats,
                         sizeof(tNAMESTATS_INFO),
                         IOCTL_NETBT_GET_BCAST_NAMES,
                         NULL,
                         0);

    if (status != STATUS_SUCCESS)
    {
        NlsPutMsg(STDOUT,IDS_BCASTNAMES_FAILED);
        return(status);
    }

    NlsPutMsg(STDOUT,IDS_NAME_STATS);

    // name query stats
    sprintf(Value,"%d",Stats.Stats[0]);
    NlsPutMsg(STDOUT,IDS_NUM_BCAST_QUERIES,Value);
    sprintf(Value,"%d",Stats.Stats[2]);
    NlsPutMsg(STDOUT,IDS_NUM_WINS_QUERIES,Value);

    // Name Registration stats
    sprintf(Value,"%d",Stats.Stats[1]);
    NlsPutMsg(STDOUT,IDS_NUM_BCAST_REGISTRATIONS,Value);
    sprintf(Value,"%d",Stats.Stats[3]);
    NlsPutMsg(STDOUT,IDS_NUM_WINS_REGISTRATIONS,Value);


    pName = Stats.NamesReslvdByBcast;
    Count = 0;

    // if there are no names, then return.
    if (pName->Name[0] == '\0')
    {
        return(STATUS_SUCCESS);
    }

    NlsPutMsg(STDOUT,IDS_BCAST_NAMES_HEADER);

    while ((Count < SIZE_RESOLVD_BY_BCAST_CACHE) && (pName->Name[0] != '\0'))
    {

        // if the last character is not a space then print it in hex
        //
        if (pName->Name[NETBIOS_NAME_SIZE-1] != ' ')
        {
            nls_printf("       %15.15s<%02.2X>\n",
                   pName->Name,
                   pName->Name[NETBIOS_NAME_SIZE-1]);

        }
        else
        {
            nls_printf("       %16.16s\n",pName->Name);

        }


        pName++;
        Count++;
    }
    return(status);
}

//
// @@@@@@@@@@------ Begin NT-specific routines ------@@@@@@@@@@@
//

#ifndef CHICAGO_PRODUCT
//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList(
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms="system\\currentcontrolset\\services\\netbt\\parameters";
    HKEY    Key;
    LONG    Type;
    ULONG   size;
    CHAR    pScopeBuffer[BUFF_SIZE];
    PUCHAR  Scope="ScopeId";

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize=10*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;
    ULONG                   index=0;
    LONG                    i;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | GENERIC_EXECUTE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (!NT_SUCCESS (status))
    {
        LocalFree(pInterfaceInfo);
        return (status);
    }

    do
    {
        status = CALL_DRIVER (StreamHandle,
                              pInterfaceInfo,
                              InterfaceInfoSize,
                              IOCTL_NETBT_GET_INTERFACE_INFO,
                              pInput,
                              SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pInterfaceInfo);

            InterfaceInfoSize *=2;
            if ((InterfaceInfoSize >= 0xFFFF) ||
                (!(pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize))))
            {
                NtClose(StreamHandle);
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        else if (STATUS_SUCCESS != status)
        {
            LocalFree(pInterfaceInfo);
            NtClose(StreamHandle);
            return(status);
        }

    } while (status == STATUS_BUFFER_OVERFLOW);
    NtClose (StreamHandle);

    for (i=0; i<pInterfaceInfo->NumAdapters; i++)
    {
        RtlInitString(&name_string, NULL);
        RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
        if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
        {
            size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

            strncpy(pDeviceInfo[index], name_string.Buffer, size);
            pDeviceInfo[index][size] = '\0';
            RtlFreeAnsiString (&name_string);

            index++;
        }
    }

    LocalFree(pInterfaceInfo);

    //
    // NULL out the next device string ptr
    //
    if (index < NBT_MAXIMUM_BINDINGS)
    {
        pDeviceInfo[index][0] = '\0';
    }

    NumDevices = index;

    //
    // Read the ScopeId key!
    //
    size = BUFF_SIZE;
    *pScope = '\0';     // By default
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 SubKeyParms,
                 0,
                 KEY_READ,
                 &Key);

    if (status == ERROR_SUCCESS)
    {
        // now read the Scope key
        status = RegQueryValueEx(Key, Scope, NULL, &Type, pScopeBuffer, &size);
        if (status == ERROR_SUCCESS)
        {
            strcpy(pScope,pScopeBuffer);
        }
        status = RegCloseKey(Key);
    }

    return (STATUS_SUCCESS);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/



HANDLE
OpenNbt(
    IN  ULONG   Index
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;

    assert (Index < NBT_MAXIMUM_BINDINGS);

    if (pDeviceInfo[Index][0] == '\0')
    {
        return ((HANDLE) -1);
    }

    RtlInitString (&name_string, pDeviceInfo[Index]);
    RtlAnsiStringToUnicodeString (&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes (&ObjectAttributes,
                                &uc_name_string,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | GENERIC_EXECUTE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString (&uc_name_string);

    if (!NT_SUCCESS(status))
    {
        StreamHandle = (HANDLE) -1;
    }

    return (StreamHandle);
} // OpenNbt


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )
{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;

    status = NtDeviceIoControlFile (fd,                      // Handle
                                    NULL,                    // Event
                                    NULL,                    // ApcRoutine
                                    NULL,                    // ApcContext
                                    &iosb,                   // IoStatusBlock
                                    Ioctl,                   // IoControlCode
                                    pInput,                  // InputBuffer
                                    SizeInput,               // InputBufferSize
                                    (PVOID) ReturnBuffer,    // OutputBuffer
                                    BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject (fd,                         // Handle
                                        TRUE,                       // Alertable
                                        NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts to KBytes or Mbytes

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


VOID
PrintKorM(
    IN PVOID    pBytesIn
    )
{
    LARGE_INTEGER   BytesIn = *(LARGE_INTEGER UNALIGNED *) pBytesIn;
    LARGE_INTEGER   Bytes;

    if (BytesIn.QuadPart > (ULONGLONG)1000)
    {
        Bytes = RtlExtendedLargeIntegerDivide(BytesIn,1000,NULL);
        if (Bytes.QuadPart > (ULONGLONG)1000)
        {
            Bytes = RtlExtendedLargeIntegerDivide(Bytes,1000,NULL);
            if (Bytes.QuadPart > (ULONGLONG)1000)
            {
                Bytes = RtlExtendedLargeIntegerDivide(Bytes,1000,NULL);

                nls_printf("%6dGB ",Bytes.LowPart);
            }
            else
            {
                nls_printf("%6dMB ",Bytes.LowPart);
            }
        }
        else
        {
            nls_printf("%6dKB ",Bytes.LowPart);
        }
    }
    else
    {
        nls_printf("%6dB  ",BytesIn.LowPart);
    }

}

#else

//
// @@@@@@@@@@------ Begin CHICAGO-specific routines ------@@@@@@@@@@@
//

/*******************************************************************

    NAME:       OsOpenVxdHandle

    SYNOPSIS:   Opens a handle to the specified VxD.

    ENTRY:      VxdName - The ASCII name of the target VxD.

                VxdId - The unique ID of the target VxD.

    RETURNS:    DWORD - A handle to the target VxD if successful,
                    0 if not.

    HISTORY:
        KeithMo     16-Jan-1994 Created.
        DavidKa     18-Apr-1994 Dynamic load.

********************************************************************/
HANDLE
OsOpenVxdHandle(
    CHAR * VxdName,
    WORD   VxdId
    )
{
    HANDLE  VxdHandle;
    CHAR    VxdPath[260];

    //
    //  Build the VxD path.
    //
    lstrcpy( VxdPath, "\\\\.\\");
    lstrcat( VxdPath, VxdName);

    //
    //  Open the device.
    //
    //  First try the name without the .VXD extension.  This will
    //  cause CreateFile to connect with the VxD if it is already
    //  loaded (CreateFile will not load the VxD in this case).
    //
    VxdHandle = CreateFile (VxdPath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_DELETE_ON_CLOSE,
                            NULL );

    if (VxdHandle == INVALID_HANDLE_VALUE)
    {
        //
        //  Not found.  Append the .VXD extension and try again.
        //  This will cause CreateFile to load the VxD.
        //
        lstrcat( VxdPath, ".VXD" );
        VxdHandle = CreateFile( VxdPath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
    }

    if (VxdHandle != INVALID_HANDLE_VALUE)
    {
        return VxdHandle;
    }

    DEBUG_PRINT(("OsOpenVxdHandle: cannot open %s (%04X), error %d\n", VxdPath, VxdId, GetLastError()));
    return 0;
}   // OsOpenVxdHandle


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure gets the entry point into the vxd (we call into this entry
    point for all the ioctl needs)

Arguments:

    VxdEntryProc: pointer to receive the entry point

Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetInterfaceList(
    )
{
    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize= sizeof(ULONG) + (NBT_MAXIMUM_BINDINGS+1)*sizeof(NETBT_ADAPTER_INDEX_MAP);
    PVOID                   pInput = NULL;
    ULONG                   i, SizeInput = 0;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;

    if (!(pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory ((PVOID)pInterfaceInfo, InterfaceInfoSize);
    if (gNbtVxdHandle = OsOpenVxdHandle("VNBT", VNBT_Device_ID))
    {
        status = CALL_DRIVER ((HANDLE) -1,
                              pInterfaceInfo,
                              InterfaceInfoSize,
                              IOCTL_NETBT_GET_INTERFACE_INFO,
                              pInput,
                              SizeInput);

        if (STATUS_SUCCESS != status)
        {
            CloseHandle (gNbtVxdHandle);
            gNbtVxdHandle = NULL;
        }
    }

    if (STATUS_SUCCESS == status)
    {
        for (i=0; i<pInterfaceInfo->NumAdapters; i++)
        {
            pDeviceInfo[i] = pInterfaceInfo->Adapter[i].LanaNumber;
        }

        NumDevices = pInterfaceInfo->NumAdapters;
    }

    LocalFree(pInterfaceInfo);
    return status;
}

//------------------------------------------------------------------------
HANDLE
OpenNbt(
    IN  ULONG   Index
    )
{
    return ((HANDLE) pDeviceInfo[Index]);
}


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure is a wrapper which makes the calls to the entry point

Arguments:

    VxdEntryProc: pointer the entry point
    pOutBuffer  : buffer to receive data in from the vxd, if applicable
    OutBufLen   : length of the output buffer
    Ioctl       : what request is this?
    pInBuffer   : ptr to the input buffer passed to netbt
    InBufLen    : size of the input buffer

Return Value:

    None

--*/

NTSTATUS
DeviceIoCtrl(
    HANDLE  LanaNumber,
    PVOID   pOutBuffer,
    ULONG   OutBufLen,
    ULONG   Ioctl,
    PVOID   pInBuffer,
    ULONG   InBufLen
    )
{
    USHORT              usIoctl;
    USHORT              usOutBufLen;
    DWORD               ActualInBufLen;
    PCHAR               pBufferData, pInBufferCopy;
    NTSTATUS            status = STATUS_SUCCESS;
    tNBT_IOCTL_HEADER   *pIoctlHeader;
    DWORD               BytesOut = 0;

    usOutBufLen = (USHORT)OutBufLen;
    usIoctl = (USHORT)Ioctl;

    //
    // vxd will copy the return code in the first 4 bytes of input buffer
    // to make sure we don't trash the input buffer that we received even
    // though it's probably not important, or to provide an input buffer
    // if we weren't given one, we allocate new memory and copy into it
    //
    if (InBufLen < sizeof(NTSTATUS))
    {
        ActualInBufLen = (USHORT) (FIELD_OFFSET (tNBT_IOCTL_HEADER, UserData) + sizeof (NTSTATUS));
    }
    else
    {
        ActualInBufLen = (USHORT) (FIELD_OFFSET (tNBT_IOCTL_HEADER, UserData) + InBufLen);
    }

    if (!(pInBufferCopy = malloc (ActualInBufLen)))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (((LONG) LanaNumber) >= 0)
    {
        pIoctlHeader = (tNBT_IOCTL_HEADER *) pInBufferCopy;
        pIoctlHeader->Signature = NBT_VERIFY_VXD_IOCTL;
        pIoctlHeader->LanaNumber = (ULONG) LanaNumber;
        pBufferData = (PCHAR) &pIoctlHeader->UserData;
    }
    else
    {
        pBufferData = pInBufferCopy;
    }
    RtlMoveMemory (pBufferData, pInBuffer, (USHORT) InBufLen);

    if (DeviceIoControl (gNbtVxdHandle,
                         Ioctl,
                         pInBufferCopy,
                         ActualInBufLen,
                         pOutBuffer,
                         OutBufLen,
                         &BytesOut,
                         FALSE))
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = GetLastError();
        //
        // Since VNbt could return Tdi error status, remap it
        //
        if (status == TDI_BUFFER_OVERFLOW)
        {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    free (pInBufferCopy);

    return( status );
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure converts to KBytes or Mbytes

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


VOID
PrintKorM(
    IN PVOID    pBytesIn
    )
{
    ULONG   BytesIn = *(ULONG UNALIGNED *) pBytesIn;
    ULONG   Bytes;

    if ( BytesIn > 1000 )
    {
        Bytes = BytesIn/1000;
        if ( Bytes > 1000 )
        {
            Bytes = Bytes/1000;
            if (Bytes > 1000 )
            {
                Bytes = Bytes/1000;

                nls_printf("%6dGB ",Bytes);
            }
            else
            {
                nls_printf("%6dMB ",Bytes);
            }
        }
        else
        {
            nls_printf("%6dKB ",Bytes);
        }
    }
    else
    {
        nls_printf("%6dB  ",BytesIn);
    }
}

#endif  // !CHICAGO_PRODUCT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\kdext\netbtkd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    netbtkd.c

Abstract:

    NETBT kd extension

Author:

    Jiandong Ruan   July 2000

Notes:
    This version is totally rewritten to support 32-bit and 64-bit debug by using
    new features of WINDBG

Revision History:

    11-Jul-2000 jruan   Support both 32-bit and 64-bit.

--*/

#include <nt.h>
#include <ntrtl.h>

#define KDEXTMODE
#define KDEXT_64BIT

#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <..\..\inc\types.h>

#define PRINTF  dprintf
#define ERROR   dprintf

EXT_API_VERSION        ApiVersion = {
        (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff),
        EXT_API_VERSION_NUMBER64, 0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;
ULONG64                ConfigPtr;

static char* inet_addr(ULONG ip, char* addr);

DECLARE_API(init)
{
    ReloadSymbols("netbt.sys");

    if (*args) {
        ConfigPtr = GetExpression(args);
    } else {
        ConfigPtr = GetExpression("netbt!NbtConfig");
    }
    if (ConfigPtr == 0) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    return;
}

__inline
ULONG
read_list_entry(
    ULONG64 addr,
    PLIST_ENTRY64 List
    )
{
    if (InitTypeRead(addr, LIST_ENTRY)) {
        return 1;
    }
    List->Flink = ReadField(Flink);
    List->Blink = ReadField(Blink);
    return 0;
}

#define READLISTENTRY   read_list_entry 

/*++
    Call callback for each entry in the list
 --*/
typedef BOOL (*LIST_FOR_EACH_CALLBACK)(ULONG64 address, PVOID);
int
ListForEach(ULONG64 address, int maximum, PVOID pContext, LIST_FOR_EACH_CALLBACK callback)
{
    LIST_ENTRY64    list;
    int             i;

    if (READLISTENTRY(address, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", address);
        return (-1);
    }
    if (list.Flink == address) {
        return (-1);
    }

    if (maximum < 0) {
        maximum = 1000000;
    }
    for (i = 0; i < maximum && (list.Flink != address); i++) {
        /*
         * Allow user to break us.
         */
        if (CheckControlC()) {
            break;
        }
        callback(list.Flink, pContext);
        if (READLISTENTRY(list.Flink, &list)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", list.Flink);
            return (-1);
        }
    }
    return i;
}

#define    NL      1
#define    NONL    0

#define MAX_LIST_ELEMENTS 4096

#define DEFAULT_UNICODE_DATA_LENGTH 4096
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 4096
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

LPSTR Extensions[] = {
    "Netbt debugger extensions",
    0
};

LPSTR LibCommands[] = {
    "help -- print out these messages",
    "init <nbtconfig address> -- Reload symbols for NETBT.SYS",
    "\tinit get the address of netbt!nbtconfig which will be used by other netbt kdext commands.",
    "\tIn case that the symbol table cannot be loaded, you can manually set the address.",
    "\tExamples:",
    "\t\tinit  --- reload symbols and automatically find the address of netbt!nbtconfig",
    "\t\tinit 0xfac30548 --- Force 0xfac30548 to be the address of netbt!nbtconfig",
    "dump -- is no longer supported. Please use 'dt <type> <addr>' instead",
    "\tFor example 'dt netbt!tDEVICECONTEXT 0x98765432'",
    "devices -- list all devices",
    "dev <devobj> -- dump a device",
    "connections -- list all connections",
    "cache [Local|Remote]",
    "localname <tNAMEADDR>   Display the connections associated with a local name",
    "verifyll <ListHead> [<Verify>]",
    "sessionhdr <session header>    Dump the session HDR",
    0
};

BOOL
help(void)
{
    int i;

    for( i=0; Extensions[i]; i++ )
        PRINTF( "   %s\n", Extensions[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );
    return TRUE;
}

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    PRINTF ( "NETBT: %s extension dll (build %d) debugging %s kernel (build %d)\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@ "
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

void
dump_device(ULONG64 addr)
{
    ULONG   linkage_offset = 0;
    ULONG   tag;
    ULONG   ip, subnet_mask, assigned_ip, name_server1, name_server2;
    UCHAR   mac[6];

    if (GetFieldOffset("netbt!tDEVICECONTEXT", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    InitTypeRead(addr, netbt!tDEVICECONTEXT);
    tag = (ULONG)ReadField(Verify);
    if (tag != NBT_VERIFY_DEVCONTEXT && tag != NBT_VERIFY_DEVCONTEXT_DOWN) {
        addr -= linkage_offset;
        InitTypeRead(addr, netbt!tDEVICECONTEXT);
        tag = (ULONG)ReadField(Verify);
        if (tag != NBT_VERIFY_DEVCONTEXT && tag != NBT_VERIFY_DEVCONTEXT_DOWN) {
            PRINTF ("Tag not found. %I64lx may not be a valid NETBT device\n", addr + linkage_offset);
            return;
        }
    }

    PRINTF ("+++++++++++++++ tDEVICECONTEXT @ %I64lx (%s) ++++++++++++++++\n",
            addr, (tag == NBT_VERIFY_DEVCONTEXT)? "Active": "Down");
    ip = (ULONG)ReadField(IpAddress);
    assigned_ip = (ULONG)ReadField(AssignedIpAddress);
    subnet_mask = (ULONG)ReadField(SubnetMask);
    GetFieldData(addr, "netbt!tDEVICECONTEXT", "MacAddress", 6, mac);
    PRINTF ("       IP Address: %s\n", inet_addr(ip, NULL));
    PRINTF ("IP Interface Flag: %I64lx\n", ReadField(IpInterfaceFlags));
    PRINTF ("      MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    PRINTF ("           subnet: %s\n", inet_addr(subnet_mask & ip, NULL));
    if (ip != assigned_ip) {
        PRINTF (" Assigned Address: %s\n", inet_addr(assigned_ip, NULL));
    }
    PRINTF ("      subnet mask: %s\n", inet_addr(subnet_mask, NULL));
    PRINTF ("broadcast address: %s\n", inet_addr((ULONG)ReadField(BroadcastAddress), NULL));
    PRINTF ("     network mask: %s\n", inet_addr((ULONG)ReadField(NetMask), NULL));
    name_server1 = (ULONG)ReadField(lNameServerAddress);
    name_server2 = (ULONG)ReadField(lBackupServer);
    if (name_server1 == 0) {
        PRINTF ("             WINS: <not configured>\n");
    } else if (name_server2 == 0) {
        PRINTF ("             WINS: %s\n", inet_addr(name_server1, NULL));
    } else {
        if (ReadField(SwitchedToBackup)) {
            PRINTF ("     Primary WINS: %s\n", inet_addr(name_server2, NULL));
            PRINTF ("   Secondary WINS: %s (in use)\n", inet_addr(name_server1, NULL));
        } else {
            PRINTF ("     Primary WINS: %s (in use)\n", inet_addr(name_server1, NULL));
            PRINTF ("   Secondary WINS: %s\n", inet_addr(name_server2, NULL));
        }
    }
    if (ReadField(WinsIsDown)) {
        PRINTF ("************* WINS(s) ARE DOWN ***************\n");
    }
    PRINTF ("  pFileObject: %I64lx (type netbt!tFILE_OBJECTS)\n", ReadField(pFileObjects));
    PRINTF ("TCP Session: HANDLE=%I64lx DeviceObject=%I64lx FileObject=%I64lx\n",
            ReadField(hSession), ReadField(pSessionDeviceObject), ReadField(pSessionFileObject));
    PRINTF ("TCP Control: HANDLE=%I64lx DeviceObject=%I64lx FileObject=%I64lx\n",
            ReadField(hControl), ReadField(pControlDeviceObject), ReadField(pControlFileObject));

    PRINTF ("\n");
}

/*++
    Dump a NETBT device
 --*/
DECLARE_API (dev)
{
    if (*args == 0) {
        return;
    }
    dump_device(GetExpression(args));
}

/*++
    Dump all NETBT devices
 --*/
DECLARE_API (devices)
{
    ULONG64         NbtSmbDevice;
    ULONG           Offset;
    USHORT          AdapterCounter;
    int             num;

    GetFieldValue(ConfigPtr, "netbt!tNBTCONFIG", "AdapterCount", AdapterCounter);

    /*
     * SMB device
     */
    NbtSmbDevice = GetExpression("netbt!pNbtSmbDevice");
    ReadPtr(NbtSmbDevice, &NbtSmbDevice);
    PRINTF( "Dumping SMB device\n");
    dump_device(NbtSmbDevice);

    /*
     * dump device list
     */
    if (GetFieldOffset("netbt!tNBTCONFIG", (LPSTR)"DeviceContexts", &Offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    num = ListForEach(ConfigPtr + Offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)dump_device);
    PRINTF ("Total devices = %d (include SMB device)\n", num + 1);

    /*
     * Check consistency
     */
    if (num != AdapterCounter) {
        PRINTF ("Inconsistent!!! Number of devices = %d in NbtConfig.AdapterCount\n", AdapterCounter);
    }
}

/*
 * call back function for dumping a list of listening request
 */
BOOL
listen_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   irp_offset;
    ULONG   linkage_offset;
    ULONG64 irp_addr;

    if (GetFieldOffset("netbt!tLISTENREQUESTS", (LPSTR)"pIrp", &irp_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    if (GetFieldOffset("netbt!tLISTENREQUESTS", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    addr -= linkage_offset;
    if (ReadPtr(addr+irp_offset, &irp_addr)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    PRINTF ("\t\t ** pListen@<%I64lx> ==> pIrp = %I64lx\n", addr, irp_addr);
    return TRUE;
}

/*
 * call back function for dumping a list of connection element
 */
BOOL
connect_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   linkage_offset;
    UCHAR   name[NETBIOS_NAME_SIZE];

    if (GetFieldOffset("netbt!tCONNECTELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    addr -= linkage_offset;

    if (GetFieldData(addr, "netbt!tCONNECTELE", "RemoteName", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    PRINTF ("\t\t ** Connection@<%I64lx> ==> <%-15.15s:%x>\n", addr, name, name[15]&0xff);
    return TRUE;
}

/*
 * call back function for dumping a list of client element
 */
BOOL
client_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   connect_offset;
    ULONG   listen_offset;
    ULONG   active_connect_offset;
    ULONG   linkage_offset, tag;
    UCHAR   name[NETBIOS_NAME_SIZE];

    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    addr -= linkage_offset;
    if (InitTypeRead(addr, netbt!tCLIENTELE)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    tag = (ULONG)ReadField(Verify);
    if (tag == NBT_VERIFY_CLIENT) {
        PRINTF ("\tActive ");
    } else if (tag == NBT_VERIFY_CLIENT_DOWN) {
        PRINTF ("\tClosed ");
    } else {
        PRINTF ("\tClient @ %I64lx: bad client tag: %lx\n", addr, tag);
        return FALSE;
    }
    if (GetFieldData(addr, "netbt!tCLIENTELE", "EndpointName", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    PRINTF ("Client@<%I64lx> ==> pDevice = %I64lx\tEndpoint=<%-15.15s:%x>\n",
            addr, ReadField(pDeviceContext), name, name[15]);

    /*
     * dump the connection associated with the client element
     */
    PRINTF ("\t\t(ConnectHead):\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ConnectHead", &connect_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + connect_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);

    PRINTF ("\t\t(ConnectActive)\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ConnectActive", &active_connect_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + active_connect_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);

    PRINTF ("\t\t(ListenHead):\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ListenHead", &listen_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + listen_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)listen_callback);

    PRINTF ("\n");
    return TRUE;
}

/*
 * call back function for dumping a list of address element
 */
BOOL
addresses_callback(ULONG64 addr, PVOID pContext)
{
    UCHAR   name[NETBIOS_NAME_SIZE];
    ULONG64 NameAddr;
    ULONG   tag, linkage_offset, client_offset;

    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %d of %s\n", __LINE__, __FILE__);
        return FALSE;
    }
    addr -= linkage_offset;

    if (InitTypeRead(addr, netbt!tADDRESSELE)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %I64lx\n", addr);
        return FALSE;
    }
    tag = (ULONG)ReadField(Verify);

    /*
     * Check tag
     */
    if (tag != NBT_VERIFY_ADDRESS) {
        PRINTF ("ERROR: incorrect tag <%4.4s>. %lx is properly not a address element\n", tag, addr);
        return FALSE;
    }

    /*
     * Print out the address element
     */
    NameAddr = ReadField(pNameAddr);
    if (GetFieldData(NameAddr, "netbt!tNAMEADDR", "Name", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT: pNameAddr=%I64lx\n", NameAddr);
        return FALSE;
    }
    PRINTF ("Address@<%I64lx> ==> <%-15.15s:%x>\n", addr, name, name[15]);

    /*
     * dump the client element associated with the address element
     */
    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"ClientHead", &client_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %I64lx\n", addr);
        return FALSE;
    }
    ListForEach(addr + client_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)client_callback);
    return TRUE;
}

DECLARE_API(connections)
{
    ULONG   Offset;

    if (GetFieldOffset("netbt!tNBTCONFIG", (LPSTR)"AddressHead", &Offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    PRINTF ("Dumping information on all NetBT conections ...\n");
    ListForEach(ConfigPtr + Offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)addresses_callback);
    PRINTF( "---------------- End of Connections ----------------\n");
}

char* inet_addr(ULONG ip, char* addr)
{
    static char my_addr[16];

    if (addr == NULL) {
        addr = my_addr;
    }
    sprintf (addr, "%d.%d.%d.%d",
        (ip >> 24) & 0xff, (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
    return addr;
}

WCHAR*
GetUnicodeString(ULONG64 addr)
{
    USHORT  length;
    ULONG   readed_bytes;
    ULONG64 buffer = 0;
    WCHAR   *p;

    InitTypeRead(addr, netbt!UNICODE_STRING);
    length = (USHORT)ReadField(Length);
    buffer = ReadField(Buffer);
    if (buffer == 0 || length == 0) {
        return NULL;
    }

    p = (WCHAR*)LocalAlloc(LMEM_FIXED, length + sizeof(WCHAR));
    if (p == NULL) {
        return NULL;
    }
    ReadMemory(buffer, (PVOID)p, length, &readed_bytes);
    if ((USHORT)readed_bytes != length) {
        LocalFree(p);
        return NULL;
    }
    p[length/sizeof(WCHAR)] = L'\0';
    return p;
}

/*
 * call back function for dumping a list of cache entries
 */
BOOL
cache_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   addr_offset = (ULONG)(-1);
    static  ULONG   fqdn_offset = (ULONG)(-1);
    ULONG   Verify;
    UCHAR   name[NETBIOS_NAME_SIZE];
    ULONG   ip, refcnt, state, ttl;
    WCHAR   *fqdn = NULL;

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            addr_offset = (ULONG)(-1);
            return FALSE;
        }
    }
    if (fqdn_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"FQDN", &fqdn_offset)) {
            fqdn_offset = (ULONG)(-1);
        }
    }

    addr -= addr_offset;
    if (InitTypeRead(addr, netbt!tNAMEADDR)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    Verify = (ULONG)ReadField(Verify);
    if (Verify != LOCAL_NAME && Verify != REMOTE_NAME) {
        PRINTF ("ERROR: bad name cache entry @ %I64x tag %lx!\n", addr, Verify);
        return FALSE;
    }
    ip = (ULONG)ReadField(IpAddress);
    refcnt = (ULONG)ReadField(RefCount);
    state = (ULONG)ReadField(NameTypeState);
    ttl = (ULONG)ReadField(Ttl);
    if (GetFieldData(addr, "netbt!tNAMEADDR", "Name", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    if (fqdn_offset != (ULONG)(-1)) {
        fqdn = GetUnicodeString(addr + fqdn_offset);
    }
    PRINTF ("[%d]\t<%16.16I64lx> => <%-15.15s:%2x> | %-15.15s |    %d | %8x | %9d\n",
            *bkt, addr, name, name[15], inet_addr(ip, NULL), refcnt, state, ttl);
    if (fqdn != NULL) {
        PRINTF("\t\t%ws\n", fqdn);
        LocalFree(fqdn);
        fqdn = NULL;
    }
    PRINTF("\t\tName State:");
    if (state & NAMETYPE_QUICK) {
        PRINTF(" QUICK");
    }
    if (state & NAMETYPE_UNIQUE) {
        PRINTF(" UNIQUE");
    }
    if (state & NAMETYPE_GROUP) {
        PRINTF(" GROUP");
    }
    if (state & NAMETYPE_INET_GROUP) {
        PRINTF(" INET_GROUP");
    }
    if (state & STATE_RESOLVED) {
        PRINTF(" RESOLVED");
    }
    if (state & STATE_RELEASED) {
        PRINTF(" RELEASED");
    }
    if (state & STATE_CONFLICT) {
        PRINTF(" CONFLICT");
    }
    if (state & STATE_RESOLVING) {
        PRINTF(" RESOLVING");
    }
    if (state & REFRESH_FAILED) {
        PRINTF(" REFRESH_FAILED");
    }
    if (state & PRELOADED) {
        PRINTF(" PRELOADED");
    }
    PRINTF("\n");

    return TRUE;
}

void
dump_cache(ULONG64 addr)
{
    LONG   bucket_number;
    int    i;
    static ULONG buckets_offset = (ULONG)(-1);
    static ULONG sizeof_list;

    if (buckets_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tHASHTABLE", (LPSTR)"Bucket", &buckets_offset)) {
            PRINTF ("\nError -- please fix symbol path for NETBT\n");
            return;
        }
        sizeof_list = GetTypeSize ("LIST_ENTRY");
    }
    if (InitTypeRead(addr, netbt!tHASHTABLE)) {
        PRINTF ("\nError -- please fix symbol path for NETBT\n");
        return;
    }
    bucket_number = (ULONG) ReadField(lNumBuckets);

    PRINTF (" %d buckets\n", bucket_number);
    PRINTF ("[Bkt#]\t<    Address    >  => <Name              > |      IpAddr     | RefC |   State  |       Ttl\n");
    for (i=0; i < bucket_number; i++) {
        ListForEach(addr + buckets_offset + i * sizeof_list, -1, &i, (LIST_FOR_EACH_CALLBACK)cache_callback);
    }
    PRINTF ("-----------------------------------------------------------------------------------\n");
}

DECLARE_API (cache)
{
    ULONG64 local_addr, remote_addr;

    if (InitTypeRead(ConfigPtr, netbt!tNBTCONFIG)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    local_addr = ReadField(pLocalHashTbl);
    remote_addr = ReadField(pRemoteHashTbl);

    if (_stricmp(args, "local") == 0) {
        PRINTF ("Dumping local cache %I64lx", local_addr);
        dump_cache (local_addr);
    } else if (_stricmp(args, "remote") == 0) {
        PRINTF ("Dumping remote cache %I64lx", remote_addr);
        dump_cache (remote_addr);
    } else {
        PRINTF ("Dumping local cache %I64lx", local_addr);
        dump_cache (local_addr);
        PRINTF ("Dumping remote cache %I64lx", remote_addr);
        dump_cache (remote_addr);
    }
    PRINTF( "---------------- Cache ----------------\n");
    return;
}

DECLARE_API (localname)
{
    ULONG   linkage_offset;
    ULONG32 tag;
    ULONG64 addr;

    if (*args == 0) {
        PRINTF ("Usage: localname pointer\n");
        return;
    }

    addr = GetExpression(args);
    if (GetFieldValue(addr, "netbt!tNAMEADDR", "Verify", tag)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    if (tag == REMOTE_NAME) {
        PRINTF ("%I64x is a remote name. Please use a local name.\n", addr);
        return;
    }
    if (tag == LOCAL_NAME) {
        ULONG   addr_offset;

        /*
         * GetFieldValue won't do signextended for 32-bit. Use ReadPtr
         */
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"pAddressEle", &addr_offset)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            return;
        }
        if (ReadPtr(addr + addr_offset, &addr)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            return;
        }
    }
    if (GetFieldValue(addr, "netbt!tADDRESSELE", "Verify", tag)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    if (tag != NBT_VERIFY_ADDRESS) {
        PRINTF ("%I64x is not a local name. Please use a local name.\n", addr);
        return;
    }
    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    addresses_callback(addr - linkage_offset, NULL);
}

ULONG
dump_field_callback(PFIELD_INFO pField, PVOID context)
{
    PRINTF ("%s, %s, %I64lx\n", pField->fName, pField->printName, pField->address);
    return 0;
}

DECLARE_API(dump)
{
    PRINTF ("dump is no longer supported because 'dt type address' is better\n");
    PRINTF ("\tFor example 'dt netbt!tDEVICECONTEXT 0x98765432'\n");
}

/*
 * read in a list entry and a ULONG following that list entry.
 */
__inline ULONG
read_list_verify(
    ULONG64 addr,
    PLIST_ENTRY64 List,
    ULONG  *verify
    )
{
    static ULONG list_size = 0;
    ULONG64 a;

    if (list_size == 0) {
        list_size = GetTypeSize("LIST_ENTRY");
    }
    if (InitTypeRead(addr, LIST_ENTRY)) {
        return 1;
    }
    List->Flink = ReadField(Flink);
    List->Blink = ReadField(Blink);
    if (GetFieldData(addr+list_size, "ULONG", NULL, sizeof(ULONG64), &a)) {
        return 1;
    }
    *verify = (ULONG)a;
    return 0;
}

DECLARE_API(verifyll)
{
    LIST_ENTRY64    list;
    ULONG64     pHead, pCurrentEntry, pNextEntry, pPreviousEntry;
    ULONG       VerifyRead, VerifyIn = 0;
    ULONG       Count = 0;
    BOOL        fVerifyIn = FALSE;
    BOOL        fListCorrupt = FALSE;

    PRINTF ("Verifying Linked list ...\n");

    if (!args || !(*args)) {
        PRINTF ("Usage: !NetbtKd.VerifyLL <ListHead>\n");
        return;
    } else {
        //
        // args = "<pHead> [<Verify>]"
        //
        LPSTR lpVerify;

        while (*args == ' ') {
            args++;
        }
        lpVerify = strpbrk(args, NAME_DELIMITERS);

        pHead = GetExpression (args);
        if (lpVerify) {
            VerifyIn = (ULONG)GetExpression (lpVerify);
            fVerifyIn = TRUE;
        }
    }

    PRINTF ("** ListHead@<%I64lx>, fVerifyIn=<%x>, VerifyIn=<%x>:\n\n", pHead, fVerifyIn, VerifyIn);
    PRINTF ("Verifying Flinks ...");

    // Read in the data for the first FLink in the list!
    pPreviousEntry = pHead;
    if (READLISTENTRY(pHead, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pHead);
        return;
    }
    pCurrentEntry = list.Flink;
    if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
        return;
    }
    pNextEntry = list.Flink;

    while ((pCurrentEntry != pHead) && (++Count < MAX_LIST_ELEMENTS)) {
        if (CheckControlC()) {
            break;
        }
        if ((fVerifyIn) && (VerifyRead != VerifyIn)) {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far\n"
                    "\tPrevious=<%I64lx>, Current=<%I64lx>, Next=<%I64lx>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
            return;
        }
        pNextEntry = list.Flink;
    }

    if (!fListCorrupt) {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF ("Verifying Blinks ...");
    Count = 0;
    fListCorrupt = FALSE;
    // Read in the data for the first BLink in the list!
    pPreviousEntry = pHead;
    if (READLISTENTRY(pHead, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pHead);
        return;
    }
    pCurrentEntry = list.Blink;
    if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
        return;
    }
    pNextEntry = list.Blink;

    while ((pCurrentEntry != pHead) && (++Count < MAX_LIST_ELEMENTS)) {
        if (CheckControlC()) {
            break;
        }
        if ((fVerifyIn) && (VerifyRead != VerifyIn)) {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far\n"
                    "\tPrevious=<%I64lx>, Current=<%I64lx>, Next=<%I64lx>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
            return;
        }
        pNextEntry = list.Blink;
    }

    if (!fListCorrupt) {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF( "---------------- Verify LinkedList ----------------\n");

    return;
}

DECLARE_API(sessionhdr)
{
    tSESSIONHDR     Hdr;
    char            called_name[34];
    char            callee_name[34];
    ULONG64         addr;
    ULONG           Size;
    int             i;

    if (!args || !(*args)) {
        PRINTF ("Usage: !NetbtKd.sessionhdr hdr\n");
        return;
    }

    addr = GetExpression(args);
    if (addr == 0) {
        return;
    }

    ReadMemory(addr, &Hdr, sizeof(Hdr), &Size);
    ReadMemory(addr + sizeof(Hdr), called_name, sizeof(called_name), &Size);
    ReadMemory(addr + sizeof(Hdr)+sizeof(called_name), callee_name, sizeof(callee_name), &Size);

    if (called_name[0] != 32 || callee_name[0] != 32) {
        PRINTF ("Error -- invalid called/callee name length called=%d, callee=%d\n",
                (unsigned)called_name[0], (unsigned)callee_name[0]);
        return;
    }

    for (i = 0; i < 16; i++) {
        called_name[i + 1] = ((called_name[i*2+1] - 'A') << 4) | (called_name[i*2+2] - 'A');
        callee_name[i + 1] = ((callee_name[i*2+1] - 'A') << 4) | (callee_name[i*2+2] - 'A');
    }
    called_name[i + 1] = 0;
    callee_name[i + 1] = 0;

    PRINTF ("called name=%15.15s<%02x>\n", called_name+1, (unsigned)called_name[16]);
    PRINTF ("callee name=%15.15s<%02x>\n", callee_name+1, (unsigned)callee_name[16]);
    return;
}

//
// Standard Functions
//
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_PROCESS_ATTACH:
        break;
    }

    return TRUE;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

    init(0, 0, 0, 0, "");
    return;
}

VOID
CheckVersion(VOID)
{
    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\lmhosts\lmhsvc.c ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    lmhsvc.c

Abstract:

    This module implements the LmHosts Service, which is part of the LmSvc
    process.

    One purpose of the LmHosts Service is to send down a NBT_RESYNC
    ioctl command to netbt.sys, after the LanmanWorkstation service has been
    started.  To accomplish this, the NT Registry is primed so that the
    LmHosts service is dependent on the LanmanWorkStation service.

    This service also handle name query requests from netbt destined for
    DNS by way of gethostbyname.


Author:

    Jim Stewart                           November 18 22, 1993

Revision History:

    ArnoldM   14-May-1996      Use winsock2 name resolution
                               instead of gethostbyname



Notes:

--*/


//
// Standard NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// C Runtime Library Headers
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//
// Transport Specific Header Files
//
#include <nbtioctl.h>

//
// Standard Windows Headers
//
#include <windows.h>

#include <tdi.h>

//
// LAN Manager Headers
//
#include <lm.h>
#include <netlib.h>
#include <netevent.h>

//
// Sockets Headers
//
#include <winsock2.h>
#include <svcguid.h>
#include <wsahelp.h>


//
// Private Definitions
//
#define NBT_DEVICE	"\\Device\\Streams\\Nbt"
#define WSA_QUERY_BUFFER_LENGTH (3*1024)
BYTE    pWSABuffer[WSA_QUERY_BUFFER_LENGTH];

//
// We currently have two threads; one for DNS names, the other for checking IP addresses
// for reachability.
//
#define NUM_THREADS 2

//
// Function Prototypes
//
VOID
announceStatus (
    IN LPSERVICE_STATUS svcstatus
    );

VOID
lmhostsHandler (
    IN DWORD opcode
    );

VOID
lmhostsSvc (
    IN DWORD argc,
    IN LPTSTR *argv
    );

NTSTATUS
prepareData (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

LONG
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN ULONG            i
    );

LONG
PrimeCacheNbt(
    OUT PHANDLE     pHandle,
    IN  ULONG       index
    );

NTSTATUS
Resync(
    IN HANDLE   fd
    );

LONG
ReadRegistry(
    IN WCHAR  *pDeviceName[]
    );

NTSTATUS
OpenNbt(
    IN  WCHAR  *path[],
    OUT PHANDLE pHandle
    );

LONG
GetHostName(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    );

LONG
PostForGetHostByName(
    IN HANDLE           fd
    );

VOID
CheckIPAddrWorkerRtn(
    IN  LPVOID  lpParam
    );

LONG
CheckIPAddresses(
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    IN ULONG   *IpAddr,
    IN BOOLEAN  fOrdered
    );

//
// Global Variables
//
PUCHAR                EventSource = "LmHostsService";

HANDLE                Poison[NUM_THREADS];                       // set to kill this service
HANDLE                NbtEvent[NUM_THREADS];                     // set when Nbt returns the Irp
SERVICE_STATUS_HANDLE SvcHandle;
SERVICE_STATUS        SvcStatus;
BOOLEAN               Trace = FALSE;                // TRUE for debugging
tIPADDR_BUFFER_DNS    *pIpAddrBuffer;
tIPADDR_BUFFER_DNS    *pIpAddrBufferChkIP;
BOOLEAN               SocketsUp;

#if DBG
#define DBG_PRINT   DbgPrint
#else
#define DBG_PRINT
#endif  // DBG


//------------------------------------------------------------------------
VOID
ServiceMain (
    IN DWORD argc,
    IN LPTSTR *argv
    )

/*++

Routine Description:

    This is the SERVICE_MAIN_FUNCTION.

Arguments:

    argc, argv

Return Value:

    None.

--*/

{
    DWORD   status;
    HANDLE  hNbt;
    HANDLE  EventList[2];
    ULONG   EventCount;
    LONG    err;
    WSADATA WsaData;
    LONG    Value;
    HANDLE  hThread;
    ULONG   Tid;
    ULONG   *pIndex;

    LARGE_INTEGER Timeout = RtlEnlargedIntegerMultiply (-10 * 60, 1000 * 1000 * 10); // 10 minutes

    if (STATUS_SUCCESS != (prepareData(argc, argv)))
    {
        ExitThread(NO_ERROR);
    }

    pIpAddrBuffer = NULL;
    pIpAddrBufferChkIP = NULL;

    if (Trace)
    {
        DbgPrint("LMHSVC: calling RegisterServiceCtrlHandler()\n");
    }

    SvcHandle = RegisterServiceCtrlHandler(SERVICE_LMHOSTS,    // ServiceName
                                           lmhostsHandler);    // HandlerProc

    if (SvcHandle == (SERVICE_STATUS_HANDLE) 0)
    {
        DBG_PRINT ("LMHSVC: RegisterServiceCtrlHandler failed %d\n", GetLastError());
        ExitThread(NO_ERROR);
        return;
    }

    SvcStatus.dwServiceType             = SERVICE_WIN32;
    SvcStatus.dwCurrentState            = SERVICE_START_PENDING;
    SvcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    SvcStatus.dwWin32ExitCode           = 0;
    SvcStatus.dwServiceSpecificExitCode = 0;
    SvcStatus.dwCheckPoint              = 0;
    SvcStatus.dwWaitHint                = 20000;         // 20 seconds

    SET_SERVICE_EXITCODE(NO_ERROR,                                // SomeApiStatus
                         SvcStatus.dwWin32ExitCode,               // Win32CodeVariable
                         SvcStatus.dwServiceSpecificExitCode);    // NetCodeVariable

    announceStatus(&SvcStatus);


    SvcStatus.dwCurrentState = SERVICE_RUNNING;
    SvcStatus.dwCheckPoint   = 0;
    SvcStatus.dwWaitHint     = 0;

    announceStatus(&SvcStatus);

    //
    // startup the sockets interface
    //
    err = WSAStartup( 0x0101, &WsaData );
    if ( err == SOCKET_ERROR )
    {
        //s_perror("nbtstat: WSAStartup:", GetLastError());
#if 0
        NetdLogEventA(
                    EventSource,                         // EventSource
                    EVENT_NBTSVC_LMHOST_SYNC_FAIL,       // MessageId
                    EVENTLOG_WARNING_TYPE,               // EventType
                    0,                                   // NumberofSubStrings
                    NULL);                               // SubStrings
#endif
        SocketsUp = FALSE;
    }
    else
    {
        SocketsUp = TRUE;
    }

    if ((pIndex = LocalAlloc(LMEM_FIXED, sizeof(ULONG))) == NULL)
    {
        DBG_PRINT ("LMHSVC: malloc of index failed %d\n", GetLastError());
        ExitThread(NO_ERROR);
        return;
    }

    if (Trace)
    {
        DbgPrint("LMHSVC: CreateThread attempting...\n");
    }

    *pIndex = 1;
    hThread = CreateThread (NULL,                   // lpThreadAttributes
                            0,                      // dwStackSize
                            (LPTHREAD_START_ROUTINE) CheckIPAddrWorkerRtn,  // lpStartAddress
                            &pIndex,                        //  lpParameter
                            0,                              //  dwCreationFlags
                            &Tid);                          //  lpThreadId

    if (hThread == NULL)
    {
        DBG_PRINT ("LMHSVC: CreateThread failed %d\n", GetLastError());
        ExitThread(NO_ERROR);
        return;
    }

    //
    // ignore the return code from resyncNbt().
    //
    // In most cases (no domains spanning an ip router), it is not a
    // catastrophe if nbt.sys couldn't successfully process the NBT_RESYNC
    // ioctl command.  Since I'm ignoring the return, I announce I'm running
    // before I call it to allow other dependent services to start.
    //
    //
    status = PrimeCacheNbt(&hNbt, 0);

    if (Trace)
    {
        DbgPrint("LMHSVC: Thread 0, hNbt %lx\n", hNbt);
    }

    if (hNbt != (HANDLE)-1)
    {
        status = PostForGetHostByName(hNbt);
        if (status == NO_ERROR)
        {
            EventCount = 2;
        }
        else
        {
            if (Trace)
            {
                DbgPrint("Lmhsvc: Error posting Irp for get host by name\n");
            }
            EventCount = 1;
        }
    }
    else
    {
        EventCount = 1;
    }
    //
    // "A SERVICE_MAIN_FUNCTION does not return until the service is ready
    // to terminate."
    //
    // (ref: api32wh.hlp, SERVICE_MAIN_FUNCTION)
    //
    //
    assert(Poison[0]);
    EventList[0] = Poison[0];
    EventList[1] = NbtEvent[0];

    while (TRUE)
    {
        status = NtWaitForMultipleObjects(EventCount,
                                          EventList,
                                          WaitAny,              // wait for any event
                                          FALSE,
                                          (EventCount == 1)? &Timeout: NULL);
        if (status == WAIT_TIMEOUT)
        {
            if (hNbt == (HANDLE)-1)
            {
                PrimeCacheNbt(&hNbt, 0);
                if (hNbt == (HANDLE)-1)
                {
                    continue; // to wait
                }
            }
            status = PostForGetHostByName(hNbt); // try again
            if (status == NO_ERROR)
            {
                EventCount = 2;
            }
        }
        else if (status == 1)
        {
            if (Trace)
            {
                DbgPrint("LMHSVC: Doing GetHostName\n");
            }

            // the irp used for gethostby name has returned
            status = GetHostName(hNbt,pIpAddrBuffer);

            //
            // disable the get host by name stuff if we have an error
            // posting a buffer to the transport
            //
            if (status != NO_ERROR)
            {
                EventCount = 1;
            }
        }
        else
        {
            // it must have been a the Poison event signalling the end of the
            // the service, so exit after getting the Irp back from the
            // transport.  This system will look after canceling the IO and
            // getting the Irp back.

            NtClose(Poison[0]);
            NtClose(NbtEvent[0]);
            NtClose(hNbt);
            break;
        }
    }

    if (pIpAddrBuffer)
    {
        LocalFree (pIpAddrBuffer);
    }

    if (pIpAddrBufferChkIP)
    {
        LocalFree (pIpAddrBufferChkIP);
    }

    if (Trace)
    {
        DBG_PRINT ("LMHSVC: [LMSVCS_ENTRY_POINT] Exiting now!\n");
    }
    ExitThread(NO_ERROR);
    return;

} // lmhostsSvc



//------------------------------------------------------------------------
VOID
announceStatus (
    IN LPSERVICE_STATUS status
    )

/*++

Routine Description:

    This procedure announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (!SvcHandle) {
        return;
    }

#if DBG
    if (Trace)
    {
        DbgPrint( "LMHSVC: announceStatus:\n"
                  "        CurrentState %lx\n"
                  "        ControlsAccepted %lx\n"
                  "        Win32ExitCode %lu\n"
                  "        ServiceSpecificExitCode %lu\n"
                  "        CheckPoint %lu\n"
                  "        WaitHint %lu\n",
                status->dwCurrentState,
                status->dwControlsAccepted,
                status->dwWin32ExitCode,
                status->dwServiceSpecificExitCode,
                status->dwCheckPoint,
                status->dwWaitHint);
    }
#endif // DBG

    SetServiceStatus(SvcHandle, status);

} // announceStatus


//------------------------------------------------------------------------
VOID
lmhostsHandler (
    IN DWORD controlcode
    )

/*++

Routine Description:

    This is the HANDLER_FUNCTION of the LmHosts service.

    It only responds to two Service Controller directives: to stop, and
    to announce the current status of the service.

Arguments:

    opcode

Return Value:

    None.

--*/

{
    BOOL retval;
    ULONG   i;

    switch (controlcode) {
    case SERVICE_CONTROL_STOP:

        for (i=0; i<NUM_THREADS; i++) {
            assert(Poison[i]);

            retval = PulseEvent(Poison[i]);

            assert(retval);
        }

        SvcStatus.dwCurrentState = SERVICE_STOPPED;
        SvcStatus.dwCheckPoint   = 0;
        SvcStatus.dwWaitHint     = 0;
        /* fall through */

    case SERVICE_CONTROL_INTERROGATE:
        announceStatus(&SvcStatus);
        break;

    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        assert(0);
        break;
    }

} // lmhostsHandler


//------------------------------------------------------------------------
NTSTATUS
prepareData (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

Arguments:

    argc, argv

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD status;

    for (i=0; i<NUM_THREADS; i++)
    {
        Poison[i] = CreateEvent(NULL,                            // security attributes
                                FALSE,                           // ManualReset
                                FALSE,                           // InitialState
                                NULL);                           // EventName

        if (!Poison[i])
        {
            DBG_PRINT ("LMHSVC: couldn't CreateEvent()\n");
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        NbtEvent[i] = CreateEvent(NULL,                            // security attributes
                                  FALSE,                           // ManualReset
                                  FALSE,                           // InitialState
                                  NULL);                           // EventName
        if (!NbtEvent[i])
        {
            DBG_PRINT ("LMHSVC: couldn't CreateEvent()\n");
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return STATUS_SUCCESS;

} // prepareData


//------------------------------------------------------------------------
LONG
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN ULONG            index
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    IO_STATUS_BLOCK                 iosb;
    PVOID                           pInput;
    ULONG                           SizeInput;

    pInput = NULL;
    SizeInput = 0;
    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NbtEvent[index],                // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        // do not wait for this to complete since it could complete
        // at any time in the future.
        //
        if ((Ioctl == IOCTL_NETBT_DNS_NAME_RESOLVE) ||
            (Ioctl == IOCTL_NETBT_CHECK_IP_ADDR))
        {
            return(NO_ERROR);
        }
        else
        {
            status = NtWaitForSingleObject(
                        fd,                         // Handle
                        TRUE,                       // Alertable
                        NULL);                      // Timeout
        }
    }

    if (NT_SUCCESS(status))
    {
        return(NO_ERROR);
    }
    else
        return(ERROR_FILE_NOT_FOUND);

}

//------------------------------------------------------------------------
NTSTATUS
Resync(
    IN HANDLE   fd
    )

/*++

Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS    status;
    CHAR        Buffer;

    status = DeviceIoCtrl(fd,
                          &Buffer,
                          1,
                          IOCTL_NETBT_PURGE_CACHE,
                          0);   // pass 0 since we know that we are called only for the first thread

    return(status);
}

#if 0
//------------------------------------------------------------------------
PCHAR
GetHost(ULONG addr,BOOLEAN Convert)
{
    static char string[32];

    union inet
    {
        unsigned long l;
        char          c[4];
    }in;
    struct hostent *hp;

    int     i;

    if (addr == 0L)
        return(" ");

    /*
     *  Look up the address in the in-core host table.
     *  If it's there, that'll do the trick.
     */

    if (Convert)
    {
        if ( hp = gethostbyname((char  *) &addr,sizeof(addr),2) )
        {
            return( hp->h_name );
        }
    }

    in.l = addr;
    sprintf(string, "%u.%u.%u.%u", (unsigned char) in.c[0],
        (unsigned char) in.c[1], (unsigned char) in.c[2],
            (unsigned char) in.c[3]);
    return(string);
}
#endif

//------------------------------------------------------------------------
NTSTATUS
PrimeCacheNbt(
    OUT PHANDLE     pHandle,
    IN  ULONG       index
    )

/*++

Routine Description:

    This procedure sends a NBT_PURGE ioctl command down to netbt.sys.

Arguments:

    None.

Return Value:

    0 if successful, an error code otherwise.

--*/

{
    LONG        status;
    HANDLE      Handle;
    int         i;

    //
    // In PnP, the Netbt device is not created until the first IP address has
    // appeared on that adapter. We need to open all available devices until
    // an open succeeds.
    //

    WCHAR       *DeviceName[NBT_MAXIMUM_BINDINGS];
    UCHAR       stringbuf[24];
    UCHAR       *subStrings[1];

    *pHandle = (HANDLE)-1;

    for (i=0; i<NBT_MAXIMUM_BINDINGS; i++)
    {
        DeviceName[i] = NULL;
    }

#ifdef USE_REGISTRY
    status = ReadRegistry(DeviceName);
    if (status == NO_ERROR)
    {
        status = OpenNbt(DeviceName,&Handle);
#else
    {
        PWCHAR ExportDevice[ ] = { L"\\Device\\NetBt_Wins_Export", 0 };

        status = OpenNbt(ExportDevice,&Handle);
#endif
        if (status == NO_ERROR)
        {
            //
            // Resync only once...
            //
            if (index == 0) {
                Resync(Handle);
            }

            *pHandle = Handle;
        }

    }

    for (i=0; i<NBT_MAXIMUM_BINDINGS; i++)
    {
        if (DeviceName[i])
        {
            free (DeviceName[i]);
        }
        else
        {
            break;
        }
    }

    if (status != NO_ERROR)
    {
        sprintf(stringbuf, "%lu", status);
        subStrings[0] = stringbuf;
#if 0
        NetdLogEventA(
                    EventSource,                         // EventSource
                    EVENT_NBTSVC_LMHOST_SYNC_FAIL,       // MessageId
                    EVENTLOG_WARNING_TYPE,               // EventType
                    1,                                   // NumberofSubStrings
                    (UCHAR **) subStrings);              // SubStrings
#endif
    }
    return(status);
}

//------------------------------------------------------------------------
LONG
ReadRegistry(
    IN WCHAR  *pDeviceName[]
    )

/*++

Routine Description:

    This procedure reads the registry to get the name of NBT to bind to.
    That name is stored in the Linkage/Exports section under the Netbt key.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    PWCHAR  SubKeyLinkage=L"system\\currentcontrolset\\services\\netbt\\linkage";
    HKEY    Key;
    PWCHAR  Linkage=L"Export";
    LONG    Type;
    UCHAR   *pBuffer;
    LONG    status;
    LONG    status2;
    ULONG   size = 512;

    pBuffer = malloc(size);
    if (!pBuffer)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 SubKeyLinkage,
                 0,
                 KEY_READ,
                 &Key);

    if (status == ERROR_SUCCESS)
    {
        // now read the linkage values
        while (pBuffer && ((status = RegQueryValueEx( Key,
                                          Linkage,
                                          NULL,
                                          &Type,
                                          pBuffer,
                                          &size)) == ERROR_MORE_DATA))
        {
            // Get a buffer that is big enough.
            size += 512;
            pBuffer = realloc( pBuffer, size );
        }

        if (status == ERROR_SUCCESS)
        {
            PUCHAR  curPtr=pBuffer;
            LONG    index=0;

            //
            // Copy over all the export keys
            //
            while((*curPtr) && (index < NBT_MAXIMUM_BINDINGS))
            {
                if (!(pDeviceName[index] = malloc (sizeof(WCHAR) * (wcslen((PWCHAR)curPtr) + 1))))
                {
                    break;
                }
                wcscpy(pDeviceName[index],(PWCHAR)curPtr);
                ++index;
                curPtr += sizeof(WCHAR) * (wcslen((PWCHAR)curPtr) + 1);
            }

        }

        status2 = RegCloseKey(Key);
    }

    if (pBuffer)
    {
        free (pBuffer);
    }

    return(status);

}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN  WCHAR  *path[],
    OUT PHANDLE pHandle
    )

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    while ((path[index]) && (index < NBT_MAXIMUM_BINDINGS))
    {
        RtlInitUnicodeString(&uc_name_string,path[index]);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(NO_ERROR);
        }

        ++index;
    }

    return(ERROR_FILE_NOT_FOUND);

}
//------------------------------------------------------------------------
LONG
PostForGetHostByName(
    IN HANDLE           fd
    )

/*++

Routine Description:

    This procedure passes a buffer down to Netbt for it to return when it
    wants a name resolved via DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG        status = ERROR_FILE_NOT_FOUND;
    CHAR        Buffer;


    if (!pIpAddrBuffer)
    {
        if (!(pIpAddrBuffer = LocalAlloc(LMEM_FIXED,sizeof(tIPADDR_BUFFER_DNS))))
        {
            DBG_PRINT ("lmhsvc: failed to send irp due to error = %x\n",status);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pIpAddrBuffer->Resolved = FALSE;
        pIpAddrBuffer->IpAddrsList[0] = 0;  // for DBG
    }

    status = DeviceIoCtrl (fd,
                           pIpAddrBuffer,
                           sizeof(tIPADDR_BUFFER_DNS),
                           IOCTL_NETBT_DNS_NAME_RESOLVE,
                           0);   // hard coded thread Index

    return(status);
}

LONG
PostForCheckIPAddr(
    IN HANDLE           fd
    )

/*++

Routine Description:

    This procedure passes a buffer down to Netbt for it to return when it
    wants a name resolved via DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG        status = ERROR_FILE_NOT_FOUND;
    CHAR        Buffer;

    if (!pIpAddrBufferChkIP)
    {
        if (!(pIpAddrBufferChkIP = LocalAlloc(LMEM_FIXED,sizeof(tIPADDR_BUFFER_DNS))))
        {
            DBG_PRINT ("lmhsvc: failed to send irp due to error = %x\n",status);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pIpAddrBufferChkIP->Resolved = FALSE;
        pIpAddrBufferChkIP->IpAddrsList[0] = 0;     // for DBG
    }

    status = DeviceIoCtrl (fd,
                           pIpAddrBufferChkIP,
                           sizeof(tIPADDR_BUFFER_DNS),
                           IOCTL_NETBT_CHECK_IP_ADDR,
                           1);   // hard coded thread Index

    if (Trace)
    {
        DbgPrint("LMHSVC: Entered PostForCheckIPAddr. status: %lx\n", status);
    }

    return(status);
}

GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;

VOID
GetHostNameCopyBack(
    tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    PWSAQUERYSETW   pwsaq
    )
{
    //
    // success, fetch the CSADDR  structure
    //
    PCSADDR_INFO    pcsadr;
    ULONG       GoodAddr;
    NTSTATUS    Status;
    int         i = 0;
    int         imax = min(MAX_IPADDRS_PER_HOST, pwsaq->dwNumberOfCsAddrs);

    pcsadr = pwsaq->lpcsaBuffer;
    if (pwsaq->lpszServiceInstanceName) {
        wcsncpy(pIpAddrBuffer->pwName, pwsaq->lpszServiceInstanceName, DNS_NAME_BUFFER_LENGTH);
        pIpAddrBuffer->pwName[DNS_NAME_BUFFER_LENGTH-1] = 0;
        pIpAddrBuffer->NameLen = wcslen(pIpAddrBuffer->pwName) * sizeof(WCHAR);
        if (Trace) {
            DbgPrint("Lmhsvc: Resolved name = \"%ws\"\n", pIpAddrBuffer->pwName);
        }
    }

    if (pIpAddrBuffer->Resolved) {
        /* In this case, we have been called before. No need to copy the IPs back again. */
        /* But we do need to copy the name back since it is the alias name that KsecDD requires */
        return;
    }

    for(i=0; i<imax; i++, pcsadr++)
    {
        PSOCKADDR_IN sockaddr;

        sockaddr = (PSOCKADDR_IN)pcsadr->RemoteAddr.lpSockaddr;
        pIpAddrBuffer->IpAddrsList[i] = htonl( sockaddr->sin_addr.s_addr);
        if (Trace)
        {
            DbgPrint("LmhSvc: Dns IpAddrsList[%d/%d] =%x\n",
                (i+1),imax,pIpAddrBuffer->IpAddrsList[i]);
        }
    }
    pIpAddrBuffer->IpAddrsList[i] = 0;

    //
    // Check the IP addr list.
    //
    Status = CheckIPAddresses(pIpAddrBuffer, &GoodAddr, FALSE);
    if (Status == NO_ERROR)
    {
        pIpAddrBuffer->Resolved = TRUE;
        pIpAddrBuffer->IpAddrsList[0] = htonl(GoodAddr);
        pIpAddrBuffer->IpAddrsList[1] = 0;
        if (Trace)
        {
            DbgPrint("LmhSvc: SUCCESS -- Dns address = <%x>\n", pIpAddrBuffer->IpAddrsList[0]);
        }
    }
    else
    {
        pIpAddrBuffer->IpAddrsList[0] = 0;
        if (Trace)
        {
            DbgPrint("LmhSvc: CheckIPAddresses returned <%x>\n", Status);
        }
    }
}


//------------------------------------------------------------------------
LONG
GetHostName(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    )

/*++

Routine Description:

    This procedure attempts to resolve a name using the Resolver through
    the Sockets interface to DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG            status;
    ULONG           NameLen;
    ULONG           IpAddr;
    PWSAQUERYSETW   pwsaq = (PWSAQUERYSETW) pWSABuffer;
    INT             err;
    HANDLE          hRnR;
    PWSTR           szHostnameW;
    BYTE            *pAllocatedBuffer = NULL;
    DWORD           dwLength;

    pIpAddrBuffer->Resolved = FALSE;

    // Hostname is encoded with OEMCP, so we convert from OEMCP->Unicode
    if (pIpAddrBuffer->bUnicode) {
        NameLen = pIpAddrBuffer->NameLen;
        ASSERT((NameLen % sizeof(WCHAR)) == 0);
        NameLen /= sizeof(WCHAR);
    } else {
        WCHAR   uncName[DNS_NAME_BUFFER_LENGTH];

        ASSERT(pIpAddrBuffer->NameLen < DNS_NAME_BUFFER_LENGTH);
        pIpAddrBuffer->pName[pIpAddrBuffer->NameLen] = 0;
        MultiByteToWideChar (CP_OEMCP, 0, pIpAddrBuffer->pName, -1, uncName, sizeof(uncName)/sizeof(WCHAR));
        NameLen = wcslen(uncName);
        memcpy (pIpAddrBuffer->pwName, uncName, NameLen * sizeof(WCHAR));
        pIpAddrBuffer->pwName[NameLen] = 0;
    }
    szHostnameW = pIpAddrBuffer->pwName;

    // truncate spaces from the end for netbios names
    //
    if (NameLen < NETBIOS_NAMESIZE)
    {
        //
        // Start from the end and find the first non-space character
        //
        NameLen = NETBIOS_NAMESIZE-1;
        while ((NameLen) && (szHostnameW[NameLen-1] == 0x20))
        {
            NameLen--;
        }
        szHostnameW[NameLen] = '\0';
    }

    if (!NameLen || !SocketsUp) {
        if (Trace) {
            DbgPrint("Lmhsvc: Failed to Resolve name, NameLen=<%d>\n", NameLen);
        }
        goto label_exit;
    }

    //
    // do a lookup using RNR
    //

    if (Trace) {
        DbgPrint("Lmhsvc: Resolving name = \"%ws\", NameLen=<%d>\n", szHostnameW, NameLen);
    }

    RtlZeroMemory(pwsaq, sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = szHostnameW;
    pwsaq->lpServiceClassId = &HostnameGuid;
    pwsaq->dwNameSpace = NS_DNS;

    err = WSALookupServiceBeginW (pwsaq, LUP_RETURN_NAME| LUP_RETURN_ADDR| LUP_RETURN_ALIASES, &hRnR);
    if(err != NO_ERROR) {
        if (Trace) {
            DbgPrint("LmhSvc: WSALookupServiceBeginA returned <%x>, Error=<%d>\n", err, GetLastError());
        }
        goto label_exit;
    }

    //
    // The query was accepted, so execute it via the Next call.
    //
    dwLength = WSA_QUERY_BUFFER_LENGTH;
    err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
    if (err != NO_ERROR)
    {
        err = GetLastError();
    } else if (pwsaq->dwNumberOfCsAddrs) {
        GetHostNameCopyBack(pIpAddrBuffer, pwsaq);

        /* check if there is any alias available */
        err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
        if (err != NO_ERROR) {
            err = GetLastError();
            if (err != WSAEFAULT) {
                err = NO_ERROR;         // Ignore this error
            }
        } else if (pwsaq->dwOutputFlags & RESULT_IS_ALIAS) {
            GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
        }
    }

    WSALookupServiceEnd (hRnR);
    if ((WSAEFAULT == err) &&
        (pAllocatedBuffer = malloc(2*dwLength)))
    {
        if (Trace)
        {
            DbgPrint("\tLmhsvc: WSALookupServiceNextW ==> WSAEFAULT: Retrying, BufferLength=<%d>-><2*%d> ...\n",
                WSA_QUERY_BUFFER_LENGTH, dwLength);
        }

        dwLength *= 2;
        pwsaq = (PWSAQUERYSETW) pAllocatedBuffer;
        RtlZeroMemory(pwsaq, sizeof(*pwsaq));
        pwsaq->dwSize = sizeof(*pwsaq);
        pwsaq->lpszServiceInstanceName = szHostnameW;
        pwsaq->lpServiceClassId = &HostnameGuid;
        pwsaq->dwNameSpace = NS_DNS;

        err = WSALookupServiceBeginW(pwsaq, LUP_RETURN_NAME| LUP_RETURN_ADDR| LUP_RETURN_ALIASES, &hRnR);
        if(err == NO_ERROR)
        {
            err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
            if (err == NO_ERROR && pwsaq->dwNumberOfCsAddrs) {
                GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
                if (WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq) == NO_ERROR) {
                    if (pwsaq->dwOutputFlags & RESULT_IS_ALIAS) {
                        GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
                    }
                }
            }
            WSALookupServiceEnd (hRnR);
        }
    }

    if (err != NO_ERROR)
    {
        if (Trace)
        {
            DbgPrint("LmhSvc: WSALookupServiceNextW returned <%x>, NumAddrs=<%d>, Error=<%d>, dwLength=<%d>\n",
                err, pwsaq->dwNumberOfCsAddrs, GetLastError(), dwLength);
        }
    }

label_exit:
    if (pAllocatedBuffer) {
        free(pAllocatedBuffer);
    }

    status = PostForGetHostByName(fd);
    return(status);
}

#include    <ipexport.h>
#include    <icmpapi.h>

#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               2
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             2000L           // default timeout set to 2 secs.

LONG
CheckIPAddresses(
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    IN ULONG   *IpAddr,
    IN BOOLEAN  fOrdered
    )

/*++

Routine Description:

    This function checks a list of IP addrs for reachability by pinging each in turn
    until a successful one is found. This function assumes that the list of addresses
    is terminated by a 0 address.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/
{
    ULONG   i;
    ULONG   *pIpAddrs;
    HANDLE  IcmpHandle;
    PUCHAR  pSendBuffer;
    PUCHAR  pRcvBuffer;
    ULONG   address = 0;
    ULONG   result;
    ULONG   status;
    ULONG   numberOfReplies;
    IP_OPTION_INFORMATION SendOpts;

    if (!(pSendBuffer = malloc(DEFAULT_SEND_SIZE)) ||
        (!(pRcvBuffer = malloc(DEFAULT_BUFFER_SIZE))))
    {
        if (Trace)
        {
            DbgPrint("LmhSvc.CheckIPAddresses: ERROR -- malloc failed for %s\n",
                (pSendBuffer ? "pRcvBuffer" : "pSendBuffer"));
        }

        if (pSendBuffer)
        {
            free (pSendBuffer);
        }

        return -1;
    }

    //
    // Open channel
    //
    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE)
    {
        DBG_PRINT ( "Unable to contact IP driver, error code %d.\n", GetLastError() );
        free (pSendBuffer);
        free (pRcvBuffer);
        return -1;
    }

    //
    // init to the first address.
    //
    pIpAddrs = pIpAddrBuffer->IpAddrsList;
    *IpAddr = (fOrdered) ? *pIpAddrs : htonl(*pIpAddrs);

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < DEFAULT_SEND_SIZE; i++)
    {
        pSendBuffer[i] = (UCHAR)('A' + (i % 23));
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = DEFAULT_TTL;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = 0;

    //
    // For each IP address in the list
    //
    while (*pIpAddrs)
    {
        struct in_addr addr;

        address = (fOrdered) ? *pIpAddrs : htonl(*pIpAddrs);
        addr.s_addr = address;

        if (address == INADDR_BROADCAST)
        {
            if (Trace)
            {
                DbgPrint("LmhSvc: Cannot ping a Broadcast address = <%s>\n", inet_ntoa(addr));
            }

            pIpAddrs++;
            continue;
        }

        for (i=0; i < DEFAULT_COUNT; i++)
        {
            if (Trace)
            {
                DbgPrint("LmhSvc: Pinging <%s>\n", inet_ntoa(addr));
            }

            numberOfReplies = IcmpSendEcho (IcmpHandle,
                                            address,
                                            pSendBuffer,
                                            (unsigned short) DEFAULT_SEND_SIZE,
                                            &SendOpts,
                                            pRcvBuffer,
                                            DEFAULT_BUFFER_SIZE,    // pRcvBuffer size!
                                            DEFAULT_TIMEOUT);
            //
            // If ping successful, return the IP address
            //
            if (numberOfReplies != 0)
            {
                PICMP_ECHO_REPLY    reply;

                reply = (PICMP_ECHO_REPLY) pRcvBuffer;
                if (reply->Status == IP_SUCCESS)
                {
                    if (Trace)
                    {
                        DbgPrint("LmhSvc: SUCCESS: Received <%d> replies after Pinging <%s>\n",
                            numberOfReplies, inet_ntoa(addr));
                    }
                    result = IcmpCloseHandle(IcmpHandle);
                    *IpAddr = address;
                    free (pSendBuffer);
                    free (pRcvBuffer);
                    return 0;
                }
            }
        }

        if (Trace)
        {
            DbgPrint("LmhSvc: FAILed: Pinging <%s>\n", inet_ntoa(addr));
        }

        pIpAddrs++;
    }

    result = IcmpCloseHandle(IcmpHandle);

    //
    // Return the first addr if none matched in the hope that TCP session setup might succeed even though
    // the pings failed.
    //

    free (pSendBuffer);
    free (pRcvBuffer);

    return NO_ERROR;
}

ULONG
VerifyIPAddresses(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    )
/*++

Routine Description:

    This function finds out the reachable IP addr and returns the Irp to Netbt

Arguments:


Return Value:

    NONE

--*/
{
    DWORD   Status;
    ULONG  GoodAddr;

    pIpAddrBuffer->Resolved = FALSE;
    Status = CheckIPAddresses(pIpAddrBuffer, &GoodAddr, TRUE);

    if (Status == NO_ERROR) {
        pIpAddrBuffer->IpAddrsList[0] = ntohl(GoodAddr);
        //
        // NULL terminate
        //
        pIpAddrBuffer->IpAddrsList[1] = 0;
        pIpAddrBuffer->Resolved = TRUE;
    } else {
        pIpAddrBuffer->IpAddrsList[0] = 0;
    }

    Status = PostForCheckIPAddr(fd);

    return  Status;
}


VOID
CheckIPAddrWorkerRtn(
    IN  LPVOID  lpParam
    )
/*++

Routine Description:

    This function submits IP address check Irps into Netbt, on completion of the Irp, it submits the IP address
    list to CheckIPAddresses.

Arguments:


Return Value:

    NONE

--*/
{
    HANDLE  EventList[2];
    DWORD   status;
    HANDLE  hNbt;
    ULONG   EventCount;
    LONG    err;
    LONG    Value;

    LARGE_INTEGER Timeout = RtlEnlargedIntegerMultiply (-10 * 60, 1000 * 1000 * 10); // 10 minutes

    assert(**lpParam == 1);

    //
    // ignore the return code from resyncNbt().
    //
    // In most cases (no domains spanning an ip router), it is not a
    // catastrophe if nbt.sys couldn't successfully process the NBT_RESYNC
    // ioctl command.  Since I'm ignoring the return, I announce I'm running
    // before I call it to allow other dependent services to start.
    //
    //
    status = PrimeCacheNbt(&hNbt, 1);

    if (Trace)
    {
        DbgPrint("LMHSVC: Entered CheckIPAddrWorkerRtn, hNbt %lx.\n", hNbt);
    }

    if (hNbt != (HANDLE)-1)
    {
        status = PostForCheckIPAddr(hNbt);
        if (status == NO_ERROR)
        {
            EventCount = 2;
        }
        else
        {
            if (Trace)
            {
                DbgPrint("Lmhsvc:Error posting Irp for get host by name\n");
            }

            EventCount = 1;
        }
    }
    else
    {
        EventCount = 1;
    }
    //
    // "A SERVICE_MAIN_FUNCTION does not return until the service is ready
    // to terminate."
    //
    // (ref: api32wh.hlp, SERVICE_MAIN_FUNCTION)
    //
    //
    assert(Poison[1]);
    EventList[0] = Poison[1];
    EventList[1] = NbtEvent[1];

    while (TRUE)
    {
        status = NtWaitForMultipleObjects(
                        EventCount,
                        EventList,
                        WaitAny,              // wait for any event
                        FALSE,
                        (EventCount == 1)? &Timeout: NULL);

        if (status == WAIT_TIMEOUT)
        {
            if (hNbt == (HANDLE)-1)
            {
                PrimeCacheNbt(&hNbt, 1);
                if (hNbt == (HANDLE)-1)
                {
                    continue; // to wait
                }
            }
            status = PostForCheckIPAddr(hNbt); // try again
            if (status == NO_ERROR)
            {
                EventCount = 2;
            }
        }
        else if (status == 1)
        {

            if (Trace)
            {
                DbgPrint("LMHSVC: Doing VerifyAddr\n");
            }
            // the irp used for gethostby name has returned
            status = VerifyIPAddresses(hNbt, pIpAddrBufferChkIP);

            //
            // disable the get host by name stuff if we have an error
            // posting a buffer to the transport
            //
            if (status != NO_ERROR)
            {
                EventCount = 1;
            }
        }
        else
        {
            // it must have been a the Poison event signalling the end of the
            // the service, so exit after getting the Irp back from the
            // transport.  This system will look after canceling the IO and
            // getting the Irp back.

            NtClose(Poison[1]);
            NtClose(NbtEvent[1]);
            NtClose(hNbt);
            break;
        }

    }

    if (Trace)
    {
        DBG_PRINT ("LMHSVC: Exiting [CheckIPAddrWorkerRtn] now!\n");
    }

    ExitThread(NO_ERROR);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\nbtstat\vxdtxt.h ===
//
//  These strings have been pulled from localmsg.mc for NT.  Attempt is made
//  to keep these strings in exactly the same format as in NT.  This is the
//  extent of localization we can have in the vxd world.
//

#define COMMON_UNABLE_TO_ALLOCATE_PACKET   "\nUnable to allocate packet"

#define IDS_FAILURE_NBT_DRIVER  "\nFailed to access NBT driver"

#define IDS_BLANK   " "

#define IDS_NETBIOS_LOCAL_STATUS  "\n\
            NetBIOS Local Name Table\n\
\n\
   Name               Type         Status\n\
---------------------------------------------\n"

#define IDS_STATUS_FIELDS  "\nNode IpAddress: [%s] Scope Id: [%s]"

#define IDS_NONAMES_INCACHE  "No names in cache"

#define IDS_NO_CONNECTIONS   "\nNo Connections"

#define IDS_NETBIOS_CONNECTION_STATUS  "\n\
                 NetBIOS Connection Table\n\
\n\
Local Name             State    In/Out  Remote Host           Input   Output\n\
----------------------------------------------------------------------------\n"

#define IDS_MACHINE_NOT_FOUND   "Host not found."

#define IDS_MAC_ADDRESS         "\nMAC Address = %s"

#define IDS_BAD_IPADDRESS   \
"\nThe IP address is not in the correct format. It needs to be\n\
dotted decimal, for example 11.11.12.13\n\
You entered \"%s\""

#define IDS_REMOTE_NAMES   \
"\n       NetBIOS Remote Machine Name Table\n\
\n\
   Name               Type         Status\n\
---------------------------------------------\n"

#define IDS_NETBIOS_REMOTE_STATUS   "\n\
              NetBIOS Remote Cache Name Table\n\
\n\
    Name              Type       Host Address    Life [sec]\n\
------------------------------------------------------------\n"

#define IDS_RESYNC_OK   "\n\
Successful purge and preload of the NBT Remote Cache Name Table."

#define IDS_RESYNC_FAILED   "\n\
Failed to Purge the NBT Remote Cache Table."

#define IDS_NETBIOS_OUTBOUND   "  Out"

#define IDS_NETBIOS_INBOUND    "  In"

#define IDS_RECONNECTING   "Reconnect"

#define IDS_IDLE           "Idle"

#define IDS_ASSOCIATED     "Associated"

#define IDS_CONNECTING     "Connecting"

#define IDS_OUTGOING       "Out-going"

#define IDS_INCOMING       "In-coming"

#define IDS_ACCEPTING      "Accepting"

#define IDS_CONNECTED      "Connected"

#define IDS_DISCONNECTING  "Disconnecting"

#define IDS_DISCONNECTED   "Disconnected"

#define IDS_LISTENING      "Listening"

#define IDS_UNBOUND        "Unbound"

#define IDS_CONFLICT_DEREGISTERED   "Conflict - Deregistered"

#define IDS_CONFLICT                "Conflict"

#define IDS_REGISTERING             "Registering"

#define IDS_REGISTERED              "Registered"

#define IDS_DEREGISTERED            "Deregistered"

#define IDS_DONT_KNOW               "??"

#define IDS_BCAST_NAMES_HEADER      "\n\
\n\
    NetBIOS Names Resolved By Broadcast\n\
---------------------------------------------\n"

#define IDS_NUM_BCAST_QUERIES   "\nResolved By Broadcast     = %s"

#define IDS_NUM_BCAST_REGISTRATIONS   "\nRegistered By Broadcast   = %s"

#define IDS_NUM_WINS_QUERIES    "\nResolved By Name Server   = %s"

#define IDS_NUM_WINS_REGISTRATIONS   "\nRegistered By Name Server = %s"

#define IDS_BCASTNAMES_FAILED   "\n\
Retrieval of Broadcast Resolved names failed."

#define IDS_NAME_STATS   "\n\
\n\
NetBIOS Names Resolution and Registration Statistics\n\
----------------------------------------------------\n"

#define IDS_USAGE  \
"\n\
Displays protocol statistics and current TCP/IP connections using NBT\
(NetBIOS over TCP/IP).\
\n\
NBTSTAT [-a RemoteName] [-A IP address] [-c] [-n]\n\
        [-r] [-R] [-s] [S] [interval] ]\n\
  -a   (adapter status) Lists the remote machine's name table given its name\n\
  -A   (Adapter status) Lists the remote machine's name table given its\n\
                        IP address.\n\
  -c   (cache)          Lists the remote name cache including the IP addresses\n\
  -n   (names)          Lists local NetBIOS names.\n\
  -r   (resolved)       Lists names resolved by broadcast and via WINS\n\
  -R   (Reload)         Purges and reloads the remote cache name table\n\
  -S   (Sessions)       Lists sessions table with the destination IP addresses\n\
  -s   (sessions)       Lists sessions table converting destination IP\n\
                        addresses to host names via the hosts file.\n\
\n\
  RemoteName   Remote host machine name.\n\
  IP address   Dotted decimal representation of the IP address.\n\
  interval     Redisplays selected statistics, pausing interval seconds\n\
               between each display. Press Ctrl+C to stop redisplaying\n\
               statistics.\n"

#define IDS_PLAIN_STRING "%s"
#define IDS_NEWLINE      "\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\nbtstat\vxdonly.h ===
#ifdef VXD

#ifndef _NBT_H
#define _NBT_H

//
// lifted from windef.h and ntdef.h
//
#define VOID           void
typedef void          *PVOID;
typedef char           CHAR;
typedef CHAR          *PCHAR;
typedef unsigned char  UCHAR;
typedef UCHAR         *PUCHAR;
typedef short          SHORT;
typedef unsigned short USHORT;
typedef USHORT        *PUSHORT;
typedef unsigned long  ULONG;
typedef ULONG         *PULONG;
typedef unsigned long  DWORD;
typedef int            BOOL;
typedef UCHAR          BOOLEAN;
typedef unsigned char  BYTE;
typedef unsigned short WORD;

#define APIENTRY       WINAPI
#define IN
#define OUT
#define STDOUT         stdout
#define STDERR         stderr


#include <windows.h>
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include <varargs.h>
#include <stdarg.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nb30.h>

//
// This lifted straight from miniport.h
//
typedef double LONGLONG;
#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

//
//  These definitions work around NTisms found in various difficult to change
//  places.
//

typedef ULONG NTSTATUS ;
typedef PNCB  PIRP ;
typedef PVOID PDEVICE_OBJECT ;


#include <tdi.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <nbtioctl.h>
#include <netvxd.h>
#include <winsock.h>
#include <assert.h>


//
//  These are needed because we include windef.h rather then
//  ntddk.h, which end up not being defined
//  Also, from ntdef.h and ntstatus.h
//
#define NT_SUCCESS(err)                 ((err==TDI_SUCCESS)||(err==TDI_PENDING))

#define STATUS_SUCCESS                  0
#define STATUS_BUFFER_OVERFLOW          9
#define STATUS_INVALID_PARAMETER        10
#define STATUS_INSUFFICIENT_RESOURCES   1

#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0xC0000001L)

#define CTRL_C   3

#endif  // _NBT_H

#endif  // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\hashtbl.c ===
//
//
//  hashtbl.c
//
//  This file contains the name code to implement the local and remote
//  hash tables used to store local and remote names to IP addresses
//  The hash table should not use more than 256 buckets since the hash
//  index is only calculated to one byte!

#include "precomp.h"


VOID DestroyHashTable(IN PHASHTABLE pHashTable);

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, CreateHashTable)
#pragma CTEMakePageable(PAGE, DestroyHashTables)
#pragma CTEMakePageable(PAGE, DestroyHashTable)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
CreateHashTable(
    tHASHTABLE          **pHashTable,
    LONG                lNumBuckets,
    enum eNbtLocation   LocalRemote
    )
/*++

Routine Description:

    This routine creates a hash table uTableSize long.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    ULONG       uSize;
    LONG        i;
    NTSTATUS    status;

    CTEPagedCode();

    uSize = (lNumBuckets-1)*sizeof(LIST_ENTRY) + sizeof(tHASHTABLE);

    *pHashTable = (tHASHTABLE *) NbtAllocMem (uSize, NBT_TAG2('01'));

    if (*pHashTable)
    {
        // initialize all of the buckets to have null chains off of them
        for (i=0;i < lNumBuckets ;i++ )
        {
            InitializeListHead(&(*pHashTable)->Bucket[i]);
        }

        (*pHashTable)->LocalRemote = LocalRemote;
        (*pHashTable)->lNumBuckets = lNumBuckets;
        status = STATUS_SUCCESS;
    }
    else
    {
        IF_DBG(NBT_DEBUG_HASHTBL)
            KdPrint(("Nbt.CreateHashTable: Unable to create hash table\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


#ifdef _PNP_POWER_
VOID
DestroyHashTable(
    IN PHASHTABLE pHashTable
    )
{
    LONG            i, j;
    tNAMEADDR       *pNameAddr;
    LIST_ENTRY      *pEntry;

    CTEPagedCode();

    if (pHashTable == NULL) {
        return;
    }

    /*
     * Go through all the buckets to see if there are any names left
     */
    for (i = 0; i < pHashTable->lNumBuckets; i++) {
        while (!IsListEmpty(&(pHashTable->Bucket[i]))) {
            pEntry = RemoveHeadList(&(pHashTable->Bucket[i]));
            pNameAddr = CONTAINING_RECORD(pEntry, tNAMEADDR, Linkage);

            IF_DBG(NBT_DEBUG_HASHTBL)
                KdPrint (("netbt!DestroyHashTable:  WARNING! Freeing Name: <%16.16s:%x>\n",
                    pNameAddr->Name, pNameAddr->Name[15]));

            /*
             * Notify deferencer not to do RemoveListEntry again becaseu we already do it above.
             */
            if (pNameAddr->Verify == REMOTE_NAME && (pNameAddr->NameTypeState & PRELOADED)) {
                ASSERT(pNameAddr->RefCount == 2);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED, FALSE);
            }
            ASSERT(pNameAddr->RefCount == 1);
            pNameAddr->Linkage.Flink = pNameAddr->Linkage.Blink = NULL;
            NBT_DEREFERENCE_NAMEADDR(pNameAddr,((pNameAddr->Verify==LOCAL_NAME)?REF_NAME_LOCAL:REF_NAME_REMOTE),FALSE);
        }
    }
    CTEMemFree(pHashTable);
}

//----------------------------------------------------------------------------
VOID
DestroyHashTables(
    )
/*++

Routine Description:

    This routine destroys a hash table and frees the entries in NumBuckets
    It Must be called with the NbtConfig lock held!

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{

    CTEPagedCode();
    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("netbt!DestroyHashTables: destroying remote hash table ..."));
    DestroyHashTable(NbtConfig.pRemoteHashTbl);
    NbtConfig.pRemoteHashTbl = NULL;

    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("\nnetbt!DestroyHashTables: destroying local hash table ..."));
    DestroyHashTable(NbtConfig.pLocalHashTbl);
    NbtConfig.pLocalHashTbl = NULL;
    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("\n"));
}
#endif  // _PNP_POWER_


//----------------------------------------------------------------------------
NTSTATUS
NbtUpdateRemoteName(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN tNAMEADDR        *pNameAddrNew,
    IN tNAMEADDR        *pNameAddrDiscard,
    IN USHORT           NameAddFlags
    )
{
    tIPADDRESS      IpAddress;
    tIPADDRESS      *pLmhSvcGroupList = NULL;
    tIPADDRESS      *pOrigIpAddrs = NULL;
    ULONG           AdapterIndex = 0;  // by default
    ULONG           i;

    ASSERT (pNameAddrNew);
    //
    // See if we need to grow the IP addrs cache for the cached name
    //
    if (pNameAddrNew->RemoteCacheLen < NbtConfig.RemoteCacheLen) {
        tADDRESS_ENTRY  *pRemoteCache;
        pRemoteCache = (tADDRESS_ENTRY *)NbtAllocMem(NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY),NBT_TAG2('02'));
        if (pRemoteCache) {
            CTEZeroMemory(pRemoteCache, NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY));

            /*
             * Copy data from and free the previous cache (if any)
             */
            if (pNameAddrNew->pRemoteIpAddrs) {
                CTEMemCopy (pRemoteCache, pNameAddrNew->pRemoteIpAddrs,
                        sizeof(tADDRESS_ENTRY) * pNameAddrNew->RemoteCacheLen);

                CTEFreeMem (pNameAddrNew->pRemoteIpAddrs)
            }

            pNameAddrNew->pRemoteIpAddrs = pRemoteCache;
            pNameAddrNew->RemoteCacheLen = NbtConfig.RemoteCacheLen;
        } else {
            KdPrint(("Nbt.NbtUpdateRemoteName:  FAILed to expand Cache entry!\n"));
        }
    }

    //
    // If the new entry being added replaces an entry which was
    // either pre-loaded or set by a client, and the new entry itself
    // does not have that flag set, then ignore this update.
    //
    ASSERT (NAME_RESOLVED_BY_DNS > NAME_RESOLVED_BY_LMH_P);     // For the check below to succeed!

    if (((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_CLIENT) !=
         (NameAddFlags & NAME_RESOLVED_BY_CLIENT)) ||
        ((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_LMH_P) > 
         (NameAddFlags & (NAME_RESOLVED_BY_LMH_P | NAME_RESOLVED_BY_DNS))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    if (pNameAddrDiscard)
    {
        IpAddress = pNameAddrDiscard->IpAddress;
        pLmhSvcGroupList = pNameAddrDiscard->pLmhSvcGroupList;
        pNameAddrDiscard->pLmhSvcGroupList = NULL;
        pNameAddrNew->TimeOutCount  = NbtConfig.RemoteTimeoutCount; // Reset it since we are updating it!
        pOrigIpAddrs = pNameAddrDiscard->pIpAddrsList;
    }
    else
    {
        IpAddress = pNameAddrNew->IpAddress;
        pLmhSvcGroupList = pNameAddrNew->pLmhSvcGroupList;
        pNameAddrNew->pLmhSvcGroupList = NULL;
    }

    if ((NameAddFlags & (NAME_RESOLVED_BY_DNS | NAME_RESOLVED_BY_CLIENT | NAME_RESOLVED_BY_IP)) &&
        (pNameAddrNew->RemoteCacheLen))
    {
        ASSERT (!pLmhSvcGroupList);
        pNameAddrNew->pRemoteIpAddrs[0].IpAddress = IpAddress;

        if ((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_LMH_P) &&
            (NameAddFlags & NAME_RESOLVED_BY_DNS))
        {
            //
            // If the name was resolved by DNS, then don't overwrite the
            // name entry if it was pre-loaded below
            //
            pNameAddrNew->NameAddFlags |= NameAddFlags;
            return (STATUS_SUCCESS);
        }
    }

    if ((pDeviceContext) &&
        (!IsDeviceNetbiosless(pDeviceContext)) &&
        (pDeviceContext->AdapterNumber < pNameAddrNew->RemoteCacheLen))
    {
        AdapterIndex = pDeviceContext->AdapterNumber;
        pNameAddrNew->AdapterMask |= pDeviceContext->AdapterMask;

        if (IpAddress)
        {
            pNameAddrNew->IpAddress = IpAddress;    // in case we are copying from pNameAddrDiscard
            pNameAddrNew->pRemoteIpAddrs[AdapterIndex].IpAddress = IpAddress;  // new addr
        }


        //
        // Now see if we need to update the Original IP addresses list!
        //
        if (pOrigIpAddrs)
        {
            // pOrigIpAddrs could only have been set earlier if it was obtained from pNameAddrDiscard!
            pNameAddrDiscard->pIpAddrsList = NULL;
        }
        else if (pOrigIpAddrs = pNameAddrNew->pIpAddrsList)
        {
            pNameAddrNew->pIpAddrsList = NULL;
        }

        if (pOrigIpAddrs)
        {
            if (pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs)
            {
                CTEFreeMem (pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs);
            }
            pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs = pOrigIpAddrs;
        }
    }

    if (pLmhSvcGroupList)
    {
        ASSERT(NameAddFlags == (NAME_RESOLVED_BY_LMH_P|NAME_ADD_INET_GROUP));
        if (pNameAddrNew->pLmhSvcGroupList) {
            CTEFreeMem (pNameAddrNew->pLmhSvcGroupList);
        }

        pNameAddrNew->pLmhSvcGroupList = pLmhSvcGroupList;
    }

    pNameAddrNew->NameAddFlags |= NameAddFlags;

    return (STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
LockAndAddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    )
{
    NTSTATUS        status;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    status = AddToHashTable(pHashTable,
                            pName,
                            pScope,
                            IpAddress,
                            NameType,
                            pNameAddr,
                            ppNameAddress,
                            pDeviceContext,
                            NameAddFlags);

    CTESpinFree (&NbtConfig.JointLock, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
AddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    )
/*++

Routine Description:

    This routine adds a name to IPaddress to the hash table
    Called with the spin lock HELD.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tNAMEADDR           *pNameAddress;
    tNAMEADDR           *pScopeAddr;
    NTSTATUS            status;
    ULONG               iIndex;
    CTELockHandle       OldIrq;
    ULONG               i, OldRemoteCacheLen;
    tNAMEADDR           *pNameAddrFound;
    tADDRESS_ENTRY      *pRemoteCache = NULL;
    BOOLEAN             fNameIsAlreadyInCache;
    tIPADDRESS          OldIpAddress;

    if (pNameAddr)
    {
        ASSERT ((pNameAddr->Verify == LOCAL_NAME) || (pNameAddr->Verify == REMOTE_NAME));
    }

    fNameIsAlreadyInCache = (STATUS_SUCCESS == FindInHashTable(pHashTable,pName,pScope,&pNameAddrFound));

    if ((fNameIsAlreadyInCache) &&
        (pNameAddrFound->Verify == REMOTE_NAME) &&
        !(pNameAddrFound->NameTypeState & STATE_RELEASED))
    {
        OldIpAddress = pNameAddrFound->IpAddress;
        pNameAddrFound->IpAddress = IpAddress;

        if (!(NameAddFlags & NAME_ADD_IF_NOT_FOUND_ONLY) &&
            ((pNameAddr) ||
             !(pNameAddrFound->NameAddFlags & NAME_ADD_INET_GROUP)))
        {
            //
            // We have a valid existing name, so just update it!
            //
            status = NbtUpdateRemoteName(pDeviceContext, pNameAddrFound, pNameAddr, NameAddFlags);
            if (!NT_SUCCESS (status))
            {
                //
                // We Failed most problably because we were not allowed to
                // over-write or modify the current entry for some reason.
                // So, reset the old IpAddress
                //
                pNameAddrFound->IpAddress = OldIpAddress;
            }
        }

        if (pNameAddr)
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        else
        {
            ASSERT (!(NameAddFlags & NAME_ADD_INET_GROUP));
        }

        if (ppNameAddress)
        {
            *ppNameAddress = pNameAddrFound;
        }

        // found it in the table so we're done - return pending to
        // differentiate from the name added case. Pending passes the
        // NT_SUCCESS() test as well as Success does.
        //
        return (STATUS_PENDING);
    }

    // first hash the name to an index
    // take the lower nibble of the first 2 characters.. mod table size
    iIndex = ((pName[0] & 0x0F) << 4) + (pName[1] & 0x0F);
    iIndex = iIndex % pHashTable->lNumBuckets;

    CTESpinLock(&NbtConfig,OldIrq);

    if (!pNameAddr)
    {
        //
        // Allocate memory for another hash table entry
        //
        pNameAddress = (tNAMEADDR *)NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('0'));
        if ((pNameAddress) &&
            (pHashTable->LocalRemote == NBT_REMOTE) &&
            (NbtConfig.RemoteCacheLen) &&
            (!(pRemoteCache = (tADDRESS_ENTRY *)
                                NbtAllocMem(NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY),NBT_TAG2('03')))))
        {
            CTEMemFree (pNameAddress);
            pNameAddress = NULL;
        }

        if (!pNameAddress)
        {
            CTESpinFree(&NbtConfig,OldIrq);
            KdPrint (("AddToHashTable: ERROR - INSUFFICIENT_RESOURCES\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        CTEZeroMemory(pNameAddress,sizeof(tNAMEADDR));
        pNameAddress->IpAddress     = IpAddress;
        pNameAddress->NameTypeState = (NameType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
        pNameAddress->NameTypeState |= STATE_RESOLVED;
        CTEMemCopy (pNameAddress->Name, pName, (ULONG)NETBIOS_NAME_SIZE);   // fill in the name

        if ((pHashTable->LocalRemote == NBT_LOCAL)  ||
            (pHashTable->LocalRemote == NBT_REMOTE_ALLOC_MEM))
        {
            pNameAddress->Verify = LOCAL_NAME;
            NBT_REFERENCE_NAMEADDR (pNameAddress, REF_NAME_LOCAL);
        }
        else
        {
            ASSERT (!(NameAddFlags & NAME_ADD_INET_GROUP));
            pNameAddress->Verify = REMOTE_NAME;
            CTEZeroMemory(pRemoteCache, NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY));
            pNameAddress->pRemoteIpAddrs = pRemoteCache;
            pNameAddress->RemoteCacheLen = NbtConfig.RemoteCacheLen;
            NBT_REFERENCE_NAMEADDR (pNameAddress, REF_NAME_REMOTE);

            NbtUpdateRemoteName(pDeviceContext, pNameAddress, NULL, NameAddFlags);
        }


    }
    else
    {
        //
        // See if we need to grow the IP addrs cache for remote names
        //
        ASSERT (!pNameAddr->pRemoteIpAddrs);
        if (pNameAddr->Verify == REMOTE_NAME)
        {
            NbtUpdateRemoteName(pDeviceContext, pNameAddr, NULL, NameAddFlags);
        }
        pNameAddress = pNameAddr;
    }

    pNameAddress->pTimer        = NULL;
    pNameAddress->TimeOutCount  = NbtConfig.RemoteTimeoutCount;

    // put on the head of the list in case the same name is in the table
    // twice (where the second one is waiting for its reference count to
    // go to zero, and will ultimately be removed, we want to find the new
    // name on any query of the table
    //
    InsertHeadList(&pHashTable->Bucket[iIndex],&pNameAddress->Linkage);


    // check for a scope too ( on non-local names only )
    if ((pHashTable->LocalRemote != NBT_LOCAL) && (*pScope))
    {
        // we must have a scope
        // see if the scope is already in the hash table and add if necessary
        //
        status = FindInHashTable(pHashTable, pScope, NULL, &pScopeAddr);
        if (!NT_SUCCESS(status))
        {
            PUCHAR  Scope;
            status = STATUS_SUCCESS;

            // *TODO* - this check will not adequately protect against
            // bad scopes passed in - i.e. we may run off into memory
            // and get an access violation...however converttoascii should
            // do the protection.  For local names the scope should be
            // ok since NBT read it from the registry and checked it first
            //
            iIndex = 0;
            Scope = pScope;
            while (*Scope && (iIndex <= 255))
            {
                iIndex++;
                Scope++;
            }

            // the whole length must be 255 or less, so the scope can only be
            // 255-16...
            if (iIndex > (255 - NETBIOS_NAME_SIZE))
            {
                RemoveEntryList(&pNameAddress->Linkage);
                if (pNameAddress->pRemoteIpAddrs)
                {
                    CTEMemFree ((PVOID)pNameAddress->pRemoteIpAddrs);
                }

                pNameAddress->Verify += 10;
                CTEMemFree(pNameAddress);

                CTESpinFree(&NbtConfig,OldIrq);
                return(STATUS_UNSUCCESSFUL);
            }

            iIndex++;   // to copy the null

            //
            // the scope is a variable length string, so allocate enough
            // memory for the tNameAddr structure based on this string length
            //
            pScopeAddr = (tNAMEADDR *)NbtAllocMem((USHORT)(sizeof(tNAMEADDR)
                                                        + iIndex
                                                        - NETBIOS_NAME_SIZE),NBT_TAG('1'));
            if ( !pScopeAddr )
            {
                RemoveEntryList(&pNameAddress->Linkage);
                if (pNameAddress->pRemoteIpAddrs)
                {
                    CTEMemFree ((PVOID)pNameAddress->pRemoteIpAddrs);
                }

                pNameAddress->Verify += 10;
                CTEMemFree (pNameAddress);

                CTESpinFree(&NbtConfig,OldIrq);
                return STATUS_INSUFFICIENT_RESOURCES ;
            }

            CTEZeroMemory(pScopeAddr, (sizeof(tNAMEADDR)+iIndex-NETBIOS_NAME_SIZE));

            // copy the scope to the name field including the Null at the end.
            // to the end of the name
            CTEMemCopy(pScopeAddr->Name,pScope,iIndex);

            // mark the entry as containing a scope name for cleanup later
            pScopeAddr->NameTypeState = NAMETYPE_SCOPE | STATE_RESOLVED;

            // keep the size of the name in the context value for easier name
            // comparisons in FindInHashTable

            pScopeAddr->Verify = REMOTE_NAME;
            NBT_REFERENCE_NAMEADDR (pScopeAddr, REF_NAME_REMOTE);
            NBT_REFERENCE_NAMEADDR (pScopeAddr, REF_NAME_SCOPE);
            pScopeAddr->ulScopeLength = iIndex;
            pNameAddress->pScope = pScopeAddr;

            // add the scope record to the hash table
            iIndex = ((pScopeAddr->Name[0] & 0x0F) << 4) + (pScopeAddr->Name[1] & 0x0F);
            iIndex = iIndex % pHashTable->lNumBuckets;
            InsertTailList(&pHashTable->Bucket[iIndex],&pScopeAddr->Linkage);

        }
        else
        {
            // the scope is already in the hash table so link the name to the
            // scope
            pNameAddress->pScope = pScopeAddr;
        }
    }
    else
    {
        pNameAddress->pScope = NULL; // no scope
    }

    // return the pointer to the hash table block
    if (ppNameAddress)
    {
        // return the pointer to the hash table block
        *ppNameAddress = pNameAddress;
    }
    CTESpinFree(&NbtConfig,OldIrq);
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tNAMEADDR *
LockAndFindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    )
{
    tNAMEADDR       *pNameAddr;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    pNameAddr = FindName(Location,
                         pName,
                         pScope,
                         pRetNameType);

    CTESpinFree (&NbtConfig.JointLock, OldIrq);
    return (pNameAddr);
}


//----------------------------------------------------------------------------
tNAMEADDR *
FindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    )
/*++

Routine Description:

    This routine searches the name table to find a name.  The table searched
    depends on the Location passed in - whether it searches the local table
    or the network names table.  The routine checks the state of the name
    and only returns names in the resolved state.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tNAMEADDR       *pNameAddr;
    NTSTATUS        status;
    tHASHTABLE      *pHashTbl;

    if (Location == NBT_LOCAL)
    {
        pHashTbl =  pNbtGlobConfig->pLocalHashTbl;
    }
    else
    {
        pHashTbl =  pNbtGlobConfig->pRemoteHashTbl;
    }

    status = FindInHashTable (pHashTbl, pName, pScope, &pNameAddr);
    if (!NT_SUCCESS(status))
    {
        return(NULL);
    }

    *pRetNameType = pNameAddr->NameTypeState;

    //
    // Only return names that are in the resolved state
    //
    if (!(pNameAddr->NameTypeState & STATE_RESOLVED))
    {
        pNameAddr = NULL;
    }

    return(pNameAddr);
}


//----------------------------------------------------------------------------
NTSTATUS
FindInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    tNAMEADDR           **pNameAddress
    )
/*++

Routine Description:

    This routine checks if the name passed in matches a hash table entry.
    Called with the spin lock HELD.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY              pEntry;
    PLIST_ENTRY              pHead;
    tNAMEADDR                *pNameAddr;
    int                      iIndex;
    ULONG                    uNameSize;
    PCHAR                    pScopeTbl;
    ULONG                    uInScopeLength = 0;

    // first hash the name to an index...
    // take the lower nibble of the first 2 characters.. mod table size
    //
    iIndex = ((pName[0] & 0x0F) << 4) + (pName[1] & 0x0F);
    iIndex = iIndex % pHashTable->lNumBuckets;

    if (pScope)
    {
        uInScopeLength = strlen (pScope);
    }

    // check if the name is already in the table
    // check each entry in the hash list...until the end of the list
    pHead = &pHashTable->Bucket[iIndex];
    pEntry = pHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

        if (pNameAddr->NameTypeState & NAMETYPE_SCOPE)
        {
            // scope names are treated differently since they are not
            // 16 bytes long...  the length is stored separately.
            uNameSize = pNameAddr->ulScopeLength;
        }
        else
        {
            uNameSize = NETBIOS_NAME_SIZE;
        }

        //
        // strncmp will terminate at the first non-matching byte
        // or when it has matched uNameSize bytes
        //
        // Bug # 225328 -- have to use CTEMemEqu to compare all
        // uNameSize bytes (otherwise bad name can cause termination
        // due to NULL character)
        //
        if (!(pNameAddr->NameTypeState & STATE_RELEASED) &&
            CTEMemEqu (pName, pNameAddr->Name, uNameSize))
        {
            // now check if the scopes match. Scopes are stored differently
            // on the local and remote tables.
            //
            if (!pScope)
            {
                // passing in a Null scope means try to find the name without
                // worrying about a scope matching too...
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }

            //
            // Check if Local Hash table
            //
            if (pHashTable == NbtConfig.pLocalHashTbl)
            {
                // In the local hash table case the scope is the same for all
                // names on the node and it is stored in the NbtConfig structure
                pScopeTbl = NbtConfig.pScope;
                uNameSize = NbtConfig.ScopeLength;
            }
            //
            // This is a Remote Hash table lookup
            //
            else if (pNameAddr->pScope)
            {
                pScopeTbl = &pNameAddr->pScope->Name[0];
                uNameSize = pNameAddr->pScope->ulScopeLength;
            }
            //
            // Remote Hash table entry with NULL scope
            // so if passed in scope is also Null, we have a match
            //
            else if (!uInScopeLength)
            {
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }
            else
            {
                //
                // Hash table scope length is 0 != uInScopeLength
                // ==> No match!
                //
                continue;
            }

            //
            // strncmp will terminate at the first non-matching byte
            // or when it has matched uNameSize bytes
            //
            if (0 == strncmp (pScope, pScopeTbl, uNameSize))
            {
                // the scopes match so return
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }
        } // end of matching name found
    }

    return(STATUS_UNSUCCESSFUL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\nbtstat\nbtstat.h ===
#ifndef VXD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <netconp.h>

#include <assert.h>
#include <stdio.h>

#include <winsock.h>
#include <wsahelp.h>
#include <nb30.h>
#include <nbtioctl.h>

//#include "../../tcpip/commands/common/tcpcmd.h"


#else
#include "vxdonly.h"
#endif

#define PROTODB_SIZE    (_MAX_PATH + 10)
#define SERVDB_SIZE     (_MAX_PATH + 10)


#define MAX_FAST_TDI_ADDRESS 32


#define TDI_QUERY_PURGE_CACHE       97
#define TDI_QUERY_CONNECTION_LIST   98
#define TDI_QUERY_CACHE_STATUS      99
#define TDI_DHCP_TEST              133
#define TDI_BCAST_RESOLVED_NAMES   134
#define NETBIOS_NAME_SIZE 16

/*
 *  Display Modes.
 */
#define ADAPTERSTATUS            0x0001
#define ADAPTERSTATUSIP          0x0002
#define BCAST                    0x0004
#define CACHE                    0x0008
#define CONNECTION               0x0010
#define CONNECTION_ALL           0x0020
#define CONNECTION_WITH_IP       0x0040
#define CONNECTION_WITH_IP_ALL   0x0080
#define DHCP                     0x0100
#define NAMES                    0x0200
#define NAMES_ALL                0x0400
#define NAME_RELEASE_REFRESH     0x0800  // not really a display mode
#define RESYNC                   0x1000  // not really a display mode

//
enum eSTATE
{
    NBT_RECONNECTING,      // waiting for the worker thread to run NbtConnect
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};
//
// These are other states for connections that are not explicitly used by
// NBT but are returned on the NbtQueryConnectionList call.
//
#define LISTENING   20
#define UNBOUND     21
#if 0
struct {
    long        TdiError;
    NTSTATUS    UnixError;
} UnixErrorMap[] = {
    {STATUS_INVALID_PARAMETER,EINVAL},
    {STATUS_INVALID_NETWORK_RESPONSE,ENETDOWN},
    {STATUS_INVALID_NETWORK_RESPONSE,ENODEV},
    {STATUS_INVALID_NETWORK_RESPONSE,ENXIO},
    {STATUS_NETWORK_BUSY,EBUSY},
    {STATUS_INSUFFICIENT_RESOURCES,ENOSR},
    {STATUS_ACCESS_DENIED,EACCES},
    {STATUS_LINK_FAILED,ECONNRESET},
    {STATUS_REMOTE_NOT_LISTENING,ECONNREFUSED},
    {STATUS_IO_TIMEOUT,ETIMEDOUT},
    {STATUS_BAD_NETWORK_PATH,ENETUNREACH},
    {STATUS_BAD_NETWORK_PATH,EHOSTUNREACH},
    {0,0}
};
#endif

//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


//              1234567890123456
#define SPACES "                "
#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//
// the defines that do the right thing
//
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

#define CALL_DRIVER     DeviceIoCtrl


//----------------------------------------------------------------------
//
//  Function Prototypes
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    tREMOTE_CACHE  Names[32];
} tREMOTE;

NTSTATUS
ReadRegistry(
    IN PUCHAR  pScope
    );

NTSTATUS
GetInterfaceList(
    );

HANDLE
OpenNbt(
    IN  ULONG   Index
    );

VOID
PrintKorM(
    IN PVOID    pBytesIn
    );

NTSTATUS
GetNames(
    IN HANDLE   fd,
    IN LONG     WhichNames
    );
NTSTATUS
GetConnections(
    IN HANDLE   fd,
    IN LONG     Display
    );
NTSTATUS
Resync(
    IN HANDLE   fd
    );

NTSTATUS
ReleaseNamesThenRefresh(
    IN HANDLE   fd
    );

PCHAR
gethost(ULONG addr,
        BOOLEAN Convert);

NTSTATUS
GetBcastResolvedNames(
    IN HANDLE   fd
    );

NTSTATUS
Dhcp(
    IN HANDLE   fd
    );

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );
VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );
NTSTATUS
AdapterStatus(
    IN HANDLE   fd,
    IN PCHAR    RemoteName
    );

NTSTATUS
AdapterStatusIpAddr(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN LONG    Display
    );

NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\hndlrs.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Hndlrs.c

Abstract:


    This file contains the Non OS specific implementation of handlers that are
    called for  Connects,Receives, Disconnects, and Errors.

    This file represents the TDI interface on the Bottom of NBT after it has
    been decoded into procedure call symantics from the Irp symantics used by
    NT.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

    Will Lees (wlees)    Sep 11, 1997
        Added support for message-only devices

--*/

#ifdef VXD

#define NTIndicateSessionSetup(pLowerConn,status) \
    DbgPrint("Skipping NTIndicateSessionSetup\n\r")

#endif //VXD

#include "precomp.h"
#include "ctemacro.h"
#include "hndlrs.tmh"

__inline long
myntohl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L));
}

VOID
ClearConnStructures (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle
    );

NTSTATUS
CompleteSessionSetup (
    IN  tCLIENTELE          *pClientEle,
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle,
    IN  PCTE_IRP            pIrp
    );

NTSTATUS
MakeRemoteAddressStructure(
    IN  PCHAR           pHalfAsciiName,
    IN  PVOID           pSourceAddr,
    IN  ULONG           lMaxNameSize,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength,
    IN  ULONG           NumAddr
    );

VOID
AddToRemoteHashTbl (
    IN  tDGRAMHDR UNALIGNED  *pDgram,
    IN  ULONG                BytesIndicated,
    IN  tDEVICECONTEXT       *pDeviceContext
    );


VOID
DoNothingComplete (
    IN PVOID        pContext
    );

VOID
AllocLowerConn(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  PVOID          pDeviceSpecial
    );

VOID
GetIrpIfNotCancelled2(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    );

//----------------------------------------------------------------------------
NTSTATUS
Inbound(
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is called to setup  inbound  session
    once the tcp connection is up.  The transport calls this routine with
    a session setup request pdu.

    In message-only mode, this routine may be called to cause a session to be set up even
    though the session request was not received over the wire.  A fake session request is
    crafted up and passed to this routine.  In this mode, we don't want to send session rejections
    back over the wire.

NOTE!!!
    // the LowerConn Lock is held prior to calling this routine

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS                 status = STATUS_SUCCESS;
    tCLIENTELE               *pClientEle;
    tSESSIONHDR UNALIGNED    *pSessionHdr;
    tLOWERCONNECTION         *pLowerConn;
    tCONNECTELE              *pConnectEle;
    CTELockHandle            OldIrq;
    PIRP                     pIrp;
    PLIST_ENTRY              pEntry;
    CONNECTION_CONTEXT       ConnectId;
    PTA_NETBIOS_ADDRESS      pRemoteAddress;
    ULONG                    RemoteAddressLength;
    tDEVICECONTEXT           *pDeviceContext;

    //
    // Verify that the DataSize >= sizeof (Sessionheader)
    // Bug# 126111
    //
    if (BytesIndicated < (sizeof(tSESSIONHDR)))
    {
        KdPrint (("Nbt.Inbound[1]: WARNING!!! Rejecting Request -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, (sizeof(tSESSIONHDR))));
        NbtTrace(NBT_TRACE_INBOUND, ("Reject request on %Z: BytestIndicated %d < %d",
                        &((tLOWERCONNECTION *)ConnectionContext)->pDeviceContext->BindName,
                        BytesIndicated, sizeof(tSESSIONHDR)));
        return (STATUS_INTERNAL_ERROR);
    }

    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;

    // get the ptrs to the lower and upper connections
    //
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnectEle = pLowerConn->pUpperConnection;
    pDeviceContext = pLowerConn->pDeviceContext;

    //
    // fake out the transport so it frees its receive buffer (i.e. we
    // say that we accepted all of the data)
    //
    *BytesTaken = BytesIndicated;

    //
    // since we send keep alives on connections in the the inbound
    // state it is possible to get a keep alive, so just return in that
    // case
    //
    if (((tSESSIONHDR UNALIGNED *)pTsdu)->Type == NBT_SESSION_KEEP_ALIVE)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("Return SUCCESS for NBT_SESSION_KEEP_ALIVE for %!ipaddr!", pLowerConn->SrcIpAddr));
        return(STATUS_SUCCESS);
    }

    //
    // Session ** INBOUND ** setup processing
    //
    if ((pSessionHdr->Type != NBT_SESSION_REQUEST) ||
        (BytesIndicated < (sizeof(tSESSIONHDR) + 2*(1+2*NETBIOS_NAME_SIZE+1))))
    {
        //
        // The Session Request packet is of the form:
        //  -- Session Header = 4 bytes
        //  -- Called name = 34+x (1 + 32 + 1(==ScopeLength) + x(==Scope))
        //  -- Calling name= 34+y (1 + 32 + 1(==ScopeLength) + y(==Scope))
        //
        CTESpinFreeAtDpc(pLowerConn);

        KdPrint(("Nbt.Inbound[2]: ERROR -- Bad Session PDU - Type=<%x>, BytesInd=[%d]<[%d], Src=<%x>\n",
            pSessionHdr->Type, BytesIndicated, (sizeof(tSESSIONHDR)+2*(1+2*NETBIOS_NAME_SIZE+1)),pLowerConn->SrcIpAddr));
        NbtTrace(NBT_TRACE_INBOUND, ("Bad Session PDU - Type=<%x>, BytesInd=[%d]<[%d], Src=%!ipaddr! %Z\n",
            pSessionHdr->Type, BytesIndicated, (sizeof(tSESSIONHDR)+2*(1+2*NETBIOS_NAME_SIZE+1)),
            pLowerConn->SrcIpAddr, &pLowerConn->pDeviceContext->BindName));

#ifdef _NETBIOSLESS
        status = STATUS_INTERNAL_ERROR;

        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, SESSION_UNSPECIFIED_ERROR, TRUE);
        }
        goto Inbound_Exit1;
    }

    // the LowerConn Lock is held prior to calling this routine, so free it
    // here since we need to get the joint lock first
    CTESpinFreeAtDpc(pLowerConn);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    // it is possible for the disconnect handler to run while the pLowerConn
    // lock is released above, to get the ConnEle  lock, and change the state
    // to disconnected.
    if (pLowerConn->State != NBT_SESSION_INBOUND)
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
#ifdef _NETBIOSLESS
        status = STATUS_CONNECTION_DISCONNECTED;
#endif
        NbtTrace(NBT_TRACE_INBOUND, ("Incorrect state %x %!ipaddr!", pLowerConn->State, pLowerConn->SrcIpAddr));
        goto Inbound_Exit1;
    }

    CTESpinFreeAtDpc(pLowerConn);

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.Inbound: In SessionSetupnotOS, connection state = %X\n",pLowerConn->State));

    status = FindSessionEndPoint(pTsdu,
                    ConnectionContext,
                    BytesIndicated,
                    &pClientEle,
                    &pRemoteAddress,
                    &RemoteAddressLength);

    if (status != STATUS_SUCCESS)
    {
        //
        // could not find the desired end point so send a negative session
        // response pdu and then disconnect
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_INBOUND, ("FindSessionEndPoint return %!status! for %!ipaddr! %Z",
            status, pLowerConn->SrcIpAddr, &pLowerConn->pDeviceContext->BindName));

#ifdef _NETBIOSLESS
        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, status, TRUE);
        }

        KdPrint (("Nbt.Inbound[3]: WARNING!!! FindSessionEndPoint failed, Rejecting Request\n"));
        goto Inbound_Exit1;
    }

    //
    // we must first check for a valid LISTEN....
    //
    CTESpinLockAtDpc(pDeviceContext);
    CTESpinLockAtDpc(pClientEle);
    if (!IsListEmpty(&pClientEle->ListenHead))
    {
        tLISTENREQUESTS     *pListen;
        tLISTENREQUESTS     *pListenTarget ;

        //
        //  Find the first listen that matches the remote name else
        //  take a listen that specified '*'
        //
        pListenTarget = NULL;
        for ( pEntry  = pClientEle->ListenHead.Flink ;
              pEntry != &pClientEle->ListenHead ;
              pEntry  = pEntry->Flink )
        {
            pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);

            // in NT-land the pConnInfo structure is passed in , but the
            // remote address field is nulled out... so we need to check
            // both of these before going on to check the remote address.
            if (pListen->pConnInfo && pListen->pConnInfo->RemoteAddress)
            {

                if (CTEMemEqu(((PTA_NETBIOS_ADDRESS)pListen->pConnInfo->RemoteAddress)->
                        Address[0].Address[0].NetbiosName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE))
                {
                    pListenTarget = pListen;
                    break;
                }
            }
            else
            {
                //
                //  Specified '*' for the remote name, save this,
                //  look for listen on a real name - only save if it is
                //  the first * listen found
                //
                if (!pListenTarget)
                {
                    pListenTarget = pListen ;
                }
            }
        }

        if (pListenTarget)
        {
            PTA_NETBIOS_ADDRESS     pRemoteAddr;

            RemoveEntryList( &pListenTarget->Linkage );

            //
            // Fill in the remote machines name to return to the client
            //
            if ((pListenTarget->pReturnConnInfo) &&
                (pRemoteAddr = pListenTarget->pReturnConnInfo->RemoteAddress))
            {
                CTEMemCopy(pRemoteAddr,pRemoteAddress,RemoteAddressLength);
            }

            //
            // get the upper connection end point out of the listen and
            // hook the upper and lower connections together.
            //
            pConnectEle = (tCONNECTELE *)pListenTarget->pConnectEle;
            CHECK_PTR(pConnectEle);
            CTESpinLockAtDpc(pConnectEle);

            pLowerConn->pUpperConnection = pConnectEle;
            pConnectEle->pLowerConnId = pLowerConn;
            pConnectEle->pIrpRcv = NULL;

            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, FALSE);

            //
            // put the upper connection on its active list
            //
            RemoveEntryList(&pConnectEle->Linkage);
            InsertTailList(&pConnectEle->pClientEle->ConnectActive, &pConnectEle->Linkage);

            //
            //  Save the remote name while we still have it
            //
            CTEMemCopy (pConnectEle->RemoteName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE ) ;

            //
            // since the lower connection now points to pConnectEle, increment
            // the reference count so we can't free pConnectEle memory until
            // the lower conn no longer points to it.
            ClearConnStructures(pLowerConn,pConnectEle);
            NBT_REFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);

            if (pListenTarget->Flags & TDI_QUERY_ACCEPT)
            {
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_WAITACCEPT);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_WAITACCEPT);
                SET_STATERCV_LOWER (pLowerConn, NORMAL, RejectAnyData);
            }
            else
            {
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
                SET_STATERCV_LOWER (pLowerConn, NORMAL, Normal);
            }

            CTESpinFreeAtDpc(pConnectEle);
            CTESpinFreeAtDpc(pClientEle);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pListenTarget->Flags & TDI_QUERY_ACCEPT)
            {
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.Inbound: Completing Client's Irp to make client issue Accept\n"));

                //
                // complete the client listen irp, which will trigger him to
                // issue an accept, which should find the connection in the
                // WAIT_ACCEPT state, and subsequently cause a session response
                // to be sent.
#ifndef VXD
                // the irp can't get cancelled because the cancel listen routine
                // also grabs the Client spin lock and removes the listen from the
                // list..
                CTEIoComplete( pListenTarget->pIrp,STATUS_SUCCESS,0);
#else
                CTEIoComplete( pListenTarget->pIrp,STATUS_SUCCESS, (ULONG) pConnectEle);
#endif
            }
            else
            {
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.Inbound: Calling CompleteSessionSetup to send session response PDU\n"));

                //
                // We need to send a session response PDU here, since
                // we do not have to wait for an accept in this case
                //
                CompleteSessionSetup(pClientEle, pLowerConn,pConnectEle, pListenTarget->pIrp);
            }

            CTEMemFree((PVOID)pRemoteAddress);
            CTEMemFree(pListenTarget);

            // now that we have notified the client, dereference it
            //
            NBT_DEREFERENCE_CLIENT(pClientEle);

            PUSH_LOCATION(0x60);
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.Inbound: Accepted Connection by a Listen %X LowerConn=%X, BytesTaken=<%x>\n",
                    pConnectEle,pLowerConn, BytesAvailable));

            // fake out the transport so it frees its receive buffer (i.e. we
            // say that we accepted all of the data)
            *BytesTaken = BytesAvailable;
            status = STATUS_SUCCESS;
            goto Inbound_Exit1;
        }
    }
    CTESpinFreeAtDpc(pClientEle);
    CTESpinFreeAtDpc(pDeviceContext);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // No LISTEN, so check for an Event handler
    //
    if (!pClientEle->ConEvContext)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("No listener for %!ipaddr! %!NBTNAME!<%02x> %Z",
            pLowerConn->SrcIpAddr, pRemoteAddress->Address[0].Address[0].NetbiosName,
            (unsigned)pRemoteAddress->Address[0].Address[0].NetbiosName[15],
            &pLowerConn->pDeviceContext->BindName));

#ifdef _NETBIOSLESS
        status = STATUS_REMOTE_NOT_LISTENING;

        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn,
                          NBT_NEGATIVE_SESSION_RESPONSE, 
                          SESSION_NOT_LISTENING_ON_CALLED_NAME, 
                          TRUE);
        }

        // undo the reference done in FindEndpoint
        //
        NBT_DEREFERENCE_CLIENT(pClientEle);
        //
        // free the memory allocated for the Remote address data structure
        //
        CTEMemFree((PVOID)pRemoteAddress);

        KdPrint (("Nbt.Inbound[4]: WARNING!!! Rejecting Request -- No Listen or EventHandler\n"));
        goto Inbound_Exit1;
    }
#ifdef VXD
    else
    {
        ASSERT( FALSE ) ;
    }
#endif

    // now call the client's connect handler...
    pIrp = NULL;
#ifndef VXD         // VXD doesn't support event handlers

    status = (*pClientEle->evConnect)(pClientEle->ConEvContext,
                             RemoteAddressLength,
                             pRemoteAddress,
                             0,
                             NULL,
                             0,          // options length
                             NULL,       // Options
                             &ConnectId,
                             &pIrp
                             );
    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_INBOUND, ("Client return %!status! for %!ipaddr! %!NBTNAME!<%02x> %Z",
            status, pLowerConn->SrcIpAddr, pRemoteAddress->Address[0].Address[0].NetbiosName,
            (unsigned)pRemoteAddress->Address[0].Address[0].NetbiosName[15],
            &pLowerConn->pDeviceContext->BindName));
    }
    //
    // With the new TDI semantics is it illegal to return STATUS_EVENT_DONE
    // or STATUS_EVENT_PENDING from the connect event handler
    //
    ASSERT(status != STATUS_EVENT_PENDING);
    ASSERT(status != STATUS_EVENT_DONE);


    // now that we have notified the client, dereference it
    //
    NBT_DEREFERENCE_CLIENT(pClientEle);

    // Check the returned status codes..
    if (status == STATUS_MORE_PROCESSING_REQUIRED && pIrp != NULL)
    {
        PIO_STACK_LOCATION          pIrpSp;

        // the pConnEle ptr was stored in the FsContext value when the connection
        // was initially created.
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
        if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.Inbound: ERROR - Invalid Connection Handle\n", 0);
            status = STATUS_INTERNAL_ERROR;
        }
        else
        {
            //
            //  Save the remote name while we still have it
            //
            CHECK_PTR(pConnectEle);
            CTEMemCopy( pConnectEle->RemoteName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE ) ;

            // be sure the connection is in the correct state
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLockAtDpc(pDeviceContext);
            CTESpinLockAtDpc(pClientEle);
            CTESpinLockAtDpc(pConnectEle);

            if (pConnectEle->state == NBT_ASSOCIATED)
            {
                //
                // Previously, the LowerConnection was in the SESSION_INBOUND state
                // hence we have to remove it from the WaitingForInbound Q and put
                // it on the active LowerConnection list!
                //
                ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
                RemoveEntryList (&pLowerConn->Linkage);
                InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
                InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
                //
                // Change the RefCount Context to Connected!
                //
                NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND,REF_LOWC_CONNECTED, FALSE);

                // since the lower connection now points to pConnectEle, increment
                // the reference count so we can't free pConnectEle memory until
                // the lower conn no longer points to it.
                //
                NBT_REFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);
                ClearConnStructures(pLowerConn,pConnectEle);
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
                SetStateProc (pLowerConn, Normal);

                RemoveEntryList(&pConnectEle->Linkage);
                InsertTailList(&pConnectEle->pClientEle->ConnectActive, &pConnectEle->Linkage);

                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_INTERNAL_ERROR;
            }

            CTESpinFreeAtDpc(pConnectEle);
            CTESpinFreeAtDpc(pClientEle);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (STATUS_SUCCESS == status)
            {
                CompleteSessionSetup(pClientEle,pLowerConn,pConnectEle,pIrp);
            }
        }
    }
    else
    {
        status = STATUS_DATA_NOT_ACCEPTED;
    }

    if (status != STATUS_SUCCESS)
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.Inbound: The client rejected in the inbound connection status = %X\n", status));

#ifdef _NETBIOSLESS
        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn,
                          NBT_NEGATIVE_SESSION_RESPONSE,
                          SESSION_CALLED_NAME_PRESENT_NO_RESRC,
                          TRUE);
        }
    }
#endif
    //
    // free the memory allocated for the Remote address data structure
    //
    CTEMemFree((PVOID)pRemoteAddress);

Inbound_Exit1:
    // This spin lock is held by the routine that calls this one, and
    // freed when this routine starts, so we must regrab this lock before
    // returning
    //
    CTESpinLockAtDpc(pLowerConn);

#ifdef _NETBIOSLESS
    // In message only mode, return the real status
    return (IsDeviceNetbiosless(pLowerConn->pDeviceContext) ? status : STATUS_SUCCESS );
#else
    return(STATUS_SUCCESS);
#endif
}
//----------------------------------------------------------------------------
VOID
ClearConnStructures (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle
    )
/*++

Routine Description:

    This routine sets various parts of the connection datastructures to
    zero, in preparation for a new connection.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    CHECK_PTR(pConnectEle);
#ifndef VXD
    pConnectEle->FreeBytesInMdl = 0;
    pConnectEle->CurrentRcvLen = 0;
    pLowerConn->BytesInIndicate = 0;
#endif
    pConnectEle->ReceiveIndicated = 0;
    pConnectEle->BytesInXport = 0;
    pConnectEle->BytesRcvd = 0;
    pConnectEle->TotalPcktLen = 0;
    pConnectEle->OffsetFromStart = 0;
    pConnectEle->pIrpRcv = NULL;
    pConnectEle->pIrp = NULL;
    pConnectEle->pIrpDisc = NULL;
    pConnectEle->pIrpClose = NULL;
    pConnectEle->DiscFlag = 0;
    pConnectEle->JunkMsgFlag = FALSE;
    pConnectEle->pLowerConnId = pLowerConn;
    InitializeListHead(&pConnectEle->RcvHead);

    pLowerConn->pUpperConnection = pConnectEle;
    SET_STATERCV_LOWER(pLowerConn, NORMAL, pLowerConn->CurrentStateProc);

    pLowerConn->BytesRcvd = 0;
    pLowerConn->BytesSent = 0;

}
//----------------------------------------------------------------------------
NTSTATUS
CompleteSessionSetup (
    IN  tCLIENTELE          *pClientEle,
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle,
    IN  PCTE_IRP            pIrp
    )
/*++

Routine Description:

    This routine is called to setup an outbound session
    once the tcp connection is up.  The transport calls this routine with
    a session setup response pdu.

    The pConnectEle + Joinlock are held when this routine is called.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS        status;
    CTELockHandle   OldIrq;

#ifdef _NETBIOSLESS
    // In message-only mode, don't send session responses back over the wire
    if (IsDeviceNetbiosless(pLowerConn->pDeviceContext))
    {
        status = STATUS_SUCCESS;
    }
    else
#endif
    {
        status = TcpSendSessionResponse(pLowerConn, NBT_POSITIVE_SESSION_RESPONSE, 0L);
    }

    if (NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CompleteSessionSetup: Accepted ConnEle=%p LowerConn=%p\n",pConnectEle,pLowerConn));

        //
        // complete the client's accept Irp
        //
#ifndef VXD
        CTEIoComplete (pIrp, STATUS_SUCCESS, 0);
#else
        CTEIoComplete (pIrp, STATUS_SUCCESS, (ULONG)pConnectEle);
#endif
    }
    else
    {   //
        // if we have some trouble sending the Session response, then
        // disconnect the connection
        //
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CompleteSessionSetup: Could not send Session Response, status = %X\n", status));

        RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, SESSION_CALLED_NAME_PRESENT_NO_RESRC, TRUE);

        CTESpinLock(&NbtConfig.JointLock, OldIrq);
        RelistConnection(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock, OldIrq);

        // Disconnect To Client - i.e. a negative Accept
        // this will get done when the disconnect indication
        // comes back from the transport
        //
        GetIrpIfNotCancelled(pConnectEle,&pIrp);
        if (pIrp)
        {
            CTEIoComplete(pIrp,STATUS_UNSUCCESSFUL,0);
        }
    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
Outbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is called while seting up an outbound session
    once the tcp connection is up.  The transport calls this routine with
    a session setup response pdu .


Arguments:

    pClientEle      - ptr to the connection record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    tSESSIONHDR UNALIGNED    *pSessionHdr;
    tLOWERCONNECTION         *pLowerConn;
    CTELockHandle            OldIrq;
    PIRP                     pIrp;
    tTIMERQENTRY             *pTimerEntry;
    tCONNECTELE              *pConnEle;
    tDGRAM_SEND_TRACKING     *pTracker;
    tDEVICECONTEXT           *pDeviceContext;

    // get the ptr to the lower connection
    //
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;
    pDeviceContext = pLowerConn->pDeviceContext;

    //
    // fake out the transport so it frees its receive buffer (i.e. we
    // say that we accepted all of the data)
    //
    *BytesTaken = BytesIndicated;
    //
    // since we send keep alives on connections in the the inbound
    // state it is possible to get a keep alive, so just return in that
    // case
    //
    if (((tSESSIONHDR UNALIGNED *)pTsdu)->Type == NBT_SESSION_KEEP_ALIVE)
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Return success for NBT_SESSION_KEEP_ALIVE"));
        return(STATUS_SUCCESS);
    }

    // the LowerConn Lock is held prior to calling this routine, so free it
    // here since we need to get the joint lock first
    CTESpinFreeAtDpc(pLowerConn);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    //
    // it is possible for the disconnect handler to run while the pLowerConn
    // lock is released above, to get the ConnEle  lock, and change the state
    // to disconnected.
    //
    if ((!(pConnEle = pLowerConn->pUpperConnection)) ||
        (pConnEle->state != NBT_SESSION_OUTBOUND))
    {
        if (pConnEle) {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Reset outbound connection %lx", pConnEle->state));
        } else {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Reset outbound connection"));
        }
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        RejectSession(pLowerConn,0,0,FALSE);
        goto ExitCode;
    }

    //
    // if no Connect Tracker, then SessionStartupCompletion has run and
    // the connection is about to be closed, so return.
    //
    if (!(pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv))
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("No tracker"));
        goto ExitCode;
    }

    CHECK_PTR(pTracker);
    CHECK_PTR(pConnEle);

    pConnEle->pIrpRcv = NULL;

    //
    // Stop the timer started in SessionStartupCompletion to time the
    // Session Setup Response message - it is possible for this routine to
    // run before SessionStartupCompletion, in which case there will not be
    // any timer to stop.
    //
    if (pTimerEntry = pTracker->pTimer)
    {
        pTracker->pTimer = NULL;
        StopTimer(pTimerEntry,NULL,NULL);
    }

    if (pSessionHdr->Type == NBT_POSITIVE_SESSION_RESPONSE)
    {
        // zero out the number of bytes received so far, since this is  a new connection
        CHECK_PTR(pConnEle);
        pConnEle->BytesRcvd = 0;
        SET_STATE_UPPER (pConnEle, NBT_SESSION_UP);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
        SetStateProc( pLowerConn, Normal ) ;

        CTESpinFreeAtDpc(pLowerConn);

        GetIrpIfNotCancelled2(pConnEle,&pIrp);

        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0)
        {
            //
            // remove the reference done when FindNameOrQuery was called, or when
            // SessionSetupContinue ran
            //
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // the assumption is that if the connect irp was cancelled then the
        // client should be doing a disconnect or close shortly thereafter, so
        // there is no error handling code here.
        if (pIrp)
        {
            //
            // complete the client's connect request Irp
            //
#ifndef VXD
            CTEIoComplete( pIrp, STATUS_SUCCESS, 0 ) ;
#else
            CTEIoComplete( pIrp, STATUS_SUCCESS, (ULONG)pConnEle ) ;
#endif
        }
    }
    else
    {
        ULONG       ErrorCode;
        ULONG       state;
        NTSTATUS    status = STATUS_SUCCESS;

        state = pConnEle->state;
        if ((NbtConfig.Unloading) ||
            (!NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, TRUE)))
        {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Outbound() gets called while unloading driver %x", state));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }


        // If the response is Retarget then setup another session
        // to the new Ip address and port number.
        //
        ErrorCode = (ULONG)((tSESSIONERROR *)pSessionHdr)->ErrorCode;
        NbtTrace(NBT_TRACE_OUTBOUND, ("state=%x (%s%d), (%s%s%s%s)",
                state,
                ((pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)? "Retarget Response ": ""),
                pConnEle->SessionSetupCount,
                ((NbtConfig.TryAllNameServers)? "TryAllNameServers ": ""),
                ((pSessionHdr->Type == NBT_NEGATIVE_SESSION_RESPONSE)? "NegativeSessionResponse ":""),
                ((pTracker->RemoteNameLength <= NETBIOS_NAME_SIZE)? "NetBIOS": "DNS_Name "),
                ((pTracker->ResolutionContextFlags != 0xFF)? "ContinueQuery ": "EndOfQuery")));
                
#ifdef MULTIPLE_WINS
        if ( (status == STATUS_SUCCESS) &&
             ( ((pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE) &&
                (pConnEle->SessionSetupCount--))
                            ||
               ((NbtConfig.TryAllNameServers) &&
                (pSessionHdr->Type == NBT_NEGATIVE_SESSION_RESPONSE) &&
                pTracker->RemoteNameLength <= NETBIOS_NAME_SIZE &&      // Don't do it for DNS name
                (pTracker->ResolutionContextFlags != 0xFF))))    // Have not finished querying
        {
#else
        if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
        {
            //
            // retry the session setup if we haven't already exceeded the
            // count
            //
            if (pConnEle->SessionSetupCount--)
            {
#endif
            PVOID                   Context=NULL;
            BOOLEAN                 Cancelled;

            SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);

            // for retarget the destination has specified an alternate
            // port to which the session should be established.
            if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
            {
                pTracker->DestPort = ntohs(((tSESSIONRETARGET *)pSessionHdr)->Port);
                Context = ULongToPtr(ntohl(((tSESSIONRETARGET *)pSessionHdr)->IpAddress));
            }
            else
#ifndef MULTIPLE_WINS
            if (ErrorCode == SESSION_CALLED_NAME_NOT_PRESENT)
#endif
            {
                // to tell DelayedReconnect to use the current name(not a retarget)
                Context = NULL;
            }

            //
            // Unlink the lower and upper connections.
            //
            CHECK_PTR(pConnEle);
            CHECK_PTR(pLowerConn);
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

            CTESpinFreeAtDpc(pLowerConn);

            //
            // put the pconnele back on the Client's ConnectHead if it
            // has not been cleanedup yet.
            //
            if (state != NBT_IDLE)
            {
                RelistConnection(pConnEle);
            }

            // if a disconnect comes down in this state we we will handle it.
            SET_STATE_UPPER (pConnEle, NBT_RECONNECTING);

            CHECK_PTR(pConnEle);

#ifdef MULTIPLE_WINS
            if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
            {
                pConnEle->SessionSetupCount = 0;// only allow one retry
            }
#else
            pConnEle->SessionSetupCount = 0;// only allow one retry
#endif

            pIrp = pConnEle->pIrp;
            Cancelled = FALSE;

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.Outbound: Attempt Reconnect, error=%X LowerConn %X\n", ErrorCode,pLowerConn));
#ifndef VXD
            // the irp can't be cancelled until the connection
            // starts up again - either when the Irp is in the transport
            // or when we set our cancel routine in SessionStartupCompletion
            //  This disconnect handler cannot complete the Irp because
            // we set the pConnEle state to NBT_ASSOCIATED above, with
            // the spin lock held, which prevents the Disconnect handler
            // from doing anything.
            IoAcquireCancelSpinLock(&OldIrq);
            if (pIrp && !pConnEle->pIrp->Cancel)
            {
                IoSetCancelRoutine(pIrp,NULL);
            }
            else
            {
                Cancelled = TRUE;
            }

            IoReleaseCancelSpinLock(OldIrq);
#endif

            if (!Cancelled)
            {
                //
                // The enqueuing can fail only if we run out of resources
                // because we have already verified the device state earlier
                // and have not released the JointLock since then, which
                // would not that state to be modified.
                //
                CTEQueueForNonDispProcessing(DelayedReConnect,
                                             pTracker,
                                             Context,
                                             NULL,
                                             pDeviceContext,
                                             TRUE);
            }

            // ...else The irp was already returned, since NtCancelSession
            // Must have already run, so just return
            NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, TRUE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            RejectSession(pLowerConn,0,0,FALSE);

            // remove the referenced added when the lower and upper
            // connections were attached in nbtconnect.
            //
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

            goto ExitCode;
#ifndef MULTIPLE_WINS
        }
#endif
        }

        // the connection will be disconnected by the Call to RejectSession
        // below, so set the state to Associated so the disconnect indication
        // handler will not complete the client's irp too
        //
        CHECK_PTR(pConnEle);
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        pConnEle->pLowerConnId = NULL;

        CTESpinFreeAtDpc(pLowerConn);

        //
        // if nbtcleanupconnection has not been called yet, relist it.
        //
        if (state != NBT_IDLE)
        {
            RelistConnection(pConnEle);
        }

        IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.Outbound: Disconnecting... Failed connection Setup %X Lowercon %X\n",
            pConnEle,pLowerConn));

        GetIrpIfNotCancelled2(pConnEle,&pIrp);

        //
        // if SessionTimedOut has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0)
        {
            //
            // remove the reference done when FindNameOrQuery was called, or when
            // SessionSetupContinue ran
            //
            if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&         // Remote names only!
                (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
                (pTracker->pNameAddr->RefCount == 2))
            {
                //
                // If no one else is referencing the name, then delete it from
                // the hash table.
                //
                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
            }
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        if (status != STATUS_INVALID_DEVICE_REQUEST)
        {
            // this should cause a disconnect indication to come from the
            // transport which will close the connection to the transport
            //
            RejectSession(pLowerConn,0,0,FALSE);
            NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, FALSE);
        }

        //
        // tell the client that the session setup failed and disconnect
        // the connection
        //
        if (pIrp)
        {
            status = STATUS_REMOTE_NOT_LISTENING;
            if (ErrorCode != SESSION_CALLED_NAME_NOT_PRESENT)
            {
                status = STATUS_BAD_NETWORK_PATH;
            }

            CTEIoComplete(pIrp, status, 0 ) ;
        }
    }

ExitCode:
    // the LowerConn Lock is held prior to calling this routine.  It is freed
    // at the start of this routine and held here again
    CTESpinLockAtDpc(pLowerConn);

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
VOID
GetIrpIfNotCancelled2(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    )
/*++

Routine Description:

    This routine coordinates access to the Irp by getting the spin lock on
    the client, getting the Irp and clearing the irp in the structure.  The
    Irp cancel routines also check the pConnEle->pIrp and if null they do not
    find the irp, then they return without completing the irp.

    This version of the routine is called with NbtConfig.JointLock held.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    CTELockHandle   OldIrq;

    CTESpinLock(pConnEle,OldIrq);

    *ppIrp = pConnEle->pIrp;
    CHECK_PTR(pConnEle);
    pConnEle->pIrp = NULL;

    CTESpinFree(pConnEle,OldIrq);
}

//----------------------------------------------------------------------------
VOID
GetIrpIfNotCancelled(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    )
/*++

Routine Description:

    This routine coordinates access to the Irp by getting the spin lock on
    the client, getting the Irp and clearing the irp in the structure.  The
    Irp cancel routines also check the pConnEle->pIrp and if null they do not
    find the irp, then they return without completing the irp.

    This version of the routine is called with NbtConfig.JointLock free.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    CTELockHandle   OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    GetIrpIfNotCancelled2(pConnEle,ppIrp);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}
//----------------------------------------------------------------------------
NTSTATUS
RejectAnyData(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler when the connection
    is not up - i.e. nbt thinks no data should be arriving. We just eat the
    data and return.  This routine should not get called.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS        status;

    //
    // take all of the data so that a disconnect will not be held up
    // by data still in the transport.
    //
    *BytesTaken = BytesAvailable;

    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.RejectAnyData: Got Session Data in state %X, StateRcv= %X\n",pLowerConn->State,
              pLowerConn->StateRcv));

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
VOID
RejectSession(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               StatusCode,
    IN  ULONG               SessionStatus,
    IN  BOOLEAN             SendNegativeSessionResponse
    )
/*++

Routine Description:

    This routine sends a negative session response (if the boolean is set)
    and then disconnects the connection.
    Cleanup connection could have been called to disconnect the call,
    and it changes the state to disconnecting, so don't disconnected
    again if that is happening.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    NTSTATUS            status;
    tCONNECTELE         *pConnEle;
    BOOLEAN             DerefConnEle=FALSE;

    //
    // There is no listen event handler so return a status code to
    // the caller indicating that this end is between "listens" and
    // that they should try the setup again in a few milliseconds.
    //
    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.RejectSession: No Listen or Connect Handlr so Disconnect! LowerConn=%X Session Status=%X\n",
            pLowerConn,SessionStatus));

    if (SendNegativeSessionResponse)
    {
        status = TcpSendSessionResponse(pLowerConn,
                                        StatusCode,
                                        SessionStatus);
    }

    // need to hold this lock if we are to un connect the lower and upper
    // connnections
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pLowerConn->pDeviceContext,OldIrq2);
    CTESpinLock(pLowerConn,OldIrq);

    CHECK_PTR(pLowerConn);
    if ((pLowerConn->State < NBT_DISCONNECTING) &&
        (pLowerConn->State > NBT_CONNECTING))
    {
        if (pLowerConn->State == NBT_SESSION_INBOUND)
        {
            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
        }
        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
        SetStateProc( pLowerConn, RejectAnyData ) ;

        pConnEle = pLowerConn->pUpperConnection;
        if (pConnEle)
        {
            CHECK_PTR(pConnEle);
            DerefConnEle = TRUE;
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTING);
        }

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        SendTcpDisconnect((PVOID)pLowerConn);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }

    if (DerefConnEle)
    {
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
FindSessionEndPoint(
    IN  PVOID           pTsdu,
    IN  PVOID           ConnectionContext,
    IN  ULONG           BytesIndicated,
    OUT tCLIENTELE      **ppClientEle,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength
    )
/*++

Routine Description:

    This routine attempts to find an end point on the node with the matching
    net bios name.  It is called at session setup time when a session request
    PDU has arrived.  The routine returns the Client Element ptr.
    The JointLock is held prior to calling this routine!

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS                status;
    tCLIENTELE              *pClientEle;
    tLOWERCONNECTION        *pLowerConn;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    tADDRESSELE             *pAddressEle;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead;
    ULONG                   lNameSize;
    tSESSIONREQ UNALIGNED   *pSessionReq = (tSESSIONREQ UNALIGNED *)pTsdu;
    ULONG                   sType;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    PUCHAR                  pSrcName;
    BOOLEAN                 Found;

    // get the ptr to the lower connection, and from that get the ptr to the
    // upper connection block
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;

    if (pSessionReq->Hdr.Type != NBT_SESSION_REQUEST)
    {
        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, pSessionReq->Hdr.Type=<%d>!=<%d>\n",
            pSessionReq->Hdr.Type, NBT_SESSION_REQUEST));
        return(SESSION_UNSPECIFIED_ERROR);
    }

    // get the called name out of the PDU
    status = ConvertToAscii ((PCHAR)&pSessionReq->CalledName,
                             BytesIndicated - FIELD_OFFSET(tSESSIONREQ,CalledName),
                             pName,
                             &pScope,
                             &lNameSize);

    if (!NT_SUCCESS(status))
    {
        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, ConvertToAscii FAILed!\n"));
        NbtTrace(NBT_TRACE_INBOUND, ("ConvertToAscii returns %!status!", status));
        return(SESSION_UNSPECIFIED_ERROR);
    }


    // now try to find the called name in this node's Local table
    //

    //
    // in case a disconnect came in while the spin lock was released
    //
    if (pLowerConn->State != NBT_SESSION_INBOUND)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    pNameAddr = FindName (NBT_LOCAL,pName,pScope,&sType);

    if (!pNameAddr)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("FindName cannot find %!NBTNAME!<%02x>", pName, (unsigned)pName[15]));
        return(SESSION_CALLED_NAME_NOT_PRESENT);
    }

    // we got to here because the name has resolved to a name on this node,
    // so accept the Session setup.
    //
    pAddressEle = (tADDRESSELE *)pNameAddr->pAddressEle;

    // lock the address structure until we find a client on the list
    //
    CTESpinLock(pAddressEle,OldIrq1);

    if (IsListEmpty(&pAddressEle->ClientHead))
    {
        CTESpinFree(pAddressEle,OldIrq1);
        NbtTrace(NBT_TRACE_INBOUND, ("No one is listening on %!NBTNAME!<%02x>", pName, (unsigned)pName[15]));
        return(SESSION_NOT_LISTENING_ON_CALLED_NAME);
    }

    //
    // get the first client on the list that is bound to the same
    // devicecontext as the connection, with a listen posted, or a valid
    // Connect event handler setup -
    //
    Found = FALSE;
    pHead = &pAddressEle->ClientHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

        CTESpinLock(pClientEle,OldIrq2);
        if ((pClientEle->pDeviceContext == pLowerConn->pDeviceContext) &&
            (NBT_VERIFY_HANDLE(pClientEle, NBT_VERIFY_CLIENT)))     // Ensure that client is not going away!
        {
            //
            // if there is a listen posted or a Connect Event Handler
            // then allow the connect attempt to carry on, otherwise go to the
            // next client in the list
            //
            if ((!IsListEmpty(&pClientEle->ListenHead)) ||
                (pClientEle->ConEvContext))
            {
                Found = TRUE;
                break;
            }
        }
        CTESpinFree(pClientEle,OldIrq2);

        pEntry = pEntry->Flink;
    }

    if (!Found)
    {
        CTESpinFree(pAddressEle,OldIrq1);
        NbtTrace(NBT_TRACE_INBOUND, ("No one is listening on %!NBTNAME!<%02x>", pName, (unsigned)pName[15]));
        return(SESSION_NOT_LISTENING_ON_CALLED_NAME);
    }

    //
    // Ensure we are calculating the Max Buffer size (3rd parameter) properly
    // Bug# 126135
    //
    pSrcName = (PUCHAR)((PUCHAR)&pSessionReq->CalledName.NameLength + 1+lNameSize);
    status = MakeRemoteAddressStructure(
                        pSrcName,
                        0,
                        BytesIndicated-(FIELD_OFFSET(tSESSIONREQ,CalledName.NameLength)+1+lNameSize),
                        ppRemoteAddress,
                        pRemoteAddressLength,
                        1);

    if (!NT_SUCCESS(status))
    {
        CTESpinFree(pClientEle,OldIrq2);
        CTESpinFree(pAddressEle,OldIrq1);

        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, MakeRemoteAddressStructure FAILed!\n"));
        NbtTrace(NBT_TRACE_INBOUND, ("MakeRemoteAddressStructure returns %!status! on %!NBTNAME!<%02x>",
                                status, pName, (unsigned)pName[15]));
        if (status == STATUS_INSUFFICIENT_RESOURCES)
        {
            return(SESSION_CALLED_NAME_PRESENT_NO_RESRC);
        }
        else
        {
            return(SESSION_UNSPECIFIED_ERROR);
        }
    }

    // prevent the client from disappearing before we can indicate to him
    //
    NBT_REFERENCE_CLIENT(pClientEle);

    CTESpinFree(pClientEle,OldIrq2);
    CTESpinFree(pAddressEle,OldIrq1);

    *ppClientEle = pClientEle;
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
MakeRemoteAddressStructure(
    IN  PCHAR           pHalfAsciiName,
    IN  PVOID           pSourceAddr,
    IN  ULONG           lMaxNameSize,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength,
    IN  ULONG           NumAddr
    )
/*++

Routine Description:

    This routine makes up the remote addres structure with the netbios name
    of the source in it, so that the info can be passed to the client...what
    a bother to do this!

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    PTA_NETBIOS_ADDRESS pRemoteAddress;

    // make up the remote address data structure to pass to the client
    status = ConvertToAscii(
                    pHalfAsciiName,
                    lMaxNameSize,
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
        KdPrint (("Nbt.MakeRemoteAddressStructure: WARNING!!! Rejecting Request, ConvertToAscii FAILed!\n"));
        return(status);
    }

    pRemoteAddress = (PTA_NETBIOS_ADDRESS)NbtAllocMem(
                                        NumAddr * sizeof(TA_NETBIOS_ADDRESS),NBT_TAG('2'));
    if (!pRemoteAddress)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pRemoteAddress->TAAddressCount = NumAddr;
    pRemoteAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    CTEMemCopy(pRemoteAddress->Address[0].Address[0].NetbiosName, pName,NETBIOS_NAME_SIZE);

    *pRemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE]);

    //
    // Copy over the IP address also.
    //
    if (NumAddr == 2)
    {
        TA_ADDRESS          *pTAAddr;
        PTRANSPORT_ADDRESS  pSourceAddress;

        pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;

        pTAAddr = (TA_ADDRESS *) (((PUCHAR)pRemoteAddress)
                                + pRemoteAddress->Address[0].AddressLength
                                + FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address));

        pTAAddr->AddressLength = sizeof(TDI_ADDRESS_IP);
        pTAAddr->AddressType = TDI_ADDRESS_TYPE_IP;
        ((TDI_ADDRESS_IP UNALIGNED *)&pTAAddr->Address[0])->in_addr = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr;
        *pRemoteAddressLength += (FIELD_OFFSET(TA_ADDRESS, Address) + pTAAddr->AddressLength);
    }

    *ppRemoteAddress = (PVOID)pRemoteAddress;
//    *pRemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);
//    *pRemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address[0]);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
ConnectHndlrNotOs (
    IN PVOID                pConnectionContext,
    IN LONG                 RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN VOID UNALIGNED       *pUserData,
    OUT CONNECTION_CONTEXT  *ppConnectionId
    )
/*++

Routine Description:

    This routine is the receive connect indication handler.

    It is called when a TCP connection is being setup for a NetBios session.
    It simply allocates a connection and returns that information to the
    transport so that the connect indication can be accepted.

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pList;
    tLOWERCONNECTION    *pLowerConn;
    tDEVICECONTEXT      *pDeviceContext;
    PTRANSPORT_ADDRESS  pSrcAddress;
    NTSTATUS            Status;

    pDeviceContext = (tDEVICECONTEXT *)pConnectionContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pDeviceContext);

    // check that the source is an IP address
    //
    pSrcAddress = pRemoteAddress;
    if ((pSrcAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP) ||
        (IsListEmpty(&pDeviceContext->LowerConnFreeHead)) ||
        ((IsDeviceNetbiosless(pDeviceContext)) &&       // Bug # 282190
         (!pDeviceContext->NumServers)))
    {
        if (pSrcAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP) {
            NbtTrace(NBT_TRACE_INBOUND, ("Reject connection on %Z: Non-IP address", &pDeviceContext->BindName));
        } else {
            NbtTrace(NBT_TRACE_INBOUND, ("Reject connection from %!ipaddr!:%d: %s%Z NumServers=%d",
                    ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->in_addr,
                    ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->sin_port,
                    (IsListEmpty(&pDeviceContext->LowerConnFreeHead)?"Out of free LowerConnection ":""),
                    &pDeviceContext->BindName, pDeviceContext->NumServers));
        }
        Status = STATUS_DATA_NOT_ACCEPTED;
    }
    else
    {
        //
        // get a free connection to the transport provider to accept this
        // incoming connnection on.
        //
        pList = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
        pLowerConn = CONTAINING_RECORD (pList,tLOWERCONNECTION,Linkage);

        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        //
        // Move the idle connection to the WaitingForInbound connection list
        //
        InsertTailList (&pDeviceContext->WaitingForInbound,pList);
        InterlockedIncrement (&pDeviceContext->NumWaitingForInbound);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_INBOUND);
        SET_STATERCV_LOWER (pLowerConn, NORMAL, Inbound);

        // increase the reference count because we are now connected.  Decrement
        // it when we disconnect.
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND);
        pLowerConn->bOriginator = FALSE;        // this end is NOT the originator

        // save the source clients IP address into the connection Structure
        // *TODO check if we need to do this or not
        //
        pLowerConn->SrcIpAddr = ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->in_addr;
        *ppConnectionId = (PVOID)pLowerConn;

        Status = STATUS_SUCCESS;
    }

    //
    // If there are less than 2 connections remaining, we allocate another one. The check
    // below is for 0 or 1 connection.
    // In order to protect ourselves from SYN ATTACKS, allocate NbtConfig.SpecialConnIncrement more now until
    // a certain (registry config) value is exhausted (NOTE this number is global and not
    // per device).
    //
    if (((pDeviceContext->NumFreeLowerConnections < NbtConfig.MinFreeLowerConnections) ||
         (pDeviceContext->NumFreeLowerConnections < (pDeviceContext->TotalLowerConnections/10))) &&
        (pDeviceContext->NumQueuedForAlloc < (2*NbtConfig.SpecialConnIncrement)))
    {
        KdPrint(("Nbt.ConnectHndlrNotOs: Queueing SpecialLowerConn: pDevice=<%p>, NumSpecialLowerConn=%d\n",
            pDeviceContext, pDeviceContext->NumSpecialLowerConn));
        NbtTrace(NBT_TRACE_INBOUND, ("Increase special lower connection to %d %Z %!ipaddr!:%d",
                pDeviceContext->NumSpecialLowerConn, &pDeviceContext->BindName,
                pLowerConn->SrcIpAddr,
                ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->sin_port));

#ifdef _PNP_POWER_
        if (!NbtConfig.Unloading)
#endif  // _PNP_POWER_
        {
            if (NT_SUCCESS (CTEQueueForNonDispProcessing( DelayedAllocLowerConnSpecial,
                                          NULL,
                                          NULL,
                                          NULL,
                                          pDeviceContext,
                                          TRUE)))
            {
                InterlockedExchangeAdd (&pDeviceContext->NumQueuedForAlloc, NbtConfig.SpecialConnIncrement);
            } else {
                NbtTrace(NBT_TRACE_INBOUND, ("Out of memory"));
            }
        }
    }

    CTESpinFreeAtDpc(pDeviceContext);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(Status);
}

//----------------------------------------------------------------------------
NTSTATUS
DisconnectHndlrNotOs (
    PVOID                EventContext,
    PVOID                ConnectionContext,
    ULONG                DisconnectDataLength,
    PVOID                pDisconnectData,
    ULONG                DisconnectInformationLength,
    PVOID                pDisconnectInformation,
    ULONG                DisconnectIndicators
    )
/*++

Routine Description:

    This routine is the receive disconnect indication handler. It is called
    by the transport when a connection disconnects.  It checks the state of
    the lower connection and basically returns a disconnect request to the
    transport, except in the case where there is an active session.  In this
    case it calls the the clients disconnect indication handler.  The client
    then turns around and calls NbtDisconnect(in some cases), which passes a disconnect
    back to the transport.  The transport won't disconnect until it receives
    a disconnect request from its client (NBT).  If the flag TDI_DISCONNECT_ABORT
    is set then there is no need to pass back a disconnect to the transport.

    Since the client doesn't always issue a disconnect (i.e. the server),
    this routine always turns around and issues a disconnect to the transport.
    In the disconnect done handling, the lower connection is put back on the
    free list if it is an inbound connection.  For out bound connection the
    lower and upper connections are left connected, since these will always
    receive a cleanup and close connection from the client (i.e. until the
    client does a close the lower connection will not be freed for outbound
    connections).

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    CTELockHandle       OldIrq4;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnectEle;
    tCLIENTELE          *pClientEle;
    enum eSTATE         state, stateLower;
    BOOLEAN             CleanupLower=FALSE;
    PIRP                pIrp= NULL;
    PIRP                pIrpClose= NULL;
    PIRP                pIrpRcv= NULL;
    tDGRAM_SEND_TRACKING *pTracker;
    tTIMERQENTRY        *pTimerEntry;
    BOOLEAN             InsertOnList=FALSE;
    BOOLEAN             DisconnectIt=FALSE;
    ULONG               StateRcv;
    COMPLETIONCLIENT    pCompletion;
    tDEVICECONTEXT      *pDeviceContext = NULL;

    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnectEle = pLowerConn->pUpperConnection;
    PUSH_LOCATION(0x63);

    CHECK_PTR(pLowerConn);
    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.DisconnectHndlrNotOs: Disc Indication, LowerConn state = %X %X\n",
        pLowerConn->State,pLowerConn));

    // get the current state with the spin lock held to avoid a race condition
    // with the client disconnecting
    //
    if (pConnectEle)
    {
        CHECK_PTR(pConnectEle);
        if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.DisconnectHndlrNotOs: Disconnect indication after already disconnected!!\n", 0);
            NbtTrace(NBT_TRACE_DISCONNECT, ("Disconnect indication after already disconnected!!"));
            return STATUS_UNSUCCESSFUL ;
        }

        //
        // We got a case where the ClientEle ptr was null. This shd not happen since the
        // connection shd be associated at this time.
        // Assert for that case to track this better.
        //
        pClientEle = pConnectEle->pClientEle;
        CHECK_PTR(pClientEle);
        if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
        {
            ASSERTMSG ("Nbt.DisconnectHndlrNotOs: Bad Client Handle!!\n", 0);
            return STATUS_UNSUCCESSFUL ;
        }

        // need to hold the joint lock if unconnecting the lower and upper
        // connections.
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq4);

        CTESpinLock(pClientEle,OldIrq3);
        CTESpinLock(pConnectEle,OldIrq2);
        CTESpinLock(pLowerConn,OldIrq);

        NbtTrace(NBT_TRACE_DISCONNECT, ("Disconnection Indication, LowerConn=%p UpperConn=%p ClientEle=%p "
                                "state=%x %!NBTNAME!<%02x> <==> %!NBTNAME!<%02x>",
                    pLowerConn, pConnectEle, pClientEle,
                    pLowerConn->State, pClientEle->pAddress->pNameAddr->Name,
                    (unsigned)pClientEle->pAddress->pNameAddr->Name[15],
                    pConnectEle->RemoteName, (unsigned)pConnectEle->RemoteName[15]));

        state = pConnectEle->state;
        stateLower = pLowerConn->State;

#ifdef VXD
        DbgPrint("DisconnectHndlrNotOs: pConnectEle->state = 0x") ;
        DbgPrintNum( (ULONG) state ) ;
        DbgPrint("pLowerConn->state = 0x") ; DbgPrintNum( (ULONG) stateLower ) ;
        DbgPrint("\r\n") ;
#endif

        if ((state > NBT_ASSOCIATED) && (state < NBT_DISCONNECTING))
        {

            PUSH_LOCATION(0x63);
            CHECK_PTR(pConnectEle);
            //
            // this irp gets returned to the client below in the case statement
            // Except in the connecting state where the transport still has
            // the irp. In that case we let SessionStartupContinue complete
            // the irp.
            //
            if ((pConnectEle->pIrp) && (state > NBT_CONNECTING))
            {
                pIrp = pConnectEle->pIrp;
                pConnectEle->pIrp = NULL;
            }

            //
            // if there is a receive irp, get it out of pConnEle since pConnEle
            // will be requeued and could get used again before we try to
            // complete this irp down below. Null the cancel routine if not
            // cancelled and just complete it below.
            //
            if (((state == NBT_SESSION_UP) || (state == NBT_SESSION_WAITACCEPT))
                && (pConnectEle->pIrpRcv))
            {
                CTELockHandle   OldIrql;

                pIrpRcv = pConnectEle->pIrpRcv;

#ifndef VXD
                IoAcquireCancelSpinLock(&OldIrql);
                //
                // if its already cancelled then don't complete it again
                // down below
                //
                if (pIrpRcv->Cancel)
                {
                    pIrpRcv = NULL;
                }
                else
                {
                    IoSetCancelRoutine(pIrpRcv,NULL);
                }
                IoReleaseCancelSpinLock(OldIrql);
#endif
                pConnectEle->pIrpRcv = NULL;
            }

            // This irp is used for DisconnectWait
            //
            if (pIrpClose = pConnectEle->pIrpClose)
            {
                pConnectEle->pIrpClose = NULL;
            }

#ifdef VXD
            if ( pLowerConn->StateRcv == PARTIAL_RCV &&
                 (pLowerConn->fOnPartialRcvList == TRUE) )
            {
                RemoveEntryList( &pLowerConn->PartialRcvList ) ;
                pLowerConn->fOnPartialRcvList = FALSE;
                InitializeListHead(&pLowerConn->PartialRcvList);
            }
#endif

            SET_STATE_UPPER (pConnectEle, NBT_ASSOCIATED);
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
            NBT_DISASSOCIATE_CONNECTION (pConnectEle, pLowerConn);

            //
            // save whether it is a disconnect abort or disconnect release
            // in case the client does a disconnect wait and wants the
            // real disconnect status  i.e. they do not have a disconnect
            // indication handler
            //
            pConnectEle->DiscFlag = (UCHAR)DisconnectIndicators;

            //
            // pConnectEle is dereferenced below, now that the lower conn
            // no longer points to it.
            //
            InsertOnList = TRUE;
            DisconnectIt = TRUE;

            //
            // put pConnEle back on the list of idle connection for this
            // client
            //
            RemoveEntryList(&pConnectEle->Linkage);
            InsertTailList(&pClientEle->ConnectHead,&pConnectEle->Linkage);

            if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
            {
                // setting the state to disconnected will allow the DisconnectDone
                // routine in updsend.c to Delayedcleanupafterdisconnect, when the disconnect
                // completes (since we have been indicated)
                //
                SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            }
            else
            {
                // there is no disconnect completion to wait for ...since it
                // was an abortive disconnect indication
                // Change the state of the lower conn incase the client has
                // done a disconnect at the same time - we don't want DisconnectDone
                // to also Queue up DelayedCleanupAfterDisconnect
                //
                SET_STATE_LOWER (pLowerConn, NBT_IDLE);
            }
        }
        //
        // the lower connection just went from disconnecting to disconnected
        // so change the state - this signals the DisconnectDone routine to
        // cleanup the connection when the disconnect request completes.
        //
        if (stateLower == NBT_DISCONNECTING)
        {
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
        }
        else if (stateLower == NBT_DISCONNECTED)
        {
            //
            // we get to here if the disconnect request Irp completes before the
            // disconnect indication comes back.  The disconnect completes
            // and checks the state, changing it to Disconnected if it
            // isn't already - see disconnectDone in udpsend.c.  Since
            // the disconnect indication and the disconnect completion
            // have occurred, cleanup the connection.
            //
            CleanupLower = TRUE;

            // this is just a precaution that may not be needed, so we
            // don't queue the cleanup twice...i.e. now that the lower state
            // is disconnected, we change it's state to idle incase the
            // transport hits us again with another disconnect indication.
            // QueueCleanup is called below based on the value in statelower
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);
        }
        //
        // During the time window that a connection is being setup and TCP
        // completes the connect irp, we could get a disconnect indication.
        // the RefCount must be incremented here so that DelayedCleanupAfterDisconnect
        // does not delete the connection (i.e. it expects refcount >= 2).
        //
        if (stateLower <= NBT_CONNECTING)
        {
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        }

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnectEle,OldIrq2);
        CTESpinFree(pClientEle,OldIrq3);
        CTESpinFree(&NbtConfig.JointLock,OldIrq4);
    }
    else
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq2);
        CTESpinLock(pLowerConn->pDeviceContext,OldIrq3);
        CTESpinLock(pLowerConn,OldIrq);
        stateLower = pLowerConn->State;
        state = NBT_IDLE;
        NbtTrace(NBT_TRACE_DISCONNECT, ("Disconnection Indication, LowerConn=%p state=%x on %!ipaddr!",
                                pLowerConn, pLowerConn->State, pLowerConn->pDeviceContext->IpAddress));

        if ((stateLower > NBT_IDLE) && (stateLower < NBT_DISCONNECTING))
        {
            // flag so we send back a disconnect to the transport
            DisconnectIt = TRUE;

            if (stateLower == NBT_SESSION_INBOUND)
            {
                //
                // Previously, the LowerConnection was in the SESSION_INBOUND state
                // hence we have to remove it from the WaitingForInbound Q and put
                // it on the active LowerConnection list!
                //
                ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
                RemoveEntryList (&pLowerConn->Linkage);
                InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
                InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
                //
                // Change the RefCount Context to Connected!
                //
                NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
            }
            //
            // set state so that DisconnectDone will cleanup the connection.
            //
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            //
            // for an abortive disconnect we will do a cleanup below, so
            // set the state to idle here
            //
            if (DisconnectIndicators != TDI_DISCONNECT_RELEASE)
            {
                SET_STATE_LOWER (pLowerConn, NBT_IDLE);
            }
        }
        else if (stateLower == NBT_DISCONNECTING)
        {
            // a Disconnect has already been initiated by this side so when
            // DisconnectDone runs it will cleanup
            //
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
        }
        else if ( stateLower == NBT_DISCONNECTED )
        {
            CleanupLower = TRUE;
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);
        }

        //
        // During the time window that a connection is being setup and TCP
        // completes the connect irp, we could get a disconnect indication.
        // the RefCount must be incremented here so that DelayedCleanupAfterDisconnect
        // does not delete the connection (i.e. it expects refcount >= 2).
        //
        if ((stateLower <= NBT_CONNECTING) &&
            (stateLower > NBT_IDLE))
        {
            NBT_REFERENCE_LOWERCONN(pLowerConn, REF_LOWC_CONNECTED);
        }
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq3);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    }

    StateRcv = pLowerConn->StateRcv;
    SetStateProc (pLowerConn, RejectAnyData);

    if (DisconnectIt)
    {
        if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
        {
            // this disconnects the connection and puts the lowerconn back on
            // its free queue. Note that OutOfRsrcKill calls this routine too
            // with the DisconnectIndicators set to Abort, and the code correctly
            // does not attempt to disconnect the connection since the OutOfRsrc
            // routine had already disconnected it.
            //
            PUSH_LOCATION(0x6d);
            NbtTrace(NBT_TRACE_DISCONNECT, ("Send TCP Disconnect LowerConn=%p on %!ipaddr!",
                                pLowerConn, pLowerConn->pDeviceContext->IpAddress));
            status = SendTcpDisconnect((PVOID)pLowerConn);
        }
        else
        {
            // this is an abortive disconnect from the transport, so there is
            // no need to send a disconnect request back to the transport.
            // So we set a flag that tells us later in the routine to close
            // the lower connection.
            //
            PUSH_LOCATION(0x69);
            CleanupLower = TRUE;
            NbtTrace(NBT_TRACE_DISCONNECT, ("Abort connection LowerConn=%p on %!ipaddr!",
                                pLowerConn, pLowerConn->pDeviceContext->IpAddress));
        }
    }

    //
    // for an orderly release, turn around and send a release to the transport
    // if there is no client attached to the lower connection. If there is a
    // client then we must pass the disconnect indication to the client and
    // wait for the client to do the disconnect.
    //
    //
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DisconnectHndlrNotOs: ConnEle=<%p>, state = %x\n", pConnectEle, state));

    switch (state)
    {
        case NBT_SESSION_INBOUND:
        case NBT_CONNECTING:

            // if an originator, then the upper and lower connections are
            // already associated, and there is a client irp to return.
            // (NBT_SESSION_CONNECTING only)
            //
            if (pIrp)
            {
                if (pLowerConn->bOriginator)
                {
                    CTEIoComplete(pIrp, STATUS_BAD_NETWORK_PATH, 0);
                    NbtTrace(NBT_TRACE_DISCONNECT, ("Complete connect IRP %p with %!status!", pIrp, status));
                }
                else
                {
                    // this could be an inbound call that could not send the
                    // session response correctly.
                    //
                    CTEIoComplete(pIrp, STATUS_UNSUCCESSFUL, 0);
                    NbtTrace(NBT_TRACE_DISCONNECT, ("Complete inbound response IRP %p with STATUS_UNSUCCESSFUL", pIrp));
                }
            }

            break;

        case NBT_SESSION_OUTBOUND:
            //
            //
            // Stop the timer started in SessionStartupCompletion to time the
            // Session Setup Response message
            //
            // NbtConnect stores the tracker in the IrpRcv ptr so that this
            // routine can access it
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLock(pConnectEle,OldIrq2);

            //
            // check if anyone else has freed the tracker yet.
            //
            pTracker = (tDGRAM_SEND_TRACKING *)pConnectEle->pIrpRcv;
            CHECK_PTR(pTracker);
            if (pTracker)
            {
                //
                // We received a Disconnect from Tcp while waiting in
                // the Outbound state!
                //
                pConnectEle->pIrpRcv = NULL;
                pTimerEntry = pTracker->pTimer;
                pTracker->pTimer = NULL;

                CTESpinFree(pConnectEle,OldIrq2);

                //
                // if the timer has expired it will not cleanup because the state
                // will not be SESSION_OUTBOUND, since we changed it above to
                // disconnected.  So we always have to complete the irp and
                // call Delayedcleanupafterdisconnect below.
                //
                if (pTimerEntry)
                {
                    StopTimer(pTimerEntry,&pCompletion,NULL);
                }

                //
                // Check if the SessionStartupCompletion has run; if so, RefConn will be 0.
                // Else, decrement so that the tracker goes away when the session send completes.
                //
                if (pTracker->RefConn == 0)
                {
                    NbtTrace(NBT_TRACE_OUTBOUND, ("Free tracker for %Z %!NBTNAME!<%02x>",
                            &pTracker->pDeviceContext->BindName, pTracker->pDestName, pTracker->pDestName[15]));
                    if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&         // Remote names only!
                        (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
                        (pTracker->pNameAddr->RefCount == 2))
                    {
                        //
                        // If no one else is referencing the name, then delete it from
                        // the hash table.
                        //
                        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
                    }
                    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
                }
                else
                {
                    pTracker->RefConn--;
                    NbtTrace(NBT_TRACE_OUTBOUND, ("Decrease pTracker->RefConn for %Z %!NBTNAME!<%02x>",
                            &pTracker->pDeviceContext->BindName, pTracker->pDestName, pTracker->pDestName[15]));
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                }
            }
            else
            {
                CTESpinFree(pConnectEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }


            if (pIrp)
            {
                NbtTrace(NBT_TRACE_OUTBOUND, ("Complete outbound request IRP %p with STATUS_REMOTE_NOT_LISTENING",
                                        pIrp));
                CTEIoComplete(pIrp,STATUS_REMOTE_NOT_LISTENING,0);
            }

            break;

        case NBT_SESSION_WAITACCEPT:
        case NBT_SESSION_UP:

            if (pIrp)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
            }
            //
            // check for any RcvIrp that may be still around.  If the
            // transport has the Irp now then pIrpRcv = NULL. There should
            // be no race condition between completing it and CompletionRcv
            // setting pIrpRcv again as long as we cannot be indicated
            // for a disconnect during completion of a Receive. In any
            // case the access is coordinated using the Io spin lock io
            // IoCancelIrp - that routine will only complete the irp once,
            // then it nulls the completion routine.
            //
            if ((StateRcv == FILL_IRP) && pIrpRcv)
            {

                PUSH_LOCATION(0x6f);

                IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DisconnectHndlrNotOs: Cancelling RcvIrp on Disconnect Indication!!!\n"));

                CTEIoComplete(pIrpRcv,STATUS_CANCELLED,0);
            }

            //
            // this is a disconnect for an active session, so just inform the client
            // and then it issues a Nbtdisconnect. We have already disconnected the
            // lowerconnection with the transport, so all that remains is
            // to cleanup for outgoing calls.
            //

            pClientEle = pConnectEle->pClientEle;

            // now call the client's disconnect handler...NBT always does
            // a abortive disconnect - i.e. the connection is closed when
            // the disconnect indication occurs and does not REQUIRE a
            // disconnect from the client to finish the job.( a disconnect
            // from the client will not hurt though.
            //
            PUSH_LOCATION(0x64);
            if ((pClientEle) &&
                (pClientEle->evDisconnect ) &&
                (!pIrpClose))
            {
                status = (*pClientEle->evDisconnect)(pClientEle->DiscEvContext,
                                            pConnectEle->ConnectContext,
                                            DisconnectDataLength,
                                            pDisconnectData,
                                            DisconnectInformationLength,
                                            pDisconnectInformation,
                                            TDI_DISCONNECT_ABORT);
                NbtTrace(NBT_TRACE_DISCONNECT, ("Client disconnect handler returns %!status!", status));
            }
            else if (pIrpClose)
            {
                //
                // the Client has issued a disconnect Wait irp, so complete
                // it now, indicating to them that a disconnect has occurred.
                //
                if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
                {
                    status = STATUS_GRACEFUL_DISCONNECT;
                }
                else
                {
                    status = STATUS_CONNECTION_RESET;
                }

                NbtTrace(NBT_TRACE_DISCONNECT, ("Complete client disconnect wait IRP %p with %!status!",
                                        pIrpClose, status));
                CTEIoComplete(pIrpClose,status,0);
            }

            //
            // return any rcv buffers that have been posted
            //
            CTESpinLock(pConnectEle,OldIrq);
            FreeRcvBuffers(pConnectEle,&OldIrq);
            CTESpinFree(pConnectEle,OldIrq);

            break;

        case NBT_DISCONNECTING:
            // the retry session setup code expects the state to change
            // to disconnected when the disconnect indication comes
            // from the wire
            SET_STATE_UPPER (pConnectEle, NBT_DISCONNECTED);

        case NBT_DISCONNECTED:
        case NBT_ASSOCIATED:
        case NBT_IDLE:

            //
            // catch all other cases here to be sure the connect irp gets
            // returned.
            //
            if (pIrp)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
                NbtTrace(NBT_TRACE_DISCONNECT, ("Complete client IRP %p with STATUS_CANCELLED", pIrp));
            }
            break;

        default:
            ASSERTMSG("Nbt:Disconnect indication in unexpected state\n",0);

    }

    if (InsertOnList)
    {
        // undo the reference done when the NbtConnect Ran - this may cause
        // pConnEle to be deleted if the Client had issued an NtClose before
        // this routine ran. We only do this dereference if InsertOnList is
        // TRUE, meaning that we just "unhooked" the lower from the Upper.
        NBT_DEREFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);
    }


    // this either puts the lower connection back on its free
    // queue if inbound, or closes the connection with the transport
    // if out bound. (it can't be done at dispatch level).
    //
    if (CleanupLower)
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.DisconnectHndlrNotOs: Calling Worker thread to Cleanup %X\n",pLowerConn));

        CTESpinLock(pLowerConn,OldIrq);

        if ( pLowerConn->pIrp )
        {
            PCTE_IRP    pIrp;

            pIrp = pLowerConn->pIrp;
            CHECK_PTR(pLowerConn);
            pLowerConn->pIrp = NULL ;

            CTESpinFree(pLowerConn,OldIrq);
            // this is the irp to complete when the disconnect completes - essentially
            // the irp requesting the disconnect.
            CTEIoComplete( pIrp, STATUS_SUCCESS, 0 ) ;
        }
        else
        {
            CTESpinFree(pLowerConn,OldIrq);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        ASSERT (pLowerConn->RefCount > 1);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        status = CTEQueueForNonDispProcessing (DelayedCleanupAfterDisconnect,
                                               NULL,
                                               pLowerConn,
                                               NULL,
                                               pDeviceContext,
                                               TRUE);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
VOID
DelayedCleanupAfterDisconnect(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    This routine handles freeing lowerconnection data structures back to the
    transport, by calling NTclose (outbound only) or by putting the connection
    back on the connection free queue (inbound only).  For the NT case this
    routine runs within the context of an excutive worker thread.

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    PIRP                pIrp=NULL;

    pLowerConn = (tLOWERCONNECTION*) pClientContext;

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DelayedCleanupAfterDisconnect: Originator= %X, pLowerConn=%X\n",
            pLowerConn->bOriginator,pLowerConn));

    //
    // DEBUG to catch upper connections being put on lower conn QUEUE
    //
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
    ASSERT (pLowerConn->RefCount > 1);
    ASSERT (pLowerConn->pUpperConnection == NULL);

    if (!pLowerConn->bOriginator)
    {
        // ******** THIS WAS AN INCOMING CONNECTION *************

        //
        // Inbound lower connections just get put back on the queue, whereas
        // outbound connections simply get closed.
        //
        if (pLowerConn->SpecialAlloc)
        {
            //
            // Connections allocated due to SynAttack backlog measures are not re-allocated
            // If this was a special connection block, decrement the count of such connections
            //
            if (pDeviceContext)
            {
                InterlockedDecrement(&pDeviceContext->NumSpecialLowerConn);
                KdPrint(("Nbt.DelayedCleanupAfterDisconnect: pDevice=<%p>, NumSpecialLowerConn= %d\n",
                    pDeviceContext, pDeviceContext->NumSpecialLowerConn));
            }
        }
        else if (pDeviceContext)
        {
            //
            // Always close the connection and then Create another since there
            // could be a Rcv Irp in TCP still that will be returned at some
            // later time, perhaps after this connection gets reused again.
            // In that case the Rcv Irp could be lost.
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DelayedCleanupAfterDisconnect: LowerConn=<%x>, State=<%x>\n",
                    pLowerConn, pLowerConn->State));

            if (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT) {
                DelayedAllocLowerConn (NULL, NULL, NULL, pDeviceContext);
            }
        }
    }

    // this deref removes the reference added when the connection
    // connnected.  When NbtDeleteLowerConn is called it dereferences
    // one more time which delete the memory.
    //
    CHECK_PTR (pLowerConn);
    ASSERT (pLowerConn->RefCount >= 2);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED, FALSE);

    // this does a close on the lower connection, so it can go ahead
    // possibly before the disconnect has completed since the transport
    // will not complete the close until is completes the disconnect.
    //
    status = NbtDeleteLowerConn(pLowerConn);
}

//----------------------------------------------------------------------------
VOID
AllocLowerConn(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  PVOID          pDeviceSpecial
    )
/*++

Routine Description:

    Allocate a lowerconn block that will go on the lowerconnfreehead.

Arguments:

    pDeviceContext - the device context

Return Value:


--*/
{
    NTSTATUS             status;
    tLOWERCONNECTION    *pLowerConn;

    /*
     * This should be ok since NbtOpenAndAssocConnection call NbtTdiOpenConnection which is PAGEABLE.
     * Make sure we are at the right IRQL.
     */
    CTEPagedCode();
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    if (pDeviceContext->Verify != NBT_VERIFY_DEVCONTEXT) {
        ASSERT (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT_DOWN);
        CTEExReleaseResource(&NbtConfig.Resource);
        return;
    }
    if (pDeviceSpecial)
    {
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, &pLowerConn, '0');
    }
    else
    {
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '1');
    }
    CTEExReleaseResource(&NbtConfig.Resource);

    if (pDeviceSpecial)
    {
        //
        // Special lowerconn for Syn attacks
        //
        if (NT_SUCCESS(status))
        {
            pLowerConn->SpecialAlloc = TRUE;
            InterlockedIncrement(&pDeviceContext->NumSpecialLowerConn);
        }

        InterlockedDecrement(&pDeviceContext->NumQueuedForAlloc);
    }
}

//----------------------------------------------------------------------------
VOID
DelayedAllocLowerConn(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pDeviceSpecial,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    If lowerconn couldn't be alloced in AllocLowerConn, an event is scheduled
    so that we can retry later.  Well, this is "later"!

Arguments:



Return Value:


--*/
{
    AllocLowerConn(pDeviceContext, pDeviceSpecial);
}

//----------------------------------------------------------------------------
VOID
DelayedAllocLowerConnSpecial(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    If lowerconn couldn't be alloced in AllocLowerConn, an event is scheduled
    so that we can retry later.  Well, this is "later"!

    This is for SYN-ATTACK, so we shd create more than one to beat the incoming
    requests. Create three at a time - this shd be controllable thru' registry.

Arguments:



Return Value:


--*/
{
    ULONG               i;

    if (pDeviceContext->Verify != NBT_VERIFY_DEVCONTEXT) {
        ASSERT (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT_DOWN);
        return;
    }

    KdPrint(("Nbt.DelayedAllocLowerConnSpecial: Allocing spl. %d lowerconn...\n",
        NbtConfig.SpecialConnIncrement));

    //
    // Alloc SpecialConnIncrement number of more connections.
    //
    for (i=0; i<NbtConfig.SpecialConnIncrement; i++)
    {
        DelayedAllocLowerConn(NULL, pDeviceContext, NULL, pDeviceContext);
    }
}

//----------------------------------------------------------------------------
VOID
AddToRemoteHashTbl (
    IN  tDGRAMHDR UNALIGNED  *pDgram,
    IN  ULONG                BytesIndicated,
    IN  tDEVICECONTEXT       *pDeviceContext
    )
/*++

Routine Description:

    This routine adds the source address of an inbound datagram to the remote
    hash table so that it can be used for subsequent return sends to that node.

    This routine does not need to be called if the datagram message type is
    Broadcast datagram, since these are sends to the broadcast name '*' and
    there is no send caching this source name

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    tNAMEADDR           *pNameAddr;
    CTELockHandle       OldIrq;
    UCHAR               pName[NETBIOS_NAME_SIZE];
    NTSTATUS            status;
    LONG                Length;
    ULONG               SrcIpAddr;
    PUCHAR              pScope;

    //
    // source ip addr should never be 0.  This is a workaround for UB's NBDD
    // which forwards the datagram, but client puts 0 in SourceIpAddr field
    // of the datagram, we cache 0 and then end up doing a broadcast when we
    // really meant to do a directed datagram to the sender.
    //
    SrcIpAddr = ntohl(pDgram->SrcIpAddr);
    if ((!SrcIpAddr) ||
        (!NT_SUCCESS (status = ConvertToAscii ((PCHAR)&pDgram->SrcName,
                                               (BytesIndicated - FIELD_OFFSET(tDGRAMHDR,SrcName)),
                                               pName,
                                               &pScope,
                                               &Length))))
    {
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // Add the name to the remote cache.
    //
    status = AddToHashTable(NbtConfig.pRemoteHashTbl,
                            pName,
                            pScope,
                            SrcIpAddr,
                            NBT_UNIQUE,     // always a unique address since you can't send from a group name
                            NULL,
                            &pNameAddr,
                            pDeviceContext,
                            NAME_RESOLVED_BY_DGRAM_IN);

    if (NT_SUCCESS(status))
    {
        //
        // we only want the name to be in the remote cache for the shortest
        // timeout allowed by the remote cache timer, so set the timeout
        // count to 1 which is 1-2 minutes.
        //

        // the name is already in the cache when Pending is returned,
        // so just update the ip address in case it is different.
        //
        if (status == STATUS_PENDING)
        {
            //
            // If the name is resolved then it is ok to overwrite the
            // ip address with the incoming one.  But if it is resolving,
            // then just let it continue resolving.
            //
            if ( (pNameAddr->NameTypeState & STATE_RESOLVED) &&
                 !(pNameAddr->NameTypeState & NAMETYPE_INET_GROUP))
            {
                pNameAddr->TimeOutCount = 1;
                // only set the adapter mask for this adapter since we are
                // only sure that this adapter can reach the dest.
                pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
            }
        }
        else
        {
            pNameAddr->TimeOutCount = 1;
            //
            // change the state to resolved
            //
            pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
            pNameAddr->NameTypeState |= STATE_RESOLVED;
            pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
NTSTATUS
DgramHndlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  ULONG               SourceAddrLength,
    IN  PVOID               pSourceAddr,
    IN  ULONG               OptionsLength,
    IN  PVOID               pOptions,
    IN  ULONG               ReceiveDatagramFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              pBytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppRcvBuffer,
    IN  tCLIENTLIST         **ppClientList
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an a datgram arrives from the network.  The code
    checks the type of datagram and then tries to route the datagram to
    the correct destination on the node.

    This procedure is called with the spin lock held on pDeviceContext.

Arguments:

    ppRcvbuffer will contain the IRP/NCB if only one client is listening,
        NULL if multiple clients are listening
    ppClientList will contain the list clients that need to be completed,
        NULL if only one client is listening



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    NTSTATUS            LocStatus;
    tCLIENTELE          *pClientEle;
    tCLIENTELE          *pClientEleToDeref = NULL;
    tNAMEADDR           *pNameAddr;
    tADDRESSELE         *pAddress;
    ULONG               RetNameType;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    ULONG               lNameSize;
    ULONG               iLength = 0;
    ULONG               RemoteAddressLength;
    PVOID               pRemoteAddress;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)ReceiveEventContext;
    tDGRAMHDR UNALIGNED *pDgram = (tDGRAMHDR UNALIGNED *)pTsdu;
    ULONG               lClientBytesTaken;
    ULONG               lDgramHdrSize;
    PIRP                pIrp;
    BOOLEAN             MoreClients;
    BOOLEAN             UsingClientBuffer;
    CTEULONGLONG        AdapterMask;
    ULONG               BytesIndicatedOrig;
    ULONG               BytesAvailableOrig;
    ULONG               Offset;

    //
    // We will be processing only directed or broadcast datagrams
    // Hence, there must be at least the header plus two half ascii names etc.
    // which all adds up to 82 bytes with no user data
    // ie. 14 + (1+32+1) + (1+32+1)     ==> Assuming 0 Scopelength + 0 UserData
    //
    if ((BytesIndicated  < 82) ||
        (pDgram->MsgType < DIRECT_UNIQUE) ||
        (pDgram->MsgType > BROADCAST_DGRAM))
    {
        KdPrint (("Nbt.DgramHndlrNotOs[1]: WARNING! Rejecting Dgram -- BytesIndicated=<%d>, MsgType=<0x%x>\n",
            BytesIndicated, pDgram->MsgType));
        NbtTrace(NBT_TRACE_RECVDGRAM, ("Rejecting Dgram: BytesIndicated=%d, MsgType=0x%x",
                                BytesIndicated, pDgram->MsgType));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // First, find the end of the SourceName .. it should end in a 0 byte,
    // but use strnlen just to be safe!  (BUG # 114996)
    //
    // Then, find the destination name in the local name service tables
    //
    Offset = FIELD_OFFSET(tDGRAMHDR,SrcName.NetBiosName[0]);
    if ((!NT_SUCCESS (LocStatus = strnlen ((PCHAR)pDgram->SrcName.NetBiosName,
                                           BytesIndicated-Offset,
                                           &iLength)))              ||
        (BytesIndicated < (Offset+iLength+1+1+32+1))                ||
        (!NT_SUCCESS (status = ConvertToAscii ((PCHAR)&pDgram->SrcName.NetBiosName[iLength+1],
                                               BytesIndicated-(Offset+iLength+1),    // Bug#: 124441
                                               pName,
                                               &pScope,
                                               &lNameSize))))
    {
        NbtTrace(NBT_TRACE_RECVDGRAM, ("Rejecting Dgram: strnlen=%!status!, ConvertToAscii=%!status!",
                                            LocStatus, status));
        KdPrint (("Nbt.DgramHndlrNotOs: WARNING!!! Rejecting Dgram -- strnlen-><%x>, ConvertToAscii-><%x>\n",
            LocStatus, status));
        KdPrint (("Nbt.DgramHndlrNotOs: iLength=<%d>, Half-Ascii Dest=<%p>, Ascii Dest=<%p>\n",
            iLength, &pDgram->SrcName.NetBiosName[iLength+1], pName));
//        ASSERT (0);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check length again, including scopes of names too. The Src
    // scope length is returned in iLength, which also includes the
    // half ascii length
    //
    if (BytesIndicated < ( 82                               // 14(Hdr) + 2 HalfAscii names (2*(1+32+1))
                          +(iLength-(2*NETBIOS_NAME_SIZE))  // Src ScopeLength
                          +(NbtConfig.ScopeLength-1)))      // Dest (ie Local) ScopeLength
    {
        KdPrint (("Nbt.DgramHndlrNoOs[2]: WARNING!!! Rejecting Dgram -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, 82+(iLength-(2*NETBIOS_NAME_SIZE))+(NbtConfig.ScopeLength-1)));
        NbtTrace(NBT_TRACE_RECVDGRAM, ("Rejecting Dgram -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, 82+(iLength-(2*NETBIOS_NAME_SIZE))+(NbtConfig.ScopeLength-1)));
        ASSERT (0);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    status = STATUS_DATA_NOT_ACCEPTED;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Check for the full name first instead of considering any name with a '*' as
    // the first char as a broadcast name (e.g. *SMBSERVER and *SMBDATAGRAM are not
    // b'cast names).
    //
    pNameAddr = FindName (NBT_LOCAL, pName, pScope, &RetNameType);

    //
    // If we failed above, it might be because the name could start with '*' and is a
    // bcast name.
    //
    if (!pNameAddr)
    {
        //
        // be sure the broadcast name has 15 zeroes after it
        //
        if (pName[0] == '*')
        {
            CTEZeroMemory(&pName[1],NETBIOS_NAME_SIZE-1);
            pNameAddr = FindName (NBT_LOCAL, pName, pScope, &RetNameType);
        }
    }

    // Change the pTsdu ptr to pt to the users data
    // -2 to account for the tNETBIOSNAME and +2 to add the length
    // bytes for both names, +1 for the null on the end of the first
    // name

    lDgramHdrSize   = sizeof(tDGRAMHDR) - 2 + 1+iLength+1 + 1+lNameSize;
    pTsdu           = (PVOID)((PUCHAR)pTsdu + lDgramHdrSize);
    BytesAvailableOrig  = BytesAvailable;
    BytesAvailable -= lDgramHdrSize;
    BytesIndicatedOrig = BytesIndicated;
    BytesIndicated -= lDgramHdrSize;

    //
    // If the name is in the local table and has an address element
    // associated with it AND the name is registered against
    // this adapter, then execute the code in the 'if' block
    //
    AdapterMask = pDeviceContext->AdapterMask;
    if ((pNameAddr) &&
        (pNameAddr->pAddressEle) &&
        (pNameAddr->AdapterMask & AdapterMask))
    {
        pAddress = pNameAddr->pAddressEle;

        // Need to hold Address lock to traverse ClientHead
        CTESpinLock(pAddress, OldIrq1);

        if (!IsListEmpty(&pAddress->ClientHead))
        {
            PLIST_ENTRY         pHead;
            PLIST_ENTRY         pEntry;

            //
            // Increment the reference count to prevent the
            // pAddress from disappearing in the window between freeing
            // the JOINT_LOCK and taking the ADDRESS_LOCK.  We also need to
            // keep the refcount if we are doing a multi client recv, since
            // Clientlist access pAddressEle when distributing the rcv'd dgram
            // in CompletionRcvDgram.
            //
            NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);

            *pBytesTaken = lDgramHdrSize;

            //
            // Check if there is more than one client that should receive this
            // datagram.  If so then pass down a new buffer to get it and
            // copy it to each client's buffer in the completion routine.
            //
            *ppRcvBuffer = NULL;
            MoreClients = FALSE;
            *ppClientList = NULL;

            pHead = &pAddress->ClientHead;
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                PTDI_IND_RECEIVE_DATAGRAM  EvRcvDgram;
                PVOID                      RcvDgramEvContext;
                PLIST_ENTRY                pRcvEntry;
                tRCVELE                    *pRcvEle;
                ULONG                      MaxLength;
                PLIST_ENTRY                pSaveEntry;

                pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                // this client must be registered against this adapter to
                // get the data
                //
                if (!(pClientEle->pDeviceContext) ||
                    (pClientEle->pDeviceContext != pDeviceContext))
                {
                    pEntry = pEntry->Flink;
                    continue;
                }

#ifdef VXD
                //
                //  Move all of the RcvAnyFromAny Datagrams to this client's
                //  RcvDatagram list so they will be processed along with the
                //  outstanding datagrams for this client if this isn't a
                //  broadcast reception (RcvAnyFromAny dgrams
                //  don't receive broadcasts).  The first client will
                //  empty the list, which is ok.
                //
                if (*pName != '*')
                {
                    PLIST_ENTRY pDGEntry ;

                    while ( !IsListEmpty( &pDeviceContext->RcvDGAnyFromAnyHead ))
                    {
                        pDGEntry = RemoveHeadList(&pDeviceContext->RcvDGAnyFromAnyHead) ;
                        InsertTailList( &pClientEle->RcvDgramHead, pDGEntry ) ;
                    }
                }
#endif
                // check for datagrams posted to this name, and if not call
                // the recv event handler. NOTE: this assumes that the clients
                // use posted recv buffer OR and event handler, but NOT BOTH.
                // If two clients open the same name, one with a posted rcv
                // buffer and another with an event handler, the one with the
                // event handler will NOT get the datagram!
                //
                if (!IsListEmpty(&pClientEle->RcvDgramHead))
                {
                    MaxLength  = 0;
                    pSaveEntry = pEntry;
                    //
                    // go through all clients finding one that has a large
                    // enough buffer
                    //
                    while (pEntry != pHead)
                    {
                        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                        if (IsListEmpty(&pClientEle->RcvDgramHead))
                        {
                            continue;
                        }

                        pRcvEntry = pClientEle->RcvDgramHead.Flink;
                        pRcvEle   = CONTAINING_RECORD(pRcvEntry,tRCVELE,Linkage);

                        if (pRcvEle->RcvLength >= BytesAvailable)
                        {
                            pSaveEntry = pEntry;
                            break;
                        }
                        else
                        {
                            // keep the maximum rcv length around incase none
                            // is large enough
                            //
                            if (pRcvEle->RcvLength > MaxLength)
                            {
                                pSaveEntry = pEntry;
                                MaxLength = pRcvEle->RcvLength;
                            }
                            pEntry = pEntry->Flink;
                        }
                    }

                    //
                    // Get the buffer off the list
                    //
                    pClientEle = CONTAINING_RECORD(pSaveEntry,tCLIENTELE,Linkage);

                    pRcvEntry = RemoveHeadList(&pClientEle->RcvDgramHead);

                    *ppRcvBuffer = pRcvEle->pIrp;
#ifdef VXD
                    ASSERT( pDgram->SrcName.NameLength <= NETBIOS_NAME_SIZE*2) ;
                    LocStatus = ConvertToAscii(
                                        (PCHAR)&pDgram->SrcName,
                                        pDgram->SrcName.NameLength+1,
                                        ((NCB*)*ppRcvBuffer)->ncb_callname,
                                        &pScope,
                                        &lNameSize);

                    if ( !NT_SUCCESS(LocStatus) )
                    {
                        DbgPrint("ConvertToAscii failed\r\n") ;
                    }
#else //VXD

                    //
                    // put the source of the datagram into the return
                    // connection info structure.
                    //
                    if (pRcvEle->ReturnedInfo)
                    {
                        UCHAR   pSrcName[NETBIOS_NAME_SIZE];

                        Offset = FIELD_OFFSET(tDGRAMHDR,SrcName);   // Bug#: 124434
                        LocStatus = ConvertToAscii(
                                            (PCHAR)&pDgram->SrcName,
                                            BytesIndicatedOrig-Offset,
                                            pSrcName,
                                            &pScope,
                                            &lNameSize);

                        if (pRcvEle->ReturnedInfo->RemoteAddressLength >=
                            sizeof(TA_NETBIOS_ADDRESS))
                        {
                            TdiBuildNetbiosAddress(pSrcName,
                                                   FALSE,
                                                   pRcvEle->ReturnedInfo->RemoteAddress);
                        }
                    }

                    //
                    // Null out the cancel routine since we are passing the
                    // irp to the transport
                    //
                    IoAcquireCancelSpinLock(&OldIrq);
                    IoSetCancelRoutine(pRcvEle->pIrp,NULL);
                    IoReleaseCancelSpinLock(OldIrq);
#endif
                    CTEMemFree((PVOID)pRcvEle);

                    if (pAddress->MultiClients)
                    {
                        // the multihomed host always passes the above test
                        // so we need a more discerning test for it.
                        if (!NbtConfig.MultiHomed)
                        {
                            // if the list is more than one on it,
                            // then there are several clients waiting
                            // to receive this datagram, so pass down a buffer to
                            // get it.
                            //
                            MoreClients = TRUE;
                            status = STATUS_SUCCESS;

                            UsingClientBuffer = TRUE;

                            // this break will jump down below where we check if
                            // MoreClients = TRUE

                            //
                            // We will need to keep the Client around when CompletionRcvDgram executes!
                            // Bug#: 124675
                            //
                            NBT_REFERENCE_CLIENT(pClientEle);
                            //
                            // Increment the RefCount by 1 here since there will be
                            // an extra Dereference in CompletionRcvDgram
                            //
                            NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
                            break;
                        }
                        else
                        {

                        }
                    }

                    status = STATUS_SUCCESS;

                    //
                    // jump to end of while to check if we need to buffer
                    // the datagram source address
                    // in the remote hash table
                    //
                    break;
                }
#ifdef VXD
                break;
#else
                EvRcvDgram        = pClientEle->evRcvDgram;
                RcvDgramEvContext = pClientEle->RcvDgramEvContext;

                // don't want to call the default handler since it just
                // returns data not accepted
                if (pClientEle->evRcvDgram != TdiDefaultRcvDatagramHandler)
                {
                    ULONG   NumAddrs;

                    // finally found a real event handler set by a client
                    if (pAddress->MultiClients)
//                        if (pEntry->Flink != pHead)
                    {
                        // if the next element in the list is not the head
                        // of the list then there are several clients waiting
                        // to receive this datagram, so pass down a buffer to
                        // get it.
                        //
                        MoreClients = TRUE;
                        UsingClientBuffer = FALSE;
                        status = STATUS_SUCCESS;

                        //
                        // We will need to keep the Client around when CompletionRcvDgram executes!
                        // Bug#: 124675
                        //
                        NBT_REFERENCE_CLIENT(pClientEle);
                        //
                        // Increment the RefCount by 1 here since there will be
                        // an extra Dereference out of the while loop
                        //
                        NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
                        break;
                    }

                    //
                    // make up an address datastructure - subtracting the
                    // number of bytes skipped from the total length so
                    // convert to Ascii can not bug chk on bogus names.
                    //
                    if (pClientEle->ExtendedAddress)
                    {
                        NumAddrs = 2;
                    }
                    else
                    {
                        NumAddrs = 1;
                    }

                    LocStatus = MakeRemoteAddressStructure(
                                     (PCHAR)&pDgram->SrcName.NameLength,
                                     pSourceAddr,
                                     BytesIndicatedOrig - FIELD_OFFSET(tDGRAMHDR,SrcName.NameLength),
                                     &pRemoteAddress,                      // the end of the pdu.
                                     &RemoteAddressLength,
                                     NumAddrs);

                    if (!NT_SUCCESS(LocStatus))
                    {
                        NbtTrace(NBT_TRACE_RECVDGRAM, ("MakeRemoteAddressStruture returns %!status!", status));
                        CTESpinFree(pAddress, OldIrq1);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        if (pClientEleToDeref)
                        {
                            NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
                        }
                        NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);
                        return(STATUS_DATA_NOT_ACCEPTED);
                    }

                    NBT_REFERENCE_CLIENT(pClientEle);
                    CTESpinFree(pAddress, OldIrq1);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    if (pClientEleToDeref)
                    {
                        NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
                    }
                    pClientEleToDeref = pClientEle;

                    pIrp = NULL;
                    lClientBytesTaken = 0;
                    LocStatus = (*EvRcvDgram)(RcvDgramEvContext,
                                        RemoteAddressLength,
                                        pRemoteAddress,
                                        OptionsLength,
                                        pOptions,
                                        ReceiveDatagramFlags,
                                        BytesIndicated,
                                        BytesAvailable,
                                        &lClientBytesTaken,
                                        pTsdu,
                                        &pIrp);

                    CTEMemFree((PVOID)pRemoteAddress);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                    CTESpinLock(pAddress, OldIrq1);

                    if (pIrp)
                    {
                        // the client has passed back an irp so pass it
                        // on the transport
                        *pBytesTaken += lClientBytesTaken;
                        *ppRcvBuffer = pIrp;

                        status = STATUS_SUCCESS;
                        break;
                    }
                    else
                    {
                        NbtTrace(NBT_TRACE_RECVDGRAM, ("Indicate datagram to the client, client returns %!status!",
                                                LocStatus));
                        status = STATUS_DATA_NOT_ACCEPTED;
                    }
                }

                pEntry = pEntry->Flink;     // go to the next client in the list
#endif // VXD
            }// of While

            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pClientEleToDeref)
            {
                NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
            }
            NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);

            //
            // Cache the source address in the remote hash table so that
            // this node can send back to the source even if the name
            // is not yet in the name server yet. (only if not on the
            // same subnet)
            //
            if ((pDgram->MsgType != BROADCAST_DGRAM))
            {
                ULONG               SrcAddress;
                PTRANSPORT_ADDRESS  pSourceAddress;
                ULONG               SubnetMask;

                pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;
                SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
                SubnetMask     = pDeviceContext->SubnetMask;
                //
                // - cache only if from off the subnet
                // - cache if not sent to 1E,1D,01 name and not from ourselves
                //
                // don't cache dgrams from ourselves, or datagrams to the
                // 1E name, 1D, or 01.
                //
                if (((SrcAddress & SubnetMask) !=
                    (pDeviceContext->IpAddress & SubnetMask))
                                ||
                    ((pName[NETBIOS_NAME_SIZE-1] != 0x1E) &&
                     (pName[NETBIOS_NAME_SIZE-1] != 0x1D) &&
                     (pName[NETBIOS_NAME_SIZE-1] != 0x01) &&
                     (!SrcIsUs(SrcAddress))))
                {
                    AddToRemoteHashTbl(pDgram,BytesIndicatedOrig,pDeviceContext);
                }
            }

            // alloc a block of memory to track where we are in the list
            // of clients so completionrcvdgram can send the dgram to the
            // other clients too.
            //
            if (MoreClients)
            {
                tCLIENTLIST     *pClientList;

                if (pClientList = (tCLIENTLIST *)NbtAllocMem(sizeof(tCLIENTLIST),NBT_TAG('4')))
                {
                    CTEZeroMemory (pClientList, sizeof(tCLIENTLIST));

                    //
                    // Set fProxy field to FALSE since the client list is for
                    // real as versus the PROXY case
                    //
                    pClientList->fProxy = FALSE;

                    // save some context information so we can pass the
                    // datagram to the clients - none of the clients have
                    // recvd the datagram yet.
                    //
                    *ppClientList            = (PVOID)pClientList;
                    pClientList->pAddress    = pAddress;
                    pClientList->pClientEle  = pClientEle; // used for VXD case
                    pClientList->fUsingClientBuffer = UsingClientBuffer;
                    pClientList->ReceiveDatagramFlags = ReceiveDatagramFlags;

                    // make up an address datastructure
                    // Bug # 452211 -- since one of the clients may have the Extended
                    // addressing field set, create an extended address
                    //
                    LocStatus = MakeRemoteAddressStructure(
                                   (PCHAR)&pDgram->SrcName.NameLength,
                                   pSourceAddr,
                                   BytesIndicatedOrig -FIELD_OFFSET(tDGRAMHDR,SrcName.NameLength),// set a max number of bytes so we don't go beyond
                                   &pRemoteAddress,                      // the end of the pdu.
                                   &RemoteAddressLength,
                                   2);
                    if (NT_SUCCESS(LocStatus))
                    {
                        pClientList->pRemoteAddress = pRemoteAddress;
                        pClientList->RemoteAddressLength = RemoteAddressLength;
                        return(STATUS_SUCCESS);
                    }
                    else
                    {
                        *ppClientList = NULL;
                        CTEMemFree(pClientList);
                        NbtTrace(NBT_TRACE_RECVDGRAM, ("MakeRemoteAddressStruture returns %!status!", LocStatus));
                        status = STATUS_DATA_NOT_ACCEPTED;
                    }
                }
                else
                {
                    status = STATUS_DATA_NOT_ACCEPTED;
                }

                //
                // We failed, so Dereference the Client + Address we had
                // reference earlier for multiple clients
                //
                NBT_DEREFERENCE_CLIENT (pClientEle);
                NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
            }
        }
        else
        {
            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_DATA_NOT_ACCEPTED;

            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.DgramHndlrNotOs: No client attached to the Address %16.16s<%X>\n",
                        pAddress->pNameAddr->Name,pAddress->pNameAddr->Name[15]));
            NbtTrace(NBT_TRACE_RECVDGRAM, ("No client attached to the address %!NBTNAME!<%02x>",
                        pAddress->pNameAddr->Name,pAddress->pNameAddr->Name[15]));
        }
    }
    else
    {

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_DATA_NOT_ACCEPTED;
    }

#ifdef PROXY_NODE
    IF_PROXY(NodeType)
    {
        ULONG               SrcAddress;
        PTRANSPORT_ADDRESS  pSourceAddress;

        pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;
        SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);

        //
        // check name in the remote name table.  If it is there, it is
        // an internet group and is in the resolved state, send the
        // datagram to all the members except self.  If it is in the
        // resolving state, just return. The fact that we got a
        // datagram send for  an internet group name still in the
        // resolving state indicates that there is a DC on the subnet
        // that responded to the  query for the group received
        // earlier. This means that the DC will respond (unless it
        // goes down) to this datagram send. If the DC is down, the
        // client node will retry.
        //
        // Futures: Queue the Datagram if the name is in the resolving
        //  state.
        //
        // If Flags are zero then it is a non fragmented Bnode send.  There
        // is not point in doing datagram distribution for P,M,or H nodes
        // can they can do their own.
        //
        if (((pDgram->Flags & SOURCE_NODE_MASK) == 0) &&
            (pName[0] != '*') &&
           (!SrcIsUs(SrcAddress)))
        {
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            pNameAddr = FindName (NBT_REMOTE, pName, pScope, &RetNameType);
            if (pNameAddr)
            {
                //
                // We have the name in the RESOLVED state.
                //
                //
                // If the name is an internet group, do datagram distribution
                // function
                // Make sure we don't distribute a datagram that has been
                // sent to us by another proxy.  In other words, distribute
                // the datagram only if we got it first-hand from original node
                //
                if ((pNameAddr->NameTypeState & NAMETYPE_INET_GROUP) &&
                    ((((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr) == pDgram->SrcIpAddr))
                {
                    //
                    // If BytesAvailable != BytesIndicated, it means that
                    // that we don't have the entire datagram.  We need to
                    // get it
                    if (BytesAvailableOrig != BytesIndicatedOrig)
                    {
                        tCLIENTLIST     *pClientList;

                        //
                        // Do some simulation to fake the caller of this fn
                        // (TdiRcvDatagramHndlr) into thinking that there are
                        // multiple clients.  This will result in
                        // TdiRcvDatagramHndlr function getting all bytes
                        // available from TDI and calling
                        // ProxyDoDgramDist to do the datagram distribution
                        //
                        if (pClientList = (tCLIENTLIST *)NbtAllocMem(sizeof(tCLIENTLIST),NBT_TAG('5')))
                        {
                            CTEZeroMemory (pClientList, sizeof(tCLIENTLIST));

                            //
                            // save some context information in the Client List
                            // data structure
                            //
                            *ppClientList = (PVOID)pClientList;
                            //
                            // Set fProxy field to TRUE since the client list
                            // not for real
                            //
                            pClientList->fProxy          = TRUE;

                            //
                            // Make use of the following fields to pass the
                            // information we would need in the
                            // CompletionRcvDgram
                            //
                            pClientList->pAddress = (tADDRESSELE *)pNameAddr;
                            pClientList->pRemoteAddress  = pDeviceContext;

                            status = STATUS_DATA_NOT_ACCEPTED;
                        }
                        else
                        {
                           status = STATUS_UNSUCCESSFUL;
                        }

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    } // end of if (we do not have the entire datagram)
                    else
                    {
                        //
                        // Increment the reference count so that this name
                        // does not disappear on us after we free the spin lock.
                        //
                        // DgramSendCleanupTracker will decrement the count
                        //
                        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM);
                        //
                        //We have the entire datagram.
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        (VOID)ProxyDoDgramDist(pDgram,
                                               BytesIndicatedOrig,
                                               pNameAddr,
                                               pDeviceContext);
                        NbtTrace(NBT_TRACE_PROXY, ("PROXY: Do Dgram distribution for %!NBTNAME!<%02x> from %!ipaddr!",
                                    pName, (unsigned)pName[15], SrcAddress));

                        status = STATUS_DATA_NOT_ACCEPTED;
                    }

                }  // end of if (if name is an internet group name)
                else
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

            }  // end of if (Name is there in remote hash table)
            else
            {
                tNAMEADDR   *pResp;

                //
                // the name is not in the cache, so try to get it from
                // WINS
                //
                status = FindOnPendingList(pName,NULL,TRUE,NETBIOS_NAME_SIZE,&pResp);
                if (!NT_SUCCESS(status))
                {
                    //
                    // cache the name and contact the name
                    // server to get the name to IP mapping
                    //
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    NbtTrace(NBT_TRACE_PROXY, ("PROXY: Query name %!NBTNAME!<%02x> from %!ipaddr!",
                                    pName, (unsigned)pName[15], SrcAddress));
                    status = RegOrQueryFromNet(
                              FALSE,          //means it is a name query
                              pDeviceContext,
                              NULL,
                              lNameSize,
                              pName,
                              pScope);
                }
                else
                {
                    //
                    // the name is on the pending list doing a name query
                    // now, so ignore this name query request
                    //
                    NbtTrace(NBT_TRACE_PROXY, ("PROXY: Ignore the name query %!NBTNAME!<%02x> from %!ipaddr!"
                                            "because it is in the pending list doing a name query",
                                    pName, (unsigned)pName[15], SrcAddress));
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                }
                status = STATUS_DATA_NOT_ACCEPTED;
            }
        } else {
            NbtTrace(NBT_TRACE_PROXY, ("Discard datagram %!NBTNAME!<%02x> %!ipaddr!",
                                    pName, (unsigned)pName[15], SrcAddress));
        }
    }
    END_PROXY
#endif

    return(status);
}

#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
ProxyDoDgramDist(
    IN  tDGRAMHDR   UNALIGNED   *pDgram,
    IN  DWORD                   DgramLen,
    IN  tNAMEADDR               *pNameAddr,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:


Arguments:

    ppRcvbuffer will contain the IRP/NCB if only one client is listening,
        NULL if multiple clients are listening
    ppClientList will contain the list clients that need to be completed,
        NULL if only one client is listening

Return Value:

    NTSTATUS - Status of receive operation

Called By:

     DgramHdlrNotOs, CompletionRcvDgram in tdihndlr.c

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAMHDR               *pMyBuff;

    //
    // get a buffer for tracking Dgram Sends
    //
    status = GetTracker(&pTracker, NBT_TRACKER_PROXY_DGRAM_DIST);
    if (!NT_SUCCESS(status))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM, FALSE);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Allocate a buffer and copy the contents of the datagram received
    // into it.  We do this because SndDgram may not have finished by the
    // time we return.
    //
    if (!(pMyBuff = (tDGRAMHDR *) NbtAllocMem(DgramLen,NBT_TAG('6'))))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM, FALSE);
        FreeTracker (pTracker, RELINK_TRACKER);
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    CTEMemCopy(pMyBuff, (PUCHAR)pDgram, DgramLen);

    //
    // fill in the tracker data block
    // note that the passed in transport address must stay valid till this
    // send completes
    //
    CHECK_PTR(pTracker);
    pTracker->SendBuffer.pDgramHdr = (PVOID)pMyBuff;
    pTracker->SendBuffer.HdrLength = DgramLen;
    pTracker->SendBuffer.pBuffer   = NULL;
    pTracker->SendBuffer.Length    = 0;
    pTracker->pNameAddr            = pNameAddr;
    pTracker->pDeviceContext       = (PVOID)pDeviceContext;
    pTracker->p1CNameAddr          = NULL;
    //
    // so DgramSendCleanupTracker does not decrement the bytes allocated
    // to dgram sends, since we did not increment the count when we allocated
    // the dgram buffer above.
    //
    pTracker->AllocatedLength      = 0;

    pTracker->pClientIrp           = NULL;
    pTracker->pClientEle           = NULL;

    KdPrint(("Nbt.ProxyDoDgramDist: Name is %16.16s(%X)\n", pNameAddr->Name,
                pNameAddr->Name[15]));

    //
    // Send the datagram to each IP address in the Internet group
    //
    //
    DatagramDistribution(pTracker,pNameAddr);

    return(STATUS_SUCCESS);
}
#endif

//----------------------------------------------------------------------------
NTSTATUS
NameSrvHndlrNotOs (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes,
    IN BOOLEAN                  fBroadcast
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an a datgram arrives from the network.  The code
    checks the type of datagram and then tries to route the datagram to
    the correct destination on the node.

    This procedure is called with the spin lock held on pDeviceContext.

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    USHORT              OpCodeFlags;
    NTSTATUS            status;

    // it appears that streams can pass a null data pointer some times
    // and crash nbt...and zero length for the bytes
    if (uNumBytes < sizeof(ULONG))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    OpCodeFlags = pNameSrv->OpCodeFlags;

    //Pnodes always ignore Broadcasts since they only talk to the NBNS unless
    // this node is also a proxy
    if ( ( ((NodeType) & PNODE)) && !((NodeType) & PROXY) )
    {
        if (OpCodeFlags & FL_BROADCAST)
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }
    }


    // decide what type of name service packet it is by switching on the
    // NM_Flags portion of the word
    switch (OpCodeFlags & NM_FLAGS_MASK)
    {
        case OP_QUERY:
            status = QueryFromNet(
                            pDeviceContext,
                            pSrcAddress,
                            pNameSrv,
                            uNumBytes,      // >= NBT_MINIMUM_QUERY (== 50)
                            OpCodeFlags,
                            fBroadcast);
            break;

        case OP_REGISTRATION:
            //
            // we can get either a registration request or a response
            //
            // is this a request or a response? - if bit is set its a Response

            if (OpCodeFlags & OP_RESPONSE)
            {
                // then this is a response to a previous reg. request
                status = RegResponseFromNet(
                                pDeviceContext,
                                pSrcAddress,
                                pNameSrv,
                                uNumBytes,      // >= NBT_MINIMUM_REGRESPONSE (== 62)
                                OpCodeFlags);
            }
            else
            {
                //
                // check if someone else is trying to register a name
                // owned by this node.  Pnodes rely on the Name server to
                // handle this...hence the check for Pnode
                //
                if (!(NodeType & PNODE))
                {
                    status = CheckRegistrationFromNet(pDeviceContext,
                                                      pSrcAddress,
                                                      pNameSrv,
                                                      uNumBytes);   // >= NBT_MINIMUM_REGREQUEST (== 68)
                }
            }
            break;

        case OP_RELEASE:
            //
            // handle other nodes releasing their names by deleting any
            // cached info
            //
            status = NameReleaseFromNet(
                            pDeviceContext,
                            pSrcAddress,
                            pNameSrv,
                            uNumBytes);         // >= NBT_MINIMUM_REGRESPONSE (== 62)
            break;

        case OP_WACK:
            if (!(NodeType & BNODE))
            {
                // the TTL in the  WACK tells us to increase our timeout
                // of the corresponding request, which means we must find
                // the transaction
                status = WackFromNet(pDeviceContext,
                                     pSrcAddress,
                                     pNameSrv,
                                     uNumBytes);    // >= NBT_MINIMUM_WACK (== 58)
            }
            break;

        case OP_REFRESH:
        case OP_REFRESH_UB:

            break;

        default:
            IF_DBG(NBT_DEBUG_HNDLRS)
                KdPrint(("Nbt.NameSrvHndlrNotOs: Unknown Name Service Pdu type OpFlags = %X\n",
                        OpCodeFlags));
            break;


    }

    return(STATUS_DATA_NOT_ACCEPTED);
}

VOID
DoNothingComplete (
    IN PVOID        pContext
    )
/*++

Routine Description:

    This routine is the completion routine for TdiDisconnect while we are
    retrying connects.  It does nothing.

    This is required because you can't have a NULL TDI completion routine.

--*/
{
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\inbound.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Inbound.c

Abstract:


    This file implements the inbound name service pdu handling.  It handles
    name queries from the network and Registration responses from the network.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "ctemacro.h"

#include "inbound.tmh"

NTSTATUS
DecodeNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress
    );

NTSTATUS
SendNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pInNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress,
    IN  USHORT              SrcPort,
    IN  tDEVICECONTEXT      *pDeviceContext
    );

NTSTATUS
UpdateNameState(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  tNAMEADDR               *pNameAddr,
    IN  ULONG                   Length,
#ifdef MULTIPLE_WINS
    IN  PULONG                  pContextFlags,
#endif
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 SrcIsNameServer,
    IN  tDGRAM_SEND_TRACKING    *Context,
    IN  CTELockHandle           OldIrq1
    );
NTSTATUS
ChkIfValidRsp(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  tNAMEADDR       *pNameAddr
    );

NTSTATUS
ChooseBestIpAddress(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  ULONG                   Len,
    IN  tDEVICECONTEXT          *pDeviceContext,
    OUT tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    IN  BOOLEAN                 fReturnAddrList
    );

NTSTATUS
GetNbFlags(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  LONG                lNumBytes,
    OUT USHORT              *pRegType
    );

VOID
PrintHexString(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG                lNumBytes
    );

ULONG
MakeList(
    IN  tDEVICECONTEXT            *pDeviceContext,
    IN  ULONG                     CountAddrs,
    IN  tADDSTRUCT UNALIGNED      *pAddrStruct,
    IN  tIPADDRESS                *pAddrArray,
    IN  ULONG                     SizeOfAddrArray,
    IN  BOOLEAN                   IsSubnetMatch
    );

BOOL
IsBrowserName(
	IN PCHAR pName
	);


#if DBG
#define KdPrintHexString(pHdr,NumBytes)     \
    PrintHexString(pHdr,NumBytes)
#else
#define KdPrintHexString(pHdr,NumBytes)
#endif


//----------------------------------------------------------------------------
BOOLEAN
IsRemoteAddress(
    IN tNAMEADDR    *pNameAddr,
    IN tIPADDRESS   IpAddress
    )
{
    ULONG   i;

    for (i=0; i<pNameAddr->RemoteCacheLen; i++)
    {
        if (pNameAddr->pRemoteIpAddrs[i].IpAddress == IpAddress)
        {
            return TRUE;
        }
    }

    return FALSE;
}


//----------------------------------------------------------------------------
NTSTATUS
QueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags,
    IN  BOOLEAN             fBroadcast
    )
/*++

Routine Description:

    This routine handles both name query requests and responses.  For Queries
    it checks if the name is registered on this node.  If this node is a proxy
    it then forwards a name query onto the Name Server, adding the name to the
    remote proxy cache...

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS                status;
    LONG                    lNameSize;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
#ifdef MULTIPLE_WINS
    tDGRAM_SEND_TRACKING    *Context;
    ULONG                   AddrStructLength;
    USHORT                  RdLength;       // The length field in the packet
#else
    PVOID                   Context;
#endif
    PTRANSPORT_ADDRESS      pSourceAddress;
    tIPADDRESS              SrcAddress;
    CTELockHandle           OldIrq1;
    tQUERYRESP  UNALIGNED   *pQuery;
    USHORT                  SrcPort;
    tIPADDRESS              IpAddr;
    tADDSTRUCT UNALIGNED    *pAddrs;
    tIPADDRESS              *pFailedAddresses;
    ULONG                   i, j, CountAddrs, InterfaceContext;
    tQUERY_ADDRS            *pQueryAddrs = NULL;
    LONG                    MinimumBytes;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);


    SrcPort = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);


#ifdef VXD
    //
    // is this a response from a DNS server?  if yes then handle it
    // appropriately
    //
    if (SrcPort == NBT_DNSSERVER_UDP_PORT)
    {
        USHORT  TransactionId;
        TransactionId = ntohs(pNameHdr->TransactId);
        if ( TransactionId >= DIRECT_DNS_NAME_QUERY_BASE )
        {
            ProcessDnsResponseDirect( pDeviceContext,
                                      pSrcAddress,
                                      pNameHdr,
                                      lNumBytes,
                                      OpCodeFlags );
        }
        else
        {
            ProcessDnsResponse( pDeviceContext,
                                pSrcAddress,
                                pNameHdr,
                                lNumBytes,
                                OpCodeFlags );
        }

       return(STATUS_DATA_NOT_ACCEPTED);
    }
#endif

    //
    // check the pdu size for errors - be sure the name is long enough for
    // the scope on this machine.
    //
    if (lNumBytes < (NBT_MINIMUM_QUERY + NbtConfig.ScopeLength - 1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Name Query PDU TOO short = %X,Src= %X\n",lNumBytes,SrcAddress));
        NbtTrace(NBT_TRACE_NAMESRV, ("Discard name query: Query PDU too short %x, Src=%!ipaddr!",
                                lNumBytes, SrcAddress));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    status = ConvertToAscii ((PCHAR) &pNameHdr->NameRR,
                             (lNumBytes-1) - FIELD_OFFSET(tNAMEHDR,NameRR), // -1 for QUEST_STATUS
                             pName,
                             &pScope,
                             &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.QueryFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        NbtTrace(NBT_TRACE_NAMESRV, ("Discard name query: Src=%!ipaddr! ConvertToAscii returns %!status!",
                                SrcAddress, status));
        return(STATUS_DATA_NOT_ACCEPTED);
    }


    // check if this is a request or a response pdu

    //
    // *** RESPONSE ***
    //
    if (OpCodeFlags & OP_RESPONSE)
    {
        if (!(OpCodeFlags & FL_AUTHORITY))
        {
            // *** Redirect Response from Wins ***

            //
            // This is a redirect response telling us to go to another
            // name server, which we do not support, so just return
            // *TODO*
            //
            NbtTrace(NBT_TRACE_NAMESRV, ("Ignore redirecting response from %!ipaddr!", SrcAddress));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // check if this is a node status request, since is looks very similar
        // to a name query, except that the NBSTAT field is 0x21 instead of
        // 0x20
        //
        pQuery = (tQUERYRESP *) &pNameHdr->NameRR.NetBiosName[lNameSize];
        if ( ((PUCHAR)pQuery)[1] == QUEST_STATUS )
        {
            //
            // *** This is an AdapterStatus response! ***
            //
            tNODESTATUS *pNodeStatus = (tNODESTATUS *)&pNameHdr->NameRR.NetBiosName[lNameSize];

            //
            // Bug# 125627
            // Check for valid Pdu data + Size
            // The PDU is of the form:
            // tNAMEHDR --> TransactionId   ==> Offset=0, Length=2 bytes
            //                  :
            //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
            //          --> NodeStatusResponse  ==> Offset=13+lNameSize, Length >=11
            //          --> NodeName[i]         ==> Offset=13+lNameSize+11+(i*NBT_NODE_NAME_SIZE)
            //
            MinimumBytes =  FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 11;
            if ((lNumBytes < MinimumBytes) ||       // so that we can read in "pNodeStatus->NumNames"
                (lNumBytes < (MinimumBytes + pNodeStatus->NumNames*NBT_NODE_NAME_SIZE)))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint (("Nbt.QueryFromNet: WARNING Bad AdapterStatusResp size -- lNumBytes=<%d> < <%d>\n",
                        lNumBytes, (MinimumBytes + pNodeStatus->NumNames*NBT_NODE_NAME_SIZE)));
                NbtTrace(NBT_TRACE_NAMESRV, ("Bad AdapterStatusResp size -- lNumBytes=%d < %d from %!ipaddr!",
                        lNumBytes, (MinimumBytes + pNodeStatus->NumNames*NBT_NODE_NAME_SIZE), SrcAddress));
                ASSERT(0);
                return(STATUS_DATA_NOT_ACCEPTED);
            }

            status = DecodeNodeStatusResponse(pNameHdr, lNumBytes, pName, lNameSize, SrcAddress);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // *** We are processing a Name Query response! ***
        //

        //
        // check the Query response pdu size before dereferencing it!
        // The PDU is of the form:
        // tNAMEHDR --> TransactionId   ==> Offset=0, Length=2 bytes
        //                  :
        //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
        //          --> QueryResponse       ==> Offset=13+lNameSize, Length >=10
        //
        //
        if (IS_POS_RESPONSE(OpCodeFlags))
        {
            MinimumBytes = 13 + lNameSize + 16;
        }
        else
        {
            MinimumBytes = 13 + lNameSize + 10;     // Upto Length field only
        }

        if (lNumBytes < MinimumBytes)
        {
            KdPrint (("Nbt.QueryFromNet:  WARNING -- Bad QueryResp size, lNumBytes=<%d>, lNameSize=<%d>\n",
                lNumBytes, lNameSize));
            NbtTrace(NBT_TRACE_NAMESRV, ("Bad QueryResp size, lNumBytes=<%d>, lNameSize=<%d> from %!ipaddr!",
                lNumBytes, lNameSize, SrcAddress));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        pAddrs = (tADDSTRUCT *) &pQuery->Flags;
        RdLength = ntohs(*(USHORT*)((PUCHAR)pQuery + 8));
        AddrStructLength = lNumBytes - (ULONG)((ULONG_PTR)&pQuery->Flags - (ULONG_PTR)pNameHdr);
        if (RdLength < AddrStructLength) {
            AddrStructLength = RdLength;
        }
        CountAddrs = AddrStructLength / tADDSTRUCT_SIZE;

        //
        // Call into IP to determine the outgoing interface for each address returned
        //
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!(ntohs(pAddrs[0].NbFlags) & FL_GROUP)) &&
            (CountAddrs && ((CountAddrs*tADDSTRUCT_SIZE) == AddrStructLength)) &&
            (pQueryAddrs = (tQUERY_ADDRS *) NbtAllocMem(CountAddrs*sizeof(tQUERY_ADDRS),NBT_TAG2('13'))))
        {
            CTEZeroMemory(pQueryAddrs, CountAddrs*sizeof(tQUERY_ADDRS));
            for (i = 0; i < CountAddrs; i++)
            {
                pQueryAddrs[i].IpAddress = pAddrs[i].IpAddr;
                pDeviceContext->pFastQuery(pAddrs[i].IpAddr,&pQueryAddrs[i].Interface,&pQueryAddrs[i].Metric);
            }
        }

        //
        // call this routine to find the name, since it does not interpret the
        // state of the name as does FindName()
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        status = FindOnPendingList(pName,pNameHdr,FALSE,NETBIOS_NAME_SIZE,&pNameAddr);
        if (NT_SUCCESS(status))
        {
            pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            // remove any timer block and call the completion routine

            if ((pTimer = pNameAddr->pTimer))
            {
                ULONG                   Flags;
                tDGRAM_SEND_TRACKING    *pTracker;
                tDEVICECONTEXT          *pDevContext;
                USHORT                  NSOthersIndex, NSOthersLeft;
                ULONG                   ContextFlags;

                pTracker = (tDGRAM_SEND_TRACKING *)pTimer->Context;
                Flags = pTracker->Flags;

                //
                // Since this Wins server was able to respond, set the last responsive
                // pointer
                //
                if ((SrcIsNameServer(SrcAddress,SrcPort)) &&
                    (pTracker->Flags & NBT_NAME_SERVER_OTHERS))
                {
                    pTracker->pDeviceContext->lLastResponsive = pTracker->NSOthersIndex;
                }
                //
                // If this is not a response to a request sent by the PROXY code
                // and
                // MSNode && Error Response code && Src is NameServer && Currently
                // resolving with the name server, then switch to broadcast
                // ... or if it is a Pnode or Mnode and EnableLmHost or
                // ResolveWithDns is on, then
                // let the timer expire again, and try Lmhost.
                //
                if (
#ifdef PROXY_NODE
                     pNameAddr->ProxyReqType == NAMEREQ_REGULAR &&
#endif
                     (IS_NEG_RESPONSE(OpCodeFlags)))

                {
                    NbtTrace(NBT_TRACE_NAMESRV, ("Receive negative response from %!ipaddr! for %!NBTNAME!<%02x>",
                            SrcAddress, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));
                    if ((NodeType & (PNODE | MNODE | MSNODE)) &&
                        (Flags & (NBT_NAME_SERVER | NBT_NAME_SERVER_BACKUP)))
                    {
                        // this should let MsnodeCompletion try the
                        // backup WINS or broadcast processing next
                        //
                        pTracker->Flags |= WINS_NEG_RESPONSE;
                        ExpireTimer (pTimer, &OldIrq1);
                    }
                    else
                    {
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                    }

                    if (pQueryAddrs)
                    {
                        CTEFreeMem (pQueryAddrs);
                    }
                    return(STATUS_DATA_NOT_ACCEPTED);
                }

                //
                // Check if any of the addresses that came over the net
                // belong to the set of failed addresses that we are tracking
                //
                if (pNameAddr->pTracker)    // pTracker will be NULL for Proxy requests
                {
                    if (pQueryAddrs)
                    {
                        //
                        // Go through the list of addresses to see which ones can be
                        // reached through this Device
                        //
                        InterfaceContext = pNameAddr->pTracker->pDeviceContext->IPInterfaceContext;
                        for (i=0; i<CountAddrs; i++)
                        {
                            if (pQueryAddrs[i].Interface != InterfaceContext)
                            {
                                CountAddrs--;
                                if (CountAddrs)
                                {
                                    pQueryAddrs[i].Interface = pQueryAddrs[CountAddrs].Interface;
                                    pAddrs[i] = pAddrs[CountAddrs];   // Copy the last entry
                                }

                                pAddrs[CountAddrs].IpAddr = 0;  // Set the last address entry to 0
                                i--;
                            }
                        }

                        CTEFreeMem (pQueryAddrs);
                        pQueryAddrs = NULL;
                    }

                    AddrStructLength = CountAddrs * tADDSTRUCT_SIZE;

                    //
                    // We have now removed all the irrelevant entries
                    // See if we also need to filter out any bad (known) addresses
                    //
                    if ((pNameAddr->pTracker->pFailedIpAddresses) && (pTimer->ClientCompletion))
                    {
                        pFailedAddresses = pNameAddr->pTracker->pFailedIpAddresses;
                        if ((CountAddrs*tADDSTRUCT_SIZE) == AddrStructLength)
                        {
                            //
                            // If some of these addresses had failed earlier, they should be purged
                            //
                            i = 0;
                            while ((i < MAX_FAILED_IP_ADDRESSES) && (pFailedAddresses[i]))
                            {
                                for (j = 0; j < CountAddrs; j++)
                                {
                                    if (pFailedAddresses[i] == (ULONG) ntohl(pAddrs[j].IpAddr))
                                    {
                                        pAddrs[j] = pAddrs[CountAddrs-1];   // Copy the last entry
                                        pAddrs[CountAddrs-1].IpAddr = 0;    // Set the last entry to 0
                                        CountAddrs--;
                                        j--;                                // Now, read this new IP address
                                    }
                                }
                                i++;
                            }

                        }
                    }

                    if (0 == (AddrStructLength = CountAddrs*tADDSTRUCT_SIZE))
                    {
                        NbtTrace(NBT_TRACE_NAMESRV, ("No new address. Treated as negative response. "
                                                "from %!ipaddr! for %!NBTNAME!<%02x>",
                            SrcAddress, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));
                        //
                        // No new addresses were found -- consider this a negative response
                        //
                        if ((NodeType & (PNODE | MNODE | MSNODE)) &&
                            (pTracker->Flags & (NBT_NAME_SERVER | NBT_NAME_SERVER_BACKUP)))
                        {
                            // this should let MsnodeCompletion try the
                            // backup WINS or broadcast
                            // processing when the timer times out.
                            //
                            pTracker->Flags |= WINS_NEG_RESPONSE;
                            ExpireTimer (pTimer, &OldIrq1);
                        }
                        else
                        {
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        }

                        return(STATUS_DATA_NOT_ACCEPTED);
                    }

                    //
                    // save the Tracker's essential info since the call to StopTimer could
                    // free pTracker
                    //
                    pNameAddr->pTracker->ResolutionContextFlags = pTracker->Flags;
                    pNameAddr->pTracker->NSOthersIndex = pTracker->NSOthersIndex;
                    pNameAddr->pTracker->NSOthersLeft = pTracker->NSOthersLeft;
                }
                else if (pQueryAddrs)
                {
                    CTEFreeMem (pQueryAddrs);
                    pQueryAddrs = NULL;
                }

                CHECK_PTR(pNameAddr);
                pDevContext = pTracker->pDeviceContext;

                //
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                //
                pNameAddr->pTimer = NULL;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);     // Since StopTimer can Deref name!
                status = StopTimer(pTimer,&pClientCompletion,&Context);
                LOCATION(0x42);
                //
                // we need to synchronize removing the name from the list
                // with MsNodeCompletion
                //
                if (pClientCompletion)
                {
                    LOCATION(0x41);
                    //
                    // Remove from the pending list
                    RemoveEntryList(&pNameAddr->Linkage);
                    InitializeListHead(&pNameAddr->Linkage);

                    // check the name query response ret code to see if the name
                    // query succeeded or not.
                    if (IS_POS_RESPONSE(OpCodeFlags))
                    {
                        BOOLEAN ResolvedByWins;

                        LOCATION(0x40);
                        //
                        // Keep track of how many names are resolved by WINS and
                        // keep a list of names not resolved by WINS
                        //
                        if (!(ResolvedByWins = SrcIsNameServer(SrcAddress,SrcPort)))
                        {
                             SaveBcastNameResolved(pName);
                        }

                        IncrementNameStats(NAME_QUERY_SUCCESS, ResolvedByWins);
#ifdef PROXY_NODE
                        // Set flag if the node queries is a PNODE
                        //
                        IF_PROXY(NodeType)
                        {
                            pNameAddr->fPnode = (pNameHdr->NameRR.NetBiosName[lNameSize+QUERY_NBFLAGS_OFFSET]
                                                &  NODE_TYPE_MASK) == PNODE_VAL_IN_PKT;

                            IF_DBG(NBT_DEBUG_PROXY)
                                KdPrint(("QueryFromNet: POSITIVE RESPONSE to name query - %16.16s(%X)\n",
                                    pNameAddr->Name, pNameAddr->Name[15]));
                        }

#endif
                        pNameAddr->AdapterMask |= pDevContext->AdapterMask;

                        IpAddr = ((tADDSTRUCT *)&pQuery->Flags)->IpAddr;

                        NbtTrace(NBT_TRACE_NAMESRV, ("Positive response for %!NBTNAME!<%02x> %!ipaddr! from %!ipaddr!",
                            pNameAddr->Name, (unsigned)pNameAddr->Name[15], IpAddr, SrcAddress));

                        status = UpdateNameState((tADDSTRUCT *)&pQuery->Flags,
                                             pNameAddr,
                                             AddrStructLength,
                                             &ContextFlags,
                                             pDevContext,
                                             SrcIsNameServer(SrcAddress,SrcPort),
                                             (tDGRAM_SEND_TRACKING *)Context,
                                             OldIrq1);
                        //
                        // since pNameAddr can be freed in UpdateNameState do not
                        // access it here
                        //
                        pNameAddr = NULL;
                        // status = STATUS_SUCCESS;
                    }
                    else   // negative query response received
                    {

                        LOCATION(0x3f);
                        NbtTrace(NBT_TRACE_NAMESRV, ("Negative response for %!NBTNAME!<%02x> from %!ipaddr!",
                            pNameAddr->Name, (unsigned)pNameAddr->Name[15], SrcAddress));
                        //
                        // Release the name.  It will get dereferenced by the
                        // cache timeout function (RemoteHashTimeout).
                        //
                        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                        pNameAddr->NameTypeState |= STATE_RELEASED;
                        //
                        // the proxy maintains a negative cache of names that
                        // do not exist in WINS.  These are timed out by
                        // the remote hash timer just as the resolved names
                        // are timed out.
                        //
                        if (!(NodeType & PROXY))
                        {
                            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                        }
                        else if (pNameAddr->ProxyReqType != NAMEREQ_PROXY_REGISTRATION)
                        {
                            //
                            // Add to cache as negative name entry
                            //
                            AddToHashTable (NbtConfig.pRemoteHashTbl,
                                            pNameAddr->Name,
                                            NbtConfig.pScope,
                                            pNameAddr->IpAddress,
                                            0,
                                            pNameAddr,
                                            NULL,
                                            pDevContext,
                                            (USHORT) (SrcIsNameServer(SrcAddress,SrcPort) ?
                                                      NAME_RESOLVED_BY_WINS:NAME_RESOLVED_BY_BCAST));
                            //
                            // this could delete the name so do not reference after this point
                            //
                        }

                        status = STATUS_BAD_NETWORK_PATH;
                    }

                    //
                    // Set the backup name server to be the main name server
                    // since we got a response from it.
                    // Bug# 95280: Do this only if the Primary Wins is down!
                    //
                    if ( (!(Flags & WINS_NEG_RESPONSE)) &&
                         ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr
                            == (ULONG)(htonl(pDeviceContext->lBackupServer)))
                    {
                        // switching the backup and the primary nameservers in
                        // the config data structure since we got a name
                        // registration response from the backup
                        //
                        SwitchToBackup(pDeviceContext);
                    }

                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    // the completion routine has not run yet, so run it
                    //
#ifdef VXD
                    //
                    // chicago only has 4k of stack (yes, it's the operating system of 1995)
                    // schedule an event to make this tcp connection later to reduce stack usage
                    //
                    CTEQueueForNonCritNonDispProcessing( DelayedSessEstablish,
                                                         (tDGRAM_SEND_TRACKING *)Context,
                                                         (PVOID)status,
                                                         pClientCompletion,
                                                         pDeviceContext);
#else
                    //
                    // If pending is returned, we have submitted the check-for-addr request to lmhsvc.
                    //
                    if (status != STATUS_PENDING)
                    {
                        CompleteClientReq(pClientCompletion, (tDGRAM_SEND_TRACKING *)Context, status);
                    }
#endif
                    return(STATUS_DATA_NOT_ACCEPTED);
                }
                else
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
        else if (!NbtConfig.MultiHomed)
        {

            // *** Name Query reponse ==> Name not on Pending list ***

            //
            // it is possible for two multihomed machines connected on two subnets
            // to respond on both subnets to a name query.  Therefore the querying
            // multihomed machine will ultimately receive two name query responses
            // each with a different ip address and think that a name conflict has
            // occurred when it hasn't.  There is no way to detect this case
            // so just disable the conflict detection code below. Conflicts will
            // still be detected by WINS and by the node owning the name if someone
            // else tries to get the name, but conflicts will no longer be detected
            // by third parties that have the name in their cache.
            // (Currently this case will be handled only if we are not multi-homed!)
            //
            //
            // This code implements a Conflict timer for name
            // queries. Look at name query response, and then send
            // name conflict demands to the subsequent responders.
            // There is no timer involved, and this node will always respond
            // negatively to name query responses sent to it, for names
            // it has in its remote cache, if the timer has been stopped.
            // ( meaning that one response has been successfully received ).

            //
            //  The name is not in the NameQueryPending list, so check the
            //  remote table.
            //
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                    pName,
                                    pScope,
                                    &pNameAddr);
            NbtTrace(NBT_TRACE_NAMESRV, ("FindInHashTable return %!status! for %!NBTNAME!<%02x> from %!ipaddr!",
                            status, pName, (unsigned)pName[15], SrcAddress));

            // check the src IP address and compare it to the one in the
            // remote hash table
            // Since it is possible for the name server to send a response
            // late, do not accidently respond to those as conflicts.
            // Since a bcast query of a group name will generally result in
            // multiple responses, each with a different address, ignore
            // this case.
            // Also, ignore if the name is a preloaded lmhosts entry (though
            // can't think of an obvious case where we would receive a response
            // when a name is preloaded!)
            //
            if (NT_SUCCESS(status) &&
                !(pNameAddr->NameTypeState & PRELOADED) &&
                (!IsRemoteAddress(pNameAddr, SrcAddress)) &&
                (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) &&
                (pNameAddr->NameTypeState & STATE_RESOLVED) &&
                (!IsNameServerForDevice (SrcAddress, pDeviceContext)))
            {
                //
                // Reference the name so that it doesn't disappear when
                // we are dereferencing it below!   Bug# 233464
                //
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_RESPONSE);

                //
                // a different node is responding to the name query
                // so tell them to buzz off.
                //
                status = UdpSendResponse(
                            lNameSize,
                            pNameHdr,
                            pNameAddr,
                            (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                            pDeviceContext,
                            CONFLICT_ERROR,
                            eNAME_REGISTRATION_RESPONSE,
                            OldIrq1);
                NbtTrace(NBT_TRACE_NAMESRV, ("UdpSendResponse return %!status! for %!NBTNAME!<%02x> from %!ipaddr!",
                            status, pName, (unsigned)pName[15], SrcAddress));

                //
                // remove the name from the remote cache so the next time
                // we need to talk to it we do a name query
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                // set the name to the released state so that multiple
                // conflicting responses don't come in and decrement the
                // reference count to zero - in the case where some other
                // part of NBT is still using the name, that part of NBT
                // should do the final decrement - i.e. a datagram send to this
                // name.
                pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddr->NameTypeState |= STATE_RELEASED;

                //
                // don't deref if someone else is using it now...
                //
                if (pNameAddr->RefCount == 2)
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_RESPONSE, TRUE);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }

        if (pQueryAddrs)
        {
            CTEFreeMem (pQueryAddrs);
            pQueryAddrs = NULL;
        }

        return(STATUS_DATA_NOT_ACCEPTED);

    }
    else        // *** REQUEST ***
    {
        NTSTATUS    Locstatus;

        //
        // check the pdu size for errors
        //
        if (lNumBytes < (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 4))
        {
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.QueryFromNet[2]: WARNING!!! Rejecting Request -- lNumBytes=<%d> < <%d>\n",
                    lNumBytes, (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 4)));
            ASSERT(0);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        // call this routine
        // to see if the name is in the local table.
        //
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);
        pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
        if (NT_SUCCESS(status) &&
            ((pNameAddr->NameTypeState & STATE_RESOLVED) ||
            (pNameAddr->NameTypeState & STATE_RESOLVING)))
        {
            //
            // check if this is a node status request, since is looks very similar
            // to a name query, except that the NBSTAT field is 0x21 instead of
            // 0x20
            //
            if ( ((PUCHAR)pQuery)[1] == QUEST_STATUS )
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                //
                // Reply only if this was not broadcast to us.
                //
                if (!fBroadcast)
                {
                    Locstatus = SendNodeStatusResponse(pNameHdr,
                                                    lNumBytes,
                                                    pName,
                                                    lNameSize,
                                                    SrcAddress,
                                                    SrcPort,
                                                    pDeviceContext);
                }
                else
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("NBT: Bcast nodestatus req.- dropped\n"));
                }
            }
            else
            {
                //
                // check if this message came from Us or it is not
                // a broadcast since WINS on this machine could send it.
                // Note: this check must be AFTER the check for a node status request
                // since we can send node status requests to ourselves.
                //
                if ((!SrcIsUs(SrcAddress)) ||
                    (!(OpCodeFlags & FL_BROADCAST)
#ifndef VXD
                     && pWinsInfo
#endif
                    ))
                {
                    //
                    // build a positive name query response pdu
                    //
                    Locstatus = UdpSendResponse(
                                    lNameSize,
                                    pNameHdr,
                                    pNameAddr,
                                    (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                    pDeviceContext,
                                    0,
                                    eNAME_QUERY_RESPONSE,
                                    OldIrq1);
                }
                else
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            }

            return(STATUS_DATA_NOT_ACCEPTED);
        } else if (((PUCHAR)pQuery)[1] == QUEST_STATUS && !fBroadcast &&
                RtlCompareMemory(pName, NBT_BROADCAST_NAME, NETBIOS_NAMESIZE) == NETBIOS_NAMESIZE) {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            Locstatus = SendNodeStatusResponse(pNameHdr,
                                                lNumBytes,
                                                pName,
                                                lNameSize,
                                                SrcAddress,
                                                SrcPort,
                                                pDeviceContext);
            return(STATUS_DATA_NOT_ACCEPTED);
        }
        else if ( !(OpCodeFlags & FL_BROADCAST) )
        {
            // Build a negative response if this query was directed rather than
            // broadcast (since we do not want to Nack all broadcasts!)

            // check that it is not a node status request...
            //
            NbtTrace(NBT_TRACE_NAMESRV, ("FindInHashTable return %!status! for %!NBTNAME!<%02x> from %!ipaddr!",
                            status, pName, (unsigned)pName[15], SrcAddress));
            pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            if ( ((PUCHAR)pQuery)[1] == QUEST_NETBIOS )
            {
                Locstatus = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                NULL,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                0,
                                eNAME_QUERY_RESPONSE,
                                OldIrq1);
            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            }

            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

#ifdef PROXY_NODE

        //
        // check if this message came from Us !! (and return if so)
        //
        if (SrcIsUs(SrcAddress))
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }
        pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];

        IF_PROXY(NodeType)
        {
            // check that it is not a node status request...
            if (((PUCHAR)pQuery)[1] == QUEST_NETBIOS )
            {
                //
                // We have a broadcast name query request for a name that
                // is not in our local name table.  If we are a proxy we need
                // to resolve the query if not already resolved and respond
                // with the address(es) to the node that sent the query.
                //
                // Note: We will respond only if the address that the name
                // resolves to is not on our subnet. For our own subnet addresses
                // the node that has the address will respond.
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                //
                // call this routine which looks for names without regard
                // to their state
                //
                status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);

                if (!NT_SUCCESS(status))
                {
                    status = FindOnPendingList(pName,pNameHdr,TRUE,NETBIOS_NAME_SIZE,&pNameAddr);
                    if (!NT_SUCCESS(status))
                    {
                        //
                        // cache the name and contact the name
                        // server to get the name to IP mapping
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status = RegOrQueryFromNet(
                                  FALSE,          //means it is a name query
                                  pDeviceContext,
                                  pNameHdr,
                                  lNameSize,
                                  pName,
                                  pScope);

                         return(STATUS_DATA_NOT_ACCEPTED);
                    }
                    else
                    {
                        //
                        // the name is on the pending list doing a name query
                        // now, so ignore this name query request
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        return(STATUS_DATA_NOT_ACCEPTED);

                    }
                }
                else
                {

                   //
                   // The name can be in the RESOLVED, RESOLVING or RELEASED
                   // state.
                   //


                   //
                   // If in the RELEASED state, its reference count has to be
                   // > 0
                   //
                   //ASSERT(pNameAddr->NameTypeState & (STATE_RESOLVED | STATE_RESOLVING) || (pNameAddr->NameTypeState & STATE_RELEASED) && (pNameAddr->RefCount > 0));

                   //
                   // Send a response only if the name is in the RESOLVED state
                   //
                   if (pNameAddr->NameTypeState & STATE_RESOLVED)
                   {

                     //
                     // The PROXY sends a response if the address of the
                     // node queries is not on the  same subnet as the
                     // node doing the query (or as us). It also responds
                     // if the name is a group name or if it belongs to
                     // a Pnode. Note: In theory there is no reason to
                     // respond for group names since a member of the group
                     // on the subnet will respond with their address if they
                     // are alive - if they are B or M nodes - perhaps
                     // the fPnode bit is not set correctly for groups, so
                     // therefore always respond in case all the members
                     // are pnodes.
                     //

                     //
                     // If we have multiple network addresses in the same
                     // broadcast area, then this test won't be sufficient
                     //
                     if (
                         ((SrcAddress & pDeviceContext->SubnetMask)
                                   !=
                         (pNameAddr->IpAddress & pDeviceContext->SubnetMask))
                                   ||
                         (pNameAddr->fPnode)
                                   ||
                         !(pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                        )
                     {
                          IF_DBG(NBT_DEBUG_PROXY)
                          KdPrint(("QueryFromNet: QUERY SATISFIED by PROXY CACHE -- name is %16.16s(%X); %s entry ; Address is (%d)\n",
                            pNameAddr->Name,pNameAddr->Name[15], (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? "UNIQUE" : "INET_GROUP",
                            pNameAddr->IpAddress));
                          //
                          //build a positive name query response pdu
                          //
                          // UdpSendQueryResponse frees the spin lock
                          //
                          status = UdpSendResponse(
                                        lNameSize,
                                        pNameHdr,
                                        pNameAddr,
                                        (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                        pDeviceContext,
                                        0,
                                        eNAME_QUERY_RESPONSE,
                                        OldIrq1);

                          return(STATUS_DATA_NOT_ACCEPTED);
                     }
                   }
                   else
                   {
                      IF_DBG(NBT_DEBUG_PROXY)
                      KdPrint(("QueryFromNet: REQUEST for Name %16.16s(%X) in %s state\n", pNameAddr->Name, pNameAddr->Name[15],( pNameAddr->NameTypeState & STATE_RELEASED ? "RELEASED" : "RESOLVING")));
                        NbtTrace(NBT_TRACE_PROXY, ("%!NBTNAME!<%02x> is in state %x for proxy request from %!ipaddr!",
                            pName, (unsigned)pName[15], pNameAddr->NameTypeState & STATE_RELEASED, SrcAddress));
                   }

                   CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                   return(STATUS_DATA_NOT_ACCEPTED);
                }
             }

        }  // end of proxy code
#endif

    } // end of else (it is a name query request)

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
RegResponseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    )
/*++

Routine Description:

    This routine handles name registration responses from the net (i.e. from
    the name server most of the time since a broadcast name registration passes
    when there is no response.

***
    The response could be from an NBT node when it notices that the name
    registration is for a name that it has already claimed - i.e. the node
    is sending a NAME_CONFLICT_DEMAND - in this case the Rcode in the PDU
    will be CFT_ERR = 7.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;           //Get rid of this later. Use pNameAddr
    tTIMERQENTRY        *pTimer;
    COMPLETIONCLIENT    pClientCompletion;
    PVOID               Context;
    PTRANSPORT_ADDRESS  pSourceAddress;
    CTELockHandle       OldIrq1;
    ULONG               SrcAddress;
    SHORT               SrcPort;


    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    SrcPort     = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);
    //
    // be sure the Pdu is at least a minimum size
    //
    if (lNumBytes < (NBT_MINIMUM_REGRESPONSE + NbtConfig.ScopeLength -1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Registration Response TOO short = %X, Src = %X\n",
            lNumBytes,SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // if Wins is locally attached then we will get registrations from
    // ourselves!!
    //
    if (SrcIsUs(SrcAddress)
#ifndef VXD
        && !pWinsInfo
#endif
                          )
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    // We need to handle group lists from the WINS server
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.RegResponseFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    status = FindInHashTable(NbtConfig.pLocalHashTbl,
                            pName,
                            pScope,
                            &pNameAddr);
    if (NT_SUCCESS(status) &&
        (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))
    {
        NTSTATUS    Localstatus;

        //
        // check the state of the name since this could be a registration
        // response or a name conflict demand
        //
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
        case STATE_CONFLICT:

            //
            // We only allow this state if we are currently trying to
            // get ourselves out of a Conflict scenario
            // We need to distinguish from the case where the name is
            // in conflict due to being dereferenced out
            //
            if (!pNameAddr->pAddressEle)
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                break;
            }
        case STATE_RESOLVING:
        case STATE_RESOLVED:

            if (IS_POS_RESPONSE(OpCodeFlags))
            {
                if (OpCodeFlags & FL_RECURAVAIL)
                {
                    // turn on the refreshed bit in NextRefresh now
                    // (when the timer completion routine is called)
                    // only count names registered, not REFRESHES too!
                    //
                    if (pNameAddr->NameTypeState & STATE_RESOLVING)
                    {
                        IncrementNameStats(NAME_REGISTRATION_SUCCESS,
                                           SrcIsNameServer(SrcAddress,SrcPort));
                    }
                    status = STATUS_SUCCESS;
                }
                else
                {
                    //
                    // in this case the name server is telling this node
                    // to do an end node challenge on the name.  However
                    // this node does not have the code to do a challenge
                    // so assume that this is a positive registration
                    // response.
                    //
                    status = STATUS_SUCCESS;
                }
            }
            else if (!SrcIsNameServer(SrcAddress,SrcPort) && pNameAddr->pTimer == NULL) {
                //
                // 05/17/00 Fix "a malicious user can flush a cache entry by sending a unsolicited negative response"
                // Drop the response if it is not from a name server and runs out of time
                //
                status = STATUS_DATA_NOT_ACCEPTED;
                KdPrint(("Waring: discard a timeout registration response from a non-namesever\n"));
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x105);
                break;
            }
            else if ((OpCodeFlags & FL_RCODE) >= FL_NAME_ACTIVE)
            {
                // if we are multihomed, then we only allow the name server
                // to send Name Active errors, since in normal operation this node
                // could generate two different IP address for the same name
                // query and confuse another client node into sending a Name
                // Conflict. So jump out if a name conflict has been received
                // from another node.
                //
                if ((NbtConfig.MultiHomed) &&
                    ((OpCodeFlags & FL_RCODE) == FL_NAME_CONFLICT))
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                    break;
                }

                if (!IS_MESSENGER_NAME(pNameAddr->Name))
                {
                    //
                    // We need to Q this event to a Worker thread since it
                    // requires the name to be converted to Unicode
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                    status = CTEQueueForNonDispProcessing (DelayedNbtLogDuplicateNameEvent,
                                                           (PVOID) pNameAddr,
                                                           IntToPtr(SrcAddress),
                                                           IntToPtr(0x101),
                                                           pDeviceContext,
                                                           TRUE);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                        NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x101);
                    }
                }

                status = STATUS_DUPLICATE_NAME;

                //
                // if the name is resolved and we get a negative response
                // then mark the name as in the conflict state so it can't
                // be used for any new sessions and this node will no longer
                // defend it.
                //
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                    pNameAddr->NameTypeState |= STATE_CONFLICT;
                    pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
                }
            }
            else
            {
                //
                // we got some kind of WINS server failure ret code
                // so just ignore it and assume the name registration
                // succeeded.
                //
                status = STATUS_SUCCESS;
            }

            // remove any timer block and call the completion routine
            // if the name is in the Resolving state only
            //
            LOCATION(0x40);
            if ((pTimer = pNameAddr->pTimer))
            {
                tDGRAM_SEND_TRACKING    *pTracker;
                USHORT                  SendTransactId;
                tDEVICECONTEXT          *pDevContext;

                // check the transaction id to be sure it is the same as the one
                // sent.
                //
                LOCATION(0x41);
                pTracker = (tDGRAM_SEND_TRACKING *)pTimer->Context;
                SendTransactId = pTracker->TransactionId;
                pDevContext = pTracker->pDeviceContext;

                if (pNameHdr->TransactId != SendTransactId)
                {
                    LOCATION(0x42);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    return(STATUS_DATA_NOT_ACCEPTED);
                }
                LOCATION(0x43);

                CHECK_PTR(pNameAddr);
                //
                // This could be either a Refresh or a name registration.  In
                // either case, stop the timer and call the completion routine
                // for the client.(below).
                //
                pNameAddr->pTimer = NULL;
                Localstatus = StopTimer(pTimer,&pClientCompletion,&Context);


                // check if it is a response from the name server
                // and a M, or P or MS node, since we will need to send
                // refreshes to the name server for these node types
                //
                pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;

                // only accept pdus from the name server to change the Ttl.
                // The first check passes the case where WINS is on this machine
                //
                if (
#ifndef VXD
                    (pWinsInfo && (SrcIsUs (SrcAddress))) ||
#endif
                    (SrcAddress == pDeviceContext->lNameServerAddress))
                {
                    if (!(NodeType & BNODE) &&
                        (status == STATUS_SUCCESS) &&
                        (IS_POS_RESPONSE(OpCodeFlags)))
                    {
                        SetupRefreshTtl(pNameHdr,pNameAddr,lNameSize);
                        // a name refresh response if in the resolved state
                    }
                }
                else if ( SrcAddress == pDeviceContext->lBackupServer)
                {
                    // switching the backup and the primary nameservers in
                    // the config data structure since we got a name
                    // registration response from the backup
                    //
                    SwitchToBackup(pDeviceContext);

                    if (!(NodeType & BNODE) &&
                        (status == STATUS_SUCCESS) &&
                        (IS_POS_RESPONSE(OpCodeFlags)))
                    {

                        SetupRefreshTtl(pNameHdr,pNameAddr,lNameSize);

                    }
                }

                //
                // mark name as refreshed if we got through to WINS Ok
                //
                if ((pClientCompletion) && (IS_POS_RESPONSE(OpCodeFlags)))
                {
                    pNameAddr->RefreshMask |= pDevContext->AdapterMask;
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                // the completion routine has not run yet, so run it - this
                // is the Registration Completion routine and we DO want it to
                // run to mark the entry refreshed (NextRefresh)
                if (pClientCompletion)
                {
                    LOCATION(0x44);
                    (*pClientCompletion)(Context,status);
                }

            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            }

        break;


        default:
            //
            // if multiple (neg)registration responses are received, subsequent ones
            // after the first will go through this path because the state of
            // the name will have been changed by the first to CONFLICT
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }


    }
    else
    {
          CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    } // end of else block (If name is not in local table)

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
CheckRegistrationFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles name registrations from the network that are
    potentially duplicates of names in the local name table. It compares
    name registrations against its local table and defends any attempts to
    take a name that is owned by this node. This routine handles name registration
    REQUESTS.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;
    tTIMERQENTRY        *pTimer;
    PTRANSPORT_ADDRESS  pSourceAddress;
    USHORT              RegType;
    CTELockHandle       OldIrq1;
    ULONG               SrcAddress;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1)))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Registration Request TOO short = %X,Src = %X\n", lNumBytes,SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check if this message came from Us !! (and return if so)
    //

    if (SrcIsUs(SrcAddress))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.CheckRegistrationFromNet: WARNING! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    status = FindInHashTable(NbtConfig.pLocalHashTbl,
                            pName,
                            pScope,
                            &pNameAddr);


    if (NT_SUCCESS(status))
    {
        // don't defend the broadcast name
        if ((pName[0] == '*') ||
            (STATUS_SUCCESS != GetNbFlags (pNameHdr, lNameSize, lNumBytes, &RegType)))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.CheckRegistrationFromNet: WARNING! Rejecting Request -- GetNbFlags FAILed\n"));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        // we defend against anyone trying to take a unique name, or anyone
        // trying to register a unique name for a group name we have. - if
        // the name is registered on this adapter
        //
        if (((pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ||
           ((pNameAddr->NameTypeState & NAMETYPE_GROUP) &&
            ((RegType & FL_GROUP) == 0)))  &&
            (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))
        {

            //
            // check the state of the name since this could be registration
            // for the same name while we are registering the name.  If another
            // node claims the name at the same time, then cancel the name
            // registration.
            //
            switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
            {

                case STATE_RESOLVING:

                    CHECK_PTR(pNameAddr);
                    // remove any timer block and call the completion routine
                    if ((pTimer = pNameAddr->pTimer))
                    {
                        COMPLETIONCLIENT    pClientCompletion;
                        PVOID               Context;

                        pNameAddr->pTimer = NULL;
                        status = StopTimer(pTimer,&pClientCompletion,&Context);
                        if (pClientCompletion)
                        {
                            if (!IS_MESSENGER_NAME(pNameAddr->Name))
                            {
                                //
                                // We need to Q this event to a Worker thread since it
                                // requires the name to be converted to Unicode
                                //
                                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                                status = CTEQueueForNonDispProcessing (DelayedNbtLogDuplicateNameEvent,
                                                                       (PVOID) pNameAddr,
                                                                       IntToPtr(SrcAddress),
                                                                       IntToPtr(0x102),
                                                                       pDeviceContext,
                                                                       TRUE);
                                if (!NT_SUCCESS(status))
                                {
                                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                                    NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x102);
                                }
                            }
                            status = STATUS_DUPLICATE_NAME; // CHANGE the state of the entry

                            // the completion routine has not run yet, so run it
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                            (*pClientCompletion)(Context,status);
                            CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                        }
                    }
                    break;

                case STATE_RESOLVED:
                    //
                    // We must defend our name against this Rogue attempting to steal
                    // our Name! ( unless the name is "*")
                    //
                    status = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                pNameAddr,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                REGISTRATION_ACTIVE_ERR,
                                eNAME_REGISTRATION_RESPONSE,
                                OldIrq1);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                    break;

            }


        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
    else
    {
        //
        // NOTE: We have the Joint Lock
        //

        //
        // The name is not in the local name table, so check if the proxy is
        // on and if we want the proxy to check name registrations.  The
        // trouble with checking name registrations is that the proxy code
        // only does a name query, so it will fail any node that is trying
        // to change its address such as a RAS client coming in on a downlevel
        // NT machine that only does broadcast name registrations.  If
        // that same user had previously dialled in on a WINS supporting RAS
        // machine, their address would be in WINS, then dialling in on the
        // downlevel machine would find that 'old' registration and deny
        // the new one ( even though it is the same machine just changing
        // its ip address).
        //

#ifdef PROXY_NODE

        if ((NodeType & PROXY) &&
            (NbtConfig.EnableProxyRegCheck))
        {

            BOOLEAN fResp = (BOOLEAN)FALSE;

            //
            // If name is RESOLVED in the remote table, has a different
            // address than the node claiming the name, is not on the
            // same subnet or is a Pnode then send a negative name
            // registration response
            //

            //
            // call this routine to find the name, since it does not
            // interpret the state of the name as does FindName()
            //
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                             pName,
                             pScope,
                             &pNameAddr);

            if (!NT_SUCCESS(status))
            {
                //
                // We  need to send a query to WINS to
                // see if the name is already taken or not.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                status = RegOrQueryFromNet(
                                  TRUE,    //means it is a reg. from the net
                                  pDeviceContext,
                                  pNameHdr,
                                  lNameSize,
                                  pName,
                                  pScope
                                           );
                return(STATUS_DATA_NOT_ACCEPTED);
            }

            //
            // If the name is in the RESOLVED state, we need to determine
            // whether we should respond or not.  For a name that is not
            // the RESOLVED state, the decision is simple. We don't respond
            if (pNameAddr->NameTypeState & STATE_RESOLVED)
            {

                ULONG IPAdd;

                if (STATUS_SUCCESS != GetNbFlags(pNameHdr, lNameSize, lNumBytes, &RegType))
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
//                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint (("Nbt.CheckRegistrationFromNet[2]: WARNING! Rejecting Request -- GetNbFlags FAILed\n"));
                    return (STATUS_DATA_NOT_ACCEPTED);
                }
                //
                // If a unique name is being registered but our cache shows
                // the name to be a group name (normal or internet), we
                // send a negative name registration response.
                //
                // If a node on the same subnet has responded negatively also,
                // it is ok.  It is possible that WINS/NBNS has old
                // information but there is no easy way to determine the
                // network address of the node that registered the group.
                // (For a normal group, there could have been several
                // nodes that registered it -- their addresses are not stored
                // by WINS.
                //
                if (!(RegType  & FL_GROUP) &&
                    !(pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                {
                    fResp = TRUE;
                }
                else
                {
                    tGENERALRR UNALIGNED         *pResrcRecord;

                    // get the Ip address out of the Registration request
                    pResrcRecord = (tGENERALRR *) &pNameHdr->NameRR.NetBiosName[lNameSize];

                    IPAdd  = ntohl(pResrcRecord->IpAddress);
                    //
                    // If a group name is being registered but our cache shows
                    // the name to be a unique name (normal or internet) or
                    // if a UNIQUE name is being registered but clashes with
                    // a unique name with a different address, we check if the
                    // the addresses belong to the same subnet.  If they do, we
                    // don't respond, else we send a negative registration
                    // response.
                    //
                    // Note: We never respond to a group registration
                    // that clashes with a group name in our cache.
                    //
                    if (((RegType & FL_GROUP)
                                      &&
                        (pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                                      ||
                        (!(RegType & FL_GROUP)
                                      &&
                        (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                                      &&
                         IPAdd != pNameAddr->IpAddress))
                    {
                        IF_DBG(NBT_DEBUG_PROXY)
                        KdPrint(("CheckReg:Subnet Mask = (%x)\nIPAdd=(%x)\npNameAddr->IPAdd = (%x)\npNameAddr->fPnode=(%d)\nIt is %s name %16.16s(%X)\nRegType Of Name Recd is %x\n---------------\n",
                        pDeviceContext->SubnetMask, IPAdd, pNameAddr->IpAddress,
                        pNameAddr->fPnode,
                        pNameAddr->NameTypeState & NAMETYPE_GROUP ? "GROUP" : "UNIQUE",
                        pName, pName[15], RegType));
                        //
                        // Are the querying node and the queried node on the
                        // same subnet ?
                        //
                        if (((IPAdd & pDeviceContext->SubnetMask)
                                       !=
                              (pNameAddr->IpAddress & pDeviceContext->SubnetMask))
                                       ||
                              (pNameAddr->fPnode))
                        {
                            fResp = TRUE;
                        }
                    }
                }

                //
                // If a negative response needs to be sent, send it now
                //
                if (fResp)
                {

                    IF_DBG(NBT_DEBUG_PROXY)
                    KdPrint(("CheckRegistrationFromNet: Sending a negative name registration response for name %16.16s(%X) to node with address (%d)\n",
                    pNameAddr->Name, pNameAddr->Name[15], IPAdd));

                    //
                    // a different node is responding to the name query
                    // so tell them to buzz off.
                    //
                    status = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                pNameAddr,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                REGISTRATION_ACTIVE_ERR,
                                eNAME_REGISTRATION_RESPONSE,
                                OldIrq1);

                    return(STATUS_DATA_NOT_ACCEPTED);

                }
            } // end of if (NAME is in the RESOLVED state)
        }
#endif
         CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
NameReleaseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles name releases that arrive from the Net.  The idea
    is to delete the name from the remote cache if it exists there so that
    this node does not erroneously use that cached information anymore.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS                status;
    LONG                    lNameSize;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    PTRANSPORT_ADDRESS      pSourceAddress;
    CTELockHandle           OldIrq1;
    USHORT                  OpCodeFlags;
    tTIMERQENTRY            *pTimer;
    ULONG                   SrcAddress;
    ULONG                   Flags;
    USHORT                  SendTransactId;
    tDGRAM_SEND_TRACKING    *pTracker;
    BOOLEAN                 bLocalTable;
    tGENERALRR UNALIGNED    *pRemainder;
    USHORT                  SrcPort;
    ULONG                   Rcode;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    SrcPort     = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);

    //
    // check if we should not release our names on demand
    //
    if (NbtConfig.NoNameReleaseOnDemand)
    {
        //
        // Don't log this event if
        //  1. WINS is running locally
        //  2. The request is coming from the WINS server
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        if (NULL == pWinsInfo && !SrcIsNameServer(SrcAddress,SrcPort)) {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        } else {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_REGRESPONSE + NbtConfig.ScopeLength -1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Release Request/Response TOO short = %X, Src = %X\n",lNumBytes,
            SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check if this message came from Us !!
    //
    if (SrcIsUs(SrcAddress))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.NameReleaseFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    OpCodeFlags = pNameHdr->OpCodeFlags;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);


    //
    // *** RESPONSE ***
    //
    if (OpCodeFlags & OP_RESPONSE)
    {

        //
        // check the pdu size for errors
        //
        if (lNumBytes < (NBT_MINIMUM_REGRESPONSE + NbtConfig.ScopeLength -1))
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }
        //
        // call this routine to find the name, since it does not interpret the
        // state of the name as does FindName()
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);
        if (!NT_SUCCESS(status))
        {
           CTESpinFree(&NbtConfig.JointLock,OldIrq1);
           return(STATUS_DATA_NOT_ACCEPTED);
        }

        // Get the Timer block
        if (!(pTimer = pNameAddr->pTimer))
        {
           CTESpinFree(&NbtConfig.JointLock,OldIrq1);
           return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // the name server is responding to a name release request
        //
        // check the transaction id to be sure it is the same as the one
        // sent.
        //
        pTracker       = (tDGRAM_SEND_TRACKING *)pTimer->Context;
        SendTransactId = pTracker->TransactionId;
        if (pNameHdr->TransactId != SendTransactId)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        // for MS & M nodes if there is a response from the name server,
        // then switch to broadcast name release.
        //
        //
        switch (NodeType & NODE_MASK)
        {
            case MNODE:
            case MSNODE:

                if (SrcIsNameServer(SrcAddress,SrcPort))
                {
                    Flags = pTracker->Flags;

                    if (Flags & NBT_NAME_SERVER)
                    {
                        //
                        // the next timeout will then switch to broadcast name
                        // release.
                        //
                        pTimer->Retries = 1;
                    }
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                return(STATUS_DATA_NOT_ACCEPTED);

            case PNODE:
                //
                //
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                //
                if ((pTimer = pNameAddr->pTimer))
                {
                    COMPLETIONCLIENT        pClientCompletion;
                    PVOID                   Context;

                    CHECK_PTR(pNameAddr);
                    pNameAddr->pTimer = NULL;
                    status = StopTimer(pTimer,&pClientCompletion,&Context);

                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    // the completion routine has not run yet, so run it
                    if (pClientCompletion)
                    {
                        (*pClientCompletion)(Context,STATUS_SUCCESS);
                    }
                }
                else
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                }

                return(STATUS_DATA_NOT_ACCEPTED);

            case BNODE:
            default:
                //
                // normally there should be no response to a name release
                // from a Bnode, but if there is, ignore it.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                return(STATUS_DATA_NOT_ACCEPTED);
        }
    }
    else
    {
        //
        //  It is a RELEASE REQUEST - so decide if the name should be removed
        //  from the remote or local table
        //

        // check for errors Bug# 125651 (NBT_MINIMUM_REGREQUEST == 68)
        //
        // Check for valid PDU size:
        //  lNumBytes >= 12 + [1+lNameSize] + 22(sizeof(tGENERALRR))
        // Check for Overflow error during comparisons with local names:
        //  lNumBytes >= 12 + [1+32(EncodedNetBios name)+Scope(==1 if NULL Scope)] + 22
        //
        if ((lNumBytes < ((NBT_MINIMUM_REGREQUEST-33) + lNameSize)) ||
            (lNumBytes < (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1))))
        {
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.NameReleaseFromNet[2]: WARNING!!! Rejecting Request -- lNumBytes<%d> < <%d>\n",
                    lNumBytes, (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1))));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        // check the REMOTE hash table for the name...
        //
        status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                 pName,
                                 pScope,
                                 &pNameAddr);
        bLocalTable = FALSE;
        if (!NT_SUCCESS(status))
        {
            //
            // check the LOCAL name table for the name since the name server
            // could be doing the equivalent of a name conflict demand
            //
            status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                     pName,
                                     pScope,
                                     &pNameAddr);
            bLocalTable = TRUE;
        }

        if (NT_SUCCESS(status))
        {
            // check if the address being released corresponds to the one in
            // the table - if not then ignore the release request - since someone
            // else presumably tried to get the name, was refused and now is
            // sending a name release request.
            //
            pRemainder = (tGENERALRR *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            if (pNameAddr->IpAddress != (ULONG)ntohl(pRemainder->IpAddress))
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            //
            // This name is neither in our local or remote hash table, so don't
            // process any further!
            // Bug#: 144944
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_DATA_NOT_ACCEPTED);
        }


        if (NT_SUCCESS(status))
        {

            //
            // Don't remove group names, since a single group member
            // releasing the name does not matter.  Group names time
            // out of the Remote table.
            //
            if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
            {
                switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
                {

                    case STATE_RESOLVING:
                        //
                        // stop any timer that may be going
                        //
                        CHECK_PTR(pNameAddr);
                        //
                        // Local table means that it is a name registration
                        // and we must avoid calling CompleteClientReq
                        //
                        if (pTimer = pNameAddr->pTimer)
                        {
                            COMPLETIONCLIENT        pClientCompletion;
                            PVOID                   pContext;

                            pNameAddr->pTimer = NULL;
                            status = StopTimer(pTimer,&pClientCompletion,&pContext);
                            // this will complete the irp(s) back to the clients
                            if (pClientCompletion)
                            {
                                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                                if (bLocalTable)
                                {
                                    (*pClientCompletion) (pContext,STATUS_DUPLICATE_NAME);
                                }
                                else
                                {
                                    CompleteClientReq (pClientCompletion, pContext, STATUS_TIMEOUT);
                                }
                                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                            }
                        }

                        break;

                    case STATE_RESOLVED:
                        // dereference the name if it is in the remote table,
                        // this should change the state to RELEASED.  For the
                        // local table just change the state to CONFLICT, since
                        // the local client still thinks it has the name open,
                        // however in the conflict state the name cannot be use
                        // to place new sessions and this node will not respond
                        // to name queries for the name.
                        //
                        if (!bLocalTable)
                        {
                            //
                            // if this is a pre-loaded name, just leave it alone
                            //
                            if (!(pNameAddr->NameTypeState & PRELOADED))
                            {
                                //
                                // if someone is still using the name, do not
                                // dereference it, since that would leave the
                                // ref count at 1, and allow RemoteHashTimeout
                                // code to remove it before the client using
                                // the name is done with it. Once the client is
                                // done with it (i.e. a connect request), they
                                // will deref it , setting the ref count to 1 and
                                // it will be suitable for reuse.
                                //
                                if (pNameAddr->RefCount > 1)
                                {
                                    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                                    pNameAddr->NameTypeState |= STATE_RELEASED;
                                }
                                else
                                {
                                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                                }
                            }
                        }
                        else
                        {
                            pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                            pNameAddr->NameTypeState |= STATE_CONFLICT;
                            pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
                            NbtLogEvent (EVENT_NBT_NAME_RELEASE, SrcAddress, 0x103);
                        }
                        break;

                    default:
                        break;
                }
            }


            //
            // tell WINS that the name released ok
            //
            Rcode = 0;
        }
        else
        {
            Rcode = NAME_ERROR;
        }

        //
        // Only respond if not a broadcast...
        //
        if (!(OpCodeFlags & FL_BROADCAST))
        {
            status = UdpSendResponse(
                            lNameSize,
                            pNameHdr,
                            NULL,
                            (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                            pDeviceContext,
                            Rcode,
                            eNAME_RELEASE,
                            OldIrq1);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
    } // end of Release Request processing

    return (STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
WackFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles Wait Acks from the name server. It finds the corresponding
    name service transaction and changes the timeout of that transaction according
    to the TTL field in the WACK.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;
    CTELockHandle       OldIrq1;
    ULONG               Ttl;
    tTIMERQENTRY        *pTimerEntry;

    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_WACK + NbtConfig.ScopeLength -1))
    {
        KdPrint(("Nbt:WACK TOO short = %X\n",lNumBytes));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.WackFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifdef VXD
    if ( FindContextDirect(    pNameHdr->TransactId ) != NULL )
    {
        status = STATUS_SUCCESS;
    }
    else
    {
#endif // VXD
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                    pName,
                                    pScope,
                                    &pNameAddr);
#ifdef VXD
    }
#endif // VXD

    if (NT_SUCCESS(status))
    {
        Ttl = *(ULONG UNALIGNED *)((ULONG_PTR)&pNameHdr->NameRR.NetBiosName[0]
                                   + lNameSize
                                   + FIELD_OFFSET(tQUERYRESP,Ttl) );
        Ttl = ntohl(Ttl);

        if (pTimerEntry = pNameAddr->pTimer)
        {

           // convert seconds to milliseconds and put into the DeltaTime
           // field so that when the next timeout occurs it changes the timer
           // value to this new one.  Depending on how many timeouts are left
           // this could cause the client to wait several times the WACK timeout
           // value.  For example a Name query nominally has two retries, so if
           // the WACK returns before the first retry then the total time waited
           // will be 2*Ttl. This is not a problem since the real reason for
           // the timeout is to prevent waiting forever for a dead name server.
           // If the server returns a WACK it is not dead and the chances are
           // that it will return a response before the timeout anyway.
           //
           // The timeout routine checks if TIMER_RETIMED is set and restarts
           // the timeout without any processing if that is true ( and clears
           // the flag too).
           //
           Ttl *= 1000;
           if (Ttl > pTimerEntry->DeltaTime)
           {
               pTimerEntry->DeltaTime = Ttl;
               pTimerEntry->Flags |= TIMER_RETIMED;
           }

        }

    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
VOID
SetupRefreshTtl(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  tNAMEADDR           *pNameAddr,
    IN  LONG                lNameSize
    )
/*++

Routine Description:

    This routine handles name refresh timeouts.  It looks at the Ttl in the
    registration response and determines if the Node's refresh timeout should
    be lengthened or shortened.  To do this both the Ttl and the name associated
    with the Ttl are kept in the Config structure.  If the Ttl becomes longer
    for the shortest names Ttl, then all the names use the longer value.

Arguments:

Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS        status;
    ULONG           Ttl;
    tTIMERQENTRY    *pTimerQEntry;

    // the Ttl in the pdu is in seconds.  We need to convert it to milliseconds
    // to use for our timer.  This limits the timeout value to about 50 days
    // ( 2**32 / 3600/24/1000  - milliseconds converted to days.)
    //
    Ttl = *(ULONG UNALIGNED *) ((PUCHAR)&pNameHdr->NameRR.NetBiosName[0]
                                + lNameSize
                                + FIELD_OFFSET(tQUERYRESP,Ttl));

    Ttl = ntohl(Ttl);

    // the Ttl value may overflow the value we can store in Milliseconds,
    // check for this case, and if it happens, use the longest timeout possible
    // that still runs refresh, - i.e. NBT_MAXIMUM_TTL disables refresh
    // altogether, so use NBT_MAXIMUM_TTL-1).
    if (Ttl >= 0xFFFFFFFF/1000)
    {
        Ttl = NBT_MAXIMUM_TTL - 1;
    }
    else
    {
        Ttl *= 1000;        // convert to milliseconds
    }

    // a zero Ttl means infinite, so set time the largest timeout
    //
    if (Ttl == 0)
    {
        Ttl = NBT_MAXIMUM_TTL;       // set very large number which turns off refreshes
    }
    else
    if (Ttl < NBT_MINIMUM_TTL)
    {
        Ttl = NBT_MINIMUM_TTL;
    }

    // Set the Ttl for the name record
    //
    pNameAddr->Ttl = Ttl;

    //
    // decide what to do about the existing timer....
    // If the new timeout is shorter, then cancel the
    // current timeout and start another one.
    //
    if (Ttl < NbtConfig.MinimumTtl)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Shortening Refresh Ttl from %d to %d\n",
                    NbtConfig.MinimumTtl, Ttl));

        NbtConfig.MinimumTtl = (ULONG)Ttl;
        //
        // don't allow the stop timer routine to call the completion routine
        // for the timer.
        //
        if (pTimerQEntry = NbtConfig.pRefreshTimer)
        {
            CHECK_PTR(pTimerQEntry);
            pTimerQEntry->TimeoutRoutine = NULL;
            status = StopTimer(pTimerQEntry,NULL,NULL);
        }

        // keep the timeout for checking refreshes to about 10 minutes
        // max. (MAX_REFRESH_CHECK_INTERVAL).  If the refresh interval
        // is less than 80 minutes then always use a refresh divisor of
        // 8 - this allows the initial default ttl of 16 minutes to result
        // in retries every 2 minutes.
        //
        NbtConfig.RefreshDivisor = NbtConfig.MinimumTtl/MAX_REFRESH_CHECK_INTERVAL;
        if (NbtConfig.RefreshDivisor < REFRESH_DIVISOR)
        {
            NbtConfig.RefreshDivisor = REFRESH_DIVISOR;
        }

        //
        // start the timer
        //
        status = StartTimer(RefreshTimeout,
                            Ttl/NbtConfig.RefreshDivisor,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This Timer is a global timer
                            &NbtConfig.pRefreshTimer,
                            0,
                            TRUE);
#if DBG
        if (!NT_SUCCESS(status))
        {
            KdPrint(("Nbt:Failed to start a new timer for refresh\n"));
        }
#endif

    }
    else
    if (Ttl > NbtConfig.MinimumTtl)
    {
        tHASHTABLE  *pHashTable;
        LONG        i;
        PLIST_ENTRY pHead,pEntry;

    // PUT this code back in again, since it is possible that the name
    // server could miss registering a name due to being busy and if we
    // lengthen the timeout here then that name will not get into wins for
    // a very long time.

        // the shortest Ttl got longer, check if there is another shortest
        // Ttl by scanning the local name table.
        //
        pHashTable = NbtConfig.pLocalHashTbl;
        for (i=0;i < pHashTable->lNumBuckets ;i++ )
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                //
                // Find a valid name with a lower TTL if possible
                //
                if ((pNameAddr->Name[0] != '*') &&
                    ((pNameAddr->NameTypeState & STATE_RESOLVED)) &&
                    (pNameAddr->Ttl < (ULONG)Ttl) &&
                    (!IsBrowserName(pNameAddr->Name)) && 
                    (!(pNameAddr->NameTypeState & NAMETYPE_QUICK)))
                {
                    if (pNameAddr->Ttl >= NBT_MINIMUM_TTL)
                    {
                        NbtConfig.MinimumTtl = pNameAddr->Ttl;
                    }
                    return;
                }
                pEntry = pEntry->Flink;
            }
        }

        //
        // if we get to here then there is no shorter ttl, so use the new
        // ttl received from the WINS as the ttl.  The next time the refresh
        // timer expires it will restart with this new ttl
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Lengthening Refresh Ttl from %d to %d\n",
                    NbtConfig.MinimumTtl, Ttl));

        NbtConfig.MinimumTtl = Ttl;

        // keep the timeout for checking refreshes to about 10 minutes
        // max. (MAX_REFRESH_CHECK_INTERVAL).  If the refresh interval
        // is less than 80 minutes then always use a refresh divisor of
        // 8 - this allows the initial default ttl of 16 minutes to result
        // in retries every 2 minutes.
        //
        NbtConfig.RefreshDivisor = NbtConfig.MinimumTtl/MAX_REFRESH_CHECK_INTERVAL;
        if (NbtConfig.RefreshDivisor < REFRESH_DIVISOR)
        {
            NbtConfig.RefreshDivisor = REFRESH_DIVISOR;
        }

    }


}

//----------------------------------------------------------------------------
NTSTATUS
DecodeNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress
    )
/*++

Routine Description:

    This routine handles putting the node status response pdu into the clients
    MDL.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pNext;
    tNODESTATUS UNALIGNED   *pNodeStatus;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq2;
    tDGRAM_SEND_TRACKING    *pTracker;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    BOOL                    MatchFound=FALSE;
    tIPADDRESS              IpAddress;
    PVOID                   pBuffer;

    // first find the originating request in the NodeStatus list
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);
    CTESpinLock(&NbtConfig,OldIrq);

    pEntry = pHead = &NbtConfig.NodeStatusHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pTracker = CONTAINING_RECORD(pEntry,tDGRAM_SEND_TRACKING,Linkage);
        ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
        ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

        if (!(pTimer = pTracker->pTimer))
        {
            continue;
        }

        MatchFound = FALSE;

        //
        // find who sent the request originally
        //
        if (pTracker->Flags & REMOTE_ADAPTER_STAT_FLAG)
        {
            IpAddress = Nbt_inet_addr(pTracker->pNameAddr->Name, REMOTE_ADAPTER_STAT_FLAG);
        }
        else
        {
            IpAddress = 0;
        }

        if ((CTEMemEqu(pName,pTracker->pNameAddr->Name,NETBIOS_NAME_SIZE)) ||
            ((IpAddress==SrcIpAddress)&&(IpAddress!=0)))
        {
            //
            // if we directed node status request to an ipaddr without knowing
            // its netbios name, then name is stored as "*      ".
            //
            if ((pName[0] == '*') && (IpAddress == 0) && (pTracker->pNameAddr->pIpAddrsList))
            {
                int  i=0;

                //
                // SrcIpAddress may not match the ipaddr to which we sent if
                // remote host is multihomed: so search whole list of all
                // ipaddrs for that host
                //
                ASSERT(pTracker->pNameAddr->pIpAddrsList);

                while(pTracker->pNameAddr->pIpAddrsList[i])
                {
                    if (pTracker->pNameAddr->pIpAddrsList[i++] == SrcIpAddress)
                    {
                        MatchFound = TRUE;
                        break;
                    }
                }
            }
            else
            {
                MatchFound = TRUE;
            }
        }

        if (MatchFound)
        {
            RemoveEntryList(pEntry);
            InitializeListHead (&pTracker->Linkage);    // in case the Timeout routine is running

            // this is the amount of data left, that we do not want to go
            // beyond, otherwise the system will bugcheck
            //
            Length -= FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize;
            pNodeStatus = (tNODESTATUS *)&pNameHdr->NameRR.NetBiosName[lNameSize];

            CTESpinFree(&NbtConfig,OldIrq);

            status = StopTimer(pTimer,&pClientCompletion,&pClientContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);

            if (pClientCompletion)
            {
                tDGRAM_SEND_TRACKING    *pClientTracker = (tDGRAM_SEND_TRACKING *) pClientContext;

                pClientTracker->RemoteIpAddress = SrcIpAddress;
                pClientTracker->pNodeStatus     = pNodeStatus;
                pClientTracker->NodeStatusLen   = Length;

                (*pClientCompletion) (pClientContext, STATUS_SUCCESS);

            }

            CTESpinLock(&NbtConfig.JointLock,OldIrq2);
            CTESpinLock(&NbtConfig,OldIrq);
            break;
        }
    }

    CTESpinFree(&NbtConfig,OldIrq);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    return(STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------
typedef enum    _dest_type {
    IP_ADDR,
    DNS,
    NETBIOS
} DEST_TYPE;

DEST_TYPE
GetDestType(
    IN tDGRAM_SEND_TRACKING *pClientTracker
    )

/*++
Routine Description:

    Classifies name passed in as an IP addr/Netbios name/Dns name

Arguments:

Return Value:
    DEST_TYPE

--*/
{
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.GetDestType: Name=<%16.16s:%x>\n",
            pClientTracker->pDestName, pClientTracker->pDestName[15]));

    if (Nbt_inet_addr(pClientTracker->pDestName, 0))
    {
        return  IP_ADDR;
    }
    else if (pClientTracker->RemoteNameLength > NETBIOS_NAME_SIZE)
    {
        return DNS;
    }
    else
    {
        return NETBIOS;
    }
}

//----------------------------------------------------------------------------
VOID
ExtractServerNameCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    )
/*++
Routine Description:

    This Routine searches for the server name (name ending with 0x20) from the
    list of names returned by node status response, and adds that name to the
    remote hash table.

Arguments:

    pNodeStatus      Node status response from the remote host
    pClientContext   Tracker for the seutp phase
    IpAddress        Ip address of the node that just responded

Return Value:

    none

--*/

{

    ULONG                   i;
    UCHAR                   NodeFlags, NameExtension;
    PCHAR                   pName;
    PCHAR                   pBestName = NULL;
    tSESSIONREQ             *pSessionReq;
    PUCHAR                  pCopyTo;
    DEST_TYPE               DestType;
    ULONG                   TrackerFlags;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    tNODESTATUS UNALIGNED   *pNodeStatus = pClientTracker->pNodeStatus;
    tIPADDRESS              IpAddress = pClientTracker->RemoteIpAddress;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    BOOL                    bForce20NameLookup = FALSE;

    ASSERT (NBT_VERIFY_HANDLE (pClientTracker, NBT_VERIFY_TRACKER));

    if (STATUS_SUCCESS == status)
    {
        status = STATUS_REMOTE_NOT_LISTENING;

        DestType = GetDestType(pClientTracker);
        TrackerFlags = pClientTracker->Flags;

        NameExtension = pClientTracker->pDestName[NETBIOS_NAME_SIZE-1];
        //
        // If the not a Netbios name, and the 16th character is ASCII,
        // then look for the Server name
        //
        if ((DestType != NETBIOS) &&
            (NameExtension > 0x20 ) &&
            (NameExtension < 0x7f ))
        {
            NameExtension = SPECIAL_SERVER_SUFFIX;
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("ExtractSrvName: DestType: %d\n", DestType));

        bForce20NameLookup = FALSE;
        
again:
        if (bForce20NameLookup) {
            DestType = DNS;
            NameExtension = 0x20;
        }

        for(i =0; i<pNodeStatus->NumNames; i++)
        {
            pName = &pNodeStatus->NodeName[i].Name[0];
            NodeFlags = pNodeStatus->NodeName[i].Flags;

            //
            // make sure it's a unique name (for connects only, for dgram sends, group names are fine)
            // and is not in conflict or released
            //
            if ((NodeFlags & (NODE_NAME_CONFLICT | NODE_NAME_RELEASED)) ||
                !(((TrackerFlags & SESSION_SETUP_FLAG) && !(NodeFlags & GROUP_STATUS)) ||
                  (TrackerFlags & (DGRAM_SEND_FLAG | REMOTE_ADAPTER_STAT_FLAG))))
            {
                continue;
            }

            if ((DestType == IP_ADDR) || (DestType == DNS))
            {
                if (pName[NETBIOS_NAME_SIZE-1] != NameExtension)
                {
                    continue;
                }

                //
                // For IP addresses and DNS names, we map the 0x20 name to the corresp 0x0 name
                // for datagram sends.
                //
                if (pClientTracker->Flags & DGRAM_SEND_FLAG)
                {
                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("ExtractServerName: Mapping 0x20 name to 0x0\n"));

                    pName[NETBIOS_NAME_SIZE-1] = 0x0;
                }
            }
            //
            // For Netbios names (resolved via DNS), we match the 16th byte exactly
            //
            else  if (pName[NETBIOS_NAME_SIZE-1] != pClientTracker->pDestName[NETBIOS_NAME_SIZE-1])
            {
                continue;
            }

            pDeviceContext = GetDeviceFromInterface(ntohl(IpAddress), TRUE);
            status = STATUS_SUCCESS;
            break;     // found the name: done with the for loop
        }

        if( !NT_SUCCESS(status) && !bForce20NameLookup &&
                pClientTracker->RemoteNameLength == NETBIOS_NAME_SIZE) {
            bForce20NameLookup = TRUE;
            goto again;
        }

        if (NT_SUCCESS(status))
        {
            //
            // fix up the connection tracker to point to the right name, now
            // that we know the server name to connect to
            //

            //
            // The FIND_NAME_FLAG was set to indicate that this is not a session setup attempt so
            // we can avoid the call to ConvertToHalfAscii.
            //
            if (!(pClientTracker->Flags & FIND_NAME_FLAG))
            {
                if (pClientTracker->Flags & SESSION_SETUP_FLAG)
                {
                    CTEMemCopy(pClientTracker->SendBuffer.pBuffer,pName,NETBIOS_NAME_SIZE);
                    CTEMemCopy(pClientTracker->pConnEle->RemoteName,pName,NETBIOS_NAME_SIZE);
#ifdef VXD
                    CTEMemCopy(&pClientTracker->pClientIrp->ncb_callname[0],pName,NETBIOS_NAME_SIZE);
#endif // VXD
                    pSessionReq = pClientTracker->SendBuffer.pDgramHdr;

                    //
                    // overwrite the Dest HalfAscii name in the Session Pdu with the correct name
                    //
                    pCopyTo = ConvertToHalfAscii((PCHAR)&pSessionReq->CalledName.NameLength,
                                                pName,
                                                NbtConfig.pScope,
                                                NbtConfig.ScopeLength);
                }
                else if (pClientTracker->Flags & DGRAM_SEND_FLAG)
                {
                    PCHAR       pCopyTo;
                    tDGRAMHDR   *pDgramHdr;

                    //
                    // Overwrite the dest name, so SendDgramContinue can find the name
                    // in the caches.
                    //
                    CTEMemCopy(pClientTracker->pDestName,pName,NETBIOS_NAME_SIZE);

                    //
                    // Copy over the actual dest name in half-ascii
                    // This is immediately after the SourceName; so offset the
                    // dest by the length of the src name.
                    //
                    pDgramHdr = pClientTracker->SendBuffer.pDgramHdr;
                    pCopyTo = (PVOID)&pDgramHdr->SrcName.NameLength;

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("pCopyTo:%lx\n", pCopyTo));

                    pCopyTo += 1 +                          // Length field
                               2 * NETBIOS_NAME_SIZE +     // actual name in half-ascii
                               NbtConfig.ScopeLength;     // length of scope

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("pCopyTo:%lx\n", pCopyTo));

                    ConvertToHalfAscii (pCopyTo, pName, NbtConfig.pScope, NbtConfig.ScopeLength);

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("Copied the remote name for dgram sends\n"));
                }
            }
            else
            {
                KdPrint(("ExtractServerName: Find name going on\n"));
            }

            //
            // Add this server name to the remote hashtable
            // if Nameaddr can't be added, it means an entry already exists
            // Get that entry and update its ipaddr.
            //
            LockAndAddToHashTable (NbtConfig.pRemoteHashTbl,
                                   pName,
                                   NbtConfig.pScope,
                                   IpAddress,
                                   NBT_UNIQUE,
                                   NULL,
                                   NULL,
                                   pDeviceContext,
                                   (USHORT) ((TrackerFlags & NBT_DNS_SERVER) ?
                                       NAME_RESOLVED_BY_DNS | NAME_RESOLVED_BY_ADAP_STAT:
                                       NAME_RESOLVED_BY_ADAP_STAT));
        }
    }

    if (pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    pClientCompletion = pClientTracker->CompletionRoutine;
    pClientContext = pClientTracker;    // Use this same tracker as the context

    CompleteClientReq(pClientCompletion, pClientContext, status);
}



//----------------------------------------------------------------------------
VOID
CopyNodeStatusResponseCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    )
/*++
Routine Description:

    This Routine copies data received from the net node status response to
    the client's irp.  It is called from inbound.c when a node status response
    comes in from the wire.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    none

--*/

{
    ULONG                   NumNames;
    ULONG                   i;
    PADAPTER_STATUS         pAdapterStatus = NULL;
    PNAME_BUFFER            pNameBuffer;
    ULONG                   BuffSize;
    ULONG                   AccumLength;
    PUCHAR                  pAscii;
    UCHAR                   Flags;
    ULONG                   DataLength;
    ULONG                   DestSize ;
    tSTATISTICS UNALIGNED   *pStatistics;
    ULONG                   SrcIpAddress;
    ULONG                   TotalLength;
    tNODESTATUS             *pNodeStat;
    COMPLETIONCLIENT        pClientCompletion;
    PIRP                    pIrp;
    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq, OldIrq1;

    CHECK_PTR(pClientTracker);
    SrcIpAddress            = pClientTracker->RemoteIpAddress;
    TotalLength             = pClientTracker->NodeStatusLen;
    pClientTracker->NodeStatusLen = 0;
    pNodeStat               = (tNODESTATUS *) pClientTracker->pNodeStatus;
    pClientTracker->pNodeStatus   = NULL;
    pIrp                    = pClientTracker->ClientContext;

    ASSERT (NBT_VERIFY_HANDLE (pClientTracker, NBT_VERIFY_TRACKER));
    ASSERT (pClientTracker->TrackerType == NBT_TRACKER_ADAPTER_STATUS);

    pClientTracker->pDeviceContext = NULL;  // Can be set below if we need add the name to the cache

    if (STATUS_SUCCESS == status)
    {
        //
        // Bug# 125629:
        // We have already verified in QueryFromNet (just before calling
        // DecodeNodeStatusResponse) that the NodeStatus structure is
        // large enough to cover the NumNames field + it has the number of
        // names specified in that field
        //
        NumNames = pNodeStat->NumNames;
        BuffSize = sizeof(ADAPTER_STATUS) + NumNames*sizeof(NAME_BUFFER);

        // sanity check that we are not allocating more than 64K for this stuff
        if (BuffSize > 0xFFFF)
        {
            status = STATUS_UNSUCCESSFUL;
            goto ExitRoutine;
        }

        pAdapterStatus = NbtAllocMem((USHORT)BuffSize,NBT_TAG('9'));
        if (!pAdapterStatus)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitRoutine;
        }

        // Fill out the adapter status structure with zeros first
        CTEZeroMemory((PVOID)pAdapterStatus,BuffSize);

        // get the source MAC address from the statistics portion of the pdu
        //
        if (TotalLength >= (NumNames*sizeof(tNODENAME) + sizeof(tSTATISTICS)))
        {
            pStatistics = (tSTATISTICS UNALIGNED *)((PUCHAR)&pNodeStat->NodeName[0] + NumNames*sizeof(tNODENAME));

            CTEMemCopy(&pAdapterStatus->adapter_address[0], &pStatistics->UnitId[0], sizeof(tMAC_ADDRESS));
        }

        pAdapterStatus->rev_major = 0x03;
        pAdapterStatus->adapter_type = 0xFE;    // pretend it is an ethernet adapter

        //
        // get the ptr to the statistics field if there is one in the pdu
        //
        AccumLength = NumNames * sizeof(tNODENAME) +
                      FIELD_OFFSET(tNODESTATUS, NodeName) + sizeof(USHORT) +
                      FIELD_OFFSET( tSTATISTICS, SessionDataPacketSize ) ;

        if (AccumLength <= TotalLength)
        {
            //
            // there is a whole statistics portion to the adapter status command,
            // so we can get the session pdu size out of it.
            //
            pAdapterStatus->max_sess = ntohs((USHORT)*((PUCHAR)pNodeStat + AccumLength - sizeof(USHORT)));
        }

        // get the address of the name buffer at the end of the adapter status
        // structure so we can copy the names into this area.
        pNameBuffer = (NAME_BUFFER *) ((ULONG_PTR)pAdapterStatus + sizeof(ADAPTER_STATUS));

        // set the AccumLength to the start of the node name array in the buffer
        // so we can count through the buffer and be sure not to run off the end
        //
        AccumLength = FIELD_OFFSET(tNODESTATUS, NodeName);

        //
        // We need to determine the outgoing Device for the remote machine, in
        // case we need to add any names below.
        //
        pClientTracker->pDeviceContext = GetDeviceFromInterface (htonl(SrcIpAddress), TRUE);

        for(i =0; i< NumNames; i++)
        {
            AccumLength += sizeof(tNODENAME);
            if (AccumLength > TotalLength)
            {
                    //
                    //  The remote buffer is incomplete, what else can we do?
                    //
                    status = STATUS_UNSUCCESSFUL;
                    goto ExitCleanup;
            }
            pAdapterStatus->name_count++ ;
            pAscii = (PCHAR)&pNodeStat->NodeName[i].Name[0];
            Flags = pNodeStat->NodeName[i].Flags;

            pNameBuffer->name_flags = (Flags & GROUP_STATUS) ? GROUP_NAME : UNIQUE_NAME;

            //
            // map the name states
            //
            if (Flags & NODE_NAME_CONFLICT)
            {
                if (Flags & NODE_NAME_RELEASED)
                    pNameBuffer->name_flags |= DUPLICATE_DEREG;
                else
                    pNameBuffer->name_flags |= DUPLICATE;
            }
            else if (Flags & NODE_NAME_RELEASED)
            {
                pNameBuffer->name_flags |= DEREGISTERED;
            }
            else
            {
                pNameBuffer->name_flags |= REGISTERED;
            }

            pNameBuffer->name_num = (UCHAR)i+1;
            CTEMemCopy(pNameBuffer->name,pAscii,NETBIOS_NAME_SIZE);

            //
            // If the name is the 0x20 name, see if we can add it to the remote hashtable
            // (only if the name is not already there)!
            //
            if ((pAscii[NETBIOS_NAME_SIZE-1] == 0x20) &&
                ((Flags & (NODE_NAME_CONFLICT | NODE_NAME_RELEASED)) == 0))
            {
                NbtAddEntryToRemoteHashTable (pClientTracker->pDeviceContext,
                                              NAME_RESOLVED_BY_ADAP_STAT,
                                              pAscii,
                                              SrcIpAddress,
                                              NbtConfig.RemoteTimeoutCount*60,  // from minutes to secs
                                              UNIQUE_STATUS);
            }

            pNameBuffer++;
        }

        //
        //  Reduce the name count if we can't fit the buffer
        //
#ifdef VXD
        DestSize = ((NCB*)pIrp)->ncb_length ;
#else
        DestSize = MmGetMdlByteCount( pIrp->MdlAddress ) ;
#endif

        CHECK_PTR(pAdapterStatus);
        if ( BuffSize > DestSize )
        {
            if ( DestSize < sizeof( ADAPTER_STATUS ))
            {
                pAdapterStatus->name_count = 0 ;
            }
            else
            {
                pAdapterStatus->name_count = (WORD) (DestSize- sizeof(ADAPTER_STATUS)) / sizeof(NAME_BUFFER) ;
            }
        }

        //
        //  Copy the built adapter status structure
        //
#ifdef VXD
        if ( BuffSize > DestSize )
        {
            status = STATUS_BUFFER_OVERFLOW ;
            BuffSize = DestSize ;
        }
        else
        {
            status = STATUS_SUCCESS ;
        }

        CTEMemCopy(((NCB*)pIrp)->ncb_buffer, pAdapterStatus, BuffSize);
        ((NCB*)pIrp)->ncb_length = (WORD) BuffSize;     //  Set here to be compatible with NT
#else
        status = TdiCopyBufferToMdl (pAdapterStatus, 0, BuffSize, pIrp->MdlAddress, 0, &DataLength);
        pIrp->IoStatus.Information = DataLength;
        pIrp->IoStatus.Status = status;
#endif
    }

ExitCleanup:
    if (pAdapterStatus)
    {
        CTEMemFree((PVOID)pAdapterStatus);
    }

ExitRoutine:

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // the tracker block was unlinked in DecodeNodeStatusResponse,
    // and its header was freed when the send completed, so just relink
    // it here - this deref should do the relink.
    //

    if (pIrp)
    {
        if (status == STATUS_SUCCESS ||
            status == STATUS_BUFFER_OVERFLOW )  // Only partial data copied
        {
            // -1 means the receive length is already set in the irp
            CTEIoComplete(pIrp,status,0xFFFFFFFF);
        }
        else
        {
            //
            // failed to get the adapter status, so
            // return failure status to the client.
            //
            CTEIoComplete(pIrp,STATUS_IO_TIMEOUT,0);
        }
    }

    if (pClientTracker->pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pClientTracker->pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
    }

    NBT_DEREFERENCE_TRACKER (pClientTracker, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
NTSTATUS
SendNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pInNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress,
    IN  USHORT              SrcPort,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine handles putting the node status response pdu into the clients
    MDL.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    PUCHAR                  pScope;
    PUCHAR                  pInScope;
    ULONG                   Position;
    ULONG                   CountNames;
    ULONG                   BuffSize;
    tNODESTATUS UNALIGNED   *pNodeStatus;
    tNAMEHDR                *pNameHdr;
    CTELockHandle           OldIrq2;
    ULONG                   i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tADDRESSELE             *pAddressEle;
    tNAMEADDR               *pNameAddr;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   InScopeLength;
    tSTATISTICS UNALIGNED   *pStatistics;
    tNODENAME UNALIGNED     *pNode;
    CTEULONGLONG            AdapterMask;
    ULONG                   Len;

    if (Length > sizeof(tNAMEHDR) + lNameSize - 1 + sizeof(ULONG))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    // verify that the requesting node is in the same scope as this node, so
    // get a ptr to the scope, which starts 16*2 (32) bytes into the
    // netbios name in the pdu.
    //
    pInScope = (PUCHAR)&pInNameHdr->NameRR.NetBiosName[(NETBIOS_NAME_SIZE <<1)];
    pScope = NbtConfig.pScope;

    Position = sizeof(tNAMEHDR) - sizeof(tNETBIOS_NAME) +1 + (NETBIOS_NAME_SIZE <<1);

    // check the scope length
    InScopeLength = Length - Position - sizeof(ULONG);
    if (InScopeLength != NbtConfig.ScopeLength)
    {
        status = STATUS_DATA_NOT_ACCEPTED;
        goto ErrorExit;
    }

    // compare scopes for equality and avoid running off the end of the pdu
    //
    i= 0;
    while (i < NbtConfig.ScopeLength)
    {
        if (*pInScope != *pScope)
        {
            status = STATUS_DATA_NOT_ACCEPTED;
            goto ErrorExit;
        }
        i++;
        pInScope++;
        pScope++;
    }

    // get the count of names, excluding '*...' which we do not send...
    //
    CountNames = CountLocalNames(&NbtConfig);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Node Status Response, with %d names\n",CountNames));

    // this is only a byte field, so only allow up to 255 names.
    if (CountNames > 255)
    {
        CountNames = 255;
    }


    // Allocate Memory for the adapter status

    // - ULONG for the Nbstat and IN that are part of Length.  CountNames-1
    // because there is one name in sizeof(tNODESTATUS) already
    //
    BuffSize = Length + sizeof(tNODESTATUS) - sizeof(ULONG) + (CountNames-1)*sizeof(tNODENAME)
                    +  sizeof(tSTATISTICS);

    pNameHdr = (tNAMEHDR *)NbtAllocMem((USHORT)BuffSize,NBT_TAG('A'));
    if (!pNameHdr)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // copy the request to the response and change a few bits around
    //
    CTEMemCopy((PVOID)pNameHdr,(PVOID)pInNameHdr,Length);
    pNameHdr->OpCodeFlags = OP_RESPONSE | FL_AUTHORITY;
    pNameHdr->QdCount = 0;
    pNameHdr->AnCount = 1;

    pNodeStatus = (tNODESTATUS UNALIGNED *)&pNameHdr->NameRR.NetBiosName[lNameSize];
    pNodeStatus->Ttl = 0;

    pNode = (tNODENAME UNALIGNED *)&pNodeStatus->NodeName[0];
    AdapterMask = pDeviceContext->AdapterMask;

    i = 0;
    pEntry = pHead = &NbtConfig.AddressHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        pNameAddr = pAddressEle->pNameAddr;

        pNode->Flags = (pAddressEle->NameType == NBT_UNIQUE) ? UNIQUE_STATUS : GROUP_STATUS;

        // all names have this one set
        //
        pNode->Flags |= NODE_NAME_ACTIVE;
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
            default:
            case STATE_RESOLVED:
                break;

            case STATE_CONFLICT:
                pNode->Flags |= NODE_NAME_CONFLICT;
                break;

            case STATE_RELEASED:
                pNode->Flags |= NODE_NAME_RELEASED;
                break;

            case STATE_RESOLVING:
                // don't count these names.
                continue;

        }

        switch (NodeType & NODE_MASK)
        {
            case BNODE:
                pNode->Flags |= STATUS_BNODE;
                break;

            case MSNODE:
            case MNODE:
                pNode->Flags |= STATUS_MNODE;
                break;

            case PNODE:
                pNode->Flags |= STATUS_PNODE;
        }

        CHECK_PTR(pNode);

        // Copy the name in the pdu
        CTEMemCopy((PVOID)&pNode->Name[0], (PVOID)pNameAddr->Name, NETBIOS_NAME_SIZE);
        pNode->Resrved = 0;

        // check for the permanent name...and add it too
        //
        if (pNameAddr->NameTypeState & NAMETYPE_QUICK)
        {
            //
            // the permanent name is added as a Quick Add in the name table
            // do not put the permanent name into the response
            //
            continue;
        }
        else if ((pNameAddr->Name[0] == '*') ||
                 (pNameAddr->NameTypeState & STATE_RESOLVING) ||
                 (!(pNameAddr->AdapterMask & AdapterMask)))
        {
            //
            // do not put the broadcast name into the response, since neither
            // NBF or WFW NBT puts it there.

            // Also, to not respond with resolving names, or names that are
            // not registered on this adapter (multihomed case)
            //
            continue;
        }

        i++;
        pNode++;
        CHECK_PTR(pNode);

        if (i >= CountNames)
        {
            break;
        }
    }

    CHECK_PTR(pNameHdr);
    CHECK_PTR(pNodeStatus);

    //
    // set the count of names in the response packet
    //
    pNodeStatus->NumNames = (UCHAR)i;

    Len = i*sizeof(tNODENAME) + 1 + sizeof(tSTATISTICS); //+1 for NumNames Byte
    pNodeStatus->Length = (USHORT)htons(Len);

    // fill in some of the statistics fields which occur after the name table
    // in the PDU
    //
    pStatistics = (tSTATISTICS UNALIGNED *)((PUCHAR)&pNodeStatus->NodeName[0] + i*sizeof(tNODENAME));

    CTEZeroMemory((PVOID)pStatistics,sizeof(tSTATISTICS));

    //
    // put the MAC address in the response
    //
    CTEMemCopy(&pStatistics->UnitId[0], &pDeviceContext->MacAddress.Address[0], sizeof(tMAC_ADDRESS));
    //
    // Now send the node status message
    //
    status = GetTracker(&pTracker, NBT_TRACKER_NODE_STATUS_RESPONSE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    if (!NT_SUCCESS(status))
    {
        CTEMemFree((PVOID)pNameHdr);
    }
    else
    {
        CHECK_PTR(pTracker);
        pTracker->SendBuffer.HdrLength = BuffSize;
        pTracker->SendBuffer.pDgramHdr = (PVOID)pNameHdr;
        pTracker->SendBuffer.pBuffer = NULL;
        pTracker->SendBuffer.Length = 0;
        pTracker->pDeviceContext = pDeviceContext;

        status = UdpSendDatagram(pTracker,
                                 SrcIpAddress,
                                 QueryRespDone, // this routine frees memory and puts the tracker back
                                 pTracker,
                                 SrcPort, // NBT_NAMESERVICE_UDP_PORT 31343 - reply to port request came on...
                                 NBT_NAME_SERVICE);
    }

    return(status);

ErrorExit:

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);


    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
UpdateNameState(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  tNAMEADDR               *pNameAddr,
    IN  ULONG                   Len,
#ifdef MULTIPLE_WINS
    IN  PULONG                  pContextFlags,
#endif
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 NameServerIsSrc,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           OldIrq1
    )
/*++

Routine Description:

    This routine handles putting a list of names into the hash table when
    a response is received that contains one or more than one ip address.

Arguments:


Return Value:

    none

--*/
{

    ULONG           i, CountAddrs;
    tIPADDRESS      *pIpList;
    ULONG           ExtraNames;
    NTSTATUS        status = STATUS_SUCCESS;
    CTELockHandle   OldIrq;
    USHORT          NameAddFlags = (NameServerIsSrc ? NAME_RESOLVED_BY_WINS : NAME_RESOLVED_BY_BCAST);

    //
    // put all of the addresses into a list that is pointed to by the pNameAddr record
    // Terminate it with -1 (0 means a broadcast address)
    //
    ASSERT(pNameAddr->pIpAddrsList == NULL);

    CountAddrs = Len / tADDSTRUCT_SIZE;
    if ((CountAddrs > NBT_MAX_INTERNET_GROUP_ADDRS)|| // probably a badly formated packet (max value=1000)
        (CountAddrs*tADDSTRUCT_SIZE != Len) ||
        (!(pNameAddr->pIpAddrsList = NbtAllocMem(sizeof(tIPADDRESS)*(1+CountAddrs),NBT_TAG('8')))))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        return (STATUS_UNSUCCESSFUL);
    }

    /*
     * Replace broadcast address -1 (0xffffffff) with 0 because -1 is reserved as terminator
     */
    for (i = 0; i < CountAddrs; i++) {
        pNameAddr->pIpAddrsList[i] =  (pAddrStruct[i].IpAddr == (tIPADDRESS)(-1))? 0: htonl(pAddrStruct[i].IpAddr);
    }
    pNameAddr->pIpAddrsList[CountAddrs] = (tIPADDRESS)(-1);

    // a pos. response to a previous query, so change the state in the
    // hash table to RESOLVED
    CHECK_PTR(pNameAddr);
    if (pNameAddr->NameTypeState & STATE_RESOLVING)
    {
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_RESOLVED;

        // check if a group name...
        //
        if (ntohs(pAddrStruct->NbFlags) & FL_GROUP)
        {
            pNameAddr->NameTypeState &= ~NAME_TYPE_MASK;

            // It is difficult to differentiate nameserver responses from
            // single node responses, when a single ip address is returned.
            // It could be the name server returning an Inet Group with one
            // entry or another node simply responding with its address.
            //
            // If the response is just a single broadcast address, we store
            // it as type NAMETYPE_GROUP, otherwise we should store it as
            // NAMETYPE_INET_GROUP -- we should remove the check for NameServer
            // since it does not always work for muti-homed, or cluster Wins servers
            //
            // WINS puts -1 to say it's a groupname
            //
            if ((CountAddrs == 1) &&
                (pAddrStruct->IpAddr == (ULONG)-1))
            {
                // using zero here tells the UdpSendDatagramCode to
                // send to the subnet broadcast address when talking to
                // that address.
                //
                // For Bnodes store the Address of the node that responded
                // to the group name query, since we do allow sessions to
                // group names for BNODES since they can resolve the name to
                // and IP address, whereas other nodes cannot.
                //
                // store the ipaddr regardless of nodetype.  We don't know if this info will be
                // used to setup a session or send a datagram.  We do check NameTypeState
                // while setting up session, so no need to filter out NodeType info here.

                ASSERT(pAddrStruct->IpAddr == (ULONG)-1);
                pNameAddr->IpAddress = 0;
                pNameAddr->NameTypeState |= NAMETYPE_GROUP;
            }
            else
            {
                NameAddFlags |= NAME_ADD_INET_GROUP;
                pNameAddr->NameTypeState |= NAMETYPE_INET_GROUP;
            }
        }
        else
        {
            if (CountAddrs > 1)
            {
                tIPADDRESS              IpAddress;
                NBT_WORK_ITEM_CONTEXT   *pContext;

                // the name query response contains several ip addresses for
                // a multihomed host, so pick an address that matches one of
                // our subnet masks
                //
                // Do the old thing for datagram sends/name queries.
                //
#ifndef VXD
                if ((NbtConfig.TryAllAddr) &&
                    (pTracker) &&
                    (pTracker->Flags & SESSION_SETUP_FLAG))
                {
                    if (NT_SUCCESS(status = ChooseBestIpAddress(pAddrStruct,
                                                                Len,
                                                                pDeviceContext,
                                                                pTracker,
                                                                &IpAddress,
                                                                TRUE)))
                    {
                        //
                        // At this point, pTracker->IPList contains the sorted list of destination
                        // IP addresses. Submit this list to the lmhsvc service to ping each and
                        // return which is reachable.
                        //
                        pContext = (NBT_WORK_ITEM_CONTEXT *) NbtAllocMem (sizeof(NBT_WORK_ITEM_CONTEXT), NBT_TAG('H'));
                        if (pContext)
                        {
                            pContext->pTracker = NULL;              // no query tracker
                            pContext->pClientContext = pTracker;    // the client tracker
                            pContext->ClientCompletion = SessionSetupContinue;
                            pContext->pDeviceContext = pTracker->pDeviceContext;
                            StartLmHostTimer(pContext, TRUE);
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                            IF_DBG(NBT_DEBUG_NAMESRV)
                                KdPrint(("Nbt.UpdateNameState: Kicking off CheckAddr : %lx\n", pAddrStruct));

                            status = NbtProcessLmhSvcRequest(pContext, NBT_PING_IP_ADDRS);
                            CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                            if (NT_SUCCESS(status))
                            {
                                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE); // PendingQ name
                                ASSERT (status == STATUS_PENDING);
                                return (status);    // shd be STATUS_PENDING
                            }

                            CTEFreeMem (pContext);
                            KdPrint(("Nbt.UpdateNameState: ERROR %lx -- NbtProcessLmhSvcRequest\n", status));
                        }
                        else
                        {
                           KdPrint(("Nbt.UpdateNameState: ERROR -- Couldn't alloc mem for pContext\n"));
                        }

                        //
                        // We failed above, but we still the addresses that were returned, so
                        // just pick up the first Ip address!
                        //
                        pNameAddr->IpAddress = IpAddress;
                        status = STATUS_SUCCESS;
                    }
                    else
                    {
                        KdPrint(("Nbt.UpdateNameState: ERROR -- ChooseBestIpAddress returned %lx\n", status));
                    }
                }
                else
#endif
                {

                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt:Choosing best IP addr...\n"));

                    if (NT_SUCCESS (status = ChooseBestIpAddress(pAddrStruct,Len,pDeviceContext,
                                                                 pTracker, &IpAddress, FALSE)))
                    {
                        pNameAddr->IpAddress = IpAddress;
                    }
#ifdef MULTIPLE_WINS
#ifdef VXD
                    //
                    // This is a hack to make VNBT work for multi-homed machines since
                    // currently we don't ping the addresses as in the case of NT above
                    // to find a good address
                    //
                    // Reset the ContextFlags so that we re-query the same server to make
                    // sure we try all the addresses
                    //
                    if (pTracker)
                    {
                        *pContextFlags = pTracker->ResolutionContextFlags;
                    }
#endif  // VXD
#endif  // MULTIPLE_WINS
                }
            }
            else
            {
                // it is already set to a unique address...since that is the default
                // when the name is queried originally.

                pNameAddr->IpAddress = ntohl(pAddrStruct->IpAddr);
            }
        }
    }

    if (NT_SUCCESS(status))
    {
        AddToHashTable (NbtConfig.pRemoteHashTbl,
                        pNameAddr->Name,
                        NbtConfig.pScope,
                        pNameAddr->IpAddress,
                        0,
                        pNameAddr,
                        NULL,
                        pDeviceContext,
                        NameAddFlags);
    }
    else
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
ULONG
MakeList(
    IN  tDEVICECONTEXT            *pDeviceContext,
    IN  ULONG                     CountAddrs,
    IN  tADDSTRUCT UNALIGNED      *pAddrStruct,
    IN  tIPADDRESS                *pAddrArray,
    IN  ULONG                     SizeOfAddrArray,
    IN  BOOLEAN                   IsSubnetMatch
    )
/*++

Routine Description:

    This routine gets a list of ip addresses that match the network number
    This can either be the subnet number or the network number depending
    on the boolean IsSubnetMatch

Arguments:


Return Value:

    none

--*/
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tDEVICECONTEXT          *pTmpDevContext;
    ULONG                   MatchAddrs = 0;
    tADDSTRUCT UNALIGNED    *pAddrs;
    ULONG                   i;
    ULONG                   IpAddr, NetworkNumber, NetworkNumberInIpAddr;
    UCHAR                    IpAddrByte;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddrs = pAddrStruct;

        pTmpDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        //
        // DeviceContext is non-null, if a check has to be made on a specific
        // DeviceContext.  Otherwise it's null (i.e. check all DeviceContexts)
        //
        if (pDeviceContext)
        {
            if (pTmpDevContext != pDeviceContext)
            {
                continue;
            }
        }

        //
        // Check whether the Caller requested a Subnet or Network number match,
        // and if they are 0 for this Device, go to the next device
        //
        if (IsSubnetMatch)
        {
            NetworkNumber = pTmpDevContext->SubnetMask & pTmpDevContext->IpAddress;
        }
        else
        {
            NetworkNumber = pTmpDevContext->NetMask;
        }

        //
        // If the Subnet Mask or Network Mask is 0, then there is no use
        // proceeding further since the Device is probably not up
        //
        if (!NetworkNumber)
        {
            continue;
        }

        // extract the ipaddress from each address structure
        for ( i = 0 ; i < CountAddrs; i++ )
        {

            NetworkNumberInIpAddr = IpAddr = ntohl(pAddrs->IpAddr);

            if (IsSubnetMatch)
            {
                if (((pTmpDevContext->SubnetMask & IpAddr) == NetworkNumber) &&
                    (MatchAddrs < SizeOfAddrArray/sizeof(ULONG)))
                {
                    // put the ipaddress into a list incase multiple match
                    // and we want to select one randomly
                    //
                    pAddrArray[MatchAddrs++] = IpAddr;

                }
                pAddrs++;
            }
            else
            {
                IpAddrByte = ((PUCHAR)&IpAddr)[3];
                if ((IpAddrByte & 0x80) == 0)
                {
                    // class A address - one byte netid
                      NetworkNumberInIpAddr &= 0xFF000000;
                }
                else if ((IpAddrByte & 0xC0) ==0x80)
                {
                    // class B address - two byte netid
                    NetworkNumberInIpAddr &= 0xFFFF0000;
                }
                else if ((IpAddrByte & 0xE0) ==0xC0)
                {
                    // class C address - three byte netid
                    NetworkNumberInIpAddr &= 0xFFFFFF00;
                }

                if ((NetworkNumberInIpAddr == NetworkNumber) &&
                    (MatchAddrs < SizeOfAddrArray/sizeof(ULONG)))
                {
                    // put the ipaddress into a list incase multiple match
                    // and we want to select one randomly
                    //
                    pAddrArray[MatchAddrs++] = IpAddr;

                }
                pAddrs++;
            }
        }
    }

    return(MatchAddrs);
}
//----------------------------------------------------------------------------
NTSTATUS
ChooseBestIpAddress(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  ULONG                   Len,
    IN  tDEVICECONTEXT          *pDeviceContext,
    OUT tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    IN  BOOLEAN                 fReturnAddrList
    )
/*++

Routine Description:

    This routine gets a list of ip addresses and attempts to pick one of them
    as the best address.  This occurs when WINS returns a list of addresses
    for a multihomed host and we want want the one that is on a subnet
    corresponding to one of the network cards.  Failing to match on
    subnet mask, results in a random selection from the addresses.

Arguments:


Return Value:

    none

--*/
{

    ULONG           CountAddrs, NextAddr, MatchAddrs = 0;
    ULONG           i, j, Random;
    tIPADDRESS      MatchAddrArray[60];
    tADDSTRUCT      temp;
    CTESystemTime   TimeValue;

    // one or more addresses were returned,
    // so pick one that is best
    //
    CountAddrs = Len / tADDSTRUCT_SIZE;

    if (CountAddrs*tADDSTRUCT_SIZE == Len)
    {
        //
        // Randomize all of the addresses!
        //
        for (i=CountAddrs-1; i>0; i--)
        {
            CTEQuerySystemTime(TimeValue);
            Random = RandomizeFromTime(TimeValue, (i+1));
            ASSERT (Random < CountAddrs);

            if (Random != i)
            {
                //
                // Exchange the address at Random with i!
                //
                temp = pAddrStruct[Random];
                pAddrStruct[Random] = pAddrStruct[i];
                pAddrStruct[i] = temp;
            }
        }

        //
        // First check if any addresses are on the same subnet as this
        // devicecontext.
        //
        MatchAddrs = MakeList(pDeviceContext,
                              CountAddrs,
                              pAddrStruct,
                              MatchAddrArray,
                              sizeof(MatchAddrArray),
                              TRUE);

        //
        // if none of the ipaddrs is on the same subnet as this DeviceContext,
        // try other DeviceContexts
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(NULL,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  TRUE);
        }

        // if none of the addresses match the subnet address of any of the
        // DeviceContexts, then go through the same checks looking for matches
        // that have the same network number as the Device this name was resolved on.
        // Bug # 212432
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(pDeviceContext,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  FALSE);
        }

        //
        // if none of the addresses match the subnet address of any of the
        // DeviceContexts, then go through the same check looking for matches
        // that have the same network number for any connected device.
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(NULL,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  FALSE);
        }
    }
    else
    {
        // the pdu length is not an even multiple of the tADDSTRUCT data
        // structure
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // We had already randomized the list earlier, so now just pick up
    // the first address for the IpAddress value!
    //
    if (MatchAddrs)
    {
        *pIpAddress = MatchAddrArray[0];
    }
    else // No match
    {
        *pIpAddress = htonl(pAddrStruct[0].IpAddr);
    }

    //
    // See if the Caller requested only 1 IP address
    //
    if (!fReturnAddrList)
    {
        return (STATUS_SUCCESS);
    }

    //
    // Move all addresses which matched any of the Subnets or Network numbers
    // to the top of the list (if no matches, then we will copy the whole list as is)
    //
    if (MatchAddrs)
    {
        //
        // Sort the IP addr list on basis of best IP addr. in MatchAddrArray
        //
        // NOTE: this is not a strictly sorted list (the actual sort might be too expensive),
        // instead we take all the addresses that match the subnet mask (say) and
        // clump the remaining ones in the same group. This way we ensure that whatever
        // we chose as the best address is still given preference as compared to the
        // other addresses.
        //

        //
        // NextAddr is the index of the next Address in AddrStruct which can be switched
        //
        NextAddr = 0;
        for (i=0; i<MatchAddrs; i++)   // for each address which matched the Net/Subnet masks
        {
            //
            // SWAP(pAddrStruct[NextAddr], pAddrStruct[Index(MatchAddrArray[i])]);
            //
            for (j=NextAddr; j<CountAddrs; j++)
            {
                if (pAddrStruct[j].IpAddr == (ULONG)ntohl(MatchAddrArray[i]))
                {
                    if (j != NextAddr)      // Swap if indices are different
                    {
                        IF_DBG(NBT_DEBUG_NAMESRV)
                            KdPrint(("Nbt.ChooseBestIpAddress: Swap Address[%d]=<%x> <=> Address[%d]=<%x>\n",
                                NextAddr, pAddrStruct[NextAddr].IpAddr, j, pAddrStruct[j].IpAddr));

                        temp = pAddrStruct[NextAddr];
                        pAddrStruct[NextAddr] = pAddrStruct[j];
                        pAddrStruct[j] = temp;
                    }
                    NextAddr++;             // Fill in next Address
                    break;
                }
            }

            if (NextAddr >= CountAddrs)
            {
                break;
            }
        }
    }

    //
    // We will have to return the list of IP addresses in the
    // Tracker's IpList field, so ensure that pTracker is valid
    //
    if (!pTracker)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Now copy all the addresses into the Tracker's IP List
    //
    pTracker->IpList = NbtAllocMem(sizeof(ULONG)*(1+CountAddrs),NBT_TAG('8'));
    if (!pTracker->IpList)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    for (j=0; j<CountAddrs; j++)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.ChooseBestIpAddress: pAddrStruct[%d/%d]: %lx\n", (j+1), CountAddrs, pAddrStruct[j].IpAddr));
        pTracker->IpList[j] = pAddrStruct[j].IpAddr;
    }
    pTracker->IpList[CountAddrs] = 0;
    pTracker->NumAddrs = CountAddrs;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

#ifdef MULTIPLE_WINS
BOOLEAN
IsNameServerForDevice(
    IN  ULONG               SrcAddress,
    IN  tDEVICECONTEXT      *pDevContext
    )
/*++

Routine Description:

    This function checks the src address against this adapter's name server
    addresses to see if it is a name server.

Arguments:


Return Value:

    BOOLEAN - TRUE or FALSE

--*/
{
    int             i;

    if ((pDevContext->lNameServerAddress == SrcAddress) ||
        (pDevContext->lBackupServer == SrcAddress))
    {
        return(TRUE);
    }

    for (i=0; i < pDevContext->lNumOtherServers; i++)
    {
        if (pDevContext->lOtherServers[i] == SrcAddress)
        {
            return (TRUE);
        }
    }

    return (FALSE);
}
//----------------------------------------------------------------------------
#endif


BOOLEAN
SrcIsNameServer(
    IN  ULONG                SrcAddress,
    IN  USHORT               SrcPort
    )
/*++

Routine Description:

    This function checks the src address against all adapters' name server
    address to see if it came from a name server.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tDEVICECONTEXT  *pDevContext;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;

    if (SrcPort == NbtConfig.NameServerPort)
    {
        while (pEntry != pHead)
        {
            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

#ifdef MULTIPLE_WINS
            if (IsNameServerForDevice(SrcAddress, pDevContext))
#else
            if ((pDevContext->lNameServerAddress == SrcAddress) ||
                (pDevContext->lBackupServer == SrcAddress))
#endif
            {
                return(TRUE);
            }
            pEntry = pEntry->Flink;
        }
    }
#ifndef VXD
    //
    // If wins is on this machine the above SrcIsNameServer
    // check may not be sufficient since this machine is
    // the name server and that check checks the nameservers
    // used for name queries.  If WINS is on this machine it
    // could have sent from any local adapter's IP address
    //
    if (pWinsInfo)
    {
        return(SrcIsUs(SrcAddress));
    }
#endif
    return(FALSE);

}


//----------------------------------------------------------------------------
BOOLEAN
SrcIsUs(
    IN  ULONG                SrcAddress
    )
/*++

Routine Description:

    This function checks the src address against all adapters'Ip addresses
    address to see if it came from this node.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tDEVICECONTEXT  *pDevContext;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;

    while (pEntry != pHead)
    {
        pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

        if (pDevContext->IpAddress == SrcAddress)
        {
            return(TRUE);
        }
        pEntry = pEntry->Flink;
    }

    return(FALSE);

}
//----------------------------------------------------------------------------
VOID
SwitchToBackup(
    IN  tDEVICECONTEXT  *pDeviceContext
    )
/*++

Routine Description:

    This function switches the primary and backup name server addresses.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    ULONG   SaveAddr;

    //
    // Bug: 30511: Dont switch servers if no backup.
    //
    if (pDeviceContext->lBackupServer == LOOP_BACK) {
        IF_DBG(NBT_DEBUG_REFRESH)
        KdPrint(("Nbt:Will not Switch to backup name server: devctx: %X, refreshtobackup=%X\n",
                pDeviceContext, pDeviceContext->RefreshToBackup));
        return;
    }

    SaveAddr = pDeviceContext->lNameServerAddress;
    pDeviceContext->lNameServerAddress = pDeviceContext->lBackupServer;
    pDeviceContext->lBackupServer = SaveAddr;

    IF_DBG(NBT_DEBUG_REFRESH)
    KdPrint(("Nbt:Switching to backup name server: devctx: %X, refreshtobackup=%X\n",
            pDeviceContext, pDeviceContext->RefreshToBackup));

    // keep track if we are on the backup or not.
    pDeviceContext->RefreshToBackup = ~pDeviceContext->RefreshToBackup;
    pDeviceContext->SwitchedToBackup = ~pDeviceContext->SwitchedToBackup;
}

//----------------------------------------------------------------------------
NTSTATUS
GetNbFlags(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  LONG                lNumBytes,
    OUT USHORT              *pRegType
    )
/*++

Routine Description:

    This function finds the Nbflags field in certain pdu types and returns it.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
    LONG    DnsLabelLength, Offset;

    //
    // Bug#s 125648, 125649
    // The Data is packed in the form:
    // tNameHdr --> TransactId          ==> Offset 0, Length = 2 bytes
    //                  :
    //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
    //          --> tGENERALRR          ==> Offset=13+lNameSize, Length >= 22bytes
    //
    // We need to verify that the NameHdr contains the minimum Buffer space required
    // to hold the entire PDU data
    // 
    if (lNumBytes < (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + NBT_MINIMUM_RR_LENGTH))
    {
        ASSERT (0);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // if the question name is not a pointer to the first name then we
    // must find the end of that name and adjust it so when added to
    // to lNameSize we endup at NB_FLAGS
    //
    if ((pNameHdr->NameRR.NetBiosName[lNameSize+PTR_OFFSET] & PTR_SIGNATURE) != PTR_SIGNATURE)
    {
        // add one to include the null on the end of the string + the NB, IN TTL,
        // and length fields( another 10 bytes NO_PTR_OFFSET) + PTR_OFFSET(4).
        //
        Offset = FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + PTR_OFFSET;
        if (STATUS_SUCCESS != (strnlen ((PUCHAR) &pNameHdr->NameRR.NetBiosName [lNameSize+PTR_OFFSET],
                                        lNumBytes - (Offset+16),    // +16 bytes to end of GeneralRR
                                        &DnsLabelLength)))
        {
            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }
        // add one to include the null on the end of the string
        DnsLabelLength++;
    }
    else
    {
        DnsLabelLength = 2;
    }

    Offset = lNameSize+PTR_OFFSET+DnsLabelLength+NO_PTR_OFFSET;
    *pRegType = ntohs((USHORT) pNameHdr->NameRR.NetBiosName[Offset]);
    return (STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
FindOnPendingList(
    IN  PUCHAR                  pName,
    IN  tNAMEHDR UNALIGNED      *pNameHdr,
    IN  BOOLEAN                 DontCheckTransactionId,
    IN  ULONG                   BytesToCompare,
    OUT tNAMEADDR               **ppNameAddr

    )
/*++

Routine Description:

    This function is called to look for a name query request on the pending
    list.  It searches the list linearly to look for the name.

    The Joint Lock is held when calling this routine.


Arguments:


Return Value:


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tNAMEADDR       *pNameAddr;
    tTIMERQENTRY    *pTimer;

    pHead = pEntry = &NbtConfig.PendingNameQueries;

    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

        //
        // there could be multiple entries with the same name so check the
        // transaction id too
        //
        if (DontCheckTransactionId ||
            ((pTimer = pNameAddr->pTimer) &&
            (((tDGRAM_SEND_TRACKING *)pTimer->Context)->TransactionId == pNameHdr->TransactId))
                             &&
            (CTEMemEqu(pNameAddr->Name,pName,BytesToCompare)))
        {
            *ppNameAddr = pNameAddr;
            return(STATUS_SUCCESS);
        }
    }


    return(STATUS_UNSUCCESSFUL);
}



#if DBG
//----------------------------------------------------------------------------
VOID
PrintHexString(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG                lNumBytes
    )
/*++

Routine Description:

    This function is called to determine whether the name packet we heard on
    the net has the same address as the one in the remote hash table.
    If it has the same address or if it does not have any address, we return
    SUCCESS, else we return NOT_LISTENING.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
    ULONG   i,Count=0;
    PUCHAR  pHdr=(PUCHAR)pNameHdr;

    for (i=0;i<lNumBytes ;i++ )
    {
        KdPrint(("%2.2X ",*pHdr));
        pHdr++;
        if (Count >= 16)
        {
            Count = 0;
            KdPrint(("\n"));
        }
        else
            Count++;
    }
    KdPrint(("\n"));
}
#endif

#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
ChkIfValidRsp(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  tNAMEADDR          *pNameAddr
    )
/*++

Routine Description:

    This function is called to determine whether the name packet we heard on
    the net has the same address as the one in the remote hash table.
    If it has the same address or if it does not have any address, we return
    SUCCESS, else we return NOT_LISTENING.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
         ULONG IpAdd;

        IpAdd = ntohl(
        pNameHdr->NameRR.NetBiosName[lNameSize+IPADDRESS_OFFSET]
             );

        //
        // If the IP address in the packet received is same as the one
        // in the table we return success, else we are not interested
        // in the packet (we want to just drop the packet)
        //
      if (
             (IpAdd == pNameAddr->IpAddress)
         )
      {
            return(STATUS_SUCCESS);
      }
      else
      {
            return(STATUS_REMOTE_NOT_LISTENING);
      }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\namesrv.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Namesrv.c

Abstract:

    This file contains the name service functions called by other parts of
    the NBT code. (QueryNameOnNet, FindName, RegisterName).  It also contains
    the completion routines for the timeouts associated with these functions.

    The pScope values that are passed around from one routine to the next
    point to the scope string for the name.  If there is no scope then the
    pScope ptr points at a single character '\0' - signifying a string of
    zero length.  Therefore the check for scope is "if (*pScope != 0)"

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "namesrv.tmh"

//
// function prototypes for completion routines that are local to this file
//
NTSTATUS
AddToPendingList(
    IN  PCHAR                   pName,
    OUT tNAMEADDR               **ppNameAddr
    );

VOID
MSnodeCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
MSnodeRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
SetWinsDownFlag(
    tDEVICECONTEXT  *pDeviceContext
    );

VOID
ReleaseCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
NextRefresh(
    IN  PVOID     pNameAdd,
    IN  NTSTATUS  status
    );

VOID
GetNextName(
    IN      tNAMEADDR   *pNameAddrIn,
    OUT     tNAMEADDR   **ppNameAddr
    );

NTSTATUS
StartRefresh(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           *pJointLockOldIrq,
    IN  BOOLEAN                 ResetDevice
    );

VOID
NextKeepAlive(
    IN  tDGRAM_SEND_TRACKING     *pTracker,
    IN  NTSTATUS                 statuss,
    IN  ULONG                    Info
    );

VOID
GetNextKeepAlive(
    tDEVICECONTEXT          *pDeviceContext,
    tDEVICECONTEXT          **ppDeviceContextOut,
    tLOWERCONNECTION        *pLowerConnIn,
    tLOWERCONNECTION        **ppLowerConnOut,
    tDGRAM_SEND_TRACKING    *pTracker
    );

VOID
WinsDownTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

BOOL
AppropriateNodeType(
	IN PCHAR pName,
	IN ULONG NodeType
	);

BOOL
IsBrowserName(
	IN PCHAR pName
	);

#if DBG
unsigned char  Buff[256];
unsigned char  Loc;
#endif

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, DelayedSessionKeepAlive)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
AddToPendingList(
    IN  PCHAR                   pName,
    OUT tNAMEADDR               **ppNameAddr
    )
/*++
Routine Description:

    This routine Adds a name query request to the PendingNameQuery list.

Arguments:


Return Value:

    The function value is the status of the operation.


--*/
{
    tNAMEADDR   *pNameAddr;

    pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('R'));
    if (pNameAddr)
    {
        CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));

        CTEMemCopy(pNameAddr->Name,pName,NETBIOS_NAME_SIZE);
        pNameAddr->NameTypeState = STATE_RESOLVING | NBT_UNIQUE;
        pNameAddr->Verify = REMOTE_NAME;
        pNameAddr->TimeOutCount  = NbtConfig.RemoteTimeoutCount;
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET);

        InsertTailList(&NbtConfig.PendingNameQueries, &pNameAddr->Linkage);

        *ppNameAddr = pNameAddr;
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
QueryNameOnNet(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  USHORT                  uType,
    IN  tDGRAM_SEND_TRACKING    *pTrackerClientContext,
    IN  PVOID                   pClientCompletion,
    IN  ULONG                   LocalNodeType,
    IN  tNAMEADDR               *pNameAddrIn,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  CTELockHandle           *pJointLockOldIrq
    )
/*++

Routine Description:

    This routine attempts to resolve a name on the network either by a
    broadcast or by talking to the NS depending on the type of node. (M,P or B)

Arguments:


Return Value:

    The function value is the status of the operation.

Called By: ProxyQueryFromNet() in proxy.c,   NbtConnect() in name.c

--*/

{
    ULONG                Timeout;
    USHORT               Retries;
    NTSTATUS             status;
    PVOID                pCompletionRoutine;
    tDGRAM_SEND_TRACKING *pTrackerQueryNet;
    tNAMEADDR            *pNameAddr;
    LPVOID               pContext2 = NULL;
    CHAR				 cNameType = pName[NETBIOS_NAME_SIZE-1];
    BOOL				 SendFlag = TRUE;
    LONG                 IpAddr = 0;
    ULONG                Flags;

    status = GetTracker(&pTrackerQueryNet, NBT_TRACKER_QUERY_NET);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    if (pTrackerClientContext)  // This will be NULL for Proxy requests
    {
        pTrackerClientContext->pTrackerWorker = pTrackerQueryNet;
    }

    //
    // put the name in the remote cache to keep track of it while it resolves...
    //
    pNameAddr = NULL;
    if (!pNameAddrIn)
    {
        status = AddToPendingList(pName,&pNameAddr);

        if (!NT_SUCCESS(status))
        {
            FreeTracker(pTrackerQueryNet,RELINK_TRACKER);
            return(status);
        }

        // fill in the record with the name and IpAddress
        pNameAddr->NameTypeState = (uType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
    }
    else
    {
        status = STATUS_SUCCESS;
        pNameAddr = pNameAddrIn;
        pNameAddr->RefCount = 1;
    }

    CHECK_PTR(pNameAddr);
    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pNameAddr->NameTypeState |= STATE_RESOLVING;
    pNameAddr->Ttl            = NbtConfig.RemoteHashTtl;
    //
    // put a pointer to the tracker here so that other clients attempting to
    // query the same name at the same time can tack their trackers onto
    // the end of this one. - i.e. This is the tracker for the
    // datagram send, or connect, not the name query.
    //
    pNameAddr->pTracker = pTrackerClientContext;
    pNameAddr->pTimer = NULL;

#ifdef PROXY_NODE
    //
    // If the node type is PROXY, it means that the request is being sent
    // as a result of hearing a name registration or a name query on the net.
    //
    // If the node type is not == PROXY (i.e. it is MSNODE | PROXY,
    // PNODE | PROXY, MSNODE, PNODE, etc, then the request is being sent as
    // a result of a client request
    //
    // Refer: RegOrQueryFromNet in Proxy.c
    //
    //  This field is used in QueryFromNet() to determine whether or not
    //  to revert to Broadcast
    //
#endif
    if(LocalNodeType & PROXY)
    {
        pNameAddr->ProxyReqType = (LocalNodeType & PROXY_REG)? NAMEREQ_PROXY_REGISTRATION: NAMEREQ_PROXY_QUERY;
        LocalNodeType &= (~PROXY_REG);    // Turn it off for safe
    }
    else
    {
        pNameAddr->ProxyReqType = NAMEREQ_REGULAR;
		LocalNodeType = AppropriateNodeType( pName, LocalNodeType );
	}

    // keep a ptr to the Ascii name so that we can remove the name from the
    // hash table later if the query fails.
    CHECK_PTR(pTrackerQueryNet);
    pTrackerQueryNet->pNameAddr = pNameAddr;
    pTrackerQueryNet->SendBuffer.pDgramHdr = NULL;     // set to NULL to catch any erroneous frees.
    pTrackerQueryNet->pDeviceContext = pDeviceContext;
    //
    // set the ref count high enough so that a pdu from the wire cannot
    // free the tracker while UdpSendNsBcast is running - i.e. between starting
    // the timer and actually sending the datagram.
    //
    pTrackerQueryNet->RefCount = 2;
#ifdef MULTIPLE_WINS
    // Set the info for the Extra Name Servers (in addition to Pri & Sec WINs)
    pTrackerQueryNet->NSOthersLeft = pDeviceContext->lNumOtherServers;
    pTrackerQueryNet->NSOthersIndex = pDeviceContext->lLastResponsive;
#endif

    //
    // Set a few values as a precursor to registering the name either by
    // broadcast or with the name server
    //
#ifdef PROXY_NODE
    IF_PROXY(LocalNodeType)
    {
        pCompletionRoutine      = ProxyTimerComplFn;
        pContext2               = pTrackerClientContext;
        pTrackerClientContext   = NULL;

        if  ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                pDeviceContext->WinsIsDown) {
            Retries = pNbtGlobConfig->uNumBcasts;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        } else {
            Retries = (USHORT)pNbtGlobConfig->uNumRetries;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            pTrackerQueryNet->Flags = NBT_NAME_SERVER;
        }
    }
    else
#endif
    if (NbtConfig.UseDnsOnly)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.QueryNameOnNet: Shorting out Query path to do DNS only for %16.16s<%X>\n",
                pName,pName[15]));

        //
        // Short out query over wire
        //
        Retries = 1;
        Timeout = 10;
        SendFlag = FALSE;
        pCompletionRoutine = MSnodeCompletion;

        //
        // For BNODE or MSNODE, the last stage is Broadcast
        //
        if (LocalNodeType & (BNODE | MSNODE))
        {
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        }
        //
        // For PNODE or MNODE, the last stage is Secondary Wins server
        //
        else
        {
            pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
        }

        pTrackerClientContext->ResolutionContextFlags = 0xff;
    }
    else if ((pTrackerClientContext->pFailedIpAddresses) &&
             (pTrackerClientContext->ResolutionContextFlags))
    {
        //
        // We are reattempting the query after the previous attempt failed!
        //
        pTrackerQueryNet->Flags            = pTrackerClientContext->ResolutionContextFlags;
        pTrackerQueryNet->NSOthersIndex    = pTrackerClientContext->NSOthersIndex;
        pTrackerQueryNet->NSOthersLeft     = pTrackerClientContext->NSOthersLeft;

        //
        // Set the Retries to 1 by default so that we can immediately proceed
        // to the next stage in the querying process
        //
        Retries = 1;
        Timeout = 10;
        SendFlag = FALSE;
        pCompletionRoutine = MSnodeCompletion;
    }
    else
    {
        Retries = pNbtGlobConfig->uNumRetries;
        Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
        pCompletionRoutine = MSnodeCompletion;
        pTrackerQueryNet->Flags = NBT_NAME_SERVER;

        // use broadcast if no name server address for MSNODE or Wins down,
        // or it is Bnode,Mnode.
        // for Pnode, just allow it to do the name query on the loop back
        // address
        //
        if ((LocalNodeType & (MNODE | BNODE)) ||
            ((LocalNodeType & MSNODE) &&
            ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
              pDeviceContext->WinsIsDown)))
        {
            Retries = pNbtGlobConfig->uNumBcasts;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        }
        else if ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                 (pDeviceContext->WinsIsDown))
        {
            //
            // short out timeout when no wins server configured -for PNODE
            //
            Retries = 1;
            Timeout = 10;
            pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
        }

        //
        // no sense doing a name query out an adapter with no Ip address
        //
        if (pTrackerClientContext)
        {
            Flags = pTrackerClientContext->Flags;
        }
        else
        {
            Flags = 0;
        }

        if ((pDeviceContext->IpAddress == 0) || (IpAddr = Nbt_inet_addr(pName, Flags)))
        {
            Retries = 1;
            Timeout = 10;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
			SendFlag = FALSE;
            if (LocalNodeType & (PNODE | MNODE))
            {
                pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);


    // do a name query... will always return status pending...
    // the pNameAddr structure cannot get deleted out from under us since
    // only a timeout on the send (3 retries) will remove the name.  Any
    // response from the net will tend to keep the name (change state to Resolved)
    //

    //
    // Bug: 22542 - prevent broadcast of remote adapter status on net view of limited subnet b'cast address.
    // In order to test for subnet broadcasts, we need to match against the subnet masks of all adapters. This
    // is expensive and not done.
    // Just check for the limited bcast.
    //
    if (IpAddr == 0xffffffff)
    {
        KdPrint(("Nbt.QueryNameOnNet: Query on Limited broadcast - failed\n"));
        status = STATUS_BAD_NETWORK_PATH;
    }
    else
    {
        status = UdpSendNSBcast(pNameAddr,
                                pScope,
                                pTrackerQueryNet,
                                pCompletionRoutine,
                                pTrackerClientContext,
                                pClientCompletion,
                                Retries,
                                Timeout,
                                eNAME_QUERY,
                                SendFlag);
        if (!NT_SUCCESS(status)) {
            NbtTrace(NBT_TRACE_NAMESRV, ("UdpSendNSBcast return %!status! for %!NBTNAME!<%02x>",
                status, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));
        }
    }

    // a successful send means, Don't complete the Irp.  Status Pending is
    // returned to ntisol.c to tell that code not to complete the irp. The
    // irp will be completed when this send either times out or a response
    // is heard.  In the event of an error in the send, allow that return
    // code to propagate back and result in completing the irp - i.e. if
    // there isn't enough memory to allocate a buffer or some such thing
    //
    CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    NBT_DEREFERENCE_TRACKER (pTrackerQueryNet, TRUE);

    if (NT_SUCCESS(status))
    {
        LOCATION(0x49);

        // this return must be here to avoid freeing the tracker below.
        status = STATUS_PENDING;
    }
    else
    {
        LOCATION(0x50);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.QueryNameOnNet: Query failed - bad retcode from UdpSendNsBcast = %X\n", status));

        //
        // UdpSendNsBcast should not fail AND start the timer, therefore there
        // is no need to worry about stopping the timer here.
        //
        CHECK_PTR(pNameAddr);
        pNameAddr->pTimer = NULL;
        if (pTrackerClientContext)
        {
            pTrackerClientContext->pTrackerWorker = NULL;
        }

        //
        // This will free the tracker
        //
        NBT_DEREFERENCE_TRACKER (pTrackerQueryNet, TRUE);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
    }

    return(status);
}


#ifdef MULTIPLE_WINS
//----------------------------------------------------------------------------
NTSTATUS
ContinueQueryNameOnNet(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN OUT BOOLEAN              *pfNameReferenced
    )
/*++

Routine Description

    This routine handles re-querying a name on the network.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    CTELockHandle           OldIrq2;
    ULONG                   lNameType;
    NTSTATUS                status;
    tNAMEADDR               *pNameAddr;
    tIPADDRESS              IpAddress;

    ASSERT (!IsDeviceNetbiosless(pDeviceContext));

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    //
    // Name and Tracker should be currently Referenced!
    //
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (NBT_VERIFY_HANDLE2(pTracker->pNameAddr, LOCAL_NAME, REMOTE_NAME));

    //
    // If no one else is referencing the name, then delete it from
    // the hash table.
    //
    pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
    if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&
        (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
        (pTracker->pNameAddr->RefCount == 2))
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
    }
    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
    pTracker->pNameAddr = NULL;
    *pfNameReferenced = FALSE;

    //
    // no sense re-doing a name query if:
    //  the request has been cancelled, or
    //  adapter has no Ip address, or
    //  the name given is itself an IP address!
    //  the previous query had finished querying all the WINS servers
    //
    if ((pTracker->Flags & TRACKER_CANCELLED) ||
        (!pDeviceContext->IpAddress) ||
        (Nbt_inet_addr(pName, SESSION_SETUP_FLAG)) ||
        (pTracker->ResolutionContextFlags == 0xff))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        return (STATUS_BAD_NETWORK_PATH);
    }

    //
    // Save the last Ip address we tried as bad!
    //
    if (!pTracker->pFailedIpAddresses)
    {
        if (!(pTracker->pFailedIpAddresses =
                    NbtAllocMem ((MAX_FAILED_IP_ADDRESSES) * sizeof(tIPADDRESS), NBT_TAG2('04'))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        CTEZeroMemory(pTracker->pFailedIpAddresses,(MAX_FAILED_IP_ADDRESSES) * sizeof(tIPADDRESS));
    }
    pTracker->pFailedIpAddresses[pTracker->LastFailedIpIndex] = pTracker->RemoteIpAddress;
    pTracker->LastFailedIpIndex = (pTracker->LastFailedIpIndex+1) % MAX_FAILED_IP_ADDRESSES;

    // check the Remote table to see if the name has been resolved
    // by someone else
    //
    if ((pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType)) &&
        (IpAddress) &&
        (pNameAddr->NameTypeState & STATE_RESOLVED) &&
        (IpAddress != pTracker->RemoteIpAddress))
    {
        //
        // We have another address to try!
        //
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT);
        *pfNameReferenced = TRUE;
        pNameAddr->TimeOutCount = NbtConfig.RemoteTimeoutCount;
        pTracker->pNameAddr = pNameAddr;

        // set the session state to NBT_CONNECTING
        CHECK_PTR(pTracker->pConnEle);
        SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
        pTracker->pConnEle->BytesRcvd = 0;;
        pTracker->pConnEle->ReceiveIndicated = 0;
        // keep track of the other end's ip address
        pTracker->pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
        SET_STATE_LOWER (pTracker->pConnEle->pLowerConnId, NBT_CONNECTING);
        pTracker->pTrackerWorker = NULL;

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtConnectCommon: Setting Up Session(cached entry!!) to %16.16s <%X>\n",
                pNameAddr->Name,pNameAddr->Name[15]));

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);

        //
        // Now, setup the Tcp connection
        //
        status = TcpSessionStart (pTracker,
                                  IpAddress,
                                  (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                  SessionStartupContinue,
                                  pTracker->DestPort);
    }
    else
    {
        status = QueryNameOnNet (pName,
                                 NbtConfig.pScope,
                                 NBT_UNIQUE,
                                 pTracker,
                                 QueryCompletion,
                                 NodeType & NODE_MASK,
                                 NULL,
                                 pDeviceContext,
                                 &OldIrq2);

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    }

    return (status);
}
#endif


//----------------------------------------------------------------------------
VOID
MSnodeCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name query should be done, and if not, then it calls the
    client's completion routine (in completion2).
    This routine handles the broadcast portion of the name queries (i.e.
    those name queries that go out as broadcasts).

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                 status;
    tDGRAM_SEND_TRACKING     *pTracker;
    CTELockHandle            OldIrq;
    COMPLETIONCLIENT         pClientCompletion;
    ULONG                    Flags;
    tDGRAM_SEND_TRACKING    *pClientTracker;
	ULONG					LocalNodeType;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
	LocalNodeType = AppropriateNodeType( pTracker->pNameAddr->Name, NodeType );

    //
    // check if the client completion routine is still set.  If not then the
    // timer has been cancelled and this routine should just clean up its
    // buffers associated with the tracker.
    //
    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        return;
    }


    //
    // to prevent a client from stopping the timer and deleting the
    // pNameAddr, grab the lock and check if the timer has been stopped
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    ASSERT (NBT_VERIFY_HANDLE (pTracker->pNameAddr, REMOTE_NAME));

    //
    // StopTimer could have been called before we acquired the lock, so
    // check for this
    // Bug#: 229616
    //
    if (!pTimerQEntry->ClientCompletion)
    {
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        return;
    }

    if (pTimerQEntry->Flags & TIMER_RETIMED)
    {
        pTimerQEntry->Flags &= ~TIMER_RETIMED;
        pTimerQEntry->Flags |= TIMER_RESTART;
        //
        // if we are not bound to this card than use a very short timeout
        //
        if (!pTracker->pDeviceContext->IpAddress)
        {
            pTimerQEntry->DeltaTime = 10;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    pClientTracker = (tDGRAM_SEND_TRACKING *)pTimerQEntry->ClientContext;

    //
    // if the tracker has been cancelled, don't do any more queries
    //
    if (pClientTracker->Flags & TRACKER_CANCELLED)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.MSnodeCompletion: tracker flag cancelled\n"));

        //
        // In case the timer has been stopped, we coordinate
        // through the pClientCompletionRoutine Value with StopTimer.
        //
        pClientCompletion = pTimerQEntry->ClientCompletion;

        //
        // remove from the PendingNameQueries list
        //
        RemoveEntryList(&pTracker->pNameAddr->Linkage);
        InitializeListHead(&pTracker->pNameAddr->Linkage);

        // remove the link from the name table to this timer block
        CHECK_PTR(((tNAMEADDR *)pTimerQEntry->pCacheEntry));
        ((tNAMEADDR *)pTimerQEntry->pCacheEntry)->pTimer = NULL;
        //
        // to synch. with the StopTimer routine, Null the client completion
        // routine so it gets called just once.
        //
        CHECK_PTR(pTimerQEntry);
        pTimerQEntry->ClientCompletion = NULL;

        //
        // remove the name from the hash table, since it did not
        // resolve
        //
        CHECK_PTR(pTracker->pNameAddr);
        pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
        pTracker->pNameAddr->pTimer = NULL;

        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        pTracker->pNameAddr = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // there can be a list of trackers Q'd up on this name
        // query, so we must complete all of them!
        //
        CompleteClientReq(pClientCompletion, pClientTracker, STATUS_CANCELLED);

        // return the tracker block to its queue
        LOCATION(0x51);
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);

        return;
    }

    // if number of retries is not zero then continue trying to contact the
    // Name Server.
    //
    if (!(--pTimerQEntry->Retries))
    {

        // set the retry count again
        //
        pTimerQEntry->Retries = NbtConfig.uNumRetries;
        Flags = pTracker->Flags;
        pTracker->Flags &= ~(NBT_NAME_SERVER_BACKUP
#ifdef MULTIPLE_WINS
                                | NBT_NAME_SERVER_OTHERS
#endif
                                | NBT_NAME_SERVER
                                | NBT_BROADCAST);

        if ((Flags & NBT_BROADCAST) && (LocalNodeType & MNODE) &&
            (pTracker->pDeviceContext->lNameServerAddress != LOOP_BACK) &&
            !pTracker->pDeviceContext->WinsIsDown)
        {
            LOCATION(0x44);
                // *** MNODE ONLY ***
            //
            // Can't Resolve through broadcast, so try the name server
            //
            pTracker->Flags |= NBT_NAME_SERVER;

            // set a different timeout for name resolution through WINS
            //
            pTimerQEntry->DeltaTime = NbtConfig.uRetryTimeout;

        }
        else if ((Flags & NBT_NAME_SERVER) && !(LocalNodeType & BNODE))
        {
            LOCATION(0x47);
                // *** NOT BNODE ***
            //
            // Can't reach the name server, so try the backup
            //
            pTracker->Flags |= NBT_NAME_SERVER_BACKUP;
            //
            // short out the timeout if no backup name server
            //
            if ((pTracker->pDeviceContext->lBackupServer == LOOP_BACK) ||
                pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->Retries = 1;
                pTimerQEntry->DeltaTime = 10;

            }

        }
#ifdef MULTIPLE_WINS
        else if ((Flags & NBT_NAME_SERVER_BACKUP) && !(LocalNodeType & BNODE))
        {
            //
            // Main backup and possibly some of the "others" have
            // failed, see if there are any (more) "others" left
            //
            USHORT  Index = pTracker->NSOthersIndex;
            USHORT  NumBackups = pTracker->pDeviceContext->lNumOtherServers;

            pTracker->Flags |= NBT_NAME_SERVER_OTHERS;

            if (Flags & NBT_NAME_SERVER_OTHERS)  // not 1st time here
            {                                   // so, move to next server
                pTracker->NSOthersLeft--;
                if (Index >= NumBackups-1)
                {
                    Index = 0;
                }
                else
                {
                    Index++;
                }
            }

            while ((pTracker->NSOthersLeft > 0) &&
                   (LOOP_BACK == pTracker->pDeviceContext->lOtherServers[Index]))
            {
                pTracker->NSOthersLeft--;
                if (Index >= NumBackups-1)
                {
                    Index = 0;
                }
                else
                {
                    Index++;
                }
            }
            pTracker->NSOthersIndex = Index;

            //
            // short out the timeout if we did not find any "other" name servers
            //
            if (0 == pTracker->NSOthersLeft)        // UdpSendNSBcast will do LOOP_BACK
            {
                pTimerQEntry->Retries = 1;
                pTimerQEntry->DeltaTime = 10;
            }
            else
            {
                pTracker->Flags |= NBT_NAME_SERVER_BACKUP;  // Try next "other" server on timeout
            }
        }
        else if ((Flags & NBT_NAME_SERVER_OTHERS)
#else
        else if ((Flags & NBT_NAME_SERVER_BACKUP)
#endif
             && (LocalNodeType & MSNODE))
        {
            LOCATION(0x46);
                // *** MSNODE ONLY ***
            //
            // Can't reach the name server(s), so try broadcast name queries
            //
            pTracker->Flags |= NBT_BROADCAST;

            // set a different timeout for broadcast name resolution
            //
            pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
            pTimerQEntry->Retries = NbtConfig.uNumBcasts;

            //
            // Set the WinsIsDown Flag and start a timer so we don't
            // try wins again for 15 seconds or so...only if we failed
            // to reach WINS, rather than WINS returning a neg response.
            //
            if (!(Flags & WINS_NEG_RESPONSE))
            {
                SetWinsDownFlag(pTracker->pDeviceContext);
            }
        }
        else
        {
            BOOLEAN    bFound = FALSE;
            LOCATION(0x45);

#ifdef MULTIPLE_WINS
            // Signal termination of WINs server queries
            pTracker->ResolutionContextFlags = NAME_RESOLUTION_DONE;
#endif
            //
            // see if the name is in the lmhosts file, if it ISN'T the
            // proxy making the name query request!!
            //
            status = STATUS_UNSUCCESSFUL;

            //
            // In case the timer has been stopped, we coordinate
            // through the pClientCompletionRoutine Value with StopTimer.
            //
            pClientCompletion = pTimerQEntry->ClientCompletion;
            //
            // the timeout has expired on the broadcast name resolution
            // so call the client
            //

            //
            // remove from the PendingNameQueries list
            //
            RemoveEntryList(&pTracker->pNameAddr->Linkage);
            InitializeListHead(&pTracker->pNameAddr->Linkage);

            // remove the link from the name table to this timer block
            CHECK_PTR(((tNAMEADDR *)pTimerQEntry->pCacheEntry));
            ((tNAMEADDR *)pTimerQEntry->pCacheEntry)->pTimer = NULL;
            //
            // to synch. with the StopTimer routine, Null the client completion
            // routine so it gets called just once.
            //
            CHECK_PTR(pTimerQEntry);
            pTimerQEntry->ClientCompletion = NULL;

            if (((NbtConfig.EnableLmHosts) ||
                 (NbtConfig.ResolveWithDns && !(pTracker->Flags & NO_DNS_RESOLUTION_FLAG))) &&
                (pTracker->pNameAddr->ProxyReqType == NAMEREQ_REGULAR))
            {
                // only do this if the client completion routine has not
                // been run yet.
                //
                if (pClientCompletion)
                {
                    status = LmHostQueueRequest(pTracker,
                                                pTimerQEntry->ClientContext,
                                                pClientCompletion,
                                                pTracker->pDeviceContext);
                }
            }

            CHECK_PTR(pTimerQEntry);
            CHECK_PTR(pTimerQEntry->pCacheEntry);
            if (NT_SUCCESS(status))
            {
                // if it is successfully queued to the Worker thread,
                // then Null the ClientCompletion routine in the timerQ
                // structure, letting
                // the worker thread handle the rest of the name query
                // resolution.  Also null the timer ptr in the
                // nameAddr entry in the name table.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }
            else
            {
                //
                // remove the name from the hash table, since it did not
                // resolve
                //
                CHECK_PTR(pTracker->pNameAddr);
                pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
                pTracker->pNameAddr->pTimer = NULL;

                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
                pTracker->pNameAddr = NULL;

                pClientTracker = (tDGRAM_SEND_TRACKING *)pTimerQEntry->ClientContext;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // there can be a list of trackers Q'd up on this name
                // query, so we must complete all of them!
                //
                CompleteClientReq(pClientCompletion, pClientTracker, STATUS_TIMEOUT);

                // return the tracker block to its queue
                LOCATION(0x51);
                NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
            }

            return;
        }
    }

    LOCATION(0x48);
    NBT_REFERENCE_TRACKER(pTracker);
    pTimerQEntry->Flags |= TIMER_RESTART;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            eNAME_QUERY,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
}

//----------------------------------------------------------------------------
VOID
SetWinsDownFlag(
    tDEVICECONTEXT  *pDeviceContext
    )
/*++

Routine Description:

    This routine sets the WinsIsDown flag if its not already set and
    its not a Bnode.  It starts a 15 second or so timer that un sets the
    flag when it expires.

    This routine must be called while holding the Joint Lock.

Arguments:

    None

Return Value:
    None

--*/
{
    NTSTATUS     status;
    tTIMERQENTRY *pTimer;

    if ((!pDeviceContext->WinsIsDown) && !(NodeType & BNODE))
    {
        status = StartTimer(WinsDownTimeout,
                            NbtConfig.WinsDownTimeout,
                            pDeviceContext,       // context value
                            NULL,
                            NULL,
                            NULL,
                            pDeviceContext,
                            &pTimer,
                            1,          // retries
                            TRUE);

        if (NT_SUCCESS(status))
        {
           pDeviceContext->WinsIsDown = TRUE;
        }
    }
}

//----------------------------------------------------------------------------
VOID
WinsDownTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires.
    It just sets the WinsIsDown boolean to False so that we will try WINS
    again.  In this way we will avoid talking to WINS during this timeout.


Arguments:


Return Value:


--*/
{
    tDEVICECONTEXT  *pDeviceContext = (tDEVICECONTEXT *)pContext;
    CTELockHandle   OldIrq;

    if (!pTimerQEntry)
    {
        return;
    }

    //
    // Hold the Joint Lock while traversing the list of devices
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (IsEntryInList (&pDeviceContext->Linkage, &NbtConfig.DeviceContexts))
    {
        pDeviceContext->WinsIsDown = FALSE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.WinsDownTimeout: WINS DOWN Timed Out - Up again\n"));
}


//----------------------------------------------------------------------------
VOID
CompleteClientReq(
    COMPLETIONCLIENT        pClientCompletion,
    tDGRAM_SEND_TRACKING    *pTracker,
    NTSTATUS                status
    )
/*++

Routine Description:

    This routine is called by completion routines to complete the client
    request.  It may involve completing several queued up requests.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY             pEntry;
    tDGRAM_SEND_TRACKING    *pTrack;
    tDEVICECONTEXT          *pDeviceContext;
    CTELockHandle           OldIrq;
    LIST_ENTRY              ListEntry;

    InitializeListHead (&ListEntry);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // set up a new list head for any queued name queries.
    // since we may need to do a new name query below.
    // The Proxy hits this routine with a Null Tracker, so check for that.
    //
    if (pTracker)
    {
        pDeviceContext = pTracker->pDeviceContext;
        if( !IsListEmpty(&pTracker->TrackerList))
        {
            ListEntry.Flink = pTracker->TrackerList.Flink;
            ListEntry.Flink->Blink = &ListEntry;
            ListEntry.Blink = pTracker->TrackerList.Blink;
            ListEntry.Blink->Flink = &ListEntry;

            InitializeListHead (&pTracker->TrackerList);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    (*pClientCompletion)(pTracker,status);

    while (!IsListEmpty(&ListEntry))
    {
        pEntry = RemoveHeadList(&ListEntry);
        pTrack = CONTAINING_RECORD(pEntry,tDGRAM_SEND_TRACKING,TrackerList);

        //
        // if the name query failed and there is another requested queued on
        // a different device context, re-attempt the name query
        //
        if ((pTrack->pDeviceContext != pDeviceContext) &&
            (status != STATUS_SUCCESS))
        {
            //
            // setup the correct back link since this guy is now the list
            // head. The Flink is ok unless the list is empty now.
            //
            pTrack->TrackerList.Blink = ListEntry.Blink;
            pTrack->TrackerList.Blink->Flink = &pTrack->TrackerList;

            if (pTrack->TrackerList.Flink == &ListEntry)
            {
                pTrack->TrackerList.Flink = &pTrack->TrackerList;
            }

            // do a name query on the next name in the list
            // and then wait for it to complete before processing any more
            // names on the list.
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = QueryNameOnNet (pTrack->pDestName,
                                     NbtConfig.pScope,
                                     NBT_UNIQUE,      //use this as the default
                                     (PVOID)pTrack,
                                     pTrack->CompletionRoutine,
                                     NodeType & NODE_MASK,
                                     NULL,
                                     pTrack->pDeviceContext,
                                     &OldIrq);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            break;
        }
        else
        {
            //
            // get the completion routine for this tracker since it may be
            // different than the tracker tied to the timer block. i.e.
            // pCompletionClient passed to this routine.
            //
            pClientCompletion = pTrack->CompletionRoutine;
            (*pClientCompletion)(pTrack,status);
        }
    }   // while
}

//----------------------------------------------------------------------------
NTSTATUS
NbtRegisterName(
    IN    enum eNbtLocation   Location,
    IN    ULONG               IpAddress,
    IN    PCHAR               pName,
    IN    tNAMEADDR           *pNameAddrIn,
    IN    tCLIENTELE          *pClientEle,
    IN    PVOID               pClientCompletion,
    IN    USHORT              uAddressType,
    IN    tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine registers a name from local or from the network depending
    on the value of Location. (i.e. local node uses this routine as well
    as the proxy code.. although it has only been tested with the local
    node registering names so far - and infact the remote code has been
    removed... since it is not used.  All that remains is to remove
    the Location parameter.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    ULONG       Timeout;
    USHORT      Retries;
    NTSTATUS    status;
    tNAMEADDR   *pNameAddr;
    USHORT      uAddrType;
    tDGRAM_SEND_TRACKING *pSentList= NULL;
    CTELockHandle OldIrq1;
    ULONG         PrevNameTypeState;
	ULONG		LocalNodeType;

	LocalNodeType = AppropriateNodeType( pName, NodeType );

    if ((uAddressType == (USHORT)NBT_UNIQUE ) ||
        (uAddressType == (USHORT)NBT_QUICK_UNIQUE))
    {
        uAddrType = NBT_UNIQUE;
    }
    else
    {
        uAddrType = NBT_GROUP;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    if (IpAddress)
    {
        status = AddToHashTable (pNbtGlobConfig->pLocalHashTbl,
                                 pName,
                                 NbtConfig.pScope,
                                 IpAddress,
                                 uAddrType,
                                 NULL,
                                 &pNameAddr,
                                 pDeviceContext,
                                 0);

        if (status != STATUS_SUCCESS)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_UNSUCCESSFUL);
        }

        pNameAddr->RefreshMask = 0;
    }
    else
    {
        // in this case the name is already in the table, we just need
        // to re-register it
        //
        status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
        if (!NT_SUCCESS(status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(status);
        }

        ASSERT (pNameAddr == pNameAddrIn);
    }

    CHECK_PTR(pNameAddr);
    if ((uAddressType != (USHORT)NBT_UNIQUE ) &&
        (uAddressType != (USHORT)NBT_QUICK_UNIQUE))
    {
        // this means group name so use Bcast Addr - UdpSendDgram changes this
        // value to the Broadcast address of the particular adapter
        // when is sees the 0.  So when we send to a group name that is
        // also registered on this node, it will go out as a broadcast
        // to the subnet as well as to this node.
        pNameAddr->IpAddress = 0;
    }

#ifdef _NETBIOSLESS
    if (IsDeviceNetbiosless(pDeviceContext))       // The Smb Device is not adapter specific
    {
        pNameAddr->NameFlags |= NAME_REGISTERED_ON_SMBDEV;
    }
    else
#endif
    {
        //
        // start with the refreshed bit not set
        //
        pNameAddr->RefreshMask &= ~pDeviceContext->AdapterMask;
        pNameAddr->AdapterMask |= pDeviceContext->AdapterMask; // turn on the adapter bit in the Mask
    }

    pClientEle->pAddress->pNameAddr = pNameAddr;    // save the local name ptr in the address element
    pNameAddr->pAddressEle = pClientEle->pAddress;  // store a back ptr to the address element
    pNameAddr->Ttl = NbtConfig.MinimumTtl; // set to 2 minutes until we hear differently from the Name Server

    PrevNameTypeState = pNameAddr->NameTypeState;
    pNameAddr->NameTypeState &= ~(NAME_TYPE_MASK | NAME_STATE_MASK);
    pNameAddr->NameTypeState |= (uAddrType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
    if ((PrevNameTypeState & NAMETYPE_QUICK) ||
        (uAddressType >= (USHORT)NBT_QUICK_UNIQUE))
    {
       pNameAddr->NameTypeState |= NAMETYPE_QUICK;
    }

    //
    // for "quick" adds, do not register the name on the net!
    // however the name will get registered with the name server and
    // refreshed later....if this is an MS or M or P node.
    //
    if ((pNameAddr->NameTypeState & NAMETYPE_QUICK) ||
        (pName[0] == '*') ||                   // broadcast netbios name does not get claimed on network
        (IpAddress == LOOP_BACK) ||            // If no IP address, pretend the registration succeeded
        (pDeviceContext->IpAddress == 0) ||    // names will be registered when we get an address
        (IsDeviceNetbiosless (pDeviceContext)))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVED;
        status = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(status = GetTracker(&pSentList, NBT_TRACKER_REGISTER_NAME)))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVING;
        InitializeListHead(&pSentList->Linkage);    // there is no list of things sent yet

        // keep a ptr to the name so we can update the state of the name
        // later when the registration completes
        pSentList->pNameAddr = pNameAddr;
        pSentList->pDeviceContext = pDeviceContext;
        pSentList->RefCount = 2; // tracker can be deref'ed by a pdu from wire before UdpSendNsBcast is done
#ifdef MULTIPLE_WINS
        pSentList->NSOthersIndex = 0;       // Initialize for Name Server Queries
        pSentList->NSOthersLeft = 0;
#endif

        // the code must now register the name on the network, depending on the type of node
        Retries = pNbtGlobConfig->uNumBcasts + 1;
        Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
        pSentList->Flags = NBT_BROADCAST;
        if (LocalNodeType & (PNODE | MSNODE))
        {
            // talk to the NS only to register the name
            // ( the +1 does not actually result in a name reg, it
            // is just compatible with the code for M node above since
            // it uses the same completion routine).
            //
            Retries = (USHORT)pNbtGlobConfig->uNumRetries + 1;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            pSentList->Flags = NBT_NAME_SERVER;
            //
            // if there is no Primary WINS server short out the timeout
            // so it completes faster. For Hnode this means to go broadcast.
            //
            if ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                pDeviceContext->WinsIsDown)
            {
                if (LocalNodeType & MSNODE)
                {
                    pSentList->Flags = NBT_BROADCAST;
                    Retries = (USHORT)pNbtGlobConfig->uNumBcasts + 1;
                    Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;

                    IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register
                }
                else // its a Pnode
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.NbtRegisterName: WINS DOWN - shorting out registration\n"));

                    Retries = 1;
                    Timeout = 10;
                    pSentList->Flags = NBT_NAME_SERVER_BACKUP;
                }
            }
        }

        // the name itself has a reference count too.
        // make the count 2, so that pNameAddr won't get released until
        // after NBT_DEREFERENCE_TRACKER is called below, since it writes to
        // pNameAddr. Note that we must increment here rather than set = 2
        // since it could be a multihomed machine doing the register at
        // the same time we are sending a datagram to that name.
        //
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REGISTER);

        pDeviceContext->DeviceRefreshState |= NBT_D_REFRESHING_NOW;

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        // start the timer in this routine.
        status = UdpSendNSBcast(pNameAddr,
                                NbtConfig.pScope,
                                pSentList,
                                (PVOID) MSnodeRegCompletion,
                                pClientEle,
                                pClientCompletion,
                                Retries,
                                Timeout,
                                eNAME_REGISTRATION,
                                TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        CHECK_PTR(pNameAddr);
        NBT_DEREFERENCE_TRACKER (pSentList, TRUE);  // possibly frees the tracker
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REGISTER, TRUE);

        if (NT_SUCCESS(status))
        {
            status = STATUS_PENDING;
        }
        else    // We failed to allocate resources, or the timer failed to start
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtRegisterName: UdpSendNsBcast returned ERROR = %x\n", status));
            NbtTrace(NBT_TRACE_NAMESRV, ("UdpSendNSBcast return %!status! for %!NBTNAME!<%02x>",
                status, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));

            NBT_DEREFERENCE_TRACKER (pSentList, TRUE);
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (!IsDeviceNetbiosless(pDeviceContext))       // The Smb Device is not adapter specific
        {
            pNameAddr->AdapterMask &= (~pDeviceContext->AdapterMask); // turn off the adapter bit in the Mask
        }
        pNameAddr->NameTypeState = PrevNameTypeState;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(status);
}

//----------------------------------------------------------------------------
VOID
MSnodeRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name registration should be done, and if not, then it calls the
    client's completion routine (in completion2).
    It first attempts to register a name via Broadcast, then it attempts
    NameServer name registration.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   Flags;
    CTELockHandle           OldIrq;
    enum eNSTYPE            PduType;
	ULONG					LocalNodeType;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    PduType = eNAME_REGISTRATION;

	LocalNodeType = AppropriateNodeType( pTracker->pNameAddr->Name, NodeType );

    //
    // check if the client completion routine is still set.  If not then the
    // timer has been cancelled and this routine should just clean up its
    // buffers associated with the tracker.
    //
    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        LOCATION(0x55);
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        return;
    }

    //
    // to prevent a client from stopping the timer and deleting the
    // pNameAddr, grab the lock and check if the timer has been stopped
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTimerQEntry->Flags & TIMER_RETIMED)
    {
        pTimerQEntry->Flags &= ~TIMER_RETIMED;
        pTimerQEntry->Flags |= TIMER_RESTART;

        if ((!pTracker->pDeviceContext->IpAddress) ||
            (pTracker->Flags & NBT_NAME_SERVER) &&
            (pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK))
        {
            // when the  address is loop back there is no wins server
            // so shorten the timeout.
            //
            pTimerQEntry->DeltaTime = 10;
        }
        else if ((pTracker->Flags & NBT_NAME_SERVER_BACKUP) &&
                 (pTracker->pDeviceContext->lBackupServer == LOOP_BACK))
        {
            // when the address is loop back there is no wins server
            // so shorten the timeout.
            //
            pTimerQEntry->DeltaTime = 10;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (!pTimerQEntry->ClientCompletion)
    {
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);    // Bug #: 230925
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    // if number of retries is not zero then continue trying to contact the Name Server
    //
    if (--pTimerQEntry->Retries)
    {
        // change the name reg pdu to a name overwrite request for the
        // final broadcast ( turn off Recursion Desired bit)
        //
        if (pTimerQEntry->Retries == 1)
        {
            if (pTracker->Flags & NBT_BROADCAST)
            {
                // do a broadcast name registration... on the last broadcast convert it to
                // a Name OverWrite Request by clearing the "Recursion Desired" bit
                // in the header
                //
                PduType = eNAME_REGISTRATION_OVERWRITE;
            }
            else if (LocalNodeType & (PNODE | MSNODE))
            {
                // we want the Pnode to timeout again, right away and fall
                // through to handle Timed out name registration - i.e. it
                // does not do the name overwrite demand like the B,M,&MS nodes
                //
                pTimerQEntry->Flags |= TIMER_RESTART;
                pTimerQEntry->DeltaTime = 5;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return;
            }
        }
    }
    else
    {
        Flags = pTracker->Flags;
        pTracker->Flags &= ~(NBT_BROADCAST | NBT_NAME_SERVER);
        // set a different timeout for nameserver name registration
        //
        pTimerQEntry->DeltaTime = NbtConfig.uRetryTimeout;
        pTimerQEntry->Retries = NbtConfig.uNumRetries + 1;

        if ((Flags & NBT_BROADCAST) && (LocalNodeType & MNODE))
        {
            //
            // Registered through broadcast, so try the name server now.
            IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);  // not name server register
            pTracker->Flags |= NBT_NAME_SERVER;
            if ((pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                 pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->DeltaTime = 10;
                pTimerQEntry->Retries = 1;
            }
        }
        else if ((Flags & NBT_NAME_SERVER) && !(LocalNodeType & BNODE))
        {
            //
            // Can't reach the name server, so try the backup
            pTracker->Flags |= NBT_NAME_SERVER_BACKUP;
            //
            // short out the timer if no backup server
            //
            if ((pTracker->pDeviceContext->lBackupServer == LOOP_BACK) ||
                 pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->DeltaTime = 10;
                pTimerQEntry->Retries = 1;
            }
        }
        else if ((LocalNodeType & MSNODE) && !(Flags & NBT_BROADCAST))
        {
            if (Flags & NBT_NAME_SERVER_BACKUP)
            {
                // the msnode switches to broadcast if all else fails
                //
                pTracker->Flags |= NBT_BROADCAST;
                IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register

                //
                // change the timeout and retries since broadcast uses a shorter timeout
                //
                pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
                pTimerQEntry->Retries = (USHORT)pNbtGlobConfig->uNumBcasts + 1;
            }
        }
        else
        {
            if (LocalNodeType & BNODE)
            {
                IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register
            }
            //
            // the timeout has expired on the name registration
            // so call the client
            //

            // return the tracker block to its queue
            LOCATION(0x54);

            //
            // start a timer to stop using WINS for a short period of
            // time.  Do this only if we had sent the last registration
            // to a Wins server
            //
            if (!(Flags & NBT_BROADCAST) && pTracker->pDeviceContext->lNameServerAddress != LOOP_BACK)
            {
                SetWinsDownFlag(pTracker->pDeviceContext);
            }

            NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_SUCCESS;
            InterlockedCallCompletion(pTimerQEntry,status);

            return;
        }
    }

    NBT_REFERENCE_TRACKER (pTracker);
    pTimerQEntry->Flags |= TIMER_RESTART;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            PduType,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
}


//----------------------------------------------------------------------------
VOID
RefreshRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles the name Refresh timeouts on packets sent to the Name
    Service. I.e it sends refreshes to the nameserver until a response is
    heard or the number of retries is exceeded.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq;
    COMPLETIONCLIENT        pCompletionClient;


    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pNameAddr->pTimer = NULL;
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // check if the timer has been stopped yet, since stopping the timer
    // nulls the client completion routine. If not null, increment the
    // tracker refcount, so that the last refresh completing cannot
    // free the tracker out from under us.
    //
    if (!(pCompletionClient = pTimerQEntry->ClientCompletion))
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    // if still some count left and not refreshed yet
    // then do another refresh request
    //
    pNameAddr = pTracker->pNameAddr;

    if (--pTimerQEntry->Retries)
    {
        NBT_REFERENCE_TRACKER (pTracker);
        pTimerQEntry->Flags |= TIMER_RESTART;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = UdpSendNSBcast(pTracker->pNameAddr,
                                NbtConfig.pScope,
                                pTracker,
                                NULL,NULL,NULL,
                                0,0,
                                pTracker->AddressType,
                                TRUE);

        // always restart even if the above send fails, since it might succeed
        // later.
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // this calls the completion routine synchronizing with the
        // timer expiry code.
        InterlockedCallCompletion(pTimerQEntry,STATUS_TIMEOUT);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
ReleaseNameOnNet(
    tNAMEADDR           *pNameAddr,
    PCHAR               pScope,
    PVOID               pClientCompletion,
    ULONG               LocalNodeType,
    tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine deletes a name on the network either by a
    broadcast or by talking to the NS depending on the type of node. (M,P or B)

Arguments:


Return Value:

    The function value is the status of the operation.

Called By: ProxyQueryFromNet() in proxy.c,   NbtConnect() in name.c

--*/

{
    ULONG                Timeout;
    USHORT               Retries;
    NTSTATUS             status=STATUS_UNSUCCESSFUL;
    tDGRAM_SEND_TRACKING *pTracker;
    CTELockHandle        OldIrq;
    tTIMERQENTRY        *pTimer;

    status = GetTracker(&pTracker, NBT_TRACKER_RELEASE_NAME);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }
    pTracker->pDeviceContext = pDeviceContext;
    pTracker->pNameAddr = pNameAddr;
    pTracker->SendBuffer.pDgramHdr = NULL;  // set to NULL to catch any erroneous frees.
    pTracker->RefCount = 3;                 // We use the same tracker for the CompletionContext + Request

    // Set a few values as a precursor to releasing the name either by
    // broadcast or with the name server
    //
    LocalNodeType = AppropriateNodeType( pNameAddr->Name, LocalNodeType );
    switch (LocalNodeType & NODE_MASK)
    {
        case MSNODE:
        case MNODE:
        case PNODE:

            pTracker->Flags = NBT_NAME_SERVER;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            Retries = (USHORT)pNbtGlobConfig->uNumRetries;

            break;

        case BNODE:
        default:

            pTracker->Flags = NBT_BROADCAST;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
#ifndef VXD
            Retries = (USHORT)pNbtGlobConfig->uNumBcasts;
#else
            Retries = (USHORT)1;
#endif
    }

    //
    // Release name on the network
    //
    IF_DBG(NBT_DEBUG_NAMESRV)
    KdPrint(("Nbt.ReleaseNameOnNet: Doing Name Release on name %16.16s<%X>\n",
        pNameAddr->Name,pNameAddr->Name[15]));

    status = UdpSendNSBcast(pNameAddr,
                            pScope,
                            pTracker,
                            ReleaseCompletion,
                            pTracker,
                            pClientCompletion,
                            Retries,
                            Timeout,
                            eNAME_RELEASE,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);

    if (!NT_SUCCESS(status))
    {
        NTSTATUS            Locstatus;
        COMPLETIONCLIENT    pCompletion;
        PVOID               pContext;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.ReleaseNameOnNet: UdpSendNSBcast failed - retcode = %X\n", status));

        // Stopping the timer will call ReleaseCompletion which will
        // free the tracker
        //
        pCompletion = NULL;
        CHECK_PTR(pNameAddr);
        if (pTimer = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            Locstatus = StopTimer(pTimer,&pCompletion,&pContext);
        }
        else
        {
            // no timer setup, so just free the tracker
            //
            FreeTracker(pTracker, RELINK_TRACKER);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}
//----------------------------------------------------------------------------
VOID
ReleaseCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name query should be done, and if not, then it calls the
    client's completion routine (in completion2).
    This routine handles both the broadcast portion of the name queries and
    the WINS server directed sends.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
	ULONG					LocalNodeType;
    BOOLEAN                 fRetry;
    CTELockHandle           OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        return;
    }

    //
    // There could be a scenario here where this name is currently being
    // released, but we just got a new client with the same name -- in that
    // case NbtOpenAddress will set the ReleaseMask to 0, so we stop
    // releasing the name on that device if that happens!
    //
    if (!(pTracker->pNameAddr->ReleaseMask))
    {
        LocalNodeType = BNODE;
        pTimerQEntry->Retries = 1;
    }
    else if (IsBrowserName(pTracker->pNameAddr->Name))
	{
		LocalNodeType = BNODE;
	}
	else
	{
		LocalNodeType = NodeType;
	}

    fRetry = TRUE;
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsEntryInList (&pTracker->pDeviceContext->Linkage, &NbtConfig.DeviceContexts))
    {
        // if number of retries is not zero then continue trying
        // to contact the Name Server.
        //
        if (!(--pTimerQEntry->Retries))
        {
            if ((LocalNodeType & MNODE) &&
               (pTracker->Flags & NBT_NAME_SERVER))
            {
                //
                // try broadcast
                //
                pTracker->Flags &= ~NBT_NAME_SERVER;
                pTracker->Flags |= NBT_BROADCAST;

                // set a different timeout for broadcast name resolution
                //
                pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
                pTimerQEntry->Retries = NbtConfig.uNumBcasts;
            }
            else
            {
                fRetry = FALSE;
            }
        }
    }
    else
    {
        fRetry = FALSE;
    }

#ifdef VXD
    if (fRetry)
#else
    if ((fRetry) &&
        (NBT_REFERENCE_DEVICE (pTracker->pDeviceContext, REF_DEV_NAME_REL, TRUE)))
#endif  // VXD
    {
        NBT_REFERENCE_TRACKER (pTracker);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        status = UdpSendNSBcast(pTracker->pNameAddr,
                                NbtConfig.pScope,
                                pTracker,
                                NULL,NULL,NULL,
                                0,0,
                                eNAME_RELEASE,
                                TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
#ifndef VXD
        NBT_DEREFERENCE_DEVICE (pTracker->pDeviceContext, REF_DEV_NAME_REL, TRUE);
#endif  !VXD
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pTimerQEntry->Flags |= TIMER_RESTART;
        return;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // the timeout has expired on the name release
    // or the Device on which we were releasing the name
    // could have gone away, so call the client
    //
    status = InterlockedCallCompletion(pTimerQEntry,STATUS_TIMEOUT);

    // return the tracker block to its queue if we successfully
    // called the completion  routine since someone else might
    // have done a Stop timer at this very moment and freed the
    // tracker already (i.e. the last else clause in this routine).
    //
    if (NT_SUCCESS(status))
    {
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }
}

//----------------------------------------------------------------------------
VOID
NameReleaseDone(
    PVOID               pContext,
    NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when a name is released on the network.  Its
    main, role in life is to free the memory in Context, which is the pAddressEle
    structure.

Arguments:


Return Value:

    The function value is the status of the operation.

Called By Release Completion (above)
--*/

{
    CTELockHandle           OldIrq1;
    tDEVICECONTEXT          *pDeviceContext;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)  pContext;
    tNAMEADDR               *pNameAddr = pTracker->pNameAddr;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    pNameAddr->pTimer = NULL;   // Since we could be starting a new Timer below
    //
    // Before releasing this name, see if this name is registered on
    // any more devices
    // WARNING -- Do not touch the current pTracker->DeviceContext since the
    // the device may have gone away
    //
    while (pDeviceContext = GetAndRefNextDeviceFromNameAddr (pNameAddr))
    {
        //
        // Increment the RefCounts for the structures we need to keep around
        // They will be Dereferenced when the Name Release has completed
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        Status = ReleaseNameOnNet(pNameAddr,
                       NbtConfig.pScope,
                       NameReleaseDone,
                       NodeType,
                       pDeviceContext);

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
#ifndef VXD
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif  // !VXD

        if (NT_SUCCESS(Status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return;
        }

        //
        // We failed to release the name on this Device, so try the
        // next Device!
        //
    }

    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
}


//----------------------------------------------------------------------------
NTSTATUS
StartRefresh(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           *pJointLockOldIrq,
    IN  BOOLEAN                 ResetDevice
    )
/*++

Routine Description:

    This routine handles refreshing a name with the Name server.

    The idea is to set the timeout to T/8 and check for names with the Refresh
    bit cleared - re-registering those names.  At T=4 and T=0, clear all bits
    and refresh all names.  The Inbound code sets the refresh bit when it gets a
    refresh response from the NS.
    The JointLock is held while this routine is called, and the last Irql is
    passed in pJointLockOldIrq

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    BOOLEAN                 NewTracker = FALSE;

    if (!pTracker)
    {
        LOCATION(0x9);

        status = GetTracker(&pTracker, NBT_TRACKER_REFRESH_NAME);
        if (!NT_SUCCESS(status))
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // need to prevent the tracker from being freed by a pdu from
        // the wire before the UdpSendNsBcast is done
        //
        pTracker->RefCount = 1;

        NewTracker = TRUE;
    }

    // set the name to be refreshed in the tracker block
    pTracker->pNameAddr = pNameAddr;

    // this is set true when a new name gets refreshed
    //
    if ((ResetDevice) || (NewTracker))
    {
        PLIST_ENTRY  pEntry, pHead;
        CTEULONGLONG AdapterMask;

        LOCATION(0xb);

        //
        // Identify the Adapters which have not been refreshed
        // Then, get the lowest Adapter number and Refresh on it
        //
        pHead = &NbtConfig.DeviceContexts;
        AdapterMask = pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask);
        AdapterMask = ~(AdapterMask - 1) & AdapterMask;

        ASSERT (AdapterMask);
        while (AdapterMask)
        {
            //
            // Travel to the actual device for this Adapter number
            //
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if (pDeviceContext->AdapterMask == AdapterMask)
                {
                    //
                    // Found a valid device on which this name is registered
                    //
                    break;
                }
                else
                {
                    pDeviceContext = NULL;
                }

                //
                // Go to next device
                //
                pEntry = pEntry->Flink;
            }

            if (pDeviceContext)
            {
                //
                // Found a Device to do a NameRefresh on
                //
                break;
            }

            //
            // This is an error case -- the device for this adapter number
            // does not exist.  Remove it from the Adapter and Refresh masks
            //
            pNameAddr->AdapterMask &= ~AdapterMask;
            pNameAddr->RefreshMask &= ~AdapterMask;

            AdapterMask = pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask);
            AdapterMask = ~(AdapterMask - 1) & AdapterMask;
        }

        if (!pDeviceContext)
        {
            IF_DBG(NBT_DEBUG_REFRESH)
                KdPrint(("Nbt.StartRefresh: Failed to Refresh <%16.16s:%x>!! no valid adapter ****\n",
                    pNameAddr->Name, pNameAddr->Name[15]));
            NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
            return(STATUS_UNSUCCESSFUL);
        }

#ifndef VXD
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint(("Nbt.StartRefresh: Refresh adapter: %lx:%lx, dev.nm: %lx for name: %lx\n",
                AdapterMask, pDeviceContext->BindName.Buffer, pNameAddr));
#endif  // !VXD

        pTracker->pDeviceContext = pDeviceContext;
        //
        // Clear the transaction Id so that CreatePdu will increment
        // it for this new name
        //
        CHECK_PTR(pTracker);
        pTracker->TransactionId = 0;
    }

    pTracker->pDeviceContext->DeviceRefreshState |= NBT_D_REFRESHING_NOW;
    pDeviceContext = pTracker->pDeviceContext;
    pTracker->AddressType = eNAME_REFRESH;
    // Check if we need to refresh to the primary or backup

    if ((pDeviceContext->IpAddress) &&
        (pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK) &&
        (pNameAddr->NameTypeState & STATE_CONFLICT) &&
        (!pNameAddr->ConflictMask))
    {
        //
        // Broadcast the Refresh to ensure no conflict
        //
        pTracker->Flags = NBT_BROADCAST;
        pTracker->AddressType = eNAME_REGISTRATION;
    }
    else if (pTracker->pDeviceContext->RefreshToBackup)
    {
        pTracker->Flags = NBT_NAME_SERVER_BACKUP;
    }
    else
    {
        pTracker->Flags = NBT_NAME_SERVER;
    }

    // this accounts for the dereference done after the call to
    // send the datagram below.
    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);

    status = UdpSendNSBcast(pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            RefreshRegCompletion,
                            pTracker,
                            NextRefresh,
                            NbtConfig.uNumRetries,
                            NbtConfig.uRetryTimeout,
                            pTracker->AddressType,
                            TRUE);

    CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    LOCATION(0x57);

    if (!NT_SUCCESS(status))
    {
        LOCATION(0xe);
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint(("Nbt.StartRefresh: Failed to send Refresh!! status = %X****\n",status));
        //
        // This will free the tracker.  Name refresh will stop until
        // the next refresh timeout and at that point it will attempt
        // to refresh the names again.
        //
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
    }

    return(status);
}

//----------------------------------------------------------------------------
VOID
GetNextName(
    IN      tNAMEADDR   *pNameAddrIn,
    OUT     tNAMEADDR   **ppNameAddr
    )
/*++

Routine Description:

    This routine finds the next name to refresh, including incrementing the
    reference count so that the name cannot be deleted during the refresh.
    The JointLock spin lock is held before calling this routine.

Arguments:


Return Value:

    none

--*/
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    LONG                    i, iIndex;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;


    pHashTable = NbtConfig.pLocalHashTbl;

    for (i= NbtConfig.CurrentHashBucket;i < pHashTable->lNumBuckets ;i++ )
    {
        //
        // use the last name as the current position in the linked list
        // only if that name is still resolved, otherwise start at the
        // begining of the hash list, incase the name got deleted in the
        // mean time.
        //
        if (pNameAddrIn)
        {
            //
            // The Address for this name is Referenced, so it has to be a valid name!
            //
            ASSERT (NBT_VERIFY_HANDLE (pNameAddrIn, LOCAL_NAME));

            if ((pNameAddrIn->NameTypeState & STATE_CONFLICT) &&
                (!pNameAddrIn->ConflictMask) &&
                (!(pNameAddrIn->NameTypeState & REFRESH_FAILED)))
            {
                //
                // If we succeeded in Refreshing on all adapters,
                // remove the name from the Conflict state
                //
                pNameAddrIn->NameTypeState &= (~NAME_STATE_MASK);
                pNameAddrIn->NameTypeState |= STATE_RESOLVED;
            }

            // first hash the name to an index
            // take the lower nibble of the first 2 characters.. mod table size
            iIndex = ((pNameAddrIn->Name[0] & 0x0F) << 4) + (pNameAddrIn->Name[1] & 0x0F);
            iIndex = iIndex % pHashTable->lNumBuckets;

            if (iIndex != NbtConfig.CurrentHashBucket)
            {
                //
                // Someone else is refreshing right now!
                //
                *ppNameAddr = NULL;
                return;
            }

            pHead = &NbtConfig.pLocalHashTbl->Bucket[NbtConfig.CurrentHashBucket];
            pEntry = pNameAddrIn->Linkage.Flink;

            pNameAddrIn = NULL;
        }
        else
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
        }

        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            // don't refresh scope names or names in conflict or that are the
            // broadcast name "*    " or quick unique names - i.e. the permanent
            // name is nametype quick
            //
            if ((pNameAddr->Name[0] != '*') &&
                (!(pNameAddr->NameTypeState & NAMETYPE_QUICK)) &&
                (pNameAddr->pAddressEle) &&                     // Not currently being closed down!
                ((pNameAddr->NameTypeState & STATE_RESOLVED) ||
                 ((pNameAddr->NameTypeState & STATE_CONFLICT) && (!pNameAddr->ConflictMask))))
            {
                // check if the name has been refreshed yet
                //
                // Refresh this name only if any of the non-refreshed bits in
                // the RefreshMask match any of the bits for the adapters this
                // device is registered on!
                pNameAddr->NameTypeState &= (~REFRESH_FAILED);  // Will be set on Failure
                if (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask)
                {
                    // increment the reference count so that this name cannot
                    // disappear while it is being refreshed and mess up the linked list
                    NBT_REFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);

                    NbtConfig.CurrentHashBucket = (USHORT)i;

                    *ppNameAddr = pNameAddr;
                    return;
                }
                else if (pNameAddr->NameTypeState & STATE_CONFLICT)
                {
                    pNameAddr->NameTypeState &= (~NAME_STATE_MASK);
                    pNameAddr->NameTypeState |= STATE_RESOLVED;
                }
            }
        }
    }

    *ppNameAddr = NULL;
}


//----------------------------------------------------------------------------
VOID
NextRefresh(
    IN  PVOID     pContext,
    IN  NTSTATUS  CompletionStatus
    )
/*++

Routine Description:

    This routine queues the work to an Executive worker thread to handle
    refreshing the next name.

Arguments:


Return Value:

    none

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *) pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pTracker->pNameAddr->pTimer = NULL;     // Set the timer to NULL!

    if (!(NBT_VERIFY_HANDLE (pTracker->pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
    {
        //
        // Since the Device is going away, let's assume we succeeded
        //
        CompletionStatus = STATUS_SUCCESS;
        pTracker->pDeviceContext = NULL;
    }

    if (!NT_SUCCESS(CTEQueueForNonDispProcessing (DelayedNextRefresh,
                                                  pTracker,
                                                  ULongToPtr(CompletionStatus), // Sundown: zero-extended.
                                                  NULL,
                                                  pTracker->pDeviceContext,
                                                  TRUE)))
    {
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint (("Nbt.NextRefresh: Failed to Enqueu DelayedNextRefresh!!!\n"));

        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
VOID
DelayedNextRefresh(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused1,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    This routine handles sending subsequent refreshes to the name server.
    This is the "Client Completion" routine of the Timer started above.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tNAMEADDR               *pNameAddrNext;
    NTSTATUS                status;
    PLIST_ENTRY             pEntry, pHead;
    CTEULONGLONG            AdapterMask;
    BOOLEAN                 fAbleToReachWins = FALSE;
    BOOLEAN                 fResetDevice = FALSE;
    NTSTATUS                CompletionStatus;

    CompletionStatus = (NTSTATUS) (ULONG_PTR) pClientContext;
    pNameAddr = pTracker->pNameAddr;
    ASSERT(pNameAddr);

    //
    // grab the resource so that a name refresh response cannot start running this
    // code in a different thread before this thread has exited this routine,
    // otherwise the tracker can get dereferenced twice and blown away.
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    LOCATION(0x1);
    // turn on the bit corresponding to this adapter, since the name refresh
    // completed ok
    //
    if (CompletionStatus == STATUS_SUCCESS)
    {
        if (pDeviceContext)
        {
            //
            // turn on the bit corresponding to this adapter, since the name refresh
            // completed ok
            //
            pNameAddr->RefreshMask |= pDeviceContext->AdapterMask;
        }
        fAbleToReachWins = TRUE;
    }
    else if (CompletionStatus == STATUS_TIMEOUT)
    {
        if (pNameAddr->NameTypeState & STATE_CONFLICT)
        {
            if ((!pDeviceContext->IpAddress) ||
                (pDeviceContext->lNameServerAddress == LOOP_BACK))
            {
                //
                // Let us assume we succeeded
                fAbleToReachWins = TRUE;
            }
            else
            {
                pNameAddr->NameTypeState |= REFRESH_FAILED;
            }
        }
    }
    else    // CompletionStatus != STATUS_TIMEOUT
    {
        LOCATION(0x3);
        // if the timer times out and we did not get to the name server, then
        // that is not an error.  However, any other bad status
        // must be a negative response to a name refresh so mark the name
        // in conflict
        //
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_CONFLICT;
        pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
        fAbleToReachWins = TRUE;
    }

    // for the multihomed case a failure to reach wins out one of the adapters
    // is not necessarily a failure to reach any WINS.  Since this flag
    // is just an optimization to prevent clients from continually trying to
    // register all of their names if WINS is unreachable, we can ignore the
    // optimization for the multihomed case.  The few nodes that are
    // multihomed will not create that much traffic compared to possibly
    // thousands that are singly homed clients.
    if (NbtConfig.MultiHomed)
    {
        fAbleToReachWins = TRUE;
    }

    LOCATION(0x8);
    //
    // still more adapters to check ...
    //
    // go to the next device context and refresh the name there
    // using the same tracker.
    // look for a device context with a valid IP address since there is
    // no sense in refreshing names out unconnected RAS links.
    //

    if (pDeviceContext)
    {
        //
        // check if any higher bits are set inthe AdapterMask
        //
        AdapterMask = pTracker->pDeviceContext->AdapterMask;
        AdapterMask = AdapterMask << 1;
        pDeviceContext = NULL;
    }
    else
    {
        //
        // The Device we were Refreshing on has gone away, but we don't
        // know which one it was, so ReRefresh!
        //
        AdapterMask = 1;
    }

    //
    // If we have finished refreshing on all devices for this name, get the next name
    //
    if ( (!(AdapterMask) ||
         (AdapterMask > (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask))) )
    {
        // *** clean up the previously refreshed name ***

        // if we failed to reach WINS on the last refresh, stop refreshing
        // until the next time interval. This cuts down on network traffic.
        //
        if (fAbleToReachWins)
        {
            GetNextName(pNameAddr,&pNameAddrNext);
            AdapterMask = 1;
            fResetDevice = TRUE;
        }
        else
        {
            pNameAddrNext = NULL;
        }

        //
        // Dereference the previous address after calling GetNextName
        // since it cause the Name to get free'ed
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        pNameAddr = pNameAddrNext;
    }

    pHead = &NbtConfig.DeviceContexts;
    while (pNameAddr)
    {
        //
        // Get mask of Adapters left to Refresh on; after that, get the lowest adapter number
        //
        AdapterMask = ~(AdapterMask-1) & (pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask));
        AdapterMask &= ~(AdapterMask - 1);

        //
        // Travel to the actual device for this Adapter number
        //
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            //
            // Check if this Device matches the AdapterMask and also has
            // a valid ip address and name server address
            //
            if (pDeviceContext->AdapterMask == AdapterMask)
            {
                if ((pDeviceContext->IpAddress != 0) &&
                    ((pDeviceContext->lNameServerAddress != LOOP_BACK)) ||
                     ((pNameAddr->NameTypeState & STATE_CONFLICT) && (!pNameAddr->ConflictMask)))
                {
                    //
                    // Found a valid device on which this name is registered
                    //
                    IF_DBG(NBT_DEBUG_REFRESH)
                        KdPrint(("Nbt.DelayedNextRefresh: Adapter <%lx:%lx>, Name <%15.15s:%X>\n",
                            AdapterMask,pNameAddr->Name,pNameAddr->Name[15]));

                    pTracker->pDeviceContext = pDeviceContext;

                    // remove the previous timer from the AddressEle since StartRefresh
                    // will start a new timer - safety measure and probably not required!
                    //
                    CHECK_PTR(pNameAddr);
                    pNameAddr->pTimer = NULL;

                    // this call sends out a name registration PDU on a different adapter
                    // to (potentially) a different name server.  The Name service PDU
                    // is the same as the last one though...no need to create a new one.
                    //
                    status = StartRefresh(pNameAddr, pTracker, &OldIrq, fResetDevice);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
                        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
                        KdPrint(("Nbt.DelayedNextRefresh: ERROR -- Refreshing <%-15.15s:%x>, status=<%X>\n",
                            pNameAddr->Name,pNameAddr->Name[15], status));
                    }

                    goto ExitRoutine;
                }

                //
                // This Device from AdapterMask did not have a valid IP or WINS address
                //
                break;
            }
            else
            {
                pDeviceContext = NULL;
            }

            //
            // Go to next device
            //
            pEntry = pEntry->Flink;
        }

        //
        // If we reached here with a non-NULL pDeviceContext, then it means that
        // the Device did not have a valid IP address or Name Server address
        // otherwise ...
        //
        if (!pDeviceContext)
        {
            //
            //
            // Error case:
            // It could be that an adapter was removed while we were looping
            //
            KdPrint (("Nbt.DelayedNextRefresh:  AdapterMask <%lx:%lx> no longer exists!\n", AdapterMask));
            pNameAddr->AdapterMask &= ~AdapterMask;
            pNameAddr->RefreshMask &= ~AdapterMask;
        }

        //
        // Go to the next adapter
        //
        AdapterMask = AdapterMask << 1;


        //
        // Check if this name has any more adapters on which it can be refreshed
        //
        if ( (!(AdapterMask) ||
             (AdapterMask > (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask))) )
        {
            // *** clean up the previously refreshed name ***

            if (fAbleToReachWins)
            {
                //
                // No more adapters on which to Refresh for the previous name
                // Get the next name in the hash table
                //
                GetNextName(pNameAddr,&pNameAddrNext);
                AdapterMask = 1;
                fResetDevice = TRUE;
                pHead = &NbtConfig.DeviceContexts;
            }
            else
            {
                pNameAddrNext = NULL;
            }

            //
            // Dereference the previous address after calling GetNextName
            // since it cause the Name to get free'ed
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            pNameAddr = pNameAddrNext;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (!pNameAddr)
    {
        LOCATION(0x7);
        // we finally delete the tracker here after using it to refresh
        // all of the names.  It is not deleted in the RefreshCompletion
        // routine anymore!
        //
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    }


ExitRoutine:

    CTEExReleaseResource(&NbtConfig.Resource);
}


//----------------------------------------------------------------------------
VOID
WakeupRefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    if (NbtConfig.pWakeupRefreshTimer)
    {
        NbtConfig.pWakeupRefreshTimer = NULL;
        ReRegisterLocalNames (NULL, FALSE);
    }
}

//----------------------------------------------------------------------------
VOID
RefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles is the timeout handler for name refreshes to
    WINS.  It just queues the request to the Executive worker thread so that
    the work can be done at non-dispatch level. If there is currently a
    refresh going on, then the routine simply restarts the timer and
    exits.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle   OldIrq;

    if (!pTimerQEntry)
    {
        NbtConfig.pRefreshTimer = NULL;
        return;
    }

    CHECK_PTR(pTimerQEntry);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (NodeType & BNODE)
    {
        pTimerQEntry->Flags = 0;    // Do not restart the timer
        NbtConfig.pRefreshTimer = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (!(NbtConfig.GlobalRefreshState & NBT_G_REFRESHING_NOW))
    {
        // this is a global flag that prevents a second refresh
        // from starting when one is currently going on.
        //
        
        if (NT_SUCCESS(CTEQueueForNonDispProcessing (DelayedRefreshBegin,
                                                     NULL, NULL, NULL, NULL, TRUE)))
        {
            NbtConfig.GlobalRefreshState |= NBT_G_REFRESHING_NOW;
        }
    } // doing refresh now

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // set any new timeout value and restart the timer
    //
    pTimerQEntry->DeltaTime = NbtConfig.MinimumTtl/NbtConfig.RefreshDivisor;
    pTimerQEntry->Flags |= TIMER_RESTART;
}

//----------------------------------------------------------------------------
VOID
DelayedRefreshBegin(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pUnused4
    )
/*++

Routine Description:

    This routine handles starting up sending name refreshes to the name server.

    The idea is to set the timeout to T/8 and check for names with the Refresh
    bit cleared - re-registering those names.  At T=4 and T=0, clear all bits
    and refresh all names.  The Inbound code sets the refresh bit when it gets a
    refresh response from the NS.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    NTSTATUS                status;
    tHASHTABLE              *pHashTable;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tDEVICECONTEXT          *pDeviceContext;
    CTEULONGLONG            Adapter;
    BOOLEAN                 fTimeToSwitch = FALSE;
    BOOLEAN                 fTimeToRefresh = FALSE;
    USHORT                  TimeoutsBeforeSwitching;
    ULONG                   TimeoutsBeforeNextRefresh;
    CTESystemTime           CurrentTime;
    ULONG                   TimeoutDelta;
    USHORT                  NumTimeoutIntervals;

    //
    // If the refresh timeout has been set to the maximum value then do
    // not send any refreshes to the name server
    //
    if (NbtConfig.MinimumTtl == NBT_MAXIMUM_TTL)
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        return;
    }

    LOCATION(0x12);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    CTEQuerySystemTime (CurrentTime);
    ExSystemTimeToLocalTime (&CurrentTime, &CurrentTime);
    TimeoutDelta = NbtConfig.MinimumTtl/NbtConfig.RefreshDivisor;
    NumTimeoutIntervals = (USHORT)
          (((CurrentTime.QuadPart - NbtConfig.LastRefreshTime.QuadPart) + ((LONGLONG)TimeoutDelta*10000/2))
                        / ((LONGLONG)TimeoutDelta*10000)); // in 100 nano second units
    NbtConfig.LastRefreshTime = CurrentTime;

    //
    // NumTimeoutIntervals > 1 if we were sleeping
    //
    if (NumTimeoutIntervals > 1)
    {
        //
        // If we crossed Ttl/2 or Ttl while sleeping, refresh all names
        //
        TimeoutsBeforeNextRefresh = (NbtConfig.RefreshDivisor/2)
                                    - (NbtConfig.sTimeoutCount % (NbtConfig.RefreshDivisor/2));
        NbtConfig.sTimeoutCount += NumTimeoutIntervals;      // Up the timeout count
        //
        // Refresh all of the names if
        // a) we crossed Ttl/2 during sleep, or
        // b) we are within Ttl/4 of the Ttl
        //
        if ((NumTimeoutIntervals > TimeoutsBeforeNextRefresh) ||
            ((NbtConfig.RefreshDivisor-NbtConfig.sTimeoutCount) < (NbtConfig.RefreshDivisor/4)))
        {
            fTimeToRefresh = TRUE;
        }
    }
    else
    {
        NbtConfig.sTimeoutCount++;      // Up the timeout count for this cycle!

        //
        // If it has been over an hour (DEFAULT_SWITCH_TTL) since we last switched,
        // then set fTimeToSwitch = TRUE
        //
        TimeoutsBeforeSwitching =(USHORT)((DEFAULT_SWITCH_TTL*NbtConfig.RefreshDivisor)/NbtConfig.MinimumTtl);
        fTimeToSwitch = (NbtConfig.sTimeoutCount - NbtConfig.LastSwitchTimeoutCount)
                        >= TimeoutsBeforeSwitching;
        fTimeToRefresh = (NbtConfig.sTimeoutCount >= (NbtConfig.RefreshDivisor/2));

        if (fTimeToSwitch)
        {
            NbtConfig.LastSwitchTimeoutCount = NbtConfig.sTimeoutCount;
        }
    }

    NbtConfig.sTimeoutCount %= NbtConfig.RefreshDivisor;

    //
    // Reset the clock if we are Refreshing everything
    //
    if (fTimeToRefresh)
    {
        NbtConfig.sTimeoutCount = 0;
        fTimeToSwitch = FALSE;
    }

    //
    // Set some special-case information
    //
    if (0 == NbtConfig.sTimeoutCount)
    {
        NbtConfig.LastSwitchTimeoutCount = 0;
    }

    IF_DBG(NBT_DEBUG_REFRESH)
        KdPrint(("Nbt.DelayedRefreshBegin: fTimeToRefresh=<%d>,fTimeToSwitch=<%d>, MinTtl=<%d>, RefDiv=<%d>\n"
                "TimeoutCount: %d, LastSwTimeoutCount: %d\n",
            fTimeToRefresh, fTimeToSwitch, NbtConfig.MinimumTtl, NbtConfig.RefreshDivisor,
                NbtConfig.sTimeoutCount, NbtConfig.LastSwitchTimeoutCount));

    //
    // go through the local table clearing the REFRESHED bit and sending
    // name refreshes to the name server
    //
    pHashTable = NbtConfig.pLocalHashTbl;
    if (fTimeToRefresh || fTimeToSwitch)
    {
        CTEULONGLONG   ToRefreshMask = 0;
        PLIST_ENTRY pHead1,pEntry1;

        for (i=0 ;i < pHashTable->lNumBuckets ;i++ )
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;

            //
            // Go through each name in each bucket of the hashtable
            //
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                CHECK_PTR(pNameAddr);

                // don't refresh scope names or names in conflict or that are the
                // broadcast name "*    ", or Quick added names.(since these are
                // not registered on the network)
                //
                if (!(pNameAddr->NameTypeState & STATE_RESOLVED) ||
                    (pNameAddr->Name[0] == '*') ||
                    (IsBrowserName(pNameAddr->Name)) ||
                    (pNameAddr->NameTypeState & NAMETYPE_QUICK))
                {
                    pEntry = pEntry->Flink;
                    continue;
                }


                if (fTimeToRefresh)
                {
                    //
                    // Clear the refreshed bits so all names get refreshed if we are
                    // at interval 0 or interval NbtConfig.RefreshDivisor/2
                    //
                    pNameAddr->RefreshMask = 0;
                }

                //
                // Set the ToRefreshMask to include any Devices not Refreshed previously
                //
                ToRefreshMask |= (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask);

                pEntry = pEntry->Flink;         // next hash table entry
            }
        }       // for ( .. pHashTable .. )

        //
        // Go through each adapter checking if a name needs to be Refreshed on this adapter.
        //
        pHead1 = &NbtConfig.DeviceContexts;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry1,tDEVICECONTEXT,Linkage);
            pEntry1 = pEntry1->Flink;

            //
            // If we are currently switched to the backup, then try
            // to switch back to the primary
            //
            if (pDeviceContext->SwitchedToBackup)
            {
                SwitchToBackup(pDeviceContext);
                pDeviceContext->RefreshToBackup = FALSE;
            }
            else if (fTimeToRefresh)     // If this is a fresh Refresh cycle, restart from the primary
            {
                pDeviceContext->RefreshToBackup = FALSE;
            }
            else if ((pDeviceContext->AdapterMask & ToRefreshMask) && // do we need to switch on this device
                     (pDeviceContext->lBackupServer != LOOP_BACK))
            {
                pDeviceContext->RefreshToBackup = ~pDeviceContext->RefreshToBackup;
            }
        }
    }

    // always start at the first name in the hash table.  As each name gets
    // refreshed NextRefresh will be hit to get the next name etc..
    //
    NbtConfig.CurrentHashBucket = 0;
    GetNextName(NULL,&pNameAddr);   // get the next(first) name in the hash table

    status = STATUS_UNSUCCESSFUL;
    if (pNameAddr)
    {
        LOCATION(0x13);
        status = StartRefresh(pNameAddr, NULL, &OldIrq, TRUE);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // If this routine fails then the address element increment done in
        // GetNextName has to be undone here
        //
        if (!NT_SUCCESS(status))
        {
            NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
            NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
        }
    }
    else
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
RemoteHashTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles deleting names in the Remote Hash table that are
    old.  The basic alorithm scans the table looking at the Timed_out bit.
    If it is set then the name is deleted, otherwise the bit is set.  This
    means the names can live as long as 2*Timeout or as little as Timeout.
    So set the Timeout to 6 Minutes and names live 9 minutes +- 3 minutes.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pDeviceHead;
    PLIST_ENTRY             pDeviceEntry;
    tDEVICECONTEXT          *pDeviceContext;
    tLOWERCONNECTION        *pLowerConn;
    ULONG                   TimeoutCount;

    if (!pTimerQEntry)
    {
        //
        // The Timer is being cancelled
        //
        NbtConfig.pRemoteHashTimer = NULL;
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Update the Remote cache timestamp
    //
    NbtConfig.CacheTimeStamp++;

    //
    // go through the remote table deleting names that have timeout bits
    // set and setting the bits for names that have the bit clear
    //
    pHashTable = NbtConfig.pRemoteHashTbl;
    for (i=0;i < pHashTable->lNumBuckets ;i++ )
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // do not delete scope entries, and do not delete names that
            // that are still resolving, and do not delete names that are
            // being used by someone (refcount > 1)
            //
            if ((pNameAddr->NameTypeState & (STATE_RESOLVED | STATE_RELEASED)) &&
                (pNameAddr->RefCount <= 1))
            {
                if ((pNameAddr->TimeOutCount == 0) ||
                    ((pContext == NbtConfig.pRemoteHashTbl) &&
                     !(pNameAddr->NameTypeState & NAMETYPE_SCOPE)))
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
                else if (!(pNameAddr->NameTypeState & NAMETYPE_SCOPE))
                {
                    pNameAddr->TimeOutCount--;
                }
            }
        }
    }

    // *** Inbound Connections Cleanup *** //

    //
    // Go through each Device and cleanup any lingering connections waiting in the Inbound state
    // Start with the SmbDevice
    //
    pDeviceHead = pDeviceEntry = &NbtConfig.DeviceContexts;
    if (pNbtSmbDevice)
    {
        pDeviceContext = pNbtSmbDevice;
    }
    else if ((pDeviceEntry = pDeviceEntry->Flink) != pDeviceHead)
    {
        pDeviceContext = CONTAINING_RECORD(pDeviceEntry,tDEVICECONTEXT,Linkage);
    }
    else
    {
        pDeviceContext = NULL;
    }

    while (pDeviceContext)
    {
        CTESpinLock(pDeviceContext,OldIrq1);

        //
        // Set the timeout based on the Resource usage!
        //
        if (pDeviceContext->NumWaitingForInbound > NbtConfig.MaxBackLog)
        {
            TimeoutCount = MIN_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Minimum Timeout value
        }
        else if (pDeviceContext->NumWaitingForInbound > NbtConfig.MaxBackLog/2)
        {
            TimeoutCount = MED_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Medium Timeout value
        }
        else
        {
            TimeoutCount = MAX_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Maximum Timeout Value
        }

        //
        // Now go through the list of Inbound connections and see if
        // we need to cleanup any that have lingering around for too long!
        //
        pHead = &pDeviceContext->WaitingForInbound;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
            pEntry = pEntry->Flink;

            pLowerConn->TimeUnitsInLastState++;

            if (pLowerConn->TimeUnitsInLastState > TimeoutCount)
            {
                RemoveEntryList (&pLowerConn->Linkage);
                InitializeListHead (&pLowerConn->Linkage);
                SET_STATE_LOWER(pLowerConn, NBT_IDLE);  // so that Inbound doesn't start processing it!
                if (pLowerConn->SpecialAlloc)
                {
                    InterlockedDecrement(&pLowerConn->pDeviceContext->NumSpecialLowerConn);
                }
                else
                {
                    CTEQueueForNonDispProcessing (DelayedAllocLowerConn,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  pLowerConn->pDeviceContext,
                                                  TRUE);
                }

                ASSERT (pLowerConn->RefCount == 2);
                NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, TRUE); // RefCount: 2 -> 1
                NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE); // Close all the Tcp handles
                InterlockedDecrement (&pDeviceContext->NumWaitingForInbound);
            }
        }       // pDeviceContext->WaitingForInbound List

        CTESpinFree(pDeviceContext,OldIrq1);

        if ((pDeviceEntry = pDeviceEntry->Flink) != pDeviceHead)
        {
            pDeviceContext = CONTAINING_RECORD(pDeviceEntry,tDEVICECONTEXT,Linkage);
        }
        else
        {
            pDeviceContext = NULL;
        }
    }           // NbtConfig.DeviceContexts List

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // restart the timer
    //
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}
//----------------------------------------------------------------------------
VOID
NextKeepAlive(
    IN  tDGRAM_SEND_TRACKING     *pTracker,
    IN  NTSTATUS                 status,
    IN  ULONG                    Info
    )
/*++

Routine Description:

    This routine handles sending subsequent KeepAlives for sessions.
    This is the "Client Completion" routine of the TdiSend that sends the
    keep alive on the session.

Arguments:


Return Value:

    none

--*/
{
    tLOWERCONNECTION        *pLowerConnLast;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

    PUSH_LOCATION(0x92);
    pDeviceContext = pTracker->pDeviceContext;
    pLowerConnLast = (tLOWERCONNECTION *)pTracker->pClientEle;

    // get the next session to send a keep alive on, if there is one, otherwise
    // free the session header block.
    //
    GetNextKeepAlive (pDeviceContext, &pDeviceContext, pLowerConnLast, &pLowerConn, pTracker);

    NBT_DEREFERENCE_LOWERCONN (pLowerConnLast, REF_LOWC_KEEP_ALIVE, FALSE);
    status = STATUS_UNSUCCESSFUL;

    if (pLowerConn)
    {
        pTracker->pDeviceContext = pDeviceContext;
        pTracker->pClientEle = (tCLIENTELE *)pLowerConn;

        ASSERT((pTracker->SendBuffer.HdrLength + pTracker->SendBuffer.Length) == 4);
        PUSH_LOCATION(0x91);
#ifndef VXD
        // this may wind up the stack if the completion occurs synchronously,
        // because the completion routine is this routine, so call a routine
        // that sets up a dpc to to the send, which will not run until this
        // procedure returns and we get out of raised irql.
        //
        status = NTSendSession (pTracker, pLowerConn, NextKeepAlive);
#else
        (void) TcpSendSession (pTracker, pLowerConn, NextKeepAlive);
        status = STATUS_SUCCESS;
#endif
    }

    if (!NT_SUCCESS(status))
    {
        if (pLowerConn)
        {
            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_KEEP_ALIVE, FALSE);
        }

        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
    }
}


//----------------------------------------------------------------------------
VOID
GetNextKeepAlive(
    tDEVICECONTEXT          *pDeviceContext,
    tDEVICECONTEXT          **ppDeviceContextOut,
    tLOWERCONNECTION        *pLowerConnIn,
    tLOWERCONNECTION        **ppLowerConnOut,
    tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description:

    This routine handles sending session keep Alives to the other end of a
    connection about once a minute or so.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tLOWERCONNECTION        *pLowerConn;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHeadDevice;
    PLIST_ENTRY             pEntryDevice;
    NTSTATUS                status;
    tDEVICECONTEXT          *pEntryDeviceContext;

    *ppLowerConnOut = NULL;

    //
    // loop through all the adapter cards looking at all connections
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    //
    // Verify that the Device passed in is a valid device,
    // otherwise either pick the next Device, or fail
    //
    status = STATUS_UNSUCCESSFUL;
    pEntryDevice = pHeadDevice = &NbtConfig.DeviceContexts;
    while ((pEntryDevice = pEntryDevice->Flink) != pHeadDevice)
    {
        pEntryDeviceContext = CONTAINING_RECORD(pEntryDevice,tDEVICECONTEXT,Linkage);
        if ((pEntryDeviceContext == pDeviceContext) ||
            (pEntryDeviceContext->AdapterNumber > pTracker->RCount))
        {
            if (pEntryDeviceContext != pDeviceContext)
            {
                pLowerConnIn = NULL;
            }
            pDeviceContext = pEntryDeviceContext;
            status = STATUS_SUCCESS;
            break;
        }
    }

    if (!NT_SUCCESS(status))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }

    pEntryDevice = &pDeviceContext->Linkage;
    while (pEntryDevice != pHeadDevice)
    {
        pDeviceContext = CONTAINING_RECORD(pEntryDevice,tDEVICECONTEXT,Linkage);
        pEntryDevice = pEntryDevice->Flink;

        // grab the device context spin lock so that the lower connection
        // element does not get removed from the Q while we are checking the
        // connection state
        //
        CTESpinLock(pDeviceContext,OldIrq);
        pHead = &pDeviceContext->LowerConnection;
        //
        // get the next lower connection after this one one the list, but
        // be sure this connection is still on the active list by checking
        // the state.
        //
        // If this connection has been cleaned up in OutOfRsrcKill, then dont trust the linkages.
        //
        if (pLowerConnIn &&
            !pLowerConnIn->OutOfRsrcFlag &&
            ((pLowerConnIn->State == NBT_SESSION_UP) ||
             (pLowerConnIn->State == NBT_SESSION_INBOUND)))
        {
            pEntry = pLowerConnIn->Linkage.Flink;
            pLowerConnIn = NULL;
        }
        else
        {
            pEntry = pHead->Flink;
        }

        while (pEntry != pHead)
        {
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);

            //
            // Inbound connections can hang around forever in that state if
            // the session setup message never gets sent, so send keep
            // alives on those too.
            //
            if ((pLowerConn->State == NBT_SESSION_UP) ||
                (pLowerConn->State == NBT_SESSION_INBOUND))
            {

                // grab the spin lock, recheck the state and
                // increment the reference count so that this connection cannot
                // disappear while the keep alive is being sent and mess up
                // the linked list.
                CTESpinLock(pLowerConn,OldIrq2);
                if ((pLowerConn->State != NBT_SESSION_UP ) &&
                    (pLowerConn->State != NBT_SESSION_INBOUND))
                {
                    // this connection is probably back on the free connection
                    // list, so we will never satisfy the pEntry = pHead and
                    // loop forever, so just get out and send keepalives on the
                    // next timeout
                    //
                    pEntry = pEntry->Flink;
                    PUSH_LOCATION(0x91);
                    CTESpinFree(pLowerConn,OldIrq2);
                    break;

                }
                else if (pLowerConn->RefCount >= 3 )
                {
                    //
                    // already a keep alive on this connection, or we
                    // are currently in the receive handler and do not
                    // need to send a keep alive.
                    //
                    pEntry = pEntry->Flink;
                    PUSH_LOCATION(0x93);
                    CTESpinFree(pLowerConn,OldIrq2);
                    continue;
                }

                //
                // found a connection to send a keep alive on
                //
                NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_KEEP_ALIVE);
                //
                // return the current position in the list of connections
                //
                pTracker->RCount = pDeviceContext->AdapterNumber;
                *ppLowerConnOut = pLowerConn;
                *ppDeviceContextOut = pDeviceContext;

                CTESpinFree(pLowerConn,OldIrq2);
                CTESpinFree(pDeviceContext,OldIrq);
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                return;
            }

            pEntry = pEntry->Flink;
        }

        CTESpinFree(pDeviceContext,OldIrq);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    return;

}

//----------------------------------------------------------------------------
VOID
SessionKeepAliveTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles starting the non dispatch level routine to send
    keep alives.

Arguments:


Return Value:

    none

--*/
{
    if (!pTimerQEntry)
    {
        NbtConfig.pSessionKeepAliveTimer = NULL;
        return;
    }

    CHECK_PTR(pTimerQEntry);
    if (!NT_SUCCESS(CTEQueueForNonDispProcessing (DelayedSessionKeepAlive,
                                                 NULL, NULL, NULL, NULL, FALSE)))
    {
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint (("Nbt.SessionKeepAliveTimeout: Failed to Queue DelayedSessionKeepAlive!!!\n"));
    }

    // restart the timer
    //
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}

//----------------------------------------------------------------------------
VOID
DelayedSessionKeepAlive(
    IN  tDGRAM_SEND_TRACKING    *Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *pUnused4
    )
/*++

Routine Description:

    This routine handles sending session keep Alives to the other end of a
    connection about once a minute or so.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;
    tSESSIONHDR             *pSessionHdr;
    tDGRAM_SEND_TRACKING    *pTracker;


    CTEPagedCode();

    if (!(pSessionHdr = (tSESSIONHDR *)NbtAllocMem(sizeof(tSESSIONERROR),NBT_TAG('S'))))
    {
        return;
    }

    // get a tracker structure, which has a SendInfo structure in it
    if (!NT_SUCCESS(status = GetTracker(&pTracker, NBT_TRACKER_KEEP_ALIVE)))
    {
        CTEMemFree((PVOID)pSessionHdr);
        return;
    }

    //
    // go through the list of connections attached to each adapter and
    // send a session keep alive pdu on each
    //
    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink,
                                        tDEVICECONTEXT,Linkage);

    // get the next session to send a keep alive on, if there is one, otherwise
    // free the session header block.
    //
    pTracker->RCount = 0;       // This field keeps track of the last device
    GetNextKeepAlive(pDeviceContext, &pDeviceContext, NULL, &pLowerConn, pTracker);
    if (pLowerConn)
    {
        // if we have found a connection, send the first keep alive.  Subsequent
        // keep alives will be sent by the completion routine, NextKeepAlive()
        //
        CHECK_PTR(pTracker);
        pTracker->SendBuffer.pDgramHdr = (PVOID)pSessionHdr;
        pTracker->SendBuffer.HdrLength = sizeof(tSESSIONHDR);
        pTracker->SendBuffer.Length  = 0;
        pTracker->SendBuffer.pBuffer = NULL;

        pSessionHdr->Flags = NBT_SESSION_FLAGS; // always zero

        pTracker->pDeviceContext = pDeviceContext;
        pTracker->pClientEle = (tCLIENTELE *)pLowerConn;
        CHECK_PTR(pSessionHdr);
        pSessionHdr->Type = NBT_SESSION_KEEP_ALIVE;     // 85
        pSessionHdr->Length = 0;        // no data following the length byte

        status = TcpSendSession(pTracker, pLowerConn, NextKeepAlive);
    }
    else
    {
        CTEMemFree((PVOID)pSessionHdr);
        FreeTracker (pTracker, RELINK_TRACKER);
    }
}


//----------------------------------------------------------------------------
VOID
IncrementNameStats(
    IN ULONG           StatType,
    IN BOOLEAN         IsNameServer
    )
/*++

Routine Description:

    This routine increments statistics on names that resolve either through
    the WINS or through broadcast.

Arguments:


Return Value:

    none

--*/
{

    //
    // Increment the stattype if the name server is true, that way we can
    // differentiate queries and registrations to the name server or not.
    //
    if (IsNameServer)
    {
        StatType += 2;
    }

    NameStatsInfo.Stats[StatType]++;

}
//----------------------------------------------------------------------------
VOID
SaveBcastNameResolved(
    IN PUCHAR          pName
    )
/*++

Routine Description:

    This routine saves the name in LIFO list, so we can see the last
    N names that resolved via broadcast.

Arguments:


Return Value:

    none

--*/
{
    ULONG                   Index;

    Index = NameStatsInfo.Index;

    CTEMemCopy(&NameStatsInfo.NamesReslvdByBcast[Index],
               pName,
               NETBIOS_NAME_SIZE);

    NameStatsInfo.Index++;
    if (NameStatsInfo.Index >= SIZE_RESOLVD_BY_BCAST_CACHE)
    {
        NameStatsInfo.Index = 0;
    }

}

//
// These are names that should never be sent to WINS.
//
BOOL
IsBrowserName(
	IN PCHAR pName
)
{
	CHAR cNameType = pName[NETBIOS_NAME_SIZE - 1];

	return (
		(cNameType == 0x1E)
		|| (cNameType == 0x1D)
		|| (cNameType == 0x01)
		);
}

//
// Returns the node type that should be used with a request,
// based on NetBIOS name type.  This is intended to help the
// node to behave like a BNODE for browser names only.
//
AppropriateNodeType(
	IN PCHAR pName,
	IN ULONG NodeType
)
{
	ULONG LocalNodeType = NodeType;

	if (LocalNodeType & BNODE)
	{
		if ( IsBrowserName ( pName ) )
		{
			LocalNodeType &= BNODE;
		}
	}
	return LocalNodeType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\init.c ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    Init.c

    OS Independent initialization routines



    FILE HISTORY:
        Johnl   26-Mar-1993     Created
*/


#include "nbtnt.h"
#include "precomp.h"
#include "hosts.h"

VOID
ReadScope(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

VOID
ReadLmHostFile(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

extern  tTIMERQ TimerQ;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, InitNotOs)
#pragma CTEMakePageable(PAGE, InitTimersNotOs)
#pragma CTEMakePageable(PAGE, StopInitTimers)
#pragma CTEMakePageable(PAGE, ReadParameters)
#pragma CTEMakePageable(PAGE, ReadParameters2)
#pragma CTEMakePageable(PAGE, ReadScope)
#pragma CTEMakePageable(PAGE, ReadLmHostFile)
#endif
//*******************  Pageable Routine Declarations ****************

#ifdef VXD
#pragma BEGIN_INIT
#endif

//----------------------------------------------------------------------------
NTSTATUS
InitNotOs(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the Non-OS Specific side of the
    NBT device driver.

    pNbtGlobConfig must be initialized before this is called!

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;


    CTEPagedCode();

    //
    // for multihomed hosts, this tracks the number of adapters as each one
    // is created.
    //
    NbtMemoryAllocated = 0;

    NbtConfig.AdapterCount = 0;
    NbtConfig.MultiHomed = FALSE;
    NbtConfig.SingleResponse = FALSE;
    NbtConfig.ServerMask = 0;
    NbtConfig.ClientMask = 0;
    NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER] = 0;
    pNbtGlobConfig->iBufferSize[eNBT_DGRAM_TRACKER] = sizeof(tDGRAM_SEND_TRACKING);
    CTEZeroMemory (&NameStatsInfo,sizeof(tNAMESTATS_INFO));     // Initialize the name statistics
    CTEZeroMemory (&LmHostQueries,sizeof(tLMHSVC_REQUESTS));    // Synchronize reads from the LmHosts file
    InitializeListHead (&LmHostQueries.ToResolve);


    //
    // Initialize the linked lists associated with the global configuration
    // data structures
    //
    InitializeListHead (&NbtConfig.DeviceContexts);
    InitializeListHead (&NbtConfig.DevicesAwaitingDeletion);
    InitializeListHead (&NbtConfig.AddressHead);
    InitializeListHead (&NbtConfig.PendingNameQueries);
    InitializeListHead (&NbtConfig.WorkerQList);
    InitializeListHead (&NbtConfig.NodeStatusHead);
    InitializeListHead (&NbtConfig.DgramTrackerFreeQ);
    InitializeListHead (&UsedTrackers);
    InitializeListHead (&UsedIrps);
    InitializeListHead (&DomainNames.DomainList);

    // initialize the spin lock
    CTEInitLock (&NbtConfig.LockInfo.SpinLock);
    CTEInitLock (&NbtConfig.JointLock.LockInfo.SpinLock);
    CTEInitLock (&NbtConfig.WorkerQLock.LockInfo.SpinLock);

#ifndef VXD
    pWinsInfo = NULL;
    NbtConfig.NumWorkerThreadsQueued = 0;
    NbtConfig.NumTimersRunning = 0;
    NbtConfig.CacheTimeStamp = 0;
    NbtConfig.InterfaceIndex = 0;
    NbtConfig.GlobalRefreshState = 0;
    NbtConfig.pWakeupRefreshTimer = NULL;
    NbtConfig.TransactionId = WINS_MAXIMUM_TRANSACTION_ID + 1;
    NbtConfig.RemoteCacheLen = REMOTE_CACHE_INCREMENT;
    NbtConfig.iBufferSize[eNBT_FREE_SESSION_MDLS] = sizeof(tSESSIONHDR);
    NbtConfig.iBufferSize[eNBT_DGRAM_MDLS] = DGRAM_HDR_SIZE + (NbtConfig.ScopeLength << 1);

    //
    // Set the Unitialized flag in the TimerQ, so that it can be initialized
    // when needed
    //
    TimerQ.TimersInitialized = FALSE;

    // Initialize the LastForcedReleaseTime!
    CTEQuerySystemTime (NbtConfig.LastForcedReleaseTime);
    CTEQuerySystemTime (NbtConfig.LastOutOfRsrcLogTime);
    CTEQuerySystemTime (NbtConfig.LastRefreshTime);
    ExSystemTimeToLocalTime (&NbtConfig.LastRefreshTime, &NbtConfig.LastRefreshTime);

    //
    // this resource is used to synchronize access to the Dns structure
    //
    CTEZeroMemory (&DnsQueries,sizeof(tLMHSVC_REQUESTS));
    InitializeListHead (&DnsQueries.ToResolve);
    //
    // this resource is used to synchronize access to the CheckAddr structure
    //
    CTEZeroMemory(&CheckAddr,sizeof(tLMHSVC_REQUESTS));
    InitializeListHead (&CheckAddr.ToResolve);

    //
    // Setup the default disconnect timeout - 10 seconds - convert
    // to negative 100 Ns.
    //
    DefaultDisconnectTimeout.QuadPart = Int32x32To64(DEFAULT_DISC_TIMEOUT, MILLISEC_TO_100NS);
    DefaultDisconnectTimeout.QuadPart = -(DefaultDisconnectTimeout.QuadPart);

    InitializeListHead (&NbtConfig.IrpFreeList);
    InitializeListHead (&FreeWinsList);
    // set up a list for connections when we run out of resources and need to
    // disconnect these connections. An Irp is also needed for this list, and
    // it is allocated in Driver.C after we have created the connections to the
    // transport and therefore know our Irp Stack Size.
    //
    InitializeListHead (&NbtConfig.OutOfRsrc.ConnectionHead);

    KeInitializeEvent (&NbtConfig.WorkerQLastEvent, NotificationEvent, TRUE);
    KeInitializeEvent (&NbtConfig.TimerQLastEvent, NotificationEvent, TRUE);
    KeInitializeEvent (&NbtConfig.WakeupTimerStartedEvent, NotificationEvent, TRUE);

    // use this resources to synchronize access to the security info between
    // assigning security and checking it - when adding names to the
    // name local name table through NbtregisterName.  This also insures
    // that the name is in the local hash table (from a previous Registration)
    // before the next registration is allowed to proceed and check for
    // the name in the table.
    //
    ExInitializeResourceLite(&NbtConfig.Resource);
#else
    DefaultDisconnectTimeout = DEFAULT_DISC_TIMEOUT * 1000; // convert to milliseconds

    InitializeListHead(&NbtConfig.SendTimeoutHead) ;
    InitializeListHead(&NbtConfig.SessionBufferFreeList) ;
    InitializeListHead(&NbtConfig.SendContextFreeList) ;
    InitializeListHead(&NbtConfig.RcvContextFreeList) ;

    //
    //  For session headers, since they are only four bytes and we can't
    //  change the size of the structure, we'll covertly add enough for
    //  a full LIST_ENTRY and treat it like a standalone LIST_ENTRY structure
    //  when adding and removing from the list.
    //
    NbtConfig.iBufferSize[eNBT_SESSION_HDR]  = sizeof(tSESSIONHDR) + sizeof(LIST_ENTRY) - sizeof(tSESSIONHDR);
    NbtConfig.iBufferSize[eNBT_SEND_CONTEXT] = sizeof(TDI_SEND_CONTEXT);
    NbtConfig.iBufferSize[eNBT_RCV_CONTEXT]  = sizeof(RCV_CONTEXT);
    NbtConfig.iCurrentNumBuff[eNBT_SESSION_HDR]    = NBT_INITIAL_NUM;
    NbtConfig.iCurrentNumBuff[eNBT_SEND_CONTEXT]   = NBT_INITIAL_NUM;
    NbtConfig.iCurrentNumBuff[eNBT_RCV_CONTEXT]    = NBT_INITIAL_NUM;

    InitializeListHead (&NbtConfig.DNSDirectNameQueries);
#endif

#if DBG
    NbtConfig.LockInfo.LockNumber = NBTCONFIG_LOCK;
    NbtConfig.JointLock.LockInfo.LockNumber = JOINT_LOCK;
    NbtConfig.WorkerQLock.LockInfo.LockNumber = WORKERQ_LOCK;
    for (i=0; i<MAXIMUM_PROCESSORS; i++)
    {
        NbtConfig.CurrentLockNumber[i] = 0;
    }
    InitializeListHead(&NbtConfig.StaleRemoteNames);
#endif

    //
    // create trackers List
    //
// #if DBG
    for (i=0; i<NBT_TRACKER_NUM_TRACKER_TYPES; i++)
    {
        TrackTrackers[i] = 0;
        TrackerHighWaterMark[i] = 0;
    }
// #endif   // DBG

    //
    // Now allocate any initial memory/Resources
    //
#ifdef VXD
    status = NbtInitQ (&NbtConfig.SessionBufferFreeList,
                       NbtConfig.iBufferSize[eNBT_SESSION_HDR],
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }

    status = NbtInitQ( &NbtConfig.SendContextFreeList,
                       sizeof( TDI_SEND_CONTEXT ),
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }

    status = NbtInitQ( &NbtConfig.RcvContextFreeList,
                       sizeof (RCV_CONTEXT),
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }
#endif

    // create the hash tables for storing names in.
    status = CreateHashTable(&NbtConfig.pLocalHashTbl, NbtConfig.uNumBucketsLocal, NBT_LOCAL);
    if (!NT_SUCCESS (status))
    {
        ASSERTMSG("NBT:Unable to create hash tables for Netbios Names\n", (status == STATUS_SUCCESS));
        return status ;
    }

    // we always have a remote hash table, but if we are a Proxy, it is
    // a larger table. In the Non-proxy case the remote table just caches
    // names resolved with the NS.  In the Proxy case it also holds names
    // resolved for all other clients on the local broadcast area.
    // The node size registry parameter controls the number of remote buckets.
    status = CreateHashTable (&NbtConfig.pRemoteHashTbl, NbtConfig.uNumBucketsRemote, NBT_REMOTE);
    if (!NT_SUCCESS (status))
    {
        return status;
    }

    status = NbtInitTrackerQ (NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status;
    }

    // create the timer control blocks, setting the number of concurrent timers
    // allowed at one time
    status = InitTimerQ (NBT_INITIAL_NUM);

    return status;
}

//----------------------------------------------------------------------------
NTSTATUS
InitTimersNotOs(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the Non-OS Specific side of the
    NBT device driver that starts the timers needed.

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;

    CTEPagedCode();

    //
    // If the timers have already been initialized, return success
    //
    if (TimerQ.TimersInitialized)
    {
        return STATUS_SUCCESS;
    }

    NbtConfig.iBufferSize[eNBT_TIMER_ENTRY] = sizeof(tTIMERQENTRY);
    NbtConfig.iCurrentNumBuff[eNBT_TIMER_ENTRY] = NBT_INITIAL_NUM;

    NbtConfig.pRefreshTimer = NULL;
    NbtConfig.pRemoteHashTimer = NULL;
    NbtConfig.pSessionKeepAliveTimer = NULL;
    NbtConfig.RefreshDivisor = REFRESH_DIVISOR;

    if (!NT_SUCCESS(status))
    {
        return status ;
    }

    // start a Timer to refresh names with the name service
    //
    if (!(NodeType & BNODE))
    {

        // the initial refresh rate until we can contact the name server
        NbtConfig.MinimumTtl = NbtConfig.InitialRefreshTimeout;
        NbtConfig.sTimeoutCount = 3;

        status = StartTimer(RefreshTimeout,
                            NbtConfig.InitialRefreshTimeout/REFRESH_DIVISOR,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This timer is a global timer
                            &NbtConfig.pRefreshTimer,
                            0,
                            FALSE);

        if ( !NT_SUCCESS(status))
        {
            return status;
        }
    }

    //
    // Set the TimersInitialized flag
    //
    TimerQ.TimersInitialized = TRUE;

    // calculate the count necessary to timeout out names in RemoteHashTimeout
    // milliseconds
    //
    NbtConfig.RemoteTimeoutCount = (USHORT)((NbtConfig.RemoteHashTtl/REMOTE_HASH_TIMEOUT));
    if (NbtConfig.RemoteTimeoutCount == 0)
    {
        NbtConfig.RemoteTimeoutCount = 1;
    }

    // start a Timer to timeout remote cached names from the Remote hash table.
    // The timer is a one minute timer, and the hash entries count down to zero
    // then time out.
    //
    status = StartTimer(RemoteHashTimeout,  // timer expiry routine
                        REMOTE_HASH_TIMEOUT,
                        NULL,            // context value
                        NULL,            // context2 value
                        NULL,
                        NULL,
                        NULL,           // This timer is a global timer
                        &NbtConfig.pRemoteHashTimer,
                        0,
                        FALSE);

    if ( !NT_SUCCESS( status ) )
    {
        StopInitTimers();
        return status ;
    }

    // start a Timer for Session Keep Alives which sends a session keep alive
    // on a connection if the timer value is not set to -1
    //
    if (NbtConfig.KeepAliveTimeout != -1)
    {
        status = StartTimer(SessionKeepAliveTimeout,  // timer expiry routine
                            NbtConfig.KeepAliveTimeout,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This timer is a global timer
                            &NbtConfig.pSessionKeepAliveTimer,
                            0,
                            FALSE);

        if ( !NT_SUCCESS( status ) )
        {
            StopInitTimers();
            return status ;
        }
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
StopInitTimers(
    VOID
    )

/*++

Routine Description:

    This is stops the timers started in InitTimerNotOS

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    CTEPagedCode();

    //
    // If the timers have already been stopped, return success
    //
    if (!TimerQ.TimersInitialized)
    {
        return STATUS_SUCCESS;
    }

    //
    // Set the TimersInitialized flag to FALSE
    //
    TimerQ.TimersInitialized = FALSE;

    if (NbtConfig.pRefreshTimer)
    {
        StopTimer(NbtConfig.pRefreshTimer,NULL,NULL);
    }
    if (NbtConfig.pSessionKeepAliveTimer)
    {
        StopTimer(NbtConfig.pSessionKeepAliveTimer,NULL,NULL);
    }
    if (NbtConfig.pRemoteHashTimer)
    {
        StopTimer(NbtConfig.pRemoteHashTimer,NULL,NULL);
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
VOID
ReadParameters(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read various parameters from the parameters
    section of the NBT section of the registry.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    ULONG           NodeSize;
    ULONG           Refresh;

    CTEPagedCode();

    ReadParameters2(pConfig, ParmHandle);

    pConfig->NameServerPort =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NS_PORT_NUM,
                                                     NBT_NAMESERVER_UDP_PORT,
                                                     0);

    pConfig->MaxPreloadEntries = CTEReadSingleIntParameter(ParmHandle,
                                       WS_MAX_PRELOADS,
                                       DEF_PRELOAD,
                                       DEF_PRELOAD ) ;

    if (pConfig->MaxPreloadEntries > MAX_PRELOAD)
    {
      pConfig->MaxPreloadEntries = MAX_PRELOAD;
    }

#ifdef VXD
    pConfig->DnsServerPort =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_DNS_PORT_NUM,
                                                     NBT_DNSSERVER_UDP_PORT,
                                                     0);

    pConfig->lRegistryMaxNames = (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                       VXD_NAMETABLE_SIZE_NAME,
                                       VXD_DEF_NAMETABLE_SIZE,
                                       VXD_MIN_NAMETABLE_SIZE ) ;

    pConfig->lRegistryMaxSessions = (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                       VXD_SESSIONTABLE_SIZE_NAME,
                                       VXD_DEF_SESSIONTABLE_SIZE,
                                       VXD_MIN_SESSIONTABLE_SIZE ) ;

    pConfig->DoDNSDevolutions =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_DO_DNS_DEVOLUTIONS,
                                               0,   // disabled by default
                                               0);
#endif

    pConfig->RemoteHashTtl =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_CACHE_TIMEOUT,
                                                     DEFAULT_CACHE_TIMEOUT,
                                                     MIN_CACHE_TIMEOUT);
    pConfig->InitialRefreshTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_INITIAL_REFRESH,
                                                     NBT_INITIAL_REFRESH_TTL,
                                                     NBT_INITIAL_REFRESH_TTL);

    pConfig->MinimumRefreshSleepTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_MINIMUM_REFRESH_SLEEP_TIME,
                                                     DEFAULT_MINIMUM_REFRESH_SLEEP_TIME,
                                                     0);

    // retry timeouts and number of retries for both Broadcast name resolution
    // and Name Service resolution
    //
    pConfig->uNumBcasts =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NUM_BCASTS,
                                                     DEFAULT_NUMBER_BROADCASTS,
                                                     1);

    pConfig->uBcastTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_BCAST_TIMEOUT,
                                                     DEFAULT_BCAST_TIMEOUT,
                                                     MIN_BCAST_TIMEOUT);

    pConfig->uNumRetries =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NAMESRV_RETRIES,
                                                     DEFAULT_NUMBER_RETRIES,
                                                     1);

    pConfig->uRetryTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NAMESRV_TIMEOUT,
                                                     DEFAULT_RETRY_TIMEOUT,
                                                     MIN_RETRY_TIMEOUT);

    pConfig->KeepAliveTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_KEEP_ALIVE,
                                               DEFAULT_KEEP_ALIVE,
                                               MIN_KEEP_ALIVE);

    pConfig->SelectAdapter =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_RANDOM_ADAPTER,
                                               0,
                                               0);
    pConfig->SingleResponse =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_SINGLE_RESPONSE,
                                               0,
                                               0);
    pConfig->NoNameReleaseOnDemand =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_NO_NAME_RELEASE,
                                               0,
                                               0);  // disabled by default
    if (pConfig->CachePerAdapterEnabled = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_CACHE_PER_ADAPTER_ENABLED,
                                               1,   // Enabled by default
                                               0))
    {
        pConfig->ConnectOnRequestedInterfaceOnly = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                                   WS_CONNECT_ON_REQUESTED_IF_ONLY,
                                                   0,   // Disabled by default
                                                   0);
    }
    else
    {
        pConfig->ConnectOnRequestedInterfaceOnly = FALSE;
    }
    pConfig->SendDgramOnRequestedInterfaceOnly = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_SEND_DGRAM_ON_REQUESTED_IF_ONLY,
                                               1,   // Enabled by default
                                               0);
    pConfig->SMBDeviceEnabled       = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_SMB_DEVICE_ENABLED,
                                               1,   // Enabled by default
                                               0);

    pConfig->MultipleCacheFlags       = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_MULTIPLE_CACHE_FLAGS,
                                               0,   // Not enabled by default
                                               0);
    pConfig->UseDnsOnly =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_USE_DNS_ONLY,
                                               0,
                                               0);  // disabled by default
    if (pConfig->UseDnsOnly)
    {
        pConfig->ResolveWithDns = TRUE;
        pConfig->TryAllNameServers = FALSE;
    }
    else
    {
        pConfig->ResolveWithDns =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_DNS,
                                               1,   // Enabled by default
                                               0);
#ifdef MULTIPLE_WINS
        pConfig->TryAllNameServers =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_TRY_ALL_NAME_SERVERS,
                                               0,   // disabled by default
                                               0);
#endif
    }
    pConfig->SmbDisableNetbiosNameCacheLookup =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_SMB_DISABLE_NETBIOS_NAME_CACHE_LOOKUP,
                                               1,   // Enabled by default
                                               0);
    pConfig->TryAllAddr =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_TRY_ALL_ADDRS,
                                               1,
                                               1);  // enabled by default
    pConfig->LmHostsTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_LMHOSTS_TIMEOUT,
                                               DEFAULT_LMHOST_TIMEOUT,
                                               MIN_LMHOST_TIMEOUT);
    pConfig->MaxDgramBuffering =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_MAX_DGRAM_BUFFER,
                                               DEFAULT_DGRAM_BUFFERING,
                                               DEFAULT_DGRAM_BUFFERING);

    pConfig->EnableProxyRegCheck =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_PROXY_REG_CHECK,
                                               0,
                                               0);

    pConfig->WinsDownTimeout =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_WINS_DOWN_TIMEOUT,
                                               DEFAULT_WINS_DOWN_TIMEOUT,
                                               MIN_WINS_DOWN_TIMEOUT);

    pConfig->MaxBackLog =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_MAX_CONNECTION_BACKLOG,
                                               DEFAULT_CONN_BACKLOG,
                                               MIN_CONN_BACKLOG);

    pConfig->SpecialConnIncrement =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                                           WS_CONNECTION_BACKLOG_INCREMENT,
                                                           DEFAULT_CONN_BACKLOG_INCREMENT,
                                                           MIN_CONN_BACKLOG_INCREMENT);

    pConfig->MinFreeLowerConnections =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                                           WS_MIN_FREE_INCOMING_CONNECTIONS,
                                                           DEFAULT_NBT_NUM_INITIAL_CONNECTIONS,
                                                           MIN_NBT_NUM_INITIAL_CONNECTIONS);

    pConfig->BreakOnAssert          = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_BREAK_ON_ASSERT,
                                               1,   // Enabled by default
                                               0);
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    pConfig->DhcpProcessingDelay = (ULONG) CTEReadSingleIntParameter(ParmHandle,
                                                WS_DHCP_PROCESSING_DELAY,
                                                DEFAULT_DHCP_PROCESSING_DELAY,
                                                MIN_DHCP_PROCESSING_DELAY);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

    //
    // Cap the upper limit
    //
    if (pConfig->MaxBackLog > MAX_CONNECTION_BACKLOG) {
        pConfig->MaxBackLog = MAX_CONNECTION_BACKLOG;
    }

    if (pConfig->SpecialConnIncrement > MAX_CONNECTION_BACKLOG_INCREMENT) {
        pConfig->SpecialConnIncrement = MAX_CONNECTION_BACKLOG_INCREMENT;
    }


    //
    // Since UB chose the wrong opcode (9) we have to allow configuration
    // of that opcode incase our nodes refresh to their NBNS
    //
    Refresh =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_REFRESH_OPCODE,
                                               REFRESH_OPCODE,
                                               REFRESH_OPCODE);
    if (Refresh == UB_REFRESH_OPCODE)
    {
        pConfig->OpRefresh = OP_REFRESH_UB;
    }
    else
    {
        pConfig->OpRefresh = OP_REFRESH;
    }

#ifndef VXD
    pConfig->EnableLmHosts =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_LMHOSTS,
                                               0,
                                               0);
#endif

#ifdef PROXY_NODE

    {
       ULONG Proxy;
       Proxy =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_IS_IT_A_PROXY,
                                               IS_NOT_PROXY,    //default value
                                               IS_NOT_PROXY);

      //
      // If the returned value is greater than IS_NOT_PROXY, it is a proxy
      // (also check that they have not entered an ascii string instead of a
      // dword in the registry
      //
      if ((Proxy > IS_NOT_PROXY) && (Proxy < ('0'+IS_NOT_PROXY)))
      {
           NodeType |= PROXY;
           RegistryNodeType |= PROXY;
           NbtConfig.ProxyType = Proxy;
      }
    }
#endif
    NodeSize =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_NODE_SIZE,
                                               NodeType & PROXY ? LARGE : DEFAULT_NODE_SIZE,
                                               NodeType & PROXY ? LARGE : SMALL);

    switch (NodeSize)
    {
        default:
        case SMALL:

            pConfig->uNumLocalNames = NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = NBT_NUM_DGRAM_TRACKERS;
            pConfig->iMaxNumBuff[eNBT_TIMER_ENTRY]     = TIMER_Q_SIZE;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_IRPS]       = NBT_NUM_IRPS;
            pConfig->iMaxNumBuff[eNBT_DGRAM_MDLS]      = NBT_NUM_DGRAM_MDLS;
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = NBT_NUM_RCV_CONTEXT ;
#endif
            break;

        case MEDIUM:

            pConfig->uNumLocalNames = MEDIUM_NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = MEDIUM_NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = MEDIUM_NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = MEDIUM_NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = MEDIUM_NBT_NUM_DGRAM_TRACKERS;
            pConfig->iMaxNumBuff[eNBT_TIMER_ENTRY]     = MEDIUM_TIMER_Q_SIZE;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_IRPS]       = MEDIUM_NBT_NUM_IRPS;
            pConfig->iMaxNumBuff[eNBT_DGRAM_MDLS]      = MEDIUM_NBT_NUM_DGRAM_MDLS;
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = MEDIUM_NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = MEDIUM_NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = MEDIUM_NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = MEDIUM_NBT_NUM_RCV_CONTEXT ;
#endif
            break;

        case LARGE:

            pConfig->uNumLocalNames = LARGE_NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = LARGE_NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = LARGE_NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = LARGE_NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = LARGE_NBT_NUM_DGRAM_TRACKERS;
            pConfig->iMaxNumBuff[eNBT_TIMER_ENTRY]     = LARGE_TIMER_Q_SIZE;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_IRPS]       = LARGE_NBT_NUM_IRPS;
            pConfig->iMaxNumBuff[eNBT_DGRAM_MDLS]      = LARGE_NBT_NUM_DGRAM_MDLS;
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = LARGE_NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = LARGE_NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = LARGE_NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = LARGE_NBT_NUM_RCV_CONTEXT ;
#endif
            break;
    }

    ReadLmHostFile(pConfig,ParmHandle);
}

#ifdef VXD
#pragma END_INIT
#endif

//----------------------------------------------------------------------------
VOID
ReadParameters2(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read DHCPable parameters from the parameters
    section of the NBT section of the registry.

    This routine is primarily for the Vxd.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    ULONG           Node;
    ULONG           ReadOne;
    ULONG           ReadTwo;

    CTEPagedCode();

    Node = CTEReadSingleIntParameter(ParmHandle,     // handle of key to look under
                                     WS_NODE_TYPE,   // wide string name
                                     0,              // default value
                                     0);

    switch (Node)
    {
        case 2:
            NodeType = PNODE;
            break;

        case 4:
            NodeType = MNODE;
            break;

        case 8:
            NodeType = MSNODE;
            break;

        case 1:
            NodeType = BNODE;
            break;

        default:
            NodeType = BNODE | DEFAULT_NODE_TYPE;
            break;
    }
    RegistryNodeType = NodeType;

    // do a trick  here - read the registry twice for the same value, passing
    // in two different defaults, in order to determine if the registry
    // value has been defined or not - since it may be defined, but equal
    // to one default.
    ReadOne =  CTEReadSingleHexParameter(ParmHandle,
                                         WS_ALLONES_BCAST,
                                         DEFAULT_BCAST_ADDR,
                                         0);
    ReadTwo =  CTEReadSingleHexParameter(ParmHandle,
                                         WS_ALLONES_BCAST,
                                         0,
                                         0);
    if (ReadOne != ReadTwo)
    {
        NbtConfig.UseRegistryBcastAddr = FALSE;
    }
    else
    {
        NbtConfig.UseRegistryBcastAddr = TRUE;
        NbtConfig.RegistryBcastAddr = ReadTwo;
    }

    ReadScope(pConfig,ParmHandle);
}

//----------------------------------------------------------------------------
VOID
ReadScope(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read the scope from registry and convert it to
    a format where the intervening dots are length bytes.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    NTSTATUS        status;
    PUCHAR          pScope, pOldScope, pNewScope;
    PUCHAR          pBuff;
    PUCHAR          pBuffer;
    PUCHAR          pPeriod;
    ULONG           Len;
    UCHAR           Chr;


    CTEPagedCode();
    //
    // this routine returns the scope in a dotted format.
    // "Scope.MoreScope.More"  The dots are
    // converted to byte lengths by the code below.  This routine allocates
    // the memory for the pScope string.
    //
    status = CTEReadIniString(ParmHandle,NBT_SCOPEID,&pBuffer);

    if (NT_SUCCESS(status))
    {
        //
        // the user can type in an * to indicate that they really want
        // a null scope and that should override the DHCP scope. So check
        // here for an * and if so, set the scope back to null.
        //

        if ((strlen(pBuffer) == 0) || (pBuffer[0] == '*'))
        {
            CTEMemFree(pBuffer);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status))
    {
        // length of scope is num chars plus the 0 on the end, plus
        // the length byte on the start(+2 total) - so allocate another buffer
        // that is one longer than the previous one so it can include
        // these extra two bytes.
        //
        Len = strlen(pBuffer);
        //
        // the scope cannot be longer than 255 characters as per RFC1002
        //
        if (Len <= MAX_SCOPE_LENGTH)
        {
            pScope = NbtAllocMem (Len+2, NBT_TAG2('02'));
            if (pScope)
            {
                CTEMemCopy((pScope+1),pBuffer,Len);

                //
                // Put a null on the end of the scope
                //
                pScope[Len+1] = 0;

                Len = 1;

                // now go through the string converting periods to length
                // bytes - we know the first byte is a length byte so skip it.
                //
                pBuff = pScope;
                pBuff++;
                Len++;
                pPeriod = pScope;
                while (Chr = *pBuff)
                {
                    Len++;
                    if (Chr == '.')
                    {
                        *pPeriod = (UCHAR) (pBuff-pPeriod-1);

                        //
                        // Each label can be at most 63 bytes long
                        //
                        if (*pPeriod > MAX_LABEL_LENGTH)
                        {
                            status = STATUS_UNSUCCESSFUL;
                            NbtLogEvent (EVENT_SCOPE_LABEL_TOO_LONG, STATUS_SUCCESS, 0x104);
                            break;
                        }

                        // check for two periods back to back and use no scope if this
                        // happens
                        if (*pPeriod == 0)
                        {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }

                        pPeriod = pBuff++;
                    }
                    else
                        pBuff++;
                }
                if (NT_SUCCESS(status))
                {
                    // the last ptr is always the end of the name.

                    *pPeriod = (UCHAR)(pBuff - pPeriod -1);

                    pOldScope = pConfig->pScope;
                    pConfig->pScope = pScope;
                    pConfig->ScopeLength = (USHORT)Len;
                    if (pOldScope)
                    {
                        CTEMemFree(pOldScope);
                    }
                    CTEMemFree(pBuffer);
                    return;
                }
                CTEMemFree(pScope);
            }
            CTEMemFree(pBuffer);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
            NbtLogEvent (EVENT_SCOPE_LABEL_TOO_LONG, STATUS_SUCCESS, 0x105);
        }
    }

    //
    // the scope is one byte => '\0' - the length of the root name (zero)
    //
    // If the old scope and new scope are the same, then don't change the
    // scope tag!
    //
    pOldScope = pConfig->pScope;
    if (!(pOldScope) ||
        (*pOldScope != '\0'))
    {
        if (pNewScope = NbtAllocMem ((1), NBT_TAG2('03')))
        {
            *pNewScope = '\0';

            pConfig->ScopeLength = 1;
            pConfig->pScope = pNewScope;
            if (pOldScope)
            {
                CTEMemFree(pOldScope);
            }
        }
    }
}

#ifdef VXD
#pragma BEGIN_INIT
#endif

//----------------------------------------------------------------------------
VOID
ReadLmHostFile(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read the lmhost file path from the registry.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    NTSTATUS        status;
    PUCHAR          pBuffer, pOldLmHosts;
    PUCHAR          pchr;

    CTEPagedCode();

    NbtConfig.PathLength = 0;
    pOldLmHosts = pConfig->pLmHosts;
    NbtConfig.pLmHosts = NULL;

    //
    // read in the LmHosts File location
    //
#ifdef VXD
    status = CTEReadIniString(ParmHandle,WS_LMHOSTS_FILE,&pBuffer);
#else
    status = NTGetLmHostPath(&pBuffer);
#endif

    //
    // Find the last backslash so we can calculate the file path length
    //
    // Also, the lm host file must include a path of at least "c:\" i.e.
    // the registry contains c:\lmhost, otherwise NBT won't be
    // able to find the file since it doesn't know what directory
    // to look in.
    //
    if (NT_SUCCESS(status))
    {
        if (pchr = strrchr(pBuffer,'\\'))
        {
            NbtConfig.pLmHosts = pBuffer;
            NbtConfig.PathLength = (ULONG) (pchr-pBuffer+1); // include backslash in length

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.ReadLmHostFile:  LmHostsFile path is %s\n",NbtConfig.pLmHosts));
        }
        else
        {
            CTEMemFree(pBuffer);
        }
    }

    //
    // If we get a new Dhcp address this routine will get called again
    // after startup so we need to free any current lmhosts file path
    //
    if (pOldLmHosts)
    {
        CTEMemFree(pOldLmHosts);
    }
}
#ifdef VXD
#pragma END_INIT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nbtutils.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Nbtutils.c

Abstract:

    This file continas  a number of utility and support routines for
    the NBT code.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"

//  For some reason inclusion of dnsapi.h seems to cause build error
//#include "dns.h"            // for DNS_MAX_NAME_LENGTH
//#include "windns.h"         // for DNS_MAX_NAME_LENGTH

#define  DNS_MAX_NAME_LENGTH    (255)


//#if DBG
LIST_ENTRY  UsedIrps;
//#endif

NTSTATUS
NewInternalAddressFromNetbios(
    IN  PTA_NETBIOS_ADDRESS         pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );
NTSTATUS
NewInternalAddressFromNetbiosEX(
    IN  PTA_NETBIOS_EX_ADDRESS      pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );
NTSTATUS
NewInternalAddressFromUnicodeAddress(
    IN  PTA_NETBIOS_UNICODE_EX_ADDRESS pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, ConvertDottedDecimalToUlong)
#pragma CTEMakePageable(PAGE, CloseLowerConnections)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

BOOLEAN
IsEntryInList(
    PLIST_ENTRY     pEntryToFind,
    PLIST_ENTRY     pListToSearch
    )
{
    PLIST_ENTRY     pEntry, pHead;

    pHead = pListToSearch;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        if (pEntry == pEntryToFind)
        {
            //
            // This Entry is still valid
            //
            return (TRUE);
        }

        //
        // Go to next Entry
        //
        pEntry = pEntry->Flink;
    }

    return (FALSE);
}


//----------------------------------------------------------------------------
void
NbtFreeAddressObj(
    tADDRESSELE    *pAddress
    )

/*++

Routine Description:

    This routine releases all memory associated with an Address object.

Arguments:


Return Value:

    none

--*/

{
    //
    // let's come back and do this later when it's not dpc time
    //
    CTEQueueForNonDispProcessing( DelayedFreeAddrObj,
                                  NULL,
                                  pAddress,
                                  NULL,
                                  NULL,
                                  FALSE);
}

//----------------------------------------------------------------------------
VOID
DelayedFreeAddrObj(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )

/*++

Routine Description:

    This routine releases all memory associated with an Address object.

Arguments:


Return Value:

    none

--*/

{
    tADDRESSELE *pAddress = (tADDRESSELE *) pClientContext;
    ULONG       SavedVerify = pAddress->Verify;

#ifndef VXD
    if (pAddress->SecurityDescriptor)
    {
        SeDeassignSecurity(&pAddress->SecurityDescriptor);
    }
#endif

#if DBG
    CTEMemSet (pAddress, 0x12, sizeof(tADDRESSELE));
#endif  // DBG

    // free the address block itself
    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier

    pAddress->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pAddress);
}

//----------------------------------------------------------------------------
void
NbtFreeClientObj(
    tCLIENTELE    *pClientEle
    )

/*++

Routine Description:

    This routine releases all memory associated with Client object.

Arguments:


Return Value:

    none

--*/

{
    ULONG   SavedVerify = pClientEle->Verify;

#if DBG
    CTEMemSet (pClientEle, 0x12, sizeof(tCLIENTELE));
#endif  // DBG

    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier
    pClientEle->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pClientEle);
}

//----------------------------------------------------------------------------
void
FreeConnectionObj(
    tCONNECTELE       *pConnEle
    )

/*++

Routine Description:

    This routine releases all memory associated with a Connection object
    and then it frees the connection object itself.

Arguments:


Return Value:

    none

--*/

{
    ULONG   SavedVerify = pConnEle->Verify;

#if DBG
    CTEMemSet (pConnEle, 0x12, sizeof(tCONNECTELE));
#endif  // DBG
    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier
    pConnEle->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pConnEle);
}


//----------------------------------------------------------------------------
tCLIENTELE *
NbtAllocateClientBlock(
    tADDRESSELE     *pAddrEle,
    tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine allocates a block of memory for a client openning an
    address.  It fills in default values for the block and links the
    block to the addresslist.  The AddressEle spin lock is held when this
    routine is called.

Arguments:


Return Value:

    none

--*/

{
    tCLIENTELE  *pClientElement;

    // allocate memory for the client block
    pClientElement = (tCLIENTELE *) NbtAllocMem (sizeof (tCLIENTELE), NBT_TAG2('05'));
    if (!pClientElement)
    {
        ASSERTMSG("Unable to allocate Memory for a client block\n",
                pClientElement);
        return(NULL);
    }
    CTEZeroMemory((PVOID)pClientElement,sizeof(tCLIENTELE));

    CTEInitLock(&pClientElement->LockInfo.SpinLock);
#if DBG
    pClientElement->LockInfo.LockNumber = CLIENT_LOCK;
#endif

    // Set Event handler function pointers to default routines provided by
    // TDI
#ifndef VXD
    pClientElement->evConnect      = TdiDefaultConnectHandler;
    pClientElement->evReceive      = TdiDefaultReceiveHandler;
    pClientElement->evDisconnect   = TdiDefaultDisconnectHandler;
    pClientElement->evError        = TdiDefaultErrorHandler;
    pClientElement->evRcvDgram     = TdiDefaultRcvDatagramHandler;
    pClientElement->evRcvExpedited = TdiDefaultRcvExpeditedHandler;
    pClientElement->evSendPossible = TdiDefaultSendPossibleHandler;
#else
    //
    // VXD provides no client support for event handlers but does
    // make use of some of the event handlers itself (for RcvAny processing
    // and disconnect cleanup).
    //
    pClientElement->evConnect      = NULL ;
    pClientElement->evReceive      = NULL ;
    pClientElement->RcvEvContext   = NULL ;
    pClientElement->evDisconnect   = NULL ;
    pClientElement->evError        = NULL ;
    pClientElement->evRcvDgram     = NULL ;
    pClientElement->evRcvExpedited = NULL ;
    pClientElement->evSendPossible = NULL ;
#endif

    pClientElement->RefCount = 1;

    // there are no rcvs or snds yet
    InitializeListHead(&pClientElement->RcvDgramHead);
    InitializeListHead(&pClientElement->ListenHead);
    InitializeListHead(&pClientElement->SndDgrams);
    InitializeListHead(&pClientElement->ConnectActive);
    InitializeListHead(&pClientElement->ConnectHead);
#ifdef VXD
    InitializeListHead(&pClientElement->RcvAnyHead);
    pClientElement->fDeregistered = FALSE ;
#endif
    pClientElement->pIrp = NULL;

    // copy a special value into the verify long so that we can verify
    // connection ptrs passed back from the application
    pClientElement->Verify = NBT_VERIFY_CLIENT;
    pClientElement->pAddress = (PVOID)pAddrEle;         // link the client block to the Address element.
    pClientElement->pDeviceContext = pDeviceContext;    // adapter this name is registered against.

    // put the new Client element block on the end of the linked list tied to
    // the address element
    InsertTailList(&pAddrEle->ClientHead,&pClientElement->Linkage);

    return(pClientElement);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAddPermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine adds the node permanent name to the local name table.  This
    is the node's MAC address padded out to 16 bytes with zeros.

Arguments:
    DeviceContext - Adapter to add permanent
    pIrp          - Irp (optional) to complete after name has been added


Return Value:

    status

--*/

{
    NTSTATUS             status;
    TDI_REQUEST          Request;
    TA_NETBIOS_ADDRESS   Address;
    UCHAR                pName[NETBIOS_NAME_SIZE];
    USHORT               uType;
    CTELockHandle        OldIrq, OldIrq1;
    tNAMEADDR            *pNameAddr;
    tCLIENTELE           *pClientEle;

    CTEZeroMemory(pName,NETBIOS_NAME_SIZE);
    CTEMemCopy(&pName[10],&pDeviceContext->MacAddress.Address[0],sizeof(tMAC_ADDRESS));

    //
    // be sure the name has not already been added
    //
    if (pDeviceContext->pPermClient)
    {
        if (CTEMemEqu(pDeviceContext->pPermClient->pAddress->pNameAddr->Name, pName, NETBIOS_NAME_SIZE))
        {
            return(STATUS_SUCCESS);
        }
        else
        {
            NbtRemovePermanentName(pDeviceContext);
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // check if the name is already in the hash table
    //
    status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
    if ((NT_SUCCESS(status)) && (pNameAddr->pAddressEle))
    {
        //  
        // Acquire Address Spinlock since we may be accessing the ClientHead list
        // Bug #: 230820
        //
        CTESpinLock(pNameAddr->pAddressEle,OldIrq1);

        //
        // create client block and link to addresslist
        // pass back the client block address as a handle for future reference
        // to the client
        //
        pClientEle = NbtAllocateClientBlock (pNameAddr->pAddressEle, pDeviceContext);

        if (!pClientEle)
        {
            CTESpinFree(pNameAddr->pAddressEle,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NBT_REFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_NEW_CLIENT);
        CTESpinFree(pNameAddr->pAddressEle,OldIrq1);

        //
        // reset the ip address incase the the address got set to loop back
        // by a client releasing and re-openning the permanent name while there
        // was no ip address for this node.
        //
        pNameAddr->IpAddress = pDeviceContext->IpAddress;

        // turn on the adapter's bit in the adapter Mask and set the
        // re-register flag so we register the name out the new adapter.
        //
        pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
        pNameAddr->NameTypeState |= NAMETYPE_QUICK;

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt: Adding Permanent name %15.15s<%X> \n", pName,(UCHAR)pName[15]));
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // make up the Request data structure from the IRP info
        Request.Handle.AddressHandle = NULL;

        //
        // Make it a Quick name so it does not get registered on the net
        //
        Address.TAAddressCount = 1;
        Address.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
        Address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        Address.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

        CTEMemCopy(Address.Address[0].Address[0].NetbiosName,pName,NETBIOS_NAME_SIZE);

        status = NbtOpenAddress(&Request,
                                (PTA_ADDRESS)&Address.Address[0],
                                pDeviceContext->IpAddress,
                                NULL,
                                pDeviceContext,
                                NULL);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        pClientEle = (tCLIENTELE *)Request.Handle.AddressHandle;

    }

    //
    // save the client element so we can remove the permanent name later
    // if required
    //
    if (NT_SUCCESS(status))
    {
        pDeviceContext->pPermClient = pClientEle;
#ifdef VXD
       //
       // 0th element is for perm. name: store it.
       //
       pDeviceContext->pNameTable[0] = pClientEle;
#endif
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return(status);
}


//----------------------------------------------------------------------------
VOID
NbtRemovePermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine remomves the node permanent name to the local name table.

Arguments:
    DeviceContext - Adapter to add permanent
    pIrp          - Irp (optional) to complete after name has been added


Return Value:

    status

--*/

{
    NTSTATUS             status;
    tNAMEADDR            *pNameAddr;
    CTELockHandle        OldIrq;
    tCLIENTELE           *pClientEle;
    tADDRESSELE          *pAddressEle;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pDeviceContext->pPermClient)
    {

        //
        // We need to free the client and set the perm name ptr to null
        //
        pClientEle = pDeviceContext->pPermClient;
        pDeviceContext->pPermClient = NULL;

#ifdef VXD
        pDeviceContext->pNameTable[0] = NULL;
#endif

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_CLIENT(pClientEle);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
ConvertDottedDecimalToUlong(
    IN  PUCHAR               pInString,
    OUT PULONG               IpAddress
    )

/*++

Routine Description:

    This routine converts a unicode dotted decimal IP address into
    a 4 element array with each element being USHORT.

Arguments:


Return Value:

    NTSTATUS

--*/

{
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    CTEPagedCode();
    pArray[0] = 0;

    // go through each character in the string, skipping "periods", converting
    // to integer by subtracting the value of '0'
    //
    while ((Chr = *pInString++) && (Chr != ' ') )
    {
        if (Chr == '.')
        {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF)
                pArray[k] = (UCHAR) iSum;
            else
                return(STATUS_UNSUCCESSFUL);

            // check for too many periods in the address
            if (++k > 3)
                return STATUS_UNSUCCESSFUL;

            pArray[k] = 0;
            iSum = 0;
        }
        else
        {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9))
                return(STATUS_UNSUCCESSFUL);

            iSum = iSum*10 + Chr;
        }
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3))
        pArray[k] = (UCHAR) iSum;
    else
        return(STATUS_UNSUCCESSFUL);

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *IpAddress = value;

    return(STATUS_SUCCESS);

}

//----------------------------------------------------------------------------
NTSTATUS
NbtInitQ(
    PLIST_ENTRY pListHead,
    LONG        iSizeBuffer,
    LONG        iNumBuffers
    )

/*++

Routine Description:

    This routine allocates memory blocks for doubly linked lists and links
    them to a list.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iSizeBuffer - size of the buffer to add to the list head
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int         i;
    PLIST_ENTRY pBuffer;

    //  NOTE THAT THIS ASSUMES THAT THE LINKAGE PTRS FOR EACH BLOCK ARE AT
    // THE START OF THE BLOCK    - so it will not work correctly if
    // the various types in types.h change to move "Linkage" to a position
    // other than at the start of each structure to be chained

    for (i=0;i<iNumBuffers ;i++ )
    {
        pBuffer =(PLIST_ENTRY) NbtAllocMem (iSizeBuffer, NBT_TAG2('06'));
        if (!pBuffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        else
        {
            InsertHeadList(pListHead,pBuffer);
        }
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtGetBuffer(
    PLIST_ENTRY         pListHead,
    PLIST_ENTRY         *ppListEntry,
    enum eBUFFER_TYPES  eBuffType)

/*++

Routine Description:

    This routine tries to get a memory block and if it fails it allocates
    another set of buffers.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iSizeBuffer - size of the buffer to add to the list head
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    NTSTATUS    status;

    if (IsListEmpty(pListHead))
    {
        // check if we are allowed to allocate more memory blocks
        if (NbtConfig.iCurrentNumBuff[eBuffType] >=
                                pNbtGlobConfig->iMaxNumBuff[eBuffType]  )
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // no memory blocks, so allocate another one
        status = NbtInitQ(
                        pListHead,
                        pNbtGlobConfig->iBufferSize[eBuffType],
                        1);
        if (!NT_SUCCESS(status))
        {
            return(status);
        }

        NbtConfig.iCurrentNumBuff[eBuffType]++;

        *ppListEntry = RemoveHeadList(pListHead);
    }
    else
    {
        *ppListEntry = RemoveHeadList(pListHead);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
NetbiosAddressToInternalAddress(
    IN  PTA_NETBIOS_ADDRESS         pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
{
    //
    // name could be longer than 16 bytes (dns name), but make sure it's at
    // least 16 bytes (sizeof(TDI_ADDRESS_NETBIOS) == (16 + sizeof(USHORT)))
    //
    if (pTA->Address[0].AddressLength < sizeof(TDI_ADDRESS_NETBIOS)) {
        return(STATUS_INVALID_PARAMETER);
    }

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS;

    pNetBT->OEMEndpointName.Buffer = NULL;
    pNetBT->OEMEndpointName.Length = pNetBT->OEMEndpointName.MaximumLength = 0;

    /* Here we bent OEM_STRING a little bit, we allow Length == MaximumLength */
    /* That is, Rtl routines cannot be used since they expect null-terminated Buffer */
    pNetBT->OEMRemoteName.MaximumLength = pNetBT->OEMRemoteName.Length =
            pTA->Address[0].AddressLength - (sizeof(TDI_ADDRESS_NETBIOS) - NETBIOS_NAME_SIZE);
    pNetBT->OEMRemoteName.Buffer = pTA->Address[0].Address[0].NetbiosName;
    pNetBT->pNetbiosUnicodeEX = NULL;
    return STATUS_SUCCESS;
}

NTSTATUS
NetbiosEXAddressToInternalAddress(
    IN  PTA_NETBIOS_EX_ADDRESS      pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
{
    //
    // Check for the minimum acceptable length for this type of address
    //
    if (MaxInputBufferLength < sizeof (TA_NETBIOS_EX_ADDRESS)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    pNetBT->OEMEndpointName.Buffer = pTA->Address[0].Address[0].EndpointName;
    pNetBT->OEMEndpointName.Length = pNetBT->OEMEndpointName.MaximumLength = NETBIOS_NAME_SIZE;

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosAddress.NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;
    pNetBT->OEMRemoteName.MaximumLength = pNetBT->OEMRemoteName.Length =
                        pTA->Address[0].AddressLength -
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) -
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS,NetbiosName);
    pNetBT->OEMRemoteName.Buffer = pTA->Address[0].Address[0].NetbiosAddress.NetbiosName;
    pNetBT->pNetbiosUnicodeEX = NULL;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromNetbiosEX(
    IN  PTA_NETBIOS_EX_ADDRESS   pTA,
    IN  ULONG                    MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    TDI_ADDRESS_NETBT_INTERNAL  ta;
 
    ppNetBT[0] = NULL;
    if (!NT_SUCCESS(NetbiosEXAddressToInternalAddress(pTA, MaxInputBufferLength, &ta))) {
        return (STATUS_INVALID_ADDRESS);
    }

    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
                    NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1) +
                    NBT_DWORD_ALIGN(ta.OEMEndpointName.Length+1);
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = ta.NameType;
    pNetBT->AddressType = ta.AddressType;

    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    pNetBT->OEMRemoteName.Length        = ta.OEMRemoteName.Length;
    pNetBT->OEMRemoteName.Buffer        = (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    ASSERT((ta.OEMRemoteName.Length % sizeof(ta.OEMRemoteName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMRemoteName.Buffer, ta.OEMRemoteName.Buffer, ta.OEMRemoteName.Length);
    pNetBT->OEMRemoteName.Buffer[ta.OEMRemoteName.Length/sizeof(ta.OEMRemoteName.Buffer[0])] = 0;

    pNetBT->OEMEndpointName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMEndpointName.Length+1);
    pNetBT->OEMEndpointName.Length        = ta.OEMEndpointName.Length;
    pNetBT->OEMEndpointName.Buffer        = (PVOID)((PUCHAR)pNetBT->OEMRemoteName.Buffer +
                                                    pNetBT->OEMRemoteName.MaximumLength);
    ASSERT((ta.OEMEndpointName.Length % sizeof(ta.OEMEndpointName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMEndpointName.Buffer, ta.OEMEndpointName.Buffer, ta.OEMEndpointName.Length);
    pNetBT->OEMEndpointName.Buffer[ta.OEMEndpointName.Length/sizeof(ta.OEMEndpointName.Buffer[0])] = 0;

    pNetBT->pNetbiosUnicodeEX = NULL;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromNetbios(
    IN  PTA_NETBIOS_ADDRESS      pTA,
    IN  ULONG                    MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    TDI_ADDRESS_NETBT_INTERNAL  ta;
 
    ppNetBT[0] = NULL;
    if (!NT_SUCCESS(NetbiosAddressToInternalAddress(pTA, MaxInputBufferLength, &ta))) {
        return (STATUS_INVALID_ADDRESS);
    }

    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
                    NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = ta.NameType;
    pNetBT->AddressType = ta.AddressType;

    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    pNetBT->OEMRemoteName.Length        = ta.OEMRemoteName.Length;
    pNetBT->OEMRemoteName.Buffer        = (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    ASSERT((ta.OEMRemoteName.Length % sizeof(ta.OEMRemoteName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMRemoteName.Buffer, ta.OEMRemoteName.Buffer, ta.OEMRemoteName.Length);
    pNetBT->OEMRemoteName.Buffer[ta.OEMRemoteName.Length/sizeof(ta.OEMRemoteName.Buffer[0])] = 0;

    pNetBT->pNetbiosUnicodeEX = NULL;
    pNetBT->OEMEndpointName.MaximumLength = 0;
    pNetBT->OEMEndpointName.Length        = 0;
    pNetBT->OEMEndpointName.Buffer        = NULL;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromUnicodeAddress(
    IN  PTA_NETBIOS_UNICODE_EX_ADDRESS pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    OEM_STRING  OemEndpoint, OemRemote;
    UNICODE_STRING  temp;
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    int         remote_len;

    ppNetBT[0] = NULL;

    if (MaxInputBufferLength < sizeof (TDI_ADDRESS_NETBIOS_UNICODE_EX)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }
    switch(pTA->Address[0].Address[0].NameBufferType) {
    case NBT_READONLY:
    case NBT_WRITEONLY:
    case NBT_READWRITE:
    case NBT_WRITTEN:
        break;
    
    default:
        ASSERT(FALSE);
        return (STATUS_INVALID_ADDRESS);
    }

    /* unaligned */
    CTEMemCopy(&temp, &pTA->Address[0].Address[0].RemoteName, sizeof(temp));
    if (!NT_SUCCESS(RtlUpcaseUnicodeStringToOemString(&OemRemote, &temp, TRUE))) {
        return (STATUS_INVALID_ADDRESS);
    }
    CTEMemCopy(&temp, &pTA->Address[0].Address[0].EndpointName, sizeof(temp));
    if (!NT_SUCCESS(RtlUpcaseUnicodeStringToOemString(&OemEndpoint, &temp, TRUE))) {
        RtlFreeOemString(&OemRemote);
        return (STATUS_INVALID_ADDRESS);
    }

    /*
     * Other NetBT may never expect that remote_len and endpoint_len can be less than NETBIOS_NAME_SIZE.
     * Some of them may try to access 15th byte of the name.
     * In NETBIOS_NAME_TYPE and NETBIOS_EX_NAME_TYPE, at least NETBIOS_NAME_SIZE bytes are required for each name.
     */
    remote_len = OemRemote.MaximumLength;
    if (remote_len <= NETBIOS_NAME_SIZE) {
        remote_len = NETBIOS_NAME_SIZE + 1;
    }

    /* Calculate the needed buffer size */
    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
            NBT_DWORD_ALIGN(remote_len) +          // For OEM remote
            NBT_DWORD_ALIGN((NETBIOS_NAME_SIZE+1)*sizeof(OemEndpoint.Buffer[0]));
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        RtlFreeOemString(&OemRemote);
        RtlFreeOemString(&OemEndpoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;  // map to NETBIOS_EX

    // copy OEM EndpointName
    pNetBT->OEMEndpointName.Buffer =
            (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    pNetBT->OEMEndpointName.MaximumLength = NBT_DWORD_ALIGN((NETBIOS_NAME_SIZE+1));
    pNetBT->OEMEndpointName.Length = NETBIOS_NAME_SIZE;
    ASSERT((NETBIOS_NAME_SIZE % sizeof(OemRemote.Buffer[0])) == 0);
    if (OemEndpoint.Length < NETBIOS_NAME_SIZE) {
        memset(pNetBT->OEMEndpointName.Buffer + OemEndpoint.Length, ' ', NETBIOS_NAME_SIZE);
        CTEMemCopy(pNetBT->OEMEndpointName.Buffer, OemEndpoint.Buffer, OemEndpoint.Length);
    } else {
        CTEMemCopy(pNetBT->OEMEndpointName.Buffer, OemEndpoint.Buffer, NETBIOS_NAME_SIZE);
    }
    pNetBT->OEMEndpointName.Buffer[NETBIOS_NAME_SIZE] = 0;
    RtlFreeOemString(&OemEndpoint);

    // copy OEM RemoteName
    pNetBT->OEMRemoteName.Buffer =
        ((PUCHAR)pNetBT->OEMEndpointName.Buffer + pNetBT->OEMEndpointName.MaximumLength);
    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(remote_len);
    if (OemRemote.Length < NETBIOS_NAME_SIZE) {
        pNetBT->OEMRemoteName.Length = NETBIOS_NAME_SIZE;
        memset (pNetBT->OEMRemoteName.Buffer, ' ', NETBIOS_NAME_SIZE);
        CTEMemCopy(pNetBT->OEMRemoteName.Buffer, OemRemote.Buffer, OemRemote.Length);
        pNetBT->OEMRemoteName.Buffer[remote_len-1] = 0;
    } else {
        pNetBT->OEMRemoteName.Length = OemRemote.Length;
        CTEMemCopy(pNetBT->OEMRemoteName.Buffer, OemRemote.Buffer, OemRemote.MaximumLength);
    }
    RtlFreeOemString(&OemRemote);

    pNetBT->pNetbiosUnicodeEX = pTA->Address[0].Address;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

VOID
DeleteInternalAddress(IN PTA_NETBT_INTERNAL_ADDRESS pNetBT)
{
#if 0
    PTA_NETBT_INTERNAL_ADDRESS  p;

    p = CONTAINING_RECORD(pNetBT,PTA_NETBT_INTERNAL_ADDRESS,Address[0].Address);
    ASSERT(p->AddressCount == 1);
    ASSERT(p->Address[0].AddressLength == sizeof(TDI_ADDRESS_NETBT_INTERNAL));
    ASSERT(p->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
#endif
    if (pNetBT == NULL) {
        return;
    }
    ASSERT(pNetBT->TAAddressCount == 1);
    ASSERT(pNetBT->Address[0].AddressLength == sizeof(TA_NETBT_INTERNAL_ADDRESS));
    ASSERT(pNetBT->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
    CTEMemFree(pNetBT);
}

//----------------------------------------------------------------------------
NTSTATUS
NewInternalAddressFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
/*++

Routine Description

    This routine handles deciphering the weird transport address syntax
    and convert all types of NetBIOS address into one internal format.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    ppNetBT[0] = NULL;
    //
    // Check for the minimum acceptable length
    //
    if ((!pTransportAddress) || (MaxInputBufferLength < sizeof (TA_NETBIOS_ADDRESS))) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    switch (pTransportAddress->Address[0].AddressType)
    {
    case (TDI_ADDRESS_TYPE_NETBIOS):
        return NewInternalAddressFromNetbios(
                (PTA_NETBIOS_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);

#ifndef VXD
    case (TDI_ADDRESS_TYPE_NETBIOS_EX):
        return NewInternalAddressFromNetbiosEX(
                (PTA_NETBIOS_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);
#endif  // !VXD

    case (TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX):
        return NewInternalAddressFromUnicodeAddress(
                (PTA_NETBIOS_UNICODE_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);

    default:
        return (STATUS_INVALID_ADDRESS);
    }

    if (ppNetBT[0]->Address[0].Address[0].OEMRemoteName.Length > DNS_MAX_NAME_LENGTH) {
        DeleteInternalAddress(ppNetBT[0]);
        ppNetBT[0] = NULL;
        return (STATUS_NAME_TOO_LONG);
    }

    return (STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetNetBiosNameFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
/*++

Routine Description

    This routine handles deciphering the weird transport address syntax
    to retrieve the netbios name out of that address.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    //
    // Check for the minimum acceptable length
    //
    if ((!pTransportAddress) ||
        (MaxInputBufferLength < sizeof (TA_NETBIOS_ADDRESS)))
    {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    CTEZeroMemory(pNetBT, sizeof(pNetBT[0]));
    switch (pTransportAddress->Address[0].AddressType)
    {
    case (TDI_ADDRESS_TYPE_NETBIOS):
        return NetbiosAddressToInternalAddress(
                (PTA_NETBIOS_ADDRESS)pTransportAddress,
                MaxInputBufferLength, pNetBT);

#ifndef VXD
    case (TDI_ADDRESS_TYPE_NETBIOS_EX):
        return NetbiosEXAddressToInternalAddress(
                (PTA_NETBIOS_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, pNetBT);
#endif  // !VXD

        default:
        {
            return (STATUS_INVALID_ADDRESS);
        }
    }

    if (pNetBT->OEMRemoteName.Length > DNS_MAX_NAME_LENGTH)
    {
        return (STATUS_NAME_TOO_LONG);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
ConvertToAscii(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PCHAR            *pScope,
    OUT PULONG           pNameSize
    )
/*++

Routine Description:

    This routine converts half ascii to normal ascii and then appends the scope
    onto the end of the name to make a full name again.

Arguments:
    NumBytes    - the total number of bytes in the message starting from the
                  tNETBIOS_NAME structure - may include more than just the name itself

Return Value:

    NTSTATUS - success or not
    This routine returns the length of the name in half ascii format including
    the null at the end, but NOT including the length byte at the beginning.
    Thus, for a non-scoped name it would return 33.

    It converts the name to ascii and puts 16 bytes into pName, then it returns
    pScope as the Ptr to the scope that is still in pNameHdr.


--*/
{
    LONG     i, ScopeLength, lValue;
    ULONG    UNALIGNED    *pHdr;

    // 1st byte is length of the half ascii name, ie 32 (0x20) ==> (Length == 1 byte)
    // It should be followed by the half-ascii name            ==> (Length == 32 bytes)
    // Finally, it has the Scope information                   ==> (Length >= 1 byte)
    //
    if ((NumBytes > 1+NETBIOS_NAME_SIZE*2) && (*pNameHdr == NETBIOS_NAME_SIZE*2))
    {
        pHdr = (ULONG UNALIGNED *)++pNameHdr;  // to increment past the length byte

        // the Half AScii portion of the netbios name is always 32 bytes long
        for (i=0; i < NETBIOS_NAME_SIZE*2 ;i +=4 )
        {
            lValue = *pHdr - 0x41414141;  // four A's
            pHdr++;
            lValue =    ((lValue & 0x0F000000) >> 16) +
                        ((lValue & 0x000F0000) >> 4) +
                        ((lValue & 0x00000F00) >> 8) +
                        ((lValue & 0x0000000F) << 4);
            *(PUSHORT)pName = (USHORT)lValue;
            ((PUSHORT)pName)++;

        }

        // verify that the name has the correct format...i.e. it is one or more
        // labels each starting with the length byte for the label and the whole
        // thing terminated with a 0 byte (for the root node name length of zero).
        // count the length of the scope.

        // pHdr should be pointing to the first byte after the half ascii name.
        // (If there is no scope present, then pHdr must be pointing to the NULL byte)
        //
        // Also, check for an overflow on the maximum length of 256 bytes
        if ((STATUS_SUCCESS != (strnlen ((PUCHAR)pHdr, NumBytes-(1+NETBIOS_NAME_SIZE*2), &ScopeLength))) ||
            (ScopeLength > ((MAX_SCOPE_LENGTH+1)-NETBIOS_NAME_SIZE)))
        {
            // the name is too long..probably badly formed
            return(STATUS_UNSUCCESSFUL);
        }

        // Store the address of the start of the scope in the netbios name
        // (if one is present).
        //
        *pScope = (PUCHAR)pHdr;
        *pNameSize = NETBIOS_NAME_SIZE*2 + ScopeLength + 1;  // include the null at the end.
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }
}


//----------------------------------------------------------------------------
PCHAR
ConvertToHalfAscii(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pScope,
    IN  ULONG            uScopeSize
    )
/*++

Routine Description:

    This routine converts ascii to half ascii and appends the scope on the
    end

Arguments:


Return Value:

    the address of the next byte in the destination after the the name
    has been converted and copied

--*/
{
    LONG     i;

    // the first byte of the name is the length field = 2*16
    *pDest++ = ((UCHAR)NETBIOS_NAME_SIZE << 1);

    // step through name converting ascii to half ascii, for 32 times
    for (i=0; i < NETBIOS_NAME_SIZE ;i++ )
    {
        *pDest++ = ((UCHAR)*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    //
    // put the length of the scope into the next byte followed by the
    // scope itself.  For 1 length scopes (the normal case), writing
    // the zero(for the end of the scope is all that is needed).
    //
    if (uScopeSize > 1)
    {
        CTEMemCopy(pDest,pScope,uScopeSize);
        pDest = pDest + uScopeSize;
    }
    else
    {
        *pDest++ = 0;
    }

    // return the address of the next byte of the destination
    return(pDest);
}


//----------------------------------------------------------------------------
ULONG
Nbt_inet_addr(
    IN  PCHAR            pName,
    IN  ULONG            Flags
    )
/*++

Routine Description:

    This routine converts ascii ipaddr (11.101.4.25) into a ULONG.  This is
    based on the inet_addr code in winsock

Arguments:
    pName   - the string containing the ipaddress

Return Value:

    the ipaddress as a ULONG if it's a valid ipaddress.  Otherwise, 0.

--*/
{

    PCHAR    pStr;
    int      i;
    int      len, fieldLen;
    int      fieldsDone;
    ULONG    IpAddress;
    BYTE     ByteVal;
    PCHAR    pIpPtr;
    BOOLEAN  fDotFound;
    BOOLEAN  fieldOk;


    pStr = pName;
    len = 0;
    pIpPtr = (PCHAR)&IpAddress;
    pIpPtr += 3;                   // so that we store in network order
    fieldsDone=0;

    //
    // the 11.101.4.25 format can be atmost 15 chars, and pName is guaranteed
    // to be at least 16 chars long (how convenient!!).  Convert the string to
    // a ULONG.
    //
    while(len < NETBIOS_NAME_SIZE)
    {
        fieldLen=0;
        fieldOk = FALSE;
        ByteVal = 0;
        fDotFound = FALSE;

        //
        // This loop traverses each of the four fields (max len of each
        // field is 3, plus 1 for the '.'
        //
        while (fieldLen < 4)
        {
            if ((*pStr >='0') && (*pStr <='9'))
            {
                //
                // No Byte value should be greater than 255!
                // Bug#: 10487
                //
                if ((ByteVal > 25) ||
                    ((ByteVal == 25) && (*pStr > '5')))
                {
                    return (0);
                }
                ByteVal = (ByteVal*10) + (*pStr - '0');
                fieldOk = TRUE;
            }
            else if ((*pStr == '.') || (*pStr == ' ') || (*pStr == '\0'))
            {
                *pIpPtr = ByteVal;
                pIpPtr--;
                fieldsDone++;

                if (*pStr == '.')
                {
                    fDotFound = TRUE;
                }
                else    // (*pStr == ' ') || (*pStr == '\0')
                {
                    // if we got a space or 0, assume it's the 4th field
                    break;
                }
            }
            else        // unacceptable char: can't be ipaddr
            {
                return(0);
            }

            pStr++;
            len++;
            fieldLen++;

            // if we found the dot, we are done with this field: go to the next one
            if (fDotFound)
                break;
        }

        // this field wasn't ok (e.g. "11.101..4" or "11.101.4." etc.)
        if (!fieldOk)
        {
            return(0);
        }

        // if we are done with all 4 fields, we are done with the outer loop too
        if ( fieldsDone == 4)
            break;

        if (!fDotFound)
        {
            return(0);
        }
    }

    //
    // make sure the remaining NETBIOS_NAME_SIZE-1 chars are spaces or 0's
    // (i.e. don't allow 11.101.4.25xyz to succeed)
    //
    for (i=len; i<NETBIOS_NAME_SIZE-1; i++, pStr++)
    {
        if (*pStr != ' ' && *pStr != '\0')
        {
            return(0);
        }
    }

    if ((Flags & (SESSION_SETUP_FLAG|REMOTE_ADAPTER_STAT_FLAG)) &&
        (!(IS_UNIQUE_ADDR(IpAddress))))
    {
        KdPrint (("Nbt.Nbt_inet_addr: Address=<%15.15s> is not unique!\n", pName));
        IpAddress = 0;
    }
    return( IpAddress );
}


//----------------------------------------------------------------------------
tDGRAM_SEND_TRACKING *
NbtAllocInitTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description:

    This routine allocates memory for several of the structures attached to
    the dgram tracking list, so that this memory does not need to be
    allocated and freed for each send.

Arguments:

    ppListHead  - a ptr to a ptr to the list head

Return Value:

    none

--*/

{
    PLIST_ENTRY             pEntry;
    PTRANSPORT_ADDRESS      pTransportAddr;
    ULONG                   TotalSize;

    TotalSize = sizeof(tDGRAM_SEND_TRACKING)
              + sizeof(TDI_CONNECTION_INFORMATION)
              + sizeof(TRANSPORT_ADDRESS) -1
              + NbtConfig.SizeTransportAddress;
    
    //
    // If not Tracker was provided, then we will have to allocate one!
    //
    if (!pTracker)
    {
        //
        // allocate all the tracker memory as one block and then divy it up later
        // into the various buffers
        //
        if (pTracker = (tDGRAM_SEND_TRACKING *) NbtAllocMem (TotalSize, NBT_TAG2('07')))
        {
            NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER]++;
        }
    }

    if (pTracker)
    {
        CTEZeroMemory(pTracker,TotalSize);

        pTracker->Verify    = NBT_VERIFY_TRACKER;
        pTracker->RefCount  = 1;
        InitializeListHead (&pTracker->Linkage);
        InitializeListHead (&pTracker->TrackerList);    // Empty the list of trackers linked to this one

        pTracker->pSendInfo = (PTDI_CONNECTION_INFORMATION)((PUCHAR)pTracker + sizeof(tDGRAM_SEND_TRACKING));

        // fill in the connection information - especially the Remote address structure

        pTracker->pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1
                                                   + pNbtGlobConfig->SizeTransportAddress;

        // allocate the remote address structure
        pTransportAddr = (PTRANSPORT_ADDRESS) ((PUCHAR)pTracker->pSendInfo
                                              + sizeof(TDI_CONNECTION_INFORMATION));

        // fill in the remote address
        pTransportAddr->TAAddressCount = 1;
        pTransportAddr->Address[0].AddressLength = NbtConfig.SizeTransportAddress;
        pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = NBT_NAMESERVICE_UDP_PORT;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = 0L;

        // put a ptr to this address structure into the sendinfo structure
        pTracker->pSendInfo->RemoteAddress = (PVOID)pTransportAddr;
    }

    return(pTracker);
}

//----------------------------------------------------------------------------
#define MAX_FREE_TRACKERS   50

ULONG   NumFreeTrackers = 0;

// #if DBG
ULONG   TrackTrackers[NBT_TRACKER_NUM_TRACKER_TYPES];
ULONG   TrackerHighWaterMark[NBT_TRACKER_NUM_TRACKER_TYPES];
// #endif   // DBG


NTSTATUS
GetTracker(
    OUT tDGRAM_SEND_TRACKING    **ppTracker,
    IN  enum eTRACKER_TYPE      TrackerType)
/*++
Routine Description:

    This Routine gets a Tracker data structure to track sending a datagram
    or session packet.

Arguments:

Return Value:

    Status - STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES

--*/

{
    PLIST_ENTRY             pListEntry;
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = NULL;
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;

    CTESpinLock(&NbtConfig,OldIrq);
    if (!IsListEmpty(&NbtConfig.DgramTrackerFreeQ))
    {
        pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
        pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
        NumFreeTrackers--;
    }
    else if (NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER] >= NbtConfig.iMaxNumBuff[eNBT_DGRAM_TRACKER])
    {
        CTESpinFree(&NbtConfig,OldIrq);
        KdPrint(("GetTracker: WARNING:  Tracker leak -- Failing request!\n")) ;
        *ppTracker = NULL;
        return (status);
    }

    if (pTracker = NbtAllocInitTracker (pTracker))
    {
// #if DBG
        pTracker->TrackerType = TrackerType;
        InsertTailList (&UsedTrackers, &pTracker->DebugLinkage);    // keep tracker on a used list for debug

        TrackTrackers[TrackerType]++;
        if (TrackTrackers[TrackerType] > TrackerHighWaterMark[TrackerType])
        {
            TrackerHighWaterMark[TrackerType] = TrackTrackers[TrackerType];
        }
// #endif
        status = STATUS_SUCCESS;
    }

    CTESpinFree(&NbtConfig,OldIrq);

    *ppTracker = pTracker;
    return (status);
}


//----------------------------------------------------------------------------
VOID
FreeTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN ULONG                    Actions
    )
/*++

Routine Description:

    This routine cleans up a Tracker block and puts it back on the free
    queue.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pListEntry;

    CTESpinLock(&NbtConfig,OldIrq);

    //
    CHECK_PTR(pTracker);
    if (!NBT_VERIFY_HANDLE(pTracker, NBT_VERIFY_TRACKER))   // Bad pointer -- don't mess with it!
    {
        CTESpinFree(&NbtConfig,OldIrq);
        DbgPrint("Nbt.FreeTracker:  ERROR!  Bad Tracker ptr @<%p>\n", pTracker);
        ASSERT(0);
        return;
    }

    if (Actions & REMOVE_LIST)
    {
        //
        // unlink the tracker block from the NodeStatus Q
        RemoveEntryList(&pTracker->Linkage);
    }

    if (Actions & FREE_HDR)
    {
        // return the datagram hdr to the free pool
        //
        if (pTracker->SendBuffer.pDgramHdr)
        {
            CTEMemFree((PVOID)pTracker->SendBuffer.pDgramHdr);
        }
        // Free the RemoteName storage
        //
        if (pTracker->pRemoteName)
        {
            CTEMemFree((PVOID)pTracker->pRemoteName);
            pTracker->pRemoteName = NULL;
        }
        if (pTracker->UnicodeRemoteName) {
            CTEMemFree((PVOID)pTracker->UnicodeRemoteName);
            pTracker->UnicodeRemoteName = NULL;
        }
    }

#ifdef MULTIPLE_WINS
    if (pTracker->pFailedIpAddresses)
    {
        CTEMemFree((PVOID)pTracker->pFailedIpAddresses);
        pTracker->pFailedIpAddresses = NULL;
    }
#endif

    if (pTracker->IpList)
    {
        ASSERT(pTracker->NumAddrs);
        CTEMemFree(pTracker->IpList);
    }

    ASSERT (IsListEmpty (&pTracker->TrackerList));
    InitializeListHead(&pTracker->TrackerList);
    InsertTailList (&NbtConfig.DgramTrackerFreeQ, &pTracker->Linkage);

    pTracker->Verify = NBT_VERIFY_TRACKER_DOWN;

// #IF DBG
    TrackTrackers[pTracker->TrackerType]--;
    RemoveEntryList(&pTracker->DebugLinkage);
// #endif // DBG

    if (NumFreeTrackers > MAX_FREE_TRACKERS)
    {
        //
        // We already have the required # of free trackers available
        // in our pool, so just free the oldest Tracker
        //
        pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
        pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
        CTEMemFree (pTracker);
        NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER]--;
    }
    else
    {
        NumFreeTrackers++;
    }

    CTESpinFree(&NbtConfig,OldIrq);
}



//----------------------------------------------------------------------------
NTSTATUS
NbtInitTrackerQ(
    LONG        iNumBuffers
    )

/*++

Routine Description:

    This routine allocates memory blocks for doubly linked lists and links
    them to a list.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int                     i;
    tDGRAM_SEND_TRACKING    *pTracker;

    for (i=0; i<iNumBuffers; i++)
    {
        pTracker = NbtAllocInitTracker (NULL);
        if (!pTracker)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        else
        {
            InsertTailList (&NbtConfig.DgramTrackerFreeQ, &pTracker->Linkage);
            NumFreeTrackers++;
        }
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
#ifndef VXD
NTSTATUS
GetIrp(
    OUT PIRP *ppIrp)
/*++
Routine Description:

    This Routine gets an Irp from the free queue or it allocates another one
    the queue is empty.

Arguments:

Return Value:

    BOOLEAN - TRUE if IRQL is too high

--*/

{
    PLIST_ENTRY     pListEntry;
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    tDEVICECONTEXT  *pDeviceContext;
    PIRP            pIrp;

    // get an Irp from the list
    CTESpinLock(&NbtConfig,OldIrq);
    status = STATUS_SUCCESS;
    if (!IsListEmpty(&NbtConfig.IrpFreeList))
    {
        pListEntry = RemoveHeadList(&NbtConfig.IrpFreeList);
        *ppIrp = CONTAINING_RECORD(pListEntry,IRP,Tail.Overlay.ListEntry);
    }
    else
    {
        // check if we are allowed to allocate more memory blocks
        if (NbtConfig.iCurrentNumBuff[eNBT_FREE_IRPS] >= NbtConfig.iMaxNumBuff[eNBT_FREE_IRPS]  )
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {

            // use the first device in the list of adapter since we need to know
            // the stack size of the Irp we are creating. It is possible to
            // get here before we have put the first device on the context Q,
            // especially for proxy operation, so check if the list is empty
            // or not first.
            //
            if (IsListEmpty(&NbtConfig.DeviceContexts))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                pListEntry = NbtConfig.DeviceContexts.Flink;
                pDeviceContext = CONTAINING_RECORD(pListEntry,tDEVICECONTEXT,Linkage);

                if (!(pIrp = NTAllocateNbtIrp(&pDeviceContext->DeviceObject)))
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    *ppIrp = pIrp;

                    //
                    // Irp allocated - Increment the #
                    //
                    NbtConfig.iCurrentNumBuff[eNBT_FREE_IRPS]++;
                }
            }
        }
    }

    CTESpinFree(&NbtConfig,OldIrq);
//#if DBG
    if (status == STATUS_SUCCESS)
    {
        ADD_TO_LIST(&UsedIrps,&(*ppIrp)->ThreadListEntry);
    }
//#endif

    return(status);
}
#endif //!VXD

//----------------------------------------------------------------------------
ULONG
CountLocalNames(IN tNBTCONFIG  *pNbtConfig
    )
/*++
Routine Description:

    This Routine counts the number of names in the local name table.

Arguments:

Return Value:

    ULONG  - the number of names

--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    ULONG           Count;
    tNAMEADDR       *pNameAddr;
    LONG            i;

    Count = 0;

    for (i=0;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {
        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            //
            // don't want unresolved names, or the broadcast name
            //
            if (!(pNameAddr->NameTypeState & STATE_RESOLVING) &&
                (pNameAddr->Name[0] != '*'))
            {
                Count++;
            }
        }
    }

    return(Count);
}
//----------------------------------------------------------------------------
ULONG
CountUpperConnections(
    IN tDEVICECONTEXT  *pDeviceContext
    )
/*++
Routine Description:

    This Routine counts the number of upper connections that have been created
    in preparation for creating an equivalent number of lower connections.


Arguments:

Return Value:

    ULONG  - the number of names

--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pClientHead;
    PLIST_ENTRY     pConnHead;
    PLIST_ENTRY     pClientEntry;
    PLIST_ENTRY     pConnEntry;
    ULONG           CountConnections = 0;
    tADDRESSELE     *pAddressEle;
    tCLIENTELE      *pClient;
    tCONNECTELE     *pConnEle;
    CTELockHandle   OldIrq1, OldIrq2, OldIrq3;

    //
    // Need to hold JointLock before accessing AddressHead!
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // get the list of addresses for this device
    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;

    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        //
        // Need to hold pAddressEle lock before accessing ClientHead!
        //
        CTESpinLock(pAddressEle,OldIrq2);

        pClientHead = &pAddressEle->ClientHead;
        pClientEntry = pClientHead->Flink;
        while (pClientEntry != pClientHead)
        {
            pClient = CONTAINING_RECORD(pClientEntry,tCLIENTELE,Linkage);

            //
            // Need to hold pClient lock before accessing ConnectHead!
            //
            CTESpinLock(pClient, OldIrq3);

            pConnHead = &pClient->ConnectHead;
            pConnEntry = pConnHead->Flink;
            while (pConnEntry != pConnHead)
            {
                pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CountConnections++;
                }

                pConnEntry = pConnEntry->Flink;
            }
            CTESpinFree(pClient, OldIrq3);

            pClientEntry = pClientEntry->Flink;
        }
        CTESpinFree(pAddressEle, OldIrq2);

        pEntry = pEntry->Flink;
    }

    CTESpinFree(&NbtConfig.JointLock, OldIrq1);

    return(CountConnections);
}



//----------------------------------------------------------------------------
NTSTATUS
DisableInboundConnections(
    IN   tDEVICECONTEXT *pDeviceContext
    )
/*++

Routine Description:

    This routine checks the devicecontext for open connections and sets
    the  Lower Connection free list to empty.

Arguments:

Return Value:

    none

--*/

{
    CTELockHandle       OldIrqJoint;
    CTELockHandle       OldIrqDevice;
    CTELockHandle       OldIrqConn;
    CTELockHandle       OldIrqLower;
    tLOWERCONNECTION    *pLowerConn;
    NTSTATUS            status;
    PVOID               ConnectContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);
    CTESpinLock(pDeviceContext,OldIrqDevice);

    //
    // First take care of the free connections
    //
    while (!IsListEmpty (&pDeviceContext->LowerConnFreeHead))
    {
        pLowerConn = CONTAINING_RECORD (pDeviceContext->LowerConnFreeHead.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        //
        // close the lower connection with the transport
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);
    }
    ASSERT (pDeviceContext->NumFreeLowerConnections == 0);

    //
    // Now go through the list of Inbound connections and cleanup!
    //
    while (!IsListEmpty (&pDeviceContext->WaitingForInbound))
    {
        pLowerConn = CONTAINING_RECORD(pDeviceContext->WaitingForInbound.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        SET_STATE_LOWER(pLowerConn, NBT_IDLE);  // so that Inbound doesn't start processing it!
        if (pLowerConn->SpecialAlloc)
        {
            InterlockedDecrement(&pLowerConn->pDeviceContext->NumSpecialLowerConn);
        }

        ASSERT (pLowerConn->RefCount == 2);
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, TRUE); // RefCount will go to 1
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);// This should close all the Tcp handles
        InterlockedDecrement (&pDeviceContext->NumWaitingForInbound);
    }
    ASSERT (pDeviceContext->NumWaitingForInbound == 0);


    // ******************************************
    // NOTE: The code after this point can probably be deleted
    // because TCP should disconnect all open connections when it
    // is notified of the address change. Just use this code for test.
    //

    //
    // Now go through the list of active Lower connections to see which are
    // still up and issue disconnects on them.
    //
    while (!IsListEmpty (&pDeviceContext->LowerConnection))
    {
        pLowerConn = CONTAINING_RECORD (pDeviceContext->LowerConnection.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_DISABLE_INBOUND);

        CTESpinFree(pDeviceContext,OldIrqDevice);
        CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);

        CTESpinLock(pLowerConn,OldIrqLower);

        //
        // In the connecting state the TCP connection is being
        // setup.
        //
        if ((pLowerConn->State == NBT_SESSION_UP) ||
            (pLowerConn->State == NBT_CONNECTING))
        {
            tCLIENTELE  *pClientEle;
            tCONNECTELE *pConnEle;

            if (pLowerConn->State == NBT_CONNECTING)
            {
                // CleanupAfterDisconnect expects this ref count
                // to be 2, meaning that it got connected, so increment
                // here
                NBT_REFERENCE_LOWERCONN(pLowerConn, REF_LOWC_CONNECTED);
            }

            pClientEle = pLowerConn->pUpperConnection->pClientEle;
            pConnEle = pLowerConn->pUpperConnection;
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTED);
            SetStateProc(pLowerConn,RejectAnyData);

            CTESpinFree(pLowerConn,OldIrqLower);

            ConnectContext = pConnEle->ConnectContext;
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

            if (pClientEle->evDisconnect)
            {
                status = (*pClientEle->evDisconnect)(pClientEle->DiscEvContext,
                                            ConnectContext,
                                            0,
                                            NULL,
                                            0,
                                            NULL,
                                            TDI_DISCONNECT_ABORT);
            }

            // this should kill of the connection when the irp
            // completes by calling CleanupAfterDisconnect.
            //
#ifndef VXD
            status = DisconnectLower(pLowerConn,
                                     NBT_SESSION_UP,
                                     TDI_DISCONNECT_ABORT,
                                     &DefaultDisconnectTimeout,
                                     TRUE);
#else
            // Vxd can't wait for the disconnect
            status = DisconnectLower(pLowerConn,
                                     NBT_SESSION_UP,
                                     TDI_DISCONNECT_ABORT,
                                     &DefaultDisconnectTimeout,
                                     FALSE);

#endif
        }
        else if (pLowerConn->State == NBT_IDLE)
        {
            tCONNECTELE     *pConnEle;

            CTESpinFree(pLowerConn,OldIrqLower);
            CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);

            if (pConnEle = pLowerConn->pUpperConnection)
            {
                CTESpinLock(pConnEle,OldIrqConn);
                //
                // this makes a best effort to find the connection and
                // and cancel it.  Anything not cancelled will eventually
                // fail with a bad ret code from the transport which is
                // ok too.
                //
                status = CleanupConnectingState(pConnEle,pDeviceContext, &OldIrqConn,&OldIrqLower);
                CTESpinFree(pConnEle,OldIrqConn);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);
        }
        else
        {
            CTESpinFree(pLowerConn,OldIrqLower);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);
        CTESpinLock(pDeviceContext,OldIrqDevice);

        //
        // remove the reference added above when the list was
        // created.
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_DISABLE_INBOUND, TRUE);
    }

    CTESpinFree(pDeviceContext,OldIrqDevice);
    CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
ReRegisterLocalNames(
    IN   tDEVICECONTEXT *pDeviceContext,
    IN  BOOLEAN         fSendNameRelease
    )

/*++

Routine Description:

    This routine re-registers names with WINS when DHCP changes the IP
    address.

Arguments:

    pDeviceContext - ptr to the devicecontext

Return Value:

    status

--*/

{
    NTSTATUS                status;
    tTIMERQENTRY            *pTimerEntry;
    CTELockHandle           OldIrq;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead1;
    PLIST_ENTRY             pEntry1;
    PLIST_ENTRY             pHead2;
    PLIST_ENTRY             pEntry2;
    tDEVICECONTEXT          *pRelDeviceContext;
    tDEVICECONTEXT          *pSrcIpDeviceContext;
    tNAMEADDR               *pNameAddr;
    tDGRAM_SEND_TRACKING    *pTracker = NULL;
    CTEULONGLONG            ReRegisterMask;
    CTESystemTime           CurrentTime;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint (("Nbt.ReRegisterLocalNames Called on Device=<%x>...\n",
            pDeviceContext));

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (fSendNameRelease)
    {
        CTEQuerySystemTime (CurrentTime);

        if (((CurrentTime.QuadPart-NbtConfig.LastForcedReleaseTime.QuadPart)
             <= (TWO_MINUTES*10000)) ||                               // Check in 100 nanosec units
            (!(NT_SUCCESS(GetTracker(&pTracker,NBT_TRACKER_RELEASE_REFRESH)))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.ReRegisterLocalNames: ERROR: Name Release -- last Release interval=<%d>Secs\n",
                (LONG) ((CurrentTime.QuadPart-NbtConfig.LastForcedReleaseTime.QuadPart)/(1000*10000))));
            return (STATUS_IO_TIMEOUT);
        }

        NbtConfig.LastForcedReleaseTime = CurrentTime;
    }

    if (pTimerEntry = NbtConfig.pRefreshTimer)
    {
        NbtConfig.pRefreshTimer = NULL;
        status = StopTimer(pTimerEntry,NULL,NULL);
    }

    //
    // restart timer and use
    // the initial refresh rate until we can contact the name server
    //
    NbtConfig.MinimumTtl = NbtConfig.InitialRefreshTimeout;
    NbtConfig.RefreshDivisor = REFRESH_DIVISOR;

    //
    // set this to 3 so that refreshBegin will refresh to the primary and
    // then switch to backup on the next refresh interval if it doesn't
    // get through.
    //
    NbtConfig.sTimeoutCount = 3;

    NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    status = StartTimer(RefreshTimeout,
                        NbtConfig.InitialRefreshTimeout/NbtConfig.RefreshDivisor,
                        NULL,            // context value
                        NULL,            // context2 value
                        NULL,
                        NULL,
                        NULL,           // This is a Global Timer!
                        &pTimerEntry,
                        0,
                        TRUE);

    if ( !NT_SUCCESS( status ) )
    {
        if (pTracker)
        {
            FreeTracker(pTracker, RELINK_TRACKER);
        }
    
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return status ;
    }
    NbtConfig.pRefreshTimer = pTimerEntry;

    //
    // If a Device was specified to ReRegister on, then Zero out only the
    // bit for this Device in the RefreshMask for each name
    // otherwise, ReRegister on all Devices (Zero out all bits!)
    //
    if (pDeviceContext)
    {
        ReRegisterMask = ~pDeviceContext->AdapterMask;    // Only bit for this Device is 0
        pDeviceContext->DeviceRefreshState &= ~NBT_D_REFRESHING_NOW;
    }
    else
    {
        ReRegisterMask = 0;
    }

    for (i=0 ;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {

        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            //
            // set so that nextrefresh finds the name and does a refresh
            //
            if (!(pNameAddr->NameTypeState & STATE_RESOLVED) ||
                (pNameAddr->Name[0] == '*') ||
                (pNameAddr->NameTypeState & NAMETYPE_QUICK))
            {
                pEntry = pEntry->Flink;
                continue;
            }

            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE_REFRESH);

            if (fSendNameRelease)
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.ReRegisterLocalNames: Name=<%16.16s:%x>\n",
                        pNameAddr->Name,pNameAddr->Name[15]));

                pTracker->pNameAddr = pNameAddr;

                //
                // Release this name on all the devices (brute force method)!
                //
                pHead1 = &NbtConfig.DeviceContexts;
                pEntry1 = pHead1->Flink;
                while (pEntry1 != pHead1)
                {
                    pSrcIpDeviceContext = CONTAINING_RECORD(pEntry1,tDEVICECONTEXT,Linkage);
                    if ((pSrcIpDeviceContext->IpAddress == 0) ||
                        (!NBT_REFERENCE_DEVICE (pSrcIpDeviceContext, REF_DEV_REREG, TRUE)))
                    {
                        pEntry1 = pEntry1->Flink;
                        continue;
                    }

                    pHead2 = &NbtConfig.DeviceContexts;
                    pEntry2 = pHead2->Flink;
                    while (pEntry2 != pHead2)
                    {
                        //
                        // See if we need to release on this device
                        //
                        pRelDeviceContext = CONTAINING_RECORD(pEntry2,tDEVICECONTEXT,Linkage);
                        if ((pRelDeviceContext->IpAddress == 0) ||
                            (!NBT_REFERENCE_DEVICE (pRelDeviceContext, REF_DEV_REREG, TRUE)))
                        {
                            pEntry2 = pEntry2->Flink;
                            continue;
                        }

                        //
                        // Send the NameRelease to the Primary and Secondary Wins!
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        pTracker->pDeviceContext = pRelDeviceContext;
                        pTracker->SendBuffer.pDgramHdr = NULL; // catch erroneous frees
                        pTracker->RemoteIpAddress = pSrcIpDeviceContext->IpAddress;
                        pTracker->TransactionId = 0;

                        // Primary Wins ...
                        pTracker->Flags = NBT_NAME_SERVER | NBT_USE_UNIQUE_ADDR;
                        pTracker->RefCount = 2;
                        status = UdpSendNSBcast(pNameAddr,NbtConfig.pScope,pTracker,
                                    NULL, NULL, NULL, 0, 0, eNAME_RELEASE, TRUE);
                        // Secondary Wins ...
                        pTracker->Flags = NBT_NAME_SERVER_BACKUP | NBT_USE_UNIQUE_ADDR;
                        pTracker->RefCount = 2;
                        status = UdpSendNSBcast(pNameAddr,NbtConfig.pScope,pTracker,
                                    NULL, NULL, NULL, 0, 0, eNAME_RELEASE, TRUE);

                        CTESpinLock(&NbtConfig.JointLock,OldIrq);

                        pEntry2 = pRelDeviceContext->Linkage.Flink;
                        NBT_DEREFERENCE_DEVICE (pRelDeviceContext, REF_DEV_REREG, TRUE);
                    }

                    pEntry1 = pSrcIpDeviceContext->Linkage.Flink;
                    NBT_DEREFERENCE_DEVICE (pSrcIpDeviceContext, REF_DEV_REREG, TRUE);
                }
            }

            pNameAddr->RefreshMask &= ReRegisterMask;
            pNameAddr->Ttl = NbtConfig.InitialRefreshTimeout;

            pEntry = pNameAddr->Linkage.Flink;
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE_REFRESH, TRUE);
        }
    }

    if (pTracker)
    {
        FreeTracker(pTracker, RELINK_TRACKER);
    }

    // start a refresh if there isn't one currently going on
    // Note that there is a time window here that if the refresh is
    // currently going on then, some names will not get refreshed with
    // the new IpAddress right away, but have to wait to the next
    // refresh interval.  It seems that this is a rather unlikely
    // scenario and given the low probability of DHCP changing the
    // address it makes even less sense to add the code to handle that
    // case.
    //

    if (NT_SUCCESS(CTEQueueForNonDispProcessing (DelayedRefreshBegin, NULL, NULL, NULL, NULL, TRUE)))
    {
        NbtConfig.GlobalRefreshState |= NBT_G_REFRESHING_NOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
NbtStopRefreshTimer(
    )
{
    tTIMERQENTRY                *pTimerEntry;
    CTELockHandle               OldIrq;

    //
    // Stop the regular Refresh Timer
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTimerEntry = NbtConfig.pRefreshTimer)
    {
        NbtConfig.pRefreshTimer = NULL;
        StopTimer (pTimerEntry, NULL, NULL);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
NTSTATUS
strnlen(
    PUCHAR  pSrcString,
    LONG    MaxBufferLength,
    LONG    *pStringLen
    )
{
    LONG    iIndex = 0;

    while ((iIndex < MaxBufferLength-1) && (*pSrcString))
    {
        iIndex++;
        pSrcString++;
    }

    if (*pSrcString)
    {
        ASSERT(0);
        *pStringLen = 0;
        return (STATUS_UNSUCCESSFUL);
    }

    *pStringLen = iIndex;
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\proxy.c ===
//
//
//  proxy.c
//
//  This file contains the Proxy related functions that implement the Bnode
//  proxy functionality.  This allows a Bnode to make use of a Name Service
//  transparently since the proxy code picks up the Bnode Query broadcasts directly
//  and either answers them directly or queries the NS and then answers them
//  later.
//  code

#include "precomp.h"
#include <ipinfo.h>
#include "proxy.tmh"

VOID
ProxyClientCompletion(
  IN PVOID            pContext,
  IN NTSTATUS         status
 );


#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
RegOrQueryFromNet(
    IN  BOOL                fReg,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  PCHAR               pNameInPkt,
    IN  PUCHAR              pScope
    )
/*++

Routine Description:

    This function handles a name registration/name overwrite  or a name
    query that comes over the subnet.  It checks the remote name table.  If
    the name is there, the function simply returns.  If the name is not
    there, the function calls QueryNameOnNet to add the name to the remote table
    (in the resolving state) and to query the NS.

    Note: If the name is there in the table, it may or may not have the same
          address as the registration that we got or it may be of a different
          type.  Not doing anything for this case is ok as explained below.


Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to the net

Called By:
        QueryFromNet() in inbound.c, NameSrvHndlrNotOs() in hndlrs.c
--*/
{
    tGENERALRR          *pResrcRecord;
    ULONG               IpAddress;
    BOOLEAN             bGroupName;
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;


    //
    // if we have heard a registration on the net, get the IP address
    // and the type of registration (unique/group) from the packet.
    //
    // if we have heard a query, use default values for the above two
    // fields
    //
    if (fReg)
    {
      // get the Ip address out of the Registration request
      pResrcRecord = (tGENERALRR *) &pNameHdr->NameRR.NetBiosName[lNameSize];
      IpAddress  = ntohl(pResrcRecord->IpAddress);
      bGroupName = pResrcRecord->Flags & FL_GROUP;
    }
    else
    {
      IpAddress  = 0;
      bGroupName = NBT_UNIQUE;  //default value
    }
    //
    // The name is not there in the remote name table.
    // Add it in the RESOLVING state and send a name query
    // to the NS.
    //


    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (NbtConfig.ProxyType == PROXY_WINS) {
        NbtTrace(NBT_TRACE_PROXY, ("Send WINS Proxy query %!NBTNAME!<%02x> on %!ipaddr!",
                                    pNameInPkt, (unsigned)pNameInPkt[15], pDeviceContext->IpAddress));
        QueryNameOnNet (pNameInPkt,
                    pScope,
                    bGroupName,
                    NULL,   //client context
                    ProxyClientCompletion,
                    PROXY| (fReg?PROXY_REG: 0),
                    NULL,     //we want to add the name(pNameAddr = NULL)
                    pDeviceContext,
                    &OldIrq);
    } else {
        pHead = &NbtConfig.DeviceContexts;
        pEntry = pHead->Flink;
        while (pEntry != pHead) {
            tDEVICECONTEXT      *dev;

            dev = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            pEntry = pEntry->Flink;

            /*
             * Make sure we are not getting the device from the DeviceAwaitingDeletion.
             * It could happen since QueryNameOnNet could temporarily release the JointLock.
             */
            if (dev->Verify != NBT_VERIFY_DEVCONTEXT) {
                break;
            }

            if (dev->IpAddress == 0 || dev->IpAddress == LOOP_BACK ||
                (!fReg && (dev->RasProxyFlags & PROXY_RAS_NONAMEQUERYFORWARDING))) {
                continue;
            }
            if (dev == pDeviceContext) {
                /* We don't want to broadcast back to the same interface through which we receive */
                continue;
            }

            /*
             * Reference the device so that it won't disappear inside QueryNameOnNet
             * Note: QueryNameOnNet may temporarily release the JointLock
             */
            NBT_REFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
            NbtTrace(NBT_TRACE_PROXY, ("Send RAS Proxy query %!NBTNAME!<%02x> on %!ipaddr!",
                                    pNameInPkt, (unsigned)pNameInPkt[15], dev->IpAddress));
            QueryNameOnNet (pNameInPkt,
                        pScope,
                        bGroupName,
                        NULL,   //client context
                        ProxyClientCompletion,
                        PROXY| (fReg?PROXY_REG: 0),
                        NULL,     //we want to add the name(pNameAddr = NULL)
                        dev,
                        &OldIrq);

            /*
             * Since the QueryNameOnNet could release the lock temporarily, it is possible
             * that the device is deleted (removing from the NbtConfig.DeviceContexts
             * list) after QueryNameOnNet returns.
             * Worse than that, the pEntry may also be removed. The IP address of pEntry
             * will be 0.0.0.0 and pEntry->Flink == pEntry. We could end up with a indefinite
             * looping above.
             */
            pEntry = dev->Linkage.Flink;
            if (dev->IpAddress == 0 || dev->Verify != NBT_VERIFY_DEVCONTEXT || pEntry->Flink == pEntry) {
                /*
                 * In this case, we cannot go ahead because dev->Linkage.Flink may not
                 * be valid. pEntry may not be valid also. Simply stop here.
                 */
                NBT_DEREFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
                break;
            }
            NBT_DEREFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
VOID
ProxyTimerComplFn (
  IN PVOID            pContext,
  IN PVOID            pContext2,
  IN tTIMERQENTRY    *pTimerQEntry
 )

/*++

Routine Description:

       This function either deletes the name from the remote name table
        if fReg is FALSE (i.e. the timer has expired on a name query
        sent by the Proxy on behalf of a node doing a name query) or changes
        the state to RESOLVED if fReg is  TRUE (i.e. the timer has expired
        on a name query sent on  behalf of a node doing name registration)

Arguments:
       pfReg  - indicates whether the timer expiry is for a name
                query

Return Value:

    NTSTATUS - success or not - failure means no response to the net

--*/
{

    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tNAMEADDR               *pNameAddrNew;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((--pTimerQEntry->Retries) == 0)     // The Retires have expired
    {
        if (!(pTracker->Flags & NBT_NAME_SERVER))
        {
            //
            // If pContext2 is not 0, it means that this timer function was
            // called by the proxy for a query which it sent on hearing a
            // registration on the net.  If pContext2 is  0, it means
            // that the timer function was called by the proxy  for a query
            // which it sent on hearing a query on the net.
            //
            pTimerQEntry->ClientCompletion = NULL;

            //
            // Mark the entry as released.  Do not dereference the name
            // The entry will remain in the remote hash table.  When the proxy
            // code sees a query or registration for a released entry in the
            // cache it does not query the name server. This cuts down on
            // name server traffic.  The released entries are removed from
            // the cache at cache timer expiry (kept small).

            //************************************

            // Changed:  Dereference the name because the name query timed
            // out meaning that we did not contact WINS, therefore we
            // do not know if the name is valid or not!
            //

            pNameAddr = pTracker->pNameAddr;
            CHECK_PTR(pNameAddr);
            pNameAddr->pTimer = NULL;           // remove the link from the name table to this timer block

//            NBT_PROXY_DBG(("ProxyTimerComplFn: State of name %16.16s(%X) changed to (%s)\n", pTracker->pNameAddr->Name, pTracker->pNameAddr->Name[15], "RELEASED"));


            // Remove from the pending Queries list - and put into the hash
            // table for 1 minute so we do not beat up on WINS if it is down
            // or slow right now.
            //
            RemoveEntryList (&pNameAddr->Linkage);
            InitializeListHead (&pNameAddr->Linkage);

            status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                     pNameAddr->Name,
                                     NbtConfig.pScope,
                                     pNameAddr->IpAddress,
                                     NBT_UNIQUE,
                                     NULL,
                                     &pNameAddrNew,
                                     pTracker->pDeviceContext,
                                     NAME_RESOLVED_BY_WINS | NAME_RESOLVED_BY_BCAST);
            if (NT_SUCCESS(status))
            {
                pNameAddrNew->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddrNew->NameTypeState |= STATE_RELEASED;

                pNameAddrNew->TimeOutCount = 60000 / REMOTE_HASH_TIMEOUT;
            }

            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
            NBT_DEREFERENCE_TRACKER (pTracker, TRUE);   // return the tracker block to its queue

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            return;
        }

        //
        // Can't reach the name server, so try the backup
        //
        pTracker->Flags &= ~NBT_NAME_SERVER;
        pTracker->Flags |= NBT_NAME_SERVER_BACKUP;

        // set the retry count again
        pTimerQEntry->Retries = NbtConfig.uNumRetries;
    }

    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            eNAME_QUERY,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}

//----------------------------------------------------------------------------
VOID
ProxyClientCompletion(
  IN PVOID            pContext,
  IN NTSTATUS         status
 )

/*++

Routine Description:

       This function does nothing since the proxy does not need to do anything
       when a name query succeeds.  The code in inbound.c does all that
       is necessary - namely put the name in the name table.

Arguments:

Return Value:


--*/
{

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\parse.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This source contains the functions that parse the lmhosts file.

Author:

    Jim Stewart           May 2, 1993

Revision History:


--*/

#include "precomp.h"
#include "hosts.h"
#include <ctype.h>
#include <string.h>

#include "parse.tmh"

#ifdef VXD
extern BOOL fInInit;
extern BOOLEAN CachePrimed;
#endif

//
//  Returns 0 if equal, 1 if not equal.  Used to avoid using c-runtime
//
#define strncmp( pch1, pch2, length ) \
    (!CTEMemEqu( pch1, pch2, length ) )


//
// Private Definitions
//
// As an lmhosts file is parsed, a #INCLUDE directive is interpreted
// according to the INCLUDE_STATE at that instance.  This state is
// determined by the #BEGIN_ALTERNATE and #END_ALTERNATE directives.
//
//
typedef enum _INCLUDE_STATE
{

    MustInclude = 0,                                    // shouldn't fail
    TryToInclude,                                       // in alternate block
    SkipInclude                                         // satisfied alternate
                                                        //  block
} INCLUDE_STATE;


//
// LmpGetTokens() parses a line and returns the tokens in the following
// order:
//
typedef enum _TOKEN_ORDER_
{

    IpAddress = 0,                                      // first token
    NbName,                                             // 2nd token
    GroupName,                                          // 3rd or 4th token
    NotUsed,                                            // #PRE, if any
    NotUsed2,                                           // #NOFNR, if any
    MaxTokens                                           // this must be last

} TOKEN_ORDER;


//
// As each line in an lmhosts file is parsed, it is classified into one of
// the categories enumerated below.
//
// However, Preload is a special member of the enum.
//
//
typedef enum _TYPE_OF_LINE
{

    Comment           = 0x0000,                         // comment line
    Ordinary          = 0x0001,                         // ip_addr NetBIOS name
    Domain            = 0x0002,                         // ... #DOM:name
    Include           = 0x0003,                         // #INCLUDE file
    BeginAlternate    = 0x0004,                         // #BEGIN_ALTERNATE
    EndAlternate      = 0x0005,                         // #END_ALTERNATE
    ErrorLine         = 0x0006,                         // Error in line

    NoFNR             = 0x4000,                         // ... #NOFNR
    Preload           = 0x8000                          // ... #PRE

} TYPE_OF_LINE;


//
// In an lmhosts file, the following are recognized as keywords:
//
//     #BEGIN_ALTERNATE        #END_ALTERNATE          #PRE
//     #DOM:                   #INCLUDE
//
// Information about each keyword is kept in a KEYWORD structure.
//
//
typedef struct _KEYWORD
{                               // reserved keyword

    char           *k_string;                           //  NULL terminated
    size_t          k_strlen;                           //  length of token
    TYPE_OF_LINE    k_type;                             //  type of line
    int             k_noperands;                        //  max operands on line

} KEYWORD, *PKEYWORD;


typedef struct _LINE_CHARACTERISTICS_
{

    int              l_category:4;                      // enum _TYPE_OF_LINE
    int              l_preload:1;                       // marked with #PRE ?
    unsigned int     l_nofnr:1;                         // marked with #NOFNR

} LINE_CHARACTERISTICS, *PLINE_CHARACTERISTICS;



//
// Do not allow DNS name queries for the following Name Types:
//
//  Name                Number(h)  Type     Usage
//  --------------------------------------------------------------------------
//  <computername>         01       Unique  Messenger Service
//  <\\--__MSBROWSE__>     01       Group   Master Browser
//  <domain>               1B       Unique  Domain Master Browser
//  <domain>               1C       Group   Domain Controllers
//  <INet~Services>        1C       Group   IIS
//  <domain>               1D       Unique  Master Browser
//  <domain>               1E       Group   Browser Service Elections

#define IsValidDnsNameTag(_c)       \
    ((_c != 0x01) &&                \
     ((_c < 0x1B) || (_c > 0x1E)))



//
// Local Variables
//
//
// In an lmhosts file, the token '#' in any column usually denotes that
// the rest of the line is to be ignored.  However, a '#' may also be the
// first character of a keyword.
//
// Keywords are divided into two groups:
//
//  1. decorations that must either be the 3rd or 4th token of a line,
//  2. directives that must begin in column 0,
//
//
KEYWORD Decoration[] =
{

    DOMAIN_TOKEN,   sizeof(DOMAIN_TOKEN) - 1,   Domain,         5,
    PRELOAD_TOKEN,  sizeof(PRELOAD_TOKEN) - 1,  Preload,        5,
    NOFNR_TOKEN,    sizeof(NOFNR_TOKEN) -1,     NoFNR,          5,

    NULL,           0                                   // must be last
};


KEYWORD Directive[] =
{

    INCLUDE_TOKEN,  sizeof(INCLUDE_TOKEN) - 1,  Include,        2,
    BEG_ALT_TOKEN,  sizeof(BEG_ALT_TOKEN) - 1,  BeginAlternate, 1,
    END_ALT_TOKEN,  sizeof(END_ALT_TOKEN) - 1,  EndAlternate,   1,

    NULL,           0                                   // must be last
};

//
// Local Variables
//
//
// Each preloaded lmhosts entry corresponds to NSUFFIXES NetBIOS names,
// each with a 16th byte from Suffix[].
//
// For example, an lmhosts entry specifying "popcorn" causes the
// following NetBIOS names to be added to nbt.sys' name cache:
//
//      "POPCORN         "
//      "POPCORN        0x0"
//      "POPCORN        0x3"
//
//
#define NSUFFIXES       3
UCHAR Suffix[] = {                                  // LAN Manager Component
    0x20,                                           //   server
    0x0,                                            //   redirector
    0x03                                            //   messenger
};

#ifndef VXD
//
// this structure tracks names queries that are passed up to user mode
// to resolve via DnsQueries
//
tLMHSVC_REQUESTS    DnsQueries;
tLMHSVC_REQUESTS    CheckAddr;
#endif
tLMHSVC_REQUESTS    LmHostQueries;   // Track names queries passed for LMhost processing
tDOMAIN_LIST    DomainNames;


//
// Local (Private) Functions
//
LINE_CHARACTERISTICS
LmpGetTokens (
    IN OUT      PUCHAR line,
    OUT PUCHAR  *token,
    IN OUT int  *pnumtokens
    );

PKEYWORD
LmpIsKeyWord (
    IN PUCHAR string,
    IN PKEYWORD table
    );

BOOLEAN
LmpBreakRecursion(
    IN PUCHAR path,
    IN PUCHAR target,
    IN ULONG  TargetLength
    );

LONG
HandleSpecial(
    IN char **pch);

ULONG
AddToDomainList (
    IN PUCHAR           pName,
    IN tIPADDRESS       IpAddress,
    IN PLIST_ENTRY      pDomainHead,
    IN BOOLEAN          fPreload
    );

NTSTATUS
ChangeStateOfName (
    IN      tIPADDRESS              IpAddress,
    IN      NBT_WORK_ITEM_CONTEXT   *pContext,
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext,
    IN      USHORT                  NameAddFlags
    );

VOID
LmHostTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

NBT_WORK_ITEM_CONTEXT *
GetNameToFind(
    OUT PUCHAR      pName
    );

VOID
GetContext (
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext
    );

VOID
MakeNewListCurrent (
    PLIST_ENTRY     pTmpDomainList
    );

VOID
RemoveNameAndCompleteReq (
    IN NBT_WORK_ITEM_CONTEXT    *pContext,
    IN NTSTATUS                 status
    );

PCHAR
Nbtstrcat( PUCHAR pch, PUCHAR pCat, LONG Len );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, LmGetIpAddr)
#pragma CTEMakePageable(PAGE, HandleSpecial)
#pragma CTEMakePageable(PAGE, LmpGetTokens)
#pragma CTEMakePageable(PAGE, LmpIsKeyWord)
#pragma CTEMakePageable(PAGE, LmpBreakRecursion)
#pragma CTEMakePageable(PAGE, AddToDomainList)
#pragma CTEMakePageable(PAGE, LmExpandName)
#pragma CTEMakePageable(PAGE, LmInclude)
#pragma CTEMakePageable(PAGE, LmGetFullPath)
#pragma CTEMakePageable(PAGE, PrimeCache)
#pragma CTEMakePageable(PAGE, DelayedScanLmHostFile)
#pragma CTEMakePageable(PAGE, NbtCompleteLmhSvcRequest)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

unsigned long
LmGetIpAddr (
    IN PUCHAR   path,
    IN PUCHAR   target,
    IN CHAR     RecurseDepth,
    OUT BOOLEAN *bFindName
    )

/*++

Routine Description:

    This function searches the file for an lmhosts entry that can be
    mapped to the second level encoding.  It then returns the ip address
    specified in that entry.

    This function is called recursively, via LmInclude() !!

Arguments:

    path        -  a fully specified path to a lmhosts file
    target      -  the unencoded 16 byte NetBIOS name to look for
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion

Return Value:

    The ip address (network byte order), or 0 if no appropriate entry was
    found.

    Note that in most contexts (but not here), ip address 0 signifies
    "this host."

--*/


{
    PUCHAR                     buffer;
    PLM_FILE                   pfile;
    NTSTATUS                   status;
    int                        count, nwords;
    INCLUDE_STATE              incstate;
    PUCHAR                     token[MaxTokens];
    LINE_CHARACTERISTICS       current;
    unsigned                   long inaddr, retval;
    UCHAR                      temp[NETBIOS_NAME_SIZE+1];

    CTEPagedCode();
    //
    // Check for infinitely recursive name lookup in a #INCLUDE.
    //
    if (LmpBreakRecursion(path, target, NETBIOS_NAME_SIZE-1) == TRUE)
    {
        return (0);
    }

#ifdef VXD
    //
    // if we came here via nbtstat -R and InDos is set, report error: user
    // can try nbtstat -R again.  (since nbtstat can only be run from DOS box,
    // can InDos be ever set???  Might as well play safe)
    //
    if ( !fInInit && GetInDosFlag() )
    {
       return(0);
    }
#endif

    pfile = LmOpenFile(path);

    if (!pfile)
    {
        return((unsigned long) 0);
    }

    *bFindName = FALSE;
    inaddr   = 0;
    incstate = MustInclude;

    while (buffer = LmFgets(pfile, &count))
    {

        nwords   = MaxTokens;
        current = LmpGetTokens(buffer, token, &nwords);

        switch ((ULONG)current.l_category)
        {
        case ErrorLine:
            continue;

        case Domain:
        case Ordinary:
            if (current.l_preload ||
              ((nwords - 1) < NbName))
            {
                continue;
            }
            break;

        case Include:
            if (!RecurseDepth || (incstate == SkipInclude) || (nwords < 2))
            {
                continue;
            }

            retval = LmInclude(token[1], LmGetIpAddr, target, (CHAR) (RecurseDepth-1), bFindName);

            if (retval != 0) {
                if (incstate == TryToInclude)
                {
                    incstate = SkipInclude;
                }
            } else {
                if (incstate == MustInclude)
                {
                    IF_DBG(NBT_DEBUG_LMHOST)
                        KdPrint(("Nbt.LmGetIpAddr: Can't #INCLUDE \"%s\"", token[1]));
                }
                continue;
            }
            inaddr = retval;
            goto found;

        case BeginAlternate:
            ASSERT(nwords == 1);
            incstate = TryToInclude;
            continue;

        case EndAlternate:
            ASSERT(nwords == 1);
            incstate = MustInclude;
            continue;

        default:
            continue;
        }

        if (strlen(token[NbName]) == (NETBIOS_NAME_SIZE))
        {
            if (strncmp(token[NbName], target, (NETBIOS_NAME_SIZE)) != 0)
            {
                continue;
            }
        } else
        {
            //
            // attempt to match, in a case insensitive manner, the first 15
            // bytes of the lmhosts entry with the target name.
            //
            LmExpandName(temp, token[NbName], 0);

            if (strncmp(temp, target, NETBIOS_NAME_SIZE - 1) != 0)
            {
                continue;
            }
        }

        if (current.l_nofnr)
        {
            *bFindName = TRUE;
        }
        status = ConvertDottedDecimalToUlong(token[IpAddress],&inaddr);
        if (!NT_SUCCESS(status))
        {
            inaddr = 0;
        }
        break;
    }

found:
    status = LmCloseFile(pfile);

    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status))
    {
        *bFindName = FALSE;
    }

    IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("Nbt.LmGetIpAddr: (\"%15.15s<%X>\") = %X\n",target,target[15],inaddr));


    return(inaddr);
} // LmGetIpAddr


//----------------------------------------------------------------------------
LONG
HandleSpecial(
    IN CHAR **pch)

/*++

Routine Description:

    This function converts ASCII hex into a ULONG.

Arguments:


Return Value:

    The ip address (network byte order), or 0 if no appropriate entry was
    found.

    Note that in most contexts (but not here), ip address 0 signifies
    "this host."

--*/


{
    int                         sval;
    int                         rval;
    char                       *sp = *pch;
    int                         i;

    CTEPagedCode();

    sp++;
    switch (*sp)
    {
    case '\\':
        // the second character is also a \ so  return a \ and set pch to
        // point to the next character (\)
        //
        *pch = sp;
        return((int)'\\');

    default:

        // convert some number of characters to hex and increment pch
        // the expected format is "\0x03"
        //
//        sscanf(sp, "%2x%n", &sval, &rval);

        sval = 0;
        rval = 0;
        sp++;

        // check for the 0x part of the hex number
        if (*sp != 'x')
        {
            *pch = sp;
            return(-1);
        }
        sp++;
        for (i=0;(( i<2 ) && *sp) ;i++ )
        {
            if (*sp != ' ')
            {
                // convert from ASCII to hex, allowing capitals too
                //
                if (*sp >= 'a')
                {
                    sval = *sp - 'a' + 10 + sval*16;
                }
                else
                if (*sp >= 'A')
                {
                    sval = *sp - 'A' + 10 + sval*16;
                }
                else
                {
                    sval = *sp - '0' + sval*16;
                }
                sp++;
                rval++;
            }
            else
                break;
        }

        if (rval < 1)
        {
            *pch = sp;
            return(-1);
        }

        *pch += (rval+2);    // remember to account for the characters 0 and x

        return(sval);

    }
}

#define LMHASSERT(s)  if (!(s)) \
{ retval.l_category = ErrorLine; return(retval); }

//----------------------------------------------------------------------------

LINE_CHARACTERISTICS
LmpGetTokens (
    IN OUT PUCHAR line,
    OUT PUCHAR *token,
    IN OUT int *pnumtokens
    )

/*++

Routine Description:

    This function parses a line for tokens.  A maximum of *pnumtokens
    are collected.

Arguments:

    line        -  pointer to the NULL terminated line to parse
    token       -  an array of pointers to tokens collected
    *pnumtokens -  on input, number of elements in the array, token[];
                   on output, number of tokens collected in token[]

Return Value:

    The characteristics of this lmhosts line.

Notes:

    1. Each token must be separated by white space.  Hence, the keyword
       "#PRE" in the following line won't be recognized:

            11.1.12.132     lothair#PRE

    2. Any ordinary line can be decorated with a "#PRE", a "#DOM:name" or
       both.  Hence, the following lines must all be recognized:

            111.21.112.3        kernel          #DOM:ntwins #PRE
            111.21.112.4        orville         #PRE        #DOM:ntdev
            111.21.112.7        cliffv4         #DOM:ntlan
            111.21.112.132      lothair         #PRE

--*/


{
    enum _PARSE
    {                                      // current fsm state

        StartofLine,
        WhiteSpace,
        AmidstToken

    } state;

    PUCHAR                     pch;                                        // current fsm input
    PUCHAR                     och;
    PKEYWORD                   keyword;
    int                        index, maxtokens, quoted, rchar;
    LINE_CHARACTERISTICS       retval;

    CTEPagedCode();
    CTEZeroMemory(token, *pnumtokens * sizeof(PUCHAR *));

    state             = StartofLine;
    retval.l_category = Ordinary;
    retval.l_preload  = 0;
    retval.l_nofnr    = 0;
    maxtokens         = *pnumtokens;
    index             = 0;
    quoted            = 0;

    for (pch = line; *pch; pch++)
    {
        switch (*pch)
        {

        //
        // does the '#' signify the start of a reserved keyword, or the
        // start of a comment ?
        //
        //
        case '#':
            if (quoted)
            {
                *och++ = *pch;
                continue;
            }
            keyword = LmpIsKeyWord(
                            pch,
                            (state == StartofLine) ? Directive : Decoration);

            if (keyword)
            {
                state     = AmidstToken;
                maxtokens = keyword->k_noperands;

                switch (keyword->k_type)
                {
                case NoFNR:
                    retval.l_nofnr = 1;
                    continue;

                case Preload:
                    retval.l_preload = 1;
                    continue;

                default:
                    LMHASSERT(maxtokens <= *pnumtokens);
                    LMHASSERT(index     <  maxtokens);

                    token[index++]    = pch;
                    retval.l_category = keyword->k_type;
                    continue;
                }

                LMHASSERT(0);
            }

            if (state == StartofLine)
            {
                retval.l_category = Comment;
            }
            /* fall through */

        case '\r':
        case '\n':
            *pch = (UCHAR) NULL;
            if (quoted)
            {
                *och = (UCHAR) NULL;
            }
            goto done;

        case ' ':
        case '\t':
            if (quoted)
            {
                *och++ = *pch;
                continue;
            }
            if (state == AmidstToken)
            {
                state = WhiteSpace;
                *pch  = (UCHAR) NULL;

                if (index == maxtokens)
                {
                    goto done;
                }
            }
            continue;

        case '"':
            if ((state == AmidstToken) && quoted)
            {
                state = WhiteSpace;
                quoted = 0;
                *pch  = (UCHAR) NULL;
                *och  = (UCHAR) NULL;

                if (index == maxtokens)
                {
                    goto done;
                }
                continue;
            }

            state  = AmidstToken;
            quoted = 1;
            LMHASSERT(maxtokens <= *pnumtokens);
            LMHASSERT(index     <  maxtokens);
            token[index++] = pch + 1;
            och = pch + 1;
            continue;

        case '\\':
            if (quoted)
            {
                rchar = HandleSpecial(&pch);
                if (rchar == -1)
                {
                    retval.l_category = ErrorLine;
                    return(retval);
                }
                *och++ = (UCHAR)rchar;
                //
                // put null on end of string
                //

                continue;
            }

        default:
            if (quoted)
            {
                *och++ = *pch;
                       continue;
            }
            if (state == AmidstToken)
            {
                continue;
            }

            state  = AmidstToken;

            LMHASSERT(maxtokens <= *pnumtokens);
            LMHASSERT(index     <  maxtokens);
            token[index++] = pch;
            continue;
        }
    }

done:
    //
    // if there is no name on the line, then return an error
    //
    if (index <= NbName && index != maxtokens)
    {
        retval.l_category = ErrorLine;
    }
    ASSERT(!*pch);
    ASSERT(maxtokens <= *pnumtokens);
    ASSERT(index     <= *pnumtokens);

    *pnumtokens = index;
    return(retval);
} // LmpGetTokens



//----------------------------------------------------------------------------

PKEYWORD
LmpIsKeyWord (
    IN PUCHAR string,
    IN PKEYWORD table
    )

/*++

Routine Description:

    This function determines whether the string is a reserved keyword.

Arguments:

    string  -  the string to search
    table   -  an array of keywords to look for

Return Value:

    A pointer to the relevant keyword object, or NULL if unsuccessful

--*/


{
    size_t                     limit;
    PKEYWORD                   special;

    CTEPagedCode();
    limit = strlen(string);

    for (special = table; special->k_string; special++)
    {

        if (limit < special->k_strlen)
        {
            continue;
        }

        if ((limit >= special->k_strlen) &&
            !strncmp(string, special->k_string, special->k_strlen))
            {

                return(special);
        }
    }

    return((PKEYWORD) NULL);
} // LmpIsKeyWord



//----------------------------------------------------------------------------

BOOLEAN
LmpBreakRecursion(
    IN PUCHAR path,
    IN PUCHAR target,
    IN ULONG  TargetLength
    )
/*++

Routine Description:

    This function checks that the file name we are about to open
    does not use the target name of this search, which would
    cause an infinite lookup loop.

Arguments:

    path        -  a fully specified path to a lmhosts file
    target      -  the unencoded 16 byte NetBIOS name to look for

Return Value:

    TRUE if the UNC server name in the file path is the same as the
    target of this search. FALSE otherwise.

Notes:

    This function does not detect redirected drives.

--*/


{
    PCHAR     keystring = "\\DosDevices\\UNC\\";
    PCHAR     servername[NETBIOS_NAME_SIZE+1];  // for null on end
    PCHAR     marker1;
    PCHAR     marker2;
    PCHAR     marker3;
    BOOLEAN   retval = FALSE;
    tNAMEADDR *pNameAddr;
    ULONG     uType;

    CTEPagedCode();
    //
    // Check for and extract the UNC server name
    //
    if ((path) && (strlen(path) > strlen(keystring)))
    {
        // check that the name is a unc name
        if (strncmp(path, keystring, strlen(keystring)) == 0)
        {
            marker1 = path + strlen(keystring); // the end of the \DosDevices\Unc\ string
            marker3 = &path[strlen(path)-1];    // the end of the whole path
            marker2 = strchr(marker1,'\\');     // the end of the server name

            if ((marker2) &&                    // marker2 can be NULL if '\\' does not exist in the string
                (marker2 != marker3))
            {
                *marker2 = '\0';

                //
                // attempt to match, in a case insensitive manner, the
                // first 15 bytes of the lmhosts entry with the target
                // name.
                //
                LmExpandName((PUCHAR)servername, marker1, 0);

                if(strncmp((PUCHAR)servername, target, TargetLength) == 0)
                {
                    //
                    // break the recursion
                    //
                    retval = TRUE;
                    IF_DBG(NBT_DEBUG_LMHOST)
                    KdPrint(("Nbt.LmpBreakRecursion: Not including Lmhosts file <%s> because of recursive name\n",
                                servername));
                }
                else
                {
                    //
                    // check if the name has been preloaded in the cache, and
                    // if not, fail the request so we can't get into a loop
                    // trying to include the remote file while trying to
                    // resolve the remote name
                    //
                    pNameAddr = LockAndFindName(NBT_REMOTE,
                                         (PCHAR)servername,
                                         NbtConfig.pScope,
                                         &uType);

                    if (!pNameAddr || !(pNameAddr->NameTypeState & PRELOADED) )
                    {
                        //
                        // break the recursion
                        //
                        retval = TRUE;
                        IF_DBG(NBT_DEBUG_LMHOST)
                        KdPrint(("Nbt.LmpBreakRecursion: Not including Lmhosts #include because name not Preloaded %s\n",
                                    servername));
                    }
                }
                *marker2 = '\\';
            }
        }
    }

    return(retval);
}


//----------------------------------------------------------------------------

char *
LmExpandName (
    OUT PUCHAR dest,
    IN PUCHAR source,
    IN UCHAR last
    )

/*++

Routine Description:

    This function expands an lmhosts entry into a full 16 byte NetBIOS
    name.  It is padded with blanks up to 15 bytes; the 16th byte is the
    input parameter, last.

    This function does not encode 1st level names to 2nd level names nor
    vice-versa.

    Both dest and source are NULL terminated strings.

Arguments:

    dest        -  sizeof(dest) must be NBT_NONCODED_NMSZ
    source      -  the lmhosts entry
    last        -  the 16th byte of the NetBIOS name

Return Value:

    dest.

--*/


{
    char             byte;
    char            *retval = dest;
    char            *src    = source ;
#ifndef VXD
    WCHAR            unicodebuf[NETBIOS_NAME_SIZE+1];
    UNICODE_STRING   unicode;
    STRING           tmp;
#endif
    NTSTATUS         status;
    PUCHAR           limit;

    CTEPagedCode();
    //
    // first, copy the source OEM string to the destination, pad it, and
    // add the last character.
    //
    limit = dest + NETBIOS_NAME_SIZE - 1;

    while ( (*source != '\0') && (dest < limit) )
    {
        *dest++ = *source++;
    }

    while(dest < limit)
    {
        *dest++ = ' ';
    }

    ASSERT(dest == (retval + NETBIOS_NAME_SIZE - 1));

    *dest       = '\0';
    *(dest + 1) = '\0';
    dest = retval;

#ifndef VXD
    //
    // Now, convert to unicode then to ANSI to force the OEM -> ANSI munge.
    // Then convert back to Unicode and uppercase the name. Finally convert
    // back to OEM.
    //
    unicode.Length = 0;
    unicode.MaximumLength = 2*(NETBIOS_NAME_SIZE+1);
    unicode.Buffer = unicodebuf;

    RtlInitString(&tmp, dest);

    status = RtlOemStringToUnicodeString(&unicode, &tmp, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Oem -> Unicode failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlUnicodeStringToAnsiString(&tmp, &unicode, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Unicode -> Ansi failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlAnsiStringToUnicodeString(&unicode, &tmp, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Ansi -> Unicode failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlUpcaseUnicodeStringToOemString(&tmp, &unicode, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Unicode upcase -> Oem failed,  status %X\n", status));
        goto oldupcase;
    }

    // write  the last byte to "0x20" or "0x03" or whatever
    // since we do not want it to go through the munge above.
    //
    dest[NETBIOS_NAME_SIZE-1] = last;
    return(retval);

#endif

oldupcase:

    for ( source = src ; dest < (retval + NETBIOS_NAME_SIZE - 1); dest++)
    {
        byte = *(source++);

        if (!byte)
        {
            break;
        }

        //  Don't use the c-runtime (nt c defn. included first)
        //  What about extended characters etc.?  Since extended characters do
        //  not normally part of netbios names, we will fix if requested
        *dest = (byte >= 'a' && byte <= 'z') ? byte-'a' + 'A' : byte ;
//        *dest = islower(byte) ? toupper(byte) : byte;
    }

    for (; dest < retval + NETBIOS_NAME_SIZE - 1; dest++)
    {
        *dest = ' ';
    }

    ASSERT(dest == (retval + NETBIOS_NAME_SIZE - 1));

    *dest       = last;
    *(dest + 1) = (char) NULL;

    return(retval);
} // LmExpandName

//----------------------------------------------------------------------------

unsigned long
LmInclude(
    IN PUCHAR            file,
    IN LM_PARSE_FUNCTION function,
    IN PUCHAR            argument  OPTIONAL,
    IN CHAR              RecurseDepth,
    OUT BOOLEAN          *NoFindName OPTIONAL
    )

/*++

Routine Description:

    LmInclude() is called to process a #INCLUDE directive in the lmhosts
    file.

Arguments:

    file        -  the file to include
    function    -  function to parse the included file
    argument    -  optional second argument to the parse function
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion
    NoFindName  -  Are find names allowed for this address

Return Value:

    The return value from the parse function.  This should be -1 if the
    file could not be processed, or else some positive number.

--*/


{
    int         retval;
    PUCHAR      end;
    NTSTATUS    status;
    PUCHAR      path;

    CTEPagedCode();
    //
    // unlike C, treat both variations of the #INCLUDE directive identically:
    //
    //      #INCLUDE file
    //      #INCLUDE "file"
    //
    // If a leading '"' exists, skip over it.
    //
    if (*file == '"')
    {

        file++;

        end = strchr(file, '"');

        if (end)
        {
            *end = (UCHAR) NULL;
        }
    }

    //
    // check that the file to be included has been preloaded in the cache
    // since we do not want to have the name query come right back to here
    // to force another inclusion of the same remote file
    //

#ifdef VXD
    return (*function)(file, argument, RecurseDepth, NoFindName ) ;
#else
    status = LmGetFullPath(file, &path);

    if (status != STATUS_SUCCESS)
    {
        return(status);
    }
//    IF_DBG(NBT_DEBUG_LMHOST)
    KdPrint(("Nbt.LmInclude: #INCLUDE \"%s\"\n", path));

    retval = (*function) (path, argument, RecurseDepth, NoFindName);

    CTEMemFree(path);

    return(retval);
#endif
} // LmInclude



#ifndef VXD                     // Not used by VXD
//----------------------------------------------------------------------------
NTSTATUS
LmGetFullPath (
    IN  PUCHAR target,
    OUT PUCHAR *ppath
    )

/*++

Routine Description:

    This function returns the full path of the lmhosts file.  This is done
    by forming a  string from the concatenation of the C strings
    DatabasePath and the string, file.

Arguments:

    target    -  the name of the file.  This can either be a full path name
                 or a mere file name.
    path    -  a pointer to a UCHAR

Return Value:

    STATUS_SUCCESS if successful.

Notes:

    RtlMoveMemory() handles overlapped copies; RtlCopyMemory() doesn't.

--*/

{
    ULONG    FileNameType;
    ULONG    Len;
    PUCHAR   path;

    CTEPagedCode();
    //
    // use a count to figure out what sort of string to build up
    //
    //  0  - local full path file name
    //  1  - local file name only, no path
    //  2  - remote file name
    //  3  - \SystemRoot\ starting file name, or \DosDevices\UNC\...
    //

    // if the target begins with a '\', or contains a DOS drive letter,
    // then assume that it specifies a full path.  Otherwise, prepend the
    // directory used to specify the lmhost file itself.
    //
    //
    if (target[1] == ':')
    {
        FileNameType = 0;
    }
    else
    if (strncmp(&target[1],"SystemRoot",10) == 0)
    {
        FileNameType = 3;
    }
    else
    if (strncmp(&target[0],"\\DosDevices\\",12) == 0)
    {
        FileNameType = 3;
    }
    else
    if (strncmp(target,"\\DosDevices\\UNC\\",sizeof("\\DosDevices\\UNC\\")-1) == 0)
    {
        FileNameType = 3;
    }
    else
    {
        FileNameType = 1;
    }

    //
    // does the directory specify a remote file ?
    //
    // If so, it must be prefixed with "\\DosDevices\\UNC", and the double
    // slashes of the UNC name eliminated.
    //
    //
    if  ((target[1] == '\\') && (target[0] == '\\'))
    {
        FileNameType = 2;
    }

    path = NULL;
    switch (FileNameType)
    {
        case 0:
            //
            // Full file name, put \DosDevices on front of name
            //
            Len = sizeof("\\DosDevices\\") + strlen(target);
            path = NbtAllocMem (Len, NBT_TAG2('11'));
            if (path)
            {
                ULONG   Length=sizeof("\\DosDevices\\"); // Took out -1

                strncpy(path,"\\DosDevices\\",Length);
                Nbtstrcat(path,target,Len);
            }
            break;


        case 1:
            //
            // only the file name is present, with no path, so use the path
            // specified for the lmhost file in the registry NbtConfig.PathLength
            // includes the last backslash of the path.
            //
            //Len = sizeof("\\DosDevices\\") + NbtConfig.PathLength + strlen(target);

            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);    // # 247429

            Len =  NbtConfig.PathLength + strlen(target) +1;
            path = NbtAllocMem (Len, NBT_TAG2('12'));
            if (path)
            {
                //ULONG   Length=sizeof("\\DosDevices") -1; // -1 not to count null

                //strncpy(path,"\\DosDevices",Length);

                strncpy(path,NbtConfig.pLmHosts,NbtConfig.PathLength);
                path[NbtConfig.PathLength] = '\0';

                Nbtstrcat(path,target,Len);
            }

            CTEExReleaseResource(&NbtConfig.Resource);

            break;

        case 2:
            //
            // Full file name, put \DosDevices\UNC on front of name and delete
            // one of the two back slashes used for the remote name
            //
            Len = strlen(target);
            path = NbtAllocMem (Len+sizeof("\\DosDevices\\UNC"), NBT_TAG2('13'));

            if (path)
            {
                ULONG   Length = sizeof("\\DosDevices\\UNC");

                strncpy(path,"\\DosDevices\\UNC",Length);

                // to delete the first \ from the two \\ on the front of the
                // remote file name add one to target.
                //
                Nbtstrcat(path,target+1,Len+sizeof("\\DosDevices\\UNC"));
            }
            break;

        case 3:
            // the target is the full path
            Len = strlen(target) + 1;
            path = NbtAllocMem (Len, NBT_TAG2('14'));
            if (path)
            {
                strncpy(path,target,Len);
            }
            break;


    }

    if (path)
    {
        *ppath = path;
        return(STATUS_SUCCESS);
    }
    else
        return(STATUS_UNSUCCESSFUL);
} // LmGetFullPath


//----------------------------------------------------------------------------
VOID
DelayedScanLmHostFile (
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )

/*++

Routine Description:

    This function is called by the Executive Worker thread to scan the
    LmHost file looking for a name. The name to query is on a list in
    the DNSQueries structure.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    NTSTATUS                status;
    LONG                    IpAddress;
    ULONG                   IpAddrsList[2];
    BOOLEAN                 bFound;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    BOOLEAN                 DoingDnsResolve = FALSE;
    UCHAR                   pName[NETBIOS_NAME_SIZE];
    PUCHAR                  LmHostsPath;
    ULONG                   LoopCount;
    tDGRAM_SEND_TRACKING   *pTracker;
    tDGRAM_SEND_TRACKING   *pTracker0;

    CTEPagedCode();

    LoopCount = 0;
    while (TRUE)
    {
        // get the next name on the linked list of LmHost name queries that
        // are pending
        //
        pContext = NULL;
        DoingDnsResolve = FALSE;

        if (!(pContext = GetNameToFind(pName)))
        {
            return;
        }

        LoopCount ++;

        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.DelayedScanLmHostFile: Lmhosts pName = %15.15s<%X>,LoopCount=%X\n",
                pName,pName[15],LoopCount));

        status = STATUS_TIMEOUT;

        //
        // check if the name is in the lmhosts file or pass to Dns if
        // DNS is enabled
        //
        IpAddress = 0;
        if (NbtConfig.EnableLmHosts)
        {
#ifdef VXD
            //
            // if for some reason PrimeCache failed at startup time
            // then this is when we retry.
            //
            if (!CachePrimed)
            {
                if (PrimeCache (NbtConfig.pLmHosts, NULL, MAX_RECURSE_DEPTH, NULL) != -1)
                {
                    CachePrimed = TRUE ;
                }
            }
#endif

            //
            // The NbtConfig.pLmHosts path can change if the registry is
            // read during this interval
            // We cannot acquire the ResourceLock here since reading the
            // LmHosts file might result in File operations + network reads
            // that could cause a deadlock (Worker threads / ResourceLock)!
            // Best solution at this time is to copy the path onto a local
            // buffer under the Resource lock, and then try to read the file!
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            if ((NbtConfig.pLmHosts) &&
                (LmHostsPath = NbtAllocMem ((strlen(NbtConfig.pLmHosts)+1), NBT_TAG2('20'))))
            {
                CTEMemCopy (LmHostsPath, NbtConfig.pLmHosts, (strlen(NbtConfig.pLmHosts)+1));
                CTEExReleaseResource(&NbtConfig.Resource);

                IpAddress = LmGetIpAddr(LmHostsPath, pName, 1, &bFound);

                CTEMemFree(LmHostsPath);
            }
            else
            {
                CTEExReleaseResource(&NbtConfig.Resource);
                IpAddress = 0;
            }
#ifdef VXD
            //
            // hmmm.. didn't find it in lmhosts: try hosts (if Dns is enabled)
            //
            if ((IpAddress == (ULONG)0) && (NbtConfig.ResolveWithDns))
            {
                IpAddress = LmGetIpAddr(NbtConfig.pHosts, pName, 1, &bFound);
            }
#endif
        }


        if (IpAddress == (ULONG)0)
        {
            // check if the name query has been cancelled
            //
            LOCATION(0x61);
            GetContext (&pContext);
            //
            // for some reason we didn't find our context: maybe cancelled.
            // Go back to the big while loop...
            //
            if (!pContext)
            {
                continue;
            }

            //
            // see if the name is in the 11.101.4.26 format: if so, we got the
            // ipaddr!  Use that ipaddr to get the server name
            //
            pTracker = ((NBT_WORK_ITEM_CONTEXT *)pContext)->pTracker;
            pTracker0 = (tDGRAM_SEND_TRACKING *)((NBT_WORK_ITEM_CONTEXT *)pContext)->pClientContext;

            if (pTracker0->Flags & (REMOTE_ADAPTER_STAT_FLAG|SESSION_SETUP_FLAG|DGRAM_SEND_FLAG))
            {
                IpAddress = Nbt_inet_addr(pTracker->pNameAddr->Name, pTracker0->Flags);
            }

            //
            // yes, the name is the ipaddr: NbtCompleteLmhSvcRequest() starts
            // the process of finding out server name for this ipaddr
            //
            if (IpAddress)
            {
                IpAddrsList[0] = IpAddress;
                IpAddrsList[1] = 0;

		        //
		        // if this is in response to an adapter stat command (e.g.nbtstat -a) then
		        // don't try to find the server name (using remote adapter status!)
		        //
		        if (pTracker0->Flags & REMOTE_ADAPTER_STAT_FLAG)
		        {
		            //
		            // change the state to resolved if the name query is still pending
		            //
                    status = ChangeStateOfName(IpAddress, pContext, &pContext, NAME_RESOLVED_BY_IP);
		        }
		        else
		        {
		            NbtCompleteLmhSvcRequest(pContext, IpAddrsList, NBT_RESOLVE_WITH_DNS, 0, NULL, TRUE);
		            //
		            // done with this name query: go back to the big while loop
		            //
		            continue;
		        }
            }

            //
            //
            // inet_addr failed.  If DNS resolution is enabled, try DNS
            else if ((NbtConfig.ResolveWithDns) &&
                     (!(pTracker0->Flags & NO_DNS_RESOLUTION_FLAG)))
            {
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);

                if (NT_SUCCESS(status))
                {
                    DoingDnsResolve = TRUE;
                }
            }
        }
        else   // if (IpAddress != (ULONG)0)
        {
            //
            // change the state to resolved if the name query is still pending
            //
            status = ChangeStateOfName(IpAddress, NULL, &pContext, NAME_RESOLVED_BY_LMH);
        }

        //
        // if DNS gets involved, then we wait for that to complete before calling
        // completion routine.
        //
        if (!DoingDnsResolve)
        {
            LOCATION(0x60);
            RemoveNameAndCompleteReq((NBT_WORK_ITEM_CONTEXT *)pContext, status);
        }

    }// of while(TRUE)
}

//----------------------------------------------------------------------------
ULONG
AddToDomainList (
    IN PUCHAR           pName,
    IN tIPADDRESS       IpAddress,
    IN PLIST_ENTRY      pDomainHead,
    IN BOOLEAN          fPreload
    )

/*++

Routine Description:

    This function adds a name and ip address to the list of domains that
    are stored in a list.


Arguments:

Return Value:


--*/


{
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pEntry;
    tNAMEADDR                  *pNameAddr=NULL;
    tIPADDRESS                 *pIpAddr;

    CTEPagedCode();

    pHead = pEntry = pDomainHead;
    if (!IsListEmpty(pDomainHead))
    {
        pNameAddr = FindInDomainList(pName,pDomainHead);
        if (pNameAddr)
        {
            //
            // the name matches, so add to the end of the ip address list
            //
            if (pNameAddr->CurrentLength < pNameAddr->MaxDomainAddrLength)
            {
                pIpAddr = pNameAddr->pLmhSvcGroupList;

                while (*pIpAddr != (ULONG)-1) {
                    pIpAddr++;
                }

                *pIpAddr++ = IpAddress;
                *pIpAddr = (ULONG)-1;
                pNameAddr->CurrentLength += sizeof(ULONG);
            }
            else
            {
                //
                // need to allocate more memory for for ip addresses
                //
                if (pIpAddr = NbtAllocMem (pNameAddr->MaxDomainAddrLength+INITIAL_DOM_SIZE, NBT_TAG2('08')))
                {
                    CTEMemCopy(pIpAddr, pNameAddr->pLmhSvcGroupList, pNameAddr->MaxDomainAddrLength);

                    //
                    // Free the old chunk of memory and tack the new one on
                    // to the pNameaddr
                    //
                    CTEMemFree(pNameAddr->pLmhSvcGroupList);
                    pNameAddr->pLmhSvcGroupList = pIpAddr;

                    pIpAddr = (PULONG)((PUCHAR)pIpAddr + pNameAddr->MaxDomainAddrLength);

                    //
                    // our last entry was -1: overwrite that one
                    //
                    pIpAddr--;

                    *pIpAddr++ = IpAddress;
                    *pIpAddr = (ULONG)-1;

                    //
                    // update the number of addresses in the list so far
                    //
                    pNameAddr->MaxDomainAddrLength += INITIAL_DOM_SIZE;
                    pNameAddr->CurrentLength += sizeof(ULONG);
                    pNameAddr->Verify = REMOTE_NAME;
                }
            }
        }
    }

    //
    // check if we found the name or we need to add a new name
    //
    if (!pNameAddr)
    {
        //
        // create a new name for the domain list
        //
        if (pNameAddr = NbtAllocMem (sizeof(tNAMEADDR), NBT_TAG2('09')))
        {
            CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
            pIpAddr = NbtAllocMem (INITIAL_DOM_SIZE, NBT_TAG2('10'));
            if (pIpAddr)
            {
                CTEMemCopy(pNameAddr->Name,pName,NETBIOS_NAME_SIZE);
                pNameAddr->pLmhSvcGroupList = pIpAddr;
                *pIpAddr++ = IpAddress;
                *pIpAddr = (ULONG)-1;

                pNameAddr->NameTypeState = NAMETYPE_INET_GROUP;
                pNameAddr->MaxDomainAddrLength = INITIAL_DOM_SIZE;
                pNameAddr->CurrentLength = 2*sizeof(ULONG);
                pNameAddr->Verify = REMOTE_NAME;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);

                InsertHeadList(pDomainHead,&pNameAddr->Linkage);
            }
            else
            {
                CTEMemFree(pNameAddr);
                pNameAddr = NULL;
            }
        }
    }

    if (pNameAddr && fPreload)
    {
        pNameAddr->fPreload = TRUE;
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tNAMEADDR *
FindInDomainList (
    IN PUCHAR           pName,
    IN PLIST_ENTRY      pDomainHead
    )

/*++

Routine Description:

    This function finds a name in the domain list passed in.

Arguments:

    name to find
    head of list to look on

Return Value:

    ptr to pNameaddr

--*/
{
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pEntry;
    tNAMEADDR                  *pNameAddr;

    pHead = pEntry = pDomainHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
        if (strncmp(pNameAddr->Name,pName,NETBIOS_NAME_SIZE) == 0)
        {
            return(pNameAddr);
        }
    }

    return(NULL);
}

//----------------------------------------------------------------------------
VOID
MakeNewListCurrent (
    PLIST_ENTRY     pTmpDomainList
    )

/*++

Routine Description:

    This function frees the old entries on the DomainList and hooks up the
    new entries

Arguments:

    pTmpDomainList  - list entry to the head of a new domain list

Return Value:


--*/


{
    CTELockHandle   OldIrq;
    tNAMEADDR       *pNameAddr;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pHead;
    NTSTATUS        status;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!IsListEmpty(pTmpDomainList))
    {
        //
        // free the old list elements
        //
        pHead = &DomainNames.DomainList;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            RemoveEntryList(&pNameAddr->Linkage);
            //
            // initialize linkage so that if the nameaddr is being
            // referenced now, when it does get freed in a subsequent
            // call to NBT_DEREFERENCE_NAMEADDR it will not
            // remove it from any lists
            //
            InitializeListHead(&pNameAddr->Linkage);

            //
            // Since the name could be in use now we must dereference rather
            // than just free it outright
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }

        //
        // See if any of the new names has to be preloaded!
        //
        pEntry = pTmpDomainList->Flink;
        while (pEntry != pTmpDomainList)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            if (pNameAddr->fPreload)
            {
                RemoveEntryList(&pNameAddr->Linkage);
                InitializeListHead(&pNameAddr->Linkage);

                status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                         pNameAddr->Name,
                                         NbtConfig.pScope,
                                         0,
                                         0,
                                         pNameAddr,
                                         &pNameAddr,
                                         NULL,
                                         NAME_RESOLVED_BY_LMH_P | NAME_ADD_INET_GROUP);

                if ((status == STATUS_SUCCESS) ||
                    ((status == STATUS_PENDING) &&
                     (!(pNameAddr->NameTypeState & PRELOADED))))
                {
                    //
                    // this prevents the name from being deleted by the Hash Timeout code
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);
                    pNameAddr->Ttl = 0xFFFFFFFF;
                    pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
                    pNameAddr->NameTypeState &= ~STATE_CONFLICT;
                    pNameAddr->AdapterMask = (CTEULONGLONG)-1;
                }
            }
        }

        DomainNames.DomainList.Flink = pTmpDomainList->Flink;
        DomainNames.DomainList.Blink = pTmpDomainList->Blink;
        pTmpDomainList->Flink->Blink = &DomainNames.DomainList;
        pTmpDomainList->Blink->Flink = &DomainNames.DomainList;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

}



//----------------------------------------------------------------------------
NTSTATUS
NtProcessLmHSvcIrp(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   *pBuffer,
    IN  LONG                    Size,
    IN  PCTE_IRP                pIrp,
    IN  enum eNbtLmhRequestType RequestType
    )
/*++

Routine Description:

    This function is used by LmHsvc Dll to collect requests for
    Pinging IP addresses or querying through DNS.
    The request is sent to LmhSvc in the buffer associated with
    this request.

Arguments:

Return Value:
    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/

{
    NTSTATUS                        status;
    NTSTATUS                        Locstatus;
    CTELockHandle                   OldIrq;
    tIPADDR_BUFFER_DNS              *pIpAddrBuf;
    PVOID                           pClientCompletion;
    PVOID                           pClientContext;
    tDGRAM_SEND_TRACKING            *pTracker;
    ULONG                           IpAddrsList[MAX_IPADDRS_PER_HOST+1];
    NBT_WORK_ITEM_CONTEXT           *pContext;
    BOOLEAN                         CompletingAnotherQuery = FALSE;
    tLMHSVC_REQUESTS                *pLmhRequest;
    tDEVICECONTEXT                  *pDeviceContextRequest;

    pIpAddrBuf = (tIPADDR_BUFFER_DNS *)pBuffer;

    switch (RequestType)
    {
        case NBT_PING_IP_ADDRS:
        {
            pLmhRequest = &CheckAddr;
            break;
        }

        case NBT_RESOLVE_WITH_DNS:
        {
            pLmhRequest = &DnsQueries;
            break;
        }

        default:
        {
            ASSERTMSG ("Nbt.NtProcessLmHSvcIrp: ERROR - Invalid Request from LmhSvc Dll\n", 0);
            return STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // If we already have an Irp posted, return this Irp -- Bug # 311924
    //
    if ((pLmhRequest->QueryIrp) &&
        (!pLmhRequest->ResolvingNow))
    {
        CTESpinFree (&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NtProcessLmHSvcIrp: ERROR -- duplicate request Irp!\n"));
        NTIoComplete (pIrp, STATUS_OBJECT_PATH_INVALID, 0);
        NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! duplicate Lmhosts request"));
        return STATUS_OBJECT_PATH_INVALID;
    }

    IoMarkIrpPending(pIrp);
    pLmhRequest->QueryIrp = pIrp;
    status = STATUS_PENDING;
    if (pLmhRequest->ResolvingNow)
    {
        //
        // if the client got tired of waiting for DNS, the NbtCancelWaitForLmhSvcIrp
        // in ntisol.c will have cleared the pContext value when cancelling the
        // irp, so check for that here.
        //
        if (pLmhRequest->Context)
        {
            pContext = (NBT_WORK_ITEM_CONTEXT *) pLmhRequest->Context;
            pLmhRequest->Context = NULL;
            pDeviceContextRequest = pContext->pDeviceContext;

            if (NBT_REFERENCE_DEVICE (pDeviceContextRequest, REF_DEV_LMH, TRUE))
            {
                NbtCancelCancelRoutine (((tDGRAM_SEND_TRACKING *) (pContext->pClientContext))->pClientIrp);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                ASSERT(sizeof(pIpAddrBuf->pwName) == DNS_NAME_BUFFER_LENGTH * sizeof(pIpAddrBuf->pwName[0]));
                pIpAddrBuf->pwName[DNS_NAME_BUFFER_LENGTH-1] = 0;
                NbtCompleteLmhSvcRequest (pContext,
                                          pIpAddrBuf->IpAddrsList,
                                          RequestType,
                                          pIpAddrBuf->NameLen,
                                          pIpAddrBuf->pwName,
                                          (BOOLEAN)pIpAddrBuf->Resolved);

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                NBT_DEREFERENCE_DEVICE (pDeviceContextRequest, REF_DEV_LMH, TRUE);
            }
            else
            {
                ASSERT (0);
            }
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NtProcessLmHSvcIrp[%s]: No Context!! *******\r\n",
                    (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS")));
        }

        pLmhRequest->ResolvingNow = FALSE;
        //
        // are there any more name query requests to process?
        //
        while (!IsListEmpty(&pLmhRequest->ToResolve))
        {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&pLmhRequest->ToResolve);
            pContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            Locstatus = NbtProcessLmhSvcRequest (pContext, RequestType);
            if (NT_SUCCESS(Locstatus))
            {
                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CompletingAnotherQuery = TRUE;
                break;
            }

            //
            // if it failed then complete the irp now
            //
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NtProcessLmHSvcIrp[%s]: NbtProcessLmhSvcRequest failed with %x\r\n",
                    (RequestType==NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS":"NBT_PING_IP_ADDRS"),
                    Locstatus));
            pClientCompletion = pContext->ClientCompletion;
            pClientContext = pContext->pClientContext;
            pTracker = pContext->pTracker;

            //
            // Clear the Cancel Routine now
            //
            (VOID)NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *)pClientContext)->pClientIrp);

            if (pTracker)
            {
                if (pTracker->pNameAddr)
                {
                    SetNameState (pTracker->pNameAddr, NULL, FALSE);
                    pTracker->pNameAddr = NULL;
                }

                //
                // pTracker is NULL for Ping requests, hence this dereference is
                // done only for Dns requests
                //
                NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
            }

            CompleteClientReq(pClientCompletion, pClientContext, STATUS_BAD_NETWORK_PATH);
            CTEMemFree(pContext);

            CTESpinLock(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // We are holding onto the Irp, so set the cancel routine.
    // (Since we may have released the lock earlier, we also need
    //  to ensure that no other Query has completed the Irp!)
    //
    if ((!CompletingAnotherQuery) &&
        (!pLmhRequest->ResolvingNow) &&
        (pLmhRequest->QueryIrp == pIrp))
    {
        status = NTCheckSetCancelRoutine(pIrp, NbtCancelLmhSvcIrp, pDeviceContext);
        if (!NT_SUCCESS(status))
        {
            // the irp got cancelled so complete it now
            //
            pLmhRequest->QueryIrp = NULL;
            pLmhRequest->pIpAddrBuf = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NTIoComplete(pIrp,status,0);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_PENDING;
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtProcessLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *pContext,
    IN  enum eNbtLmhRequestType RequestType
    )
/*++

Routine Description:

    This function is called to pass a NBT request to ping IP addrs
    or query DNS to the LmhSvc Dll

Arguments:

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    tIPADDR_BUFFER_DNS      *pIpAddrBuf;
    PCTE_IRP                pIrp;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAM_SEND_TRACKING    *pClientTracker;
    CTELockHandle           OldIrq;
    PCHAR                   pDestName;
    ULONG                   NameLen, NumAddrs;
    tLMHSVC_REQUESTS        *pLmhRequest;

    switch (RequestType)
    {
        case NBT_PING_IP_ADDRS:
        {
            pLmhRequest = &CheckAddr;
            break;
        }

        case NBT_RESOLVE_WITH_DNS:
        {
            pLmhRequest = &DnsQueries;
            break;
        }

        default:
        {
            ASSERTMSG ("Nbt.NbtProcessLmHSvcRequest: ERROR - Invalid Request type\n", 0);
            return STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pContext->TimedOut = FALSE;
    if ((!NBT_VERIFY_HANDLE (pContext->pDeviceContext, NBT_VERIFY_DEVCONTEXT)) ||
        (!pLmhRequest->QueryIrp))
    {
        //
        // Either the device is going away, or
        // the irp either never made it down here, or it was cancelled,
        // so pretend the name query timed out.
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: QueryIrp is NULL, returning\r\n",
                (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS")));
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        if (pLmhRequest->QueryIrp) {
            NbtTrace(NBT_TRACE_NAMESRV, ("return STATUS_BAD_NETWORK_PATH because the device is going away"));
        } else {
            NbtTrace(NBT_TRACE_NAMESRV, ("LmHost services didn't start"));
        }
        return(STATUS_BAD_NETWORK_PATH);
    }
    else if (!pLmhRequest->ResolvingNow)
    {
        pIrp = pLmhRequest->QueryIrp;
        if ((!pLmhRequest->pIpAddrBuf) &&
            (!(pLmhRequest->pIpAddrBuf = (tIPADDR_BUFFER_DNS *)
                                         MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! returns STATUS_UNSUCCESSFUL"));
            return(STATUS_UNSUCCESSFUL);
        }

        pIpAddrBuf = pLmhRequest->pIpAddrBuf;
        pLmhRequest->ResolvingNow = TRUE;
        pLmhRequest->Context = pContext;

        pTracker = pContext->pTracker;           // this is the name query tracker (for Dns queries only)
        pClientTracker = (tDGRAM_SEND_TRACKING *)pContext->pClientContext; // session setup tracker

        switch (RequestType)
        {
            case NBT_PING_IP_ADDRS:
            {
                ASSERT(pTracker == NULL);

                //
                // copy the IP addrs for lmhsvc to ping (upto MAX_IPADDRS_PER_HOST) ...
                //
                NumAddrs = pClientTracker->NumAddrs > MAX_IPADDRS_PER_HOST ?
                                MAX_IPADDRS_PER_HOST : pClientTracker->NumAddrs;
                CTEMemCopy(pIpAddrBuf->IpAddrsList, pClientTracker->IpList, NumAddrs * sizeof(ULONG));
                pIpAddrBuf->IpAddrsList[NumAddrs] = 0;
                break;
            }
            case NBT_RESOLVE_WITH_DNS:
            {
                WCHAR   *UnicodeDestName;

                UnicodeDestName =  pClientTracker? pClientTracker->UnicodeDestName: NULL;

                //
                // whenever dest. name is 16 bytes long (or smaller), we have no
                // way of knowing if its a netbios name or a dns name, so we presume
                // it's netbios name, go to wins, broadcast etc. and then come to dns
                // In this case, the name query tracker will be setup, so be non-null
                //
                if (pTracker)
                {
                    pDestName = pTracker->pNameAddr->Name;
                    NameLen = NETBIOS_NAME_SIZE;
                }
                //
                // if the dest name is longer than 16 bytes, it's got to be dns name so
                // we bypass wins etc. and come straight to dns.  In this case, we didn't
                // set up a name query tracker so it will be null.  Use the session setup
                // tracker (i.e. pClientTracker) to get the dest name
                //
                else
                {
                    ASSERT(pClientTracker);

                    pDestName = pClientTracker->pDestName;
                    NameLen = pClientTracker->RemoteNameLength;
                }

                if ((NameLen == NETBIOS_NAME_SIZE) &&
                    (!(IsValidDnsNameTag (pDestName[NETBIOS_NAME_SIZE-1]))))
                {
                    NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! returns STATUS_BAD_NETWORK_PATH %02x",
                                            (unsigned)pDestName[NETBIOS_NAME_SIZE-1]));
                    status = STATUS_BAD_NETWORK_PATH;
                }
                else
                {
                    //
                    // Ignore the 16th byte only if it is a non-DNS name character (we should be
                    // safe below 0x20). This will allow queries to DNS names which are exactly 16
                    // characters long.
                    //
                    if (NameLen == NETBIOS_NAME_SIZE)
                    {
                        if ((pDestName[NETBIOS_NAME_SIZE-1] <= 0x20 ) ||
                            (pDestName[NETBIOS_NAME_SIZE-1] >= 0x7f ))
                        {
                            NameLen = NETBIOS_NAME_SIZE-1;          // ignore 16th byte
                        }
                    }
                    else if (NameLen > DNS_MAX_NAME_LENGTH)
                    {
                        NameLen = DNS_MAX_NAME_LENGTH;
                    }

                    //
                    // copy the name to the Irps return buffer for lmhsvc to resolve with
                    // a gethostbyname call
                    //

                    if (UnicodeDestName) {
                        int len;

                        len = pClientTracker->UnicodeRemoteNameLength;
                        if (len > sizeof(pIpAddrBuf->pwName - sizeof(WCHAR))) {
                            len = sizeof(pIpAddrBuf->pwName) - sizeof(WCHAR);
                        }
                        ASSERT((len % sizeof(WCHAR)) == 0);
                        CTEMemCopy(pIpAddrBuf->pwName, UnicodeDestName, len);
                        pIpAddrBuf->pwName[len/sizeof(WCHAR)] = 0;
                        pIpAddrBuf->NameLen = len;
                        pIpAddrBuf->bUnicode = TRUE;
                    } else {
                        //
                        // I would like to maintain only UNICODE interface between NetBT and LmhSVC.
                        // But I cannot do RtlAnsiStringToUnicodeString here due to IRQ level here.
                        //
                        pIpAddrBuf->bUnicode = FALSE;
                        CTEMemCopy(pIpAddrBuf->pName, pDestName, NameLen);
                        pIpAddrBuf->pName[NameLen] = 0;
                        pIpAddrBuf->NameLen = NameLen;
                    }
                }

                break;
            }

            default:
            {
                //
                // This code path should never be hit!
                //
                ASSERT(0);
            }
        }   // switch

        //
        // Since datagrams are buffered there is no client irp to get cancelled
        // since the client's irp is returned immediately -so this check
        // is only for connections being setup or QueryFindname or
        // nodestatus, where we allow the irp to
        // be cancelled.
        //
        if ((NT_SUCCESS(status)) &&
            (pClientTracker->pClientIrp))
        {
            //
            // allow the client to cancel the name query Irp - no need to check
            // if the client irp was already cancelled or not since the DNS query
            // will complete and find no client request and stop.
            //
            status = NTCheckSetCancelRoutine(pClientTracker->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
        }

        //
        // pass the irp up to lmhsvc.dll to do a gethostbyname call to
        // sockets
        // The Irp will return to NtDnsNameResolve, above
        //
        if (NT_SUCCESS(status))
        {
            pLmhRequest->pIpAddrBuf = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NTIoComplete(pLmhRequest->QueryIrp,STATUS_SUCCESS,0);
            return (STATUS_PENDING);
        }

        //
        // We failed to set the cancel routine, so undo setting up the
        // the pLmhRequest structure.
        //
        NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! returns %!status!", status));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: CheckSet (submitting) failed with %x\r\n",
            (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS"),status));
        pLmhRequest->ResolvingNow = FALSE;
        pLmhRequest->Context = NULL;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
    else
    {
        pClientTracker = (tDGRAM_SEND_TRACKING *)pContext->pClientContext;
        //
        // Since datagrams are buffered there is no client irp to get cancelled
        // since the client's irp is returned immediately -so this check
        // is only for connections being setup, where we allow the irp to
        // be cancelled.
        //
        //
        // allow the client to cancel the name query Irp
        //
        if (pClientTracker->pClientIrp)         // check if this is the session setup tracker
        {
            status = NTCheckSetCancelRoutine(pClientTracker->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
        }

        if (NT_SUCCESS(status))
        {
            // the irp is busy resolving another name, so wait for it to return
            // down here again, mean while, Queue the name query
            //
            InsertTailList(&pLmhRequest->ToResolve, &pContext->Item.List);
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: CheckSet (queuing) failed with %x\r\n",
                (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS"),status));
            NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! returns %!status!", status));
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    if (NT_SUCCESS(status))
    {
        status = STATUS_PENDING;
    }

    return(status);
}


//----------------------------------------------------------------------------
extern
VOID
SetNameState(
    IN  tNAMEADDR   *pNameAddr,
    IN  PULONG      pIpList,
    IN  BOOLEAN     IpAddrResolved
    )

/*++

Routine Description:

    This function dereferences the pNameAddr and sets the state to Released
    just incase the dereference does not delete the entry right away, due to
    another outstanding reference against the name.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    CTELockHandle   OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (IpAddrResolved)
    {
        pNameAddr->IpAddress = pIpList[0];
    }
    else
    {
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_RELEASED;
        pNameAddr->pTracker = NULL;
    }

    ASSERT (pNameAddr->RefCount == 1);
    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
VOID
NbtCompleteLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  ULONG                   *IpList,
    IN  enum eNbtLmhRequestType RequestType,
    IN  ULONG                   lNameLength,
    IN  PWSTR                   pwsName,        // The rosolved name return by LmhSvc
    IN  BOOLEAN                 IpAddrResolved
    )
/*++

Routine Description:

    If the destination name is of the form 11.101.4.25 or is a dns name (i.e. of
    the form ftp.microsoft.com) then we come to this function.  In addition to
    doing some house keeping, if the name did resolve then we also send out
    a nodestatus request to find out the server name for that ipaddr

Arguments:

    Context        - (NBT_WORK_ITEM_CONTEXT)
    IpList         - Array of ipaddrs if resolved (i.e. IpAddrResolved is TRUE)
    IpAddrResolved - TRUE if ipaddr could be resolved, FALSE otherwise

Return Value:

    Nothing

Notes:


--*/

{

    NTSTATUS                status;
    PVOID                   pClientCompletion;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAM_SEND_TRACKING    *pClientTracker;
    ULONG                   TdiAddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ULONG                   IpAddrsList[MAX_IPADDRS_PER_HOST+1];
    tDEVICECONTEXT          *pDeviceContext;
    int                     i;
    tCONNECTELE             *pConnEle;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
       KdPrint(("Nbt.NbtCompleteLmhSvcRequest: Entered ...\n"));

    pTracker = Context->pTracker;
    pClientCompletion = Context->ClientCompletion;
    pClientTracker = (tDGRAM_SEND_TRACKING *) Context->pClientContext;
    pDeviceContext = pClientTracker->pDeviceContext;

    // whether or not name resolved, we don't need this nameaddr anymore
    // (if name resolved, then we do a node status to that addr and create
    // a new nameaddr for the server name in ExtractServerName)
    // pTracker is null if we went straight to dns (without wins etc)
    if (pTracker)
    {
        //
        // Set some info in case some client is still resolving the name
        //
        SetNameState (pTracker->pNameAddr, IpList, IpAddrResolved);
        pTracker->pNameAddr = NULL;
    }

    (VOID)NbtCancelCancelRoutine (pClientTracker->pClientIrp);
    pClientTracker->pTrackerWorker = NULL;  // The original NameQuery Tracker will be dereferenced below

    status = STATUS_BAD_NETWORK_PATH;

    if (RequestType == NBT_RESOLVE_WITH_DNS)
    {
        TdiAddressType = ((pTracker == NULL) ? pClientTracker->AddressType: TDI_ADDRESS_TYPE_NETBIOS);
    }

    //
    // If we failed to resolve it, set the state approriately!
    //
    if (!IpAddrResolved)
    {
        if ((TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS_EX) &&
            (pConnEle = pClientTracker->pConnEle))   // NULL if request was to send Datagram!
        {
            pConnEle->RemoteNameDoesNotExistInDNS = TRUE;
        }
    }
    else if (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT)) // check if this Device is still up!
    {
        // the name was resolved successfully!
        switch (RequestType)
        {
            case NBT_RESOLVE_WITH_DNS:
            {
                // bug #20697, #95241
                if (pwsName && pClientTracker->pNetbiosUnicodeEX &&
                            (pClientTracker->pNetbiosUnicodeEX->NameBufferType == NBT_READWRITE ||
                            pClientTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITEONLY)) {
                    UNICODE_STRING  temp;

                    temp = pClientTracker->pNetbiosUnicodeEX->RemoteName;

                    //
                    // Has the buffer changed?
                    //
                    if (memcmp(&temp, &pClientTracker->ucRemoteName, sizeof(UNICODE_STRING)) == 0) {
                        ASSERT(lNameLength <= (DNS_NAME_BUFFER_LENGTH-1) * sizeof(pwsName[0]));
                        ASSERT((lNameLength%sizeof(WCHAR)) == 0);

                        //
                        // Make sure we don't overrun the buffer
                        //
                        if (lNameLength > temp.MaximumLength - sizeof(WCHAR)) {
                            // Don't return STATUS_BUFFER_OVERFLOW since it is just a warning instead of error
                            status = STATUS_BUFFER_TOO_SMALL;
                            break;
                        }
                        CTEMemCopy(temp.Buffer, pwsName, lNameLength);
                        temp.Buffer[lNameLength/sizeof(WCHAR)] = 0;
                        temp.Length = (USHORT)lNameLength;
                        pClientTracker->pNetbiosUnicodeEX->NameBufferType = NBT_WRITTEN;
                        pClientTracker->pNetbiosUnicodeEX->RemoteName = temp;

                        IF_DBG(NBT_DEBUG_NETBIOS_EX)
                            KdPrint(("netbt!NbtCompleteLmhSvcRequest: Update Unicode Name at %d of %s\n"
                                    "\t\tDNS return (%ws)\n",
                                __LINE__, __FILE__, pwsName));
                    }
                }

                if ((TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS) &&
                    (!IsDeviceNetbiosless(pDeviceContext)))         // Can't do a NodeStatus on the SMB port
                {
                    for (i=0; i<MAX_IPADDRS_PER_HOST; i++)
                    {
                        IpAddrsList[i] = IpList[i];
                        if (IpAddrsList[i] == 0)
                        {
                            break;
                        }
                    }
                    IpAddrsList[MAX_IPADDRS_PER_HOST] = 0;

                    pClientTracker->Flags |= NBT_DNS_SERVER;    // Set this so that the completion will know
                    pClientTracker->CompletionRoutine = pClientCompletion;
                    status = NbtSendNodeStatus(pDeviceContext,
                                               NULL,
                                               IpAddrsList,
                                               pClientTracker,
                                               ExtractServerNameCompletion);

                    //
                    // If we succeeded in sending a Node status, exit now,
                    // without calling the completion routine
                    //
                    if (NT_SUCCESS(status))
                    {
                        // pTracker is null if we went straight to dns (without wins etc) or
                        // if this was a Ping request
                        if (pTracker)
                        {
                            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
                        }

                        CTEMemFree(Context);
                        return;
                    }

                    break;
                }

                //
                // The Address is of type TDI_ADDRESS_TYPE_NETBIOS_EX,
                // so now handle this scenario in the same way as for
                // for a Ping request!
                //
                // NO break!
            }

            case NBT_PING_IP_ADDRS:
            {
                //
                // add this server name to the remote hashtable
                // Call into IP to determine the outgoing interface for this address
                //
                pDeviceContext = GetDeviceFromInterface (htonl(IpList[0]), TRUE);
                status = LockAndAddToHashTable(NbtConfig.pRemoteHashTbl,
                                               pClientTracker->pDestName,
                                               NbtConfig.pScope,
                                               IpList[0],
                                               NBT_UNIQUE,
                                               NULL,
                                               NULL,
                                               pDeviceContext,
                                               (USHORT) ((RequestType == NBT_RESOLVE_WITH_DNS) ?
                                                    NAME_RESOLVED_BY_DNS : 
                                                    NAME_RESOLVED_BY_WINS | NAME_RESOLVED_BY_BCAST));


                if (pDeviceContext)
                {
                    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
                }

                //
                // STATUS_PENDING will be returned if the name already existed
                // in the hashtable
                //
                if (status == STATUS_PENDING)
                {
                    status = STATUS_SUCCESS;
                }

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtCompleteLmhSvcRequest: AddRecordToHashTable Status %lx\n",status));

                break;
            }

            default:
            {
                ASSERT(0);
            }
        }   // switch
    }

    // pTracker is null if we went straight to dns (without wins etc) or
    // if this was a Ping request
    if (pTracker)
    {
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }

    NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! complete client request with %!status!", status));
    CompleteClientReq(pClientCompletion, pClientTracker, status);

    CTEMemFree(Context);
}
#endif  // !VXD


//----------------------------------------------------------------------------
NTSTATUS
PreloadEntry(
    IN PUCHAR       name,
    IN tIPADDRESS   inaddr
    )
/*++

Routine Description:

    This function adds an lmhosts entry to nbt's name cache.  For each
    lmhosts entry, NSUFFIXES unique cache entries are created.

    Even when some cache entries can't be created, this function doesn't
    attempt to remove any that were successfully added to the cache.

Arguments:

    name        -  the unencoded NetBIOS name specified in lmhosts
    inaddr      -  the ip address, in host byte order

Return Value:

    The number of new name cache entries created.

--*/

{
    NTSTATUS        status;
    tNAMEADDR       *pNameAddr;
    LONG            nentries;
    LONG            Len;
    CHAR            temp[NETBIOS_NAME_SIZE+1];
    CTELockHandle   OldIrq;
    LONG            NumberToAdd;
    tDEVICECONTEXT  *pDeviceContext;

    // if all 16 bytes are present then only add that name exactly as it
    // is.
    //
    Len = strlen(name);
    //
    // if this string is exactly 16 characters long, do  not expand
    // into 0x00, 0x03,0x20 names.  Just add the single name as it is.
    //
    if (Len == NETBIOS_NAME_SIZE)
    {
        NumberToAdd = 1;
    }
    else
    {
        NumberToAdd = NSUFFIXES;
    }
    for (nentries = 0; nentries < NumberToAdd; nentries++)
    {
        // for names less than 16 bytes, expand out to 16 and put a 16th byte
        // on according to the suffix array
        //
        if (Len != NETBIOS_NAME_SIZE)
        {
            LmExpandName(temp, name, Suffix[nentries]);
        }
        else
        {
            CTEMemCopy(temp,name,NETBIOS_NAME_SIZE);
        }

        pDeviceContext = GetDeviceFromInterface (htonl(inaddr), TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                 temp,
                                 NbtConfig.pScope,
                                 inaddr,
                                 NBT_UNIQUE,
                                 NULL,
                                 &pNameAddr,
                                 pDeviceContext,
                                 NAME_RESOLVED_BY_LMH_P);

        // if the name is already in the hash table, the status code is
        // status pending. This could happen if the preloads are purged
        // when one is still being referenced by another part of the code,
        // and was therefore not deleted.  We do not want to add the name
        // twice, so we just change the ip address to agree with the preload
        // value
        //
        if ((status == STATUS_SUCCESS) ||
            ((status == STATUS_PENDING) &&
             (!(pNameAddr->NameTypeState & PRELOADED))))
        {
            //
            // this prevents the name from being deleted by the Hash Timeout code
            //
            pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
            pNameAddr->NameTypeState &= ~STATE_CONFLICT;
            pNameAddr->Ttl = 0xFFFFFFFF;
            pNameAddr->Verify = REMOTE_NAME;
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);

            if (pDeviceContext)
            {
                pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
            }
        }
        else if (status == STATUS_PENDING)
        {
            pNameAddr->IpAddress = inaddr;
        }

        if (pDeviceContext)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_SUCCESS);

} // PreloadEntry
//----------------------------------------------------------------------------
extern
VOID
RemovePreloads (
    )

/*++

Routine Description:

    This function removes preloaded entries from the remote hash table.
    If it finds any of the preloaded entries are active with a ref count
    above the base level of 2, then it returns true.

Arguments:

    none
Return Value:

    none

--*/

{
    tNAMEADDR       *pNameAddr;
    PLIST_ENTRY     pHead,pEntry;
    CTELockHandle   OldIrq;
    tHASHTABLE      *pHashTable;
    BOOLEAN         FoundActivePreload=FALSE;
    LONG            i;

    //
    // go through the remote table deleting names that have the PRELOAD
    // bit set.
    //
    pHashTable = NbtConfig.pRemoteHashTbl;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    for (i=0;i < pHashTable->lNumBuckets ;i++ )
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // Delete preloaded entries that are not in use by some other
            // part of the code now.  Note that preloaded entries start with
            // a ref count of 2 so that the normal remote hashtimeout code
            // will not delete them
            //
            if ((pNameAddr->NameTypeState & PRELOADED) &&
                (pNameAddr->RefCount == 2))
            {
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED, TRUE);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return;
}

//----------------------------------------------------------------------------
LONG
PrimeCache(
    IN  PUCHAR  path,
    IN  PUCHAR   ignored,
    IN  CHAR    RecurseDepth,
    OUT BOOLEAN *ignored2
    )

/*++

Routine Description:

    This function is called to prime the cache with entries in the lmhosts
    file that are marked as preload entries.


Arguments:

    path        -  a fully specified path to a lmhosts file
    ignored     -  unused
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion

Return Value:

    Number of new cache entries that were added, or -1 if there was an
    i/o error.

--*/

{
    int             nentries;
    PUCHAR          buffer;
    PLM_FILE        pfile;
    NTSTATUS        status;
    int             count, nwords;
    unsigned long   temp;
    INCLUDE_STATE   incstate;
    PUCHAR          token[MaxTokens];
    ULONG           inaddr;
    LINE_CHARACTERISTICS current;
    UCHAR           Name[NETBIOS_NAME_SIZE+1];
    ULONG           IpAddr;
    LIST_ENTRY      TmpDomainList;
    int             domtoklen;

    CTEPagedCode();

    if (!NbtConfig.EnableLmHosts)
    {
        return(STATUS_SUCCESS);
    }

    InitializeListHead(&TmpDomainList);
    //
    // Check for infinitely recursive name lookup in a #INCLUDE.
    //
    if (LmpBreakRecursion(path, "", 1) == TRUE)
    {
        return (-1);
    }

    pfile = LmOpenFile(path);

    if (!pfile)
    {
        return(-1);
    }

    nentries  = 0;
    incstate  = MustInclude;
    domtoklen = strlen(DOMAIN_TOKEN);

    while (buffer = LmFgets(pfile, &count))
    {
#ifndef VXD
        if ((NbtConfig.MaxPreloadEntries - nentries) < 3)
        {
            break;
        }
#else
        if ( nentries >= (NbtConfig.MaxPreloadEntries - 3) )
        {
            break;
        }
#endif

        nwords   = MaxTokens;
        current =  LmpGetTokens(buffer, token, &nwords);

        // if there is and error or no name on the line, then continue
        // to the next line.
        //
        if (current.l_category == ErrorLine)
        {
            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.PrimeCache: Error line in Lmhost file\n"));
            continue;
        }
        if (current.l_category != BeginAlternate && current.l_category != EndAlternate) {
            if (token[NbName] == NULL) {
                IF_DBG(NBT_DEBUG_LMHOST)
                KdPrint(("Nbt.PrimeCache: Error line in Lmhost file\n"));
                continue;
            }
        }

        if (current.l_preload)
        {
            status = ConvertDottedDecimalToUlong(token[IpAddress],&inaddr);

            if (NT_SUCCESS(status))
            {
                status = PreloadEntry (token[NbName], inaddr);
                if (NT_SUCCESS(status))
                {
                    nentries++;
                }
            }
        }
        switch ((ULONG)current.l_category)
        {
        case Domain:
            if ((nwords - 1) < GroupName)
            {
                continue;
            }

            //
            // and add '1C' on the end
            //
            LmExpandName(Name, token[GroupName]+ domtoklen, SPECIAL_GROUP_SUFFIX);

            status = ConvertDottedDecimalToUlong(token[IpAddress],&IpAddr);
            if (NT_SUCCESS(status))
            {
                AddToDomainList (Name, IpAddr, &TmpDomainList, (BOOLEAN)current.l_preload);
            }

            continue;

        case Include:

            if (!RecurseDepth || ((incstate == SkipInclude) || (nwords < 2)))
            {
                continue;
            }

#ifdef VXD
            //
            // the buffer which we read into is reused for the next file: we
            // need the contents when we get back: back it up!
            // if we can't allocate memory, just skip this include
            //
            if ( !BackupCurrentData(pfile) )
            {
                continue;
            }
#endif

            temp = LmInclude(token[1], PrimeCache, NULL, (CHAR) (RecurseDepth-1), NULL);

#ifdef VXD
            //
            // going back to previous file: restore the backed up data
            //
            RestoreOldData(pfile);
#endif

            if (temp != -1)
            {

                if (incstate == TryToInclude)
                {
                    incstate = SkipInclude;
                }
                nentries += temp;
                continue;
            }

            continue;

        case BeginAlternate:
            ASSERT(nwords == 1);
            incstate = TryToInclude;
            continue;

        case EndAlternate:
            ASSERT(nwords == 1);
            incstate = MustInclude;
            continue;

        default:
            continue;
        }

    }

    status = LmCloseFile(pfile);
    ASSERT(status == STATUS_SUCCESS);

    //
    // make this the new domain list
    //
    MakeNewListCurrent(&TmpDomainList);

    ASSERT(nentries >= 0);
    return(nentries);


} // LmPrimeCache

//----------------------------------------------------------------------------
extern
VOID
GetContext(
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext
    )

/*++

Routine Description:

    This function is called to get the context value to check if a name
    query has been cancelled or not.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    CTELockHandle           OldIrq;
    NBT_WORK_ITEM_CONTEXT   *pContext;

    //
    // remove the Context value and return it.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pContext = LmHostQueries.Context)
    {
        if ((*ppContext) &&
            (*ppContext != pContext))
        {
            pContext = NULL;
        }
#ifndef VXD
        else if (NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp)
                == STATUS_CANCELLED)
        {
            pContext = NULL;
        }
        else
#endif // VXD
        {
            LmHostQueries.Context = NULL;
        }
    }
    *ppContext = pContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
extern
NTSTATUS
ChangeStateOfName (
    IN      tIPADDRESS              IpAddress,
    IN      NBT_WORK_ITEM_CONTEXT   *pContext,
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext,
    IN  USHORT                      NameAddFlags
    )

/*++

Routine Description:

    This function changes the state of a name and nulls the Context
    value in lmhostqueries.

Arguments:

    pContext    -   The Context value if it has been removed from the
                    LmHostQueries.Context ptr.
    ppContext   -   The Context we are processing

Return Value:

    none

--*/


{
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    tDEVICECONTEXT          *pDeviceContext;

    pDeviceContext = GetDeviceFromInterface(htonl(IpAddress), TRUE);
    if (pContext == NULL)
    {
        //
        // See if the name query is still active
        //
        pContext = *ppContext;
        GetContext (&pContext);
    }

    if (pContext)
    {
        // convert broadcast addresses to zero since NBT interprets zero
        // to be broadcast
        //
        if (IpAddress == (ULONG)-1)
        {
            IpAddress = 0;
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                 pContext->pTracker->pNameAddr->Name,
                                 NbtConfig.pScope,
                                 IpAddress,
                                 NBT_UNIQUE,
                                 NULL,
                                 NULL,
                                 pDeviceContext,
                                 NameAddFlags);
        //
        // this will free the pNameAddr, so do not access this after this point
        //
        NBT_DEREFERENCE_NAMEADDR (pContext->pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        pContext->pTracker->pNameAddr = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        *ppContext = pContext;
    }
    else
    {
        *ppContext = NULL;
    }

    if (pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
RemoveLmHRequests(
    IN  tLMHSVC_REQUESTS    *pLmHRequest,
    IN  PLIST_ENTRY         pTmpHead,
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine is called to find timed out entries in the queue of
    lmhost or dns name queries.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext;
    BOOLEAN                 fRestartTimer = FALSE;

    //
    // check the currently processing LMHOSTS entry
    //
    if (pLmHRequest->Context)
    {
        pWiContext = (NBT_WORK_ITEM_CONTEXT *) pLmHRequest->Context;
        if ((pWiContext->TimedOut) || (pWiContext->pDeviceContext == pDeviceContext))
        {
            pLmHRequest->Context = NULL;
            InsertTailList(pTmpHead, &pWiContext->Item.List);
#ifndef VXD
            // Not for win95, MohsinA, 05-Dec-96.
            NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *) (pWiContext->pClientContext))->pClientIrp);
#endif
        }
        else
        {
            //
            // restart the timer
            //
            fRestartTimer = TRUE;
            pWiContext->TimedOut = TRUE;
        }
    }

    //
    // Check the list of queued entries
    //
    if (!IsListEmpty(&pLmHRequest->ToResolve))
    {
        //
        // restart the timer
        //
        fRestartTimer = TRUE;

        pEntry = pLmHRequest->ToResolve.Flink;
        while (pEntry != &pLmHRequest->ToResolve)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);
            pEntry = pEntry->Flink;

            if ((pWiContext->TimedOut) || (pWiContext->pDeviceContext == pDeviceContext))
            {
                //
                // save on a temporary list and complete below
                //
                RemoveEntryList(&pWiContext->Item.List);
                InsertTailList(pTmpHead, &pWiContext->Item.List);
            }
            else
            {
                pWiContext->TimedOut = TRUE;
            }
        }
    }

    if ((fRestartTimer) && (pTimerQEntry))
    {
        pTimerQEntry->Flags |= TIMER_RESTART;
    }
}


//----------------------------------------------------------------------------
VOID
TimeoutLmHRequests(
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  BOOLEAN             fLocked,
    IN  CTELockHandle       *pJointLockOldIrq
    )
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext;
    LIST_ENTRY              TmpHead;

    InitializeListHead(&TmpHead);

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    }

    //
    // check the currently processing LMHOSTS entry
    //
    RemoveLmHRequests (&LmHostQueries, &TmpHead, pTimerQEntry, pDeviceContext);
    RemoveLmHRequests (&CheckAddr, &TmpHead, pTimerQEntry, pDeviceContext);
#ifndef VXD
    RemoveLmHRequests (&DnsQueries, &TmpHead, pTimerQEntry, pDeviceContext);
#endif

    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);

    if (!IsListEmpty(&TmpHead))
    {
        pHead = &TmpHead;
        pEntry = pHead->Flink;

        while (pEntry != pHead)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);
            pEntry = pEntry->Flink;
            RemoveEntryList(&pWiContext->Item.List);

            IF_DBG(NBT_DEBUG_LMHOST)
                KdPrint(("Nbt.TimeoutLmHRequests: Context=<%p>, pDeviceContext=<%p>\n",
                    pWiContext, pDeviceContext));

            RemoveNameAndCompleteReq(pWiContext,STATUS_TIMEOUT);
        }
    }

    if (fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
LmHostTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It
    marks all items in Lmhosts/Dns q as timed out and completes any that have
    already timed out with status timeout.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    CTELockHandle           OldIrq;

    //
    // If the timer is NULL, it means that the Timer is currently
    // being stopped (usually at Unload time), so don't do anything!
    //
    if (!pTimerQEntry)
    {
        LmHostQueries.pTimer = NULL;
        return;
    }

    TimeoutLmHRequests (pTimerQEntry, NULL, FALSE, &OldIrq);

    // null the timer if we are not going to restart it.
    //
    if (!(pTimerQEntry->Flags & TIMER_RESTART))
    {
        LmHostQueries.pTimer = NULL;
    }
}


//----------------------------------------------------------------------------
extern
VOID
StartLmHostTimer(
    IN NBT_WORK_ITEM_CONTEXT   *pContext,
    IN BOOLEAN                 fLockedOnEntry
    )

/*++
Routine Description

    This routine handles setting up a timer to time the Lmhost entry.
    The Joint Spin Lock may be held when this routine is called

Arguments:


Return Values:

    VOID

--*/

{
    NTSTATUS        status;
    tTIMERQENTRY    *pTimerEntry;
    CTELockHandle   OldIrq;

    if (!fLockedOnEntry)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    pContext->TimedOut = FALSE;

    //
    // start the timer if it is not running
    //
    if (!LmHostQueries.pTimer)
    {
        status = StartTimer(LmHostTimeout,
                            NbtConfig.LmHostsTimeout,
                            NULL,                // context value
                            NULL,                // context2 value
                            NULL,
                            NULL,
                            NULL,
                            &pTimerEntry,
                            0,
                            TRUE);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.StartLmHostTimer: Start Timer to time Lmhost Qing for pContext= %x,\n", pContext));

        if (NT_SUCCESS(status))
        {
            LmHostQueries.pTimer = pTimerEntry;
        }
        else
        {
            // we failed to get a timer, but that is not
            // then end of the world.  The lmhost query will just
            // not timeout in 30 seconds.  It may take longer if
            // it tries to include a remove file on a dead machine.
            //
            LmHostQueries.pTimer = NULL;
        }
    }

    if (!fLockedOnEntry)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
LmHostQueueRequest(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  PVOID                   pDeviceContext
    )
/*++

Routine Description:

    This routine exists so that LmHost requests will not take up more than
    one executive worker thread.  If a thread is busy performing an Lmhost
    request, new requests are queued otherwise we could run out of worker
    threads and lock up the system.

    The Joint Spin Lock is held when this routine is called

Arguments:
    pTracker        - the tracker block for context
    DelayedWorkerRoutine - the routine for the Workerthread to call
    pDeviceContext  - dev context that initiated this

Return Value:


--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    tDGRAM_SEND_TRACKING    *pTrackClient;
    PCTE_IRP                pIrp;
    BOOLEAN                 OnList;

    if (pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('V')))
    {
        pContext->pTracker = pTracker;
        pContext->pClientContext = pClientContext;
        pContext->ClientCompletion = ClientCompletion;
        pContext->pDeviceContext = pDeviceContext;
        pContext->TimedOut = FALSE;

        if (LmHostQueries.ResolvingNow)
        {
            // Lmhosts is busy resolving another name, so wait for it to return
            // mean while, Queue the name query
            //
            InsertTailList(&LmHostQueries.ToResolve,&pContext->Item.List);
            OnList = TRUE;
        }
        else
        {
            LmHostQueries.Context = pContext;
            LmHostQueries.ResolvingNow = TRUE;
            OnList = FALSE;

            if (!NT_SUCCESS (CTEQueueForNonDispProcessing (DelayedScanLmHostFile,
                                                           pTracker,
                                                           pClientContext,
                                                           ClientCompletion,
                                                           pDeviceContext,
                                                           TRUE)))
            {
                LmHostQueries.Context = NULL;
                LmHostQueries.ResolvingNow = FALSE;
                CTEMemFree(pContext);
                return (STATUS_UNSUCCESSFUL);
            }
        }

        //
        // To prevent this name query from languishing on the Lmhost Q when
        // a #include on a dead machine is trying to be openned, start the
        // connection setup timer
        //
        StartLmHostTimer(pContext, TRUE);

        //
        // this is the session setup tracker
        //
#ifndef VXD
        pTrackClient = (tDGRAM_SEND_TRACKING *)pClientContext;
        if (pIrp = pTrackClient->pClientIrp)
        {
            //
            // allow the client to cancel the name query Irp
            //
            // but do not call NTSetCancel... since it takes need to run
            // at non DPC level, and it calls the completion routine
            // which takes the JointLock that we already have.
            //
            status = NTCheckSetCancelRoutine(pTrackClient->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
            if (status == STATUS_CANCELLED)
            {
                //
                // since the name query is cancelled do not let lmhost processing
                // handle it.
                //
                if (OnList)
                {
                    RemoveEntryList(&pContext->Item.List);
                }
                else
                {
                    //
                    // do not set resolving now to False since the work item
                    // has been queued to the worker thread
                    //
                    LmHostQueries.Context = NULL;
                    LmHostQueries.ResolvingNow = FALSE;
                }

                CTEMemFree(pContext);
            }
            return(status);
        }
#endif
        status = STATUS_SUCCESS;
    }

    return(status);
}

//----------------------------------------------------------------------------
extern
NBT_WORK_ITEM_CONTEXT *
GetNameToFind(
    OUT PUCHAR      pName
    )

/*++

Routine Description:

    This function is called to get the name to query from the LmHostQueries
    list.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    NBT_WORK_ITEM_CONTEXT   *Context;
    PLIST_ENTRY             pEntry;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    // if the context value has been cleared then that name query has been
    // cancelled, so check for another one.
    //
    if (!(Context = LmHostQueries.Context))
    {
        //
        // the current name query got canceled so see if there are any more
        // to service
        //
        if (!IsListEmpty(&LmHostQueries.ToResolve))
        {
            pEntry = RemoveHeadList(&LmHostQueries.ToResolve);
            Context = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);
            LmHostQueries.Context = Context;
        }
        else
        {
            //
            // no more names to resolve, so clear the flag
            //
            LmHostQueries.ResolvingNow = FALSE;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            return(NULL);
        }
    }
    pTracker = ((NBT_WORK_ITEM_CONTEXT *)Context)->pTracker;


    CTEMemCopy(pName,pTracker->pNameAddr->Name,NETBIOS_NAME_SIZE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(Context);
}
//----------------------------------------------------------------------------
extern
VOID
RemoveNameAndCompleteReq (
    IN NBT_WORK_ITEM_CONTEXT    *pContext,
    IN NTSTATUS                 status
    )

/*++

Routine Description:

    This function removes the name, cleans up the tracker
    and then completes the clients request.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientContext;
    PVOID                   pClientCompletion;
    CTELockHandle           OldIrq;

    // if pContext is null the name query was cancelled during the
    // time it took to go read the lmhosts file, so don't do this
    // stuff
    //
    if (pContext)
    {
        pTracker = pContext->pTracker;
        pClientCompletion = pContext->ClientCompletion;
        pClientContext = pContext->pClientContext;

        CTEMemFree(pContext);

#ifndef VXD
        //
        // clear out the cancel routine if there is an irp involved
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NbtCancelCancelRoutine( ((tDGRAM_SEND_TRACKING *)(pClientContext))->pClientIrp );
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
#endif

        // remove the name from the hash table, since it did not resolve
        if (pTracker)
        {
            if ((status != STATUS_SUCCESS) &&
                (pTracker->pNameAddr))
            {
                SetNameState (pTracker->pNameAddr, NULL, FALSE);
                pTracker->pNameAddr = NULL;
            }

            // free the tracker and call the completion routine.
            //
            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        }

        if (pClientCompletion)
        {
            CompleteClientReq(pClientCompletion, pClientContext, status);
        }
    }
}

//----------------------------------------------------------------------------
//
//  Alternative to the c-runtime
//
#ifndef VXD
PCHAR
Nbtstrcat( PUCHAR pch, PUCHAR pCat, LONG Len )
{
    STRING StringIn;
    STRING StringOut;

    RtlInitAnsiString(&StringIn, pCat);
    RtlInitAnsiString(&StringOut, pch);
    StringOut.MaximumLength = (USHORT)Len;
    //
    // increment to include the null on the end of the string since
    // we want that on the end of the final product
    //
    StringIn.Length++;
    RtlAppendStringToString(&StringOut,&StringIn);

    return(pch);
}
#else
#define Nbtstrcat( a,b,c ) strcat( a,b )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\name.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Name.c

Abstract:

    This file implements Tdi interface into the Top of NBT.  In the NT
    implementation, ntisol.c calls these routines after extracting the
    relevent information from the Irp passed in from the Io subsystem.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"   // procedure headings
#ifndef VXD

#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#endif // RASAUTODIAL
#include "name.tmh"
#endif

//
// Allocate storage for the configuration information and setup a ptr to
// it.
//
tNBTCONFIG      NbtConfig;
tNBTCONFIG      *pNbtGlobConfig = &NbtConfig;
BOOLEAN         CachePrimed;

//
// This structure is used to store name query and registration statistics
//
tNAMESTATS_INFO NameStatsInfo;
#ifndef VXD
//
// this tracks the original File system process that Nbt was booted by, so
// that handles can be created and destroyed in that process
//
PEPROCESS   NbtFspProcess;
#endif
//
// this describes whether we are a Bnode, Mnode, MSnode or Pnode
//
USHORT      RegistryNodeType;
USHORT      NodeType;
//
// this is used to track the memory allocated for datagram sends
//
ULONG       NbtMemoryAllocated;

// this is used to track used trackers to help solve cases where they all
// are used.
//
//#if DBG

LIST_ENTRY  UsedTrackers;

//#endif

#ifdef VXD
ULONG   DefaultDisconnectTimeout;
#else
LARGE_INTEGER DefaultDisconnectTimeout;
#endif

// ************* REMOVE LATER *****************88
BOOLEAN StreamsStack;

#ifdef DBG
//
// Imported routines.
//
#endif

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    );

//
// Function prototypes for functions local to this file
//
VOID
CleanupFromRegisterFailed(
    IN  PUCHAR      pNameRslv,
    IN  tCLIENTELE  *pClientEle
        );

VOID
SendDgramContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
CTECountedAllocMem(
    PVOID   *pBuffer,
    ULONG   Size
    );

VOID
CTECountedFreeMem(
    IN PVOID    pBuffer,
    IN ULONG    Size,
    IN BOOLEAN  fJointLockHeld
    );

VOID
SendNextDgramToGroup(
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN  NTSTATUS            status
    );

VOID
SendDgramCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
DgramSendCleanupTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  BOOLEAN                 fJointLockHeld
    );

VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
SessionStartupCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);


VOID
SendNodeStatusContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );


NTSTATUS
SendToResolvingName(
    IN  tNAMEADDR               *pNameAddr,
    IN  PCHAR                   pName,
    IN  CTELockHandle           OldIrq,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   QueryCompletion
        );

NTSTATUS
StartSessionTimer(
    tDGRAM_SEND_TRACKING    *pTracker,
    tCONNECTELE             *pConnEle
    );

VOID
QueryNameCompletion(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

#ifndef VXD
VOID
NTClearFindNameInfo(
    tDGRAM_SEND_TRACKING    *pTracker,
    PIRP                    *ppClientIrp,
    PIRP                    pIrp,
    PIO_STACK_LOCATION      pIrpSp
    );
#endif  // !VXD

NTSTATUS
FindNameOrQuery(
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  ULONG                   NameFlags,
    OUT tIPADDRESS              *IpAddress,
    OUT tNAMEADDR               **pNameAddr,
    IN  ULONG                   NameReferenceContext,
    IN  BOOLEAN                 DgramSend
    );

#ifdef RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

VOID
NbtRetryPreConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

VOID
NbtCancelPreConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
NbtRetryPostConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

BOOLEAN
NbtAttemptAutoDial(
    IN  tCONNECTELE                 *pConnEle,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp,
    IN  ULONG                       ulFlags,
    IN  ACD_CONNECT_CALLBACK        pProc
    );

VOID
NbtNoteNewConnection(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       IPAddress
    );
#endif // RASAUTODIAL

NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

NTSTATUS
GetListOfAllAddrs(
    IN tNAMEADDR   *pNameAddr,
    IN tNAMEADDR   *p1CNameAddr,
    IN tIPADDRESS  **ppIpBuffer,
    IN ULONG       *pNumAddrs
    );

BOOL
IsLocalAddress(
    tIPADDRESS  IpAddress
    );

BOOL
IsSmbBoundToOutgoingInterface(
    IN  tIPADDRESS      IpAddress
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtOpenConnection)
#pragma CTEMakePageable(PAGE, NbtSendDatagram)
#pragma CTEMakePageable(PAGE, BuildSendDgramHdr)
#pragma CTEMakePageable(PAGE, DelayedNbtResyncRemoteCache)
#pragma CTEMakePageable(PAGE, NbtQueryFindName)
#pragma CTEMakePageable(PAGE, NbtCloseAddress)
#pragma CTEMakePageable(PAGE, NbtCloseConnection)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
PickBestAddress(
    IN  tNAMEADDR       *pNameAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tIPADDRESS      *pIpAddress
    )
/*++
Routine Description:

    This Routine picks the best address on a name based on strictness of Source addressing specified
    -- MUST be called with the JointLock held!

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tDEVICECONTEXT  *pThisDeviceContext;
    LIST_ENTRY      *pHead, *pEntry;
    BOOLEAN         fFreeGroupList = FALSE;
    tIPADDRESS      IpAddress = 0;
    tIPADDRESS      *pIpNbtGroupList = NULL;

    CHECK_PTR (pNameAddr);
    CHECK_PTR (pDeviceContext);

    if (pNameAddr->Verify == REMOTE_NAME)
    {
        //
        // Check if this is a pre-loaded name!
        //
        if (pNameAddr->NameAddFlags & NAME_RESOLVED_BY_LMH_P)
        {
            IpAddress = pNameAddr->IpAddress;
            pIpNbtGroupList = pNameAddr->pLmhSvcGroupList;
        }
        //
        // See if we can find the preferred address
        //
        else if (((IsDeviceNetbiosless(pDeviceContext)) && (pNameAddr->pRemoteIpAddrs[0].IpAddress)) ||
                 ((!IsDeviceNetbiosless(pDeviceContext)) &&
                  (pNameAddr->RemoteCacheLen > pDeviceContext->AdapterNumber) &&
                  (pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))
        {
            IpAddress = pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].IpAddress;
            pIpNbtGroupList = pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs;
        }
        //
        // If strict source routing was not set, then pick the last updated address
        //
        if ((!NbtConfig.ConnectOnRequestedInterfaceOnly) &&
                 (!IpAddress) && (!pIpNbtGroupList))
        {
            if (STATUS_SUCCESS == GetListOfAllAddrs(pNameAddr, NULL, &pIpNbtGroupList, NULL))
            {
                fFreeGroupList = TRUE;
            }
            else
            {
                pIpNbtGroupList = NULL;     // for safety
            }
        }

        //
        // If this was a Group name, then IpAddress can be 0!
        //
        if ((!IpAddress) && (pIpNbtGroupList)) {
            //
            // Pick the first non-zero address from the group list
            //
            int i;

            for (i = 0; pIpNbtGroupList[i] != (tIPADDRESS) -1; i++) {
                if (pIpNbtGroupList[i]) {
                    IpAddress = pIpNbtGroupList[i];
                    break;
                }
            }
        }

        if (fFreeGroupList)
        {
            CTEMemFree(pIpNbtGroupList);
        }
    }
    else
    {
        ASSERT (pNameAddr->Verify == LOCAL_NAME);
        //
        // For local names, first check if the name is registered on this device
        //
        if ((!(IsDeviceNetbiosless(pDeviceContext)) && (pDeviceContext->IpAddress) &&
             (pNameAddr->AdapterMask & pDeviceContext->AdapterMask)) ||
            ((IsDeviceNetbiosless(pDeviceContext)) &&
             (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV)))
        {
            IpAddress = pDeviceContext->IpAddress;
        }
        //
        // If the strict source routing option is not set, then return the first valid local address
        //
        else if (!NbtConfig.ConnectOnRequestedInterfaceOnly)
        {
            //
            // Find the first device with a valid IP address that this name is registered on
            //
            pHead = pEntry = &NbtConfig.DeviceContexts;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pThisDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if ((pThisDeviceContext->IpAddress) &&
                    (pThisDeviceContext->AdapterMask & pNameAddr->AdapterMask))
                {
                    IpAddress = pThisDeviceContext->IpAddress;
                    pNameAddr->IpAddress = pThisDeviceContext->IpAddress;
                    break;
                }
            }

            //
            // If we failed to find the name registered on any of the legacy
            // devices, then we should check if the name is registered on the
            // SMBDevice and if so, return its IP address.
            //
            if ((!IpAddress) &&
                (pNbtSmbDevice) &&
                (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV))
            {
                IpAddress = pNbtSmbDevice->IpAddress;
            }
        }
    }

    if ((IpAddress) && (pIpAddress))
    {
        *pIpAddress = IpAddress;
        return (STATUS_SUCCESS);
    }

    return (STATUS_UNSUCCESSFUL);
}

//----------------------------------------------------------------------------
VOID
RemoveDuplicateAddresses(
    tIPADDRESS  *pIpAddrBuffer,
    ULONG       *pNumAddrs
    )
{
    ULONG       NumAddrs = *pNumAddrs;
    ULONG       i, j;

    for (i=0; i<NumAddrs; i++) {
        for (j=i+1; j<NumAddrs; j++) {
            if (pIpAddrBuffer[i] == pIpAddrBuffer[j]) {
                NumAddrs--;
                pIpAddrBuffer[j] = pIpAddrBuffer[NumAddrs];
                j--;
            }
        }
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.RemoveDuplicateAddresses: NumAddresses = <%d> --> <%d>\n", *pNumAddrs, NumAddrs));

    *pNumAddrs = NumAddrs;
}

VOID
CountAndCopyAddrs(
    tIPADDRESS  *pIpAddrSrc,
    tIPADDRESS  *pIpAddrDest,
    ULONG       *pNumAddrs
    )
{
    ULONG       NumAddrs = *pNumAddrs;

    if (pIpAddrSrc)
    {
        while (*pIpAddrSrc != (ULONG)-1)
        {
            if (*pIpAddrSrc)
            {
                if (pIpAddrDest)
                {
                    pIpAddrDest[NumAddrs] = *pIpAddrSrc;
                }
                NumAddrs++;
            }

            pIpAddrSrc++;
        }
    }

    *pNumAddrs = NumAddrs;
}


//----------------------------------------------------------------------------
NTSTATUS
GetListOfAllAddrs(
    IN tNAMEADDR   *pNameAddr,
    IN tNAMEADDR   *p1CNameAddr,
    IN tIPADDRESS  **ppIpBuffer,
    IN ULONG       *pNumAddrs
    )
{
    ULONG       i;
    tIPADDRESS  *pIpBuffer;
    tIPADDRESS  *pIpAddr;
    ULONG       NumAddrs = 0;
    BOOLEAN     fAddBcastAddr = FALSE;

    *ppIpBuffer = NULL;
    if (pNumAddrs)
    {
        *pNumAddrs = 0;
    }

    //
    // First count all the addresses
    //
    if (pNameAddr->pLmhSvcGroupList) // if the name was Preloaded from LmHosts
    {
        ASSERT(pNameAddr->NameTypeState & NAMETYPE_INET_GROUP);
        CountAndCopyAddrs (pNameAddr->pLmhSvcGroupList, NULL, &NumAddrs);
    }
    else
    {
        if (pNameAddr->IpAddress)
        {
            NumAddrs++;
        }

        //
        // RemoteCacheLen will be 0 if we had failed to allocate the pRemoteIpAddrs structure earlier
        //
        for (i=0; i<pNameAddr->RemoteCacheLen; i++)
        {
            CountAndCopyAddrs (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs, NULL, &NumAddrs);
            if (pNameAddr->pRemoteIpAddrs[i].IpAddress)
            {
                NumAddrs++;
            }
        }
    }

    if (p1CNameAddr)
    {
        //
        // This would a name that was added through LmHosts, so it will
        // not have been resolved-per-interface from Wins!
        //
        ASSERT((p1CNameAddr->NameTypeState & NAMETYPE_INET_GROUP) && (!p1CNameAddr->pRemoteIpAddrs));
        CountAndCopyAddrs (p1CNameAddr->pLmhSvcGroupList, NULL, &NumAddrs);
    }

    if (!NumAddrs)
    {
        return (STATUS_BAD_NETWORK_PATH);
    }

    NumAddrs++;  // For the terminating address
    if ((pNameAddr->NameTypeState & NAMETYPE_INET_GROUP) &&
        (!(pNameAddr->fPreload)))
    {
        // Add the bcast address
        fAddBcastAddr = TRUE;
        NumAddrs++; // For the bcast address
    }

    if (!(pIpBuffer = NbtAllocMem((NumAddrs*sizeof(tIPADDRESS)),NBT_TAG('N'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Now copy all the addresses starting with the broadcast address if necessary
    //
    NumAddrs = 0;
    if (fAddBcastAddr)
    {
        pIpBuffer[0] = 0;
        NumAddrs++;
    }

    if (pNameAddr->pLmhSvcGroupList) // if the name was Preloaded from LmHosts
    {
        CountAndCopyAddrs (pNameAddr->pLmhSvcGroupList, pIpBuffer, &NumAddrs);
    }
    else
    {
        if (pNameAddr->IpAddress)
        {
            pIpBuffer[NumAddrs] = pNameAddr->IpAddress;
            NumAddrs++;
        }
        for (i=0; i<pNameAddr->RemoteCacheLen; i++)
        {
            CountAndCopyAddrs (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs, pIpBuffer, &NumAddrs);
            if (pNameAddr->pRemoteIpAddrs[i].IpAddress)
            {
                pIpBuffer[NumAddrs] = pNameAddr->pRemoteIpAddrs[i].IpAddress;
                NumAddrs++;
            }
        }
    }

    if (p1CNameAddr)
    {
        CountAndCopyAddrs (p1CNameAddr->pLmhSvcGroupList, pIpBuffer, &NumAddrs);
    }

    RemoveDuplicateAddresses(pIpBuffer, &NumAddrs);
    pIpBuffer[NumAddrs] = (tIPADDRESS)-1;

    *ppIpBuffer = pIpBuffer;
    if (pNumAddrs)
    {
        *pNumAddrs = NumAddrs;
    }
    return (STATUS_SUCCESS);
}



VOID
FilterIpAddrsForDevice(
    IN tIPADDRESS       *pIpAddr,
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            *pNumAddrs
    )
{
    ULONG   i;
    ULONG   Interface, Metric;
    ULONG   NumAddrs = *pNumAddrs;

    ASSERT (NumAddrs > 0);
    if (NbtConfig.SendDgramOnRequestedInterfaceOnly)
    {
        for (i=1; i<NumAddrs; i++)
        {
            pDeviceContext->pFastQuery(ntohl(pIpAddr[i]), &Interface, &Metric);
            if (Interface != pDeviceContext->IPInterfaceContext)
            {
                pIpAddr[i] = pIpAddr[NumAddrs-1];
                NumAddrs--;
                i--;
            }
        }

        *pNumAddrs = NumAddrs;
        pIpAddr[NumAddrs] = (tIPADDRESS) -1;
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  TA_ADDRESS          *pTaAddress,
    IN  tIPADDRESS          IpAddress,
    IN  PVOID               pSecurityDescriptor,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp)
/*++
Routine Description:

    This Routine handles opening an address for a Client.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS             status;
    tADDRESSELE          *pAddrElement;
    tCLIENTELE           *pClientEle;
    USHORT               uAddrType;
    CTELockHandle        OldIrq;
    CTELockHandle        OldIrq1;
    PUCHAR               pNameRslv;
    tNAMEADDR            *pNameAddr;
    COMPLETIONCLIENT     pClientCompletion;
    PVOID                Context;
    tTIMERQENTRY         *pTimer;
    BOOLEAN              MultiHomedReRegister = FALSE;
    BOOLEAN              DontIncrement= FALSE;
    ULONG                TdiAddressType;
    UCHAR                *BroadcastName = "\x2a\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0";
    LIST_ENTRY           *pClientEntry;
    tCLIENTELE           *pClientEleTemp;
    BOOLEAN              fFirstClientOnDevice = TRUE;

    ASSERT(pTaAddress);
    if (!IpAddress)
    {
        //
        // when there is no ip address yet, use the Loop back address as
        // a default rather than null, since null tells NbtRegisterName
        // that the address is already in the name table and it only needs
        // to be reregistered.
        //
        IpAddress = LOOP_BACK;
    }

    TdiAddressType = pTaAddress->AddressType;
    switch (TdiAddressType)
    {
        case TDI_ADDRESS_TYPE_NETBIOS:
        {
            PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTaAddress->Address;

            uAddrType = pNetbiosAddress->NetbiosNameType;
            pNameRslv = pNetbiosAddress->NetbiosName;

            break;
        }

#ifndef VXD
        case TDI_ADDRESS_TYPE_NETBIOS_EX:
        {
            // The NETBIOS_EX address passed in will have two components,
            // an Endpoint name as well as the NETBIOS address.
            // In this implementation we ignore the second
            // component and register the Endpoint name as a netbios
            // address.

            PTDI_ADDRESS_NETBIOS_EX pNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pTaAddress->Address;

            uAddrType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            pNameRslv = pNetbiosExAddress->EndpointName;

            break;
        }
#endif

        default:
            return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // If the name is a Broadcast name, it can only be opened as a Group name
    //
    if ((CTEMemEqu (BroadcastName, pNameRslv, NETBIOS_NAME_SIZE)) &&
        (uAddrType != NBT_GROUP))
    {
        KdPrint (("Nbt.NbtOpenAddress: Warning: Opening broadcast name as Groupname!\n"));
        uAddrType = NBT_GROUP;
    }

    // check for a zero length address, because this means that the
    // client wants to receive "Netbios Broadcasts" which are names
    // that start with "*...." ( and 15 0x00's ).  However they should have
    // queried the broadcast address with NBT which would have returned
    // "*....'
    //

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtOpenAddress: Name=<%-16.16s:%x>, pDevice=<%p>\n",
            pNameRslv, pNameRslv[15], pContext));

    //
    // be sure the broadcast name has 15 zeroes after it
    //
    if ((pNameRslv[0] == '*') && (TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS))
    {
        CTEZeroMemory(&pNameRslv[1],NETBIOS_NAME_SIZE-1);
    }

    // this synchronizes access to the local name table when a new name
    // is registered.  Basically it will not let the second registrant through
    // until the first has put the name into the local table (i.e.
    // NbtRegisterName has returned )
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    // see if the name is registered on the local node.. we call the hash
    // table function directly rather than using findname, because find name
    // checks the state of the name too.  We want to know if the name is in
    // the table at all, and don't care if it is still resolving.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pNameAddr = NULL;
    status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pNameRslv, NbtConfig.pScope, &pNameAddr);

    //
    // the name could be in the hash table, but the address element deleted
    //
    if (!NT_SUCCESS(status) || !pNameAddr->pAddressEle)
    {
        //
        // pNameAddr->pAddressEle is NULL <==> the Name is currently being released
        //
        if (pNameAddr)
        {
            //
            // Check if the name is about to be released on this adapter
            //
            if (pNameAddr->AdapterMask & pContext->AdapterMask)
            {
                pNameAddr->AdapterMask &= ~pContext->AdapterMask;
            }
            //
            // Check if the name is currently being released on this adapter
            //
            else if (pNameAddr->ReleaseMask & pContext->AdapterMask)
            {
                // Set the ReleaseMask bit to 0 so that the Timeout routine
                // does does not send this release out on the wire again
                //
                pNameAddr->ReleaseMask &= ~pContext->AdapterMask;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // open the name since it could not be found
        //
        // first of all allocate memory for the address block
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        if (pAddrElement = (tADDRESSELE *) NbtAllocMem(sizeof (tADDRESSELE),NBT_TAG('C')))
        {
            CTEZeroMemory(pAddrElement,sizeof(tADDRESSELE));
            InitializeListHead(&pAddrElement->Linkage);
            InitializeListHead(&pAddrElement->ClientHead);
            CTEInitLock(&pAddrElement->LockInfo.SpinLock);
#if DBG
            pAddrElement->LockInfo.LockNumber = ADDRESS_LOCK;
#endif
            pAddrElement->AddressType = TdiAddressType;
            if ((uAddrType == NBT_UNIQUE ) || (uAddrType == NBT_QUICK_UNIQUE))
            {
                pAddrElement->NameType = NBT_UNIQUE;
            }
            else
            {
                pAddrElement->NameType = NBT_GROUP;;
            }

            pAddrElement->Verify = NBT_VERIFY_ADDRESS;
            NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);

            // create client block and link to addresslist.  This allows multiple
            // clients to open the same address - for example a group name must
            // be able to handle multiple clients, each receiving datagrams to it.
            //
            if (pClientEle = NbtAllocateClientBlock(pAddrElement, pContext))
            {
                pClientEle->AddressType = TdiAddressType;
                pClientEle->pIrp = pIrp; // Track Irp -- complete it when the name registration completes
#ifndef VXD
                // set the share access ( NT only ) - security descriptor stuff
                if (pIrp)
                {
                    status = NTSetSharedAccess(pContext,pIrp,pAddrElement);
                }
                else
                {
                    status = STATUS_SUCCESS;
                }

                if (!NT_SUCCESS(status))
                {
                    // unable to set the share access correctly so release the
                    // address object and the client block connected to it
                    NbtFreeAddressObj(pAddrElement);
                    NbtFreeClientObj(pClientEle);

                    CTEExReleaseResource(&NbtConfig.Resource);
                    return(status);
                }

                // fill in the context values passed back to the client. These must
                // be done before the name is registered on the network because the
                // registration can succeed (or fail) before this routine finishes).
                // Since this routine can be called by NBT itself, pIrp may not be set,
                // so check for it.
                //
                if (pIrp)
                {
                    NTSetFileObjectContexts( pClientEle->pIrp,(PVOID)pClientEle, (PVOID)(NBT_ADDRESS_TYPE));
                }
#endif //!VXD

                // pass back the client block address as a handle for future reference
                // to the client
                pRequest->Handle.AddressHandle = (PVOID)pClientEle;

                // then add it to name service local name Q, passing the address of
                // the block as a context value ( so that subsequent finds return the
                // context value.
                // we need to know if the name is a group name or a unique name.
                // This registration may take some time so we return STATUS_PENDING
                // to the client
                //

                NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
                status = NbtRegisterName (NBT_LOCAL,
                                          IpAddress,
                                          pNameRslv,
                                          NULL,
                                          pClientEle,            // context value
                                          (PVOID)NbtRegisterCompletion, // completion routine for
                                          uAddrType,                    // Name Srv to call
                                          pContext);
                //
                // ret status could be either status pending or status success since Quick
                // names return success - or status failure
                //
                if (!NT_SUCCESS(status))
                {
                    if (pIrp)
                    {
                        pClientEle->pIrp = NULL;
                        NTClearFileObjectContext(pIrp);
                    }

                    ASSERT(pAddrElement->RefCount == 2);
                    CTEExReleaseResource(&NbtConfig.Resource);

                    NBT_DEREFERENCE_CLIENT (pClientEle);
                    NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
                    return (status);
                }

                NbtTrace(NBT_TRACE_NAMESRV, ("Client open address %!NBTNAME!<%02x> ClientEle=%p",
                                        pNameRslv, (unsigned)pNameRslv[15], pClientEle));

                // link the address element to the head of the address list
                // The Joint Lock protects this operation.
                ExInterlockedInsertTailList(&NbtConfig.AddressHead,
                                            &pAddrElement->Linkage,
                                            &NbtConfig.JointLock.LockInfo.SpinLock);

                NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
            } // if pClientEle
            else
            {
                NbtFreeAddressObj(pAddrElement);
                pAddrElement = NULL;
            }

        } // if pAddrElement

    }
    else
    {
        pAddrElement = (tADDRESSELE *)pNameAddr->pAddressEle;

        // lock the address element so that we can
        // coordinate with the name registration response handling in NBtRegister
        // Completion below.
        //
        CTESpinLock(pAddrElement,OldIrq1);

        //
        // Write the correct Ip address to the table incase this
        // was a group name and has now changed to a unique
        // name, but don't overwrite with the loop back address because
        // that means that the adapter does not have an address yet.
        // For Group names the Ip address stays as 0, so we know to do a
        // broadcast.
        //
        if ((IpAddress != LOOP_BACK) &&
            (pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
        {
            pNameAddr->IpAddress = IpAddress;
        }

        //
        // increment here bef