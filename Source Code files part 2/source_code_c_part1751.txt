Terminate);
    void RemoveHead(ULONG Len);
    void RemoveMiddle(ULONG Start, ULONG Len);
    void RemoveTail(ULONG Len);
    HRESULT Resize(ULONG Len);
    void Free(void);
    
    void Empty(void)
    {
        m_DataUsed = 0;
    }
    HRESULT GetStatus(void)
    {
        return m_Status;
    }
    void SetStatus(HRESULT Status)
    {
        m_Status = Status;
    }
    ULONG GetReadRequest(void)
    {
        return m_ReadRequest;
    }
    ULONG GetReadDone(void)
    {
        return m_ReadDone;
    }
    void RequestRead(void)
    {
        InterlockedIncrement((LONG *)&m_ReadRequest);
    }
    void SetReadDone(ULONG Done)
    {
        m_ReadDone = Done;
    }
    PVOID GetDataBuffer(void)
    {
        return m_Data;
    }
    ULONG GetDataLen(void)
    {
        return m_DataUsed;
    }

    HRESULT Update(void);
    
    void UiRequestRead(void);
    HRESULT UiLockForRead(void);
    
    // Base implementation just returns S_OK for
    // buffers maintained in other ways.
    // ReadState should only be called in the engine thread.
    virtual HRESULT ReadState(void);
    
protected:
    void SetNoData(void)
    {
        m_Data = NULL;
        m_DataLen = 0;
        Empty();
    }

    ULONG m_ChangeBy;

    UINT m_UpdateMessage;
    HRESULT m_Status;
    ULONG m_ReadRequest;
    ULONG m_ReadDone;
    
    PBYTE m_Data;
    ULONG m_DataLen;
    ULONG m_DataUsed;
};

//----------------------------------------------------------------------------
//
// OutputToStateBuffer.
//
//----------------------------------------------------------------------------

class OutputToStateBuffer : public DefOutputCallbacks
{
public:
    OutputToStateBuffer(void)
    {
        m_Buffer = NULL;
    }

    void SetBuffer(StateBuffer* Buffer)
    {
        m_Buffer = Buffer;
    }

    HRESULT Start(BOOL Empty);
    HRESULT End(BOOL RemoveLastNewLine);

    ULONG GetLineCount(void)
    {
        return m_NewLineCount + m_PartialLine;
    }
    ULONG RecountLines(void)
    {
        m_NewLineCount = 0;
        AddLines((PSTR)m_Buffer->GetDataBuffer() + m_DataStart);
        return GetLineCount();
    }

    void ReplaceChar(char From, char To);
    
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );

private:
    void AddLines(PCSTR Start);

    StateBuffer* m_Buffer;
    ULONG m_DataStart;
    HRESULT m_Status;
    ULONG m_NewLineCount;
    ULONG m_PartialLine;
};

extern OutputToStateBuffer g_OutStateBuf;
extern OutputToStateBuffer g_UiOutStateBuf;

//----------------------------------------------------------------------------
//
// Dynamic state buffers.
//
//----------------------------------------------------------------------------

extern LIST_ENTRY g_StateList;

// Global lock for short operations where it doesn't matter
// if the threads block on each other briefly.  This lock should
// not be held longer than a fraction of a second.
// Used for protecting:
//   State buffer list.
//   g_Event values.
extern DBG_CRITICAL_SECTION g_QuickLock;

#define LockStateBuffer(Buffer) Dbg_EnterCriticalSection(&(Buffer)->m_Lock)
#define UnlockStateBuffer(Buffer) Dbg_LeaveCriticalSection(&(Buffer)->m_Lock)

#define AssertStateBufferLocked(Buffer) \
    Assert(Dbg_CriticalSectionOwned(&(Buffer)->m_Lock))

extern ULONG64 g_CodeIp;
// If g_CodeFileFound[0] == 0 no source file was found.
extern char g_CodeFileFound[];
// If g_CodeSymFile[0] == 0 no source symbol information was found.
extern char g_CodeSymFile[];
extern ULONG g_CodeLine;
extern BOOL g_CodeUserActivated;
extern ULONG g_CodeBufferSequence;

extern ULONG64 g_EventIp;
extern ULONG64 g_EventReturnAddr;
extern ULONG g_CurProcessId, g_CurProcessSysId;
extern ULONG g_CurThreadId, g_CurThreadSysId;

enum BpStateType
{
    BP_ENABLED,
    BP_DISABLED,
    BP_NONE,
    BP_UNKNOWN
};

struct BpBufferData
{
    ULONG64 Offset;
    ULONG Id;
    ULONG Flags;
    ULONG Thread;
    ULONG Sequence;
    ULONG FileOffset;
};
extern ULONG g_BpCount;
extern StateBuffer* g_BpBuffer;
extern ULONG g_BpTextOffset;

extern StateBuffer* g_BpCmdsBuffer;

extern StateBuffer* g_FilterTextBuffer;

extern StateBuffer* g_FilterBuffer;
extern ULONG g_FilterArgsOffset;
extern ULONG g_FilterCmdsOffset;
extern ULONG g_FilterWspCmdsOffset;
extern ULONG g_NumSpecEvents, g_NumSpecEx, g_NumArbEx;

extern StateBuffer* g_ModuleBuffer;
extern ULONG g_NumModules;

void FillCodeBuffer(ULONG64 Ip, BOOL UserActivated);
void FillEventBuffer(void);

void ReadStateBuffers(void);

#define BUFFERS_ALL 0xffffffff

void InvalidateStateBuffers(ULONG Types);

void UpdateBufferWindows(ULONG Types, UpdateType Type);

//----------------------------------------------------------------------------
//
// Static state buffers.
//
//----------------------------------------------------------------------------

extern StateBuffer* g_RegisterNamesBuffer;
extern StateBuffer* g_WatchWinBuffer;

extern PUSHORT g_RegisterMap;
extern ULONG g_RegisterMapEntries;

#define MAP_REGISTER(i) \
    (g_RegisterMap != NULL && (i) < g_RegisterMapEntries ? \
     g_RegisterMap[(i)] : (i))

void GetRegisterMapText(HWND Edit);
void ScanRegisterMapText(HWND Edit);

//----------------------------------------------------------------------------
//
// UI thread state buffer.
//
// The UI thread has simple needs and so one state buffer for
// output capture is sufficient.
//
//----------------------------------------------------------------------------

extern StateBuffer g_UiOutputCapture;

#endif // #ifndef __STATEBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\toolbar.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    Toolbar.h

Abstract:

    This module contains the support code for toolbar

--*/

#define TEXT_TB_BTN(Id, Text, Flags) \
    { I_IMAGENONE, Id, TBSTATE_ENABLED, \
      BTNS_AUTOSIZE | BTNS_SHOWTEXT | (Flags), \
      {0}, 0, (INT_PTR)(Text) }

#define SEP_TB_BTN() \
    { 8, 8, 0, BTNS_SEP, {0}, 0, 0 }

HWND GetHwnd_Toolbar();
PTSTR GetToolTipTextFor_Toolbar(UINT uToolbarId);
BOOL CreateToolbar(HWND hwndParent);

//Update toolbar
void Show_Toolbar(BOOL bShow);

void EnableToolbarControls();

void ToolbarIdEnabled(UINT, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\status.h ===
/*++ 

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    status.h

Environment:

    Win32, User Mode

---*/



// Used as indexes into the rgnItemWidth & rgszItemText
// arrays. These are in order from left to right.

typedef enum
{
    nMESSAGE_IDX_STATUSBAR,         // Generic txt message such as menu help,
                                    // or error messages, etc.
    nSRCLIN_IDX_STATUSBAR,          // Line num. & coloumn num. in src file
    nPROCID_IDX_STATUSBAR,          // Process ID
    nTHRDID_IDX_STATUSBAR,          // Thread ID
    nSRCASM_IDX_STATUSBAR,          // Src/Asm mode idicator      
    nOVRTYPE_IDX_STATUSBAR,         // Insert/Overtype indicator
    nCAPSLCK_IDX_STATUSBAR,         // Caps lock indicator
    nNUMLCK_IDX_STATUSBAR,          // Num lock indicator
    nMAX_IDX_STATUSBAR,             // Max num items in enum
} nIDX_STATUSBAR_ITEMS;

// Init/Term functions
BOOL CreateStatusBar(HWND hwndParent);
void TerminateStatusBar();

void Show_StatusBar(BOOL bShow);

void WM_SIZE_StatusBar(WPARAM wParam, LPARAM lParam); 

HWND GetHwnd_StatusBar();

// Some of the items are owner draw.
void OwnerDrawItem_StatusBar(LPDRAWITEMSTRUCT lpDrawItem);

//
// Status bar operations
//

void SetMessageText_StatusBar(UINT StringId);

void SetLineColumn_StatusBar(int newLine, int newColumn);

void SetPidTid_StatusBar(ULONG ProcessId, ULONG ProcessSysId,
                         ULONG ThreadId, ULONG ThreadSysId);

// TRUE - considered on, and the text is displayed in black
// FALSE - considered off, and the text is displayed in dark gray
//
BOOL GetNumLock_StatusBar();
BOOL SetNumLock_StatusBar(BOOL newValue);

BOOL GetCapsLock_StatusBar();
BOOL SetCapsLock_StatusBar(BOOL newValue);

BOOL GetSrcMode_StatusBar();
BOOL SetSrcMode_StatusBar(BOOL bSrcMode);

BOOL GetOverType_StatusBar();
BOOL SetOverType_StatusBar(BOOL bOverType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\util.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    util.h

--*/

/****************************************************************************

    PROTOTYPES DECLARATION FOR UTIL MODULE

****************************************************************************/

//Current Help Id for Open, Merge, Save and Open project dialog box
extern WORD g_CurHelpId;

// Number of dialog/message boxes currently open
extern int g_nBoxCount;

// Opens a standard error Dialog Box (Parent is hwnd)

BOOL ErrorBox(HWND hwnd, UINT type, int wErrorFormat, ...);
void InformationBox(WORD wDescript, ...);

// Opens a message box with the QCWin title
int MsgBox(HWND hwndParent, PTSTR szText, UINT wType);


// Loads and execute dialog box 'rcDlgNb' with 'dlgProc' function
int StartDialog(int rcDlgNb, DLGPROC dlgProc, LPARAM);


// Loads a resource string from resource file
void LoadResourceString(
    WORD wStrId,
    PTSTR lpszStrBuffer);

//Opens a standard question box containing combination
//of : Yes, No, Cancel
int CDECL QuestionBox(
    WORD wMsgFormat,
    UINT wType,
    ...);

//Opens a standard question box containing combination
//of : Yes, No, Cancel
int CDECL QuestionBox2(HWND hwnd, WORD wMsgFormat, UINT wType, ...);


// Drain the thread message queue.
void ProcessPendingMessages(void);


//Initialize files filters for dialog boxes using commonfile DLL
void InitFilterString(WORD id, PTSTR filter, int maxLen);


//Check if keyboard hit is NUMLOCK, CAPSLOCK or INSERT
LRESULT KeyboardHook( int iCode, WPARAM wParam, LPARAM lParam );




//Opens a Dialog box with a title and accepting a printf style for text
int InfoBox(
    PTSTR text,
    ...);



UINT_PTR
APIENTRY
DlgFile(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL StartFileDlg(HWND hwnd, int titleId, int defExtId,
                  int helpId, int templateId,
                  PTSTR InitialDir, PTSTR fileName,
                  DWORD *pFlags, LPOFNHOOKPROC lpfnHook);

void DECLSPEC_NORETURN ExitDebugger(PDEBUG_CLIENT Client, ULONG Code);
void DECLSPEC_NORETURN ErrorExit(PDEBUG_CLIENT Client, PCSTR Format, ...);

HWND 
MDIGetActive(
    HWND    hwndParent,
    BOOL   *lpbMaximized
    );

LPSTR
FormatAddr64(
    ULONG64 addr
    );

int matchExt (PTSTR pTargExt, PTSTR pSrcList);

void ActivateNewMDIChild(
    HWND hwndPrev,
    HWND hwndNew,
    BOOL bUserActivated);

void ActivateMDIChild(
    HWND hwndNew,
    BOOL bUserActivated);

void SetProgramArguments(
    PTSTR lpszTmp);

void
AppendTextToAnEditControl(
    HWND hwnd,
    PTSTR pszNewText);

VOID
CopyToClipboard(
    PSTR str);

void SetAllocString(PSTR* Str, PSTR New);
BOOL DupAllocString(PSTR* Str, PSTR New);
BOOL PrintAllocString(PSTR* Str, int Len, PCSTR Format, ...);

HMENU CreateContextMenuFromToolbarButtons(ULONG NumButtons,
                                          TBBUTTON* Buttons,
                                          ULONG IdBias);

HWND AddButtonBand(HWND Bar, PTSTR Text, PTSTR SizingText, UINT Id);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\toolbar.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    Toolbar.cpp

Abstract:

    This module contains the support code for toolbar

--*/


#include "precomp.hxx"
#pragma hdrstop

// Handle to main toolbar window
HWND g_Toolbar;

// See docs for TBBUTTON
TBBUTTON g_TbButtons[] =
{
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 0,    IDM_FILE_OPEN,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 2,    IDM_EDIT_CUT,               TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 3,    IDM_EDIT_COPY,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 4,    IDM_EDIT_PASTE,             TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 5,    IDM_DEBUG_GO,               TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 6,    IDM_DEBUG_RESTART,          TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 7,    IDM_DEBUG_STOPDEBUGGING,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 8,    IDM_DEBUG_BREAK,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 9,    IDM_DEBUG_STEPINTO,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 10,   IDM_DEBUG_STEPOVER,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 11,   IDM_DEBUG_STEPOUT,          TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 12,   IDM_DEBUG_RUNTOCURSOR,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 13,   IDM_EDIT_TOGGLEBREAKPOINT,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 15,   IDM_VIEW_COMMAND,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 16,   IDM_VIEW_WATCH,             TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 17,   IDM_VIEW_LOCALS,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 18,   IDM_VIEW_REGISTERS,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 19,   IDM_VIEW_MEMORY,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 20,   IDM_VIEW_CALLSTACK,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 21,   IDM_VIEW_DISASM,            TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 22,   IDM_VIEW_SCRATCH,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 23,   IDM_DEBUG_SOURCE_MODE_ON,   TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0},
    { 24,   IDM_DEBUG_SOURCE_MODE_OFF,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 25,   IDM_EDIT_PROPERTIES,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 26,   IDM_VIEW_FONT,              TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 27,   IDM_VIEW_OPTIONS,           TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
    { 0,    0,                          TBSTATE_ENABLED, TBSTYLE_SEP,    0},
    { 28,   IDM_WINDOW_ARRANGE,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0},
};

// Toolbar constants.
#define NUM_BMPS_IN_TOOLBAR  ( sizeof(g_TbButtons) / sizeof(g_TbButtons[0]) )

// Used to retrieve the tooltip text
typedef struct
{
    UINT    uCmdId;     // TBBUTTON command
    int     nStrId;     // String resource ID
} TB_STR_MAP;

// Map the command id to resource string identifier.
TB_STR_MAP g_TbStrMap[] =
{
    { IDM_FILE_OPEN,                TBR_FILE_OPEN },
    { IDM_EDIT_CUT,                 TBR_EDIT_CUT },
    { IDM_EDIT_COPY,                TBR_EDIT_COPY },
    { IDM_EDIT_PASTE,               TBR_EDIT_PASTE },
    { IDM_DEBUG_GO,                 TBR_DEBUG_GO },
    { IDM_DEBUG_RESTART,            TBR_DEBUG_RESTART },
    { IDM_DEBUG_STOPDEBUGGING,      TBR_DEBUG_STOPDEBUGGING },
    { IDM_DEBUG_BREAK,              TBR_DEBUG_BREAK },
    { IDM_DEBUG_STEPINTO,           TBR_DEBUG_STEPINTO },
    { IDM_DEBUG_STEPOVER,           TBR_DEBUG_STEPOVER },
    { IDM_DEBUG_STEPOUT,            TBR_DEBUG_STEPOUT },
    { IDM_DEBUG_RUNTOCURSOR,        TBR_DEBUG_RUNTOCURSOR },
    { IDM_EDIT_TOGGLEBREAKPOINT,    TBR_EDIT_BREAKPOINTS },
    { IDM_VIEW_COMMAND,             TBR_VIEW_COMMAND },
    { IDM_VIEW_WATCH,               TBR_VIEW_WATCH },
    { IDM_VIEW_LOCALS,              TBR_VIEW_LOCALS },
    { IDM_VIEW_REGISTERS,           TBR_VIEW_REGISTERS },
    { IDM_VIEW_MEMORY,              TBR_VIEW_MEMORY },
    { IDM_VIEW_CALLSTACK,           TBR_VIEW_CALLSTACK },
    { IDM_VIEW_DISASM,              TBR_VIEW_DISASM },
    { IDM_VIEW_SCRATCH,             TBR_VIEW_SCRATCH },
    { IDM_DEBUG_SOURCE_MODE_ON,     TBR_DEBUG_SOURCE_MODE_ON },
    { IDM_DEBUG_SOURCE_MODE_OFF,    TBR_DEBUG_SOURCE_MODE_OFF },
    { IDM_EDIT_PROPERTIES,          TBR_EDIT_PROPERTIES },
    { IDM_VIEW_FONT,                TBR_VIEW_FONT },
    { IDM_VIEW_OPTIONS,             TBR_VIEW_OPTIONS },
    { IDM_WINDOW_ARRANGE,           TBR_WINDOW_ARRANGE },
};

#define NUM_TOOLBAR_BUTTONS (sizeof(g_TbButtons) / sizeof(TBBUTTON))
#define NUM_TOOLBAR_STRINGS (sizeof(g_TbStrMap) / sizeof(TB_STR_MAP))


PTSTR
GetToolTipTextFor_Toolbar(UINT uToolbarId)
/*++
Routine Description:
    Given the id of the toolbar button, we retrieve the
    corresponding tooltip text from the resources.

Arguments:
    uToolbarId - The command id for the toolbar button. This is the
        value contained in the WM_COMMAND msg.

Returns:
    Returns a pointer to a static buffer that contains the tooltip text.
--*/
{
    // Display tool tip text.
    static TCHAR sz[MAX_MSG_TXT];
    int nStrId = 0, i;
    
    // Get the str id given the cmd id
    for (i = 0; i < NUM_TOOLBAR_STRINGS; i++)
    {
        if (g_TbStrMap[i].uCmdId == uToolbarId)
        {
            nStrId = g_TbStrMap[i].nStrId;
            break;
        }
    }
    Assert(nStrId);
    
    // Now that we have the string id ....
    Dbg(LoadString(g_hInst, nStrId, sz, _tsizeof(sz) ));

    return sz;
}


BOOL
CreateToolbar(HWND hwndParent)
/*++
Routine Description:
    Creates the toolbar.

Arguments:
    hwndParent - The parent window of the toolbar.
--*/
{
    g_Toolbar = CreateToolbarEx(hwndParent,                 // parent
                                WS_CHILD | WS_BORDER 
                                | WS_VISIBLE 
                                | TBSTYLE_TOOLTIPS 
                                | TBSTYLE_WRAPABLE
                                | CCS_TOP,                  // style
                                ID_TOOLBAR,                 // toolbar id
                                NUM_BMPS_IN_TOOLBAR,        // number of bitmaps
                                g_hInst,                    // mod instance
                                IDB_BMP_TOOLBAR,            // resource id for the bitmap
                                g_TbButtons,                // address of buttons
                                NUM_TOOLBAR_BUTTONS,        // number of buttons
                                16,15,                      // width & height of the buttons
                                16,15,                      // width & height of the bitmaps
                                sizeof(TBBUTTON)            // structure size
                                );
    return g_Toolbar != NULL;
}


void
Show_Toolbar(BOOL bShow)
/*++
Routine Description:
    Shows/hides the toolbar.

Arguments:
    bShow - TRUE - Show the toolbar.
            FALSE - Hide the toolbar.

            Autmatically resizes the MDI Client
--*/
{
    RECT rect;
    
    // Show/Hide the toolbar
    ShowWindow(g_Toolbar, bShow ? SW_SHOW : SW_HIDE);
    
    //Ask the frame to resize, so that everything will be correctly positioned.
    GetWindowRect(g_hwndFrame, &rect);
    
    EnableToolbarControls();
    
    SendMessage(g_hwndFrame, 
                WM_SIZE, 
                SIZE_RESTORED,
                MAKELPARAM(rect.right - rect.left, rect.bottom - rect.top)
                );
    
    // Ask the MDIClient to redraw itself and its children.
    // This is  done in order to fix a redraw problem where some of the
    // MDIChild window are not correctly redrawn.
    RedrawWindow(g_hwndMDIClient, 
                 NULL, 
                 NULL, 
                 RDW_UPDATENOW | RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_FRAME
                 );
}                                       /* UpdateToolbar() */


HWND
GetHwnd_Toolbar()
{
    return g_Toolbar;
}




/***    EnableToolbarControls
**
**  Description:
**      Enables/disables the controls in the toolbar according
**      to the current state of the system.
**
*/

void
EnableToolbarControls()
{
    int i;

    for (i = 0; i < NUM_TOOLBAR_BUTTONS; i++)
    {
        // This will enable disable the toolbar
        if (g_TbButtons[i].idCommand)
        {
            CommandIdEnabled(g_TbButtons[i].idCommand);
        }
    }
}


void
ToolbarIdEnabled(
    IN UINT uMenuID,
    IN BOOL fEnabled
    )
/*++

Routine Description:

    Enables/disables a ToolBar item based.

Arguments:

    uMenuID - Supplies a menu id whose state is to be determined.
    
    fEnabled - enable or disable a toolbar item.

Return Value:

    None

--*/
{
    switch (uMenuID)
    {
    case IDM_FILE_OPEN:
    case IDM_EDIT_CUT:
    case IDM_EDIT_COPY:
    case IDM_EDIT_PASTE:
    case IDM_DEBUG_GO:
    case IDM_DEBUG_RESTART:
    case IDM_DEBUG_STOPDEBUGGING:
    case IDM_DEBUG_BREAK:
    case IDM_DEBUG_STEPINTO:
    case IDM_DEBUG_STEPOVER:
    case IDM_DEBUG_STEPOUT:
    case IDM_DEBUG_RUNTOCURSOR:
    case IDM_EDIT_TOGGLEBREAKPOINT:
    case IDM_VIEW_COMMAND:
    case IDM_VIEW_WATCH:
    case IDM_VIEW_LOCALS:
    case IDM_VIEW_REGISTERS:
    case IDM_VIEW_MEMORY:
    case IDM_VIEW_CALLSTACK:
    case IDM_VIEW_DISASM:
    case IDM_EDIT_PROPERTIES:
        // Nothing special to do here, except change the state
        SendMessage(GetHwnd_Toolbar(), 
                    TB_ENABLEBUTTON, 
                    uMenuID, 
                    MAKELONG(fEnabled, 0));
        break;

    case IDM_DEBUG_SOURCE_MODE_ON:
    case IDM_DEBUG_SOURCE_MODE_OFF:
        // Toggle the state between the two items
        SendMessage(GetHwnd_Toolbar(), 
                    TB_CHECKBUTTON,
                    IDM_DEBUG_SOURCE_MODE_ON, 
                    MAKELONG(GetSrcMode_StatusBar(), 0));
        SendMessage(GetHwnd_Toolbar(), 
                    TB_CHECKBUTTON,
                    IDM_DEBUG_SOURCE_MODE_OFF, 
                    MAKELONG(!GetSrcMode_StatusBar(), 0));
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\util.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    util.cpp

--*/


#include "precomp.hxx"
#pragma hdrstop

//Current Help Id for Open, Merge, Save and Open project dialog box
WORD g_CurHelpId;

// Number of dialog/message boxes currently open
int  g_nBoxCount;

BOOL g_fNoPopups;


HWND 
MDIGetActive(
    HWND    hwndParent,
    BOOL   *lpbMaximized
    )
/*++
Routine Description:

  Create the command window.

Arguments:

    hwndParent - The parent window to the command window. In an MDI document,
        this is usually the handle to the MDI client window: g_hwndMDIClient

Return Value:

    The return value is the handle to the active MDI child window.

    NULL if no MDI window has been created.

--*/
{
    Assert(IsWindow(hwndParent));
    return (HWND)SendMessage(hwndParent, 
                             WM_MDIGETACTIVE, 
                             0, 
                             (LPARAM)lpbMaximized
                             );
}


/***    hGetBoxParent
**
**  Synopsis:
**      hwnd = hGetBoxParent()
**
**  Entry:
**      none
**
**  Returns:
**
**  Description:
**      Gets a suitable parent window handle for an
**      invocation of a message or dialog box.
**      Helper function to util.c functions so declared
**      near.
**
*/

HWND
hGetBoxParent()
{
    HWND hCurWnd;
    int i = 0;

    hCurWnd = GetFocus();
    if (hCurWnd)
    {
        while (GetWindowLong(hCurWnd, GWL_STYLE) & WS_CHILD)
        {
            hCurWnd = GetParent(hCurWnd);
            Dbg((++i < 100));
        }
    }
    else
    {
        hCurWnd = g_hwndFrame;
    }

    return hCurWnd;
}

/****************************************************************************

        FUNCTION:   MsgBox

        PURPOSE:    General purpose message box routine which takes
                    a pointer to the message text.  Provides
                    program title as caption.

****************************************************************************/

int
MsgBox(
    HWND hwndParent,
    PTSTR szText,
    UINT wType
    )
/*++

Routine Description:

    Generial purpose message box routine which takes a pointer to a message
    text and prvoides the program title for the caption of the message box.

Arguments:

    hwndParament - Supplies the parent window handle for the message box
    szText      - Supplies a pointer to the message box text.
    wType       - Supplies the message box type (to specify buttons)

Return Value:

    Returns the message box return code

--*/

{
    int MsgBoxRet = IDOK;

    if (g_fNoPopups)
    {
        //
        // log the string to the command win in case testing
        // or when the remote server is running
        //
        CmdLogFmt (_T("%s\r\n"), szText);
    }
    else
    {
        g_nBoxCount++;
        MsgBoxRet = MessageBox(hwndParent, szText,
                               g_MainTitleText, wType);
        g_nBoxCount--;
    }

    return MsgBoxRet;
}                               /* MsgBox() */

/***    ErrorBox
**
**  Returns:
**      FALSE
**
**  Description:
**      Display an error message box with an "Error" title, an OK
**      button and a Exclamation Icon. First parameter is a
**      reference string in the ressource file.  The string
**      can contain printf formatting chars, the arguments
**      follow from the second parameter onwards.
**
*/

BOOL
ErrorBox(
    HWND hwnd,
    UINT type,
    int wErrorFormat,
    ...
    )
{
    TCHAR szErrorFormat[MAX_MSG_TXT];
    TCHAR szErrorText[MAX_VAR_MSG_TXT];  // size is as big as considered necessary
    va_list vargs;

    // load format string from resource file
    Dbg(LoadString(g_hInst, wErrorFormat, (PTSTR)szErrorFormat, MAX_MSG_TXT));

    va_start(vargs, wErrorFormat);
    _vstprintf(szErrorText, szErrorFormat, vargs);
    va_end(vargs);

    if (hwnd == NULL)
    {
        hwnd = g_hwndFrame;
    }

    if (type == 0)
    {
        type = MB_TASKMODAL;
    }

    MsgBox(g_hwndFrame, (PTSTR)szErrorText, type | MB_OK | MB_ICONINFORMATION);
    return FALSE;   //Keep it always FALSE please
}


/***    InformationBox
**
**  Description:
**      Display an information message box with an "Information"
**      title, an OK button and an Information Icon.
**
*/

void
InformationBox(
    WORD wDescript
    ...
    )
{
    TCHAR szFormat[MAX_MSG_TXT];
    TCHAR szText[MAX_VAR_MSG_TXT];       // size is as big as considered necessary
    va_list vargs;

    // load format string from resource file
    Dbg(LoadString(g_hInst, wDescript, (PTSTR)szFormat, MAX_MSG_TXT));

    // set up szText from passed parameters
    va_start(vargs, wDescript);
    _vstprintf(szText, szFormat, vargs);
    va_end(vargs);

    MsgBox(g_hwndFrame, (PTSTR)szText, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);

    return;
}

/***    QuestionBox
**
**  Synopsis:
**      int = QuestionBox(wCaptionId, wMsgFormat, wType, ...)
**
**  Entry:
**
**  Returns:
**      The result of the message box call
**
**  Description:
**      Display an query box with combination of YES, NO and
**      CANCEL buttons and a question mark Icon.
**      See ErrorBox for discussion.
**
*/

int
CDECL
QuestionBox(
    WORD wMsgFormat,
    UINT wType,
    ...
    )
{
    TCHAR szMsgFormat[MAX_MSG_TXT];
    TCHAR szMsgText[MAX_VAR_MSG_TXT];
    va_list vargs;

    //Load format string from resource file
    Dbg(LoadString(g_hInst, wMsgFormat, (PTSTR)szMsgFormat, MAX_MSG_TXT));

    //Set up szMsgText from passed parameters
    va_start(vargs, wType);
    _vstprintf(szMsgText, szMsgFormat, vargs);
    va_end(vargs);

    return MsgBox(g_hwndFrame, szMsgText,
        wType | MB_ICONEXCLAMATION | MB_TASKMODAL);
}                                       /* QuestionBox() */

/****************************************************************************

        FUNCTION:   QuestionBox2

        PURPOSE:    Display an query box with combination of YES, NO and
                                        CANCEL buttons and a question mark Icon. The type and
                                        the parent window are adjustable.

        RETURNS:                MessageBox result

****************************************************************************/
int
CDECL
QuestionBox2(
    HWND hwnd,
    WORD wMsgFormat,
    UINT wType,
    ...
    )
{
    TCHAR szMsgFormat[MAX_MSG_TXT];
    TCHAR szMsgText[MAX_VAR_MSG_TXT];
    va_list vargs;

    //Load format string from resource file
    Dbg(LoadString(g_hInst, wMsgFormat, (PTSTR)szMsgFormat, MAX_MSG_TXT));

    //Set up szMsgText from passed parameters
    va_start(vargs, wType);
    _vstprintf(szMsgText, szMsgFormat, vargs);
    va_end(vargs);

    return MsgBox(hwnd, szMsgText, wType | MB_ICONEXCLAMATION);
}                                       /* QuestionBox2() */


/***    ShowAssert
**
**  Synopsis:
**      void = ShowAssert(szCond, iLine, szFile)
**
**  Entry:
**      szCond  - tokenized form of the failed condition
**      iLine   - Line number for the assertion
**      szFile  - File for the assertion
**
**  Returns:
**      void
**
**  Description:
**      Prepare and display a Message Box with szCondition, iLine and
**      szFile as fields.
**
*/
void
ShowAssert(
    PTSTR condition,
    UINT line,
    PTSTR file
    )
{
    TCHAR text[MAX_VAR_MSG_TXT];

    //Build line, show assertion and exit program

    _stprintf(text, _T("- Line:%u, File:%Fs, Condition:%Fs"),
        (WPARAM) line, file, condition);

    TCHAR szBuffer[_MAX_PATH];
    PTSTR pszBuffer;
    PTSTR szAssertFile = _T("assert.wbg");
    HANDLE hFile = NULL;

    hFile = CreateFile(szAssertFile, 
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       CREATE_ALWAYS, 
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL
                       );
    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Write the text out to the file
        DWORD dwBytesWritten = 0;
        
        Assert(WriteFile(hFile, text, _tcslen(text), &dwBytesWritten, NULL));
        Assert(_tcslen(text) == dwBytesWritten);
        CloseHandle(hFile);
    }

    int Action =
        MessageBox(GetDesktopWindow(), text, "Assertion Failure",
                   MB_ABORTRETRYIGNORE);
    if (Action == IDABORT)
    {
        exit(3);
    }
    else if (Action == IDRETRY)
    {
        DebugBreak();
    }
}                                       // ShowAssert()


/***    StartDialog
**
**  Synopsis:
**      int = StartDialog(rcDlgNb, dlgProc, lParam)
**
**  Entry:
**      rcDlgNb - Resource number of dialog to be openned
**      dlgProc - Filter procedure for the dialog
**      lParam  - Data passed into the dlg proc via LPARAM
**
**  Returns:
**      Result of the dialog box call
**
**  Description:
**      Loads and execute the dialog box 'rcDlgNb' (resource
**      file string number) associated with the dialog
**      function 'dlgProc'
**
*/

int
StartDialog(
    int rcDlgNb,
    DLGPROC dlgProc,
    LPARAM lParam
    )
{
    LRESULT result;

    //
    //Execute Dialog Box
    //

    g_nBoxCount++;
    result = DialogBoxParam(g_hInst,
                            MAKEINTRESOURCE(rcDlgNb),
                            hGetBoxParent(),
                            dlgProc,
                            lParam
                            );
    Assert(result != (LRESULT)-1);
    g_nBoxCount--;

    return (int)result;
}


void
ProcessNonDlgMessage(LPMSG Msg)
{
#if 0
    {
        DebugPrint("NonDlg msg %X for %p, args %X %X\n",
                   Msg->message, Msg->hwnd, Msg->wParam, Msg->lParam);
    }
#endif
    
    // If a keyboard message is for the MDI , let the MDI client
    // take care of it.  Otherwise, check to see if it's a normal
    // accelerator key (like F3 = find next).  Otherwise, just handle
    // the message as usual.
    if (!TranslateMDISysAccel(g_hwndMDIClient, Msg) &&
        !TranslateAccelerator(g_hwndFrame, g_hMainAccTable, Msg))
    {
        //
        // If this is a right-button-down over a child window,
        // automatically activate the window's contex menu.
        //
        if (Msg->message == WM_RBUTTONDOWN &&
            IsChild(g_hwndMDIClient, Msg->hwnd))
        {
            HMENU Menu;
            PCOMMONWIN_DATA CmnWin;
            POINT ScreenPt;
            
            POINT Pt = {LOWORD(Msg->lParam), HIWORD(Msg->lParam)};
            ClientToScreen(Msg->hwnd, &Pt);
            ScreenPt = Pt;
            ScreenToClient(g_hwndMDIClient, &Pt);
            
            HWND Win = ChildWindowFromPointEx(g_hwndMDIClient, Pt,
                                              CWP_SKIPINVISIBLE);
            if (Win != NULL &&
                (CmnWin = GetCommonWinData(Win)) != NULL &&
                (Menu = CmnWin->GetContextMenu()) != NULL)
            {
                UINT Item = TrackPopupMenu(Menu, TPM_LEFTALIGN | TPM_TOPALIGN |
                                           TPM_NONOTIFY | TPM_RETURNCMD |
                                           TPM_RIGHTBUTTON,
                                           ScreenPt.x, ScreenPt.y,
                                           0, Msg->hwnd, NULL);
                if (Item)
                {
                    CmnWin->OnContextMenuSelection(Item);
                }
                return;
            }
        }
        
        TranslateMessage(Msg);
        DispatchMessage(Msg);
    }
}

void
ProcessPendingMessages(void)
{
    MSG Msg;
    
    // Process all available messages.
    while (PeekMessage(&Msg, NULL, 0, 0, PM_NOREMOVE))
    {
        if (!GetMessage(&Msg, NULL, 0, 0))
        {
            g_Exit = TRUE;
            break;
        }

        if (g_FindDialog == NULL ||
            !IsDialogMessage(g_FindDialog, &Msg))
        {
            ProcessNonDlgMessage(&Msg);
        }
    }
}


/****************************************************************************

    FUNCTION:   InfoBox

    PURPOSE:    Opens a Dialog box with a title and accepting
                a printf style for text. It's for DEBUGGING USE ONLY

****************************************************************************/
int
InfoBox(
        PTSTR text,
        ...
        )
{
    TCHAR buffer[MAX_MSG_TXT];
    va_list vargs;

    va_start(vargs, text);
    _vstprintf(buffer, text, vargs);
    va_end(vargs);
    return MsgBox(GetActiveWindow(), buffer, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL);
}


void
ExitDebugger(PDEBUG_CLIENT Client, ULONG Code)
{
    if (Client != NULL && !g_RemoteClient)
    {
        Client->EndSession(DEBUG_END_PASSIVE);
        // Force servers to get cleaned up.
        Client->EndSession(DEBUG_END_REENTRANT);
    }

    ExitProcess(Code);
}

// XXX drewb - Is this functionality present in other utilities?
// FatalErrorBox is close.  Probably can combine something here.
void
ErrorExit(PDEBUG_CLIENT Client, PCSTR Format, ...)
{
    char Message[1024];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Message, sizeof(Message), Format, Args);
    va_end(Args);

    // XXX drewb - Could put up message box.
    OutputDebugString(Message);

    ExitDebugger(Client, E_FAIL);
}

#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr
    )
/*++

Routine Description:

    Format a 64 bit address, showing the high bits or not
    according to various flags.

    An array of static string buffers is used, returning a different
    buffer for each successive call so that it may be used multiple
    times in the same printf.

Arguments:

    addr - Supplies the value to format

Return Value:

    A pointer to the string buffer containing the formatted number

--*/
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if (g_Ptr64) {
        sprintf(string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    } else {
        sprintf(string, "%08x", (ULONG)addr);
    }
    return string;
}


static BOOL     FAddToSearchPath = FALSE;
static BOOL     FAddToRootMap = FALSE;

/*
**  AppendFilter
**
**  Description:
**      Append a filter to an existing filters string.
**
*/

BOOL
AppendFilter(
    WORD filterTextId,
    int filterExtId,
    PTSTR filterString,
    int *len,
    int maxLen
    )
{
    int size;
    TCHAR Tmp[MAX_MSG_TXT];

    //
    // Append filter text
    //

    Dbg(LoadString(g_hInst, filterTextId, Tmp, MAX_MSG_TXT));
    size = _tcslen(Tmp) + 1;
    if (*len + size > maxLen)
    {
        return FALSE;
    }
    memmove(filterString + *len, Tmp, size);
    *len += size;

    //
    // Append filter extension
    //

    Dbg(LoadString(g_hInst, filterExtId, Tmp, MAX_MSG_TXT));
    size = _tcslen(Tmp) + 1;
    if (*len + size > maxLen)
    {
        return FALSE;
    }
    memmove(filterString + *len, Tmp, size);
    *len += size;

    return TRUE;
}

/*
**  InitFilterString
**
**  Description:
**      Initialize file filters for file dialog boxes.
*/

void
InitFilterString(
    WORD titleId,
    PTSTR filter,
    int maxLen
    )
{
    int len = 0;

    switch (titleId) {
    case DLG_Browse_CrashDump_Title:
        AppendFilter(TYP_File_DUMP, DEF_Ext_DUMP, filter, &len, maxLen);
        break;

    case DLG_Browse_Executable_Title:
        AppendFilter(TYP_File_EXE, DEF_Ext_EXE, filter, &len, maxLen);
        break;

    case DLG_Browse_LogFile_Title:
        AppendFilter(TYP_File_LOG, DEF_Ext_LOG, filter, &len, maxLen);
        break;

    case DLG_Open_Filebox_Title:
    case DLG_Browse_Filebox_Title:
        AppendFilter(TYP_File_SOURCE, DEF_Ext_SOURCE, filter, &len, maxLen);
        AppendFilter(TYP_File_INCLUDE, DEF_Ext_INCLUDE, filter, &len, maxLen);
        AppendFilter(TYP_File_ASMSRC, DEF_Ext_ASMSRC, filter, &len, maxLen);
        AppendFilter(TYP_File_INC, DEF_Ext_INC, filter, &len, maxLen);
        AppendFilter(TYP_File_RC, DEF_Ext_RC, filter, &len, maxLen);
        AppendFilter(TYP_File_DLG, DEF_Ext_DLG, filter, &len, maxLen);
        AppendFilter(TYP_File_DEF, DEF_Ext_DEF, filter, &len, maxLen);
        AppendFilter(TYP_File_MAK, DEF_Ext_MAK, filter, &len, maxLen);
        break ;

    case DLG_Browse_DbugDll_Title:
        AppendFilter(TYP_File_DLL, DEF_Ext_DLL, filter, &len, maxLen);
        break;

    default:
        Assert(FALSE);
        break;
    }

    AppendFilter(TYP_File_ALL, DEF_Ext_ALL, filter, &len, maxLen);
    filter[len] = _T('\0');
}

BOOL
StartFileDlg(
    HWND hwnd,
    int titleId,
    int defExtId,
    int helpId,
    int templateId,
    PTSTR InitialDir,
    PTSTR fileName,
    DWORD* pFlags,
    LPOFNHOOKPROC lpfnHook
    )

/*++

Routine Description:

    This function is used by windbg to open the set of common file handling
    dialog boxes.

Arguments:

    hwnd        - Supplies the wnd to hook the dialog box to

    titleId     - Supplies the string resource of the title

    defExtId    - Supplies The default extension resource string

    helpId      - Supplies the help number for the dialog box

    templateId  - Supplies the dialog resource number if non-zero

    fileName    - Supplies the default file name

    pFiles      - Supplies a pointer to flags

    lpfnHook    - Supplies the address of a hook procedure for the dialog

Return Value:

    The result of the dialog box call (usually TRUE for OK and FALSE for
    cancel)

--*/

{
#define filtersMaxSize 350

    OPENFILENAME_NT4    OpenFileName = {0};
    TCHAR               title[MAX_MSG_TXT];
    TCHAR               defExt[MAX_MSG_TXT];
    BOOL                result;
    TCHAR               filters[filtersMaxSize];
    LPOFNHOOKPROC       lpDlgHook = NULL;
    HCURSOR             hSaveCursor;
    TCHAR               files[_MAX_PATH + 8];
    TCHAR               szExt[_MAX_EXT + 8];
    TCHAR               szBase[_MAX_PATH + 8];
    int                 indx;
    TCHAR               ch;
    TCHAR               fname[_MAX_FNAME];
    TCHAR               ext[_MAX_EXT];
    PTSTR               LocalInitialDir = NULL;

    *pFlags |= (OFN_EXPLORER | OFN_NOCHANGEDIR);

    if (InitialDir == NULL || !InitialDir[0])
    {
        DWORD retval = GetCurrentDirectory(NULL, NULL);
        InitialDir = (PTSTR)calloc(retval, sizeof(TCHAR) );
        if (InitialDir == NULL)
        {
            return FALSE;
        }
        
        GetCurrentDirectory(retval, InitialDir);
        LocalInitialDir = InitialDir;
    }

    if (DLG_Browse_Filebox_Title == titleId)
    {
        _tsplitpath( fileName, NULL, NULL, fname, ext );
        _tmakepath( files, NULL, NULL, fname, ext );
    }
    else
    {
        _tcscpy(files, fileName);
    }

    //
    // Set the Hour glass cursor
    //

    hSaveCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    InitFilterString((WORD)titleId, (PTSTR)filters, (int)filtersMaxSize);
    Dbg(LoadString(g_hInst, titleId, (PTSTR)title, MAX_MSG_TXT));
    Dbg(LoadString(g_hInst, defExtId, (PTSTR)defExt, MAX_MSG_TXT));
    if (templateId)
    {
        //
        // Build dialog box Name
        //

        *pFlags |= OFN_ENABLETEMPLATE;
        OpenFileName.lpTemplateName = MAKEINTRESOURCE(templateId);
    }
    else
    {
        *pFlags |= OFN_EXPLORER;
    }

    //
    // Make instance for _T('dlgProc')
    //

    if (lpfnHook)
    {
        lpDlgHook = lpfnHook;

        *pFlags |= OFN_ENABLEHOOK;
    }

    g_CurHelpId = (WORD) helpId;
    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = hwnd;
    OpenFileName.hInstance = g_hInst;
    OpenFileName.lpstrFilter = (PTSTR)filters;
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter = 0;
    OpenFileName.nFilterIndex = 1;
    OpenFileName.lpstrFile = files;
    OpenFileName.nMaxFile = _MAX_PATH;
    OpenFileName.lpstrFileTitle = NULL;
    OpenFileName.lpstrInitialDir = InitialDir;
    OpenFileName.lpstrTitle = (PTSTR)title;
    OpenFileName.Flags = *pFlags;
    OpenFileName.lpstrDefExt = (PTSTR)NULL;
    OpenFileName.lCustData = 0L;
    OpenFileName.lpfnHook = lpDlgHook;

    g_nBoxCount++;

    switch (titleId)
    {
    case DLG_Open_Filebox_Title:
        _tcscat(OpenFileName.lpstrFile, defExt);
        // fall thru
    case DLG_Browse_Executable_Title:
    case DLG_Browse_CrashDump_Title:
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName) ;
        break ;

    case DLG_Browse_LogFile_Title:
        if (fileName)
        {
            _tcscpy(OpenFileName.lpstrFile, fileName);
        }
        else
        {
            *OpenFileName.lpstrFile = 0;
        }
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName) ;
        break;

    case DLG_Browse_DbugDll_Title:
        *(OpenFileName.lpstrFile) = _T('\0');
        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName) ;
        break ;

    case DLG_Browse_Filebox_Title:
        _tsplitpath (files, (PTSTR)NULL, (PTSTR)NULL, (PTSTR)szBase, szExt);
        indx = matchExt (szExt, filters);

        if (indx != -1)
        {
            OpenFileName.nFilterIndex = indx;
        }

        _tcscat(title, szBase);
        if (*szExt)
        {
            _tcscat(title, szExt);
        }

        FAddToSearchPath = FALSE;
        FAddToRootMap = FALSE;

        result = GetOpenFileName((LPOPENFILENAME)&OpenFileName) ;

        //
        // Check to see if the use said to add a file to the browse path.
        //     If so then add it to the front of the path
        //

        /*if (FAddToSearchPath)
        {
            AddToSearchPath(OpenFileName.lpstrFile);
        }
        else if (FAddToRootMap)
        {
            RootSetMapped(fileName, OpenFileName.lpstrFile);
        }*/
        break;

    default:
        Assert(FALSE);
        free(LocalInitialDir);
        return FALSE;
    }


    g_nBoxCount--;

    if (result)
    {
        _tcscpy(fileName, OpenFileName.lpstrFile);
        if (titleId == DLG_Open_Filebox_Title)
        {
            AddFileToMru(FILE_USE_SOURCE, fileName);
        }

        //
        // Get the output of flags
        //

        *pFlags = OpenFileName.Flags ;
    }

    //
    //Restore cursor
    //

    SetCursor(hSaveCursor);

    free(LocalInitialDir);
    return result;
}                                       /* StartFileDlg() */

/***    matchExt
**
**  Synopsis:
**      int = matchExt (queryExtension, sourceList)
**
**  Entry:
**
**  Returns: 1-based index of pairwise substring for which the second
**           element (i.e., the extension list), contains the target
**           extension.  If there is no match, we return -1.
**
**  Description:
**      Searches extension lists for the Open/Save/Browse common
**      dialogs to try to match a filter to the input filename's
**      extension.
**      (Open File, Save File, Merge File and Open Project)
**
**  Implementation note:  Our thinking looks like this:
**
**     We are given a sequence of null-terminated strings which
**     are text/extension pairs.  We return the pairwise 1-based
**     index of the first pair for which the second element has an
**     exact match for the target extension.  (Everything, by the
**     way, is compared without case sensitivity.)  We picture the
**     source sequence, then, to be an array whose elements are pairs
**     of strings (we will call the pairs 'left' and 'right').
**
**     Just to complicate things, we allow the '.right' pair elements to
**     be strings like "*.c;*.cpp;*.cxx", where we our query might be
**     any one of the three (minus the leading asterisk).  Fortunately,
**     _tcstok() will break things apart for us (see the 'delims[]' array
**     in the code for the delimiters we have chosen).
**
**     Assuming there is a match in there somewhere, our invariant
**     for locating the first one will be:
**
**     Exists(k):
**                   ForAll(i) : 0 <= i < k
**                             : queryExtension \not IS_IN source[i].right
**               \and
**                   queryExtension IS_IN source[k].right
**
**     where we define IS_IN to be a membership predicate (using _tcstok()
**     and _tcsicmp() in the implementation, eh?):
**
**        x IS_IN y
**     <=>
**        Exists (t:token) : (t \in y) \and (x == t).
**
**     The guard for our main loop, then, comes from the search for the
**     queryExtension within the tokens inside successive '.right' elements.
**     We choose to continue as long as there is no current token in the
**     pair's right side that contains the query.
**
**     (We have the pragmatic concern that the value may not be there, so we
**     augment the loop guard with the condition that we have not yet
**     exhausted the source.  This is straightforward to add to the
**     invariant, but it causes a lot of clutter that does help our
**     comprehension at all, so we just stick it in the guard without
**     formal justification.)
*/

int 
matchExt(
    PTSTR queryExtension, 
    PTSTR sourceList
    )
{
    int   answer;
    int   idxPair    = 1;        // a 1-based index!
    PTSTR tokenMatch = 0;

    TCHAR  delims[]   = _T("*,; ") ;  // Given a typical string: "*.c;*.cpp;*.cxx",
    // _tcstok() would produce three tokens:
    // ".c", ".cpp", and ".cxx".

    while (*sourceList != 0  &&  tokenMatch == 0)
    {
        while (*sourceList != _T('\0'))
        { sourceList++; }          // skip first string of pair
        sourceList++;                 // and increment beyond NULL

        if (*sourceList != _T('\0'))
        {
            PTSTR work = _tcsdup (sourceList);  // copy to poke holes in

            tokenMatch = _tcstok (work, delims);

            while (tokenMatch  &&  _tcsicmp (tokenMatch, queryExtension))
            {
                tokenMatch = _tcstok (0, delims);
            }

            free (work);
        }

        if (tokenMatch == 0)             // no match:  need to move to next pair
        {
            while (*sourceList != _T('\0'))
            { sourceList++; }          // skip second string of pair
            sourceList++;                 // and increment beyond NULL

            idxPair++;
        }
    }

    answer = (tokenMatch != 0) ? idxPair : (-1);

    return (answer);
}





/***    DlgFile
**
**  Synopsis:
**      bool = DlgFile(hDlg, message, wParam, lParam)
**
**  Entry:
**
**  Returns:
**
**  Description:
**      Processes messages for file dialog boxes
**      Those dialogs are not called directly but are called
**      by the DlgFile function which contains all basic
**      elements for Dialogs Files Operations Handling.
**      (Open File, Save File, Merge File and Open Project)
**
**      See OFNHookProc
*/

UINT_PTR
APIENTRY
DlgFile(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

{
    switch (uMsg)
    {
    case WM_NOTIFY:
        {
            LPOFNOTIFY lpon = (LPOFNOTIFY) lParam;

            //
            // Determine what happened/why we are being notified
            //
            switch (lpon->hdr.code)
            {
            case CDN_HELP:
                // Help button pushed
                Dbg(HtmlHelp(hDlg,g_HelpFileName, HH_HELP_CONTEXT,
                             g_CurHelpId));
                break;
            }
        }
        break;
    }
    return FALSE;
}                                       /* DlgFile() */


UINT_PTR
APIENTRY
GetOpenFileNameHookProc(
                        HWND    hDlg,
                        UINT    msg,
                        WPARAM  wParam,
                        LPARAM  lParam
                        )

/*++

Routine Description:

    This routine is handle the Add Directory To radio buttons in the
    browser source file dialog box.

Arguments:

    hDlg        - Supplies the handle to current dialog
    msg         - Supplies the message to be processed
    wParam      - Supplies info about the message
    lParam      - Supplies info about the message

Return Value:

    TRUE if we replaced default processing of the message, FALSE otherwise

--*/
{
    /*

    switch( msg ) {
    case  WM_INITDIALOG:
        return TRUE;

    case WM_NOTIFY:
        {
            LPOFNOTIFY lpon = (LPOFNOTIFY) lParam;

            switch(lpon->hdr.code) {
            case CDN_FILEOK:
                FAddToSearchPath = (IsDlgButtonChecked( hDlg, IDC_CHECK_ADD_SRC_ROOT_MAPPING) == BST_CHECKED);
                return 0;
            }
        }
    }
    return DlgFile(hDlg, msg, wParam, lParam);
    */
    return 0;
}                               /* GetOpenFileNameHookProc() */


void
Internal_Activate(
    HWND hwndCur,
    HWND hwndNew,
    int nPosition
    )
/*++

Routine Description:

    Places a window in the specified Z order position.

Arguments:

    hwndCur - Currently active window, topmost in Z order. Can be NULL.

    hwndNew - The window to be placed in the new Z order.

    nPosition - Where the window is to be place in the Z order.
        1 - topmost
        2 - 2nd place (behind topmost)
        3 - 3rd place, etc....

Return Value: 

    None

--*/
{
    // Sanity check. Make sure the programmer
    // specified a 1, 2, or 3. We are strict in order to
    // keep it readable.
    Assert(1 <= nPosition && nPosition <= 3);
    Assert(hwndNew);

    switch (nPosition) {
    case 1:
        // Make it topmost
        SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        break;

    case 2:
        // Try to place it 2nd in Z order
        if (NULL == hwndCur) {
            // We don't have a topmost window, so make this one the topmost window
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        } else {
            // Place it in 2nd
            SetWindowPos(hwndNew, hwndCur, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            // Give the topmost most focus again and activate UI visual clues.
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndCur, 0);
        }
        break;

    case 3:
        // Try to place it 3rd in Z order
        if (NULL == hwndCur) {
            // We don't have a topmost window, so make this one the topmost window
            SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndNew, 0);
        } else {
            // Is there a window 2nd in the Z order?
            HWND hwndPlaceAfter = GetNextWindow(hwndCur, GW_HWNDNEXT);

            if (NULL == hwndPlaceAfter) {
                // No window 2nd in Z order. Then simply place it after the
                // topmost window.
                hwndPlaceAfter = hwndCur;
            }

            // Place it
            SetWindowPos(hwndNew, hwndPlaceAfter, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

          // Give the topmost most focus again and activate UI visual clues.
          SendMessage(g_hwndMDIClient, WM_MDIACTIVATE, (WPARAM) hwndCur, 0);
        }
        break;

    default:
        // Sanity check, the programmer missed a case
        Assert(0);
    }
}


void
ActivateMDIChild(
    HWND hwndNew,
    BOOL bUserActivated
    )
/*++
Routine Description:
    Used to activate a specified window. Automatically uses the hwndActive
    variable to determine the currently active window.

Arguments:
    hwndNew - The window to be placed in the new Z order.
    bUserActivated - Indicates whether this action was initiated by the
                user or by windbg. The value is to determine the Z order of
                any windows that are opened.
--*/
{
    if (hwndNew == NULL)
    {
        Assert(hwndNew);
        return;
    }

    HWND hwndPrev = NULL;
    PCOMMONWIN_DATA pCur_WinData = NULL;
    PCOMMONWIN_DATA pNew_WinData = NULL;
    PCOMMONWIN_DATA pPrev_WinData = NULL;

    HWND hwndCur = MDIGetActive(g_hwndMDIClient, NULL);

    if (!hwndCur || bUserActivated || hwndCur == hwndNew)
    {
        // Nothing else was open. So we make this one the
        // topmost window.
        //
        // Or the user requested that this window be made
        // the topmost window, and we obey.
        //
        // Or we are re-activating the current window.
        Internal_Activate(hwndCur, hwndNew, 1);
        return;
    }

    // See is we have 3 or more windows open
    hwndPrev = GetNextWindow(hwndCur, GW_HWNDNEXT);

    if (hwndCur)
    {
        pCur_WinData = GetCommonWinData(hwndCur);
    }

    pNew_WinData = GetCommonWinData(hwndNew);
    Assert(pNew_WinData);
    if (!pNew_WinData)
    {
        return;
    }

    if (hwndPrev)
    {
        pPrev_WinData = GetCommonWinData(hwndPrev);
    }

    //
    // Handle the case where the window activation
    // was requested by the debugger itself and not the
    // user.
    //

    switch (pNew_WinData->m_enumType)
    {
    default:
        Internal_Activate(hwndCur, hwndNew, bUserActivated ? 2 : 1);
        break;

    case DISASM_WINDOW:
    case DOC_WINDOW:
        if (GetSrcMode_StatusBar())
        {
            // Src mode

            if (pCur_WinData != NULL &&
                (DISASM_WINDOW == pCur_WinData->m_enumType ||
                 DOC_WINDOW == pCur_WinData->m_enumType))
            {
                // We can take the place of another doc/asm wind
                // Place 1st in z-order
                Internal_Activate(hwndCur, hwndNew, 1);
            }
            else
            {
                if (pPrev_WinData != NULL &&
                    (DOC_WINDOW == pPrev_WinData->m_enumType ||
                     DISASM_WINDOW == pPrev_WinData->m_enumType))
                {
                    // Don't have a window in 2nd place, or if we do it
                    // is a src or asm window, and we can hide it.
                    // Place 2nd in Z-order
                    Internal_Activate(hwndCur, hwndNew, 2);
                }
                else
                {
                    // Place 3rd in Z-order
                    Internal_Activate(hwndCur, hwndNew, 3);
                }
            }
        }
        else
        {
            WIN_TYPES Type = pCur_WinData != NULL ?
                pCur_WinData->m_enumType : MINVAL_WINDOW;
            
            // Asm mode

            // Which is currently the topmost window.
            switch (Type)
            {
            case DOC_WINDOW:
                // Place 1st in z-order
                Internal_Activate(hwndCur, hwndNew, 1);
                break;

            case DISASM_WINDOW:
                if (DOC_WINDOW == pNew_WinData->m_enumType)
                {
                    if (pPrev_WinData == NULL ||
                        DOC_WINDOW != pPrev_WinData->m_enumType)
                    {
                        // We have a window in second place that isn't a doc
                        // window (locals, watch, ...).
                        Internal_Activate(hwndCur, hwndNew, 3);
                    }
                    else
                    {
                        // Either don't have any windows in second place, or
                        // we have a window in second place that is a doc
                        // window. We can take its place.
                        //
                        // Place 2nd in z-order
                        Internal_Activate(hwndCur, hwndNew, 2);
                    }
                }
                else
                {
                    // Should never happen. The case of disasm being activated
                    // when it is currently active should ahve already been
                    // taken care of.
                    Dbg(0);
                }
                break;

            default:
                if ((pPrev_WinData != NULL &&
                     DISASM_WINDOW == pPrev_WinData->m_enumType) &&
                    DOC_WINDOW == pNew_WinData->m_enumType)
                {
                    // window (locals, watch, ...).
                    Internal_Activate(hwndCur, hwndNew, 3);
                }
                else
                {
                    // Place 2nd in z-order
                    Internal_Activate(hwndCur, hwndNew, 2);
                }
                break;
            }
        }
        break;
    }
}


void
AppendTextToAnEditControl(
    HWND hwnd,
    PTSTR pszNewText
    )
{
    Assert(hwnd);
    Assert(pszNewText);

    CHARRANGE chrrgCurrent = {0};
    CHARRANGE chrrgAppend = {0};

    // Get the current selection
    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM) &chrrgCurrent);

    // Set the selection to the very end of the edit control
    chrrgAppend.cpMin = chrrgAppend.cpMax = GetWindowTextLength(hwnd);
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM) &chrrgCurrent);
    // Append the text
    SendMessage(hwnd, EM_REPLACESEL, FALSE, (LPARAM) pszNewText);

    // Restore previous selection
    SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM) &chrrgCurrent);
}


VOID
CopyToClipboard(
    PSTR str
    )
{
    if (!str)
    {
        return;
    }

    ULONG  Len = strlen(str)+1;
    HANDLE Mem = GlobalAlloc(GMEM_MOVEABLE, Len);
    if (Mem == NULL)
    {
        return;
    }

    PSTR Text = (PSTR)GlobalLock(Mem);
    if (Text == NULL)
    {
        GlobalFree(Mem);
        return;
    }

    strcpy(Text, str);

    GlobalUnlock(Mem);

    if (OpenClipboard(NULL))
    {
        EmptyClipboard();
        if (SetClipboardData(CF_TEXT, Mem) == NULL)
        {
            GlobalFree(Mem);
        }

        CloseClipboard();
    }
}

void
SetAllocString(PSTR* Str, PSTR New)
{
    if (*Str != NULL)
    {
        free(*Str);
    }
    *Str = New;
}

BOOL
DupAllocString(PSTR* Str, PSTR New)
{
    PSTR NewStr = (PSTR)malloc(strlen(New) + 1);
    if (NewStr == NULL)
    {
        return FALSE;
    }

    strcpy(NewStr, New);
    SetAllocString(Str, NewStr);
    return TRUE;
}

BOOL
PrintAllocString(PSTR* Str, int Len, PCSTR Format, ...)
{
    PSTR NewStr = (PSTR)malloc(Len);
    if (NewStr == NULL)
    {
        return FALSE;
    }
    
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(NewStr, Len, Format, Args);
    va_end(Args);

    SetAllocString(Str, NewStr);
    return TRUE;
}

HMENU
CreateContextMenuFromToolbarButtons(ULONG NumButtons,
                                    TBBUTTON* Buttons,
                                    ULONG IdBias)
{
    ULONG i;
    HMENU Menu;

    Menu = CreatePopupMenu();
    if (Menu == NULL)
    {
        return Menu;
    }

    for (i = 0; i < NumButtons; i++)
    {
        MENUITEMINFO Item;

        ZeroMemory(&Item, sizeof(Item));
        Item.cbSize = sizeof(Item);
        Item.fMask = MIIM_TYPE;
        if (Buttons->fsStyle & BTNS_SEP)
        {
            Item.fType = MFT_SEPARATOR;
        }
        else
        {
            Item.fMask |= MIIM_ID;
            Item.fType = MFT_STRING;
            Item.wID = (WORD)(Buttons->idCommand + IdBias);
            Item.dwTypeData = (LPSTR)Buttons->iString;
        }
        
        if (!InsertMenuItem(Menu, i, TRUE, &Item))
        {
            DestroyMenu(Menu);
            return NULL;
        }

        Buttons++;
    }

    DrawMenuBar(g_hwndFrame);
    return Menu;
}

HWND
AddButtonBand(HWND Bar, PTSTR Text, PTSTR SizingText, UINT Id)
{
    HWND Button;
    HDC Dc;
    RECT Rect;
    
    Button = CreateWindowEx(0, "BUTTON", Text, WS_VISIBLE | WS_CHILD,
                            0, 0, 0, 0,
                            Bar, (HMENU)(UINT_PTR)Id, g_hInst, NULL);
    if (Button == NULL)
    {
        return NULL;
    }

    Rect.left = 0;
    Rect.top = 0;
        
    SendMessage(Button, WM_SETFONT, (WPARAM)g_Fonts[FONT_VARIABLE].Font, 0);
    Dc = GetDC(Button);
    if (Dc != NULL)
    {
        SIZE Size;
        
        GetTextExtentPoint32(Dc, SizingText, strlen(SizingText), &Size);
        Rect.right = Size.cx;
        Rect.bottom = Size.cy;
        ReleaseDC(Button, Dc);
    }
    else
    {
        Rect.right = strlen(Text) * g_Fonts[FONT_FIXED].Metrics.tmAveCharWidth;
        Rect.bottom = g_Fonts[FONT_FIXED].Metrics.tmHeight;
    }

    REBARBANDINFO BandInfo;
    BandInfo.cbSize = sizeof(BandInfo);
    BandInfo.fMask = RBBIM_STYLE | RBBIM_CHILD | RBBIM_CHILDSIZE;
    BandInfo.fStyle = RBBS_FIXEDSIZE;
    BandInfo.hwndChild = Button;
    BandInfo.cxMinChild = Rect.right - Rect.left +
        4 * GetSystemMetrics(SM_CXEDGE);
    BandInfo.cyMinChild = Rect.bottom - Rect.top +
        2 * GetSystemMetrics(SM_CYEDGE);
    SendMessage(Bar, RB_INSERTBAND, -1, (LPARAM)&BandInfo);

    return Button;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\windbg.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    windbg.cpp

Abstract:

    This module contains the main program, main window proc and MDICLIENT
    window proc for Windbg.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <dbghelp.h>

ULONG g_CodeDisplaySequence;

PTSTR g_ProgramName;
ULONG g_CommandLineStart;
PSTR g_RemoteOptions;

BOOL g_QuietMode;

ULONG g_DefPriority;

char g_TitleServerText[MAX_PATH];
char g_TitleExtraText[MAX_PATH];
BOOL g_ExplicitTitle;

PFN_FlashWindowEx g_FlashWindowEx;

BOOL g_AllowJournaling;

BOOL g_Exit;

// Handle to main window
HWND g_hwndFrame = NULL;

// Handle to MDI client
HWND g_hwndMDIClient = NULL;

// Width and height of MDI client.
ULONG g_MdiWidth, g_MdiHeight;

//Handle to instance data
HINSTANCE g_hInst;

//Handle to accelerator table
HACCEL g_hMainAccTable;

//Keyboard Hooks functions
HHOOK   hKeyHook;

// WinDBG title text
TCHAR g_MainTitleText[MAX_MSG_TXT];

// menu that belongs to g_hwndFrame
HMENU g_hmenuMain;
HMENU g_hmenuMainSave;

// Window submenu
HMENU g_hmenuWindowSub;

#ifdef DBG
// Used to define debugger output
DWORD dwVerboseLevel = MIN_VERBOSITY_LEVEL;
#endif

INDEXED_COLOR g_Colors[COL_COUNT] =
{
    // Set from GetSysColor(COLOR_WINDOW).
    "Background", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_WINDOWTEXT).
    "Text", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHT).
    "Current line background", 0, 0, NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Current line text", 0, 0, NULL,
    
    // Purple.
    "Breakpoint current line background", 0, RGB(255, 0, 255), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Breakpoint current line text", 0, 0, NULL,
    
    // Red.
    "Enabled breakpoint background", 0, RGB(255, 0, 0), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Enabled breakpoint text", 0, 0, NULL,
    
    // Yellow.
    "Disabled breakpoint background", 0, RGB(255, 255, 0), NULL,
    
    // Set from GetSysColor(COLOR_HIGHLIGHTTEXT).
    "Disabled breakpoint text", 0, 0, NULL,
};

// There is a foreground and background color for each
// possible bit in the output mask.  The default foreground
// color is normal window text and the background is
// the normal window background.
//
// There are also some extra colors for user-added output.
//
// Some mask bits have no assigned meaning right now and
// are given NULL names to mark them as skip entries.  Their
// indices are allocated now for future use.
INDEXED_COLOR g_OutMaskColors[OUT_MASK_COL_COUNT] =
{
    // 0x00000001 - 0x00000008.
    "Normal level command window text", 0, 0, NULL,
    "Normal level command window text background", 0, 0, NULL,
    "Error level command window text", 0, 0, NULL,
    "Error level command window text background", 0, 0, NULL,
    "Warning level command window text", 0, 0, NULL,
    "Warning level command window text background", 0, 0, NULL,
    "Verbose level command window text", 0, 0, NULL,
    "Verbose level command window text background", 0, 0, NULL,
    // 0x00000010 - 0x00000080.
    "Prompt level command window text", 0, 0, NULL,
    "Prompt level command window text background", 0, 0, NULL,
    "Prompt registers level command window text", 0, 0, NULL,
    "Prompt registers level command window text background", 0, 0, NULL,
    "Extension warning level command window text", 0, 0, NULL,
    "Extension warning level command window text background", 0, 0, NULL,
    "Debuggee level command window text", 0, 0, NULL,
    "Debuggee level command window text background", 0, 0, NULL,
    // 0x00000100 - 0x00000800.
    "Debuggee prompt level command window text", 0, 0, NULL,
    "Debuggee prompt level command window text background", 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00001000 - 0x00008000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00010000 - 0x00080000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x00100000 - 0x00800000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x01000000 - 0x08000000.
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    NULL, 0, 0, NULL,
    // 0x10000000 - 0x80000000.
    "Internal event level command window text", 0, 0, NULL,
    "Internal event level command window text background", 0, 0, NULL,
    "Internal breakpoint level command window text", 0, 0, NULL,
    "Internal breakpoint level command window text background", 0, 0, NULL,
    "Internal remoting level command window text", 0, 0, NULL,
    "Internal remoting level command window text background", 0, 0, NULL,
    "Internal KD protocol level command window text", 0, 0, NULL,
    "Internal KD protocol level command window text background", 0, 0, NULL,
    // User-added text.
    "User-added command window text", 0, 0, NULL,
    "User-added command window text background", 0, 0, NULL,
};

COLORREF g_CustomColors[CUSTCOL_COUNT];

void
UpdateFrameTitle(void)
{
    char TitleBuf[MAX_MSG_TXT + 2 * MAX_PATH + 32];
    PSTR Title = TitleBuf;

    strcpy(Title, g_MainTitleText);
    Title = Title + strlen(Title);

    if (g_ExplicitTitle)
    {
        strcpy(Title, " - ");
        Title += 3;
        strcpy(Title, g_TitleExtraText);
    }
    else
    {
        if (g_TitleServerText[0])
        {
            strcpy(Title, " - ");
            Title += 3;
            strcpy(Title, g_TitleServerText);
            Title += strlen(Title);
        }

        if (g_TitleExtraText[0])
        {
            strcpy(Title, " - ");
            Title += 3;
            strcpy(Title, g_TitleExtraText);
            Title += strlen(Title);
        }
    }
    
    SetWindowText(g_hwndFrame, TitleBuf);
}

void
SetTitleServerText(PCSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    _vsnprintf(g_TitleServerText, sizeof(g_TitleServerText), Format, Args);
    g_TitleServerText[sizeof(g_TitleServerText) - 1] = 0;
    va_end(Args);
    UpdateFrameTitle();
}

void
SetTitleSessionText(PCSTR Format, ...)
{
    // Don't override an explicit title.
    if (g_ExplicitTitle)
    {
        return;
    }

    if (Format == NULL)
    {
        g_TitleExtraText[0] = 0;
    }
    else
    {
        va_list Args;
        va_start(Args, Format);
        _vsnprintf(g_TitleExtraText, sizeof(g_TitleExtraText), Format, Args);
        g_TitleExtraText[sizeof(g_TitleExtraText) - 1] = 0;
        va_end(Args);
    }
    
    UpdateFrameTitle();
}

void
SetTitleExplicitText(PCSTR Text)
{
    g_TitleExtraText[0] = 0;
    strncat(g_TitleExtraText, Text, sizeof(g_TitleExtraText) - 1);
    g_ExplicitTitle = TRUE;
    UpdateFrameTitle();
}

void
UpdateTitleSessionText(void)
{
    if (!g_RemoteClient)
    {
        char ProcServer[MAX_CMDLINE_TXT];

        if (g_ProcessServer != NULL)
        {
            sprintf(ProcServer, "[%s] ", g_ProcessServer);
        }
        else
        {
            ProcServer[0] = 0;
        }
        
        if (g_DumpFile != NULL)
        {
            SetTitleSessionText("Dump %s", g_DumpFile);
        }
        else if (g_DebugCommandLine != NULL)
        {
            SetTitleSessionText("%s%s", ProcServer, g_DebugCommandLine);
        }
        else if (g_PidToDebug != 0)
        {
            SetTitleSessionText("%sPid %d", ProcServer, g_PidToDebug);
        }
        else if (g_ProcNameToDebug != NULL)
        {
            SetTitleSessionText("%sProcess %s", ProcServer, g_ProcNameToDebug);
        }
        else if (g_AttachKernelFlags == DEBUG_ATTACH_LOCAL_KERNEL)
        {
            SetTitleSessionText("Local kernel");
        }
        else if (g_AttachKernelFlags == DEBUG_ATTACH_EXDI_DRIVER)
        {
            SetTitleSessionText("eXDI '%s'",
                                g_KernelConnectOptions);
        }
        else
        {
            SetTitleSessionText("Kernel '%s'",
                                g_KernelConnectOptions);
        }
    }
    else
    {
        SetTitleSessionText("Remote '%s'", g_RemoteOptions);
    }
}

BOOL
CreateUiInterfaces(
    BOOL   Remote,
    LPTSTR CreateOptions
    )
{
    HRESULT Hr;

    //
    // Destroy the old interfaces if they existed.
    //

    ReleaseUiInterfaces();

    //
    // Create the new debugger interfaces the UI will use.
    //

    if (Remote)
    {
        if ((Hr = DebugConnect(CreateOptions, IID_IDebugClient,
                               (void **)&g_pUiClient)) != S_OK)
        {
            if (Hr == E_INVALIDARG)
            {
                InformationBox(ERR_Invalid_Remote_Param);
            }
            else if (Hr == RPC_E_VERSION_MISMATCH)
            {
                InformationBox(ERR_Remoting_Version_Mismatch);
            }
            else if (Hr == RPC_E_SERVER_DIED ||
                     Hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                InformationBox(ERR_No_Remote_Server, CreateOptions);
            }
            else
            {
                InformationBox(ERR_Unable_To_Connect, CreateOptions, Hr);
            }
            return FALSE;
        }

        g_RemoteClient = TRUE;
        g_RemoteOptions = _tcsdup(CreateOptions);
    }
    else
    {
        if ((Hr = DebugCreate(IID_IDebugClient,
                             (void **)&g_pUiClient)) != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "UI DebugCreate");
            return FALSE;
        }

        if (CreateOptions != NULL &&
            (Hr = g_pUiClient->StartServer(CreateOptions)) != S_OK)
        {
            if (Hr == E_INVALIDARG)
            {
                InformationBox(ERR_Invalid_Server_Param);
            }
            else if (Hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) ||
                     Hr == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                InformationBox(ERR_Connection_In_Use);
            }
            else
            {
                InformationBox(ERR_Internal_Error, Hr, "UI StartServer");
            }
            return FALSE;
        }
    }

    if ((Hr = g_pUiClient->QueryInterface(IID_IDebugControl,
                                          (void **)&g_pUiControl)) != S_OK)
    {
        if (Hr == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InformationBox(ERR_Internal_Error, Hr, "UI QueryControl");
        }
        return FALSE;
    }

    if ((Hr = g_pUiClient->QueryInterface(IID_IDebugSymbols,
                                          (void **)&g_pUiSymbols)) != S_OK)
    {
        if (Hr == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InformationBox(ERR_Internal_Error, Hr, "UI QuerySymbols");
        }
        return FALSE;
    }

    if ((Hr = g_pUiClient->QueryInterface(IID_IDebugSystemObjects,
                                          (void **)&g_pUiSystem)) != S_OK)
    {
        if (Hr == RPC_E_VERSION_MISMATCH)
        {
            InformationBox(ERR_Remoting_Version_Mismatch);
        }
        else
        {
            InformationBox(ERR_Internal_Error, Hr, "UI QuerySystem");
        }
        return FALSE;
    }

    //
    // Optional interfaces.
    //

    if ((Hr = g_pUiClient->QueryInterface(IID_IDebugSymbols2,
                                          (void **)&g_pUiSymbols2)) != S_OK)
    {
        g_pUiSymbols2 = NULL;
    }

    if (g_RemoteClient)
    {
        // Create a local client to do local source file lookups.
        if ((Hr = DebugCreate(IID_IDebugClient,
                              (void **)&g_pUiLocClient)) != S_OK ||
            (Hr = g_pUiLocClient->
             QueryInterface(IID_IDebugControl,
                            (void **)&g_pUiLocControl)) != S_OK ||
            (Hr = g_pUiLocClient->
             QueryInterface(IID_IDebugSymbols,
                            (void **)&g_pUiLocSymbols)) != S_OK)
        {
            InformationBox(ERR_Internal_Error, Hr, "UI local symbol object");
            return FALSE;
        }
    }
    else
    {
        g_pUiLocClient = g_pUiClient;
        g_pUiLocClient->AddRef();
        g_pUiLocControl = g_pUiControl;
        g_pUiLocControl->AddRef();
        g_pUiLocSymbols = g_pUiSymbols;
        g_pUiLocSymbols->AddRef();
    }
    
    return TRUE;
}

void
ReleaseUiInterfaces(void)
{
    RELEASE(g_pUiClient);
    RELEASE(g_pUiControl);
    RELEASE(g_pUiSymbols);
    RELEASE(g_pUiSymbols2);
    RELEASE(g_pUiSystem);
    RELEASE(g_pUiLocClient);
    RELEASE(g_pUiLocControl);
    RELEASE(g_pUiLocSymbols);
}

PTSTR
GetArg(
    PTSTR *lpp
    )
{
    static PTSTR pszBuffer = NULL;
    int r;
    PTSTR p1 = *lpp;

    while (*p1 == _T(' ') || *p1 == _T('\t'))
    {
        p1++;
    }

    if (pszBuffer)
    {
        free(pszBuffer);
    }
    pszBuffer = (PTSTR) calloc(_tcslen(p1) + 1, sizeof(TCHAR));
    if (pszBuffer == NULL)
    {
        ErrorExit(NULL, "Unable to allocate command line argument\n");
    }

    r = CPCopyString(&p1, pszBuffer, 0, (*p1 == _T('\'') || *p1 == _T('"') ));
    if (r >= 0)
    {
        *lpp = p1;
    }
    return pszBuffer;
}


BOOL
ParseCommandLine(BOOL FirstParse)
{
    PTSTR   lp1 = GetCommandLine();
    PTSTR   lp2 = NULL;
    int Starts;

    g_CommandLineStart = 0;
    g_EngOptModified = 0;
    
    // skip whitespace
    while (*lp1 == _T(' ') || *lp1 == _T('\t'))
    {
        lp1++;
    }

    // skip over our program name
    if (_T('"') != *lp1)
    {
        lp1 += _tcslen(g_ProgramName);
    }
    else
    {
        // The program name is quoted.  If there's a trailing
        // quote skip over it.
        lp1 += _tcslen(g_ProgramName) + 1;
        if (*lp1 == _T('"'))
        {
            *lp1++;
        }
    }

    while (*lp1)
    {
        if (*lp1 == _T(' ') || *lp1 == _T('\t'))
        {
            lp1++;
            continue;
        }

        if (*lp1 == _T('-') || *lp1 == _T('/'))
        {
            ++lp1;

            switch (*lp1++)
            {
            case _T('?'):
            usage:
                SpawnHelp(HELP_TOPIC_COMMAND_LINE_WINDBG);
                exit(1);

            case _T(' '):
            case _T('\t'):
                break;

            case _T('b'):
                g_pUiControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
                if (g_RemoteClient)
                {
                    // The engine may already be waiting so just ask
                    // for a breakin immediately.
                    g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
                }
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_BREAK;
                break;

            case _T('c'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 5 &&
                    !memcmp(lp1, "lines", 5))
                {
                    lp1 = lp2;
                    g_HistoryLines = atoi(GetArg(&lp1));
                }
                else
                {
                    g_InitialCommand = _tcsdup(GetArg(&lp1));
                }
                break;
                    
            case _T('d'):
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_INITIAL_MODULE_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
                break;

            case _T('e'):
                // Signal an event after process is attached.
                g_pUiControl->SetNotifyEventHandle(_atoi64(GetArg(&lp1)));
                break;

            case _T('f'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 != lp1 + 6 ||
                    memcmp(lp1, "ailinc", 6))
                {
                    goto usage;
                }
                
                lp1 = lp2;
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION);
                g_pUiSymbols->
                    AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
                break;
                
            case _T('g'):
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_INITIAL_BREAK;
                break;

            case _T('G'):
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
                g_EngOptModified |= DEBUG_ENGOPT_FINAL_BREAK;
                break;

            case _T('h'):
                if (*lp1 == _T('d'))
                {
                    lp1++;
                    g_DebugCreateFlags |=
                        DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
                }
                else
                {
                    goto usage;
                }
                break;
                    
            case _T('i'):
                g_pUiSymbols->SetImagePath(GetArg(&lp1));
                break;

            case _T('I'):
                if (!InstallAsAeDebug(NULL))
                {
                    InformationBox(ERR_Fail_Inst_Postmortem_Dbg);
                }
                else
                {
                    InformationBox(ERR_Success_Inst_Postmortem_Dbg);
                    exit(1);
                }
                break;

                // XXX AndreVa - This needs to be checked before we start
                // the GUI.
            case _T('J'):
            case _T('j'):
                g_AllowJournaling = TRUE;
                break;
        
            case _T('k'):
                if (*lp1 == _T('l'))
                {
                    g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
                    lp1++;
                }
                else if (*lp1 == _T('x'))
                {
                    g_AttachKernelFlags = DEBUG_ATTACH_EXDI_DRIVER;
                    lp1++;
                    g_KernelConnectOptions = _tcsdup(GetArg(&lp1));
                }
                else
                {
                    g_KernelConnectOptions = _tcsdup(GetArg(&lp1));
                }
                g_CommandLineStart++;
                break;

            case _T('n'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 6 &&
                    !memcmp(lp1, "oshell", 6))
                {
                    lp1 = lp2;
                    g_pUiControl->AddEngineOptions
                        (DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS);
                    break;
                }
                else
                {
                    g_pUiSymbols->AddSymbolOptions(SYMOPT_DEBUG);
                }
                break;

            case _T('o'):
                if (g_RemoteClient)
                {
                    goto usage;
                }

                g_DebugCreateFlags |= DEBUG_PROCESS;
                g_DebugCreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
                break;

            case _T('p'):
                // attach to an active process
                // p specifies a process id
                // pn specifies a process by name
                // ie: -p 360 
                //     -pn _T("foo bar")
                
                if (!isspace(*lp1) && !isdigit(*lp1))
                {
                    // They may have specified a -p flag with
                    // a tail such as -premote.
                    lp2 = lp1;
                    while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                    {
                        lp2++;
                    }
                    if (lp2 == lp1 + 6 &&
                        !memcmp(lp1, "remote", 6))
                    {
                        lp1 = lp2;
                        g_ProcessServer = _tcsdup(GetArg(&lp1));
                        break;
                    }
                    else if (_T('d') == *lp1)
                    {
                        lp1++;
                        g_DetachOnExit = TRUE;
                        break;
                    }
                    else if (_T('e') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags = DEBUG_ATTACH_EXISTING;
                        break;
                    }
                    else if (_T('t') == *lp1)
                    {
                        lp1++;
                        g_pUiControl->
                            SetInterruptTimeout(atoi(GetArg(&lp1)));
                        break;
                    }
                    else if (_T('v') == *lp1)
                    {
                        lp1++;
                        g_AttachProcessFlags = DEBUG_ATTACH_NONINVASIVE;
                        break;
                    }
                    else if (_T('n') != *lp1)
                    {
                        goto usage;
                    }
                    else
                    {
                        // Skip the _T('n')
                        lp1++;
                        g_ProcNameToDebug = _tcsdup(GetArg(&lp1));
                    }
                }
                else
                {
                    // They specified -p 360
                    g_PidToDebug = strtoul(GetArg(&lp1), NULL, 0);
                    
                    if (g_PidToDebug <= 0)
                    {
                        g_PidToDebug = -2;
                        ErrorBox(NULL, 0, ERR_Invalid_Process_Id,
                                 g_PidToDebug);
                    }
                }
                g_CommandLineStart++;
                break;

            case _T('Q'):
                g_QuietMode = TRUE;
                break;
                    
            case _T('r'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 3 &&
                    !memcmp(lp1, "obp", 3))
                {
                    lp1 = lp2;
                    g_pUiControl->AddEngineOptions
                        (DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS);
                    break;
                }
                else if (lp2 != lp1 + 5 ||
                         memcmp(lp1, "emote", 5))
                {
                    goto usage;
                }
                    
                lp1 = lp2;
                lp2 = GetArg(&lp1);
                if (!CreateUiInterfaces(TRUE, lp2))
                {
                    return FALSE;
                }

                g_CommandLineStart++;
                break;

            case _T('s'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 5 &&
                    !memcmp(lp1, "erver", 5))
                {
                    lp1 = lp2;
                    lp2 = GetArg(&lp1);
                    if (!CreateUiInterfaces(FALSE, lp2))
                    {
                        return FALSE;
                    }
                    
                    SetTitleServerText("Server '%s'", lp2);
                }
                else if (lp2 == lp1 + 2 &&
                         !memcmp(lp1, "es", 2))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "fce", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "icv", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->AddSymbolOptions(SYMOPT_IGNORE_CVREC);
                }
                else if (lp2 == lp1 + 3 &&
                         !memcmp(lp1, "nul", 3))
                {
                    lp1 = lp2;
                    g_pUiSymbols->
                        AddSymbolOptions(SYMOPT_NO_UNQUALIFIED_LOADS);
                }
                else if (lp2 == lp1 + 6 &&
                         !memcmp(lp1, "rcpath", 6))
                {
                    lp1 = lp2;
                    g_pUiSymbols->SetSourcePath(GetArg(&lp1));
                }
                else
                {
                    goto usage;
                }
                break;
                    
            case _T('T'):
                lp2 = GetArg(&lp1);
                SetTitleExplicitText(lp2);
                if (g_ExplicitWorkspace && g_Workspace != NULL)
                {
                    g_Workspace->SetString(WSP_WINDOW_FRAME_TITLE, lp2);
                }
                break;

            case _T('v'):
                g_Verbose = TRUE;
                break;

            case _T('w'):
                lp2 = lp1;
                while (*lp2 && *lp2 != ' ' && *lp2 != '\t')
                {
                    lp2++;
                }
                if (lp2 == lp1 + 3 &&
                    !memcmp(lp1, "ake", 3))
                {
                    ULONG Pid;
                    
                    lp1 = lp2;
                    Pid = strtoul(GetArg(&lp1), NULL, 0);
                    if (!SetPidEvent(Pid, OPEN_EXISTING))
                    {
                        InformationBox(ERR_Wake_Failed, Pid);
                        ErrorExit(NULL,
                                  "Process %d is not a sleeping debugger\n",
                                  Pid);
                    }
                    else
                    {
                        ExitDebugger(NULL, 0);
                    }
                }
                break;
                
            case _T('W'):
                if (*lp1 != _T('X'))
                {
                    if (UiSwitchWorkspace(WSP_NAME_EXPLICIT, GetArg(&lp1),
                                          FALSE, WSP_APPLY_EXPLICIT,
                                          &Starts) != S_OK)
                    {
                        goto usage;
                    }

                    g_CommandLineStart += Starts;
                }
                else
                {
                    // Skip X.
                    lp1++;
                    if (g_Workspace != NULL)
                    {
                        g_Workspace->Flush(FALSE, FALSE);
                        delete g_Workspace;
                    }
                    g_Workspace = NULL;
                }
                g_ExplicitWorkspace = TRUE;
                break;
                
            case _T('y'):
                g_pUiSymbols->SetSymbolPath(GetArg(&lp1));
                break;

            case _T('z'):
                if (*lp1 == _T('p'))
                {
                    lp1++;
                    g_DumpPageFile = _tcsdup(GetArg(&lp1));
                }
                else if (*lp1 && *lp1 != _T(' ') && *lp1 != _T('\t'))
                {
                    goto usage;
                }
                else
                {
                    g_DumpFile = _tcsdup(GetArg(&lp1));
                    g_CommandLineStart++;
                }
                break;

            default:
                --lp1;
                goto usage;
            }
        }
        else
        {
            // pick up file args.  If it is a program name,
            // keep the tail of the cmd line intact.
            g_DebugCommandLine = _tcsdup(lp1);
            g_CommandLineStart++;
            break;
        }
    }

    //
    // If a command line start option was set, we can just start the engine
    // right away.  Otherwise, we have to wait for user input.
    //
    // If multiple command line option were set, print an error.
    //

    if (g_CommandLineStart == 1)
    {
        PostMessage(g_hwndFrame, WU_START_ENGINE, 0, 0);
    }
    else if (g_CommandLineStart > 1)
    {
        ErrorBox(NULL, 0,  ERR_Invalid_Command_Line);
        return FALSE;
    }
    return TRUE;
}

void
StopDebugging(BOOL UserRequest)
{
    // Flush the current workspace first so
    // the engine thread doesn't.
    if (g_Workspace != NULL &&
        g_Workspace->Flush(FALSE, FALSE) == S_FALSE)
    {
        // User cancelled things so don't terminate.  We
        // don't offer that option right now so this
        // should never happen.
        return;
    }
                
    if (g_EngineThreadId)
    {
        DWORD WaitStatus;

        if (UserRequest)
        {
            // Try to get the current engine operation stopped.
            g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_EXIT);
        
            // If this stop is coming from the UI thread
            // clean up the current session.
            AddEnumCommand(UIC_END_SESSION);
        }

        for (;;)
        {
            // Wait for the engine thread to finish.
            WaitStatus = WaitForSingleObject(g_EngineThread, 30000);
            if (WaitStatus != WAIT_TIMEOUT)
            {
                break;
            }
            else
            {
                // Engine is still busy.  If the user requested
                // the stop, ask the user whether they want to keep
                // waiting.  If they don't they'll have to exit
                // windbg as the engine must be available in
                // order to restart anything.  If this is a stop
                // from the engine thread itself it should have
                // finished up by now, so something is wrong.
                // For now give the user the same option but
                // in the future we might want to have special
                // behavior.
                if (QuestionBox(STR_Engine_Still_Busy, MB_YESNO) == IDNO)
                {
                    ExitDebugger(g_pUiClient, 0);
                }

                if (UserRequest)
                {
                    // Try again to get the engine to stop.
                    g_pUiControl->SetInterrupt(DEBUG_INTERRUPT_EXIT);
                }
            }
        }
    }

    if (g_EngineThread != NULL)
    {
        CloseHandle(g_EngineThread);
        g_EngineThread = NULL;
    }
    
    CloseAllWindows();
    if (!CreateUiInterfaces(FALSE, NULL))
    {
        InformationBox(ERR_Internal_Error, E_OUTOFMEMORY,
                       "CreateUiInterfaces");
        ErrorExit(NULL, "Unable to recreate UI interfaces\n");
    }

    //
    // Reset all session starting values.
    //
    // Do not clear the process server value here
    // as the UI doesn't offer any way to set it
    // so just let the command line setting persist
    // for the entire run of the process.
    //
    
    g_AttachKernelFlags = 0;
    free(g_KernelConnectOptions);
    g_KernelConnectOptions = NULL;
    g_PidToDebug = 0;
    free(g_ProcNameToDebug);
    g_ProcNameToDebug = NULL;
    free(g_DumpFile);
    g_DumpFile = NULL;
    free(g_DumpPageFile);
    g_DumpPageFile = NULL;
    free(g_DebugCommandLine);
    g_DebugCommandLine = NULL;
    g_DebugCreateFlags = DEBUG_ONLY_THIS_PROCESS;
    g_RemoteClient = FALSE;
    free(g_RemoteOptions);
    g_RemoteOptions = NULL;
    g_DetachOnExit = FALSE;
    g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;
    SetTitleSessionText(NULL);
                
    // Any changes caused by shutting things down
    // are not user changes and can be ignored.
    if (g_Workspace != NULL)
    {
        g_Workspace->ClearDirty();
    }
    if (!g_ExplicitWorkspace)
    {
        UiSwitchWorkspace(WSP_NAME_BASE, g_WorkspaceDefaultName,
                          TRUE, WSP_APPLY_DEFAULT, NULL);
    }

    SetLineColumn_StatusBar(0, 0);
    SetPidTid_StatusBar(0, 0, 0, 0);
    EnableToolbarControls();
}


/****************************************************************/
/****************************************************************/
/****************************************************************/
/*
                case _T('A'):
                    // Auto start a dlg
                    // Used by the wizard so that the open executable
                    //  dlg or the attach dlg, will appear as soon as
                    //  windbg is started.
                    //
                    // _T('e') executable
                    // _T('p') process
                    // _T('d') dump file
                    // ie: Ae, Ap, Ad
                    if (isspace(*lp1)) {
                        goto usage;
                    } else {
                        if (_T('e') == *lp1) {
                            // Auto open the Open Executable dlg
                            PostMessage(g_hwndFrame,
                                        WM_COMMAND,
                                        MAKEWPARAM(IDM_FILE_OPEN_EXECUTABLE, 0),
                                        0);
                            lp1++;
                        } else if (_T('d') == *lp1) {
                            // Auto open the Attach to Process dlg
                            PostMessage(g_hwndFrame,
                                        WM_COMMAND,
                                        MAKEWPARAM(IDM_FILE_OPEN_CRASH_DUMP, 0),
                                        0);
                            lp1++;
                        } else if (_T('p') == *lp1) {
                            // Auto open the Attach to Process dlg
                            PostMessage(g_hwndFrame,
                                        WM_COMMAND,
                                        MAKEWPARAM(IDM_DEBUG_ATTACH, 0),
                                        0);
                            lp1++;
                        } else {
                            goto usage;
                        }
                    }
                    break;

                case _T('d'):
                    iDebugLevel = atoi( GetArg(&lp1) );
                    break;

                case _T('h'):
                    bInheritHandles = TRUE;
                    break;

                case _T('m'):
                    fMinimize = TRUE;
                    nCmdShow = SW_MINIMIZE;
                    break;


                case _T('r'):
                    g_AutoRun = arCmdline;
                    PszAutoRun = _tcsdup( GetArg(&lp1) );
                    ShowWindow(g_hwndFrame, nCmdShow);
                    break;

                case _T('R'):
                    {
                        //
                        // This code does not support nested dbl quotes.
                        //
                        BOOL bInDblQuotes = FALSE;
                        PTSTR lpszCmd;
                        PTSTR lpsz;

                        lpszCmd = lpsz = GetArg(&lp1);

                        while (*lpsz) {
                            if (_T('"') == *lpsz) {
                                // We found a quote. We assume it is either an
                                // opening quote or an ending quote, that's why
                                // we toggle.
                                bInDblQuotes = !bInDblQuotes;
                            } else {
                                // We only replace the _T('_') if we are not inside
                                // dbl quotes.
                                if (!bInDblQuotes && _T('_') == *lpsz) {
                                    *lpsz = _T(' ');
                                }
                            }
                            lpsz = CharNext(lpsz);
                        }

                        if ( nNumCmds < _tsizeof(rgpszCmds)/_tsizeof(rgpszCmds[0]) ) {
                            rgpszCmds[nNumCmds++] = _tcsdup(lpszCmd);
                        }
                    }
                    break;

                case _T('w'):
                    fWorkSpaceSpecified = TRUE;
                    _tcsncpy( szWorkSpace, GetArg(&lp1), _tsizeof(szWorkSpace) );
                    szWorkSpace[_tsizeof(szWorkSpace)-1] =NULL;
                    break;

                case _T('x'):
                    // window layout
                    bWindowLayoutSpecified = TRUE;
                    _tcsncpy(szWindowLayout, 
                             GetArg(&lp1),
                            _tsizeof(szWorkSpace)
                            );
                    szWindowLayout[_tsizeof(szWindowLayout)-1] =NULL;
                    break;
*/


void 
InitDefaults(
    void
    )
{
    SetSrcMode_StatusBar(TRUE);
}


INDEXED_COLOR*
GetIndexedColor(ULONG Index)
{
    INDEXED_COLOR* Table;

    if (Index < OUT_MASK_COL_BASE)
    {
        if (Index >= COL_COUNT)
        {
            return NULL;
        }
        
        return g_Colors + Index;
    }
    else
    {
        Index -= OUT_MASK_COL_BASE;
        if (Index >= OUT_MASK_COL_COUNT ||
            g_OutMaskColors[Index].Name == NULL)
        {
            return NULL;
        }

        return g_OutMaskColors + Index;
    }
}

BOOL
SetColor(ULONG Index, COLORREF Color)
{
    INDEXED_COLOR* IdxCol = GetIndexedColor(Index);
    if (IdxCol == NULL)
    {
        return FALSE;
    }
    
    if (IdxCol->Brush != NULL)
    {
        DeleteObject(IdxCol->Brush);
    }
        
    IdxCol->Color = Color;
    IdxCol->Brush = CreateSolidBrush(IdxCol->Color);

    // A UI color selection changing means the UI needs to refresh.
    // Out mask color changes only apply to new text and do
    // not need a refresh.
    return Index < COL_COUNT ? TRUE : FALSE;
}

BOOL
GetOutMaskColors(ULONG Mask, COLORREF* Fg, COLORREF* Bg)
{
    if (Mask == 0)
    {
        return FALSE;
    }
    
    ULONG Idx = 0;

    while ((Mask & 1) == 0)
    {
        Idx++;
        Mask >>= 1;
    }

    Idx *= 2;
    if (g_OutMaskColors[Idx].Name == NULL)
    {
        return FALSE;
    }
    
    *Fg = g_OutMaskColors[Idx].Color;
    *Bg = g_OutMaskColors[Idx + 1].Color;

    return TRUE;
}

void
InitColors(void)
{
    g_Colors[COL_PLAIN].Default =
        GetSysColor(COLOR_WINDOW);
    g_Colors[COL_PLAIN_TEXT].Default =
        GetSysColor(COLOR_WINDOWTEXT);
    g_Colors[COL_CURRENT_LINE].Default =
        GetSysColor(COLOR_HIGHLIGHT);
    g_Colors[COL_CURRENT_LINE_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_BP_CURRENT_LINE_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_ENABLED_BP_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_Colors[COL_DISABLED_BP_TEXT].Default =
        GetSysColor(COLOR_HIGHLIGHTTEXT);

    ULONG i;

    for (i = 0; i < COL_COUNT; i++)
    {
        SetColor(i, g_Colors[i].Default);
    }
    for (i = 0; i < OUT_MASK_COL_COUNT; i++)
    {
        if (g_OutMaskColors[i].Name != NULL)
        {
            g_OutMaskColors[i].Default =
                GetSysColor((i & 1) ? COLOR_WINDOW : COLOR_WINDOWTEXT);
            SetColor(i + OUT_MASK_COL_BASE, g_OutMaskColors[i].Default);
        }
    }

    for (i = 0; i < CUSTCOL_COUNT; i++)
    {
        g_CustomColors[i] = GetSysColor(i + 1);
    }
}

BOOL
InitGUI(
    VOID
    )
/*++

Routine Description:

    Initialize the GUI components of WinDBG so we can bring up
    the parent MDI window with the top level menus.

Arguments:

Return Value:

    TRUE if everything is OK, FALSE if something fails

--*/
{
    ULONG i;
    WNDCLASSEX wcex = {0};
    TCHAR szClassName[MAX_MSG_TXT];
    INITCOMMONCONTROLSEX InitCtrls =
    {
        sizeof(InitCtrls), ICC_WIN95_CLASSES | ICC_COOL_CLASSES |
        ICC_USEREX_CLASSES
    };


    // Journaling is a feature that applications, such as Visual Test, can
    // enable to synchronize all message queues.
    // In order to allow WinDBG to debug an app such as Visual Test, we
    // provide the option to disable journaling, which ensures WinDBG
    // has its own message queue at all times.
    //
    // Should journaling be allowed or disabled?
    //
    if (g_AllowJournaling == FALSE)
    {
        #define RST_DONTJOURNALATTACH 0x00000002
        typedef VOID (WINAPI * RST)(DWORD,DWORD);

        RST Rst = (RST) GetProcAddress( GetModuleHandle( _T("user32.dll") ),
                                        "RegisterSystemThread" );
        if (Rst)
        {
            (Rst) (RST_DONTJOURNALATTACH, 0);
        }
    }

    // Load the richedit 2.0 dll so that it can register the window class.
    // We require RichEdit 2 and cannot use RichEdit 1.
    // Since we intentionally need this library the entire duration, we
    // simply load it and lose the handle to it. We are in win32 and running
    // separate address spaces, and don't have to worry about freeing the
    // library.
    if (!LoadLibrary(_T("RICHED20.DLL")))
    {
        return FALSE;
    }

    if ( !InitCommonControlsEx( &InitCtrls ))
    {
        return FALSE;
    }

    //We use tmp strings as edit buffers
    Assert(MAX_LINE_SIZE < TMP_STRING_SIZE);


    Dbg(LoadString(g_hInst, SYS_Main_wTitle,
                   g_MainTitleText, _tsizeof(g_MainTitleText)));
    Dbg(LoadString(g_hInst, SYS_Main_wClass,
                   szClassName, _tsizeof(szClassName) ));
    
    //Register the main window szClassName

    wcex.cbSize         = sizeof(wcex);
    wcex.style          = 0;
    wcex.lpfnWndProc    = MainWndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = LoadIcon(g_hInst, MAKEINTRESOURCE(WINDBGICON) );
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wcex.lpszMenuName   = MAKEINTRESOURCE(MAIN_MENU);
    wcex.lpszClassName  = szClassName;
    wcex.hIconSm        = LoadIcon(g_hInst, MAKEINTRESOURCE(WINDBGICON) );

    if (!RegisterClassEx (&wcex) )
    {
        return FALSE;
    }


    //
    // Generic MDI child window.  Channels all processing
    // through the COMMONWIN abstraction.
    //
    Dbg(LoadString(g_hInst, SYS_CommonWin_wClass,
                   szClassName, _tsizeof(szClassName)));

    wcex.cbSize         = sizeof(wcex);
    wcex.style          = 0;
    wcex.lpfnWndProc    = COMMONWIN_DATA::WindowProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = NULL;
    // The cursor is set to SIZENS so that the proper
    // cursor appears in the command window splitter area.
    // All other areas are covered by child windows with
    // their own cursors.
    wcex.hCursor        = LoadCursor(NULL, IDC_SIZENS);
    wcex.hbrBackground  = (HBRUSH) (COLOR_ACTIVEBORDER + 1);
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = szClassName;
    wcex.hIconSm        = NULL;

    if (!RegisterClassEx(&wcex))
    {
        return FALSE ;
    }

    HDC Dc = GetDC(NULL);
    if (Dc == NULL)
    {
        return FALSE;
    }

    g_Fonts[FONT_FIXED].Font = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    g_Fonts[FONT_VARIABLE].Font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    
    for (ULONG FontIndex = 0; FontIndex < FONT_COUNT; FontIndex++)
    {
        SelectObject(Dc, g_Fonts[FontIndex].Font);
        if (!GetTextMetrics(Dc, &g_Fonts[FontIndex].Metrics))
        {
            return FALSE;
        }
    }

    ReleaseDC(NULL, Dc);

    InitColors();

    // Register message for FINDMSGSTRING.
    g_FindMsgString = RegisterWindowMessage(FINDMSGSTRING);

    // Look up FindWindowEx.
    HMODULE User32 = GetModuleHandle("user32.dll");
    if (User32 != NULL)
    {
        g_FlashWindowEx = (PFN_FlashWindowEx)
            GetProcAddress(User32, "FlashWindowEx");
    }
    
    //
    // Initialize window lists
    //
    InitializeListHead(&g_ActiveWin);

    Dbg(g_hMainAccTable = LoadAccelerators(g_hInst, MAKEINTRESOURCE(MAIN_ACC)));
    Dbg(LoadString(g_hInst, SYS_Main_wClass, szClassName, MAX_MSG_TXT));

    InitializeListHead(&g_StateList);

    __try
    {
        Dbg_InitializeCriticalSection( &g_QuickLock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    RECT WorkRect;
    RECT FrameRect;

    //
    // Try and create an initial window that's ready to work
    // without resizing.  Our goal here is to grab enough
    // screen space to given plenty of room for MDI windows
    // but not so much we might as well be maximized.
    //
    
    Dbg(SystemParametersInfo(SPI_GETWORKAREA, 0, &WorkRect, FALSE));

    // We don't want to take up more than 80% of either dimension.
    FrameRect.right = (WorkRect.right - WorkRect.left) * 4 / 5;
    FrameRect.bottom = (WorkRect.bottom - WorkRect.top) * 4 / 5;

    // We want width for an 80-character window plus space for
    // another narrow window like the CPU window.  We want
    // height for a forty row window plus space for a short
    // window like the stack.
    // If we can't get that much room just let the system
    // take charge.
    if (FrameRect.right < (CMD_WIDTH + CPU_WIDTH_32) ||
        FrameRect.bottom < (CMD_HEIGHT + CALLS_HEIGHT))
    {
        SetRect(&FrameRect, CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT);
    }
    else
    {
        // Hug the bottom left corner of the screen to
        // try and keep out of the way as much as possible
        // while still allowing the first bits of the
        // window to be seen.
        FrameRect.left = WorkRect.left;
        FrameRect.top = (WorkRect.bottom - WorkRect.top) - FrameRect.bottom;
    }
    
    //
    //  Create the frame
    //
    g_hwndFrame = CreateWindow(szClassName, 
                               g_MainTitleText,
                               WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN
                               | WS_VISIBLE,
                               FrameRect.left,
                               FrameRect.top,
                               FrameRect.right,
                               FrameRect.bottom,
                               NULL, 
                               NULL, 
                               g_hInst,
                               NULL
                               );

    //
    // Initialize the debugger
    //
    if ( !g_hwndFrame || !g_hwndMDIClient )
    {
        return FALSE;
    }

    //
    //  Get handle to main menu, window submenu, MRU submenu
    //
    Dbg( g_hmenuMain = GetMenu(g_hwndFrame) );
    g_hmenuMainSave = g_hmenuMain;

    Dbg( g_hmenuWindowSub = GetSubMenu(g_hmenuMain, WINDOWMENU) );

    Dbg( g_MruMenu = GetSubMenu(g_hmenuMain, FILEMENU) );
    Dbg( g_MruMenu = GetSubMenu(g_MruMenu,
                                IDM_FILE_MRU_FILE1 - IDM_FILE - 1) );

    //
    //  Init Items Colors ,Environment and RunDebug params to their default
    //  values 'They will later be overrided by the values in .INI file
    //  but we ensure to have something coherent even if we can't load
    //  the .INI file
    //
    InitDefaults();

    //
    //  Initialize Keyboard Hook
    //
    hKeyHook = SetWindowsHookEx(WH_KEYBOARD, 
                                KeyboardHook,
                                g_hInst,
                                GetCurrentThreadId()    
                                );

    return TRUE;
}


int
WINAPIV
main(
    int argc,
    PTSTR argv[ ],
    PTSTR envp[]
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argc - Supplies the count of arguments on command line.

    argv - Supplies a pointer to an array of string pointers.

Return Value:

    int - Returns the wParam from the WM_QUIT message.
    None.

--*/

{
    HRESULT Status;
    CHAR helpfile[MAX_PATH];

    g_ProgramName = argv[0];
    g_hInst = GetModuleHandle(NULL);
    g_DefPriority = GetPriorityClass(GetCurrentProcess());
    
    Dbg(LoadString(g_hInst, SYS_Help_File, helpfile, sizeof(helpfile)));
    MakeHelpFileName(helpfile);

    // Initialize enough of the GUI to bring up the top level window
    // so the menus can be activated.

    if (!InitGUI())
    {
        InformationBox(ERR_Internal_Error, E_OUTOFMEMORY, "InitGUI");
        return FALSE;
    }

    if (!CreateUiInterfaces(FALSE, NULL))
    {
        InformationBox(ERR_Internal_Error, E_OUTOFMEMORY,
                       "CreateUiInterfaces");
        return FALSE;
    }

    // Select the default workspace.
    if ((Status = UiSwitchWorkspace(WSP_NAME_BASE, g_WorkspaceDefaultName,
                                    TRUE, WSP_APPLY_DEFAULT, NULL)) != S_OK)
    {
        //InformationBox(ERR_Internal_Error, Status, "DefaultWorkspace");
    }
    
    // Parse the command line.
    // We need to do this before any GUI window is created to support the
    // journaling option.

    if (!ParseCommandLine(TRUE))
    {
        return FALSE;
    }

    // Enter main message loop.
    for (;;)
    {
        WaitMessage();
        ProcessPendingMessages();

        if (g_Exit)
        {
            break;
        }

        //
        // Check for any engine work that needs to be done.
        //

        ULONG EventSeq = g_CodeBufferSequence;
        if (EventSeq != g_CodeDisplaySequence)
        {
            // We don't want to stall the engine during
            // file loading so capture the state and then
            // release the lock.

            Dbg_EnterCriticalSection(&g_QuickLock);

            ULONG64 Ip = g_CodeIp;
            char FoundFile[MAX_SOURCE_PATH];
            char SymFile[MAX_SOURCE_PATH];
            strcpy(FoundFile, g_CodeFileFound);
            strcpy(SymFile, g_CodeSymFile);
            ULONG Line = g_CodeLine;
            BOOL UserActivated = g_CodeUserActivated;

            Dbg_LeaveCriticalSection(&g_QuickLock);

            UpdateCodeDisplay(Ip, FoundFile[0] ? FoundFile : NULL,
                              SymFile, Line, UserActivated);
            g_CodeDisplaySequence = EventSeq;
        }

        LockUiBuffer(&g_UiOutputBuffer);

        if (g_UiOutputBuffer.GetDataLen() > 0)
        {
            PSTR Text, End;
            COLORREF Fg, Bg;

            Text = (PSTR)g_UiOutputBuffer.GetDataBuffer();
            End = Text + g_UiOutputBuffer.GetDataLen();
            while (Text < End)
            {
                GetOutMaskColors(*(ULONG UNALIGNED *)Text, &Fg, &Bg);
                Text += sizeof(ULONG);
                CmdOutput(Text, Fg, Bg);
                Text += strlen(Text) + 1;
            }
            
            g_UiOutputBuffer.Empty();
        }

        UnlockUiBuffer(&g_UiOutputBuffer);
    }

    TerminateApplication(FALSE);
    
    // Keep the C++ compiler from whining
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\windbg.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    Windbg.h

Abstract:

    Main header file for the Windbg debugger.

--*/

#if ! defined( _WINDBG_ )
#define _WINDBG_

//----------------------------------------------------------------------------
//
// Global limit constants.
//
//----------------------------------------------------------------------------

#define MAX_MSG_TXT         4096    //Max text width in message boxes

#define TMP_STRING_SIZE     8192    //All purpose strings

#define MAX_CMDLINE_TXT     8192    //Max size for command line
#define MAX_VAR_MSG_TXT     8192    //Max size of a message built at run-time

#define MAX_LINE_SIZE       512     //Max inside length of editor line
#define MAX_USER_LINE       MAX_LINE_SIZE //Max length of user line

//----------------------------------------------------------------------------
//
// UI constants.
//
//----------------------------------------------------------------------------

//
//  Private window messages
//

#define WU_UPDATE               (WM_USER + 0)
#define WU_INVALIDATE           (WM_USER + 1)
#define WU_START_ENGINE         (WM_USER + 2)
#define WU_ENGINE_STARTED       (WM_USER + 3)
#define WU_SWITCH_WORKSPACE     (WM_USER + 4)
#define WU_ENGINE_IDLE          (WM_USER + 5)
#define WU_RECONFIGURE          (WM_USER + 6)

// Position of window menu.
#define WINDOWMENU              4

// Position of file menu.
#define FILEMENU                0

// Toolbar control identifier.
#define ID_TOOLBAR              100

// Generic customize button ID.
#define ID_CUSTOMIZE            29876
// Generic show/hide toolbar button ID.
#define ID_SHOW_TOOLBAR         29877

// For MDI default menu handling.
#define IDM_FIRSTCHILD      30000

/*
**  Include the defines which are used have numbers for string
**      resources.
*/

#include "res_str.h"

//----------------------------------------------------------------------------
//
// Variables.
//
//----------------------------------------------------------------------------

// Set when the debugger is exiting.
extern BOOL g_Exit;

extern ULONG g_CommandLineStart;
extern BOOL g_QuietMode;
extern ULONG g_DefPriority;

typedef BOOL (WINAPI* PFN_FlashWindowEx)(PFLASHWINFO pfwi);

extern PFN_FlashWindowEx g_FlashWindowEx;

//Handle to instance data
extern HINSTANCE g_hInst;

//Main window frame
extern HWND g_hwndFrame;

// Handle to MDI client
extern HWND g_hwndMDIClient;

// Width and height of MDI client.
extern ULONG g_MdiWidth, g_MdiHeight;

//Handle to accelerator table
extern HACCEL g_hMainAccTable;

//Keyboard Hooks functions
extern HHOOK hKeyHook;

// menu that belongs to g_hwndFrame
extern HMENU g_hmenuMain;
extern HMENU g_hmenuMainSave;

//Window submenu
extern HMENU g_hmenuWindowSub;

// WinDBG title text
extern TCHAR g_MainTitleText[MAX_MSG_TXT];

extern TCHAR g_ExeFilePath[];
extern TCHAR g_DumpFilePath[];
extern TCHAR g_SrcFilePath[];

enum
{
    COL_PLAIN,
    COL_PLAIN_TEXT,
    COL_CURRENT_LINE,
    COL_CURRENT_LINE_TEXT,
    COL_BP_CURRENT_LINE,
    COL_BP_CURRENT_LINE_TEXT,
    COL_ENABLED_BP,
    COL_ENABLED_BP_TEXT,
    COL_DISABLED_BP,
    COL_DISABLED_BP_TEXT,
    
    COL_COUNT
};

#define OUT_MASK_COL_BASE  0xff00
#define OUT_MASK_COL_COUNT 66

#define USER_OUT_MASK_COL 64

struct INDEXED_COLOR
{
    PSTR Name;
    COLORREF Color;
    COLORREF Default;
    HBRUSH Brush;
};

extern INDEXED_COLOR g_Colors[];
extern INDEXED_COLOR g_OutMaskColors[];

#define CUSTCOL_COUNT 16

extern COLORREF g_CustomColors[];

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);

void UpdateFrameTitle(void);
void SetTitleServerText(PCSTR Format, ...);
void SetTitleSessionText(PCSTR Format, ...);
void SetTitleExplicitText(PCSTR Text);
void UpdateTitleSessionText(void);

BOOL CreateUiInterfaces(BOOL Remote, LPTSTR CreateOptions);
void ReleaseUiInterfaces(void);
BOOL ParseCommandLine(BOOL FirstParse);

#define StartDebugging() \
    PostMessage(g_hwndFrame, WU_START_ENGINE, 0, 0)
void StopDebugging(BOOL UserRequest);
void TerminateApplication(BOOL Cancellable);

INDEXED_COLOR* GetIndexedColor(ULONG Index);
BOOL SetColor(ULONG Index, COLORREF Color);
BOOL GetOutMaskColors(ULONG Mask, COLORREF* Fg, COLORREF* Bg);

//----------------------------------------------------------------------------
//
// Macros.
//
//----------------------------------------------------------------------------

// Dbg have to be used for every assertion during Debugging time.
// If false Dbg Opens a fatal error message Box and Stops program

// Standard function to prompt an Assertion False
void ShowAssert(PTSTR condition, UINT line, PTSTR file);


// First, a sanity check
#ifdef Dbg
#undef Dbg
#endif


// Assert are assertions that will stay in final Release.
// If false Assert Opens a fatal error message Box and Stops program
#define RAssert(condition)  \
    {                               \
        if (!(condition))    \
        {                    \
            ShowAssert( _T(#condition), __LINE__, _T(__FILE__) );  \
        }                           \
    }


#ifdef DBG

#define Assert          RAssert
#define Dbg             RAssert

#else // !DBG

//#pragma warning(disable: 4553)      // disable warnings for pure expressions
//#pragma warning(disable: 4552)      // disable level 4 warnings
#define Assert(x)       ((void)0)
#define Dbg(condition)  condition

#endif

#endif // _WINDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\wrkspace.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    wrkspace.cpp

Abstract:

    This module contains the workspace implementation.

--*/

#include "precomp.hxx"
#pragma hdrstop

// #define DBG_WSP

#define WSP_ALIGN(Size) (((Size) + 7) & ~7)
#define WSP_GROW_BY 1024

#if DBG
#define SCORCH_ENTRY(Entry) \
    memset((Entry) + 1, 0xdb, (Entry)->FullSize - sizeof(*(Entry)))
#else
#define SCORCH_ENTRY(Entry)
#endif

ULONG g_WspSwitchKey;
TCHAR g_WspSwitchValue[MAX_PATH];
BOOL g_WspSwitchBufferAvailable = TRUE;

Workspace* g_Workspace;
BOOL g_ExplicitWorkspace;

char* g_WorkspaceKeyNames[] =
{
    "",
    "Kernel",
    "User",
    "Dump",
    "Remote",
    "Explicit",
};
char* g_WorkspaceDefaultName = "Default";

char* g_WorkspaceKeyDescriptions[] =
{
    "Base workspace",
    "Kernel mode workspaces",
    "User mode workspaces",
    "Dump file workspaces",
    "Remote client workspaces",
    "User-saved workspaces",
};

Workspace::Workspace(void)
{
    m_Flags = 0;
    
    m_Data = NULL;
    m_DataLen = 0;
    m_DataUsed = 0;

    m_Key = WSP_NAME_BASE;
    m_Value = NULL;
}

Workspace::~Workspace(void)
{
    free(m_Data);
    free(m_Value);
}
    
WSP_ENTRY*
Workspace::Get(WSP_TAG Tag)
{
    WSP_ENTRY* Entry = NULL;
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if (Entry->Tag == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

WSP_ENTRY*
Workspace::GetNext(WSP_ENTRY* Entry, WSP_TAG Tag, WSP_TAG TagMask)
{
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

WSP_ENTRY*
Workspace::GetString(WSP_TAG Tag, PSTR Str, ULONG MaxSize)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        if (Entry->DataSize > MaxSize)
        {
            return NULL;
        }

        strcpy(Str, WSP_ENTRY_DATA(PSTR, Entry));
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::GetAllocString(WSP_TAG Tag, PSTR* Str)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        *Str = (PSTR)malloc(Entry->DataSize);
        if (*Str == NULL)
        {
            return NULL;
        }

        strcpy(*Str, WSP_ENTRY_DATA(PSTR, Entry));
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::GetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size)
{
    WSP_ENTRY* Entry = Get(Tag);
    
    if (Entry != NULL)
    {
        if (Entry->DataSize != Size)
        {
            return NULL;
        }

        memcpy(Buf, WSP_ENTRY_DATA(PUCHAR, Entry), Size);
    }
    
    return Entry;
}

WSP_ENTRY*
Workspace::Set(WSP_TAG Tag, ULONG Size)
{
    WSP_ENTRY* Entry;
    ULONG FullSize;

    // Compute full rounded size.
    FullSize = sizeof(WSP_ENTRY) + WSP_ALIGN(Size);
    
    // Check and see if there's already an entry.
    Entry = Get(Tag);
    if (Entry != NULL)
    {
        // If it's already large enough use it and
        // pack in remaining data.
        if (Entry->FullSize >= FullSize)
        {
            ULONG Pack = Entry->FullSize - FullSize;
            if (Pack > 0)
            {
                PackData((PUCHAR)Entry + FullSize, Pack);
                Entry->FullSize = (USHORT)FullSize;
            }

            Entry->DataSize = (USHORT)Size;
            SCORCH_ENTRY(Entry);
            m_Flags |= WSPF_DIRTY_WRITE;
            return Entry;
        }

        // Entry is too small so remove it.
        PackData((PUCHAR)Entry, Entry->FullSize);
    }

    return Add(Tag, Size);
}

WSP_ENTRY*
Workspace::SetString(WSP_TAG Tag, PSTR Str)
{
    ULONG Size = strlen(Str) + 1;
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(WSP_ENTRY_DATA(PSTR, Entry), Str, Size);
    }

    return Entry;
}

WSP_ENTRY*
Workspace::SetStrings(WSP_TAG Tag, ULONG Count, PSTR* Strs)
{
    ULONG i;
    ULONG Size = 0;

    for (i = 0; i < Count; i++)
    {
        Size += strlen(Strs[i]) + 1;
    }
    // Put a double terminator at the very end.
    Size++;
    
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        PSTR Data = WSP_ENTRY_DATA(PSTR, Entry);
        
        for (i = 0; i < Count; i++)
        {
            Size = strlen(Strs[i]) + 1;
            memcpy(Data, Strs[i], Size);
            Data += Size;
        }
        *Data = 0;
    }

    return Entry;
}

WSP_ENTRY*
Workspace::SetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size)
{
    WSP_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(WSP_ENTRY_DATA(PUCHAR, Entry), Buf, Size);
    }

    return Entry;
}

WSP_ENTRY*
Workspace::Add(WSP_TAG Tag, ULONG Size)
{
    // Compute full rounded size.
    ULONG FullSize = sizeof(WSP_ENTRY) + WSP_ALIGN(Size);
    
    WSP_ENTRY* Entry = AllocateEntry(FullSize);
    if (Entry != NULL)
    {
        Entry->Tag = Tag;
        Entry->FullSize = (USHORT)FullSize;
        Entry->DataSize = (USHORT)Size;
        SCORCH_ENTRY(Entry);
        m_Flags |= WSPF_DIRTY_WRITE;
    }

    return Entry;
}

ULONG
Workspace::Delete(WSP_TAG Tag, WSP_TAG TagMask)
{
    ULONG Deleted = 0;
    WSP_ENTRY* Entry = NextEntry(NULL);

    while (Entry != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            PackData((PUCHAR)Entry, Entry->FullSize);
            Deleted++;
            m_Flags |= WSPF_DIRTY_WRITE;

            // Check and see if we packed away the last entry.
            if (!ValidEntry(Entry))
            {
                break;
            }
        }
        else
        {
            Entry = NextEntry(Entry);
        }
    }
    
    return Deleted;
}

void
Workspace::Empty(void)
{
    // Reset used to just the header.
    m_DataUsed = sizeof(WSP_HEADER);
    
    // Nothing is dirty now except the write of emptiness.
    m_Flags = (m_Flags & ~WSPF_DIRTY_ALL) | WSPF_DIRTY_WRITE;
}

HRESULT
Workspace::Create(ULONG Key, PTSTR Value,
                  Workspace** NewWsp)
{
    Workspace* Wsp = new Workspace;
    if (Wsp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    Wsp->m_Key = Key;
    if (Value != NULL)
    {
        Wsp->m_Value = _tcsdup(Value);
        if (Wsp->m_Value == NULL)
        {
            delete Wsp;
            return E_OUTOFMEMORY;
        }
    }

    WSP_ENTRY* Entry;
    WSP_HEADER* Header;

    // Allocate intial space for the header and eight
    // small entries.  The workspace grows by large amounts
    // so this will immediately allocate a reasonable chunk.
    Entry = Wsp->AllocateEntry(sizeof(WSP_HEADER) +
                               8 * (sizeof(WSP_ENTRY) + 2 * sizeof(ULONG64)));
    if (Entry == NULL)
    {
        delete Wsp;
        return E_OUTOFMEMORY;
    }
    
    Header = (WSP_HEADER*)Entry;
    Header->Signature = WSP_SIGNATURE;
    Header->Version = WSP_VERSION;
    
    // Reset used to just the header.
    Wsp->m_DataUsed = sizeof(*Header);

    // Start out dirty so the workspace will be written
    // out and therefore can be opened later.
    Wsp->m_Flags |= WSPF_DIRTY_WRITE;

    *NewWsp = Wsp;
    return S_OK;
}

HRESULT
Workspace::Read(ULONG Key, PTSTR Value,
                Workspace** NewWsp)
{
    // Make sure basic structures preserve alignment.
    C_ASSERT(sizeof(WSP_HEADER) == WSP_ALIGN(sizeof(WSP_HEADER)));
    C_ASSERT(sizeof(WSP_ENTRY) == WSP_ALIGN(sizeof(WSP_ENTRY)));
    C_ASSERT(sizeof(WSP_COMMONWIN_HEADER) ==
             WSP_ALIGN(sizeof(WSP_COMMONWIN_HEADER)));

    HRESULT Status;
    
    Workspace* Wsp = new Workspace;
    if (Wsp == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Fail;
    }

    Wsp->m_Key = Key;
    if (Value != NULL)
    {
        Wsp->m_Value = _tcsdup(Value);
        if (Wsp->m_Value == NULL)
        {
            delete Wsp;
            return E_OUTOFMEMORY;
        }
    }

    HKEY RegKey;
    LONG RegStatus;
    BOOL InPrimary;

    //
    // First check and see if the value exists under the
    // primary key.  If not, check the secondary key.
    //
    
    RegKey = OpenKey(TRUE, Key, FALSE);
    if (RegKey)
    {
        RegStatus = RegQueryValueEx(RegKey, Value, NULL, NULL, NULL, NULL);
        if (RegStatus != ERROR_SUCCESS && RegStatus != ERROR_MORE_DATA)
        {
            RegCloseKey(RegKey);
            RegKey = NULL;
        }
    }
    if (RegKey == NULL)
    {
        RegKey = OpenKey(FALSE, Key, FALSE);
        if (RegKey == NULL)
        {
            Status = E_NOINTERFACE;
            goto EH_Wsp;
        }
        
        InPrimary = FALSE;
    }
    else
    {
        InPrimary = TRUE;
    }
    
    DWORD Type;
    DWORD Size;

    Size = 0;
    RegStatus = RegQueryValueEx(RegKey, Value, NULL, &Type, NULL, &Size);
    if (RegStatus != ERROR_SUCCESS && RegStatus != ERROR_MORE_DATA)
    {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
        {
            Status = E_NOINTERFACE;
        }
        else
        {
            Status = HRESULT_FROM_WIN32(RegStatus);
        }
        goto EH_Key;
    }
    if (Type != REG_BINARY ||
        WSP_ALIGN(Size) != Size)
    {
        Status = E_INVALIDARG;
        goto EH_Key;
    }

    WSP_ENTRY* Entry;
    WSP_HEADER* Header;

    Entry = Wsp->AllocateEntry(Size);
    if (Entry == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Key;
    }
    Header = (WSP_HEADER*)Entry;

    if (RegQueryValueEx(RegKey, Value, NULL, &Type, (LPBYTE)Header, &Size) !=
        ERROR_SUCCESS ||
        Header->Signature != WSP_SIGNATURE ||
        Header->Version != WSP_VERSION)
    {
        Status = E_INVALIDARG;
        goto EH_Key;
    }

    RegCloseKey(RegKey);

    //
    // If the workspace was read from the secondary key
    // migrate it to the primary and remove the secondary
    // entry.
    //

    if (!InPrimary)
    {
        if (Wsp->WriteReg() == S_OK)
        {
            Wsp->DeleteReg(FALSE);
        }
    }
    
    *NewWsp = Wsp;
    return S_OK;
    
 EH_Key:
    RegCloseKey(RegKey);
 EH_Wsp:
    delete Wsp;
 EH_Fail:
    return Status;
}

HRESULT
Workspace::ChangeName(ULONG Key, PTSTR Value, BOOL Force)
{
    if (!Force)
    {
        HKEY RegKey;

        //
        // Check and see if a workspace entry already
        // exists under the given name.  We only need
        // to check the primary key as we're only concerned
        // with overwriting and writing always occurs
        // to the primary key.
        //
    
        RegKey = OpenKey(TRUE, Key, FALSE);
        if (RegKey != NULL)
        {
            LONG RegStatus;

            RegStatus = RegQueryValueEx(RegKey, Value, NULL, NULL,
                                        NULL, NULL);

            RegCloseKey(RegKey);
            
            if (RegStatus == ERROR_SUCCESS || RegStatus == ERROR_MORE_DATA)
            {
                return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            }
        }
    }

    //
    // Swap the workspace name.
    //

    PTSTR NewValue;
    
    if (Value != NULL)
    {
        NewValue = _tcsdup(Value);
        if (NewValue == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        NewValue = NULL;
    }

    delete m_Value;
    m_Key = Key;
    m_Value = NewValue;
    // Need to write data out to the new location.
    m_Flags |= WSPF_DIRTY_WRITE;

    return S_OK;
}

void
Workspace::UpdateBreakpointInformation(void)
{
    HRESULT Status;
    
    Status = g_BpCmdsBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        // Clear old information.
        Delete(WSP_GLOBAL_BREAKPOINTS, WSP_TAG_MASK);

        // Only save an entry if there are breakpoints.
        // Minimum output is a newline and terminator so
        // don't count those.
        if (g_BpCmdsBuffer->GetDataLen() > 2)
        {
            PSTR Cmds = (PSTR)g_BpCmdsBuffer->GetDataBuffer();
            SetString(WSP_GLOBAL_BREAKPOINTS, Cmds);
        }
        
        UnlockStateBuffer(g_BpCmdsBuffer);
    }
}

void
Workspace::UpdateWindowInformation(void)
{
    // Clear old information.
    Delete(DEF_WSP_TAG(WSP_GROUP_WINDOW, 0), WSP_GROUP_MASK);

    //
    // Record the frame window state.
    //

    WINDOWPLACEMENT Place;

    Place.length = sizeof(Place);
    GetWindowPlacement(g_hwndFrame, &Place);
    SetBuffer(WSP_WINDOW_FRAME_PLACEMENT, &Place, sizeof(Place));
    
    //
    // Persist windows from the bottom of the Z order up
    // so that when they're recreated in the same order
    // the Z order is also recreated.
    //
    
    HWND Win = MDIGetActive(g_hwndMDIClient, NULL);
    if (Win == NULL ||
        (Win = GetWindow(Win, GW_HWNDLAST)) == NULL)
    {
        // No windows.
        return;
    }

    while (Win != NULL)
    {
        PCOMMONWIN_DATA WinData = GetCommonWinData(Win);
        if (WinData != NULL)
        {
            WSP_ENTRY* Entry;
            ULONG Size;

            Size = WinData->GetWorkspaceSize();
            Entry = Add(WSP_WINDOW_COMMONWIN_1,
                        Size + sizeof(WSP_COMMONWIN_HEADER));
            if (Entry != NULL)
            {
                WSP_COMMONWIN_HEADER* Hdr =
                    WSP_ENTRY_DATA(WSP_COMMONWIN_HEADER*, Entry);
                Hdr->Type = WinData->m_enumType;
                Hdr->Reserved = 0;

                if (Size > 0)
                {
                    WinData->SetWorkspace((PUCHAR)(Hdr + 1));
                }
            }
        }

        Win = GetWindow(Win, GW_HWNDPREV);
    }
}

void
Workspace::UpdateLogFileInformation(void)
{
    HRESULT Status;
    char LogFile[MAX_PATH];
    BOOL Append;
    ULONG FileLen;

    Status = g_pUiControl->GetLogFile(LogFile, sizeof(LogFile), NULL,
                                      &Append);
    if (Status != S_OK && Status != E_NOINTERFACE)
    {
        return;
    }

    // Clear old information.
    Delete(WSP_GLOBAL_LOG_FILE, WSP_TAG_MASK);

    if (Status == E_NOINTERFACE)
    {
        // No log is open.
        return;
    }
    
    FileLen = strlen(LogFile) + 1;
    
    WSP_ENTRY* Entry = Set(WSP_GLOBAL_LOG_FILE, sizeof(BOOL) + FileLen);
    if (Entry != NULL)
    {
        PSTR Data = WSP_ENTRY_DATA(PSTR, Entry);
        *(PBOOL)Data = Append;
        strcpy(Data + sizeof(Append), LogFile);
    }
}

void
Workspace::UpdatePathInformation(void)
{
    HRESULT Status;
    char Path[MAX_ENGINE_PATH];

    Status = g_pUiSymbols->GetSymbolPath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_SYMBOL_PATH, Path);
    }
    Status = g_pUiSymbols->GetImagePath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_IMAGE_PATH, Path);
    }
    Status = g_pUiSymbols->GetSourcePath(Path, sizeof(Path), NULL);
    if (Status == S_OK)
    {
        SetString(WSP_GLOBAL_SOURCE_PATH, Path);
    }

    // Local source path is only set explicitly.
}

void
Workspace::UpdateFilterInformation(void)
{
    HRESULT Status;
    
    Status = g_FilterBuffer->UiLockForRead();
    if (Status == S_OK)
    {
        // Clear old information.
        Delete(WSP_GLOBAL_FILTERS, WSP_TAG_MASK);

        // Only save an entry if there are changes.
        // Minimum output is a newline and terminator so
        // don't count those.
        if (g_FilterWspCmdsOffset < g_FilterBuffer->GetDataLen() - 2)
        {
            PSTR Cmds = (PSTR)g_FilterBuffer->GetDataBuffer() +
                g_FilterWspCmdsOffset;
            SetString(WSP_GLOBAL_FILTERS, Cmds);
        }
        
        UnlockStateBuffer(g_FilterBuffer);
    }
}

void
Workspace::UpdateMruListInformation(void)
{
    ULONG Size;
    WSP_ENTRY* Entry;
    
    // Clear old information.
    Delete(WSP_GLOBAL_MRU_LIST, WSP_TAG_MASK);

    Size = GetMruSize();
    Entry = Set(WSP_GLOBAL_MRU_LIST, Size);
    if (Entry != NULL)
    {
        WriteMru(WSP_ENTRY_DATA(PUCHAR, Entry));
    }
}

HRESULT
Workspace::WriteReg(void)
{
    // Writing always occurs to the primary key.
    HKEY RegKey = OpenKey(TRUE, m_Key, TRUE);
    if (RegKey == NULL)
    {
        return E_FAIL;
    }
    
    LONG Status = RegSetValueEx(RegKey, m_Value, 0, REG_BINARY,
                                m_Data, m_DataUsed);

    RegCloseKey(RegKey);

    if (Status != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(Status);
    }
    else
    {
        m_Flags &= ~WSPF_DIRTY_ALL;
        return S_OK;
    }
}

void
Workspace::DeleteReg(BOOL Primary)
{
    DeleteRegKey(Primary, m_Key, m_Value);

    // We don't want to leave any dirty bits
    // on because the workspace would just be written
    // out again at the next flush.
    m_Flags &= ~WSPF_DIRTY_ALL;
}

void
Workspace::DeleteRegKey(BOOL Primary, ULONG Key, PTSTR Value)
{
    HKEY RegKey = OpenKey(Primary, Key, FALSE);
    if (RegKey != NULL)
    {
        RegDeleteValue(RegKey, Value);
        RegCloseKey(RegKey);
    }
}

HRESULT
Workspace::Flush(BOOL ForceSave, BOOL Cancellable)
{
    if (getenv("WINDBG_NO_WORKSPACE_WINDOWS") != NULL)
    {
        // Window layout saving is suppressed so don't
        // consider them dirty.
        m_Flags &= ~WSPF_DIRTY_WINDOWS;
    }
    
    if ((m_Flags & WSPF_DIRTY_ALL) == 0 ||
        (g_QuietMode && !ForceSave))
    {
        return S_OK;
    }

#ifdef DBG_WSP
    DebugPrint("Workspace dirty flags %X\n", m_Flags & WSPF_DIRTY_ALL);
#endif
    
    WORD Str;
    PTSTR Arg;

    if (!strcmp(m_Value, g_WorkspaceDefaultName))
    {
        Arg = g_WorkspaceKeyNames[m_Key];
        if (m_Key == WSP_NAME_BASE)
        {
            Str = STR_Save_Base_Workspace;
        }
        else
        {
            Str = STR_Save_Default_Workspace;
        }
    }
    else
    {
        Str = STR_Save_Specific_Workspace;
        Arg = m_Value;
    }

    int Answer;

    if (ForceSave)
    {
        Answer = IDOK;
    }
    else
    {
        Answer = QuestionBox(Str, Cancellable ? MB_YESNOCANCEL : MB_YESNO,
                             Arg);
    }
    
    if (Answer == IDNO)
    {
        return S_OK;
    }
    else if (Answer == IDCANCEL)
    {
        Assert(Cancellable);
        return S_FALSE;
    }

    if (m_Flags & WSPF_DIRTY_BREAKPOINTS)
    {
        UpdateBreakpointInformation();
    }
    if (m_Flags & WSPF_DIRTY_WINDOWS)
    {
        UpdateWindowInformation();
    }
    if (m_Flags & WSPF_DIRTY_LOG_FILE)
    {
        UpdateLogFileInformation();
    }
    if (m_Flags & WSPF_DIRTY_PATHS)
    {
        UpdatePathInformation();
    }
    if (m_Flags & WSPF_DIRTY_FILTERS)
    {
        UpdateFilterInformation();
    }
    if (m_Flags & WSPF_DIRTY_MRU_LIST)
    {
        UpdateMruListInformation();
    }
    
    return WriteReg();
}

WSP_ENTRY*
Workspace::AllocateEntry(ULONG FullSize)
{
    // Sizes must fit in USHORTs.  This shouldn't be
    // a big problem since workspaces shouldn't have
    // huge data items in them.
    if (FullSize > 0xffff)
    {
        return NULL;
    }
    
    if (m_DataUsed + FullSize > m_DataLen)
    {
        ULONG NewLen = m_DataLen;
        do
        {
            NewLen += WSP_GROW_BY;
        }
        while (m_DataUsed + FullSize > NewLen);
    
        PUCHAR NewData = (PUCHAR)realloc(m_Data, NewLen);
        if (NewData == NULL)
        {
            return NULL;
        }

        m_Data = NewData;
        m_DataLen = NewLen;
    }

    WSP_ENTRY* Entry = (WSP_ENTRY*)(m_Data + m_DataUsed);
    m_DataUsed += FullSize;
    return Entry;
}

void
Workspace::GetKeyName(ULONG Key, PSTR KeyName)
{
    _tcscpy(KeyName, WSP_REG_KEY);
    if (Key > WSP_NAME_BASE)
    {
        _tcscat(KeyName, "\\");
        _tcscat(KeyName, g_WorkspaceKeyNames[Key]);
    }
}
    
HKEY
Workspace::OpenKey(BOOL Primary, ULONG Key, BOOL Create)
{
    TCHAR KeyName[MAX_PATH];
    HKEY RegKey;
    HKEY Base = Primary ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    GetKeyName(Key, KeyName);
    if (Create)
    {
        if (RegCreateKeyEx(Base, KeyName, 0, NULL, 0,
                           KEY_ALL_ACCESS, NULL, &RegKey,
                           NULL) == ERROR_SUCCESS)
        {
            return RegKey;
        }
    }
    else if (RegOpenKeyEx(Base, KeyName, 0, KEY_ALL_ACCESS,
                          &RegKey) == ERROR_SUCCESS)
    {
        return RegKey;
    }

    return NULL;
}

int
Workspace::Apply(ULONG Flags)
{
    WSP_ENTRY* Entry;
    ULONG Count;
    PUCHAR Data;
    BOOL UpdateColors = FALSE;
    int SessionStarts;
    ULONG MemWins = 0;

#ifdef DBG_WSP
    DebugPrint("Applying workspace %s%s%s with:\n",
               m_Key == NULL ? "" : m_Key,
               m_Key == NULL ? "" : "\\",
               m_Value);
#endif

    //
    // Scan for explicit session start entries first.
    // If any are present and a session is active
    // fail the apply before anything actually happens.
    //

    if ((Flags & (WSP_APPLY_AGAIN |
                  WSP_APPLY_EXPLICIT)) == WSP_APPLY_EXPLICIT &&
        g_EngineThreadId)
    {
        Entry = NULL;
        while ((Entry = NextEntry(Entry)) != NULL)
        {
            switch(Entry->Tag)
            {
            case WSP_GLOBAL_EXE_COMMAND_LINE:
            case WSP_GLOBAL_DUMP_FILE_NAME:
            case WSP_GLOBAL_ATTACH_KERNEL_FLAGS:
                return -1;
            }
        }
    }
    
    SessionStarts = 0;
    Entry = NULL;
    while ((Entry = NextEntry(Entry)) != NULL)
    {
#ifdef DBG_WSP
        DebugPrint("  %04X: Tag: %08X Size %X:%X\n",
                   (PUCHAR)Entry - m_Data, Entry->Tag,
                   Entry->DataSize, Entry->FullSize);
#endif

        // If this is a reapply only a subset of the
        // workspace is applied to prevent duplication
        // and problems.
        if ((Flags & WSP_APPLY_AGAIN) &&
            Entry->Tag != WSP_GLOBAL_BREAKPOINTS &&
            Entry->Tag != WSP_GLOBAL_REGISTER_MAP)
        {
            continue;
        }
        
        if (WSP_TAG_GROUP(Entry->Tag) == WSP_GROUP_COLORS)
        {
            if (SetColor(WSP_TAG_ITEM(Entry->Tag),
                         *WSP_ENTRY_DATA(COLORREF*, Entry)))
            {
                UpdateColors = TRUE;
            }
            continue;
        }
        
        switch(Entry->Tag)
        {
        case WSP_GLOBAL_SYMBOL_PATH:
            g_pUiSymbols->SetSymbolPath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_IMAGE_PATH:
            g_pUiSymbols->SetImagePath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_SOURCE_PATH:
            g_pUiSymbols->SetSourcePath(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_WINDOW_OPTIONS:
            g_WinOptions = *WSP_ENTRY_DATA(PULONG, Entry);
            if (g_WinOptions & WOPT_AUTO_ARRANGE)
            {
                Arrange();
            }
            break;
        case WSP_GLOBAL_REGISTER_MAP:
            Count = Entry->DataSize / sizeof(*g_RegisterMap);
            g_RegisterMap = new USHORT[Count];
            if (g_RegisterMap != NULL)
            {
                memcpy(g_RegisterMap, WSP_ENTRY_DATA(PUSHORT, Entry),
                       Count * sizeof(*g_RegisterMap));
                g_RegisterMapEntries = Count;
            }
            break;
        case WSP_GLOBAL_BREAKPOINTS:
            Assert(Entry->DataSize > 1);
            AddStringMultiCommand(UIC_INVISIBLE_EXECUTE,
                                  WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_LOG_FILE:
            Data = WSP_ENTRY_DATA(PUCHAR, Entry);
            g_pUiControl->OpenLogFile((PSTR)Data + sizeof(BOOL), *(PBOOL)Data);
            break;
        case WSP_GLOBAL_LOCAL_SOURCE_PATH:
            if (g_RemoteClient)
            {
                g_pUiLocSymbols->SetSourcePath(WSP_ENTRY_DATA(PSTR, Entry));
            }
            break;
        case WSP_GLOBAL_FILTERS:
            Assert(Entry->DataSize > 1);
            AddStringMultiCommand(UIC_INVISIBLE_EXECUTE,
                                  WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_FIXED_LOGFONT:
            g_Fonts[FONT_FIXED].LogFont = *WSP_ENTRY_DATA(LPLOGFONT, Entry);
            CreateIndexedFont(FONT_FIXED, TRUE);
            break;
        case WSP_GLOBAL_TAB_WIDTH:
            SetTabWidth(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_MRU_LIST:
            Data = WSP_ENTRY_DATA(PUCHAR, Entry);
            ReadMru(Data, Data + Entry->DataSize);
            break;
        case WSP_GLOBAL_REPEAT_COMMANDS:
            if (*WSP_ENTRY_DATA(PULONG, Entry))
            {
                g_pUiControl->
                    RemoveEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
            }
            else
            {
                g_pUiControl->
                    AddEngineOptions(DEBUG_ENGOPT_NO_EXECUTE_REPEAT);
            }
            break;
        case WSP_GLOBAL_COM_SETTINGS:
            if (Entry->DataSize <= sizeof(g_ComSettings))
            {
                memcpy(g_ComSettings, WSP_ENTRY_DATA(PSTR, Entry),
                       Entry->DataSize);
                PrintAllocString(&g_KernelConnectOptions, 256,
                                 "com:port=%s,baud=%s", g_ComSettings,
                                 g_ComSettings + strlen(g_ComSettings) + 1);
            }
            break;
        case WSP_GLOBAL_1394_SETTINGS:
            if (Entry->DataSize <= sizeof(g_1394Settings))
            {
                memcpy(g_1394Settings, WSP_ENTRY_DATA(PSTR, Entry),
                       Entry->DataSize);
                PrintAllocString(&g_KernelConnectOptions, 256,
                                 "1394:channel=%s", g_1394Settings);
            }
            break;
        case WSP_GLOBAL_DISASM_ACTIVATE_SOURCE:
            g_DisasmActivateSource = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_VIEW_TOOL_BAR:
            CheckMenuItem(g_hmenuMain, IDM_VIEW_TOOLBAR,
                          *WSP_ENTRY_DATA(PULONG, Entry) ?
                          MF_CHECKED : MF_UNCHECKED);
            Show_Toolbar(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_VIEW_STATUS_BAR:
            CheckMenuItem(g_hmenuMain, IDM_VIEW_STATUS,
                          *WSP_ENTRY_DATA(PULONG, Entry) ?
                          MF_CHECKED : MF_UNCHECKED);
            Show_StatusBar(*WSP_ENTRY_DATA(PULONG, Entry));
            break;
        case WSP_GLOBAL_AUTO_CMD_SCROLL:
            g_AutoCmdScroll = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_SRC_FILE_PATH:
            strcpy(g_SrcFilePath, WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_EXE_COMMAND_LINE:
            if ((Flags & WSP_APPLY_EXPLICIT) &&
                DupAllocString(&g_DebugCommandLine,
                               WSP_ENTRY_DATA(PSTR, Entry)))
            {
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_EXE_CREATE_FLAGS:
            g_DebugCreateFlags = *WSP_ENTRY_DATA(PULONG, Entry);
            break;
        case WSP_GLOBAL_DUMP_FILE_NAME:
            if ((Flags & WSP_APPLY_EXPLICIT) &&
                DupAllocString(&g_DumpFile,
                               WSP_ENTRY_DATA(PSTR, Entry)))
            {
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_ATTACH_KERNEL_FLAGS:
            if ((Flags & WSP_APPLY_EXPLICIT))
            {
                g_AttachKernelFlags = *WSP_ENTRY_DATA(PULONG, Entry);
                SessionStarts++;
            }
            break;
        case WSP_GLOBAL_TYPE_OPTIONS:
            {
                g_TypeOptions = *WSP_ENTRY_DATA(PULONG, Entry);
		if (g_pUiSymbols2 != NULL) 
		{
		    g_pUiSymbols2->SetTypeOptions(g_TypeOptions);
		}
            }
            break;
        case WSP_GLOBAL_DUMP_FILE_PATH:
            strcpy(g_DumpFilePath, WSP_ENTRY_DATA(PSTR, Entry));
            break;
        case WSP_GLOBAL_EXE_FILE_PATH:
            strcpy(g_ExeFilePath, WSP_ENTRY_DATA(PSTR, Entry));
            break;
            
        case WSP_WINDOW_COMMONWIN_1:
            WSP_COMMONWIN_HEADER* Hdr;
            HWND Win;
            PCOMMONWIN_DATA WinData;

            Hdr = WSP_ENTRY_DATA(WSP_COMMONWIN_HEADER*, Entry);
            Win = New_OpenDebugWindow(Hdr->Type, TRUE, MemWins);
            if (Win != NULL &&
                (WinData = GetCommonWinData(Win)) != NULL &&
                Entry->DataSize > sizeof(WSP_COMMONWIN_HEADER))
            {
                Data = (PUCHAR)(Hdr + 1);
                WinData->m_InAutoOp++;
                WinData->ApplyWorkspace1(Data, Data +
                                         (Entry->DataSize -
                                          sizeof(WSP_COMMONWIN_HEADER)));
                WinData->m_InAutoOp--;
            }

            // A user can have as many open memory windows as
            // they like, which makes things a little tricky
            // for workspaces as applying stacked workspaces
            // could result in memory windows multiplying out
            // of control if the same set of memory windows
            // is saved in each workspace level.  To avoid
            // this and to function more like the other windows
            // we reuse memory windows from any that are
            // already in existence.
            if (Hdr->Type == MEM_WINDOW)
            {
                MemWins++;
            }
            break;
        case WSP_WINDOW_FRAME_PLACEMENT:
            LPWINDOWPLACEMENT Place;

            Place = WSP_ENTRY_DATA(LPWINDOWPLACEMENT, Entry);
            SetWindowPlacement(g_hwndFrame, Place);
            break;
        case WSP_WINDOW_FRAME_TITLE:
            SetTitleExplicitText(WSP_ENTRY_DATA(PSTR, Entry));
            break;
        }
    }

    if (UpdateColors)
    {
        UpdateAllColors();
    }

    return SessionStarts;
}

HRESULT
UiSwitchWorkspace(ULONG Key, PTSTR Value, BOOL Create,
                  ULONG Flags, int* SessionStarts)
{
    if (getenv("WINDBG_NO_WORKSPACE") != NULL)
    {
        return E_NOTIMPL;
    }
    
    HRESULT Status;
    Workspace* OldWsp;
    Workspace* NewWsp;
    int Starts = 0;

    Status = Workspace::Read(Key, Value, &NewWsp);
    if (Status != S_OK)
    {
        if (Status == E_NOINTERFACE && Create)
        {
            // Workspace does not exist so create a new one.
            Status = Workspace::Create(Key, Value, &NewWsp);
        }
        
        if (Status != S_OK)
        {
            return Status;
        }
    }

    // We have a new workspace ready to go so flush the old one.
    OldWsp = g_Workspace;
    if (OldWsp != NULL)
    {
        OldWsp->Flush(FALSE, FALSE);
    }

    // Apply the new workspace with no global workspace to
    // avoid writing changes into the workspace as we apply it.
    g_Workspace = NULL;
    if (NewWsp != NULL)
    {
        Starts = NewWsp->Apply(Flags);
        
        // Clear any window messages queued during the workspace
        // application so that they're processed with no
        // active workspace.
        ProcessPendingMessages();
    }

    if (SessionStarts != NULL)
    {
        *SessionStarts = Starts;
    }

    if (Starts < 0)
    {
        // Apply failed so put the old workspace back.
        g_Workspace = OldWsp;
        return E_FAIL;
    }
    else
    {
        // Apply succeeded to replace the old workspace.
        g_Workspace = NewWsp;
        delete OldWsp;
        return S_OK;
    }
}

HRESULT
UiDelayedSwitchWorkspace(void)
{
    Assert(!g_WspSwitchBufferAvailable);
    
    HRESULT Status = UiSwitchWorkspace(g_WspSwitchKey, g_WspSwitchValue, TRUE,
                                       WSP_APPLY_DEFAULT, NULL);

    // Mark the delayed switch buffer as available and
    // wait for acknowledgement.
    g_WspSwitchBufferAvailable = TRUE;
    while (g_WspSwitchValue[0])
    {
        Sleep(50);
    }        

    return Status;
}

void
EngSwitchWorkspace(ULONG Key, PTSTR Value)
{
    // If the user explicitly selected a workspace
    // don't override it due to engine activity.
    if (g_ExplicitWorkspace ||
        g_Exit)
    {
        return;
    }
    
    // We can't switch workspaces on the engine thread
    // because of the UI work involved.  Send the
    // switch over to the UI thread and wait for
    // it to be processed.

    Assert(g_WspSwitchBufferAvailable);
    g_WspSwitchBufferAvailable = FALSE;

    g_WspSwitchKey = Key;
    _tcscpy(g_WspSwitchValue, Value);
    PostMessage(g_hwndFrame, WU_SWITCH_WORKSPACE, 0, 0);

    if (g_pDbgClient != NULL)
    {
        // Temporarily disable event callbacks to keep
        // activity at a minimum while we're in this halfway state.
        g_pDbgClient->SetEventCallbacks(NULL);
    
        while (!g_WspSwitchBufferAvailable)
        {
            if (FAILED(g_pDbgClient->DispatchCallbacks(50)))
            {
                Sleep(50);
            }
        }

        g_pDbgClient->SetEventCallbacks(&g_EventCb);
    }
    else
    {
        while (!g_WspSwitchBufferAvailable)
        {
            Sleep(100);
        }
    }

    // We know that at this point the new workspace cannot be dirty
    // so just clear the dirty flags.

    if (g_Workspace)
    {
        g_Workspace->ClearDirty();
    }

    // Let the UI thread continue.
    g_WspSwitchKey = WSP_NAME_BASE;
    g_WspSwitchValue[0] = 0;
    Sleep(50);

    //
    // Warn the user is the workspace was not be created properly.
    //

    if (!g_Workspace)
    {
        InformationBox(ERR_NULL_Workspace, NULL);
        return;
    }
}

PSTR g_WspGlobalNames[] =
{
    "Symbol path", "Image path", "Source path", "Window menu checks",
    "Register customization", "Breakpoints", "Log file settings",
    "Local source path", "Event filter settings", "Fixed-width font",
    "Tab width", "MRU list", "Repeat commands setting", "COM port settings",
    "1394 settings", "Activate source windows in disassembly mode",
    "Show tool bar", "Show status bar", "Automatically scroll command window",
    "Source open dialog path", "Executable command line",
    "Executable create flags", "Dump file name", "Kernel attach flags",
    "Type options", "Dump open dialog path", "Executable open dialog path",
};

PSTR g_WspWindowNames[] =
{
    "Child window settings", "WinDBG window settings", "WinDBG window title",
};

PSTR
GetWspTagName(WSP_TAG Tag)
{
    ULONG Item = WSP_TAG_ITEM(Tag);
    static char Buffer[128];
    
    switch(WSP_TAG_GROUP(Tag))
    {
    case WSP_GROUP_GLOBAL:
        if (Item < WSP_GLOBAL_COUNT)
        {
            return g_WspGlobalNames[Item];
        }
        break;
    case WSP_GROUP_WINDOW:
        if (Item < WSP_WINDOW_COUNT)
        {
            return g_WspWindowNames[Item];
        }
        break;
    case WSP_GROUP_COLORS:
        INDEXED_COLOR* IdxCol = GetIndexedColor(Item);
        if (IdxCol != NULL)
        {
            sprintf(Buffer, "%s color", IdxCol->Name);
            return Buffer;
        }
        break;
    }

    return "Unknown tag";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\windbg\wrkspace.h ===
//----------------------------------------------------------------------------
//
// Workspace support.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __WRKSPACE_H__
#define __WRKSPACE_H__

//----------------------------------------------------------------------------
//
// A workspace tag is a two-deep tag hierarchy.  The group portion
// of the tag allows related items to be collected into a single group.
//
//----------------------------------------------------------------------------

typedef ULONG WSP_TAG;

// Sixteen bits for the group.
#define WSP_GROUP_MASK  0xffff0000
#define WSP_GROUP_SHIFT 16
#define WSP_GROUP_BITS  16
// Sixteen bits for the item.
#define WSP_ITEM_MASK   0x0000ffff
#define WSP_ITEM_SHIFT  0
#define WSP_ITEM_BITS   16

#define WSP_TAG_MASK (WSP_GROUP_MASK | WSP_ITEM_MASK)

#define DEF_WSP_GROUP_TAG(Tag, Group) \
    ((Group) << WSP_GROUP_SHIFT)
#define ADD_WSP_ITEM_TAG(Tag, Item) \
    ((Tag) | (Item))
    
#define DEF_WSP_TAG(Group, Item) \
    (((Group) << WSP_GROUP_SHIFT) | (Item))

#define WSP_TAG_GROUP(Tag) \
    (((Tag) & WSP_GROUP_MASK) >> WSP_GROUP_SHIFT)

#define WSP_TAG_ITEM(Tag) \
    (((Tag) & WSP_ITEM_MASK) >> WSP_ITEM_SHIFT)

// Groups.
enum
{
    WSP_GROUP_GLOBAL,
    WSP_GROUP_WINDOW,
    WSP_GROUP_COLORS,
};

// Global group items.
enum
{
    WSP_ITEM_SYMBOL_PATH,
    WSP_ITEM_IMAGE_PATH,
    WSP_ITEM_SOURCE_PATH,
    WSP_ITEM_WINDOW_OPTIONS,
    WSP_ITEM_REGISTER_MAP,
    WSP_ITEM_BREAKPOINTS,
    WSP_ITEM_LOG_FILE,
    WSP_ITEM_LOCAL_SOURCE_PATH,
    WSP_ITEM_FILTERS,
    WSP_ITEM_FIXED_LOGFONT,
    WSP_ITEM_TAB_WIDTH,
    WSP_ITEM_MRU_LIST,
    WSP_ITEM_REPEAT_COMMANDS,
    WSP_ITEM_COM_SETTINGS,
    WSP_ITEM_1394_SETTINGS,
    WSP_ITEM_DISASM_ACTIVATE_SOURCE,
    WSP_ITEM_VIEW_TOOL_BAR,
    WSP_ITEM_VIEW_STATUS_BAR,
    WSP_ITEM_AUTO_CMD_SCROLL,
    WSP_ITEM_SRC_FILE_PATH,
    WSP_ITEM_EXE_COMMAND_LINE,
    WSP_ITEM_EXE_CREATE_FLAGS,
    WSP_ITEM_DUMP_FILE_NAME,
    WSP_ITEM_ATTACH_KERNEL_FLAGS,
    WSP_ITEM_TYPE_OPTIONS,
    WSP_ITEM_DUMP_FILE_PATH,
    WSP_ITEM_EXE_FILE_PATH,
    WSP_GLOBAL_COUNT
};

// Window group items.
// The commonwin items exist largely to allow versioning of the window
// information blob.  The actual content is determined
// by the implementation of COMMONWIN_DATA::SetWorkspace.
enum
{
    WSP_ITEM_COMMONWIN_1,
    WSP_ITEM_FRAME_PLACEMENT,
    WSP_ITEM_FRAME_TITLE,
    WSP_WINDOW_COUNT
};

// Color group items use the color index as the item value.

//
// Specific tags.
//

#define WSP_GLOBAL_SYMBOL_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SYMBOL_PATH)
#define WSP_GLOBAL_IMAGE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_IMAGE_PATH)
#define WSP_GLOBAL_SOURCE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SOURCE_PATH)
#define WSP_GLOBAL_WINDOW_OPTIONS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_WINDOW_OPTIONS)
#define WSP_GLOBAL_REGISTER_MAP \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_REGISTER_MAP)
#define WSP_GLOBAL_BREAKPOINTS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_BREAKPOINTS)
#define WSP_GLOBAL_LOG_FILE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_LOG_FILE)
#define WSP_GLOBAL_LOCAL_SOURCE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_LOCAL_SOURCE_PATH)
#define WSP_GLOBAL_FILTERS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_FILTERS)
#define WSP_GLOBAL_FIXED_LOGFONT \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_FIXED_LOGFONT)
#define WSP_GLOBAL_TAB_WIDTH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_TAB_WIDTH)
#define WSP_GLOBAL_MRU_LIST \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_MRU_LIST)
#define WSP_GLOBAL_REPEAT_COMMANDS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_REPEAT_COMMANDS)
#define WSP_GLOBAL_COM_SETTINGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_COM_SETTINGS)
#define WSP_GLOBAL_1394_SETTINGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_1394_SETTINGS)
#define WSP_GLOBAL_DISASM_ACTIVATE_SOURCE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DISASM_ACTIVATE_SOURCE)
#define WSP_GLOBAL_VIEW_TOOL_BAR \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_VIEW_TOOL_BAR)
#define WSP_GLOBAL_VIEW_STATUS_BAR \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_VIEW_STATUS_BAR)
#define WSP_GLOBAL_AUTO_CMD_SCROLL \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_AUTO_CMD_SCROLL)
#define WSP_GLOBAL_SRC_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_SRC_FILE_PATH)
#define WSP_GLOBAL_EXE_COMMAND_LINE \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_COMMAND_LINE)
#define WSP_GLOBAL_EXE_CREATE_FLAGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_CREATE_FLAGS)
#define WSP_GLOBAL_DUMP_FILE_NAME \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DUMP_FILE_NAME)
#define WSP_GLOBAL_ATTACH_KERNEL_FLAGS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_ATTACH_KERNEL_FLAGS)
#define WSP_GLOBAL_TYPE_OPTIONS \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_TYPE_OPTIONS)
#define WSP_GLOBAL_DUMP_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_DUMP_FILE_PATH)
#define WSP_GLOBAL_EXE_FILE_PATH \
    DEF_WSP_TAG(WSP_GROUP_GLOBAL, WSP_ITEM_EXE_FILE_PATH)

#define WSP_WINDOW_COMMONWIN_1 \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_COMMONWIN_1)
#define WSP_WINDOW_FRAME_PLACEMENT \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_FRAME_PLACEMENT)
#define WSP_WINDOW_FRAME_TITLE \
    DEF_WSP_TAG(WSP_GROUP_WINDOW, WSP_ITEM_FRAME_TITLE)

// Workspace header for window entries.
struct WSP_COMMONWIN_HEADER
{
    WIN_TYPES Type;
    ULONG Reserved;
};

//----------------------------------------------------------------------------
//
// A workspace is a dynamic buffer of tagged blobs.  Values
// are accessed through the Get/Set methods.
//
// Entries are always eight-byte aligned.
//
// Workspaces can be saved and restored from the registry under
// the windbg workspace key.
//
//----------------------------------------------------------------------------

#define WSP_REG_KEY "Software\\Microsoft\\Windbg\\Workspaces"

enum
{
    WSP_NAME_BASE,
    WSP_NAME_KERNEL,
    WSP_NAME_USER,
    WSP_NAME_DUMP,
    WSP_NAME_REMOTE,
    WSP_NAME_EXPLICIT,
    WSP_NAME_COUNT
};

#define MAX_WSP_NAME 256

#define WSP_SIGNATURE 'SWDW'
#define WSP_VERSION   1

struct WSP_HEADER
{
    ULONG Signature;
    ULONG Version;
};

struct WSP_ENTRY
{
    WSP_TAG Tag;
    USHORT FullSize;
    USHORT DataSize;
};

#define WSP_ENTRY_DATA(Type, Entry) ((Type)((Entry) + 1))

#define WSPF_DIRTY_WRITE       0x00000001
#define WSPF_DIRTY_WINDOWS     0x00000002
#define WSPF_DIRTY_BREAKPOINTS 0x00000004
#define WSPF_DIRTY_LOG_FILE    0x00000008
#define WSPF_DIRTY_PATHS       0x00000010
#define WSPF_DIRTY_FILTERS     0x00000020
#define WSPF_DIRTY_MRU_LIST    0x00000040
#define WSPF_DIRTY_ALL         0x0000007f

#define WSP_APPLY_DEFAULT  0x00000000
#define WSP_APPLY_EXPLICIT 0x00000001
#define WSP_APPLY_AGAIN    0x00000002

class Workspace
{
public:
    Workspace(void);
    ~Workspace(void);
    
    WSP_ENTRY* Get(WSP_TAG Tag);
    WSP_ENTRY* GetNext(WSP_ENTRY* Entry, WSP_TAG Tag, WSP_TAG TagMask);
    WSP_ENTRY* GetString(WSP_TAG Tag, PSTR Str, ULONG MaxSize);
    WSP_ENTRY* GetAllocString(WSP_TAG Tag, PSTR* Str);
    WSP_ENTRY* GetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size);
    WSP_ENTRY* GetUlong(WSP_TAG Tag, PULONG Value)
    {
        return GetBuffer(Tag, Value, sizeof(*Value));
    }
    
    WSP_ENTRY* Set(WSP_TAG Tag, ULONG Size);
    WSP_ENTRY* SetString(WSP_TAG Tag, PSTR Str);
    WSP_ENTRY* SetStrings(WSP_TAG Tag, ULONG Count, PSTR* Strs);
    WSP_ENTRY* SetBuffer(WSP_TAG Tag, PVOID Buf, ULONG Size);
    WSP_ENTRY* SetUlong(WSP_TAG Tag, ULONG Value)
    {
        WSP_ENTRY* Entry = SetBuffer(Tag, &Value, sizeof(Value));
        return Entry;
    }

    WSP_ENTRY* Add(WSP_TAG Tag, ULONG Size);
    
    ULONG Delete(WSP_TAG Tag, WSP_TAG TagMask);
    void Empty(void);
    BOOL IsEmpty(void)
    {
        return m_DataUsed == sizeof(WSP_HEADER);
    }
    
    WSP_HEADER* GetHeader(void)
    {
        return (WSP_HEADER*)m_Data;
    }
    BOOL ValidEntry(WSP_ENTRY* Entry)
    {
        return (PUCHAR)Entry >= m_Data &&
            (ULONG)((PUCHAR)Entry - m_Data) < m_DataUsed;
    }
    WSP_ENTRY* NextEntry(WSP_ENTRY* Entry)
    {
        if (Entry == NULL)
        {
            Entry = (WSP_ENTRY*)(m_Data + sizeof(WSP_HEADER));
        }
        else
        {
            Entry = (WSP_ENTRY*)((PUCHAR)Entry + Entry->FullSize);
        }
        
        if (ValidEntry(Entry))
        {
            return Entry;
        }
        else
        {
            return NULL;
        }
    }

    ULONG GetFlags(void)
    {
        return m_Flags;
    }
    void SetFlags(ULONG Flags, ULONG Mask)
    {
        m_Flags = (m_Flags & ~Mask) | (Flags & Mask);
    }
    
    void AddDirty(ULONG Flags)
    {
        m_Flags |= Flags;
    }
    void ClearDirty(void)
    {
        m_Flags &= ~WSPF_DIRTY_ALL;
    }

    ULONG GetKey(void)
    {
        return m_Key;
    }
    PTSTR GetValue(void)
    {
        return m_Value;
    }
    
    static HRESULT Create(ULONG Key, PTSTR Value,
                          Workspace** NewWsp);
    static HRESULT Read(ULONG Key, PTSTR Value,
                        Workspace** NewWsp);
    HRESULT ChangeName(ULONG Key, PTSTR Value, BOOL Force);
    HRESULT Flush(BOOL ForceSave, BOOL Cancellable);

    void UpdateBreakpointInformation(void);
    void UpdateWindowInformation(void);
    void UpdateLogFileInformation(void);
    void UpdatePathInformation(void);
    void UpdateFilterInformation(void);
    void UpdateMruListInformation(void);
    HRESULT WriteReg(void);
    void DeleteReg(BOOL Primary);
    static void DeleteRegKey(BOOL Primary, ULONG Key, PTSTR Value);
    
    int Apply(ULONG Flags);
    
private:
    ULONG m_Flags;
    
    PUCHAR m_Data;
    ULONG m_DataLen;
    ULONG m_DataUsed;
    
    ULONG m_Key;
    PTSTR m_Value;

    void PackData(PUCHAR Dst, ULONG Len)
    {
        PUCHAR Src = Dst + Len;
        memmove(Dst, Src, m_DataUsed - (ULONG)(Src - m_Data));
        m_DataUsed -= Len;
    }
    WSP_ENTRY* AllocateEntry(ULONG FullSize);
    static void GetKeyName(ULONG Key, PSTR KeyName);
    static HKEY OpenKey(BOOL Primary, ULONG Key, BOOL Create);
};

// The current workspace.
extern Workspace* g_Workspace;
extern BOOL g_ExplicitWorkspace;
extern char* g_WorkspaceKeyNames[];
extern char* g_WorkspaceDefaultName;
extern char* g_WorkspaceKeyDescriptions[];

HRESULT UiSwitchWorkspace(ULONG Key, PTSTR Value, BOOL Create,
                          ULONG Flags, int* SessionStarts);
HRESULT UiDelayedSwitchWorkspace(void);

void EngSwitchWorkspace(ULONG Key, PTSTR Value);

PSTR GetWspTagName(WSP_TAG Tag);

#endif // #ifndef __WRKSPACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\devmap\makefile.inc ===
$(O)\dosdev.res: dosdev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\delrp\makefile.inc ===
delrpmsg.rc: msg00001.bin

delrpmsg.h msg00001.bin: delrpmsg.mc
    mc -v -h .\ delrpmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\delnode\delnode.c ===
/*
 * History
 *      17-SEP-90   w-barry     Ported to Cruiser
 */

#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <string.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

#define BS    0x08
#define CTRLC 0x03
#define ENTER 0x0d

// Define external function calls..
extern flagType delnode( char * );

void
Usage (
      void
      )
{
    fputs("Usage:  delnode [/q] nodes\n"
          "                /q quiet, no confirm\n",
          stderr);
    exit (1);
}

flagType
fConfirm (
         char *psz
         )
{
    int ch, chLast;

    chLast = 0;
    printf ("\nDELNODE: Delete node \"%s\" and all its subdirectories? [yn] ", psz);
    while ( TRUE ) {

        ch = _getch();
        ch = tolower( ch );

        if (ch == 0x03) {
            printf( "^C Aborted\n" );
            exit( 1 );
        }
        if (ch == ENTER && (chLast == 'y' || chLast == 'n')) {
            putchar('\n');
            return (flagType)(chLast == 'y');
        }

        if (ch != 0) {
            if (ch == 'y' || ch == 'n') {
                putchar(ch);
                putchar('\b');
            }
        }
        chLast = ch;
    }

}

int
__cdecl
main(
    int c,
    char *v[]
    )
{
    char sz[MAX_PATH];
    flagType fAsk = TRUE;

    ConvertAppToOem( c, v );
    SHIFT (c, v);
    while (c && fSwitChr (**v)) {
        if (!strcmp (*v+1, "q"))
            fAsk = FALSE;
        else
            Usage ();
        SHIFT (c, v);
    }
    if (c == 0)
        Usage ();

    while (c) {
        if (strlen( *v ) == 0) {
            printf( "DELNODE: invalid null argument\n" );
        } else if (!fAsk || fConfirm (*v)) {
            if (!fileext (*v, sz)) {
                upd ("*.*", *v, sz);
            } else {
                strcpy (sz, *v);
                if (!strcmp ("..", sz) || !strcmp (".", sz)) {
                    pathcat (sz, "*.*");
                }
            }
            if (fAsk) {
                printf( "DELNODE: deleting ... \n", sz );
            }
            delnode (sz);
        } else if (fAsk) {
            printf("DELNODE: ** nothing ** deleted\n");
        }
        SHIFT (c, v);
    }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\devmap\devmap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    devmap.c

Abstract:

    Program to launch a command with a different device mapping.

Author:

    02-Oct-1996 Steve Wood (stevewo)

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

UCHAR DeviceNames[ 4096 ];
UCHAR TargetPath[ 4096 ];

typedef struct _DEVICE_LINK {
    PCHAR LinkName;
    ULONG LinkTargetLength;
    PCHAR LinkTarget;
    BOOL ProtectedDevice;
    BOOL RemoveDevice;
} DEVICE_LINK, *PDEVICE_LINK;

ULONG NumberOfDriveLetters;
ULONG NumberOfDevices;
DEVICE_LINK DriveLetters[ 128 ];
DEVICE_LINK Devices[ 128 ];
BOOLEAN CreatePermanentPrivilegeEnabled;
BOOLEAN CreatePermanentPrivilegeWasEnabled;

BOOLEAN
EnableCreatePermanentPrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable create permanent privilege
    //
    Status = RtlAdjustPrivilege( SE_CREATE_PERMANENT_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &CreatePermanentPrivilegeWasEnabled    // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    CreatePermanentPrivilegeEnabled = TRUE;
    return TRUE;
}


void
DisableCreatePermanentPrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_CREATE_PERMANENT_PRIVILEGE,
                        CreatePermanentPrivilegeWasEnabled,
                        FALSE,
                        &CreatePermanentPrivilegeWasEnabled
                      );

    CreatePermanentPrivilegeEnabled = FALSE;
    return;
}



void
Usage( void )
{
    fprintf( stderr, "usage: DEVMAP [-R]\n" );
    fprintf( stderr, "              [-r \"device list\"]\n" );
    fprintf( stderr, "              [-a \"device list\"]\n" );
    fprintf( stderr, "              command line...\n" );
    fprintf( stderr, "where: -R - removes all device definitions\n" );
    fprintf( stderr, "       -r - removes specified device definitions\n" );
    fprintf( stderr, "       -a - adds specified device definitions\n" );
    fprintf( stderr, "       \"device list\" - is a list of one or more blank separated\n" );
    fprintf( stderr, "                         defintions of the form name[=target]\n" );
    fprintf( stderr, "                         If target is not specified for -a then\n" );
    fprintf( stderr, "                         uses the target in effect when DEVMAP\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Examples:\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "    DEVMAP -R -a \"C: D: NUL\" CMD.EXE\n" );
    fprintf( stderr, "    DEVMAP -r \"UNC\" CMD.EXE\n" );
    fprintf( stderr, "    DEVMAP -a \"COM1=\\Device\\Serial8\" CMD.EXE\n" );
    exit( 1 );
}

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    );

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    )
{
    char *s;

    printf( "%s%s = ", Msg, Name );
    s = Target;
    while (*s && cchTarget != 0) {
        if (s > Target) {
            printf( " ; " );
            }
        printf( "%s", s );
        while (*s++) {
            if (!cchTarget--) {
                cchTarget = 0;
                break;
                }
            }
        }
}

PDEVICE_LINK
FindDevice(
    LPSTR Name,
    BOOL fAdd
    )
{
    DWORD i;
    LPSTR NewTarget;
    PDEVICE_LINK p;

    if (fAdd) {
        NewTarget = strchr( Name, '=' );
        if (NewTarget != NULL) {
            *NewTarget++ = '\0';
            }
        }

    for (i=0; i<NumberOfDriveLetters; i++) {
        p = &DriveLetters[ i ];
        if (!_stricmp( p->LinkName, Name )) {
            if (fAdd && NewTarget) {
                p->LinkTargetLength = strlen( NewTarget ) + 2;
                p->LinkTarget = calloc( 1, p->LinkTargetLength );
                if (!p->LinkTarget) {
                    return NULL;
                }
                strcpy( p->LinkTarget, NewTarget );
                }
            return p;
            }
        }

    for (i=0; i<NumberOfDevices; i++) {
        p = &Devices[ i ];
        if (!_stricmp( p->LinkName, Name )) {
            if (fAdd && NewTarget) {
                p->LinkTargetLength = strlen( NewTarget ) + 2;
                p->LinkTarget = calloc( 1, p->LinkTargetLength );
                if (!p->LinkTarget) {
                    return NULL;
                }
                strcpy( p->LinkTarget, NewTarget );
                }
            return p;
            }
        }

    if (fAdd) {
        if (NewTarget != NULL) {
            if (strlen( Name ) == 2 && Name[1] == ':') {
                p = &DriveLetters[ NumberOfDriveLetters++ ];
                }
            else {
                p = &Devices[ NumberOfDevices++ ];
                }

            p->LinkName = Name;
            p->LinkTargetLength = strlen( NewTarget ) + 2;
            p->LinkTarget = calloc( 1, p->LinkTargetLength );
            if (!p->LinkTarget) {
                return NULL;
            }
            strcpy( p->LinkTarget, NewTarget );
            }
        else {
            fprintf( stderr, "DEVMAP: Unable to add '%s' device name without target.\n", Name );
            }
        }
    else {
        fprintf( stderr, "DEVMAP: Unable to remove '%s' device name.\n", Name );
        }

    return NULL;
}

BOOL
CreateSymbolicLink(
    HANDLE DirectoryHandle,
    LPSTR Name,
    LPSTR Target,
    DWORD cchTarget,
    BOOL fVerbose
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING LinkName, LinkTarget;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE LinkHandle;

    RtlInitAnsiString( &AnsiString, Name );
    RtlAnsiStringToUnicodeString( &LinkName, &AnsiString, TRUE );

    AnsiString.Buffer = Target;
    AnsiString.Length = (USHORT)cchTarget - 2;
    AnsiString.MaximumLength = (USHORT)(cchTarget - 1);
    RtlAnsiStringToUnicodeString( &LinkTarget, &AnsiString, TRUE );

    InitializeObjectAttributes( &ObjectAttributes,
                                &LinkName,
                                CreatePermanentPrivilegeEnabled ? OBJ_PERMANENT : 0,
                                DirectoryHandle,
                                NULL
                              );
    Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &LinkTarget
                                       );
    if (NT_SUCCESS( Status )) {
        if (CreatePermanentPrivilegeEnabled) {
            NtClose( LinkHandle );
            }
        return TRUE;
        }
    else {
        if (fVerbose) {
            printf( " (*** FAILED %x ***)", Status );
            }
        return FALSE;
        }
}

int
__cdecl
CompareDeviceLink(
    void const *p1,
    void const *p2
    )
{
    return _stricmp( ((PDEVICE_LINK)p1)->LinkName, ((PDEVICE_LINK)p2)->LinkName );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD cch, i;
    char c, *s;
    BOOL fVerbose;
    BOOL fRemoveAllDevices;
    LPSTR lpCommandLine;
    LPSTR lpRemoveDevices;
    LPSTR lpAddDevices;
    PDEVICE_LINK p;
    char szWindowsDirectory[ MAX_PATH ] = {0};
    char chWindowsDrive;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    if (!GetWindowsDirectory( szWindowsDirectory, sizeof( szWindowsDirectory ) )) {
        return 1;
    }
    chWindowsDrive = (char) toupper( szWindowsDirectory[ 0 ] );
    fVerbose = FALSE;
    fRemoveAllDevices = FALSE;
    lpCommandLine = NULL;
    lpRemoveDevices = NULL;
    lpAddDevices = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch (tolower( c )) {
                    case '?':
                    case 'h':
                        Usage();

                    case 'v':
                        fVerbose = TRUE;
                        break;

                    case 'r':
                        if (c == 'R') {
                            fRemoveAllDevices = TRUE;
                            }
                        else
                        if (--argc) {
                            lpRemoveDevices = *++argv;
                            }
                        else {
                            fprintf( stderr, "DEVMAP: missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;

                    case 'a':
                        if (--argc) {
                            lpAddDevices = *++argv;
                            }
                        else {
                            fprintf( stderr, "DEVMAP: missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;
                    }
                }
            }
        else
        if (lpCommandLine == NULL) {
            lpCommandLine = s;
            break;
            }
        else {
            Usage();
            }
        }

    if (lpCommandLine != NULL) {
        lpCommandLine = strstr( GetCommandLine(), lpCommandLine );
        }

    if (lpCommandLine == NULL) {
        lpCommandLine = "CMD.EXE";
        }


    cch = QueryDosDevice( NULL,
                          DeviceNames,
                          sizeof( DeviceNames )
                        );
    if (cch == 0) {
        fprintf( stderr, "DOSDEV: Unable to query device names - %u\n", GetLastError() );
        exit( 1 );
        }

    s = DeviceNames;
    while (*s) {
        cch = QueryDosDevice( s,
                              TargetPath,
                              sizeof( TargetPath )
                            );
        if (cch == 0) {
            sprintf( TargetPath, "*** unable to query target path - %u ***", GetLastError() );
            }
        else {
            if (strlen( s ) == 2 && s[1] == ':') {
                p = &DriveLetters[ NumberOfDriveLetters++ ];
                if (chWindowsDrive == toupper( *s )) {
                    p->ProtectedDevice = TRUE;
                    }
                }
            else {
                p = &Devices[ NumberOfDevices++ ];
                }

            p->LinkName = s;
            p->LinkTargetLength = cch;
            p->LinkTarget = malloc( cch );
            if (!p->LinkTarget) {
                return 1;
            }
            memmove( p->LinkTarget, TargetPath, cch );
            }

        while (*s++)
            ;
        }

    qsort( DriveLetters,
           NumberOfDriveLetters,
           sizeof( DEVICE_LINK ),
           CompareDeviceLink
         );

    qsort( Devices,
           NumberOfDevices,
           sizeof( DEVICE_LINK ),
           CompareDeviceLink
         );

    if (fVerbose) {
        printf( "Existing Device Names\n" );

        for (i=0; i<NumberOfDriveLetters; i++) {
            p = &DriveLetters[ i ];
            DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( "\n" );
            }

        for (i=0; i<NumberOfDevices; i++) {
            p = &Devices[ i ];
            DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( "\n" );
            }
        }

    if (fRemoveAllDevices) {
        for (i=0; i<NumberOfDriveLetters; i++) {
            DriveLetters[ i ].RemoveDevice = TRUE;
            }
        for (i=0; i<NumberOfDevices; i++) {
            Devices[ i ].RemoveDevice = TRUE;
            }
        }

    while (s = lpRemoveDevices) {
        while (*s && *s != ' ') {
            s++;
            }
        c = *s;
        *s++ = '\0';
        if (p = FindDevice( lpRemoveDevices, FALSE )) {
            p->RemoveDevice = TRUE;
            }
        if (c) {
            lpRemoveDevices = s;
            }
        else {
            lpRemoveDevices = NULL;
            }
        }

    while (s = lpAddDevices) {
        while (*s && *s != ' ') {
            s++;
            }
        c = *s;
        *s++ = '\0';
        if (p = FindDevice( lpAddDevices, TRUE )) {
            p->RemoveDevice = FALSE;
            }

        if (c) {
            lpAddDevices = s;
            }
        else {
            lpAddDevices = NULL;
            }
        }

    if (fVerbose) {
        printf( "Launching '%s' with following Device Names\n", lpCommandLine );
        }
    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    if (!CreateProcess( NULL,
                        lpCommandLine,
                        NULL,
                        NULL,
                        TRUE,
                        CREATE_SUSPENDED,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                      )
       ) {
        fprintf( stderr, "DEVMAP: CreateProcess failed - %u\n", GetLastError() );
        return 1;
        }

    Status = NtCreateDirectoryObject( &DirectoryHandle,
                                      DIRECTORY_ALL_ACCESS,
                                      NULL
                                    );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "DEVMAP: NtCreateDirectoryObject failed - %x\n", Status );
        return 1;
        }

    ProcessDeviceMapInfo.Set.DirectoryHandle = DirectoryHandle;
    Status = NtSetInformationProcess( ProcessInfo.hProcess,
                                      ProcessDeviceMap,
                                      &ProcessDeviceMapInfo.Set,
                                      sizeof( ProcessDeviceMapInfo.Set )
                                    );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "DEVMAP: Set ProcessDeviceMap failed - %x\n", Status );
        exit(1);
        }

    EnableCreatePermanentPrivilege();
    for (i=0; i<NumberOfDriveLetters; i++) {
        p = &DriveLetters[ i ];
        if (!p->RemoveDevice || p->ProtectedDevice) {
            if (fVerbose) {
                DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                if (p->RemoveDevice && p->ProtectedDevice) {
                    printf( "  (*** may not remove boot device)" );
                    }
                }
            CreateSymbolicLink( DirectoryHandle,
                                p->LinkName,
                                p->LinkTarget,
                                p->LinkTargetLength,
                                fVerbose
                              );
            if (fVerbose) {
                printf( "\n" );
                }
            }
        }

    for (i=0; i<NumberOfDevices; i++) {
        p = &Devices[ i ];
        if (!p->RemoveDevice || p->ProtectedDevice) {
            if (fVerbose) {
                DisplayDeviceTarget( "    ", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                }
            CreateSymbolicLink( DirectoryHandle,
                                p->LinkName,
                                p->LinkTarget,
                                p->LinkTargetLength,
                                fVerbose
                              );
            if (fVerbose) {
                printf( "\n" );
                }
            }
        }
    DisableCreatePermanentPrivilege();
    NtClose( DirectoryHandle );

    ResumeThread( ProcessInfo.hThread );
    WaitForSingleObject( ProcessInfo.hProcess, 0xffffffff );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\delrp\delrp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    delrp.c

    This module contains a simple program to blatantly delete a reparse point
    of any kind.

Author:

    Felipe Cabrera   (Cabrera)   11-Jul-1997

Revision History:


--*/
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>          //  exit
#include <io.h>              //  _get_osfhandle

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>

#include <windows.h>
#include <locale.h>         //  setlocale

//
//
//  Functions forward referenced.
//

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    );

void
ScanArgs (
    int argc,
    char **argv
    );

void
__cdecl
printmessage (
    DWORD messageID,
    ...
    );

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    );

int
FileIsConsole (
    int fh
    );

//
//  I/O stream  handles and variables.
//

HANDLE hInput;
HANDLE hOutput;
HANDLE hError;

#define STDIN   0
#define STDOUT  1
#define STDERR  2

BOOL ConsoleInput;
BOOL ConsoleOutput;
BOOL ConsoleError;

//
// Core control state vars
//

BOOLEAN     NeedHelp;

#include "delrpmsg.h"

TCHAR Buf[1024];                            // for displaying stuff

//
//  Main
//

void
__cdecl
main(
    int  argc,
    char **argv
    )
/*++

Routine Description:

    Main procedure for pentnt.

    First, we call a series of routines that build a state vector
    in some booleans.

    We'll then act on these control variables:

        NeedHelp -  User has asked for help, or made a command error

Arguments:

    argc - count of arguments, including the name of our proggram

    argv - argument list - see command line syntax above

Return Value:

    Exit(0) - the file was deleted

    Exit(1) - a problem ocurred.

--*/

{
    CHAR    lBuf[16];
    DWORD   dwCodePage;
    LANGID  LangId;

    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    UNICODE_STRING UnicodeName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    FILE_DISPOSITION_INFORMATION Disposition = {TRUE};
    WCHAR WFileName[MAX_PATH];

    //
    // Build up state vector in global booleans.
    //

    ScanArgs(argc, argv);

    //
    // printf( "argc = %d NeedHelp = %d\n", argc, NeedHelp );
    //

    //
    // Since FormatMessage checks the current TEB's locale, and the Locale for
    // CHCP is initialized when the message class is initialized, the TEB has to
    // be updated after the code page is changed successfully.

    // Why are we doing this, you ask.  Well, the FE guys have plans to add
    // more than one set of language resources to this module, but not all
    // the possible resources.  So this limited set is what they plan for.
    // If FormatMessage can't find the right language, it falls back to
    // something hopefully useful.
    //

    dwCodePage = GetConsoleOutputCP();

    sprintf(lBuf, ".%d", dwCodePage);

    switch( dwCodePage )
    {
    case 437:
        LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
        break;
    case 932:
        LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
        break;
    case 949:
        LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
        break;
    case 936:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
        break;
    case 950:
        LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
        break;
    default:
        LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
        lBuf[0] = '\0';
        break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    setlocale(LC_ALL, lBuf);

    //
    //  Set the appropriate handles.
    //

    hInput = GetStdHandle(STD_INPUT_HANDLE);
    ConsoleInput = FileIsConsole(STDIN);

    hOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleOutput = FileIsConsole(STDOUT);

    hError = GetStdHandle(STD_ERROR_HANDLE);
    ConsoleError = FileIsConsole(STDERR);

    //
    // OK, we know the state of the command, do work
    //

    //
    // If they asked for help, or did something that indicates they don't
    // understand how the program works, print help and exit.
    //

    if (NeedHelp) {
        printmessage( MSG_DELRP_HELP );
        exit(1);
    }

    //
    //  Change the string to Unicode and pass down to open the file.
    //

    SzToWsz( WFileName, argv[1] );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                             WFileName,
                             &UnicodeName,
                             NULL,
                             NULL
                             );

    if (!TranslationStatus) {
        printmessage( MSG_DELRP_WRONG_NAME );
        exit(1);
    }

    FreeBuffer = UnicodeName.Buffer;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // printf( "Transformed unicode str is %Z\n", &UnicodeName );
    //

    //
    // Open the file for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    // This will get a handle to the entity whether the appropriate filter is or not in place.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );

    if (!NT_SUCCESS(Status)) {

        SzToWsz( WFileName, argv[1] );
        swprintf(&Buf[0], TEXT("%s"), WFileName);
        DisplayMsg(MSG_DELRP_OPEN_FAILED_NL, Buf);

        // printmessage( MSG_DELRP_OPEN_FAILED );

        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
        exit(1);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);

    if (!NT_SUCCESS(Status)) {
        printmessage( MSG_DELRP_DELETE_FAILED );
        exit(1);
    }

    exit(0);
}  // main



VOID
ScanArgs(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    ScanArgs - parse command line arguments, and set control flags
                to reflect what we find.

    Sets NeedHelp.

Arguments:

    argc - count of command line args

    argv - argument vector

Return Value:

--*/
{
    int i;

    NeedHelp = FALSE;

    if ((argc == 1) ||
        (argc > 3)) {
        NeedHelp = TRUE;
        goto done;
    }

    //
    //  At this point argc == 2
    //

    if ((argv[1][0] == '/') &&
        (argv[1][1] == '?') &&
        (strlen(argv[1]) == 2)) {
        NeedHelp = TRUE;
        goto done;
    }

done:
    return;
} // ScanArgs


//
//  Changing a file name to wide characters.
//

void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
    return;
} // SzToWsz


//
// Call FormatMessage and dump the result.  All messages to Stdout
//
void
__cdecl
printmessage (
    DWORD messageID,
    ...
    )
{
    unsigned short messagebuffer[4096];
    va_list ap;

    va_start(ap, messageID);

    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0,
                  messagebuffer, 4095, &ap);

    wprintf(messagebuffer);

    va_end(ap);
}  // printmessage


TCHAR DisplayBuffer[4096];
CHAR DisplayBuffer2[4096];

void
__cdecl
DisplayMsg (
    DWORD MsgNum,
    ...
    )
{
    DWORD len, bytes_written;
    BOOL success;
    DWORD status;
    va_list ap;

    va_start(ap, MsgNum);

    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0,
        DisplayBuffer, 4096, &ap);

    if (ConsoleOutput) {
        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len,
                 &bytes_written, NULL);

    } else {
        CharToOem(DisplayBuffer, DisplayBuffer2);
        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len,
                 &bytes_written, NULL);
    }

    if (!success || bytes_written != len) {
        status = GetLastError();
    }

    va_end(ap);
} // DisplayMsg


int
FileIsConsole(int fh)
{
    unsigned htype;
    DWORD dwMode;
    HANDLE hFile;

    hFile = (HANDLE)_get_osfhandle(fh);
    htype = GetFileType(hFile);
    htype &= ~FILE_TYPE_REMOTE;

    if (FILE_TYPE_CHAR == htype) {

        switch (fh) {
        case STDIN:
            hFile = GetStdHandle(STD_INPUT_HANDLE);
            break;
        case STDOUT:
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
            break;
        case STDERR:
            hFile = GetStdHandle(STD_ERROR_HANDLE);
            break;
        }

        if (GetConsoleMode(hFile, &dwMode)) {
            return TRUE;
        }
    }

    return FALSE;

} // FileIsConsole
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diff\diff.c ===
/*                                                                                        SORT
*      %Z% %M% %I% %D% %Q%
*
*      Copyright (C) Microsoft Corporation, 1983
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and AT&T, and should be treated as Confidential.
*/

/***    diff - differential file comparison
*
*      MODIFICATION HISTORY
*      M000    18 Apr 83       andyp
*      - 3.0 upgrade.  No changes.
*      M001    22 Mar 84       vich
*      - Don't try to unlink NULL.  Trying to do so doesn't break anything,
*        but it makes kernel debugging a pain due to faults in user mode.
*      M002    ??
*      - added the MSDOS flag.
*      M006    31 Mar 86       craigwi
*      - for the MSDOS version, fixed -b feature so that it ignores all \r
*      M010    15 Dec 86       craigwi
*      - after printing the result, diff aborts with status = 2 if any error
*        occurred on stdout.
*      M013    21 Mar 88       jangr
*      - added -s flag to return SLM specific error statuses:
*        10    files identical
*        11    files different
*        12    other errors
*        13    write error
*      M017    27 Oct 88       alanba
*      - changed messages to not specify using the -h option and giving
*        a clear error message if being executed from within SLM.
*/
/*
*      Uses an algorithm due to Harold Stone, which finds
*      a pair of longest identical subsequences in the two
*      files.
*
*      The major goal is to generate the match vector J.
*      J[i] is the index of the line in file1 corresponding
*      to line i file0. J[i] = 0 if there is no
*      such line in file1.
*
*      Lines are hashed so as to work in core. All potential
*      matches are located by sorting the lines of each file
*      on the hash (called value). In particular, this
*      collects the equivalence classes in file1 together.
*      Subroutine equiv  replaces the value of each line in
*      file0 by the index of the first element of its
*      matching equivalence in (the reordered) file1.
*      To save space equiv squeezes file1 into a single
*      array member in which the equivalence classes
*      are simply concatenated, except that their first
*      members are flagged by changing sign.
*
*      Next the indices that point into member are unsorted into
*      array class according to the original order of file0.
*
*      The cleverness lies in routine stone. This marches
*      through the lines of file0, developing a vector klist
*      of "k-candidates". At step i a k-candidate is a matched
*      pair of lines x,y (x in file0 y in file1) such that
*      there is a common subsequence of lenght k
*      between the first i lines of file0 and the first y
*      lines of file1, but there is no such subsequence for
*      any smaller y. x is the earliest possible mate to y
*      that occurs in such a subsequence.
*
*      Whenever any of the members of the equivalence class of
*      lines in file1 matable to a line in file0 has serial number
*      less than the y of some k-candidate, that k-candidate
*      with the smallest such y is replaced. The new
*      k-candidate is chained (via pred) to the current
*      k-1 candidate so that the actual subsequence can
*      be recovered. When a member has serial number greater
*      that the y of all k-candidates, the klist is extended.
*      At the end, the longest subsequence is pulled out
*      and placed in the array J by unravel.
*
*      With J in hand, the matches there recorded are
*      checked against reality to assure that no spurious
*      matches have crept in due to hashing. If they have,
*      they are broken, and "jackpot " is recorded--a harmless
*      matter except that a true match for a spuriously
*      mated line may now be unnecessarily reported as a change.
*
*      Much of the complexity of the program comes simply
*      from trying to minimize core utilization and
*      maximize the range of doable problems by dynamically
*      allocating what is needed and reusing what is not.
*      The core requirements for problems larger than somewhat
*      are (in words) 2*length(file0) + length(file1) +
*      3*(number of k-candidates installed),  typically about
*      6n words for files of length n.
*/

#include <stdio.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <excpt.h>
#include <process.h>
#include <fcntl.h>
#ifdef _OS2_SUBSYS_
    #define INCL_DOSSIGNALS
    #include <os2.h>
#else
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
/*
 * Signal subtypes for XCPT_SIGNAL
 */
    #define XCPT_SIGNAL                     0xC0010003
    #define XCPT_SIGNAL_INTR        1
    #define XCPT_SIGNAL_KILLPROC    3
    #define XCPT_SIGNAL_BREAK       4
#endif


#define isslash(c)  (c=='/'||c=='\\')
#define DIFFH           "diffh.exe"

#ifndef _MAX_PATH
    #if defined(LFNMAX) && defined(LPNMAX)
        #define _MAX_PATH (LFNMAX + LPNMAX + 1)
    #else
        #define _MAX_PATH (80)
    #endif
#endif
#ifndef _HEAP_MAXREQ
    #define _HEAP_MAXREQ ((~(unsigned int) 0) - (unsigned) 32)
#endif
#define HALFLONG 16
#define low(x)  (x&((1L<<HALFLONG)-1))
#define high(x) (x>>HALFLONG)

struct cand **clist;    /* merely a free storage pot for candidates */
int clistcnt = 0;       /* number of arrays of struct cand in clist */
unsigned clen = 0;      /* total number of struct cand in all clist arrays */

/*
Number of struct cand in one clist array
(the largest power of 2 smaller than (64k / sizeof(struct cand))
is 2^13.  Thus, these gross hacks to make the array references
more efficient, and still permit huge files.
*/
#define CLISTSEG (0x2000)
#define CLISTDIV(x) ((x) >> 13)
#define CLISTMOD(x) ((x) & (CLISTSEG - 1))
#define CLIST(x) (clist[CLISTDIV(x)][CLISTMOD(x)])

PVOID   input[2];

char *inputfile[2];
int  inputfilesize[2];
char *inputfilep[2];
int  inputfileleft[2];

#define EndOfFile(x)    (inputfileleft[x] <= 0)

#define  GetChar(x)  ((char)((inputfileleft[x]--) ?     \
                           (*(inputfilep[x])++)  :  \
                           EOF))



#define SEARCH(c1,k1,y1) (CLIST(c1[k1]).y < y1) ? (k1+1) : search(c1,k1,y1)

#if 0

char
GetChar( int x );

char
GetChar( int x ) {
    if ( inputfileleft[x]-- ) {
        return *(inputfilep[x])++;
    } else {
        return EOF;
    }
}

#endif

struct cand {
    int x;
    int y;
    unsigned pred;
} cand;
struct line {
    int serial;
    int value;
} *file[2], line;


typedef struct _FILEMAP *PFILEMAP;
typedef struct _FILEMAP {
    HANDLE  FileHandle;
    HANDLE  MapHandle;
    DWORD   Access;
    DWORD   Create;
    DWORD   Share;
    PVOID   Base;
    DWORD   Offset;
    DWORD   Size;
    DWORD   Allocated;
} FILEMAP;

PVOID
Open(
    const char *FileName,
    const char *Mode,
    DWORD      Size
    );

int
Close (
      PVOID   Map
      );




/* fn prototypes gen'd from cl -Zg */

void  done(void);
char  *talloc(unsigned n);
char  *ralloc(char      *p,unsigned n);
void  myfree( char *p );
void  noroom(void);
int   __cdecl  sortcmp(void    const *first, void const *second);
void  unsort(struct  line *f,unsigned l,int  *b);
void  filename(char     * *pa1,char     * *pa2);
void  prepare(int       i,char  *arg);
void  prune(void);
void  equiv(struct      line *a,int     n,struct  line *b,int  m,int  *c);
int  stone(int  *a,unsigned  n,int  *b,unsigned  *c);
unsigned newcand(int  x,int  y,unsigned pred);
int  search(unsigned  *c,int  k,int  y);
void  unravel(unsigned  p);
void  check(char        * *argv);
char *  skipline(int  f);
void  output(char       * *argv);
void  change(int        a,int   b,int  c,int  d);
void  range(int a,int  b,char  *separator);
void  fetch(char *      *f,int  a,int   b, int lb,char  *s);
int   readhash( int f);
void  mesg(char *s,char  *t);
void  SetOutputFile (char *FileName);

unsigned len[2];
struct line *sfile[2];  /*shortened by pruning common prefix and suffix*/
unsigned slen[2];

unsigned int pref, suff; /*length of prefix and suffix*/
int *class;     /*will be overlaid on file[0]*/
int *member;    /*will be overlaid on file[1]*/
unsigned *klist;             /*will be overlaid on file[0] after class*/
int *J;         /*will be overlaid on class*/
char * *ixold;    /*will be overlaid on klist*/
char * *ixnew;    /*will be overlaid on file[1]*/
int opt;        /* -1,0,1 = -e,normal,-f */
int status = 2; /*abnormal status; set to 0/1 just before successful exit */
int anychange = 0;
char *empty = "";
int bflag;
int slmFlag;
FILE*   OutputFile;





char *tempfile; /*used when comparing against std input*/

#ifndef MSDOS
char *dummy;    /*used in resetting storage search ptr*/
#endif
void
done()
{
    if (tempfile != NULL)
        _unlink(tempfile);

    if (OutputFile && OutputFile != stdout) {
        fclose(OutputFile);
    }
    exit(10*slmFlag + status);
}

#define MALLOC(n)               talloc(n)
#define REALLOC(p,n)    ralloc(p,n)
#define FREE(p)                 myfree(p)


// #define DEBUG_MALLOC

#ifdef DEBUG_MALLOC

    #define MALLOC_SIG              0xABCDEF00
    #define FREE_SIG                0x00FEDCBA

typedef struct _MEMBLOCK {
    DWORD   Sig;
} MEMBLOCK, *PMEMBLOCK;

#endif

char *
talloc(
      unsigned n
      )
{

#ifdef DEBUG_MALLOC
    PMEMBLOCK         mem;
    char              DbgB[128];

    //sprintf(DbgB, "MALLOC size %d -> ", n );
    //OutputDebugString( DbgB );

    mem = malloc( n + sizeof(MEMBLOCK)+1 );

    if ( !mem ) {
        noroom();
    }

    mem->Sig = MALLOC_SIG;

    //sprintf(DbgB, "%lX\n", mem );
    //OutputDebugString( DbgB );

    return (char *)((PBYTE)mem + sizeof(MEMBLOCK));

#else
    register char *p;

    p = malloc(++n);
    if (p == NULL) {
        noroom();
    }

    return p;
#endif
}

char *
ralloc(
      char *p,
      unsigned n
      )
{
#ifdef DEBUG_MALLOC
    PMEMBLOCK         mem;
    char              DbgB[128];

    mem = (PMEMBLOCK)((PBYTE)p - sizeof(MEMBLOCK));

    //sprintf(DbgB, "REALLOC: %lX, %d  -> ", mem, n );
    //OutputDebugString( DbgB );

    if ( mem->Sig != MALLOC_SIG ) {
        sprintf(DbgB, "REALLOC ERROR: Reallocating %lX\n", mem );
        OutputDebugString( DbgB );
    }
    mem->Sig = FREE_SIG;
    mem = (PMEMBLOCK)realloc(mem, n + sizeof(MEMBLOCK)+1);
    if (!mem) {
        noroom();
    }

    mem->Sig = MALLOC_SIG;

    //sprintf(DbgB, "%lX\n", mem );
    //OutputDebugString( DbgB );

    return (char *)((PBYTE)mem + sizeof(MEMBLOCK));

#else
    p = realloc(p, ++n);
    if (p==NULL) {
        noroom();
    }
    return(p);

#endif
}


void
myfree(
      char *p
      )
{

#ifdef DEBUG_MALLOC
    PMEMBLOCK mem;
    char      DbgB[128];

    mem = (PMEMBLOCK)((PBYTE)p - sizeof(MEMBLOCK));

    //sprintf(DbgB, "FREE: %lX -> ", mem );
    //OutputDebugString( DbgB);

    if ( mem->Sig != MALLOC_SIG ) {
        sprintf(DbgB, "\n\tFREE ERROR: FREEING %lX\n", mem );
        OutputDebugString( DbgB );
    }
    mem->Sig = FREE_SIG;
    free(mem);

    //sprintf(DbgB, "Ok\n", mem );
    //OutputDebugString( DbgB);

#else
    if (p) {
        free(p);
    }
#endif
}



void
noroom()
{

    if (slmFlag == 1) {
        mesg("file too big; do delfile filename/addfile filename, or",empty);
        mesg("reduce the size of the file.",empty);
        done();
    }
    mesg("files too big",empty);    /* end M017 */
    done();
}


int
__cdecl
sortcmp(
       const  void *first,
       const  void *second
       )
{
    struct line *one = (struct line *)first;
    struct line *two = (struct line *)second;

    if (one->value < two->value)
        return -1;
    else if (one->value > two->value)
        return 1;
    else if (one->serial < two->serial)
        return -1;
    else if (one->serial > two->serial)
        return 1;
    else
        return 0;
}

void
unsort(
      struct line *f,
      unsigned l,
      int *b
      )
{
    register int *a;
    register unsigned int i;
    a = (int *)MALLOC((l+1)*sizeof(int));
    if (a) {
        memset(a, 0, (l+1)*sizeof(int));
        for (i=1;i<=l;i++)
            a[f[i].serial] = f[i].value;
        for (i=1;i<=l;i++)
            b[i] = a[i];
        FREE((char *)a);
    }
}

void
filename(
        char **pa1,
        char **pa2
        )
{

    register char *a1, *b1, *a2;
    char buf[BUFSIZ];
    struct _stat stbuf;
    int i, f;

    a1 = *pa1;
    a2 = *pa2;


    if (_stat(a1,&stbuf)!=-1 && ((stbuf.st_mode&S_IFMT)==S_IFDIR)) {
        b1 = *pa1 = MALLOC((unsigned) _MAX_PATH);
        while (*b1++ = *a1++) ;
        if (isslash(b1[-2]))
            b1--;
        else
            b1[-1] = '/';
        a1 = b1;
        if ( a2[1] == ':' ) {
            a2 += 2;
        }
        while (*a1++ = *a2++)
            if (*a2 && !isslash(*a2) && isslash(a2[-1])) /*M002*/
                a1 = b1;
    } else if (a1[0]=='-'&&a1[1]==0&&tempfile==NULL) {
        /*  the signal handling in original source
        **
        **      signal(SIGINT,done);
        **  #ifndef MSDOS
        **      signal(SIGHUP,done);
        **      signal(SIGPIPE,done);
        **      signal(SIGTERM,done);
        **  #endif
        */

        if ((*pa1 = tempfile = _tempnam(getenv("TEMP"), "d")) == NULL) {
            mesg("cannot create temporary file", "");
            done();
        }
        if ((f = _open(tempfile,O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {
            mesg("cannot create ",tempfile);
            done();
        }

        while ((i=_read(0,buf,BUFSIZ))>0)
            _write(f,buf,i);
        _close(f);
    }
}

void
prepare(
       int i,
       char *arg
       )
{

#define CHUNKSIZE   100

    register struct line *p;
    register unsigned j;
    register int h;
    char *c;
    PVOID f;
    unsigned int MaxSize;

    if ((f = input[i] = Open(arg,"r", 0)) == NULL) {
        mesg("cannot open ", arg);
        done();
    }

    inputfile[i]     = ((PFILEMAP)f)->Base;
    inputfilesize[i] = ((PFILEMAP)f)->Size;

    inputfilep[i]    = inputfile[i];
    inputfileleft[i] = inputfilesize[i];

    //
    //  Lets assume that lines are 30 characters on average
    //
    MaxSize = inputfilesize[i] / 30;
    p = (struct line *)MALLOC((3+MaxSize)*sizeof(line));
    for (j=0; h=readhash(i);) {
        j++;
        if ( j >= MaxSize ) {
            MaxSize += CHUNKSIZE;
            p = (struct line *)REALLOC((char *)p,(MaxSize+3)*sizeof(line));
        }
        p[j].value = h;
    }
    p = (struct line *)REALLOC((char *)p,(j+3+1)*sizeof(line));

    len[i] = j;
    file[i] = p;
    //Close(input[i]);
}

void
prune()
{
    register unsigned int i,j;
    for (pref=0;pref<len[0]&&pref<len[1]&&
        file[0][pref+1].value==file[1][pref+1].value;
        pref++ ) ;
    for (suff=0;suff<len[0]-pref&&suff<len[1]-pref&&
        file[0][len[0]-suff].value==file[1][len[1]-suff].value;
        suff++) ;
    for (j=0;j<2;j++) {
        sfile[j] = file[j]+pref;
        slen[j] = len[j]-pref-suff;
        for (i=0;i<=slen[j];i++)
            sfile[j][i].serial = i;
    }
}

void
equiv(
     struct line *a,
     int n,
     struct line *b,
     int m,
     int *c
     )
{
    register int i, j;
    i = j = 1;
    while (i<=n && j<=m) {
        if (a[i].value <b[j].value)
            a[i++].value = 0;
        else if (a[i].value == b[j].value)
            a[i++].value = j;
        else
            j++;
    }
    while (i <= n)
        a[i++].value = 0;
    b[m+1].value = 0;
    j = 0;
    while (++j <= m) {
        c[j] = -b[j].serial;
        while (b[j+1].value == b[j].value) {
            j++;
            c[j] = b[j].serial;
        }
    }
    c[j] = -1;
}

char **args;

void
__cdecl
main(
    int argc,
    char **argv
    )
{

    register int k;

    args = argv;

    OutputFile = stdout;        // Init to default

    argc--;
    argv++;

    while (argc > 0 && argv[0][0]=='-') {

        BOOL    Skip = FALSE;

        for (k=1; (!Skip) && argv[0][k]; k++) {

            switch (argv[0][k]) {

                case 'e':
                    opt = -1;
                    break;

                case 'f':
                    opt = 1;
                    break;

                case 'b':
                    bflag = 1;
                    break;

                case 'h':
                    _execvp(DIFFH, args);
                    mesg("cannot run diffh",empty);
                    done();

                case 's':
                    slmFlag = 1;
                    break;

                case 'o':
                    //
                    //  Dirty hack: Redirection is not working, so if
                    //  this flag is present, output goes to
                    //  file.
                    //
                    argc--;
                    argv++;
                    if (argc < 3) {
                        mesg("arg count",empty);
                        done();
                    }
                    SetOutputFile(argv[0]);
                    Skip = TRUE;
                    break;
            }
        }
        argc--;
        argv++;
    }

    if (argc!=2) {
        mesg("arg count",empty);
        done();
    }

#ifndef MSDOS
    dummy = malloc(1);
#endif
    _setmode(_fileno(OutputFile), O_BINARY);
    _setmode(_fileno(stdin),O_TEXT);
    filename(&argv[0], &argv[1]);
    filename(&argv[1], &argv[0]);
    prepare(0, argv[0]);
    prepare(1, argv[1]);
    prune();
    qsort((char *) (sfile[0] + 1), slen[0], sizeof(struct line), sortcmp);
    qsort((char *) (sfile[1] + 1), slen[1], sizeof(struct line), sortcmp);

    member = (int *)file[1];
    equiv(sfile[0], slen[0], sfile[1], slen[1], member);
    member = (int *)REALLOC((char *)member,(slen[1]+2)*sizeof(int));

    class = (int *)file[0];
    unsort(sfile[0], slen[0], class);
    class = (int *)REALLOC((char *)class,(slen[0]+2)*sizeof(int));
    klist = (unsigned *)MALLOC((slen[0]+2)*sizeof(int));
    clist = (struct cand **)MALLOC(sizeof(struct cand *));
    clist[0] = (struct cand *) MALLOC(sizeof(struct cand));
    clistcnt = 1;
    k = stone(class, slen[0], member, klist);
    FREE((char *)member);
    FREE((char *)class);

    J = (int *)MALLOC((len[0]+2)*sizeof(int));

    unravel(klist[k]);
    for (k = 0; k < clistcnt; ++k)
        FREE((char *)(clist[k]));
    FREE((char *)clist);
    FREE((char *)klist);

    ixold = (char **)MALLOC((len[0]+2)*sizeof(char *));
    ixnew = (char **)MALLOC((len[1]+2)*sizeof(char *));
    check(argv);
    output(argv);
    status = anychange;
    Close(input[0]);
    Close(input[1]);

    done();
}

stone(
     int *a,
     unsigned n,
     int *b,
     unsigned *c
     )
{
    register int i, k,y;
    int j, l;
    unsigned oldc, tc;
    int oldl;
    k = 0;
    c[0] = newcand(0,0,0);
    for (i=1; i<=(int)n; i++) {
        j = a[i];
        if (j==0)
            continue;
        y = -b[j];
        oldl = 0;
        oldc = c[0];
        do {
            if (y <= CLIST(oldc).y)
                continue;
            l = SEARCH(c, k, y);
            if (l!=oldl+1)
                oldc = c[l-1];
            if (l<=k) {
                if (CLIST(c[l]).y <= y)
                    continue;
                tc = c[l];
                c[l] = newcand(i,y,oldc);
                oldc = tc;
                oldl = l;
            } else {
                c[l] = newcand(i,y,oldc);
                k++;
                break;
            }
        } while ((y=b[++j]) > 0);
    }
    return(k);
}

unsigned
newcand(
       int x,
       int y,
       unsigned pred
       )
{
    register struct cand *q;


    ++clen;
    if ((int)CLISTDIV(clen) > (clistcnt - 1)) {
        // printf("diff: surpassing segment boundry..\n");
        clist = (struct cand **) REALLOC((char *) clist,
                                         ++clistcnt * sizeof(struct cand *));
        clist[clistcnt-1] = (struct cand *) MALLOC(sizeof(struct cand));
    }
    clist[clistcnt-1] = (struct cand *)
                        REALLOC((char *)(clist[clistcnt-1]),
                                (1 + CLISTMOD(clen)) * sizeof(struct cand));
    q = &CLIST(clen - 1);
    q->x = x;
    q->y = y;
    q->pred = pred;
    return(clen-1);
}

search(
      unsigned *c,
      int k,
      int y
      )
{
    register int i, j;
    int l;
    int t;
    //if(CLIST(c[k]).y<y) /*quick look for typical case*/
    //    return(k+1);
    i = 0;
    j = k+1;
    while ((l=(i+j)/2) > i) {
        t = CLIST(c[l]).y;
        if (t > y)
            j = l;
        else if (t < y)
            i = l;
        else
            return(l);
    }
    return(l+1);
}

void
unravel(
       unsigned p
       )
{
    register unsigned int i;
    register struct cand *q;

    for (i=0; i<=len[0]; i++)
        J[i] =  i<=pref ? i:
                i>len[0]-suff ? i+len[1]-len[0]:
                0;


    for (q=&CLIST(p);q->y!=0;q=&CLIST(q->pred)) {

        J[q->x+pref] = q->y+pref;
    }
}

/* check does double duty:
1.  ferret out any fortuitous correspondences due
to confounding by hashing (which result in "jackpot")
2.  collect random access indexes to the two files */

void
check(
     char **argv
     )
{
    register unsigned int i, j;
    int jackpot;
    char c,d;
    //input[0] = fopen(argv[0],"r");
    //input[1] = fopen(argv[1],"r");

    inputfilep[0] = inputfile[0];
    inputfilep[1] = inputfile[1];

    inputfileleft[0] = inputfilesize[0];
    inputfileleft[1] = inputfilesize[1];

    j = 1;
    ixold[0] = ixnew[0] = 0L;
    ixold[0] = inputfilep[0];
    ixnew[0] = inputfilep[1];
    //ixold[1] = inputfilep[0];
    //ixnew[1] = inputfilep[1];
    jackpot = 0;
    for (i=1;i<=len[0];i++) {
        if (J[i]==0) {
            ixold[i] = skipline(0);
            continue;
        }
        while (j<(unsigned)J[i]) {
            ixnew[j] = skipline(1);
            j++;
        }
        for (;;) {
            c = GetChar(0);
            d = GetChar(1);
            if (bflag && isspace(c) && isspace(d)) {
                do {
                    if (c=='\n') break;
                } while (isspace(c=GetChar(0)));
                do {
                    if (d=='\n') break;
                } while (isspace(d=GetChar(1)));
            }
            if (c!=d) {
                jackpot++;
                J[i] = 0;
                if (c!='\n')
                    skipline(0);
                if (d!='\n')
                    skipline(1);
                break;
            }
            if (c=='\n')
                break;
        }
        ixold[i] = inputfilep[0];
        ixnew[j] = inputfilep[1];
        j++;
    }
    for (;j<=len[1];j++) {
        ixnew[j] = skipline(1);
    }
    //fclose(input[0]);
    //fclose(input[1]);
    /*
    if(jackpot)
            mesg("jackpot",empty);
    */
}

char *
skipline(
        int f
        )
{
    while (GetChar(f) != '\n' )
        ;

    return inputfilep[f];
}

void
output(
      char **argv
      )
{
    int m;
    register int i0, i1, j1;
    int j0;

    input[0] = Open(argv[0],"r", 0);
    input[1] = Open(argv[1],"r", 0);
    m = len[0];
    J[0] = 0;
    J[m+1] = len[1]+1;
    if (opt!=-1) for (i0=1;i0<=m;i0=i1+1) {
            while (i0<=m&&J[i0]==J[i0-1]+1) i0++;
            j0 = J[i0-1]+1;
            i1 = i0-1;
            while (i1<m&&J[i1+1]==0) i1++;
            j1 = J[i1+1]-1;
            J[i1] = j1;
            change(i0,i1,j0,j1);
        } else for (i0=m;i0>=1;i0=i1-1) {
            while (i0>=1&&J[i0]==J[i0+1]-1&&J[i0]!=0) i0--;
            j0 = J[i0+1]-1;
            i1 = i0+1;
            while (i1>1&&J[i1-1]==0) i1--;
            j1 = J[i1-1]+1;
            J[i1] = j1;
            change(i1,i0,j1,j0);
        }
    if (m==0)
        change(1,0,1,len[1]);
}

void
change(
      int a,
      int b,
      int c,
      int d
      )
{
    if (a>b&&c>d)
        return;
    anychange = 1;
    if (opt!=1) {
        range(a,b,",");
        putc(a>b?'a':c>d?'d':'c', OutputFile);
        if (opt!=-1)
            range(c,d,",");
    } else {
        putc(a>b?'a':c>d?'d':'c', OutputFile);
        range(a,b," ");
    }
    putc('\r',OutputFile);
    putc('\n',OutputFile);
    if (opt==0) {
        fetch(ixold,a,b,0,"< ");
        if (a<=b&&c<=d)
            fputs("---\r\n", OutputFile);
    }
    fetch(ixnew,c,d,1,opt==0?"> ":empty);
    if (opt!=0&&c<=d)
        fputs(".",OutputFile);
}


void
range(
     int a,
     int b,
     char *separator
     )
{
    fprintf(OutputFile,"%d", a>b?b:a);
    if (a<b)
        fprintf(OutputFile,"%s%d", separator, b);
}

void
fetch(
     char **f,
     int a,
     int b,
     int lb,
     char *s
     )
{
    register int i, j;
    register int nc;
    register char c;
    char *p;

    UNREFERENCED_PARAMETER( lb );

    for (i=a;i<=b;i++) {
        p = f[i-1];
        nc = (int)(f[i]-f[i-1]);
        fputs(s, OutputFile);
        for (j=0;j<nc;j++) {
            c = *p++;
            if (c == '\n' ) {
                //putc( '\r', OutputFile );
                putc( '\n', OutputFile );
                if ( p >= f[i] ) break;
            } else {
                putc(c, OutputFile);
            }
        }

    }
}

/* hashing has the effect of
* arranging line in 7-bit bytes and then
* summing 1-s complement in 16-bit hunks
*/

readhash(
        int f
        )
{
    register unsigned shift;
    register char t;
    register int space;
    long sum = 1L;

    space = 0;
    if (!bflag) for (shift=0;(t=GetChar(f))!='\n';shift+=7) {
            if (t==(char)EOF && EndOfFile(f) )
                return(0);
            sum += (long)t << (shift%=HALFLONG);
        } else for (shift=0;;) {
            switch (t=GetChar(f)) {
                case '\t':
                case ' ':
                case '\r':
                    space++;
                    continue;
                default:
                    if ( t==(char)EOF && EndOfFile(f) ) {
                        return(0);
                    }
                    if (space) {
                        shift += 7;
                        space = 0;
                    }
                    sum += (long)t << (shift%=HALFLONG);
                    shift += 7;
                    continue;
                case '\n':
                    break;
            }
            break;
        }
    sum = low(sum) + high(sum);
    return((short)low(sum) + (short)high(sum));
}

void
mesg(
    char *s,
    char *t
    )
{
    fprintf(stderr,"diff: %s%s\n",s,t);
}

void
SetOutputFile (
              char *FileName
              )
{
    OutputFile = fopen(FileName, "ab");
    if (!OutputFile) {
        mesg("Unable to open: ", FileName);
        done();
    }

}



PVOID
Open(
    const char *FileName,
    const char *Mode,
    DWORD      Size
    )
{
    PFILEMAP    FileMap = NULL;

    FileMap = (PFILEMAP)malloc(sizeof(FILEMAP));

    if ( FileMap ) {

        FileMap->Access = 0;
        FileMap->Share  = FILE_SHARE_READ | FILE_SHARE_WRITE;

        while ( *Mode ) {

            switch ( *Mode ) {

                case 'r':
                    FileMap->Access |= GENERIC_READ;
                    FileMap->Create = OPEN_EXISTING;
                    break;

                case 'w':
                    FileMap->Access |= GENERIC_WRITE;
                    FileMap->Create = CREATE_ALWAYS;
                    break;

                case 'a':
                    FileMap->Access += GENERIC_WRITE;
                    FileMap->Create = OPEN_ALWAYS;
                    break;

                case '+':
                    FileMap->Access |= (GENERIC_READ | GENERIC_WRITE);
                    break;

                default:
                    break;
            }

            Mode++;
        }

        FileMap->FileHandle = CreateFile(
                                        FileName,
                                        FileMap->Access,
                                        FileMap->Share,
                                        NULL,
                                        FileMap->Create,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        );

        if ( FileMap->FileHandle != INVALID_HANDLE_VALUE ) {

            FileMap->Size       = GetFileSize( FileMap->FileHandle, NULL );
            FileMap->Allocated  = (FileMap->Access == GENERIC_READ) ? FileMap->Size : Size;

            FileMap->MapHandle = CreateFileMapping(
                                                  FileMap->FileHandle,
                                                  NULL,
                                                  (FileMap->Access & GENERIC_WRITE) ? PAGE_READWRITE : PAGE_READONLY,
                                                  0,
                                                  (FileMap->Access == GENERIC_READ) ? 0 : (DWORD)Size,
                                                  NULL
                                                  );

            if ( FileMap->MapHandle ) {

                FileMap->Base = MapViewOfFile(
                                             FileMap->MapHandle,
                                             (FileMap->Access & GENERIC_WRITE) ? FILE_MAP_ALL_ACCESS : FILE_MAP_READ,
                                             0,
                                             0,
                                             (FileMap->Access == GENERIC_READ) ? 0 : Size
                                             );

                if ( FileMap->Base ) {

                    if ( FileMap->Create == OPEN_ALWAYS ) {
                        FileMap->Offset = FileMap->Size;
                    }
                    goto Done;
                }

                CloseHandle( FileMap->MapHandle );
            }

            CloseHandle( FileMap->FileHandle );
        }

        free( FileMap );
        FileMap = NULL;
    }

    Done:
    return (PVOID)FileMap;
}


int
Close (
      PVOID   Map
      )
{
    PFILEMAP    FileMap = (PFILEMAP)Map;

    UnmapViewOfFile( FileMap->Base );
    CloseHandle( FileMap->MapHandle );

    if ( FileMap->Access & GENERIC_WRITE ) {

        SetFilePointer( FileMap->FileHandle,
                        FileMap->Size,
                        0,
                        FILE_BEGIN );

        SetEndOfFile( FileMap->FileHandle );
    }

    CloseHandle( FileMap->FileHandle );

    free( FileMap );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\diskmon.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    diskmon.c

Abstract:

    This module contians the code for the disk monitor utility.

Author:

    Chuck Park (chuckp) 10-Feb-1994
    Mike Glass (mglass)

Revision History:


--*/
#include "diskmon.h"
#include "gauge.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

PCHAR
*GetAttachedDrives(
    PINT NumberDrives
    );

VOID
CalcStats(
    PDISK list,
    BOOL  initial
    );


VOID
ZeroList(
    PDISK list
    );

VOID
WriteStatText(
    VOID
    );

VOID
FormatTime(
    ULONG Time
    );



DISK      TotalDrives;
PDISK     DriveList = NULL,
          SelectedDrive = NULL;
HINSTANCE hInst;
HWND      hDataDlg,
          hMainWnd;
HMENU     MenuHandle,Popup = NULL;
UINT      ActiveDrives = 0;

CHAR      AppName[]     = "diskmon";
CHAR      Title[]       = "Disk Performance Monitor";
CHAR      TimerText[]   = "00:00:00:00";
CHAR      labels[9][17] =  {"BPS Read",
                            "BPS Write",
                            "Ave. BPS Read",
                            "Ave. BPS Write",
                            "Ave. BPS Xfer",
                            "Cur Queue",
                            "Ave Queue",
                            "Max Queue",
                            "Requests / Sec"
                            };


HWND      currentDrvHandle,
          totalDrvHandle,
          staticHandle[18],
          selectedDriveId,
          TimerTextId;

INT       cx,
          cy;
INT       Seconds,
          Minutes,
          Hours,
          Days;
ULONG     ElapsedTime = 0;



int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int   CmdShow
    )
{

    MSG msg;
    HANDLE hAccelTable;

    if (!hPrevInstance) {
        if (!InitApplication(hInstance)) {
            return (FALSE);
        }
    }

    if (!InitInstance(hInstance, CmdShow)) {
            return (FALSE);
    }

    hAccelTable = LoadAccelerators (hInstance, AppName);

    while (GetMessage(&msg,NULL,0,0) ) {
        if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }


    return (int)msg.wParam;

    lpCmdLine;
}



BOOL InitApplication(HINSTANCE hInstance)
{

    WNDCLASS  wc;

    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = WndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;
    wc.hInstance      = hInstance;
    wc.hIcon            = LoadIcon (hInstance, AppName);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);
    wc.lpszMenuName  = "DiskmonMenu";
    wc.lpszClassName = AppName;

    if (!RegisterClass(&wc))
        return FALSE;


    if(!RegisterGauge(hInstance))
        return FALSE;

    return TRUE;
}


BOOL InitInstance(
    HINSTANCE hInstance,
    int       CmdShow
    )

{
    CHAR             buffer[80];
    DISK_PERFORMANCE perfbuf;
    DWORD            BytesReturned;
    HANDLE           handle;
     HWND                hWnd;
    INT              height,
                     width;

    hInst = hInstance;

    cx     = 70;
    cy     = 70;
    width  =  7;
    height =  7;

    //
    //Create the main window.
    //

    hWnd = CreateWindow(
            AppName,
            Title,
            WS_CAPTION | WS_SYSMENU,
            20,20,
            cx * width,
            cy * height,
            NULL,
            NULL,
            hInstance,
            NULL
            );

    if (!hWnd) {
        return (FALSE);
    }

    //
    // If the IOCTL GET_DISK_PERF returns ERROR_INVALID_FUNCTION, let the user
    // know that Diskperf.sys is not started.
    //

    handle = CreateFile("\\\\.\\PhysicalDrive0",
                        GENERIC_READ,
                        FILE_SHARE_READ
                            | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (handle == INVALID_HANDLE_VALUE) {
        MessageBox(NULL,"Couldn't open a drive.","Error.",
            MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    if (!DeviceIoControl (handle,
                          IOCTL_DISK_PERFORMANCE,
                          NULL,
                          0,
                          &perfbuf,
                          sizeof(DISK_PERFORMANCE),
                          &BytesReturned,
                          NULL
                          )) {
        if (GetLastError() == ERROR_INVALID_FUNCTION) {

            sprintf(buffer,"Diskperf.sys is not started on your system.\n Start the driver and reboot.");
            MessageBox(NULL,buffer,"Error",MB_ICONEXCLAMATION | MB_OK);
            return FALSE;
        }
    }

    CloseHandle(handle);

    ShowWindow(hWnd, CmdShow);
    UpdateWindow(hWnd);
    hMainWnd = hWnd;

    return TRUE;

}

LRESULT CALLBACK
WndProc(
    HWND hWnd,
    UINT message,
    WPARAM uParam,
    LPARAM lParam
    )
{
    CHAR              buffer[20];
    INT               wmId,
                      wmEvent,
                      x,
                      y,
                      minValue,
                      maxValue,
                      menuIndex,
                      i,
                      j;
    static HBRUSH     brush;
    HDC               DC;
    PAINTSTRUCT       ps;
    PDISK             current;
    RECT              childRect;
    POINT             point;

    switch (message) {

    case WM_CREATE:

        MenuHandle = GetMenu(hWnd);
        brush = GetStockObject(DKGRAY_BRUSH);

        x = cx / 3;
        y = cy / 3;
        minValue = 0;
        maxValue = 5000;

        //
        //Create gauge windows
        //

        currentDrvHandle = CreateGauge (hWnd,hInst,
                                        x,y,cx*3,cy*2,
                                        minValue,maxValue);

        x =  cx * 3 + ((cx * 2) / 3) ;

        totalDrvHandle = CreateGauge (hWnd,hInst,
                                      x,y,cx*3,cy*2,
                                      minValue,maxValue*8);

        if (!currentDrvHandle || !totalDrvHandle) {
            DestroyWindow(hWnd);
        }

        //
        //Allocate and zero mem for the totaldrive structs.
        //

        TotalDrives.start = (PDISK_PERFORMANCE)malloc(sizeof(DISK_PERFORMANCE));
        if (!TotalDrives.start){
            return 1;
        }
        TotalDrives.current = (PDISK_PERFORMANCE)malloc(sizeof(DISK_PERFORMANCE));
        if (!TotalDrives.current) {
            free(TotalDrives.start);
            return 1;
        }
        TotalDrives.previous = (PDISK_PERFORMANCE)malloc(sizeof(DISK_PERFORMANCE));
        if (!TotalDrives.previous) {
            free(TotalDrives.current);
            free(TotalDrives.start);
            return 1;
        }

        memset (TotalDrives.start, 0x0,sizeof(DISK_PERFORMANCE));
        memset (TotalDrives.current, 0x0,sizeof(DISK_PERFORMANCE));
        memset (TotalDrives.previous, 0x0,sizeof(DISK_PERFORMANCE));

        TotalDrives.MaxQDepth = 0;
        TotalDrives.QDepth    = 0;

        InvalidateRect(currentDrvHandle,NULL,TRUE);
        InvalidateRect(totalDrvHandle,NULL,TRUE);
        UpdateWindow(currentDrvHandle);
        UpdateWindow(totalDrvHandle);


        //
        //Create static text controls.
        //

        for (j = 1;j < 3;j++ ) {
            for (i = 0; i < 9 ; i++ ) {
                CreateWindow("static",
                              labels[i],
                              WS_CHILD | WS_VISIBLE | SS_LEFT,
                              (INT)( ((cx / 3) * j) + ((j - 1) * cx * 3)),
                              (INT)(cy * 3 + 20 * i),
                              (INT)(cx * 1.7),
                              (INT)(cy / 3),
                              hWnd,
                              (HMENU)IntToPtr(i | j << 8),
                              hInst,
                              NULL);
            }
        }


        for (j = 1;j < 3 ; j++ ) {
            for (i = 0; i < 9 ; i++ ) {
                staticHandle[i + ((j-1) * 9)] =
                    CreateWindow("static",
                                 "0",
                                 WS_CHILD | WS_VISIBLE | SS_RIGHT,
                                 (INT)( ((cx * 2)+cx/3*(j-1) ) + ((j - 1) * cx * 3)),
                                 (INT)(cy * 3 + 20 * i),
                                 (INT)(cx * 1.3),
                                 (INT)(cy / 3),
                                 hWnd,
                                 (HMENU)IntToPtr(i | j << 8),
                                 hInst,
                                 NULL);
            }
        }

        //
        //Create Selected drive id control and All drives control
        //

        selectedDriveId = CreateWindow("static",
                                      "",
                                      WS_CHILD | WS_VISIBLE | SS_LEFT,
                                      (INT)( cx * 1.3),
                                      (INT)(cy * 2.7),
                                      (INT)(cx * 1.5),
                                      (INT)(cy / 3),
                                      hWnd,
                                      (HMENU)(25),
                                      hInst,
                                      NULL);

        CreateWindow("static","All Active Drives",
                     WS_CHILD | WS_VISIBLE | SS_LEFT,
                     (INT)( cx * 4.6),
                     (INT)(cy * 2.7),
                     (INT)(cx * 2.0),
                     (INT)(cy / 3),
                     hWnd,
                    (HMENU)(26),
                    hInst,
                    NULL);

        TimerTextId = CreateWindow("static","00:00:00:00",
                                 WS_CHILD | WS_VISIBLE | SS_LEFT,
                                 (INT)(cx * 3),
                                 (INT)(cy * .5),
                                 (INT)(cx * 1.5),
                                 (INT)(cy / 3),
                                 hWnd,
                                 (HMENU)(26),
                                 hInst,
                                 NULL);

        break;

    case WM_CTLCOLORSTATIC:


        SetStretchBltMode((HDC)uParam,HALFTONE);

        //
        // Get the original brush origins
        //

        GetBrushOrgEx((HDC)uParam,&point);

        //
        // Get the extents of the child window.
        //

        GetWindowRect((HWND)lParam,&childRect);

        //
        // Set new brush origin
        //

        SetBrushOrgEx((HDC)uParam,childRect.left,childRect.top,&point);

        //
        //Set the color of text and background for the static controls
        //

        SetBkMode ((HDC)uParam,TRANSPARENT);
        SetBkColor ((HDC)uParam,(COLORREF)PtrToUlong(brush));
        SetTextColor ((HDC)uParam, RGB(255,255,255));

        //
        // restore the original brush origin
        //

        return (LRESULT)brush;

    case WM_PAINT:

        DC = BeginPaint (hWnd,&ps);


        SetStretchBltMode(DC,BLACKONWHITE);
        //RealizePalette(DC);

        //
        // Force repaint of the gauges.
        //

        InvalidateRect (currentDrvHandle,NULL,TRUE);
        InvalidateRect (totalDrvHandle,NULL,TRUE);
        InvalidateRect (TimerTextId,NULL,TRUE);

        EndPaint (hWnd,&ps);

        break;

    case WM_TIMER:
        ++ElapsedTime;
        FormatTime (ElapsedTime);
        SetWindowText(TimerTextId,TimerText);

        CalcStats (DriveList,FALSE);

        //
        //Determine currently selected drive and update
        //the gauge.
        //

        UpdateGauge(currentDrvHandle,(INT)(SelectedDrive->AveBPS / 1000));

        //
        //Calc total stats and update active drives gauge.
        //

        UpdateGauge(totalDrvHandle,(INT)(TotalDrives.AveBPS / (1000)));
        WriteStatText();

        break;

        case WM_COMMAND:
            wmId    = LOWORD(uParam);
            wmEvent = HIWORD(uParam);

            if (wmId >= ID_DRV0 && wmId <= ID_DRV0 + 32) {

                //
                //Uncheck currently selected drive.
                //

                CheckMenuItem (Popup,SelectedDrive->MenuId,
                               MF_BYPOSITION | MF_UNCHECKED);

                //
                //Determine which drive, make it the selected drive,
                //and check it.
                //

                current = DriveList;
                while ( current && (current->MenuId != wmId - ID_DRV0)) {
                    current = current->next;
                }
                SelectedDrive = current;
                CheckMenuItem (Popup,SelectedDrive->MenuId,
                               MF_BYPOSITION | MF_CHECKED);

                //
                //Update the drive Id static control
                //

                SetWindowText (selectedDriveId,SelectedDrive->DrvString);

                break;
            }

            switch (wmId) {

            case IDM_VIEW:

                //
                // TODO: Not yet implemented.
                //

                break;
            case IDM_RESET:

                //
                // Zero all disk data
                //

                ZeroList (DriveList);

                //
                // Disable reset
                //

                EnableMenuItem (GetMenu(hWnd),IDM_RESET,MF_GRAYED);
                DrawMenuBar (hWnd);

                //
                // Show zero'ed info.
                //

                UpdateGauge(currentDrvHandle,0);
                UpdateGauge(totalDrvHandle,0);
                WriteStatText();

                break;
            case IDM_CHOOSE:


                DialogBox(hInst,
                          "DISKDLG",
                          hWnd,
                          (DLGPROC)ConfigMonitor
                          );
                //
                //If any drives were selected, set up the remaining
                //fields in the structures.
                //

                if (DriveList) {

                    //
                    //Delete the old "Drive" menu if it exists and
                    //create a new one.
                    //

                    if (Popup) {
                        DeleteMenu (GetMenu(hWnd),3,MF_BYPOSITION);
                        DrawMenuBar (hWnd);
                    }
                    Popup = CreatePopupMenu ();
                    menuIndex = 1;

                    current = DriveList;
                    while (current) {

                        //
                        //Open the drive
                        //

                        sprintf (buffer,"\\\\.\\");
                        strcat (buffer,current->DrvString);

                        current->handle = CreateFile(buffer,
                                              GENERIC_READ,
                                              FILE_SHARE_READ
                                                  | FILE_SHARE_WRITE,
                                              NULL,
                                              OPEN_EXISTING,
                                              FILE_ATTRIBUTE_NORMAL,
                                              NULL);

                        if (current->handle == INVALID_HANDLE_VALUE) {
                            MessageBox(NULL,"Couldn't open a drive.","Error.",
                                MB_ICONEXCLAMATION | MB_OK);
                            DestroyWindow(hWnd);
                        }

                        //
                        //Allocate memory for each of the DISK_PERFORMANCE
                        //structures.
                        //

                        current->start =
                            (PDISK_PERFORMANCE) malloc(sizeof(DISK_PERFORMANCE));
                        current->current =
                            (PDISK_PERFORMANCE) malloc(sizeof(DISK_PERFORMANCE));
                        current->previous =
                            (PDISK_PERFORMANCE) malloc(sizeof(DISK_PERFORMANCE));

                        if (!(current->start && current->current
                                  && current->previous)) {

                            MessageBox(NULL,"Couldn't allocate memory.","Error.",
                                MB_ICONEXCLAMATION | MB_OK);
                            DestroyWindow(hWnd);
                        }


                        //
                        //Add to the Popup menu
                        //

                        if (menuIndex == 1) {
                            AppendMenu (Popup,MF_STRING | MF_BYPOSITION,
                                        ID_DRV0 + ActiveDrives - menuIndex++,
                                        current->DrvString);

                        } else {

                            InsertMenu (Popup,0,
                                        MF_STRING | MF_BYPOSITION,
                                        ID_DRV0 + ActiveDrives - menuIndex++,
                                        current->DrvString);
                        }

                        current = current->next;
                    }

                    //
                    //Start with first PhysicalDrive choosen being the currently
                    //selected drive.
                    //


                    SelectedDrive = DriveList;
                    while (SelectedDrive->next) {
                        SelectedDrive = SelectedDrive->next;
                    }

                    AppendMenu (GetMenu(hWnd),MF_POPUP,(INT_PTR)Popup,"Dri&ve");

                    //
                    //Put check mark next to selected drive.
                    //

                    CheckMenuItem (Popup,SelectedDrive->MenuId,
                                   MF_BYPOSITION | MF_CHECKED);
                    //
                    //Set the drive id control
                    //

                    SetWindowText (selectedDriveId,SelectedDrive->DrvString);

                    //
                    //Enable the start menu item.
                    //

                    EnableMenuItem (GetMenu(hWnd),IDM_START,MF_ENABLED);
                    DrawMenuBar (hWnd);

                }
                break;

            case IDM_START:
                SetTimer(hWnd,ID_TIMER,1000,(TIMERPROC)NULL);

                //
                //Get initial values for each drive.
                //

                CalcStats(DriveList,TRUE);

                ModifyMenu (GetMenu(hWnd),
                            IDM_START,
                            MF_BYCOMMAND,
                            IDM_STOP,
                            "Sto&p");

                EnableMenuItem (GetMenu(hWnd),IDM_CHOOSE,MF_GRAYED);


                DrawMenuBar(hWnd);


                break;

            case IDM_STOP:

                EnableMenuItem (GetMenu(hWnd),IDM_RESET,MF_ENABLED);
                KillTimer(hWnd, ID_TIMER);
                ModifyMenu (GetMenu(hWnd),
                            IDM_STOP,
                            MF_BYCOMMAND,
                            IDM_START,
                            "S&tart");

                EnableMenuItem (GetMenu(hWnd),IDM_CHOOSE,MF_ENABLED);


                DrawMenuBar(hWnd);

                break;

            case IDM_EXIT:
                DestroyWindow (hWnd);
                break;

            default:
                return (DefWindowProc(hWnd, message, uParam, lParam));
            }
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return (DefWindowProc(hWnd, message, uParam, lParam));
    }

    return (0);
}



BOOL
CALLBACK
ConfigMonitor(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL     Processed = TRUE;
static INT   NumberCurrentDrives = 0;
    INT      selectedDrvBuf[32],
             i;
    CHAR     (*drvs)[16],
             buffer[16];
    PDISK    drive;

    switch (Msg) {
    case WM_INITDIALOG:

        //
        // Determine the currently installed PhysicalDrives
        //

        (char **)drvs = GetAttachedDrives(&NumberCurrentDrives);
        if (!drvs) {
            break;
        }

        //
        // Load the listbox with the installed drives.
        //

        for (i = 0;i < NumberCurrentDrives ;i++ ) {
            SendDlgItemMessage (hDlg,ID_LB,LB_ADDSTRING,
                                0,(LPARAM)(LPCTSTR)drvs[i]);
        }

        //
        // Release the strings allocated in GetAttachedDrives
        //

        free (drvs);

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_LB:

            //
            // Message for the drive list box.
            //

            if ( HIWORD(wParam) == LBN_DBLCLK || HIWORD(wParam) == LBN_SELCHANGE ) {
                if (!IsWindowEnabled(GetDlgItem(hDlg,IDOK))) {
                     EnableWindow(GetDlgItem(hDlg,IDOK),TRUE);
                }  else {
                    if(!SendDlgItemMessage (hDlg,ID_LB,LB_GETSELCOUNT,0,0)) {
                        EnableWindow(GetDlgItem(hDlg,IDOK),FALSE);
                    }
                }
            }

            break;

        case IDOK:

            //
            //Poison the selection array
            //

            for (i = 0; i < 32; i++ ) {
                selectedDrvBuf[i] = -1;
            }

            //
            // If already configed free up all old stuff.
            //

            if (DriveList) {
                ActiveDrives = 0;
                drive = DriveList;
                while (drive) {
                    if (drive->start) {
                        free (drive->start);
                    }
                    if (drive->current) {
                        free (drive->current);
                    }
                    if (drive->previous) {
                        free (drive->previous);
                    }
                    CloseHandle (drive->handle);
                    drive = drive->next;
                }
                free(DriveList);
                DriveList = NULL;
            }

            //
            //Determine which drives are selected.
            //

            ActiveDrives = (UINT)SendDlgItemMessage (hDlg,ID_LB,LB_GETSELITEMS,(WPARAM)NumberCurrentDrives,
                                (LPARAM)(LPINT)selectedDrvBuf);

            for (i = 0;i < (INT)ActiveDrives ; i++ ) {
                if ( selectedDrvBuf[i] != -1 && selectedDrvBuf[i] < NumberCurrentDrives) {

                    //
                    // One more check because return from GETSELITEMS is
                    // sometimes bogus.
                    //

                    if (!SendDlgItemMessage (hDlg,ID_LB,LB_GETSEL,(WPARAM)selectedDrvBuf[i],0)) {
                        MessageBox(NULL,"Bogus val from GETSELITEMS","BUG",MB_OK);
                        continue;
                    }

                    //
                    //Allocate mem. and link into DISK list.
                    //

                    if ((drive = (PDISK) malloc(sizeof(DISK)))==NULL) {
                        MessageBox(NULL,"Couldn't allocate memory.","Error",
                                   MB_ICONEXCLAMATION | MB_OK);
                        EndDialog (hDlg,wParam);
                        break;
                    }

                    //
                    //pull out the string from the list box.
                    //

                    SendDlgItemMessage (hDlg,ID_LB,LB_GETTEXT,selectedDrvBuf[i],
                                        (LPARAM)(LPCTSTR)buffer);

                    strcpy (drive->DrvString,buffer);

                    //
                    // Init rest of structure
                    //

                    drive->BytesRead    = 0;
                    drive->BytesWritten = 0;
                    drive->QDepth       = 0;
                    drive->MaxQDepth    = 0;
                    drive->next         = NULL;
                    drive->MenuId       = i;

                    //
                    // Link into the list of selected drives
                    //

                    if ( !DriveList ) {
                        DriveList = drive;
                    } else {
                        drive->next = DriveList;
                        DriveList = drive;
                    }
                }
            }

            //
            //Fall through to EndDialog
            //

        case IDCANCEL:

            EndDialog(hDlg, wParam);
            break;

        default:
            Processed = FALSE;
            break;
        }
    default:
       Processed = FALSE;
       break;
    }
    return(Processed);

}

PCHAR
*GetAttachedDrives(
    PINT NumberDrives
    )
{
    BOOL  ValidDrive = FALSE;
    CHAR (*drivestrings)[16];
    CHAR  buffer[21];
    HANDLE handle;
    INT    i = 0;

    *NumberDrives = 0;

    do {

        //
        // Try to open each disk starting with 0, if it is present,
        // continue. When last is found, exit the loop.
        //

        ValidDrive = FALSE;

        sprintf(buffer,"\\\\.\\PhysicalDrive%d",i);

        handle = CreateFile(buffer,
                            GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (handle != INVALID_HANDLE_VALUE) {
            ValidDrive = TRUE;
            ++(*NumberDrives);
            ++i;
            CloseHandle(handle);
        }

    } while (ValidDrive);

    //
    // Allocate mem for array of char strings and
    // copy "PhysicalDriveX" into each.
    //

    drivestrings =  malloc ((16 * *NumberDrives));
    if (!drivestrings) {
        return NULL;
    }

    for (i = 0;i < *NumberDrives ; i++ ) {
        sprintf (drivestrings[i],"PhysicalDrive%d",i);
    }

    return (char **)drivestrings;
}

VOID
CalcStats(
    PDISK list,
    BOOL  initial
    )
{
    BOOL             retval = FALSE;
    CHAR             errorbuf[25];
    DWORD            BytesReturned;
    LARGE_INTEGER    liVal,
                     BytesRead,
                     BytesWritten,
                     curBytesRead,
                     curBytesWritten;
    PDISK            newvals = list,
                     curdisk = list;
    UINT             tmpQDepth = 0;



    BytesRead.QuadPart    = 0;
    BytesWritten.QuadPart = 0;
    TotalDrives.current->QueueDepth = 0;
    TotalDrives.current->ReadCount = 0;
    TotalDrives.current->WriteCount = 0;
    TotalDrives.current->BytesRead.QuadPart = 0;
    TotalDrives.current->BytesWritten.QuadPart = 0;


    //
    //Issue disk perf IOCTL on each drive in list.
    //

    while (curdisk) {
        curBytesRead.QuadPart = 0;

        *(curdisk->previous) = *(curdisk->current);


        retval = DeviceIoControl (curdisk->handle,
                                  IOCTL_DISK_PERFORMANCE,
                                  NULL,
                                  0,
                                  curdisk->current,
                                  sizeof(DISK_PERFORMANCE),
                                  &BytesReturned,
                                  NULL
                                  );

        if (!retval) {
            sprintf(errorbuf,"IOCTL returned error %x",GetLastError());
            MessageBox(NULL,errorbuf,"Error",MB_ICONEXCLAMATION | MB_OK);
            break;
        }
        if (initial) {
            *(curdisk->start) = *(curdisk->current);
            *(curdisk->previous) = *(curdisk->current);
            curdisk->AveBPS = 0;
            curdisk->MaxBPS = 0;
        } else {

            //
            //Calc the averages and per disk totals
            //

            curBytesRead.QuadPart = curdisk->current->BytesRead.QuadPart -
                                    curdisk->previous->BytesRead.QuadPart;
            curBytesWritten.QuadPart = curdisk->current->BytesWritten.QuadPart -
                                       curdisk->previous->BytesWritten.QuadPart;

            BytesRead.QuadPart = BytesRead.QuadPart + curBytesRead.QuadPart;
            BytesWritten.QuadPart = BytesWritten.QuadPart + curBytesWritten.QuadPart;

            liVal.QuadPart = curBytesRead.QuadPart + curBytesWritten.QuadPart;
            curdisk->AveBPS = (ULONG)liVal.QuadPart;

            curdisk->BytesRead += (ULONG)curBytesRead.QuadPart;
            curdisk->BytesWritten += (ULONG)curBytesWritten.QuadPart;
            curdisk->QDepth += curdisk->current->QueueDepth;

            curdisk->MaxQDepth = (curdisk->current->QueueDepth >
                                  curdisk->MaxQDepth) ?
                                      curdisk->current->QueueDepth :
                                      curdisk->MaxQDepth;
            TotalDrives.QDepth += curdisk->current->QueueDepth;
            TotalDrives.current->QueueDepth += curdisk->current->QueueDepth;
            tmpQDepth += curdisk->current->QueueDepth;
            TotalDrives.current->ReadCount += curdisk->current->ReadCount-curdisk->previous->ReadCount;
            TotalDrives.current->WriteCount += curdisk->current->WriteCount - curdisk->previous->WriteCount;

            TotalDrives.current->BytesRead.QuadPart = TotalDrives.current->BytesRead.QuadPart +
                                                      curBytesRead.QuadPart;
            TotalDrives.current->BytesWritten.QuadPart = TotalDrives.current->BytesWritten.QuadPart +
                                                         curBytesWritten.QuadPart;

        }
        curdisk = curdisk->next;
    }

    //
    // Calculate total active drive stats.
    //

    TotalDrives.AveBPS = (ULONG)(BytesRead.QuadPart + BytesWritten.QuadPart);

    TotalDrives.previous->BytesRead.QuadPart = TotalDrives.previous->BytesRead.QuadPart +
                                               BytesRead.QuadPart;
    TotalDrives.previous->BytesWritten.QuadPart =
        TotalDrives.previous->BytesWritten.QuadPart + BytesWritten.QuadPart;

    TotalDrives.MaxQDepth = (TotalDrives.MaxQDepth > tmpQDepth) ?
                             TotalDrives.MaxQDepth : tmpQDepth;

    list = newvals;
}


VOID
FormatTime(ULONG Time)
{

    ++Seconds;
    if (Seconds % 60  == 0) {
        ++Minutes;
        Seconds = 0;

        if(Minutes % 60 == 0) {
            ++Hours;
            Minutes = 0;

            if(Hours % 24 == 0) {
                ++Days;
                Hours = 0;
            }
        }
    }

    sprintf(TimerText,"%02d:%02d:%02d:%02d",Days,Hours,Minutes,Seconds);
}

VOID
ZeroList(
    PDISK list
    )
{
    PDISK curdrive = list;

    memset (TotalDrives.start, 0x0,sizeof(DISK_PERFORMANCE));
    memset (TotalDrives.current, 0x0,sizeof(DISK_PERFORMANCE));
    memset (TotalDrives.previous, 0x0,sizeof(DISK_PERFORMANCE));

    TotalDrives.MaxQDepth = 0;
    TotalDrives.QDepth    = 0;
    TotalDrives.AveBPS    = 0;
    TotalDrives.MaxBPS    = 0;
    TotalDrives.BytesRead    = 0;
    TotalDrives.BytesWritten = 0;


    while (curdrive) {
        memset (curdrive->start,0x0,sizeof(DISK_PERFORMANCE));
        memset (curdrive->current,0x0,sizeof(DISK_PERFORMANCE));
        memset (curdrive->previous,0x0,sizeof(DISK_PERFORMANCE));

        curdrive->AveBPS = 0;
        curdrive->MaxBPS = 0;
        curdrive->BytesRead = 0;
        curdrive->BytesWritten = 0;
        curdrive->QDepth = 0;
        curdrive->MaxQDepth = 0;

        curdrive = curdrive->next;
    }
    CalcStats (list,TRUE);
    SelectedDrive->current->QueueDepth = 0;

    Seconds = 0;
    Minutes = 0;
    Hours = 0;
    Days = 0;
    ElapsedTime = 1;
    sprintf (TimerText,"00:00:00:00");

}

VOID
WriteStatText(
    VOID
    )
{
    LARGE_INTEGER Val,BytesRead,BytesWritten;

    CHAR              buffer[20];

        //
        // BPS Read
        //

        BytesRead.QuadPart = SelectedDrive->current->BytesRead.QuadPart -
                             SelectedDrive->previous->BytesRead.QuadPart;
        sprintf(buffer,"%.0Lu%Lu",BytesRead.HighPart,BytesRead.LowPart);
        SetWindowText(staticHandle[0],buffer);

        //
        // BPS Write
        //

        BytesWritten.QuadPart = SelectedDrive->current->BytesWritten.QuadPart -
                                SelectedDrive->previous->BytesWritten.QuadPart;
        sprintf(buffer,"%.0Lu%Lu",BytesWritten.HighPart,BytesWritten.LowPart);
        SetWindowText(staticHandle[1],buffer);

        //
        // Ave. BPS Read
        //

        BytesRead.QuadPart = SelectedDrive->current->BytesRead.QuadPart +
                             SelectedDrive->start->BytesRead.QuadPart;
        Val.QuadPart = BytesRead.QuadPart / ElapsedTime;                                                 //  1 10 BPS Write",
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);                                            //  2 11 Ave. BPS Read",
        SetWindowText(staticHandle[2],buffer);                                                           //  3 12 Ave. BPS Write",
                                                                                                         //  4 13 Ave. BPS Xfer",
        //                                                                                               //  5 14 Cur Queue",
        // Ave. BPS Write                                                                                //  6 15 Ave Queue",
        //                                                                                               //  7 16 Max Queue",
                                                                                                         //  8 17 Requests / Sec"
        BytesWritten.QuadPart = SelectedDrive->current->BytesWritten.QuadPart +
                                SelectedDrive->start->BytesWritten.QuadPart;
        Val.QuadPart = BytesWritten.QuadPart / ElapsedTime;
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);
        SetWindowText(staticHandle[3],buffer);

        //
        // Ave. BPS Total
        //

        Val.QuadPart = (BytesRead.QuadPart + BytesWritten.QuadPart) / ElapsedTime;
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);
        SetWindowText (staticHandle[4],buffer);


        //
        // Current Queue depth
        //

        sprintf (buffer, "%Lu",SelectedDrive->current->QueueDepth);
        SetWindowText (staticHandle[5],buffer);

        //
        // Ave. Queue depth
        //

        sprintf (buffer, "%Lu",SelectedDrive->QDepth / ElapsedTime);
        SetWindowText (staticHandle[6],buffer);

        //
        // Max Q
        //

        sprintf (buffer, "%Lu",SelectedDrive->MaxQDepth);
        SetWindowText (staticHandle[7],buffer);

        //
        // Requests / Sec
        //

        sprintf (buffer, "%Lu",SelectedDrive->current->ReadCount-SelectedDrive->previous->ReadCount +
                               SelectedDrive->current->WriteCount-SelectedDrive->previous->WriteCount);
        SetWindowText (staticHandle[8],buffer);


        //
        //  Total drives Stats
        //



        //
        // BPS Read
        //

        sprintf(buffer,"%.0Lu%Lu",TotalDrives.current->BytesRead.HighPart,
                                  TotalDrives.current->BytesRead.LowPart);
        SetWindowText(staticHandle[9],buffer);

        sprintf(buffer,"%.0Lu%Lu",TotalDrives.current->BytesWritten.HighPart,
                                  TotalDrives.current->BytesWritten.LowPart);
        SetWindowText(staticHandle[10],buffer);

        Val.QuadPart = TotalDrives.previous->BytesRead.QuadPart / ElapsedTime;
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);
        SetWindowText(staticHandle[11],buffer);

        Val.QuadPart = TotalDrives.previous->BytesWritten.QuadPart / ElapsedTime;
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);
        SetWindowText(staticHandle[12],buffer);

        Val.QuadPart = (TotalDrives.previous->BytesWritten.QuadPart +
                        TotalDrives.previous->BytesRead.QuadPart) /  ElapsedTime;
        sprintf (buffer,"%.0Lu%Lu",Val.HighPart,Val.LowPart);
        SetWindowText (staticHandle[13],buffer);

        sprintf (buffer,"%Lu",TotalDrives.current->QueueDepth);
        SetWindowText (staticHandle[14],buffer);

        sprintf (buffer, "%Lu",TotalDrives.QDepth / ElapsedTime);
        SetWindowText (staticHandle[15],buffer);

        sprintf (buffer, "%Lu",TotalDrives.MaxQDepth);
        SetWindowText (staticHandle[16],buffer);

        sprintf (buffer, "%Lu",TotalDrives.current->ReadCount + TotalDrives.current->WriteCount);
        SetWindowText (staticHandle[17],buffer);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\id.h ===
#define   IDM_EXIT       200
#define   IDM_VIEW       201
#define   IDM_CHOOSE     203
#define   IDM_SELECT     204
#define   IDM_START      205
#define   IDM_STOP       206
#define   ID_DRV0        207

//
// 207-239 are taken by drive ids
//

#define   ID_TIMER       300
#define   IDM_RESET      308

#define   ID_LB          400
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\diskmon.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <windows.h>
#include "id.h"

typedef struct _DISK {
    HANDLE            handle;
    PDISK_PERFORMANCE start;
    PDISK_PERFORMANCE current;
    PDISK_PERFORMANCE previous;
    ULONG             AveBPS;
    ULONG             MaxBPS;
    ULONG             BytesRead;
    ULONG             BytesWritten;
    UINT              QDepth;
    UINT              MaxQDepth;
    INT              MenuId;
    CHAR              DrvString[16];
    CHAR              Identifier[24];
    struct _DISK      *next;
} DISK, *PDISK;

BOOL
InitApplication(
    HANDLE
    );

BOOL
InitInstance(
    HANDLE,
    int
    );

LRESULT CALLBACK
WndProc(
    HWND,
    UINT,
    WPARAM,
    LPARAM
    );


LRESULT CALLBACK
DiskmonWndProc(
    HWND hWnd,
    UINT message,
    WPARAM uParam,
    LPARAM lParam
    );


BOOL CALLBACK
ConfigMonitor(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\gauge.h ===
typedef struct _GAUGEVALS {
    int   curValue;
    int   minValue;
    int   maxValue;
    POINT base;
    POINT top;
    HWND  handle;
    struct _GAUGEVALS *next;
} GAUGEVALS, *PGAUGEVALS;

BOOL
RegisterGauge(
    HINSTANCE hInstance
    );

HWND
CreateGauge(
    HWND parent,
    HINSTANCE hInstance,
    INT  x,
    INT  y,
    INT  width,
    INT  height,
    INT  minVal,
    INT  maxVal
    );


VOID
DestroyGauge(
    HWND  GaugeHandle
    );


LRESULT CALLBACK GaugeWndProc(
    HWND hWnd,
    UINT message,
    WPARAM uParam,
    LPARAM lParam
    );

VOID
UpdateGauge(
    HWND  handle,
    INT   value
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskmon\gauge.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gauge.c

Abstract:

    This module contains the code for the gauge window class used
    with the diskmon utility.

Author:

    Chuck Park (chuckp) 10-Feb-1994
    Mike Glass (mglass)

Revision History:


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "gauge.h"

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>


BOOL
IndicatorOverText(
    DOUBLE radians
    );

VOID
DrawDial(
    HWND  handle
    );

VOID
DrawGaugeText(
    HANDLE handle
    );

HPEN       ArcPen,
           IndicatorPen,
           CoverPen,
           TickMarkPen;

INT        cx, cy;
PGAUGEVALS head;
RECT       LeftTick,
           RightTick;


BOOL
RegisterGauge(
    HINSTANCE hInstance
    )
{

    WNDCLASS  wc;

	wc.style	     = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc	 = (WNDPROC)GaugeWndProc;
	wc.cbClsExtra	 = 0;
	wc.cbWndExtra	 = 4;
	wc.hInstance	 = hInstance;
	wc.hIcon	     = NULL;
	wc.hCursor	     = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = "GaugeClass";

    return RegisterClass(&wc);
}



HWND
CreateGauge(
    HWND parent,
    HINSTANCE hInstance,
    INT  x,
    INT  y,
    INT  width,
    INT  height,
    INT  minVal,
    INT  maxVal
    )
{
    static INT winId = 0;
    HWND   handle;
    PGAUGEVALS  curvals;

    handle = CreateWindow("GaugeClass",
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        x,y,
                        width,
                        height,
                        parent,
                        (HMENU)IntToPtr(winId++),
                        hInstance,
                        NULL
                        );

    ShowWindow( handle, SW_SHOW) ;

    //
    //Allocate mem for GAUGEVALS (window specific info.)
    //

    if ((curvals = (PGAUGEVALS)malloc(sizeof(GAUGEVALS))) == NULL) {
        MessageBox(NULL,"Couldn't allocate memory for window.","Error",
                   MB_ICONEXCLAMATION | MB_OK);
        return NULL;
    }
    curvals->handle   = handle;
    curvals->minValue = minVal;
    curvals->maxValue = maxVal;
    curvals->curValue = 0;
    curvals->next     = NULL;

    //
    //Link into list.
    //

    if (head == NULL) {
        head = curvals;
    } else {
        curvals->next = head;
        head = curvals;
    }

    return handle;

}


LRESULT CALLBACK GaugeWndProc(
    HWND hWnd,
    UINT message,
    WPARAM uParam,
    LPARAM lParam
    )
{
    HDC  DC;

    switch (message) {
    case WM_CREATE:

        DC = GetDC(hWnd);

        //
        // Create Objects to be used in drawing the different parts
        // of the gauge.
        //

        ArcPen = CreatePen(PS_SOLID,GetSystemMetrics(SM_CXFRAME),RGB(255,0,0));
        IndicatorPen = CreatePen(PS_SOLID,GetSystemMetrics(SM_CXDLGFRAME),RGB(230,230,220));
        CoverPen = CreatePen(PS_SOLID,GetSystemMetrics(SM_CXDLGFRAME),RGB(0,0,0));
        TickMarkPen = CreatePen(PS_SOLID,(2*GetSystemMetrics(SM_CXBORDER)),RGB(255,255,0));

        cx = 70;
        cy = 70;

        LeftTick.top    = (INT)(cy * 2 - ((1.5 * cy) * sin (.78) ) );
        LeftTick.left   = (INT)(cx * 1.5 - ((1.5 * cx) * cos (.78)));
        LeftTick.bottom = (INT)(cy * 2 - ((1.4 * cy) * sin (.78) ) );
        LeftTick.right  = (INT)(cx * 1.5 - ((1.4 * cx) * cos (.78)));

        RightTick.top    = (INT)(cy * 2 - ((1.5 * cy) * sin (.78) ) );
        RightTick.left   = (INT)(cx * 1.5 + ((1.5 * cx) * cos (.78)));
        RightTick.bottom = (INT)(cy * 2 - ((1.4 * cy) * sin (.78) ) );
        RightTick.right  = (INT)(cx * 1.5 + ((1.4 * cx) * cos (.78)));

        ReleaseDC(hWnd,DC);
        break;

    case WM_PAINT:
        DrawDial(hWnd);
        break;

    case WM_DESTROY:

        DeleteObject (ArcPen);
        DeleteObject (IndicatorPen);
        DeleteObject (CoverPen);
        DeleteObject (TickMarkPen);

        break;

    default:
        return (DefWindowProc(hWnd, message, uParam, lParam));
    }

    return 0;
}


VOID
UpdateGauge(
    HWND  handle,
    INT   value
    )
{
    DOUBLE     radians;
    HDC        DC;
    INT        x,y;
    PGAUGEVALS current;
    POINT      pt,point;
    RECT       gaugeRect;

    current = head;
    while (current) {
        if (current->handle == handle) {
            break;
        }
        current = current->next;
    }
    current->curValue = value;

    DC = GetDC (handle);

    RealizePalette(DC);

    //
    // Get the original brush origins
    //

    GetBrushOrgEx(DC,&point);

    //
    // Get the extents of the child window.
    //

    GetWindowRect(handle,&gaugeRect);

    //
    // Set new brush origin
    //

    SetStretchBltMode(DC,HALFTONE);
    SetBrushOrgEx(DC,gaugeRect.left,gaugeRect.top,&point);

    //
    //Draw line over old indicator line
    //

    MoveToEx (DC,current->base.x, current->base.y, &pt);
    SelectObject(DC,CoverPen);
    LineTo (DC,current->top.x,current->top.y);
    SelectObject(DC,IndicatorPen);
    MoveToEx (DC,current->base.x, current->base.y, &pt);

    //
    //calc value adjusting it if over or under max/min.
    //

    if (current->curValue > current->maxValue) {
        current->curValue = current->maxValue;
    } else if (current->curValue < current->minValue) {
        current->curValue = current->minValue;
    }

    radians = (DOUBLE)(current->curValue * 3.14159) / (DOUBLE)(current->maxValue - current->minValue);

    x = (INT)(cx * (1.5 -  cos(radians)));
    y = (INT)(cy * (1.9 -  sin(radians)));

    LineTo (DC,x,y);
    current->top.x = x;
    current->top.y = y;


    ReleaseDC(handle,DC);

    DrawGaugeText( handle);

}

VOID
DrawDial(
    HWND  handle
    )
{

    CHAR        buffer[15];
    DOUBLE      radians;
    HDC         DC;
    INT         x,y;
    POINT       pt;
    PAINTSTRUCT ps;
    PGAUGEVALS  gaugevals;

    DC = BeginPaint(handle,&ps);

    SetBkMode(DC,TRANSPARENT);

    //
    //Find correct info for this window.
    //

    gaugevals = head;
    while (gaugevals) {
        if (gaugevals->handle == handle) {
            break;
        }
        gaugevals = gaugevals->next;
    }

    //
    // Draw the Arc for the gauge
    //

    MoveToEx ( DC, 0, cy * 2, &pt);
    SelectObject(DC,ArcPen);
    AngleArc (DC,
              (INT)(cx * 1.5),
              (INT)(cy * 2),
              (INT)(cy * 1.5),
              (float)0.0,
              (float)180.0
              );

    //
    //Fill in arc with black.
    //

    SelectObject(DC,GetStockObject(BLACK_BRUSH));
    ExtFloodFill (DC,5,cy*2 - 10,RGB(255,0,0),FLOODFILLBORDER);

    //
    // Draw the tick marks
    //

    SelectObject (DC, TickMarkPen);
    MoveToEx (DC, (INT)(cx * 1.5),(INT)( cy * .5), &pt);
    LineTo (DC, (INT)(cx * 1.5),(INT)(cy * .6));
    MoveToEx (DC, LeftTick.right, LeftTick.bottom, &pt);
    LineTo (DC, LeftTick.left, LeftTick.top);
    MoveToEx (DC, RightTick.right, RightTick.bottom, &pt);
    LineTo (DC, RightTick.left, RightTick.top);
    MoveToEx (DC, 0, (INT)(cy * 1.9), &pt);
    LineTo (DC, (INT)(cx * .1),(INT)(cy * 1.9));
    MoveToEx (DC, (INT)(cx * 3), (INT)(cy * 1.9), &pt);
    LineTo (DC, (INT)(cx * 2.9), (INT)(cy * 1.9));


    //
    // Max difference / curvalue = PI / radians
    //

    radians = (DOUBLE)(gaugevals->curValue * 3.14159) / (DOUBLE)(gaugevals->maxValue - gaugevals->minValue);

    MoveToEx (DC,(INT)(cx * 1.5), (INT)(cy * 1.9), &pt);
    SelectObject(DC,IndicatorPen);

    //
    //Save begin and end point in gaugevals.
    //

    gaugevals->base.x = (INT)(cx * 1.5);
    gaugevals->base.y = (INT)(cx * 1.9);

    //
    //Draw dial indicator as thick line.
    //

    y = (INT)(cy * (1.9 -  sin(radians)));
    x = (INT)(cx * (1.5 -  cos(radians)));

    gaugevals->top.x = x;
    gaugevals->top.y = y;

    LineTo(DC,x ,y );


    //
    //Draw indicator value text.
    //

    SetTextColor(DC,RGB(230,230,200));

    sprintf (buffer,"%Lu",gaugevals->minValue);
    TextOut (DC,(INT)(cx / 10),(INT)(cy * 1.70),buffer,strlen(buffer));

    sprintf (buffer,"%Lu",(gaugevals->maxValue - gaugevals->minValue) /4 );
    TextOut (DC,(INT)(cx * .4),(INT)(cy * 1.1 ), buffer, strlen(buffer));

    sprintf (buffer,"%Lu",(gaugevals->maxValue - gaugevals->minValue) / 2 );
    TextOut (DC,(INT)(cx * 1.3), (INT)(cy * .6) ,buffer,strlen(buffer));

    sprintf (buffer,"%Lu",((gaugevals->maxValue - gaugevals->minValue) / 4) * 3 );
    TextOut (DC,(INT)(cx * (2 + (gaugevals->maxValue > 10000 ? .1 : .2))),(INT)(cy * 1.1), buffer, strlen(buffer));

    sprintf(buffer,"%Lu",gaugevals->maxValue);
    TextOut(DC,(int)(cx * (2 + (gaugevals->maxValue > 10000 ? .4 : .5 ))), (INT)(cy * 1.70),buffer,strlen(buffer));



    EndPaint(handle,&ps);

}

VOID
DrawGaugeText(
    HANDLE handle
    )
{
    HDC DC;

    CHAR        buffer[15];
    PGAUGEVALS  gaugevals;

    //
    //Find correct info for this window.
    //

    gaugevals = head;
    while (gaugevals) {
        if (gaugevals->handle == handle) {
            break;
        }
        gaugevals = gaugevals->next;
    }

    DC = GetDC (handle);

    SetBkMode(DC,TRANSPARENT);
    SetTextColor(DC,RGB(230,230,200));

    sprintf (buffer,"%Lu",gaugevals->minValue);
    TextOut (DC,(INT)(cx / 10),(INT)(cy * 1.70),buffer,strlen(buffer));

    sprintf (buffer,"%Lu",(gaugevals->maxValue - gaugevals->minValue) /4 );
    TextOut (DC,(INT)(cx * .4),(INT)(cy * 1.1 ), buffer, strlen(buffer));

    sprintf (buffer,"%Lu",(gaugevals->maxValue - gaugevals->minValue) / 2 );
    TextOut (DC,(INT)(cx * 1.3), (INT)(cy * .6) ,buffer,strlen(buffer));

    sprintf (buffer,"%Lu",((gaugevals->maxValue - gaugevals->minValue) / 4) * 3 );
    TextOut (DC,(INT)(cx * (2 + (gaugevals->maxValue > 10000 ? .1 : .2))),(INT)(cy * 1.1), buffer, strlen(buffer));

    sprintf(buffer,"%Lu",gaugevals->maxValue);
    TextOut(DC,(int)(cx * (2 + (gaugevals->maxValue > 10000 ? .4 : .5 ))), (INT)(cy * 1.70),buffer,strlen(buffer));

    ReleaseDC (handle,DC);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dosdev\makefile.inc ===
$(O)\dosdev.res: dosdev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskperf\diskperf.h ===
/*++

    Copyright (c) 1991-1999  Microsoft Corporation

Module:

    diskperf.h

Abstract:

    definitions for diskperf.exe

Revision History:

    9-Dec-92 a-robw (Bob Watson)    Created

--*/
#ifndef _DISKPERF_H_
#define _DISKPERF_H_

#define DP_BOOT_START   0
#define DP_SYSTEM_START 1
#define DP_AUTO_START   2
#define DP_DEMAND_START 3
#define DP_NEVER_START  4
#define DP_UNDEFINED    5

// Dialog Box ID's
#define IDD_DP_EXPLAIN                  101
#define IDD_DP_HELP                     107
#define IDC_STATIC                      -1

//
//  Stringtable String ID's
//

#define DP_START_VALUE          100
#define DP_THIS_SYSTEM          101

#define DP_START_AT_BOOT        102
#define DP_START_AT_START       103
#define DP_START_AUTOMATICALLY  104
#define DP_START_ON_DEMAND      105
#define DP_START_NEVER          106
#define DP_START_UNDEFINED      107
#define DP_LOAD_STATUS_BASE     DP_START_AT_BOOT

#define DP_CMD_HELP_1           201
#define DP_CMD_HELP_2           202
#define DP_CMD_HELP_3           203
#define DP_CMD_HELP_4           204
#define DP_CMD_HELP_5           205
#define DP_CMD_HELP_6           206
#define DP_CMD_HELP_7           207
#define DP_CMD_HELP_8           208
#define DP_CMD_HELP_9           209
#define DP_CMD_HELP_10          210
#define DP_CMD_HELP_11          211
#define DP_CMD_HELP_12          212
#define DP_CMD_HELP_13          213
#define DP_CMD_HELP_14          214
#define DP_CMD_HELP_15          215
#define DP_CMD_HELP_16          216
#define DP_CMD_HELP_START       DP_CMD_HELP_1
#define DP_CMD_HELP_END         DP_CMD_HELP_16

#define DP_HELP_TEXT_1          301
#define DP_HELP_TEXT_2          302
#define DP_HELP_TEXT_3          303
#define DP_HELP_TEXT_4          304
#define DP_HELP_TEXT_5          305
#define DP_HELP_TEXT_6          306
#define DP_HELP_TEXT_7          307
#define DP_HELP_TEXT_8          308
#define DP_HELP_TEXT_9          309
#define DP_HELP_TEXT_10         310
#define DP_HELP_TEXT_11         311
#define DP_HELP_TEXT_12         312
#define DP_HELP_TEXT_13         313
#define DP_HELP_TEXT_START      DP_HELP_TEXT_1
#define DP_HELP_TEXT_END        DP_HELP_TEXT_13

#define DP_CURRENT_FORMAT       401
#define DP_UNABLE_READ_START    402
#define DP_UNABLE_READ_REGISTRY 403
#define DP_UNABLE_CONNECT       404
#define DP_UNABLE_MODIFY_VALUE  405
#define DP_NEW_DISKPERF_STATUS  406
#define DP_REBOOTED             407
#define DP_STATUS_FORMAT        408
#define DP_TEXT_FORMAT          409
#define DP_ENHANCED             410
#define DP_DISCLAIMER           411
#define DP_PHYSICAL             412
#define DP_LOGICAL              413
#define DP_CURRENT_FORMAT1      414
#define DP_NEW_DISKPERF_STATUS1 415
#define DP_NOCHANGE             416
#define DP_PERMANENT_FORMAT     417
#define DP_PERMANENT_FORMAT1    418
#define DP_PERMANENT_FORMAT2    419
#define DP_PERMANENT_IOCTL      420

#endif // _DISKPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dload\sdktoolspch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dskbench\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dosdev\dosdev.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    User mode beep program.  This program simply beeps at the frequency
    specified on the command line and for the time specified on the
    command line (in milliseconds).

Author:

    01-Dec-1992 Steve Wood (stevewo)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#define DEVICE_NAME_SIZE  (20 * 1024)
#define TARGET_PATH_SIZE  (20 * 1024)

UCHAR DeviceNames[ DEVICE_NAME_SIZE ];
UCHAR TargetPath[ TARGET_PATH_SIZE ];

typedef struct _DEVICE_LINK {
    PCHAR LinkName;
    ULONG LinkTargetLength;
    PCHAR LinkTarget;
    PCHAR DriveType;
    DWORD LogicalDriveBit;
} DEVICE_LINK, *PDEVICE_LINK;

ULONG NumberOfDriveLetters;
ULONG NumberOfDevices;
DEVICE_LINK DriveLetters[ 4096 ];
DEVICE_LINK Devices[ 4096 ];

void
Usage( void )
{
    fprintf( stderr, "usage: DOSDEV [-a] [-s] [-h] [[-r] [-d [-e]] DeviceName [TargetPath]]\n" );
    exit( 1 );
}

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    );

char *DriveTypes[] = {
    "Unknown",
    "NoRootDir",
    "Removable",
    "Fixed",
    "Remote",
    "CDRom",
    "RamDisk"
};

void
DisplayDeviceTarget(
    char *Msg,
    char *Name,
    char *Target,
    DWORD cchTarget
    )
{
    char *s;

    printf( "%s%s = ", Msg, Name );
    s = Target;
    while (*s && cchTarget != 0) {
        if (s > Target) {
            printf( " ; " );
            }
        printf( "%s", s );
        while (*s++) {
            if (!cchTarget--) {
                cchTarget = 0;
                break;
                }
            }
        }
}

int
GetSystemPartitionFromRegistry(
    char*  lpSystemPartition
    )

{
    LONG    r;
    HKEY    key;
    DWORD   bytes;

    r = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM\\Setup", 0, KEY_QUERY_VALUE,
                     &key);
    if (r) {
        printf("RegOpenKeyEx failed with %d\n", r);
        return 0;
    }

    bytes = MAX_PATH;
    r = RegQueryValueEx(key, "SystemPartition", NULL, NULL, lpSystemPartition,
                        &bytes);
    RegCloseKey(key);
    if (r) {
        printf("RegQueryValueEx failed with %d\n", r);
        return 0;
    }

    return 1;
}

int
__cdecl
CompareDeviceLink(
    const void *p1,
    const void *p2
    )
{
    return _stricmp( ((PDEVICE_LINK)p1)->LinkName, 
                     ((PDEVICE_LINK)p2)->LinkName );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD cch, i;
    char c, *s;
    char RootDir[ 4 ];
    DWORD dwFlags;
    DWORD UnknownLogicalDrives;
    BOOL fShowOnlyDrives, fSystemPartition;
    LPSTR lpDeviceName;
    LPSTR lpTargetPath;
    PDEVICE_LINK p;
    char systemBuffer[MAX_PATH];

    lpDeviceName = NULL;
    lpTargetPath = NULL;
    fShowOnlyDrives = TRUE;
    fSystemPartition = FALSE;
    dwFlags = 0;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (c = *++s) {
                switch (tolower( c )) {
                    case '?':
                    case 'h':
                        Usage();

                    case 'e':
                        dwFlags |= DDD_EXACT_MATCH_ON_REMOVE;
                        break;

                    case 'd':
                        dwFlags |= DDD_REMOVE_DEFINITION;
                        break;

                    case 'r':
                        dwFlags |= DDD_RAW_TARGET_PATH;
                        break;

                    case 'a':
                        fShowOnlyDrives = FALSE;
                        break;

                    case 's':
                        fSystemPartition = TRUE;
                        dwFlags |= DDD_RAW_TARGET_PATH;
                        break;
                    }
                }
            }
        else
        if (lpDeviceName == NULL) {
            lpDeviceName = s;
            }
        else
        if (lpTargetPath == NULL) {
            lpTargetPath = s;
            }
        else {
            Usage();
            }
        }

    if (fSystemPartition) {
        lpTargetPath = systemBuffer;
        if (!GetSystemPartitionFromRegistry(lpTargetPath)) {
            exit( 1 );
            }
        }

    if (lpDeviceName == NULL && lpTargetPath == NULL) {
        cch = QueryDosDevice( NULL,
                              DeviceNames,
                              sizeof( DeviceNames )
                            );
        if (cch == 0) {
            fprintf( stderr, "DOSDEV: Unable to query device names - %u\n", GetLastError() );
            exit( 1 );
            }

        s = DeviceNames;
        while (*s) {
            cch = QueryDosDevice( s,
                                  TargetPath,
                                  sizeof( TargetPath )
                                );
            if (cch == 0) {
                sprintf( TargetPath, "*** unable to query target path - %u ***", GetLastError() );
                }
            else {
                if (strlen( s ) == 2 && s[1] == ':') {
                    p = &DriveLetters[ NumberOfDriveLetters++ ];

                    sprintf( RootDir, "%s\\", s );
                    p->DriveType = DriveTypes[ GetDriveType( RootDir ) ];
                    p->LogicalDriveBit = 1 << (s[0] - 'A');
                    }
                else {
                    p = &Devices[ NumberOfDevices++ ];
                    }

                p->LinkName = s;
                p->LinkTargetLength = cch;
                p->LinkTarget = malloc( cch + 1 );
                memmove( p->LinkTarget, TargetPath, cch );
                }

            while (*s++)
                ;
            }

        qsort( &DriveLetters[0],
               NumberOfDriveLetters,
               sizeof( DEVICE_LINK ),
               CompareDeviceLink
             );

        UnknownLogicalDrives = GetLogicalDrives();
        for (i=0; i<NumberOfDriveLetters; i++) {
            p = &DriveLetters[ i ];
            DisplayDeviceTarget( "", p->LinkName, p->LinkTarget, p->LinkTargetLength );
            printf( " [%s]", p->DriveType );
            if (UnknownLogicalDrives & p->LogicalDriveBit) {
                UnknownLogicalDrives ^= p->LogicalDriveBit;
                }
            else {
                printf( " *** LOGICAL DRIVE BIT NOT SET ***" );
                }
            printf( "\n" );
            }

        if (UnknownLogicalDrives) {
            for (i=0; i<26; i++) {
                if (UnknownLogicalDrives & (1 << i)) {
                    printf( "%c: = *** LOGICAL DRIVE BIT SET BUT NO DRIVE LETTER ***\n",
                            'A' + i
                          );
                    }
                }
            }

        if (!fShowOnlyDrives) {
            printf( "\n" );
            qsort( &Devices[0],
                   NumberOfDevices,
                   sizeof( DEVICE_LINK ),
                   CompareDeviceLink
                 );

            for (i=0; i<NumberOfDevices; i++) {
                p = &Devices[ i ];
                DisplayDeviceTarget( "", p->LinkName, p->LinkTarget, p->LinkTargetLength );
                printf( "\n" );
                }
            }

        exit( 0 );
        }

    if (lpDeviceName == NULL) {
        Usage();
        }
    else
    if (!(dwFlags & DDD_REMOVE_DEFINITION) && lpTargetPath == NULL) {
        Usage();
        }

    cch = QueryDosDevice( lpDeviceName,
                          TargetPath,
                          sizeof( TargetPath )
                        );
    if (cch != 0) {
        DisplayDeviceTarget( "Current definition: ", lpDeviceName, TargetPath, cch );
        printf( "\n" );
        }

    if (!DefineDosDevice( dwFlags, lpDeviceName, lpTargetPath )) {
        fprintf( stderr,
                 "DOSDEV: Unable to %s device name %s - %u\n",
                 (dwFlags & DDD_REMOVE_DEFINITION) ? "delete"
                                                   : "define",

                 lpDeviceName,
                 GetLastError()
               );
        }
    else {
        cch = QueryDosDevice( lpDeviceName,
                              TargetPath,
                              sizeof( TargetPath )
                            );
        if (cch != 0) {
            DisplayDeviceTarget( "Current definition: ", lpDeviceName, TargetPath, cch );
            printf( "\n" );
            }
        else {
            printf( "%s deleted.\n", lpDeviceName );
            }
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\drivemap\drivemap.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    drivemap.c

Abstract:

    User mode program to determine which ide/scsi device each drive letter is
    connected to.

Author:

    01-Nov-1995 Peter Wieland (peterwie)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include <winioctl.h>
#include <ntddscsi.h>

#define BUFSIZE             6   // <drive letter>:<NULL>
#define NUM_DRIVES          26  // 26 drive letters
#define MAX_FLOPPY_OFFSET   1

enum    {UNKNOWN = 0, FLOPPY, SCSI, IDE};

typedef struct devent   {
    char    *dosName;           // dosdevices name
    char    devName[64];
    int     type;
    void    *desc;
} devent;

void splitDosQuery(LPTSTR queryString, devent *list);
void checkDeviceType(devent *dev);
void processDevice(DWORD driveLetterOffset);

ULONG NumberOfDriveLetters;

int __cdecl main(int argc, char *argv[])    {

    DWORD   dwT, i, Index;
    TCHAR   strDriveLetter[BUFSIZE];

    dwT = GetLogicalDrives();

    if(dwT == 0)    {
        printf("Error getting device letters (%d)\n", GetLastError());
        exit(-2);
    }

    Index = 1;

    for( i = 0; i < NUM_DRIVES; i++ ) {
        if(Index & dwT) {
            processDevice(i);
        }
        Index <<= 1;
    }

    return 0;
}

//
// processDevice(driveLetterOffset);
//  in:     driveLetterOffset - offset of the drive letter relative to 'A'
//

void processDevice(DWORD driveLetterOffset)     {

    LPTSTR          next;
    char            chBuf[32];

    HANDLE          hDevice = INVALID_HANDLE_VALUE;
    DWORD           ioctlData[2];
    PSCSI_ADDRESS           scsiAddress = (PSCSI_ADDRESS) ioctlData;
    PDISK_CONTROLLER_NUMBER atAddress = (PDISK_CONTROLLER_NUMBER) ioctlData; 
    DWORD           dwSize;
    UCHAR           diskType = UNKNOWN;
    DWORD           offset = driveLetterOffset;

    // only do processing on drive letters

    try {
        sprintf(chBuf, "\\\\.\\%c:", ('A' + offset));

        // Check if drive letter is 'A' or 'B'
        if(offset <= MAX_FLOPPY_OFFSET)	{
            diskType = FLOPPY;
            hDevice = INVALID_HANDLE_VALUE;
            goto typeKnown;
        }

        hDevice = CreateFile(chBuf,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if(hDevice == INVALID_HANDLE_VALUE)     {
//              printf("Error opening device %s (%d)\n", 
//                           chBuf, GetLastError());
            return;
        }

        // send down the scsi query first (yes, i'm biased)
        if(!DeviceIoControl(hDevice,
                            IOCTL_SCSI_GET_ADDRESS,
                            NULL,
                            0,
                            scsiAddress,
                            sizeof(SCSI_ADDRESS),
                            &dwSize,
                            NULL))  {

            // if the ioctl was invalid, then we don't know the disk type yet,
            // so just keep going
            // if there was another error, skip to the next device
            if(GetLastError() != ERROR_INVALID_FUNCTION)    {
                return;
            }

        } else	{
            // if the ioctl was valid, then we're a scsi device (or a scsiport
            // controlled device in the case of atapi) - go on to the end
            diskType = SCSI;
            goto typeKnown;
        }

        if(!DeviceIoControl(hDevice,
                            IOCTL_DISK_CONTROLLER_NUMBER,
                            NULL,
                            0,
                            atAddress,
                            sizeof(DISK_CONTROLLER_NUMBER),
                            &dwSize,
                            NULL)) {
            // if the ioctl was invalid, then we still don't know the
            // disk type - continue on.

            if(GetLastError() != ERROR_INVALID_FUNCTION) return;

        } else {

            // if the ioctl was valid, then we're an IDE device

            diskType = IDE;
            goto typeKnown;

        }

        diskType = UNKNOWN;

typeKnown:
        printf("%s -> ", chBuf);

        switch(diskType)    {
            case FLOPPY:
                printf("Floppy drive\n");
                break;

            case SCSI:
                printf("Port %d, Path %d, Target %d, Lun %d\n",
                    scsiAddress->PortNumber,
                    scsiAddress->PathId,
                    scsiAddress->TargetId,
                    scsiAddress->Lun);
                break;

            case IDE:
                printf("Controller %d, Disk %d\n",
                    atAddress->ControllerNumber,
                    atAddress->DiskNumber);
                break;

            default:
                printf("Unknown\n");
                break;
        }
    } finally {

        // close the file handle if we've opened it
        if(hDevice != INVALID_HANDLE_VALUE) CloseHandle(hDevice);
        }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\diskperf\diskperf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    diskperf.c

Abstract:

    Program to display and/or update the current value of the Diskperf
    driver startup value

Author:

    Bob Watson (a-robw) 4 Dec 92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntconfig.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <regstr.h>  // for REGSTR_VAL_UPPERFILTERS
#include <tchar.h>
#include <locale.h>

#include "diskperf.h"    // include text string id constancts
#include <ntdddisk.h>
#include <mountmgr.h>

LANGID WINAPI MySetThreadUILanguage(
    WORD wReserved);

#define  SWITCH_CHAR    '-' // is there a system call to get this?
#define  ENABLE_CHAR    'Y' // command will be upcased
#define  DISABLE_CHAR   'N'
#define  ENHANCED_CHAR  'E'

#define  LOCAL_CHANGE   2   // number of commands in a local change command
#define  REMOTE_CHANGE  3   // number of commands in a remote change command

//
//  note these values are arbitrarily based on the whims of the people
//  developing the disk drive drivers that belong to the "Filter" group.
//
#define  TAG_NORMAL     4   // diskperf starts AFTER ftdisk
#define  TAG_ENHANCED   2   // diskperf starts BEFORE ftdisk

#define  IRP_STACK_ENABLED  5 // size of IRP stack when diskperf is enabled
#define  IRP_STACK_DISABLED 4 // size of IRP stack when diskperf is enabled

#define  IRP_STACK_DEFAULT  8 // default IRP stack size in W2K
#define  IRP_STACK_NODISKPERF 7

#define DISKPERF_SERVICE_NAME TEXT("DiskPerf")

LPCTSTR lpwszDiskPerfKey = TEXT("SYSTEM\\CurrentControlSet\\Services\\Diskperf");
LPCTSTR lpwszIOSystemKey = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\I/O System");
LPCTSTR lpwszOsVersionKey = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
LPCTSTR lpwszBuildNumber = TEXT("CurrentBuildNumber");
LPCTSTR lpwszOsVersion = TEXT("CurrentVersion");

#define ENABLE_DISKDRIVE        0x0001
#define ENABLE_VOLUME           0x0002
#define ENABLE_PERMANENT        0x0004
#define ENABLE_PERMANENT_IOCTL  0x0008

LPCTSTR lpwszDiskDriveKey
    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E967-E325-11CE-BFC1-08002BE10318}");
LPCTSTR lpwszVolumeKey
    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}");

LPCTSTR lpwszPartmgrKey = TEXT("SYSTEM\\CurrentControlSet\\Services\\Partmgr");
LPCTSTR lpwszEnableCounterValue = TEXT("EnableCounterForIoctl");

ULONG
OpenRegKeys(
    IN LPCTSTR lpszMachine,
    OUT PHKEY hRegistry,
    OUT PHKEY hDiskKey,
    OUT PHKEY hVolumeKey,
    OUT PHKEY hServiceKey
    );

ULONG
SetFilter(
    IN HKEY hKey,
    IN LPTSTR strFilterString,
    IN DWORD dwSize
    );

ULONG
GetFilter(
    IN HKEY hKey,
    OUT LPTSTR strFilterString,
    IN DWORD dwSize
    );

ULONG
CheckFilter(
    IN TCHAR *Buffer
    );

ULONG
GetEnableFlag(
    IN HKEY hDiskKey,
    IN HKEY hVolumeKey
    );

ULONG
AddToFilter(
    IN HKEY hKey
    );

ULONG
RemoveFromFilter(
    IN HKEY hKey
    );

void
PrintStatus(
    IN BOOL bCurrent,
    IN ULONG EnableFlag,
    IN LPCTSTR cMachineName
    );

int __cdecl
Dp_wprintf(
    const wchar_t *format,
    ...
    );

int __cdecl
Dp_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
Dp_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );

BOOL
IsBeyondW2K(
    IN LPCTSTR lpszMachine,
    OUT PDWORD EnableCounter);

ULONG
EnableForIoctl(
    IN LPWSTR lpszMachineName
    );

ULONG
DisableForIoctl(
    IN LPWSTR lpszMachineName,
    IN ULONG Request
    );

#if DBG
void
DbgPrintMultiSz(
    TCHAR *String,
    ULONG Size
    );
#endif

#define REG_TO_DP_INDEX(reg_idx)    (DP_LOAD_STATUS_BASE + (\
    (reg_idx == SERVICE_BOOT_START) ? DP_BOOT_START : \
    (reg_idx == SERVICE_SYSTEM_START) ? DP_SYSTEM_START : \
    (reg_idx == SERVICE_AUTO_START) ? DP_AUTO_START : \
    (reg_idx == SERVICE_DEMAND_START) ? DP_DEMAND_START : \
    (reg_idx == SERVICE_DISABLED) ? DP_NEVER_START : DP_UNDEFINED))

#define MAX_MACHINE_NAME_LEN    32

// command line arguments

#define CMD_SHOW_LOCAL_STATUS   1
#define CMD_DO_COMMAND          2

#define ArgIsSystem(arg)   (*(arg) == '\\' ? TRUE : FALSE)

//
//  global buffer for help text display strings
//
#define DISP_BUFF_LEN       256
#define NUM_STRING_BUFFS      2
LPCTSTR BlankString = TEXT(" ");
LPCTSTR StartKey = TEXT("Start");
LPCTSTR TagKey = TEXT("Tag");
LPCTSTR EmptyString = TEXT("");
LPCTSTR LargeIrps = TEXT("LargeIrpStackLocations");

HINSTANCE   hMod = NULL;
DWORD   dwLastError;


LPCTSTR
GetStringResource (
    UINT    wStringId
)
{
    static TCHAR    DisplayStringBuffer[NUM_STRING_BUFFS][DISP_BUFF_LEN];
    static DWORD    dwBuffIndex;
    LPTSTR          szReturnBuffer;

    dwBuffIndex++;
    dwBuffIndex %= NUM_STRING_BUFFS;
    szReturnBuffer = (LPTSTR)&DisplayStringBuffer[dwBuffIndex][0];

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }

    if (hMod) {
        if ((LoadString(hMod, wStringId, szReturnBuffer, DISP_BUFF_LEN)) > 0) {
            return (LPCTSTR)szReturnBuffer;
        } else {
            dwLastError = GetLastError();
            return EmptyString;
        }
    } else {
        return EmptyString;
    }
}
LPCTSTR
GetFormatResource (
    UINT    wStringId
)
{
    static TCHAR   TextFormat[DISP_BUFF_LEN];

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }

    if (hMod) {
        if ((LoadString(hMod, wStringId, TextFormat, DISP_BUFF_LEN)) > 0) {
            return (LPCTSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}

VOID
DisplayChangeCmd (
)
{
    UINT        wID;
    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];
    TCHAR       DisplayStringBuffer[DISP_BUFF_LEN];

    if (hMod) {
        if ((LoadString(hMod, DP_TEXT_FORMAT, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
            for (wID=DP_CMD_HELP_START; wID <= DP_CMD_HELP_END; wID++) {
                if ((LoadString(hMod, wID, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
                    Dp_wprintf(DisplayStringBuffer);
                }
            }
        }
    }
}
VOID
DisplayCmdHelp(
)
{
    UINT        wID;
    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];
    TCHAR       DisplayStringBuffer[DISP_BUFF_LEN];

    if (hMod) {
        if ((LoadString(hMod, DP_TEXT_FORMAT, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
            for (wID=DP_HELP_TEXT_START; wID <= DP_HELP_TEXT_END; wID++) {
                if ((LoadString(hMod, wID, DisplayStringBuffer, DISP_BUFF_LEN)) > 0) {
                    Dp_wprintf(DisplayStringBuffer);
                }
            }
        }
    }

    DisplayChangeCmd();
}

ULONG
DisplayStatus (
    LPTSTR lpszMachine
)
{
    ULONG       Status;
    HKEY        hRegistry;
    HKEY        hDiskPerfKey;
    HKEY        hDiskKey;
    HKEY        hVolumeKey;
    DWORD       dwValue, dwValueSize, dwTag;
    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];

    TCHAR       cMachineName[MAX_MACHINE_NAME_LEN];
    PTCHAR      pThisWideChar;
    PTCHAR       pThisChar;
    INT         iCharCount;
    DWORD       EnableCounter;

    pThisChar = lpszMachine;
    pThisWideChar = cMachineName;
    iCharCount = 0;

    if (pThisChar) {    // if machine is not NULL, then copy
        while (*pThisChar) {
            *pThisWideChar++ = (TCHAR)(*pThisChar++);
            if (++iCharCount >= MAX_MACHINE_NAME_LEN) break;
        }
        *pThisWideChar = 0;
    }

    if (!lpszMachine) {
        lstrcpy(cMachineName,
            GetStringResource(DP_THIS_SYSTEM));
    }

    if (IsBeyondW2K(lpszMachine, &EnableCounter)) {
        if (EnableCounter) {
            PrintStatus(TRUE, ENABLE_PERMANENT_IOCTL, cMachineName);
        }
        else {
            PrintStatus(TRUE, ENABLE_PERMANENT, cMachineName);
        }
        return ERROR_SUCCESS;
    }

    Status = OpenRegKeys(
                lpszMachine,
                &hRegistry,
                &hDiskKey,
                &hVolumeKey,
                &hDiskPerfKey);

    if (Status != ERROR_SUCCESS) {
#if DBG
        fprintf(stderr,
                "DisplayStatus: Cannot open HKLM on target machine: %d\n",
                Status);
#endif
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
        return Status;
    }

    dwTag = GetEnableFlag(hDiskKey, hVolumeKey);
    dwValue = (dwTag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
    dwValueSize = sizeof(dwValue);
    Status = RegQueryValueEx (
                hDiskPerfKey,
                StartKey,
                NULL,
                NULL,
                (LPBYTE)&dwValue,
                &dwValueSize);

    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_START));
        goto DisplayStatusCleanup;
    }

    PrintStatus(TRUE, dwTag, cMachineName);

  DisplayStatusCleanup:
    RegCloseKey(hDiskKey);
    RegCloseKey(hVolumeKey);
    RegCloseKey(hDiskPerfKey);
    RegCloseKey(hRegistry);

    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_STATUS_FORMAT), Status);

    }
    return Status;
}

ULONG
DoChangeCommand (
    LPTSTR lpszCommand,
    LPTSTR lpszMachine
)
{
    // connect to registry on local machine with read/write access
    ULONG       Status;
    HKEY        hRegistry;
    HKEY        hDiskPerfKey;
    HKEY        hDiskKey;
    HKEY        hVolumeKey;
    DWORD       dwValue, dwValueSize, dwOrigValue, dwTag, dwOrigTag;

    TCHAR       cMachineName[MAX_MACHINE_NAME_LEN];
    PTCHAR      pThisWideChar;
    PTCHAR       pThisChar;
    INT         iCharCount;
    PTCHAR       pCmdChar;

    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];

    HKEY        hIOSystemKey;
    DWORD       dwDisposition;
    DWORD       dwIrpValue;
    ULONG       EnableRequest, DisableRequest;
    ULONG       EnableFlag, EndFlag = 0;
    BOOL        bModified, bIrpStackReg;
    LONG        nIrpStack, nIrpStackReg, nIncrement;
    DWORD       EnableCounter;

    // check command to see if it's valid

    _tcsupr (lpszCommand);

    pCmdChar = lpszCommand;
    dwValue = 0;
    EnableRequest = DisableRequest = 0;

    if (*pCmdChar++ == SWITCH_CHAR ) {
        if (!_tcscmp(pCmdChar, _T("Y")) ||
            !_tcscmp(pCmdChar, _T("YA")) ||
            !_tcscmp(pCmdChar, _T("YALL"))) {
            EnableRequest = ENABLE_DISKDRIVE | ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("N")) ||
            !_tcscmp(pCmdChar, _T("NA")) ||
            !_tcscmp(pCmdChar, _T("NALL")) ) {
            DisableRequest = ENABLE_DISKDRIVE | ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("YD")) ||
            !_tcscmp(pCmdChar, _T("YDISK")) ) {
            EnableRequest = ENABLE_DISKDRIVE;
        }
        else if (!_tcscmp(pCmdChar, _T("YV")) ||
            !_tcscmp(pCmdChar, _T("YVOLUME")) ) {
            EnableRequest = ENABLE_VOLUME;
        }
        else if (!_tcscmp(pCmdChar, _T("ND")) ||
            !_tcscmp(pCmdChar, _T("NDISK")) ) {
            DisableRequest = ENABLE_DISKDRIVE;
        }
        else if (!_tcscmp(pCmdChar, _T("NV")) ||
            !_tcscmp(pCmdChar, _T("NVOLUME")) ) {
            DisableRequest = ENABLE_VOLUME;
        } else {
            DisplayCmdHelp();
            return ERROR_SUCCESS;
        }
    } else {
        DisplayChangeCmd();
        return ERROR_SUCCESS;
    }

    // if command OK then convert machine to wide string for connection

    pThisChar = lpszMachine;
    pThisWideChar = cMachineName;
    iCharCount = 0;

    if (pThisChar) {
        while (*pThisChar) {
            *pThisWideChar++ = (TCHAR)(*pThisChar++);
            if (++iCharCount >= MAX_MACHINE_NAME_LEN) break;
        }
        *pThisWideChar = 0; // null terminate
    }

    if (!lpszMachine) {
        lstrcpy (cMachineName,
            GetStringResource(DP_THIS_SYSTEM));
    }

    if (IsBeyondW2K(lpszMachine, &EnableCounter)) {
        if (EnableRequest != 0) {
            EnableForIoctl(lpszMachine);
            PrintStatus(TRUE, ENABLE_PERMANENT_IOCTL, cMachineName);
        }
        else if (DisableRequest != 0) {
            DisableForIoctl(lpszMachine, DisableRequest);
            PrintStatus(TRUE, ENABLE_PERMANENT, cMachineName);
        }
        return ERROR_SUCCESS;
    }

    // connect to registry
    Status = OpenRegKeys(
                lpszMachine,
                &hRegistry,
                &hDiskKey,
                &hVolumeKey,
                &hDiskPerfKey);

    if (Status != ERROR_SUCCESS) {
#if DBG
        fprintf(stderr,
                "DoChangeCommand: Cannot connect to registry: Status=%d\n",
                Status);
#endif
        Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
        return Status;
    }

    hIOSystemKey = NULL;
    nIrpStackReg = 0;
    bIrpStackReg = FALSE;       // no registry key prior to this
    Status = RegCreateKeyEx (
                hRegistry,
                lpwszIOSystemKey,
                0L, //Reserved
                NULL,
                0L, // no special options
                KEY_WRITE | KEY_READ, // desired access
                NULL, // default security
                &hIOSystemKey,
                &dwDisposition);
    if (Status != ERROR_SUCCESS) {
        if ((Status == ERROR_ALREADY_EXISTS) &&
            (dwDisposition == REG_OPENED_EXISTING_KEY)) {
            // then this key is already in the registry so this is OK
                Status = ERROR_SUCCESS;
        }
        else {
            Dp_wprintf(GetFormatResource(DP_UNABLE_READ_REGISTRY));
            goto DoChangeCommandCleanup;
        }
    }
    if ( (Status == ERROR_SUCCESS) && (dwDisposition == REG_OPENED_EXISTING_KEY)) {
            DWORD dwSize;
            dwSize = sizeof(DWORD);

            Status = RegQueryValueEx (
                        hIOSystemKey,
                        LargeIrps,
                        0L,
                        NULL,
                        (LPBYTE)&dwIrpValue,
                        &dwSize);
            if (Status == ERROR_SUCCESS) {
#if DBG
                fprintf(stderr, "Registry LargeIrpStack=%d\n", dwIrpValue);
#endif
                nIrpStackReg = dwIrpValue;
                bIrpStackReg = TRUE;
            }
    }

    EnableFlag = GetEnableFlag(hDiskKey, hVolumeKey);
#if DBG
    fprintf(stderr, "DoChangeCommand: EnableFlag is %x\n", EnableFlag);
#endif

    bModified = FALSE;

    nIncrement = 0;
    if ( (EnableRequest & ENABLE_DISKDRIVE) &&
        !(EnableFlag & ENABLE_DISKDRIVE) ) {
        // Turn on filter for disk drives
        if (AddToFilter(hDiskKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement++;
        }
    }
    if ( (EnableRequest & ENABLE_VOLUME) &&
        !(EnableFlag & ENABLE_VOLUME) ) {
        // Turn on filter for volumes
        if (AddToFilter(hVolumeKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement++;
        }
    }
    if ( (DisableRequest & ENABLE_DISKDRIVE) &&
         (EnableFlag & ENABLE_DISKDRIVE) ) {
        // Turn off filter for disk drives
        if (RemoveFromFilter(hDiskKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement--;
        }
    }
    if ( (DisableRequest & ENABLE_VOLUME) &&
         (EnableFlag & ENABLE_VOLUME) ) {
        // Turn off filter for volumes
        if (RemoveFromFilter(hVolumeKey) == ERROR_SUCCESS) {
            bModified = TRUE;
            nIncrement--;
        }
    }

    nIrpStack = 0;
    EndFlag = GetEnableFlag(hDiskKey, hVolumeKey);

    if (bModified) {    // we have modified the registry


        dwValue = (EndFlag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
        Status = RegSetValueEx(
                    hDiskPerfKey,
                    StartKey,
                    0L,
                    REG_DWORD,
                    (LPBYTE)&dwValue,
                    sizeof(dwValue));
        //
        // First update service registry entries
        //

        if (DisableRequest != 0) {
            nIrpStack = nIrpStackReg + nIncrement;
            if (EndFlag == 0) {
                //
                // Turn off service completely
                //
                // Set Irp stack size to original value or default
                if (nIrpStack < IRP_STACK_NODISKPERF)
                    nIrpStack = IRP_STACK_NODISKPERF;
            }
            else {  // else, there is only one stack left
                if (nIrpStack < IRP_STACK_NODISKPERF+1)
                    nIrpStack = IRP_STACK_NODISKPERF+1;
            }
        }
        else if (EnableRequest != 0) {
            nIrpStack = nIrpStackReg + nIncrement;
            //
            // Set proper Irp stack size
            //
            if (EndFlag == (ENABLE_DISKDRIVE | ENABLE_VOLUME)) {
                if (nIrpStack < IRP_STACK_NODISKPERF+2)    // a value is set
                    nIrpStack = IRP_STACK_NODISKPERF+2;
            }
            else {  // at least one is enabled
                if (nIrpStack < IRP_STACK_NODISKPERF+1)
                    nIrpStack = IRP_STACK_NODISKPERF+1;
            }
        }
    }
    else {
        //
        // No action taken. Should tell the user the state.
        //        
        PrintStatus(TRUE, EndFlag, cMachineName);
        Dp_wprintf(GetFormatResource(DP_NOCHANGE));
    }

#if DBG
    fprintf(stderr, "New LargeIrp is %d\n", nIrpStack);
#endif
    if (hIOSystemKey != NULL && Status == ERROR_SUCCESS) {
        if (bModified) {
            Status = RegSetValueEx (
                        hIOSystemKey,
                        LargeIrps,
                        0L,
                        REG_DWORD,
                        (LPBYTE)&nIrpStack,
                        sizeof(DWORD));
            if (Status == ERROR_SUCCESS) {
                PrintStatus(FALSE, EndFlag, cMachineName);
            }
            else {
                Dp_wprintf(GetFormatResource(DP_UNABLE_MODIFY_VALUE));
            }
        }
        RegCloseKey(hIOSystemKey);
    }

  DoChangeCommandCleanup:
    if (hDiskPerfKey != NULL) {
        RegCloseKey(hDiskPerfKey);
    }
    if (hDiskKey != NULL) {
        RegCloseKey(hDiskKey);
    }
    if (hVolumeKey != NULL) {
        RegCloseKey(hVolumeKey);
    }
    if (hRegistry != NULL) {
        RegCloseKey(hRegistry);
    }
    if (Status != ERROR_SUCCESS) {
        Dp_wprintf(GetFormatResource(DP_STATUS_FORMAT), Status);
    }
    return Status;
}

ULONG
OpenRegKeys(
    IN LPCTSTR lpszMachine,
    OUT PHKEY hRegistry,
    OUT PHKEY hDiskKey,
    OUT PHKEY hVolumeKey,
    OUT PHKEY hServiceKey
    )
{
    ULONG status;

    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    *hRegistry = NULL;
    status = RegConnectRegistry(
                lpszMachine,
                HKEY_LOCAL_MACHINE,
                hRegistry);
    if (status != ERROR_SUCCESS)
        return status;
    if (*hRegistry == NULL)
        return ERROR_INVALID_PARAMETER; // Avoid PREFIX error

    if (hDiskKey) {
        *hDiskKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszDiskDriveKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hDiskKey);
        }
    }
    if (hVolumeKey) {
        *hVolumeKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszVolumeKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hVolumeKey);
        }
    }
    if (hServiceKey) {
        *hServiceKey = NULL;
        if (status == ERROR_SUCCESS) {
            status = RegOpenKeyEx(
                        *hRegistry,
                        lpwszDiskPerfKey,
                        (DWORD) 0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        hServiceKey);
        }
    }
    if ( (status != ERROR_SUCCESS) && (hDiskKey != NULL) ) {
        if (*hDiskKey != NULL)
            RegCloseKey(*hDiskKey);
        *hDiskKey = NULL;
    }
    if ( (status != ERROR_SUCCESS) && (hVolumeKey != NULL) ) {
        if (*hVolumeKey != NULL)
            RegCloseKey(*hVolumeKey);
        *hVolumeKey = NULL;
    }
    if ( (status != ERROR_SUCCESS) && (hServiceKey != NULL) ) {
        if (*hServiceKey != NULL)
            RegCloseKey(*hServiceKey);
        *hServiceKey = NULL;
    }
    return status;
}

ULONG
SetFilter(
    IN HKEY hKey,
    IN LPTSTR strFilterString,
    IN DWORD dwSize
    )
{
    ULONG status;
    LONG len;
    DWORD dwType = REG_MULTI_SZ;

    if (hKey == NULL)
        return ERROR_BADKEY;

//
// NOTE: Assumes that strFilterString is always MAX_PATH, NULL padded
//
    len = dwSize / sizeof(TCHAR);
    if (len < 2) {
        dwSize = 2 * sizeof(TCHAR);
#if DBG
        fprintf(stderr, "SetFilter: Length %d dwSize %d\n", len, dwSize);
#endif
    }
    else {  // ensures 2 null character always
        if (strFilterString[len-1] != 0) { // no trailing null
            len += 2;
            strFilterString[len] = 0;
            strFilterString[len+1] = 0;
#if DBG
    fprintf(stderr, "SetFilter: New length(+2) %d\n", len);
#endif
        }
        else if (strFilterString[len-2] != 0) { // only one trailing null
            len += 1;
            strFilterString[len+1] = 0;
#if DBG
            fprintf(stderr, "SetFilter: New length(+1) %d\n", len);
#endif
        }
        dwSize = len * sizeof(TCHAR);
    } 
    if (len <= 2) {
        status = RegDeleteValue(hKey, REGSTR_VAL_UPPERFILTERS);
#if DBG
        fprintf(stderr, "Delete status = %d\n", status);
#endif
        return status;
    }
    status = RegSetValueEx(
                hKey,
                REGSTR_VAL_UPPERFILTERS,
                (DWORD) 0,
                dwType,
                (BYTE*)strFilterString,
                dwSize);

#if DBG
    if (status != ERROR_SUCCESS) {
        _ftprintf(stderr, _T("SetFilter: Cannot query key %s status=%d\n"),
                REGSTR_VAL_UPPERFILTERS, status);
    }
    else {
        fprintf(stderr, "SetFilter: ");
        DbgPrintMultiSz(strFilterString, dwSize);
        fprintf(stderr, "\n");
    }
#endif
    return status;
}

ULONG
GetFilter(
    IN HKEY hKey,
    OUT LPTSTR strFilterString,
    IN DWORD dwSize
    )
// Returns size of strFilterString
{
    ULONG status;

    if (hKey == NULL)
        return ERROR_BADKEY;

    status = RegQueryValueEx(
                hKey,
                REGSTR_VAL_UPPERFILTERS,
                NULL,
                NULL,
                (BYTE*)strFilterString,
                &dwSize);
    if (status != ERROR_SUCCESS) {
#if DBG
        _ftprintf(stderr, _T("GetFilter: Cannot query key %s status=%d\n"),
                REGSTR_VAL_UPPERFILTERS, status);
#endif
        return 0;
    }
#if DBG
    else {
        fprintf(stderr, "GetFilter: ");
        DbgPrintMultiSz(strFilterString, dwSize);
        fprintf(stderr, "\n");
    }
#endif
    return dwSize;
}

ULONG
CheckFilter(TCHAR *Buffer)
{
    TCHAR *string = Buffer;
    ULONG stringLength, diskperfLen, result;

    if (string == NULL)
        return 0;
    stringLength = _tcslen(string);

    diskperfLen = _tcslen(DISKPERF_SERVICE_NAME);

    result = FALSE;
    while(stringLength != 0) {

        if ((diskperfLen == stringLength) && 
            (_tcsicmp(string, DISKPERF_SERVICE_NAME) == 0)) {
#if DBG
            fprintf(stderr, 
                    "CheckFilter: string found at offset %d\n",
                    (string - Buffer));
#endif
            result = TRUE;
            break;
        } else {
            string += stringLength + 1;
            stringLength = _tcslen(string);
        }
    }
    return result;
}

ULONG
GetEnableFlag(
    IN HKEY hDiskKey,
    IN HKEY hVolumeKey
    )
// Returns the flags indicating what is enabled
{
    ULONG bFlag = 0;
    TCHAR strFilter[MAX_PATH+1] = {0};
    DWORD dwSize;
    ULONG status;

    dwSize = sizeof(TCHAR) * (MAX_PATH+1);
    if (GetFilter(hDiskKey, strFilter, dwSize) > 0) {
        if (CheckFilter(strFilter))
            bFlag |= ENABLE_DISKDRIVE;
    }
#if DBG
    else
        fprintf(stderr, "GetEnableFlag: No filters for disk drive\n");
#endif

    dwSize = sizeof(TCHAR) * (MAX_PATH+1);
    if (GetFilter(hVolumeKey, strFilter, dwSize) > 0) {
        if (CheckFilter(strFilter))
            bFlag |= ENABLE_VOLUME;
    }
#if DBG
    else
        fprintf(stderr, "GetEnableFlag: No filters for volume\n");
#endif
    return bFlag;
}

ULONG
AddToFilter(
    IN HKEY hKey
    )
{
    TCHAR *string, buffer[MAX_PATH+1];
    ULONG dataLength;
    DWORD dwType, dwSize;

    dwSize = sizeof(TCHAR) * MAX_PATH;
    RtlZeroMemory(buffer, dwSize + sizeof(TCHAR));
    string = buffer;

    dataLength = GetFilter(hKey, buffer, dwSize);
    dwSize = dataLength;
#if DBG
    if (dataLength > 0) {
        fprintf(stderr, "AddToFilter: Original string ");
        DbgPrintMultiSz(buffer, dataLength);
        fprintf(stderr, "\n");
    }
    else fprintf(stderr, "AddToFilter: Cannot get original string\n");
#endif
    dataLength /= sizeof(TCHAR);
    if (dataLength != 0) {
        dataLength -= 1;
    }
    _tcscpy(&(string[dataLength]), DISKPERF_SERVICE_NAME);
    dwSize += (_tcslen(DISKPERF_SERVICE_NAME)+1) * sizeof(TCHAR);

#if DBG
    fprintf(stderr, "AddToFilter: New string ");
    DbgPrintMultiSz(buffer, dataLength + _tcslen(DISKPERF_SERVICE_NAME)+1);
    fprintf(stderr, "\n"); 
#endif
    return SetFilter(hKey, buffer, dwSize);
}

void
PrintStatus(
    IN BOOL bCurrent,
    IN ULONG EnableFlag,
    IN LPCTSTR cMachineName
    )
{
    DWORD       dwValue;
    TCHAR       OemDisplayStringBuffer[DISP_BUFF_LEN * 2];

    dwValue = (EnableFlag == 0) ? SERVICE_DISABLED : SERVICE_BOOT_START;
    if ((EnableFlag & ENABLE_PERMANENT) | (EnableFlag & ENABLE_PERMANENT_IOCTL)) {
        _stprintf(OemDisplayStringBuffer,
                  GetFormatResource(DP_PERMANENT_FORMAT),
                  cMachineName);
        if (EnableFlag & ENABLE_PERMANENT_IOCTL) {
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_IOCTL),
                      cMachineName);
        }
        else {
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_FORMAT1),
                      cMachineName);
            Dp_wprintf(OemDisplayStringBuffer);
            _stprintf(OemDisplayStringBuffer,
                      GetFormatResource(DP_PERMANENT_FORMAT2),
                      cMachineName);
        }
    }
    else  if ( (EnableFlag == (ENABLE_DISKDRIVE | ENABLE_VOLUME)) ||
               (EnableFlag == 0) ) {
        _stprintf(OemDisplayStringBuffer,
                bCurrent ?  GetFormatResource (DP_CURRENT_FORMAT1)
                         :  GetFormatResource (DP_NEW_DISKPERF_STATUS1),
                cMachineName,
                GetStringResource(REG_TO_DP_INDEX(dwValue)));
    }
    else {
        _stprintf (OemDisplayStringBuffer,
                 bCurrent ?  GetFormatResource (DP_CURRENT_FORMAT)
                          :  GetFormatResource (DP_NEW_DISKPERF_STATUS),
                 (EnableFlag  == ENABLE_DISKDRIVE) ?
                 GetStringResource(DP_PHYSICAL) :
                 GetStringResource(DP_LOGICAL),
                 cMachineName,
                 GetStringResource(REG_TO_DP_INDEX(dwValue)));
    }
    Dp_wprintf(OemDisplayStringBuffer);
}

ULONG
RemoveFromFilter(
    IN HKEY hKey
    )
{
    TCHAR *string, buffer[MAX_PATH+1];
    ULONG dataLength, stringLength, diskperfLen, found;
    ULONG removeSize;

    dataLength = sizeof(TCHAR) * (MAX_PATH+1);
    RtlZeroMemory(buffer, sizeof(TCHAR) * MAX_PATH);
    dataLength = GetFilter(hKey, buffer, dataLength);
    if (dataLength == 0)
        return 0;

#if DBG
    fprintf(stderr, "RemoveFromFilter: Original string ");
    DbgPrintMultiSz(buffer, dataLength);
    fprintf(stderr, "'\n");
#endif

    string = (TCHAR *) buffer;
    if(dataLength != 0) {
        dataLength -= sizeof(TCHAR);
    }

    //
    // now, find DiskPerf from the entry to remove it
    //
    stringLength = _tcslen(string);

    diskperfLen = _tcslen(DISKPERF_SERVICE_NAME); // includes NULL
    removeSize = (diskperfLen+1) * sizeof(TCHAR);

#if DBG
    fprintf(stderr, "RemoveFromFilter: diskperfLen=%d removeSize=%d\n",
                    diskperfLen, removeSize);
#endif
    found = FALSE;
    while(stringLength != 0 && !found) {

#if DBG
        fprintf(stderr,
            "RemoveFromFilter: Loop stringLength=%d\n", stringLength);
#endif
        if (diskperfLen == stringLength) {
            if(_tcsicmp(string, DISKPERF_SERVICE_NAME) == 0) {
                //
                // found it, so we will remove it right now
                //
                if (dataLength > removeSize) {
                    RtlCopyMemory(
                        string,
                        string+stringLength+1,
                        dataLength - removeSize);
                    RtlZeroMemory(
                        buffer + dataLength - removeSize,
                        removeSize);
                }
                else {
                    RtlZeroMemory( buffer, removeSize);
                }
                found = TRUE;
            }
        } else {        // else, try the next entry
            string += stringLength + 1;
            stringLength = _tcslen(string);
        }
    }
    dataLength = dataLength + sizeof(TCHAR) - removeSize;
    buffer[dataLength] = 0;
/*    if (dataLength == sizeof(TCHAR)) {
        dataLength += sizeof(TCHAR);
        buffer[dataLength] = 0;
    } */

#if DBG
    fprintf(stderr, "RemoveFromFilter: New string ");
    DbgPrintMultiSz(buffer, dataLength);
    fprintf(stderr, "\n");
#endif
    return SetFilter(hKey, buffer, dataLength);
}




 /***
 * Dp_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This Dp_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
Dp_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = Dp_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * Dp_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW. 
 * Note: This Dp_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
Dp_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = Dp_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
Dp_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}



#if DBG
void
DbgPrintMultiSz(
    TCHAR *String,
    ULONG Size
    )
{
    ULONG len;

#if DBG
    fprintf(stderr, "%d ", Size);
#endif
    len = _tcslen(String);
    while (len > 0) {
        _ftprintf(stderr, _T("'%s' "), String);
        String += len+1;
        len = _tcslen(String);
    }
}
#endif


void
SplitCommandLine(
    LPTSTR CommandLine,
    LPTSTR* pArgv
    )
{

    LPTSTR arg;
    int i = 0;
    arg = _tcstok( CommandLine, _T(" \t"));
    while( arg != NULL ){
        _tcscpy(pArgv[i++], arg);
        arg = _tcstok(NULL, _T(" \t"));
    }
}

int 
__cdecl main(
    int argc, 
    char **argv
    )
{
    LPTSTR *targv,*commandLine;
    ULONG  Status = ERROR_SUCCESS;
    int i;

    setlocale(LC_ALL, ".OCP");

    MySetThreadUILanguage(0);

    commandLine = (LPTSTR*)malloc( argc * sizeof(LPTSTR) );
    if (!commandLine)
        exit(1);
    for(i=0;i<argc;i++){
        commandLine[i] = (LPTSTR)malloc( (strlen(argv[i])+1) * sizeof(LPTSTR));
        if (!commandLine[i]) 
            exit(1);
    }

    SplitCommandLine( GetCommandLine(), commandLine );
    targv = commandLine;

    hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;

    // check for command arguments
    
    if (argc == CMD_SHOW_LOCAL_STATUS) {
        Status = DisplayStatus(NULL);
//        if (Status == ERROR_SUCCESS) {
//            DisplayChangeCmd();
//      }
    } else if (argc >= CMD_DO_COMMAND) {
        if (ArgIsSystem(targv[1])) {
            Status = DisplayStatus (targv[1]);
//          if (Status != ERROR_SUCCESS) {
//              DisplayChangeCmd();
//          }
        } else {    // do change command
            if (argc == LOCAL_CHANGE) {
                DoChangeCommand (targv[1], NULL);
            } else if (argc == REMOTE_CHANGE) {
                DoChangeCommand(targv[1], targv[2]);
            } else {
                DisplayChangeCmd();
            }
        }
    } else {
        DisplayCmdHelp();
    }
    Dp_wprintf(_T("\n"));

    for(i=0;i<argc;i++){
        free(commandLine[i]);
        commandLine[i] = NULL;
    }
    free(commandLine);

    return 0;
}

BOOL
IsBeyondW2K(
    IN LPCTSTR lpszMachine,
    OUT PDWORD EnableCounter
    )
{
    OSVERSIONINFO OsVersion;
    HKEY hRegistry, hKey;
    TCHAR szBuildNumber[32];
    TCHAR szVersion[32];
    DWORD dwBuildNumber, dwMajor, status, dwSize;
    BOOL bRet = FALSE;

    *EnableCounter = 0;
    if (lpszMachine != NULL) {
        if (*lpszMachine != 0) {
           status = RegConnectRegistry(
                       lpszMachine,
                       HKEY_LOCAL_MACHINE,
                       &hRegistry);
            if (status != ERROR_SUCCESS)
                return FALSE;
            status = RegOpenKeyEx(
                        hRegistry,
                        lpwszOsVersionKey,
                        (DWORD) 0,
                        KEY_QUERY_VALUE,
                        &hKey);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hRegistry);
                return FALSE;
            }
            dwSize = sizeof(TCHAR) * 32;
            status = RegQueryValueEx(
                        hKey,
                        lpwszBuildNumber,
                        NULL,
                        NULL,
                        (BYTE*)szBuildNumber,
                        &dwSize);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hKey);
                RegCloseKey(hRegistry);
                return FALSE;
            }
            status = RegQueryValueEx(
                       hKey,
                       lpwszOsVersion,
                       NULL,
                       NULL,
                       (BYTE*)szVersion,
                       &dwSize);
            if (status != ERROR_SUCCESS) {
                RegCloseKey(hKey);
                RegCloseKey(hRegistry);
                return FALSE;
            }
            RegCloseKey(hKey);
            status = RegOpenKeyEx(
                        hRegistry,
                        lpwszPartmgrKey,
                        (DWORD) 0,
                        KEY_QUERY_VALUE,
                        &hKey);
            if (status == ERROR_SUCCESS) {
                *EnableCounter = 0;
                status = RegQueryValueEx(
                            hKey,
                            lpwszEnableCounterValue,
                            NULL,
                            NULL,
                            (BYTE*) EnableCounter,
                            &dwSize);
                if ((status != ERROR_SUCCESS) || (dwSize != sizeof(DWORD))) {
                    *EnableCounter = 0;
                }
            }
            dwBuildNumber = _ttoi(szBuildNumber);
            dwMajor = _ttoi(szVersion);
            if ((dwMajor >= 5) && (dwBuildNumber > 2195)) {
                bRet = TRUE;
                status = RegOpenKeyEx(
                            hRegistry,
                            lpwszPartmgrKey,
                            (DWORD) 0,
                            KEY_QUERY_VALUE,
                            &hKey);
                if (status == ERROR_SUCCESS) {
                    status = RegQueryValueEx(
                                hKey,
                                lpwszEnableCounterValue,
                                NULL,
                                NULL,
                                (BYTE*) EnableCounter,
                                &dwSize);
                    if ((status != ERROR_SUCCESS) || (dwSize != sizeof(DWORD))) {
                        *EnableCounter = 0;
                    }
                    RegCloseKey(hKey);
                }
            }
            RegCloseKey(hRegistry);
        }
    }
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&OsVersion)) {
        if ((OsVersion.dwMajorVersion >= 5) &&
            (OsVersion.dwMinorVersion > 0) &&
            (OsVersion.dwBuildNumber > 2195))
        return TRUE;
    }
    return FALSE;
}

ULONG
EnableForIoctl(
    IN LPWSTR lpszMachineName
    )
{
    DWORD status;
    HKEY hRegistry, hKey;
    DWORD dwValue = 1;

    hRegistry = NULL;

    status = RegConnectRegistry(
                lpszMachineName,
                HKEY_LOCAL_MACHINE,
                &hRegistry);
    if (status != ERROR_SUCCESS)
        return status;
    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    hKey = NULL;
    status = RegOpenKeyEx(
                hRegistry,
                lpwszPartmgrKey,
                (DWORD) 0,
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hRegistry);
        return status;
    }
    status = RegSetValueEx(
                hKey,
                lpwszEnableCounterValue,
                0L,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);
    return 0;
}

ULONG
DisableForIoctl(
    IN LPWSTR lpszMachineName,
    IN ULONG Request
    )
{
    ULONG nDisk, i;
    SYSTEM_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS status;

    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;

    WCHAR devname[256];
    PWCHAR s;

    HANDLE PartitionHandle, MountMgrHandle, VolumeHandle;
    DWORD ReturnedBytes;

    DWORD MountError;
    HKEY hRegistry, hKey;

    status = RegConnectRegistry(
                lpszMachineName,
                HKEY_LOCAL_MACHINE,
                &hRegistry);
    if (status != ERROR_SUCCESS)
        return status;
    if (hRegistry == NULL)
        return ERROR_INVALID_PARAMETER;

    status = RegOpenKeyEx(
                hRegistry,
                lpwszPartmgrKey,
                (DWORD) 0,
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey);
    if (status != ERROR_SUCCESS) {
        RegCloseKey(hRegistry);
        return status;
    }
    RegDeleteValue(hKey, lpwszEnableCounterValue);
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);

    if (!(Request & ENABLE_DISKDRIVE)) goto DisableVolume;
    status = NtQuerySystemInformation(SystemDeviceInformation, &DeviceInfo, sizeof(DeviceInfo), NULL);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    nDisk = DeviceInfo.NumberOfDisks;
    // for each physical disk
    for (i = 0; i < nDisk; i++) {

        swprintf(devname, L"\\Device\\Harddisk%d\\Partition0", i);

        RtlInitUnicodeString(&UnicodeName, devname);

        InitializeObjectAttributes(
                   &ObjectAttributes,
                   &UnicodeName,
                   OBJ_CASE_INSENSITIVE,
                   NULL,
                   NULL
                   );
        // opening a partition handle for physical drives
        status = NtOpenFile(
                &PartitionHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );

        if ( !NT_SUCCESS(status) ) {
            continue;
        }
        // sending IOCTL over to Partition Handle
        if (!DeviceIoControl(PartitionHandle,
                        IOCTL_DISK_PERFORMANCE_OFF,
                        NULL,
                        0,
                        NULL,
                        0,
                        &ReturnedBytes,
                        NULL
                        )) {
#if DBG
            printf("IOCTL failed for %ws\n", devname);
#endif
        }

        NtClose(PartitionHandle);
    }

    DisableVolume:
    if (!(Request | ENABLE_VOLUME)) {
        return 0;
    }

    MountMgrHandle = FindFirstVolumeW(devname, sizeof(devname));
    if (MountMgrHandle == NULL) {
#if DBG
        printf("Cannot find first volume\n");
#endif
        return 0;
    }
    s = (PWCHAR) &devname[wcslen(devname)-1];
    if (*s == L'\\') {
        *s = UNICODE_NULL;
    }

    VolumeHandle = CreateFile(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
    if (VolumeHandle != INVALID_HANDLE_VALUE) {
#if DBG
        printf("Opened with success\n");
#endif
        // sending IOCTL over to a volume handle
        if (!DeviceIoControl(VolumeHandle,
               IOCTL_DISK_PERFORMANCE_OFF,
               NULL,
               0,
               NULL,
               0,
               &ReturnedBytes,
               NULL
               )) {
#if DBG
            printf("IOCTL failed for %ws\n", devname);
#endif
        }
       CloseHandle(VolumeHandle);
    }

    while (FindNextVolumeW(MountMgrHandle, devname, sizeof(devname))) {
        s = (PWCHAR) &devname[wcslen(devname)-1];
        if (*s == L'\\') {
            *s = UNICODE_NULL;
        }
        VolumeHandle = CreateFile(devname, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE);
        if (VolumeHandle != INVALID_HANDLE_VALUE) {
#if DBG
            printf("Opened with success\n");
#endif
            if (!DeviceIoControl(VolumeHandle,
                   IOCTL_DISK_PERFORMANCE_OFF,
                   NULL,
                   0,
                   NULL,
                   0,
                   &ReturnedBytes,
                   NULL
                   )) {
#if DBG
               printf("IOCTL failed for %ws\n", devname);
#endif
           }
           CloseHandle(VolumeHandle);
        }
    }
    FindVolumeClose(MountMgrHandle);
    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  MySetThreadUILanguage
//
//  This routine sets the thread UI language based on the console codepage.
//
//  9-29-00    WeiWu    Created.
//  Copied from Base\Win32\Winnls so that it works in W2K as well
////////////////////////////////////////////////////////////////////////////

LANGID WINAPI MySetThreadUILanguage(
    WORD wReserved)
{
    //
    //  Cache system locale and CP info
    // 
    static LCID s_lidSystem = 0;
    static UINT s_uiSysCp = 0;
    static UINT s_uiSysOEMCp = 0;

    ULONG uiUserUICp;
    ULONG uiUserUIOEMCp;
    WCHAR szData[16];
    UNICODE_STRING ucStr;

    LANGID lidUserUI = GetUserDefaultUILanguage();
    LCID lcidThreadOld = GetThreadLocale();

    //
    //  Set default thread locale to EN-US
    //
    //  This allow us to fall back to English UI to avoid trashed characters 
    //  when console doesn't meet the criteria of rendering native UI.
    //
    LCID lcidThread = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
    UINT uiConsoleCp = GetConsoleOutputCP();

    //
    //  Make sure nobody uses it yet
    //
    ASSERT(wReserved == 0);

    //
    //  Get cached system locale and CP info.
    //
    if (!s_uiSysCp)
    {
        LCID lcidSystem = GetSystemDefaultLCID();

        if (lcidSystem)
        {
            //
            // Get ANSI CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUICp);

            //
            // Get OEM CP
            //
            GetLocaleInfoW(lcidSystem, LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
            RtlInitUnicodeString(&ucStr, szData);
            RtlUnicodeStringToInteger(&ucStr, 10, &s_uiSysOEMCp);
            
            //
            // Cache system primary langauge
            //
            s_lidSystem = PRIMARYLANGID(LANGIDFROMLCID(lcidSystem));
        }
    }

    //
    //  Don't cache user UI language and CP info, UI language can be changed without system reboot.
    //
    if (lidUserUI)
    {
        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(&ucStr, szData);
        RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUICp);

        GetLocaleInfoW(MAKELCID(lidUserUI,SORT_DEFAULT), LOCALE_IDEFAULTCODEPAGE, szData, sizeof(szData)/sizeof(WCHAR));
        RtlInitUnicodeString(&ucStr, szData);
        RtlUnicodeStringToInteger(&ucStr, 10, &uiUserUIOEMCp);
    }

    //
    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
    //
    if (uiConsoleCp && 
        s_lidSystem != LANG_ARABIC && 
        s_lidSystem != LANG_HEBREW &&
        s_lidSystem != LANG_VIETNAMESE && 
        s_lidSystem != LANG_THAI)
    {
        //
        //  Use UI language for console only when console CP, system CP and UI language CP match.
        //
        if ((uiConsoleCp == s_uiSysCp || uiConsoleCp == s_uiSysOEMCp) && 
            (uiConsoleCp == uiUserUICp || uiConsoleCp == uiUserUIOEMCp))
        {
            lcidThread = MAKELCID(lidUserUI, SORT_DEFAULT);
        }
    }

    //
    //  Set the thread locale if it's different from the currently set
    //  thread locale.
    //
    if ((lcidThread != lcidThreadOld) && (!SetThreadLocale(lcidThread)))
    {
        lcidThread = lcidThreadOld;
    }

    //
    //  Return the thread locale that was set.
    //
    return (LANGIDFROMLCID(lcidThread));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dskbench\dskbench.h ===
#define BENCH_DLG                   104
#define TIMER_ID                    105
#define TIMER_ID2                   106

#define DRV_BOX                     300
#define START_BUTTON                303
#define STOP_BUTTON                 304
#define QUIT_BUTTON                 305
#define SPIN_CTL                    306
#define SPIN_CTL2                   307
#define BUFFER_TEXT                 308
#define STATUS_BUFFER               310
#define STATUS_IOCOUNT              311
#define STATUS_CASE                 312
#define STATUS_CASE1                313
#define STATUS_TEST                 314
#define TIME_TEXT                   315

#define TEST_RAD_READ               316
#define TEST_RAD_WRITE              317
#define VAR_RAD_SEQ                 318
#define VAR_RAD_RAND                319
#define GAUGE                       320

#define FILE_SIZE     40 * 1024 * 1024

typedef struct _PARAMS{
    ULONG   BufferSize;
    PCHAR   TargetFile;
    ULONG   Tcount;
} PARAMS, *PPARAMS;


typedef struct _FILE_PARAMS {
    PCHAR   TestDrive;
    PCHAR   TestFile;
    HWND    Window;
} FILE_PARAMS, *PFILE_PARAMS;


INT APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInst,
    LPSTR     CmdLine,
    INT       CmdShow
    );

INT_PTR CALLBACK
BenchDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );


VOID        DrawMeterBar( HWND, DWORD, DWORD, DWORD, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dskbench\dskbench.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    diskmon.c

Abstract:

    This module contians the code for the disk monitor utility.

Author:

    Chuck Park (chuckp) 15-Feb-1994
    Mike Glass (mglass)

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>

#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "dskbench.h"

CHAR    TestDrv[8]    = "\\\\.\\";
CHAR    TestFile[MAX_PATH];
CHAR    TimerText[]   = "00:00:00:00";
DWORD   SectorSize;
HANDLE  DrvStrHandle;

HANDLE  ThrdHandle;
ULONG   BufferSize  = 0,
        IoCount     = 0,
        index       = 0,
        Seconds     = 0,
        Minutes     = 0,
        Hours       = 0,
        Days        = 0,
        ElapsedTime = 0,
        NumberIOs   = 0;

BOOL    RunTest         = FALSE;
BOOL    TestFileCreated = FALSE;
BOOL    KillFileCreate  = FALSE;

PARAMS  Params;
FILE_PARAMS TestFileParams;

HINSTANCE HInst;
HWND      Gauge;
DWORD     GaugeId;

//
// Thread proc. declarations
//

DWORD
ReadSequential(
    PPARAMS pParams
    );

DWORD
WriteSequential(
    PPARAMS pParams
    );

DWORD
ReadRandom(
    PPARAMS pParams
    );

DWORD
WriteRandom(
    PPARAMS pParams
    );


//
// Common util. functions
//

ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    );


BOOL
GetSectorSize(
    PDWORD SectorSize,
    PCHAR  DrvLetter
    );

VOID
LogError(
    PCHAR ErrString,
    DWORD UniqueId,
    DWORD ErrCode
    );


VOID
Usage(
    VOID
    );

LPTHREAD_START_ROUTINE
    TestProc[4] = {ReadSequential,
                   ReadRandom,
                   WriteSequential,
                   WriteRandom
                   };


BOOL
InitDialog (
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    BOOLEAN Found = FALSE;
    CHAR   buffer[34];
    DWORD  bytes;
    HWND   Drives = GetDlgItem (hwnd,DRV_BOX);
    PCHAR  lp;
    UINT   i = 0,
           NoDrives = 0;

    srand(GetTickCount());
    Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), FALSE);


    //
    // Get attached drives, filter out non-disk drives, and fill drive box.
    //

    bytes = GetLogicalDriveStrings(0,NULL);

    DrvStrHandle = VirtualAlloc(NULL,bytes + 1,
                                MEM_COMMIT | MEM_RESERVE,
                                PAGE_READWRITE);

    GetLogicalDriveStrings( bytes, DrvStrHandle);
    for (lp = DrvStrHandle;*lp; ) {
        if (GetDriveType(lp) == DRIVE_FIXED) {
            ComboBox_AddString(Drives,lp);
            ++NoDrives;
        }
        while(*lp++);
    }

    //
    // Check for cmd line params passed in, and set the test drive to either
    // the specified drive, or to the first in the drive list.
    //

    ComboBox_SetCurSel (Drives,0);
    if (TestDrv[4] != '\0') {
        do {
            ComboBox_GetText(GetDlgItem(hwnd,DRV_BOX),buffer,4);
            if (buffer[0] == TestDrv[4]) {
                Found = TRUE;
            } else {
                if (++i >= NoDrives) {
                    Found = TRUE;
                } else {
                    ComboBox_SetCurSel (Drives,i);
                }
            }
        } while (!Found);
        if (i >= NoDrives) {

            //
            // Couldn't find the drive, exit with a message.
            //

            LogError("Incorrect Drive Letter in command line.",1,0);
            EndDialog(hwnd,0);
            return FALSE;
        }

    } else {
        ComboBox_SetCurSel (Drives,0);
    }

    //
    // Get the sector size for the default selection.
    //
    TestDrv[4] = '\0';
    ComboBox_GetText(GetDlgItem(hwnd,DRV_BOX),buffer, 4);
    strcat (TestDrv,buffer);
    TestDrv[6] = '\0';
    GetSectorSize(&SectorSize,TestDrv);

    //
    // If index is 0, use defaults, otherwise set the test according to
    // the cmdline passes in.
    //

    Button_SetCheck(GetDlgItem(hwnd,TEST_RAD_READ + (index >> 1)), TRUE);
    Button_SetCheck(GetDlgItem(hwnd,VAR_RAD_SEQ + (index & 0x01)),TRUE);

    //
    // Set buffer size.
    //

    if (BufferSize == 0) {

        BufferSize = 65536;
        NumberIOs = FILE_SIZE / BufferSize;

    } else {

        //
        // Verify that buffersize is a multiple of sector size, if not adjust it.
        //

        if (BufferSize % SectorSize) {
            BufferSize &= ~(SectorSize - 1);
        }

        NumberIOs = FILE_SIZE / BufferSize;

        //
        // Cmd line was present and has been used to config. the test. Send a message
        // to the start button to get things rolling.
        //

        SendMessage(hwnd,WM_COMMAND,(BN_CLICKED << 16) | START_BUTTON,(LPARAM)GetDlgItem(hwnd,START_BUTTON));
    }
    _ultoa(BufferSize,buffer,10);
    Static_SetText(GetDlgItem(hwnd,BUFFER_TEXT),buffer);

    return(TRUE);
}


DWORD
CreateTestFile(
    PFILE_PARAMS  FileParams
    )
{
    PCHAR      index = FileParams->TestDrive;
    PUCHAR     buffer;
    CHAR       errBuf[80];
    HANDLE     file,port;
    OVERLAPPED overlapped,*overlapped2;
    DWORD      bytesTransferred,bytesTransferred2;
    DWORD_PTR  key;
    BOOL       status;
    ULONG      i;

    while (*index == '\\' || *index == '.') {
        index++;
    }

    strcpy(FileParams->TestFile,index);
    strcat(FileParams->TestFile,"\\test.dat");
    DeleteFile(FileParams->TestFile);

    buffer = VirtualAlloc(NULL,
                          BufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE);

    if ( !buffer ) {
        sprintf(errBuf,"Error allocating buffer %d\n",GetLastError());
        MessageBox(NULL,errBuf,"Error",MB_ICONEXCLAMATION|MB_OK);
        ExitThread(3);
        return 3;
    }

    file = CreateFile(FileParams->TestFile,
                      GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        sprintf(errBuf,"Error opening file %s %d\n",FileParams->TestFile,GetLastError());
        MessageBox(NULL,errBuf,"Error",MB_ICONEXCLAMATION|MB_OK);
        ExitThread(3);
        return 3;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        sprintf(errBuf,"Error creating completion port %d\n",GetLastError());
        MessageBox(NULL,errBuf,"Error",MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }

    memset(&overlapped,0,sizeof(overlapped));

    for (i = 0; i < NumberIOs; i++) {

        //
        // If user aborted file create, exit.
        //

        if (KillFileCreate) {

            DeleteFile(FileParams->TestFile);

            ExitThread(4);
            return 4;
        }

retryWrite:
        status = WriteFile(file,
                           buffer,
                           BufferSize,
                           &bytesTransferred,
                           &overlapped);

        if ( !status && GetLastError() != ERROR_IO_PENDING ) {
            if (GetLastError() == ERROR_INVALID_USER_BUFFER ||
                GetLastError() == ERROR_NOT_ENOUGH_QUOTA ||
                GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

                goto retryWrite;
            }
            sprintf(errBuf,"Error creating test file %d\n",GetLastError());
            MessageBox(NULL,errBuf,"Error",MB_ICONEXCLAMATION|MB_OK);
            ExitThread(3);
            return 3;
        }

        //
        // Update gauge.
        //

        DrawMeterBar(FileParams->Window,GaugeId,i / 2,NumberIOs,FALSE);

        overlapped.Offset += BufferSize;
    }

    for (i = 0; i < NumberIOs; i++ ) {
        status = GetQueuedCompletionStatus(port,
                                           &bytesTransferred2,
                                           &key,
                                           &overlapped2,
                                           (DWORD)-1);
        if ( !status ) {
            sprintf(errBuf,"Error picking up completion pre-write %d\n",GetLastError());
            MessageBox(NULL,errBuf,"Error",MB_ICONEXCLAMATION|MB_OK);
            ExitThread(2);
            return 2;
        }

        DrawMeterBar(FileParams->Window,GaugeId, NumberIOs / 2 + i / 2,NumberIOs,FALSE);
    }

    CloseHandle(port);
    CloseHandle(file);

    ExitThread(1);
    return 1;
}

//
// Progress gauge courtesy of wesw
//

VOID
DrawMeterBar(
    HWND   hwnd,
    DWORD  ctlId,
    DWORD  wPartsComplete,
    DWORD  wPartsInJob,
    BOOL   fRedraw
    )
{
    RECT    rcPrcnt;
    DWORD   dwColor;
    SIZE    size;
    DWORD   pct;
    CHAR    szPercentage[255];
    HPEN    hpen;
    HPEN    oldhpen;
    HDC     hDC;
    RECT    rcItem;
    POINT   pt;

    hDC = GetDC( hwnd );

    GetWindowRect( GetDlgItem(hwnd,ctlId), &rcItem );

    pt.x = rcItem.left;
    pt.y = rcItem.top;
    ScreenToClient( hwnd, &pt );
    rcItem.left = pt.x;
    rcItem.top  = pt.y;

    pt.x = rcItem.right;
    pt.y = rcItem.bottom;
    ScreenToClient( hwnd, &pt );
    rcItem.right  = pt.x;
    rcItem.bottom = pt.y;

    hpen = CreatePen( PS_SOLID, 1, RGB(0,0,0) );
    if (hpen) {
        oldhpen = SelectObject( hDC, hpen );
        if (fRedraw) {
            Rectangle( hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom );
        }
        SelectObject( hDC, oldhpen );
        DeleteObject( hpen );
    }
    rcItem.left   += 2;
    rcItem.top    += 2;
    rcItem.right  -= 2;
    rcItem.bottom -= 2;

    //
    // Set-up default foreground and background text colors.
    //
    SetBkColor( hDC, RGB(125,125,125) );
    SetTextColor( hDC, RGB(125,58,125) );

    SetTextAlign(hDC, TA_CENTER | TA_TOP);

    //
    // Invert the foreground and background colors.
    //
    dwColor = GetBkColor(hDC);
    SetBkColor(hDC, SetTextColor(hDC, dwColor));

    //
    // calculate the percentage done
    //
    try {
        pct = (DWORD)((float)wPartsComplete / (float)wPartsInJob * 100.0);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        pct = 0;
    }

    //
    // Set rectangle coordinates to include only left part of the window
    //
    rcPrcnt.top    = rcItem.top;
    rcPrcnt.bottom = rcItem.bottom;
    rcPrcnt.left   = rcItem.left;
    rcPrcnt.right  = rcItem.left +
                     (DWORD)((float)(rcItem.right - rcItem.left) * ((float)pct / 100));

    //
    // Output the percentage value in the window.
    // Function also paints left part of window.
    //
    wsprintf(szPercentage, "%d%%", pct);
    GetTextExtentPoint(hDC, "X", 1, &size);
    ExtTextOut( hDC,
                (rcItem.right - rcItem.left) / 2,
                rcItem.top + ((rcItem.bottom - rcItem.top - size.cy) / 2),
                ETO_OPAQUE | ETO_CLIPPED,
                &rcPrcnt,
                szPercentage,
                strlen(szPercentage),
                NULL
              );

    //
    // Adjust rectangle so that it includes the remaining
    // percentage of the window.
    //
    rcPrcnt.left = rcPrcnt.right;
    rcPrcnt.right = rcItem.right;

    //
    // Invert the foreground and background colors.
    //
    dwColor = GetBkColor(hDC);
    SetBkColor(hDC, SetTextColor(hDC, dwColor));

    //
    // Output the percentage value a second time in the window.
    // Function also paints right part of window.
    //
    ExtTextOut( hDC,
                (rcItem.right - rcItem.left) / 2,
                rcItem.top + ((rcItem.bottom - rcItem.top - size.cy) / 2),
                ETO_OPAQUE | ETO_CLIPPED,
                &rcPrcnt,
                szPercentage,
                strlen(szPercentage),
                NULL
              );
    ReleaseDC( hwnd, hDC );
    return;
}

VOID
ProcessCommands(
    HWND hwnd,
    INT  id,
    HWND hwndCtl,
    UINT codeNotify)
{
    DWORD        exitCode;
    CHAR         buffer[20];
    ULONG        tid;
    ULONG        units;

    switch (id) {
        case DRV_BOX:
            if (codeNotify == CBN_KILLFOCUS) {

                //
                // Determine sector size of chosen drive.
                //

                ComboBox_GetText(GetDlgItem(hwnd,DRV_BOX),buffer, 4);
                sprintf(TestDrv,"\\\\.\\");
                strcat(TestDrv,buffer);
                TestDrv[6] = '\0';
                GetSectorSize(&SectorSize,TestDrv);

            }

            break;

        case START_BUTTON:

            if (!TestFileCreated) {

                //
                // Create gauge window.
                //

                units = GetDialogBaseUnits();

                Gauge = CreateWindow("static","",
                                 WS_CHILD | WS_VISIBLE | SS_BLACKFRAME,
                                 (INT)(10 * (units & 0xFFFF) / 4),
                                 (INT)(60 * (units >> 16) / 8),
                                 (INT)(150 *  (units & 0xFFFF) / 4),
                                 (INT)(12 * (units >> 16) / 8),
                                 hwnd,
                                 (HMENU)(26),
                                 HInst,
                                 NULL);

                GaugeId = GetDlgCtrlID(Gauge);

                TestFileParams.TestDrive = TestDrv;
                TestFileParams.TestFile  = TestFile;
                TestFileParams.Window    = hwnd;

                ThrdHandle = CreateThread (NULL,0,(LPTHREAD_START_ROUTINE)CreateTestFile, &TestFileParams,CREATE_SUSPENDED,&tid);
                if (ThrdHandle) {

                    //
                    // Disable controls
                    //

                    Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), TRUE);
                    SetFocus(GetDlgItem(hwnd,STOP_BUTTON));
                    Button_Enable(GetDlgItem(hwnd,START_BUTTON), FALSE);

                    SetTimer(hwnd,TIMER_ID2,1000,(TIMERPROC)NULL);

                    ResumeThread(ThrdHandle);

                    sprintf(buffer,"CREATING TEST FILE");
                    Static_SetText(GetDlgItem(hwnd,STATUS_TEST), buffer);
                }

                break;
            }

            //
            // Determine the test drive.
            //

            strcpy(TestDrv,"\\\\.\\");
            ComboBox_GetText(GetDlgItem(hwnd,DRV_BOX),buffer, 4);
            strcat (TestDrv,buffer);
            TestDrv[6] = '\0';

            //
            // Determine the test case.
            //

            index = Button_GetCheck(GetDlgItem(hwnd,TEST_RAD_WRITE));
            index <<= 1;
            index |= Button_GetCheck(GetDlgItem(hwnd,VAR_RAD_RAND));

            //
            // Update the status fields
            //

            sprintf(buffer,"%Lu",BufferSize);
            Static_SetText(GetDlgItem(hwnd,STATUS_BUFFER ),buffer);
            sprintf(buffer,"%d",IoCount);
            Static_SetText(GetDlgItem(hwnd,STATUS_IOCOUNT), buffer);

            sprintf(buffer,"%s",(index >> 1) ? "Write" : "Read");
            Static_SetText(GetDlgItem(hwnd,STATUS_CASE), buffer);

            sprintf(buffer,"%s",(index & 0x1) ? "Random" : "Sequential");
            Static_SetText(GetDlgItem(hwnd,STATUS_CASE1), buffer);

            sprintf(buffer,"RUNNING");
            Static_SetText(GetDlgItem(hwnd,STATUS_TEST), buffer);

            ElapsedTime = Seconds = Minutes = Hours = Days = 0;
            SetTimer(hwnd,TIMER_ID,1000,(TIMERPROC)NULL);

            //
            // Gather parameters and launch the test.
            //

            Params.BufferSize = BufferSize;
            Params.TargetFile = TestFile;
            Params.Tcount     = NumberIOs;

            RunTest = TRUE;

            //
            // Launch the thread.
            //

            ThrdHandle = CreateThread (NULL,
                                           0,
                                           TestProc[index],
                                           &Params,
                                           CREATE_SUSPENDED,
                                           &tid
                                           );
            if (ThrdHandle)
                ResumeThread(ThrdHandle);

            //
            // Disable controls
            //

            Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), TRUE);
            SetFocus(GetDlgItem(hwnd,STOP_BUTTON));
            Button_Enable(GetDlgItem(hwnd,START_BUTTON), FALSE);

            break;

        case STOP_BUTTON:

            if (!TestFileCreated) {

                //
                // Kill the test file create thread.
                //

                KillFileCreate = TRUE;

                WaitForSingleObject(ThrdHandle,INFINITE);

                //
                // Redo button enable/disable/focus
                //

                Button_Enable(GetDlgItem(hwnd,START_BUTTON), TRUE);
                Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), FALSE);

                SetFocus(GetDlgItem(hwnd,START_BUTTON));

                KillTimer(hwnd, TIMER_ID2);
                KillFileCreate = FALSE;

                sprintf(buffer,"STOPPED");
                Static_SetText(GetDlgItem(hwnd,STATUS_TEST), buffer);

                DestroyWindow(Gauge);
                UpdateWindow(hwnd);

                break;
            }

            KillTimer(hwnd, TIMER_ID);

            //
            // If the thread is not running disregard it.
            //

            GetExitCodeThread(ThrdHandle,&exitCode);
            if (exitCode == STILL_ACTIVE) {

                //
                // Set flag to kill the threads.
                //

                RunTest = FALSE;

                if ((WaitForSingleObject (ThrdHandle,INFINITE)) == WAIT_FAILED) {

                    //
                    // TODO: Do something drastic.
                    //

                }
            }

            //
            // Re-enable/disable buttons
            //

            Button_Enable(GetDlgItem(hwnd,START_BUTTON), TRUE);
            Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), FALSE);


            SetFocus(GetDlgItem(hwnd,START_BUTTON));

            sprintf(buffer,"STOPPED");
            Static_SetText(GetDlgItem(hwnd,STATUS_TEST), buffer);


            break;

        case QUIT_BUTTON:
        case IDCANCEL:
            EndDialog(hwnd, id);
            break;
    default:
        break;
    }
}

VOID
ProcessSpinCmds(
    HWND hwnd,
    HWND hCtl,
    UINT code,
    INT  position)
{
    CHAR buffer[34];


    if (hCtl == GetDlgItem(hwnd,SPIN_CTL)) {

        //
        // Get the current buffer size
        //

        Static_GetText(GetDlgItem(hwnd,BUFFER_TEXT),buffer,sizeof(buffer));
        BufferSize = atol(buffer);
        switch (code) {
            case SB_PAGEDOWN:
            case SB_BOTTOM:
            case SB_LINEDOWN:
                if ((BufferSize -= SectorSize) < SectorSize) {
                    BufferSize = 1048576;
                }

                NumberIOs = FILE_SIZE / BufferSize;
                _ultoa(BufferSize,buffer,10);
                Static_SetText(GetDlgItem(hwnd,BUFFER_TEXT),buffer);
                break;

            case SB_LINEUP:
            case SB_PAGEUP:
            case SB_TOP:

                if ((BufferSize += SectorSize) > 1048576) {
                    BufferSize = SectorSize;
                }

                NumberIOs = FILE_SIZE / BufferSize;
                _ultoa(BufferSize,buffer,10);
                Static_SetText(GetDlgItem(hwnd,BUFFER_TEXT),buffer);
                break;

            case SB_THUMBPOSITION:
            case SB_THUMBTRACK:
                break;
        }
    }
}


VOID
FormatTime(ULONG Time)
{

    ++Seconds;
    if (Seconds % 60  == 0) {
	    ++Minutes;
	    Seconds = 0;

	    if(Minutes % 60 == 0) {
	        ++Hours;
	        Minutes = 0;

	        if(Hours % 24 == 0) {
		        ++Days;
		        Hours = 0;
	        }
	    }
    }

    sprintf(TimerText,"%02d:%02d:%02d:%02d",Days,Hours,Minutes,Seconds);
}

VOID
ProcessTimer(
    HWND hwnd,
    UINT id)
{

    CHAR  buffer[40];

    if (id == TIMER_ID) {

        ++ElapsedTime;
        FormatTime (ElapsedTime);
        SetWindowText(GetDlgItem(hwnd,TIME_TEXT),TimerText);

    } else if (id == TIMER_ID2) {

        //
        // Get status of file create thread.
        //

        if ( WaitForSingleObject (ThrdHandle,0) == WAIT_OBJECT_0) {

            TestFileCreated = TRUE;
            KillTimer(hwnd, TIMER_ID2);

            DestroyWindow(Gauge);
            UpdateWindow(hwnd);

            //
            // Redo controls
            //

            Button_Enable(GetDlgItem(hwnd,START_BUTTON), TRUE);
            Button_Enable(GetDlgItem(hwnd,STOP_BUTTON), FALSE);
            SetFocus(GetDlgItem(hwnd,START_BUTTON));


            sprintf(buffer,"READY");
            Static_SetText(GetDlgItem(hwnd,STATUS_TEST), buffer);
        }
    }

}

INT_PTR
CALLBACK
BenchDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
   BOOL Processed = TRUE;

   switch (uMsg) {
      HANDLE_MSG(hDlg, WM_INITDIALOG, InitDialog);
      HANDLE_MSG(hDlg, WM_COMMAND, ProcessCommands);
      HANDLE_MSG(hDlg, WM_VSCROLL, ProcessSpinCmds);
      HANDLE_MSG(hDlg, WM_TIMER,   ProcessTimer);

      default:
         Processed = FALSE;
         break;
   }
   return Processed;
}




INT APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     CmdLine,
    INT       CmdShow)
{
    CHAR  buffer[10];
    PCHAR tmp = buffer,
          cmdLinePtr,
          ptr;
    //
    // Check for, and process cmd line.
    //

    HInst = hInstance;

    cmdLinePtr = CmdLine;
    if (*cmdLinePtr != '\0') {

        while (*cmdLinePtr != '\0') {
            tmp = buffer;
            memset (tmp,0,sizeof(buffer));
            if (*cmdLinePtr == '-') {
                switch (*(cmdLinePtr + 1)) {
                    case 'b':
                    case 'B':
                        ptr = cmdLinePtr + 2;
                        while (*ptr != ' ') {
                            *tmp++ = *ptr++;
                        }
                        BufferSize = 1024 * atol(buffer);
                        cmdLinePtr = ptr;
                        while (*cmdLinePtr++ == ' ');
                        --cmdLinePtr;
                        break;
                    case 't':
                    case 'T':
                        ptr = cmdLinePtr + 2;
                        if (*ptr != 'r' && *ptr != 'R' && *ptr != 'w' && *ptr != 'W') {
                            Usage();
                            return 1;
                        }
                        index = (*ptr == 'R' || *ptr == 'r') ? 0 : 1;
                        ++ptr;

                        if (*ptr != 's' && *ptr != 'S' && *ptr != 'r' && *ptr != 'R') {
                            Usage();
                            return 1;
                        }
                        index <<= 1;
                        index |= (*ptr == 'S' || *ptr == 's') ? 0 : 1;
                        ++ptr;
                        cmdLinePtr = ptr;
                        while (*cmdLinePtr++ == ' ');
                        --cmdLinePtr;
                        break;

                    default:
                        Usage();
                        return 1;
                }
            } else if (*(cmdLinePtr + 1) == ':') {
                sprintf (buffer,"%c%c%c",toupper(*cmdLinePtr),':','\\');
                strcat (TestDrv,buffer);

                while (*cmdLinePtr++ != ' ');
                while (*cmdLinePtr++ == ' ');

                --cmdLinePtr;

            } else {
                Usage();
                return 1;
            }
        }

    }

    DialogBox(hInstance, MAKEINTRESOURCE(BENCH_DLG), NULL, BenchDlgProc);
    return(0);
}


DWORD
ReadSequential(
    PPARAMS Params
    )
{
    ULONG      j,
               errCode,
               outstandingRequests;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          Params->BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        LogError("Error allocating buffer",1,GetLastError());
        ExitThread(1);
        return 2;
    }

    while (RunTest) {

        file = CreateFile(Params->TargetFile,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                          NULL );

        if ( file == INVALID_HANDLE_VALUE ) {
            LogError("Error opening Target file",2,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(2);
            return 2;
        }

        port = CreateIoCompletionPort(file,
                                      NULL,
                                      (DWORD_PTR)file,
                                      0);
        if ( !port ) {
            LogError("Error creating completion port",3,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(3);
            return 3;
        }

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

            for (j = 0; j < Params->Tcount; j++) {
                do {

                    status = ReadFile(file,
                                      buffer,
                                      Params->BufferSize,
                                      &bytesRead,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            LogError("Error in ReadFile",4,errCode);
                            VirtualFree(buffer,
                                        Params->BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            ExitThread(4);
                            return 4;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                overlapped.Offset += Params->BufferSize;
            }

            for (j = 0; j < outstandingRequests; j++) {

                status = GetQueuedCompletionStatus(port,
                                                   &bytesRead2,
                                                   &completionKey,
                                                   &overlapped2,
                                                   (DWORD)-1);

                if (!status) {
                    LogError("GetQueuedCompletionStatus error.",5,GetLastError());
                    VirtualFree(buffer,
                                Params->BufferSize + SectorSize - 1,
                                MEM_DECOMMIT);
                    ExitThread(5);
                    return 5;
                }

            }

            if (version > 612) {
                CloseHandle(port);
            }

            CloseHandle(file);

    }

    VirtualFree(buffer,
                Params->BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    ExitThread(0);
    return 0;
}

DWORD
WriteSequential(
    PPARAMS Params
    )
{

    ULONG      j,
               errCode,
               outstandingRequests;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWrite,
               bytesWrite2,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          Params->BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        LogError("Error allocating buffer",1,GetLastError());
        ExitThread(1);
        return 2;
    }

    while (RunTest) {

        file = CreateFile(Params->TargetFile,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                          NULL );

        if ( file == INVALID_HANDLE_VALUE ) {
            LogError("Error opening Target file",2,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(2);
            return 2;
        }

        port = CreateIoCompletionPort(file,
                                      NULL,
                                      (DWORD_PTR)file,
                                      0);
        if ( !port ) {
            LogError("Error creating completion port",3,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(3);
            return 3;
        }

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

            for (j = 0; j < Params->Tcount; j++) {
                do {

                    status = WriteFile(file,
                                      buffer,
                                      Params->BufferSize,
                                      &bytesWrite,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            LogError("Error in WriteFile",4,errCode);
                            VirtualFree(buffer,
                                        Params->BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            ExitThread(4);
                            return 4;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                overlapped.Offset += Params->BufferSize;
            }

            for (j = 0; j < outstandingRequests; j++) {

                status = GetQueuedCompletionStatus(port,
                                                   &bytesWrite2,
                                                   &completionKey,
                                                   &overlapped2,
                                                   (DWORD)-1);

                if (!status) {
                    LogError("GetQueuedCompletionStatus error.",5,GetLastError());
                    VirtualFree(buffer,
                                Params->BufferSize + SectorSize - 1,
                                MEM_DECOMMIT);
                    ExitThread(5);
                    return 5;
                }

            }

            if (version > 612) {
                CloseHandle(port);
            }

            CloseHandle(file);

    }

    VirtualFree(buffer,
                Params->BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    ExitThread(0);
    return 0;
}

DWORD
ReadRandom(
    PPARAMS Params
    )
{

    ULONG      j,
               errCode,
               outstandingRequests;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          Params->BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        LogError("Error allocating buffer",1,GetLastError());
        ExitThread(1);
        return 2;
    }

    while (RunTest) {

        file = CreateFile(Params->TargetFile,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                          NULL );

        if ( file == INVALID_HANDLE_VALUE ) {
            LogError("Error opening Target file",2,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(2);
            return 2;
        }

        port = CreateIoCompletionPort(file,
                                      NULL,
                                      (DWORD_PTR)file,
                                      0);
        if ( !port ) {
            LogError("Error creating completion port",3,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(3);
            return 3;
        }

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

            for (j = 0; j < Params->Tcount; j++) {
                do {

                    status = ReadFile(file,
                                      buffer,
                                      Params->BufferSize,
                                      &bytesRead,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            LogError("Error in ReadFile",4,errCode);
                            VirtualFree(buffer,
                                        Params->BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            ExitThread(4);
                            return 4;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                overlapped.Offset = GetRandomOffset(0,FILE_SIZE - Params->BufferSize);
            }

            for (j = 0; j < outstandingRequests; j++) {

                status = GetQueuedCompletionStatus(port,
                                                   &bytesRead2,
                                                   &completionKey,
                                                   &overlapped2,
                                                   (DWORD)-1);

                if (!status) {
                    LogError("GetQueuedCompletionStatus error.",5,GetLastError());
                    VirtualFree(buffer,
                                Params->BufferSize + SectorSize - 1,
                                MEM_DECOMMIT);
                    ExitThread(5);
                    return 5;
                }

            }

            if (version > 612) {
                CloseHandle(port);
            }

            CloseHandle(file);

    }

    VirtualFree(buffer,
                Params->BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    ExitThread(0);
    return 0;
}

DWORD
WriteRandom(
    PPARAMS Params
    )
{
    ULONG      j,
               errCode,
               outstandingRequests;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWrite,
               bytesWrite2,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;


    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          Params->BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        LogError("Error allocating buffer",1,GetLastError());
        ExitThread(1);
        return 2;
    }

    while (RunTest) {

        file = CreateFile(Params->TargetFile,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                          NULL );

        if ( file == INVALID_HANDLE_VALUE ) {
            LogError("Error opening Target file",2,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(2);
            return 2;
        }

        port = CreateIoCompletionPort(file,
                                      NULL,
                                      (DWORD_PTR)file,
                                      0);
        if ( !port ) {
            LogError("Error creating completion port",3,GetLastError());
            VirtualFree(buffer,
                        Params->BufferSize + SectorSize - 1,
                        MEM_DECOMMIT);
            ExitThread(3);
            return 3;
        }

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

            for (j = 0; j < Params->Tcount; j++) {
                do {

                    status = WriteFile(file,
                                      buffer,
                                      Params->BufferSize,
                                      &bytesWrite,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            LogError("Error in WriteFile",4,errCode);
                            VirtualFree(buffer,
                                        Params->BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            ExitThread(4);
                            return 4;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                overlapped.Offset = GetRandomOffset(0,FILE_SIZE - Params->BufferSize);
            }

            for (j = 0; j < outstandingRequests; j++) {

                status = GetQueuedCompletionStatus(port,
                                                   &bytesWrite2,
                                                   &completionKey,
                                                   &overlapped2,
                                                   (DWORD)-1);

                if (!status) {
                    LogError("GetQueuedCompletionStatus error.",5,GetLastError());
                    VirtualFree(buffer,
                                Params->BufferSize + SectorSize - 1,
                                MEM_DECOMMIT);
                    ExitThread(5);
                    return 5;
                }

            }

            if (version > 612) {
                CloseHandle(port);
            }

            CloseHandle(file);

    }

    VirtualFree(buffer,
                Params->BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    ExitThread(0);
    return 0;
}


ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    )
{

    INT base = rand();
    ULONG retval = ((max - min) / RAND_MAX) * base;
    retval += SectorSize -1;
    retval &= ~(SectorSize - 1);
    if (retval < min) {
        return min;
    } else if (retval > max ){
        return max & ~(SectorSize - 1);
    } else{
        return retval;
    }

}


VOID
LogError(
    PCHAR ErrString,
    DWORD UniqueId,
    DWORD ErrCode
    )
{
    CHAR ErrBuf[80];
#if DBG
    sprintf(ErrBuf,"%d: %s WinError %d",UniqueId,ErrString,ErrCode);
    MessageBox(NULL,ErrBuf,"Error",MB_OK | MB_ICONEXCLAMATION);
#else
    return;
#endif

}

BOOL
GetSectorSize(
    PDWORD SectorSize,
    PCHAR  DrvLetter
    )
{
    DISK_GEOMETRY  DiskGeometry;
    DWORD          BytesReturned;
    HANDLE         handle;

    handle = CreateFile(DrvLetter,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                        NULL
                        );
    if (handle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Starting offset and sectors
    //

    if (!DeviceIoControl (handle,
   	              	      IOCTL_DISK_GET_DRIVE_GEOMETRY,
   		                  NULL,
   		                  0,
   		                  &DiskGeometry,
   		                  sizeof(DISK_GEOMETRY),
   		                  &BytesReturned,
   		                  NULL
   		                  )) {
        return FALSE;
    }
    *SectorSize = DiskGeometry.BytesPerSector;

    return TRUE;
}

VOID
Usage(
    VOID
    )
{
    CHAR buffer[255];

    sprintf(buffer,"\nDSKBENCH: V1.0\n\n");
    strcat (buffer,"Usage:  DSKBENCH\n");
    strcat (buffer,"\t[Drvletter:]\n\t[-b] Buffer size in 1kb increments.\n\t[-tXX] Test specifier.");
    strcat (buffer,"\n\tWhere XX is:\n\t\t'RS' - Read sequential.\n\t\t'RR' - Read Random\n\t\t");
    strcat (buffer,"'WS' - Write sequential\n\t\t'WR' - Write Random\n\n");
    strcat (buffer,"Example: Dskbench d: -b64 -tRS\n");

    MessageBox(NULL,buffer,"Usage",MB_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dload\imagehlp.c ===
#include "sdktoolspch.h"
#pragma hdrstop

#define _IMAGEHLP_SOURCE_
#include <imagehlp.h>

static
BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN  HANDLE      FileHandle,
    IN  WORD        TypeFilter,
    OUT PDWORD      CertificateCount,
    IN OUT PDWORD   Indices OPTIONAL,
    IN  DWORD       IndexCount  OPTIONAL
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetCertificateData(
    IN  HANDLE              FileHandle,
    IN  DWORD               CertificateIndex,
    OUT LPWIN_CERTIFICATE   Certificate,
    IN OUT PDWORD           RequiredLength
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   CertificateHeader
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
ImageGetDigestStream(
    IN      HANDLE  FileHandle,
    IN      DWORD   DigestLevel,
    IN      DIGEST_FUNCTION DigestFunction,
    IN      DIGEST_HANDLE   DigestHandle
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
MapAndLoad(
    LPSTR ImageName,
    LPSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    )
{
    return FALSE;
}

static
BOOL
StackWalk(
    DWORD                           MachineType,
    HANDLE                          hProcess,
    HANDLE                          hThread,
    LPSTACKFRAME                    StackFrame32,
    LPVOID                          ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE    ReadMemory32,
    PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccess32,
    PGET_MODULE_BASE_ROUTINE        GetModuleBase32,
    PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress32
    )
{
    return FALSE;
}

static
BOOL
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    return FALSE;
}

static
LPVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{
    return NULL;
}

static
LPVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return NULL;
}

static
BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    )
{
    if (ModuleInfo != NULL) {
        DWORD dwSize = ModuleInfo->SizeOfStruct;
        ZeroMemory(ModuleInfo, dwSize);
        ModuleInfo->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULE64  ModuleInfo
    )
{
    return FALSE;
}

static
DWORD
IMAGEAPI
SymGetOptions(
    VOID
    )
{
    return 0;
}

static
BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD               Address,
    OUT PDWORD              Displacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    )
{
    if (Displacement != NULL) {
        *Displacement = 0;
    }
    if (Symbol != NULL) {
        DWORD dwSize = Symbol->SizeOfStruct;
        ZeroMemory(Symbol, dwSize);
        Symbol->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{
    if (Displacement != NULL) {
        *Displacement = 0;
    }
    if (Symbol != NULL) {
        DWORD dwSize = Symbol->SizeOfStruct;
        ZeroMemory(Symbol, dwSize);
        Symbol->SizeOfStruct = dwSize;
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     InvadeProcess
    )
{
    return FALSE;
}

static
DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return FALSE;
}

static
DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return FALSE;
}

static
DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  PMODLOAD_DATA   Data,
    IN  DWORD           Flags
    )
{
    return FALSE;
}

static
DWORD
IMAGEAPI
SymSetOptions(
    DWORD   UserOptions
    )
{
    return FALSE;
}

static
BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL  sym,
    OUT LPSTR             UnDecName,
    OUT DWORD             UnDecNameLength
    )
{
    if (UnDecName != NULL && UnDecNameLength > 0) {
        UnDecName[0] = '\0';
    }

    return FALSE;
}

static
BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    if (UnDecName != NULL && UnDecNameLength > 0) {
        UnDecName[0] = '\0';
    }

    return FALSE;
}

static
DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    if (outputString != NULL && maxStringLength > 0) {
        outputString[0] = '\0';
    }

    return FALSE;
}

static
BOOL
UnMapAndLoad(
    PLOADED_IMAGE pLi
    )
{
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(imagehlp)
{
    DLPENTRY(ImageEnumerateCertificates)
    DLPENTRY(ImageGetCertificateData)
    DLPENTRY(ImageGetCertificateHeader)
    DLPENTRY(ImageGetDigestStream)
    DLPENTRY(MapAndLoad)
    DLPENTRY(StackWalk)
    DLPENTRY(StackWalk64)
    DLPENTRY(SymFunctionTableAccess)
    DLPENTRY(SymFunctionTableAccess64)
    DLPENTRY(SymGetModuleInfo)
    DLPENTRY(SymGetModuleInfo64)
    DLPENTRY(SymGetOptions)
    DLPENTRY(SymGetSymFromAddr)
    DLPENTRY(SymGetSymFromAddr64)
    DLPENTRY(SymInitialize)
    DLPENTRY(SymLoadModule)
    DLPENTRY(SymLoadModule64)
    DLPENTRY(SymLoadModuleEx)
    DLPENTRY(SymSetOptions)
    DLPENTRY(SymUnDName)
    DLPENTRY(SymUnDName64)
    DLPENTRY(UnDecorateSymbolName)
    DLPENTRY(UnMapAndLoad)
};

DEFINE_PROCNAME_MAP(imagehlp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dskdump\dskdump.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DskDump.c

Abstract:

    This is the main module for the Win32 DskDump command.

Author:

    Gary Kimura     [GaryKi]        26-Aug-91

Revision History:

--*/

#include "DskDump.h"
#include "cvtoem.h"

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    HANDLE Handle;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    LARGE_INTEGER Offset;

    LONG FirstSector;
    LONG Count;
    LONG i;
    LONG j;
    LONG k;

    UCHAR Buffer[512];
    UCHAR NewOutput[80];
    UCHAR PreviousOutput[80];
    LONG LastOut;

    //
    //  Check in the input arguments
    //
    ConvertAppToOem( argc, argv );
    if (argc < 3) {
        printf("Syntax - Drive: [0x]Count [[0x]StartSector]\n");
        return 0;
    }

    if (argc == 4) {
        if (sscanf( argv[3], 
                strncmp( argv[3], "0x", 2 ) ? "%ld" : "%lx",
                &FirstSector ) != 1) 
        {
            printf("Syntax - Drive: [0x]Count [[0x]StartSector]\n");
            return 0;
        }
    } else {
        FirstSector = 0;
    }

    //
    //  Convert the input arguments and tell the user what we're going to do
    //

    if (sscanf( argv[2], strncmp( argv[2], "0x", 2 ) ? "%ld" : "%lx", &Count ) != 1) {
        printf("Syntax - Drive: [0x]Count [[0x]StartSector]\n");
        return 0;
    }

    fprintf(stdout, " Dump of \"%s\" for %ld sectors starting at %ld\n", argv[1], Count, FirstSector);

    if ((Handle = OpenVolume( argv[1][0] )) == NULL) {

        return 0;
    }

    //
    //  for each sector we go through our main loop
    //

    LastOut = -16;

    for (i = FirstSector; i < FirstSector + Count; i += 1) {

        Offset.HighPart = 0;
        Offset.LowPart = i * 512;

        //
        //  Read the file at the indicated Offset
        //

        if (!NT_SUCCESS(Status = NtReadFile( Handle,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &Iosb,
                                          Buffer,
                                          512,
                                          &Offset,
                                          NULL ))) {

            fprintf(stderr, "Read Error - %08lx\n", Status );
            return 0;
        }

        //
        //  And write the buffer to standard out
        //

        for (j = 0; j < 512; j += 16) {

            sprintf( NewOutput, "  %02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x  ",
                     Buffer[j],
                     Buffer[j+1],
                     Buffer[j+2],
                     Buffer[j+3],
                     Buffer[j+4],
                     Buffer[j+5],
                     Buffer[j+6],
                     Buffer[j+7],
                     Buffer[j+8],
                     Buffer[j+9],
                     Buffer[j+10],
                     Buffer[j+11],
                     Buffer[j+12],
                     Buffer[j+13],
                     Buffer[j+14],
                     Buffer[j+15]);

            if (strcmp( NewOutput, PreviousOutput ) != 0 ) {

                if (LastOut + 16 != (i*512L) + j) {
                    fprintf(stdout, "*\n");
                }

                strcpy( PreviousOutput, NewOutput );

                LastOut = (i * 512L) + j;

                fprintf(stdout, "%06lx ", LastOut);

                fprintf(stdout, NewOutput );

                for (k = j; k < j + 16; k += 1) {

                    if (isprint(Buffer[k])) {
                        fprintf(stdout, "%c", Buffer[k]);
                    } else {
                        fprintf(stdout, ".");
                    }
                }

                fprintf(stdout, "\n");

            }

        }

    }

    CloseHandle(Handle);

    return 0;
}

HANDLE
OpenVolume(
    CHAR c
    )
{
    WCHAR VolumeNameW[4];
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;
    LPWSTR FilePart;

    VolumeNameW[0] = (WCHAR)c;
    VolumeNameW[1] = (WCHAR)':';
    VolumeNameW[2] = UNICODE_NULL;

    if (!RtlDosPathNameToNtPathName_U( VolumeNameW, &FileName, &FilePart, NULL )) {

        fprintf(stderr,"Cannot translate drive letter %c\n", c);
        return NULL;
    }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes( &Obja, &FileName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    {
        ULONG i;
        for (i = 0; i < (ULONG)FileName.Length/2; i += 1) {
            if (FileName.Buffer[i] == ':') {
                FileName.Buffer[i+1] = UNICODE_NULL;
                FileName.Length = (USHORT)((i+1)*2);
                break;
            }
        }
    }

    //
    // Open the volume
    //

    Status = NtOpenFile( &Handle,
                         FILE_READ_DATA | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {

        fprintf(stderr,"Cannot open drive letter %c\n", c);
        return NULL;
    }

    return Handle;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\du\du.c ===
// du - simple disk usage program

// If UNICODE/_UNICODE is turned on, we need to link with
// wsetargv.lib (not setargv.lib) and with UMENTRY=wmain
#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <tchar.h>
#include <wchar.h>
#include <string.h>
#include <process.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <locale.h>
#include <windows.h>

typedef struct USESTAT USESTAT;
typedef struct EXTSTAT EXTSTAT;
typedef USESTAT *PUSESTAT;

struct USESTAT {
    DWORDLONG    cchUsed;                    // bytes used in all files
    DWORDLONG    cchAlloc;                   // bytes allocated in all files
    DWORDLONG    cchCompressed;              // compressed bytes in all files
    DWORDLONG    cchDeleted;                 // bytes in deleted files
    DWORDLONG    cFile;                      // number of files
    };

struct EXTSTAT {
    EXTSTAT *Next;
    TCHAR *Extension;
    USESTAT Stat;
};

EXTSTAT *ExtensionList = NULL;
int ExtensionCount = 0;

#define CLEARUSE(use)                                   \
        {   (use).cchUsed       = (DWORDLONG)0;         \
            (use).cchAlloc      = (DWORDLONG)0;         \
            (use).cchDeleted    = (DWORDLONG)0;         \
            (use).cchCompressed = (DWORDLONG)0;         \
            (use).cFile         = (DWORDLONG)0;         \
        }


#define ADDUSE(sum,add)                                 \
        {   (sum).cchUsed       += (add).cchUsed;       \
            (sum).cchAlloc      += (add).cchAlloc;      \
            (sum).cchDeleted    += (add).cchDeleted;    \
            (sum).cchCompressed += (add).cchCompressed; \
            (sum).cFile         += (add).cFile;         \
        }

#define DWORD_SHIFT     (sizeof(DWORD) * 8)

#define SHIFT(c,v)      {c--; v++;}


DWORD  gdwOutputMode;
HANDLE ghStdout;


int cDisp;                              //  number of summary lines displayed
BOOL fExtensionStat = FALSE;            //  TRUE gather statistics by extension
BOOL fNodeSummary = FALSE;              //  TRUE => only display top-level
BOOL fShowDeleted = FALSE;              //  TRUE => show deleted files information
BOOL fThousandSeparator = TRUE;         //  TRUE => use thousand separator in output
BOOL fShowCompressed = FALSE;           //  TRUE => show compressed file info
BOOL fSubtreeTotal = FALSE;             //  TRUE => show info in subtree total form (add from bottom up)
BOOL fUnc = FALSE;                      //  Set if we're checking a UNC path.
TCHAR *pszDeleted = TEXT("deleted\\*.*");

long        bytesPerAlloc;
int         bValidDrive;
DWORDLONG   totFree;
DWORDLONG   totDisk;

TCHAR  buf[MAX_PATH];
TCHAR  root[] = TEXT("?:\\");


USESTAT DoDu (TCHAR *dir);
void TotPrint (PUSESTAT puse, TCHAR *p);

void _setenvp(){ }           // Don't make a copy of the environment

TCHAR ThousandSeparator[8];

// HACK for MSVCRT - Later, ask BryanT if this is still necessary (IanJa)
extern int _dowildcard;
void __cdecl __wsetargv ( void )
{
    _dowildcard = 1;
}

TCHAR *
FormatFileSize(
    DWORDLONG FileSize,
    TCHAR *FormattedSize,
    ULONG Width
    )
{

    TCHAR Buffer[ 100 ];
    TCHAR *s, *s1;
    ULONG DigitIndex, Digit;
    ULONG nThousandSeparator;
    DWORDLONG Size;

    nThousandSeparator = _tcslen(ThousandSeparator);
    s = &Buffer[ 99 ];
    *s = TEXT('\0');
    DigitIndex = 0;
    Size = FileSize;
    while (Size != 0) {
        Digit = (ULONG)(Size % 10);
        Size = Size / 10;
        *--s = (TCHAR)(TEXT('0') + Digit);
        if ((++DigitIndex % 3) == 0 && fThousandSeparator) {
            // If non-null Thousand separator, insert it.
            if (nThousandSeparator) {
                s -= nThousandSeparator;
                _tcsncpy(s, ThousandSeparator, nThousandSeparator);
            }
        }
    }

    if (DigitIndex == 0) {
        *--s = TEXT('0');
    }
    else
    if (fThousandSeparator && !_tcsncmp(s, ThousandSeparator, nThousandSeparator)) {
        s += nThousandSeparator;
    }

    Size = _tcslen( s );
    if (Width != 0 && Size < Width) {
        s1 = FormattedSize;
        while (Width > Size) {
            Width -= 1;
            *s1++ = TEXT(' ');
        }
        _tcscpy( s1, s );
    } else {
        _tcscpy( FormattedSize, s );
    }

    return FormattedSize;
}


#ifdef UNICODE
int __cdecl wmain(int c, wchar_t **v, wchar_t **envp)
#else
int __cdecl main(int c, char *v[])
#endif
{
    int         tenth, pct;
    int         bValidBuf;
    DWORDLONG   tmpTot, tmpFree;
    DWORD       cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    USESTAT     useTot, useTmp;
    TCHAR       Buffer[MAX_PATH];
    TCHAR       *p;
    UINT Codepage;
    char achCodepage[6] = ".OCP";

    ghStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleMode(ghStdout, &gdwOutputMode);
    gdwOutputMode &= ~ENABLE_PROCESSED_OUTPUT;

    /*
     * This is mainly here as a good example of how to set a character-mode
     * application's codepage.
     * This affects C-runtime routines such as mbtowc(), mbstowcs(), wctomb(),
     * wcstombs(), mblen(), _mbstrlen(), isprint(), isalpha() etc.
     * To make sure these C-runtimes come from msvcrt.dll, use TARGETLIBS in
     * the sources file, together with TARGETTYPE=PROGRAM (and not UMAPPL?)
     */
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%3.4d", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    SHIFT (c, v);

    if (GetLocaleInfo(GetUserDefaultLCID(),
                      LOCALE_STHOUSAND,
                      Buffer,
                      sizeof(ThousandSeparator)/sizeof(TCHAR))) {
#ifdef UNICODE
        _tcscpy(ThousandSeparator, Buffer);
#else
        CharToOemA(Buffer, ThousandSeparator);
#endif
    }
    else {
        _tcscpy(ThousandSeparator, TEXT(","));
    }

    while (c && (**v == TEXT('/') || **v == TEXT('-')))
    {
        if (!_tcscmp (*v + 1, TEXT("e"))) {
            fExtensionStat = TRUE;
        } else
        if (!_tcscmp (*v + 1, TEXT("s")))
            fNodeSummary = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("d")))
            fShowDeleted = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("p")))
            fThousandSeparator = FALSE;
        else
        if (!_tcscmp (*v + 1, TEXT("c")))
                fShowCompressed = TRUE;
        else
        if (!_tcscmp (*v + 1, TEXT("t")))
                fSubtreeTotal = TRUE;
        else
        {
            fprintf( stderr, "Usage: DU [/e] [/d] [/p] [/s] [/c] [/t] [dirs]\n" );
            fprintf( stderr, "where:\n" );
            fprintf( stderr, "       /e - displays information by extension.\n" );
            fprintf( stderr, "       /d - displays informations about [deleted] subdirectories.\n" );
            fprintf( stderr, "       /p - displays numbers plainly, without thousand separators.\n" );
            fprintf( stderr, "       /s - displays summary information only.\n" );
            fprintf( stderr, "       /c - displays compressed file information.\n" );
            fprintf( stderr, "       /t - displays information in subtree total form.\n" );
            exit (1);
        }
        SHIFT (c, v);
    }

    if (c == 0)
    {
        GetCurrentDirectory( MAX_PATH, (LPTSTR)buf );

        root[0] = buf[0];
        if( bValidDrive = GetDiskFreeSpace( root,
                                            &cSecsPerClus,
                                            &cBytesPerSec,
                                            &cFreeClus,
                                            &cTotalClus ) == TRUE )
        {
            bytesPerAlloc = cBytesPerSec * cSecsPerClus;
            totFree       = (DWORDLONG)bytesPerAlloc * cFreeClus;
            totDisk       = (DWORDLONG)bytesPerAlloc * cTotalClus;
        }
        useTot = DoDu (buf);
        if (fNodeSummary)
            TotPrint (&useTot, buf);
    }
    else
    {
        CLEARUSE (useTot);

        while (c)
        {
            LPTSTR FilePart;

            bValidBuf = GetFullPathName( *v, MAX_PATH, buf, &FilePart);

            if ( bValidBuf )
            {
                if ( buf[0] == TEXT('\\') ) {

                    fUnc        = TRUE;
                    bValidDrive = TRUE;
                    bytesPerAlloc = 1;
                } else {
                    root[0] = buf[0];
                    if( bValidDrive = GetDiskFreeSpace( root,
                                                        &cSecsPerClus,
                                                        &cBytesPerSec,
                                                        &cFreeClus,
                                                        &cTotalClus ) == TRUE)
                    {
                        bytesPerAlloc = cBytesPerSec * cSecsPerClus;
                        totFree       = (DWORDLONG)bytesPerAlloc * cFreeClus;
                        totDisk       = (DWORDLONG)bytesPerAlloc * cTotalClus;
                    } else
                        _tprintf (TEXT("Invalid drive or directory %s\n"), *v );
                }

                if( bValidDrive && (GetFileAttributes( buf ) & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
                {
                    useTmp = DoDu (buf);
                    if (fNodeSummary)
                        TotPrint (&useTmp, buf);
                    ADDUSE (useTot, useTmp);
                }
            }
            else
                _tprintf (TEXT("Invalid drive or directory %s\n"), *v );
            SHIFT (c, v);
        }
    }

    if (cDisp != 0)
    {
        if (cDisp > 1)
            TotPrint (&useTot, TEXT("Total"));

        /* quick full-disk test */
        if ( !fUnc ) {
            if (totFree == 0)
                puts ("Disk is full");
            else
            {
                tmpTot = (totDisk + 1023) / 1024;
                tmpFree = (totFree + 1023) / 1024;
                pct = (DWORD)(1000 * (tmpTot - tmpFree) / tmpTot);
                tenth = pct % 10;
                pct /= 10;

                // Disable processing so Middle Dot won't beep
                // Middle Dot 0x2022 aliases to ^G when using Raster Fonts
                SetConsoleMode(ghStdout, gdwOutputMode);
                _tprintf(TEXT("%s/"), FormatFileSize( totDisk-totFree, Buffer, 0 ));
                _tprintf(TEXT("%s "), FormatFileSize( totDisk, Buffer, 0 ));
                // Re-enable processing so newline works
                SetConsoleMode(ghStdout, gdwOutputMode | ENABLE_PROCESSED_OUTPUT);

                _tprintf (TEXT("%d.%d%% of disk in use\n"), pct, tenth);
            }
        }
    }

    if (fExtensionStat) {
        int i;

        printf( "\n" );
        for (i = 0; i < ExtensionCount; i++) {
            TotPrint( &ExtensionList[i].Stat, ExtensionList[i].Extension );
        }
    }
    return( 0 );
}

int __cdecl ExtSearchCompare( const void *Key, const void *Element)
{
    return _tcsicmp( (TCHAR *)Key, ((EXTSTAT *) Element)->Extension );
}

int __cdecl ExtSortCompare( const void *Element1, const void *Element2)
{
    return _tcsicmp( ((EXTSTAT *) Element1)->Extension, ((EXTSTAT *) Element2)->Extension );
}

#define MYMAKEDWORDLONG(h,l) (((DWORDLONG)(h) << DWORD_SHIFT) + (DWORDLONG)(l))
#define FILESIZE(wfd)        MYMAKEDWORDLONG((wfd).nFileSizeHigh, (wfd).nFileSizeLow)
#define ROUNDUP(m,n)         ((((m) + (n) - 1) / (n)) * (n))

USESTAT DoDu (TCHAR *dir)
{
    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    USESTAT use, DirUse;

    TCHAR pszSearchName[MAX_PATH];
    TCHAR *pszFilePart;

    DWORDLONG compressedSize;
    DWORD compHi, compLo;

    CLEARUSE(use);

    // Make a copy of the incoming directory name and append a trailing
    // slash if necessary. pszFilePart will point to the char just after
    // the slash, making it easy to build fully qualified filenames.

    _tcscpy(pszSearchName, dir);
    pszFilePart = pszSearchName + _tcslen(pszSearchName);
    if (pszFilePart > pszSearchName)
    {
        if (pszFilePart[-1] != TEXT('\\') && pszFilePart[-1] != TEXT('/'))
        {
            *pszFilePart++ = TEXT('\\');
        }
    }

    if (fShowDeleted) {
        // First count the size of all the files in the current deleted tree

        _tcscpy(pszFilePart, pszDeleted);

        hFind = FindFirstFile(pszSearchName, &wfd);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    use.cchDeleted += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                }
            } while (FindNextFile(hFind, &wfd));

            FindClose(hFind);
        }
    }

    // Then count the size of all the file in the current tree.

    _tcscpy(pszFilePart, TEXT("*.*"));

    hFind = FindFirstFile(pszSearchName, &wfd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                use.cchUsed += FILESIZE( wfd );
                use.cchAlloc += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                use.cFile++;

                compressedSize = FILESIZE(wfd);

                if (fShowCompressed && (wfd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED))
                {
                    _tcscpy(pszFilePart, wfd.cFileName);
                    compLo = GetCompressedFileSize(pszSearchName, &compHi);

                    if (compLo != (DWORD)-1 || GetLastError() == 0) {
                        compressedSize = MYMAKEDWORDLONG(compHi, compLo);
                    }
                }

                use.cchCompressed += compressedSize;

                //
                //  Accrue statistics by extension
                //

                if (fExtensionStat) {
                    TCHAR Ext[_MAX_EXT];
                    EXTSTAT *ExtensionStat;

                    _tsplitpath( wfd.cFileName, NULL, NULL, NULL, Ext );

                    while (TRUE) {

                        //
                        //  Find extension in list
                        //

                        ExtensionStat =
                            (EXTSTAT *) bsearch( Ext, ExtensionList,
                                                 ExtensionCount, sizeof( EXTSTAT ),
                                                 ExtSearchCompare );

                        if (ExtensionStat != NULL) {
                            break;
                        }

                        //
                        //  Extension not found, go add one and resort
                        //

                        ExtensionCount++;
                        ExtensionList =
                            (EXTSTAT *)realloc( ExtensionList,
                                                sizeof( EXTSTAT ) * ExtensionCount);

                        ExtensionList[ExtensionCount - 1].Extension = _tcsdup( Ext );
                        CLEARUSE( ExtensionList[ExtensionCount - 1].Stat );
                        qsort( ExtensionList, ExtensionCount, sizeof( EXTSTAT ), ExtSortCompare );
                    }

                    ExtensionStat->Stat.cchUsed += FILESIZE( wfd );
                    ExtensionStat->Stat.cchAlloc += ROUNDUP( FILESIZE( wfd ), bytesPerAlloc );
                    ExtensionStat->Stat.cchCompressed += compressedSize;
                    ExtensionStat->Stat.cFile++;
                }
            }

        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    if (!fNodeSummary && !fSubtreeTotal)
        TotPrint (&use, dir);

    // Now, do all the subdirs and return the current total.

    _tcscpy(pszFilePart, TEXT("*.*"));
    hFind = FindFirstFile(pszSearchName, &wfd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                _tcsicmp (wfd.cFileName, TEXT("deleted")) &&
                _tcscmp  (wfd.cFileName, TEXT(".")) &&
                _tcscmp  (wfd.cFileName, TEXT("..")))
            {
                _tcscpy(pszFilePart, wfd.cFileName);

                DirUse = DoDu(pszSearchName);

                ADDUSE(use, DirUse);
            }
        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    if (fSubtreeTotal)
        TotPrint(&use, dir);
    
    return(use);
}



void TotPrint (PUSESTAT puse, TCHAR *p)
{
    static BOOL fFirst = TRUE;
    TCHAR  Buffer[MAX_PATH];
    TCHAR  *p1;

    if (fFirst) {
        //              XXX,XXX,XXX,XXX  XXX,XXX,XXX,XXX    xx,xxx,xxx    name
        _tprintf( TEXT("           Used        Allocated  %s%s     Files\n"),
                fShowCompressed ? TEXT("     Compressed  ") : TEXT(""),
        //                              XXX,XXX,XXX,XXX
                fShowDeleted ? TEXT("        Deleted  ") : TEXT("")
        //                           XXX,XXX,XXX,XXX
              );
        fFirst = FALSE;
    }

    // Disable processing so Middle Dot won't beep
    // Middle Dot 0x2022 aliases to ^G when using Raster Fonts
    SetConsoleMode(ghStdout, gdwOutputMode);
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cchUsed, Buffer, 15 ));
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cchAlloc, Buffer, 15 ));
    if (fShowCompressed) {
        _tprintf(TEXT("%s  "), FormatFileSize( puse->cchCompressed, Buffer, 15 ));
    }
    if (fShowDeleted) {
        _tprintf(TEXT("%s  "), FormatFileSize( puse->cchDeleted, Buffer, 15 ));
    }
    _tprintf(TEXT("%s  "), FormatFileSize( puse->cFile, Buffer, 10 ));
    _tprintf(TEXT("%s"),p);
    // Re-enable processing so newline works
    SetConsoleMode(ghStdout, gdwOutputMode | ENABLE_PROCESSED_OUTPUT);
    _tprintf(TEXT("\n"));

    cDisp++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dskdump\dskdump.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    winnt.h

Abstract:

    This is the main header file for the Win32 dskdump command.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


int
ProcessParameters(
    int argc,
    char *argv[]
    );

HANDLE
OpenVolume( CHAR c );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dumppo\dumppo.c ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1988-1991      **/
/*****************************************************************/

#include <stdio.h>
#include <process.h>
#include <setjmp.h>
#include <stdlib.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

PROCESSOR_POWER_POLICY      PAc, PDc;
SYSTEM_POWER_POLICY         Ac, Dc;
SYSTEM_POWER_CAPABILITIES   Cap;
SYSTEM_POWER_STATUS         PS;
ADMINISTRATOR_POWER_POLICY  Admin;
SYSTEM_BATTERY_STATE        Batt;

typedef
VOID
(*PCUR_PRINT)(
    IN PVOID Context
    );

typedef
VOID
(*PCUR_ASSIGN)(
    PUCHAR      Variable,
    PUCHAR      Value
    );

ULONG                       CurType;
POWER_INFORMATION_LEVEL     CurInfo;
PVOID                       CurContext;
ULONG                       CurContextSize;
PCUR_PRINT                  CurPrint;
PCUR_ASSIGN                 CurAssign;
PUCHAR                      CurDesc;

PUCHAR                      CurValue;
BOOLEAN                     ItemUpdated;
BOOLEAN                     CurValueIsNumeric;

BOOLEAN                     Verbose1;
BOOLEAN                     Verbose2;



PUCHAR szBool[] = { "FALSE", "TRUE" };


typedef struct {
    ULONG   Flags;
    PUCHAR  String;
} DEFBITS, *PDEFBITS;

DEFBITS ActFlags[] = {
    POWER_ACTION_QUERY_ALLOWED,     "QueryApps",
    POWER_ACTION_UI_ALLOWED,        "UIAllowed",
    POWER_ACTION_OVERRIDE_APPS,     "OverrideApps",
    POWER_ACTION_DISABLE_WAKES,     "DisableWakes",
    POWER_ACTION_CRITICAL,          "Critical",
    0, NULL
    };

DEFBITS PsBatteryFlagBits[] = {
    BATTERY_FLAG_HIGH,              "high",
    BATTERY_FLAG_LOW,               "low",
    BATTERY_FLAG_CRITICAL,          "critical",
    BATTERY_FLAG_CHARGING,          "charing",
    0, NULL
    };




PUCHAR
ActionS(
    IN POWER_ACTION Act
    )
{
    static char line[50];
    PCHAR       p;

    switch (Act) {
        case PowerActionNone:          p = "None";          break;
        case PowerActionSleep:         p = "Sleep";         break;
        case PowerActionHibernate:     p = "Hibernate";     break;
        case PowerActionShutdown:      p = "Shutdown";      break;
        case PowerActionShutdownReset: p = "ShutdownReset"; break;
        case PowerActionShutdownOff:   p = "ShutdownOff";   break;
        default:
            sprintf(line, "Unknown action %x", Act);
            p = line;
            break;
    }

    return p;
}

PUCHAR
SysPower(
    IN SYSTEM_POWER_STATE   State
    )
{
    static char line[50];
    PCHAR       p;

    switch (State) {
        case PowerSystemUnspecified:    p = "Unspecified";      break;
        case PowerSystemWorking:        p = "Working";          break;
        case PowerSystemSleeping1:      p = "S1";               break;
        case PowerSystemSleeping2:      p = "S2";               break;
        case PowerSystemSleeping3:      p = "S3";               break;
        case PowerSystemHibernate:      p = "S4 - hibernate";   break;
        case PowerSystemShutdown:       p = "Shutdown";         break;
        default:
            sprintf(line, "Unknown power state %x", State);
            p = line;
            break;
    }

    return p;
}

PUCHAR
DynamicThrottle(
    IN  UCHAR   Throttle
    )
{
    static char line[50];
    PCHAR       p;

    switch (Throttle) {
        case PO_THROTTLE_NONE:      p = "None";         break;
        case PO_THROTTLE_CONSTANT:  p = "Constant";     break;
        case PO_THROTTLE_DEGRADE:   p = "Degrade";      break;
        case PO_THROTTLE_ADAPTIVE:  p = "Adaptive";     break;
        default:
            sprintf(line,"Unknown Dynamic Throttle state %x", Throttle);
            p = line;
            break;
    }
    return p;
}

PUCHAR
MicroSeconds(
    IN  ULONG   Time
    )
{
    static char line[256];
    PCHAR       p;
    ULONG       MicroSeconds;
    ULONG       MilliSeconds;
    ULONG       Seconds;
    ULONG       Minutes;
    ULONG       Hours;
    ULONG       Days;

    MicroSeconds = Time % 1000;
    MilliSeconds = Time / 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes      = Seconds / 60;
    Seconds      = Seconds % 60;

    Hours        = Minutes / 60;
    Minutes      = Minutes % 60;

    Days         = Hours / 24;
    Hours        = Hours % 24;

    if (Hours) {

        sprintf(
            line,
            "%d [%2d:%2d %ds %dms %dus]",
            Time,
            Hours,
            Minutes,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (Minutes) {

        sprintf(
            line,
            "%d [0:%2d %ds %dms %dus]",
            Time,
            Minutes,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (Seconds) {

        sprintf(
            line,
            "%d [%ds %dms %dus]",
            Time,
            Seconds,
            MilliSeconds,
            MicroSeconds
            );

    } else if (MilliSeconds) {

        sprintf(
            line,
            "%d [%dms %dus]",
            Time,
            MilliSeconds,
            MicroSeconds
            );

    } else {

        sprintf(
            line,
            "%d [%dus]",
            Time,
            MicroSeconds
            );

    }
    p = line;
    return p;
}

VOID
GetBits (
    IN PUCHAR   Dest,
    IN ULONG    Flags,
    IN PDEFBITS DefBits
    )
{
    UCHAR   c;
    ULONG   i;

    c = 0;

    *Dest = 0;
    for (i=0; DefBits[i].Flags; i++) {
        if (Flags & DefBits[i].Flags) {
            if (c) {
                *Dest = c;
                Dest += 1;
            }
            Dest += sprintf (Dest, "%s", DefBits[i].String);
            c  = '|';
        }
    }
}

VOID
PrintPowerStatus (
    VOID
    )
{
    ULONG   i;
    PUCHAR  Ls;
    UCHAR   Bf[200];

    switch (PS.ACLineStatus) {
        case AC_LINE_OFFLINE:       Ls = "off line";        break;
        case AC_LINE_ONLINE:        Ls = "on line";         break;
        case AC_LINE_BACKUP_POWER:  Ls = "backup power";    break;
        case AC_LINE_UNKNOWN:       Ls = "unknown";         break;
        default:                    Ls = "**invalid**";     break;
    }

    strcpy (Bf, "unkown");
    if (PS.BatteryFlag != BATTERY_FLAG_UNKNOWN) {
        GetBits(Bf, PS.BatteryFlag, PsBatteryFlagBits);
    }

    printf ("Win32 System power status\n");
    printf ("AC line status..........: %s\n",   Ls);
    printf ("Battery flag............: %s\n",   Bf);
    printf ("Battery life percent....: %d\n",   PS.BatteryLifePercent);
    printf ("Battery full life time..: %d\n",   PS.BatteryFullLifeTime);
    printf ("\n");
}

VOID
PrintBattStatus (
    VOID
    )
{
    ULONG   i;
    PUCHAR  Ls;
    UCHAR   Bf[200];

    printf ("AC on line..............: %s\n",   szBool[Batt.AcOnLine]);
    printf ("Battery present ........: %s\n",   szBool[Batt.BatteryPresent]);
    printf ("Charging................: %s\n",   szBool[Batt.Charging]);
    printf ("Discharging.............: %s\n",   szBool[Batt.Discharging]);
    printf ("Max Capacity............: %d\n",   Batt.MaxCapacity);
    printf ("Remaining Capacity......: %d",     Batt.RemainingCapacity);
    if (Batt.MaxCapacity) {
        printf (" %d%%\n", Batt.RemainingCapacity * 100 / Batt.MaxCapacity);
    } else {
        printf (" (divide by zero)%%\n");
    }

    printf ("Rate....................: %d\n",   Batt.Rate);
    printf ("Estimated time..........: %d\n",   Batt.EstimatedTime);
    printf ("Default alert 1 & 2.....: %d %d\n",Batt.DefaultAlert1, Batt.DefaultAlert2);
    printf ("\n");
}

BOOLEAN
streql (
    PUCHAR  p1,
    PUCHAR  p2
    )
{
    return strcmp(p1, p2) == 0;
}

PUCHAR
_strtok (
    PUCHAR  Start
    )
{
    static PUCHAR   Location;
    PUCHAR          p;


    if (Start) {
        Location = Start;
    }

    for (p = Location; *p  &&  *p <'a' && *p >'z'; p++) ;
    if (!*p) {
        return NULL;
    }

    Start = p;
    for (; *p && *p >= 'a'  &&  *p <= 'z'; p++) ;
    if (*p) {
        *p++ = 0;
    }
    Location = p;
    return Start;
}


VOID
PrintCap (
    PVOID   Context
    )
{
    ULONG   i;

    printf ("System power capabilties\n");
    printf ("Power Button Present....: %s\n",   szBool[Cap.PowerButtonPresent]);
    printf ("Sleep Button Present....: %s\n",   szBool[Cap.SleepButtonPresent]);
    printf ("Lid Present.............: %s\n",   szBool[Cap.LidPresent]);
    printf ("System states supported.: %s%s%s%s%s\n",
            Cap.SystemS1 ? "S1 " : "",
            Cap.SystemS2 ? "S2 " : "",
            Cap.SystemS3 ? "S3 " : "",
            Cap.SystemS4 ? "S4 " : "",
            Cap.SystemS5 ? "S5 " : ""
            );
    printf ("Hiber file reserved.....: %s\n",   szBool[Cap.HiberFilePresent]);
    printf ("Thermal control.........: %s\n",   szBool[Cap.ThermalControl]);
    printf ("CPU Throttle control....: %s\n",   szBool[Cap.ProcessorThrottle]);
    printf ("Processor min throttle..: %d\n",   Cap.ProcessorMinThrottle);
    printf ("Processor max throttle..: %d\n",   Cap.ProcessorMaxThrottle);
    printf ("Some disk will spindown.: %s\n", szBool[Cap.DiskSpinDown]);
    printf ("System batteries present: %s %s\n",
            szBool[Cap.SystemBatteriesPresent],
            Cap.BatteriesAreShortTerm ? "- short term" : ""
            );
    printf ("System batteries scale..: ");
    for (i=0; i<3; i++) {
        printf ("(G:%d C:%d) ",
            Cap.BatteryScale[i].Granularity,
            Cap.BatteryScale[i].Capacity
            );
    }
    printf ("\n");
    printf ("Ac on line wake ability.: %s\n",   SysPower(Cap.AcOnLineWake));
    printf ("Lid wake ability........: %s\n",   SysPower(Cap.SoftLidWake));
    printf ("RTC wake ability........: %s\n",   SysPower(Cap.RtcWake));
    printf ("Min device wake.........: %s\n",   SysPower(Cap.MinDeviceWakeState));
    printf ("Default low latency wake: %s\n",   SysPower(Cap.DefaultLowLatencyWake));
    printf ("\n");
}

PUCHAR
Action (
    IN PBOOLEAN CapFlag,
    IN PPOWER_ACTION_POLICY Act
    )
{
    static UCHAR text[200];
    PUCHAR  p;
    UCHAR   c;
    ULONG   i;

    p = text;

    if (CapFlag && !*CapFlag) {
        p += sprintf(p, "Disabled ");
    }

    p += sprintf (p, "%s", ActionS(Act->Action));
    if (Act->Action != PowerActionNone  &&  Act->Flags) {
        c = '(';
        for (i=0; ActFlags[i].Flags; i++) {
            if (Act->Flags & ActFlags[i].Flags) {
                p += sprintf (p, "%c%s", c, ActFlags[i].String);
                c  = '|';
            }
        }
        p += sprintf (p, ")");
    }

    if (Act->EventCode) {
        p += sprintf (p, "-Code=%x", Act->EventCode);
    }

    return text;
}

VOID
SetAction (
    IN PPOWER_ACTION_POLICY Action
    )
{
    PUCHAR  p;
    POWER_ACTION    Act;
    ULONG           Flags;


    Flags = 0;
    p = _strtok (CurValue);
    if (!p) {
        printf ("Unknown power action %s.\n", CurValue);
        printf ("use: doze, sleep, shutdown, shutdownreset, shutdownoff\n");
        exit (1);
    }
    if (streql(p, "none")) {                    Act = PowerActionNone;
    } else if (streql(p, "sleep")) {            Act = PowerActionSleep;
    } else if (streql(p, "hiber")) {            Act = PowerActionHibernate;
    } else if (streql(p, "shutdown")) {         Act = PowerActionShutdown;
    } else if (streql(p, "shutdownreset")) {    Act = PowerActionShutdownReset;
    } else if (streql(p, "shutdownoff")) {      Act = PowerActionShutdownOff;
    } else {
        printf ("Unknown power action '%s'.\n", p);
        printf ("use: doze, sleep, shutdown, shutdownreset, shutdownoff\n");
        exit (1);
    }

    while (p = _strtok(NULL)) {
        if (streql(p, "qapp")) {                    Flags |= POWER_ACTION_QUERY_ALLOWED;
        } else if (streql(p, "ui")) {               Flags |= POWER_ACTION_UI_ALLOWED;
        } else if (streql(p, "override")) {         Flags |= POWER_ACTION_OVERRIDE_APPS;
        } else if (streql(p, "disablewake")) {      Flags |= POWER_ACTION_DISABLE_WAKES;
        } else if (streql(p, "critical")) {         Flags |= POWER_ACTION_CRITICAL;
        } else {
            printf ("Unknown power action '%s'.\n", p);
            printf ("use: qapp, io, override, disablewake, critical\n");
            exit (1);
        }
    }

    Action->Action = Act;
    Action->Flags  = Flags;
}


VOID
SetSysPower (
    IN PSYSTEM_POWER_STATE SysPower
    )
{
    PUCHAR      p;

    p = CurValue;
    if (streql(p, "s0")) {          *SysPower = PowerSystemWorking;
    } else if (streql(p, "s1")) {   *SysPower = PowerSystemSleeping1;
    } else if (streql(p, "s2")) {   *SysPower = PowerSystemSleeping2;
    } else if (streql(p, "s3")) {   *SysPower = PowerSystemSleeping3;
    } else if (streql(p, "s4")) {   *SysPower = PowerSystemHibernate;
    } else {
        printf ("Unknown system power state '%s'.  Use S0,S1,S2,S3 or S4\n", p);
        exit (1);
    }
}

VOID
SetPolicyCount(
    IN PULONG Variable
    )
{
    ULONG   local;
    if (!CurValueIsNumeric) {
        printf("'%s' is not numeric\n", CurValue);
        exit(1);
    }
    local = atol(CurValue);
    if (local > 3) {
        printf("PolicyCount can only be in the range 0 to 3\n");
        exit(1);
    }
    *Variable = local;
}

VOID
SetDynamicThrottle(
    IN PUCHAR Variable
    )
{
    ULONG   local;
    PUCHAR  p;

    p = CurValue;
    if (streql(p,"none")) {             *Variable = PO_THROTTLE_NONE;
    } else if (streql(p,"constant")) {  *Variable = PO_THROTTLE_CONSTANT;
    } else if (streql(p,"degrade")) {   *Variable = PO_THROTTLE_DEGRADE;
    } else if (streql(p,"degraded")) {  *Variable = PO_THROTTLE_DEGRADE;
    } else if (streql(p,"adaptive")) {  *Variable = PO_THROTTLE_ADAPTIVE;
    } else {
        printf("Unknown Dynamic Throttle state %s\n", CurValue);
        exit(1);
    }
}

VOID
SetPercentage (
    IN PUCHAR Variable
    )
{
    PUCHAR  p;

    if (!CurValueIsNumeric) {

        for (p = CurValue; *p; p++) {
            if (*p == '%') {
                *p = '\0';
            }
        }
        CurValueIsNumeric = TRUE;
        for (p = CurValue; *p; p++) {
            if (*p < '0'  ||  *p > '9') {
                CurValueIsNumeric = FALSE;
            }
        }
        if (!CurValueIsNumeric) {
            printf ("'%s' is not numeric\n", CurValue);
            exit (1);
        }
    }
    *Variable = (UCHAR) atol(CurValue);
}


VOID
SetValue (
    IN PULONG Variable
    )
{
    if (!CurValueIsNumeric) {
        printf ("'%s' is not numeric\n", CurValue);
        exit (1);
    }

    *Variable = atol(CurValue);
}

VOID
SetBool (
    IN PBOOLEAN Variable
    )
{
    BOOLEAN     State;

    State = 99;
    if (CurValueIsNumeric) {
        State = (BOOLEAN)atol(CurValue);
    } else {
        if (streql(CurValue, "true")) {           State = TRUE;
        } else if (streql(CurValue, "false")) {   State = FALSE;
        }
    }

    if (State != FALSE && State != TRUE) {
        printf ("'%s' is not boolean\n");
        exit (1);
    }

    *Variable = State;
}

VOID
SetField(
    IN  PPROCESSOR_POWER_POLICY Pol,
    IN  ULONG                   Index,
    IN  PUCHAR                  What
    )
{
    BOOLEAN     State;

    State = 99;
    if (CurValueIsNumeric) {

        State = (BOOLEAN)atol(CurValue);

    } else {

        if (streql(CurValue, "true")) {           State = TRUE;
        } else if (streql(CurValue, "false")) {   State = FALSE;
        }

    }

    if (State != FALSE && State != TRUE) {
        printf ("'%s' is not boolean\n", CurValue);
        exit (1);
    }

    if (streql(What,"allowpromotion")) {        Pol->Policy[Index].AllowPromotion = State;
    } else if (streql(What,"allowdemotion")) {  Pol->Policy[Index].AllowDemotion  = State;
    }

}


VOID
PrintPol (
    IN PSYSTEM_POWER_POLICY Pol
    )
{
    BOOLEAN     AnySleep;
    ULONG       i;
    UCHAR       text[200];
    PUCHAR      p;

    if (Pol->Revision != 1) {
        printf ("** revision not 1**\n");
    }

    AnySleep = Cap.SystemS1 || Cap.SystemS2 || Cap.SystemS3 || Cap.SystemS4;

    printf ("Power button.........: %s\n",  Action(&Cap.PowerButtonPresent, &Pol->PowerButton));
    printf ("Sleep button.........: %s\n",  Action(&Cap.SleepButtonPresent, &Pol->SleepButton));
    printf ("Lid close............: %s\n",  Action(&Cap.LidPresent, &Pol->LidClose));
    printf ("Lid open wake........: %s\n",  SysPower(Pol->LidOpenWake));

    printf ("Idle.................: %s\n", Action(&AnySleep, &Pol->Idle));
    printf ("Settings.............: Timeout=%d, Sensitivity=%d\n",
             Pol->IdleTimeout,
             Pol->IdleSensitivity
             );

    printf ("Min sleep state......: %s\n", SysPower(Pol->MinSleep));
    printf ("Max sleep state......: %s\n", SysPower(Pol->MaxSleep));
    printf ("Reduced latency.sleep: %s\n", SysPower(Pol->ReducedLatencySleep));
    printf ("WinLogonFlags........: %x\n", Pol->WinLogonFlags);
    printf ("DynamicThrottle......: %s\n", DynamicThrottle(Pol->DynamicThrottle));
    printf ("Doze S4 timeout......: %d\n", Pol->DozeS4Timeout);

    printf ("Battery broadcast res: %d\n", Pol->BroadcastCapacityResolution);
    for (i=0; i < NUM_DISCHARGE_POLICIES; i++) {
        printf ("Battery discharge %d..: ", i);
        p = "Disabled";
        if (!Cap.SystemBatteriesPresent && Pol->DischargePolicy[i].Enable) {
            p = "No battery, but enable is set";
        }
        if (Cap.SystemBatteriesPresent && Pol->DischargePolicy[i].Enable) {
            sprintf (text, "%d, %s, Min=%s",
                Pol->DischargePolicy[i].BatteryLevel,
                Action (NULL, &Pol->DischargePolicy[i].PowerPolicy),
                SysPower(Pol->DischargePolicy[i].MinSystemState)
                );
            p = text;
        }
        printf ("%s\n", p);
    }

    printf ("Video  timeout.......: %d\n", Pol->VideoTimeout);
    printf ("Hard disk timeout....: %d\n", Pol->SpindownTimeout);
    printf ("Optimize for power...: %s\n", szBool[Pol->OptimizeForPower]);
    printf ("Fan throttle toler...: %d\n", Pol->FanThrottleTolerance);
    printf ("Forced throttle......: %d%% %s\n",
             Pol->ForcedThrottle,
             Pol->ForcedThrottle == 100 ? "(off)" : "(on)"
             );
    printf ("Min throttle.........: %d%%\n", Pol->MinThrottle);
    printf ("Over throttle act....: %s\n", Action (NULL, &Pol->OverThrottled));
    printf ("\n");
}


VOID
PrintPPol (
    IN PPROCESSOR_POWER_POLICY Pol
    )
{
    ULONG       i;
    UCHAR       text[200];
    PUCHAR      p;

    if (Pol->Revision != 1) {

        printf ("** revision not 1**\n");

    }

    printf ("Dynamic Throttle.....: %s\n",  DynamicThrottle(Pol->DynamicThrottle) );
    printf ("\n");
    for (i = 0; i < Pol->PolicyCount; i++) {

        printf ("C%x Processor Power Policy\n",  (i+1) );
        printf ("   Allow Demotion....: %s\n",  szBool[Pol->Policy[i].AllowDemotion]);
        printf ("   Allow Promotion...: %s\n",  szBool[Pol->Policy[i].AllowPromotion]);
        printf ("   Demote Percent....: %d%%\n", Pol->Policy[i].DemotePercent);
        printf ("   Promote Percent...: %d%%\n", Pol->Policy[i].PromotePercent);
        printf ("   Demote Limit......: %s\n",  MicroSeconds(Pol->Policy[i].DemoteLimit) );
        printf ("   Promote Limit.....: %s\n",  MicroSeconds(Pol->Policy[i].PromoteLimit) );
        printf ("   Time Check........: %s\n",  MicroSeconds(Pol->Policy[i].TimeCheck) );
        printf ("\n");
    }
    printf ("\n");
}

VOID
PrintAdmin (
    PVOID   Context
    )
{
    printf ("Min sleep state......: %s\n", SysPower(Admin.MinSleep));
    printf ("Max sleep state......: %s\n", SysPower(Admin.MaxSleep));
    printf ("Min video timeout....: %d\n", Admin.MinVideoTimeout);
    printf ("Max video timeout....: %d\n", Admin.MaxVideoTimeout);
    printf ("Min spindown timeout.: %d\n", Admin.MinSpindownTimeout);
    printf ("Max spindown timeout.: %d\n", Admin.MaxSpindownTimeout);
}

VOID
AssignSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PSYSTEM_POWER_POLICY    Pol;
    PUCHAR                  p;

    if (!CurContext) {
        printf ("must select ac, dc, pac, pdc, cap, admin to make setting in\n");
        exit (1);
    }

    CurValue = Value;
    if (!*CurValue) {
        printf ("null settings not allowed\n");
        exit (1);
    }

    CurValueIsNumeric = TRUE;
    for (p = Value; *p; p++) {
        if (*p < '0'  ||  *p > '9') {
            CurValueIsNumeric = FALSE;
        }
    }

    ItemUpdated = TRUE;
    CurAssign (Variable, Value);
}

VOID
AssignPolicySetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PSYSTEM_POWER_POLICY    Pol;

    Pol = (PSYSTEM_POWER_POLICY) CurContext;

    // set policy
    if (streql(Variable, "pbutt")) {                 SetAction(&Pol->PowerButton);
    } else if (streql(Variable, "sbutt")) {          SetAction(&Pol->SleepButton);
    } else if (streql(Variable, "lidclose")) {       SetAction(&Pol->LidClose);
    } else if (streql(Variable, "idle")) {           SetAction(&Pol->Idle);
    } else if (streql(Variable, "idlesense")) {      SetValue((PULONG)&Pol->IdleSensitivity);
    } else if (streql(Variable, "idletimeout")) {    SetValue(&Pol->IdleTimeout);
    } else if (streql(Variable, "minsleep")) {       SetSysPower(&Pol->MinSleep);
    } else if (streql(Variable, "maxsleep")) {       SetSysPower(&Pol->MaxSleep);
    } else if (streql(Variable, "reducedsleep")) {   SetSysPower(&Pol->ReducedLatencySleep);
    } else if (streql(Variable, "s4timeout")) {      SetValue(&Pol->DozeS4Timeout);
    } else if (streql(Variable, "videotimeout")) {   SetValue(&Pol->VideoTimeout);
    } else if (streql(Variable, "disktimeout")) {    SetValue(&Pol->SpindownTimeout);
    } else if (streql(Variable, "optpower")) {       SetBool(&Pol->OptimizeForPower);
    } else if (streql(Variable, "fantol")) {         SetValue((PULONG)&Pol->FanThrottleTolerance);
    } else if (streql(Variable, "minthrot")) {       SetValue((PULONG)&Pol->MinThrottle);
    } else if (streql(Variable, "forcethrot")) {     SetValue((PULONG)&Pol->ForcedThrottle);
    } else if (streql(Variable, "overthrot")) {      SetAction(&Pol->OverThrottled);
    } else {
        printf ("Variable not:\n");
        printf ("  pbutt, sbutt, lidclose\n");
        printf ("  idle, idlesense, idletime\n");
        printf ("  minsleep, maxsleep, reducedsleep, s4timeout\n");
        printf ("  videotimeout, disktimeout, optpower\n");
        printf ("  optpower, fantol, minthrot, forcethrot, overthrot\n");
        exit   (1);
    }

}

VOID
AssignPPolicySetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    PPROCESSOR_POWER_POLICY Pol;

    Pol = (PPROCESSOR_POWER_POLICY) CurContext;
    if (streql(Variable,"policycount")) {               SetPolicyCount(&(Pol->PolicyCount));
    } else if (streql(Variable,"dynamicthrottle")) {    SetDynamicThrottle(&(Pol->DynamicThrottle));
    } else if (streql(Variable,"c1allowpromotion")) {   SetField(Pol,0,"allowpromotion");
    } else if (streql(Variable,"c1allowdemotion")) {    SetField(Pol,0,"allowdemotion");
    } else if (streql(Variable,"c1demotepercent")) {    SetPercentage(&(Pol->Policy[0].DemotePercent));
    } else if (streql(Variable,"c1promotepercent")) {   SetPercentage(&(Pol->Policy[0].PromotePercent));
    } else if (streql(Variable,"c1demotelimit")) {      SetValue(&(Pol->Policy[0].DemoteLimit));
    } else if (streql(Variable,"c1promotelimit")) {     SetValue(&(Pol->Policy[0].PromoteLimit));
    } else if (streql(Variable,"c1timecheck")) {        SetValue(&(Pol->Policy[0].TimeCheck));
    } else if (streql(Variable,"c2allowpromotion")) {   SetField(Pol,1,"allowpromotion");
    } else if (streql(Variable,"c2allowdemotion")) {    SetField(Pol,1,"allowdemotion");
    } else if (streql(Variable,"c2demotepercent")) {    SetPercentage(&(Pol->Policy[1].DemotePercent));
    } else if (streql(Variable,"c2promotepercent")) {   SetPercentage(&(Pol->Policy[1].PromotePercent));
    } else if (streql(Variable,"c2demotelimit")) {      SetValue(&(Pol->Policy[1].DemoteLimit));
    } else if (streql(Variable,"c2promotelimit")) {     SetValue(&(Pol->Policy[1].PromoteLimit));
    } else if (streql(Variable,"c2timecheck")) {        SetValue(&(Pol->Policy[1].TimeCheck));
    } else if (streql(Variable,"c3allowpromotion")) {   SetField(Pol,2,"allowpromotion");
    } else if (streql(Variable,"c3allowdemotion")) {    SetField(Pol,2,"allowdemotion");
    } else if (streql(Variable,"c3demotepercent")) {    SetPercentage(&(Pol->Policy[2].DemotePercent));
    } else if (streql(Variable,"c3promotepercent")) {   SetPercentage(&(Pol->Policy[2].PromotePercent));
    } else if (streql(Variable,"c3demotelimit")) {      SetValue(&(Pol->Policy[2].DemoteLimit));
    } else if (streql(Variable,"c3promotelimit")) {     SetValue(&(Pol->Policy[2].PromoteLimit));
    } else if (streql(Variable,"c3timecheck")) {        SetValue(&(Pol->Policy[2].TimeCheck));
    } else {
        printf("Variable not:\n");
        printf("  policycount        - number of elements in policy\n");
        printf("  dynamicthrottle    - which throttle policy to use\n");
        printf("  cXallowpromotion   - allow promotion from state X\n");
        printf("  cXallowdemotion    - allow demotion from state X\n");
        printf("  cXdemotepercent    - set demote percent for state X\n");
        printf("  cXpromotepercent   - set promote percent for state X\n");
        printf("  cXdemotelimit      - set demote limit for state X\n");
        printf("  cXpromotelimit     - set promote limit for state X\n");
        printf("  cXtimecheck        - set time check interval for state X\n");
        printf("     where X = <1,2,3>\n");
        exit(1);
    }
}


VOID
AssignAdminSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    if (streql(Variable, "minsleep")) {              SetSysPower(&Admin.MinSleep);
    } else if (streql(Variable, "maxsleep")) {       SetSysPower(&Admin.MaxSleep);
    } else if (streql(Variable, "minvideo")) {       SetValue(&Admin.MinVideoTimeout);
    } else if (streql(Variable, "maxvideo")) {       SetValue(&Admin.MaxVideoTimeout);
    } else if (streql(Variable, "mindisk")) {        SetValue(&Admin.MinSpindownTimeout);
    } else if (streql(Variable, "maxdisk")) {        SetValue(&Admin.MaxSpindownTimeout);
    } else {
        printf ("Variable not:\n");
        printf ("  minsleep, maxsleep\n");
        printf ("  minvideo, maxvideo, mindisk, maxdisk\n");
        exit   (1);
    }
}


VOID
AssignCapSetting (
    PUCHAR      Variable,
    PUCHAR      Value
    )
{
    // set capability
    if (streql(Variable, "pbutt")) {                 SetBool(&Cap.PowerButtonPresent);
    } else if (streql(Variable, "sbutt")) {          SetBool(&Cap.SleepButtonPresent);
    } else if (streql(Variable, "lid")) {            SetBool(&Cap.LidPresent);
    } else if (streql(Variable, "s1")) {             SetBool(&Cap.SystemS1);
    } else if (streql(Variable, "s2")) {             SetBool(&Cap.SystemS2);
    } else if (streql(Variable, "s3")) {             SetBool(&Cap.SystemS3);
    } else if (streql(Variable, "s4")) {             SetBool(&Cap.SystemS4);
    } else if (streql(Variable, "s5")) {             SetBool(&Cap.SystemS5);
    } else if (streql(Variable, "batt")) {           SetBool(&Cap.SystemBatteriesPresent);
    } else if (streql(Variable, "shortterm")) {      SetBool(&Cap.BatteriesAreShortTerm);
    } else if (streql(Variable, "acwake")) {         SetSysPower(&Cap.AcOnLineWake);
    } else if (streql(Variable, "lidwake")) {        SetSysPower(&Cap.SoftLidWake);
    } else if (streql(Variable, "rtcwake")) {        SetSysPower(&Cap.RtcWake);
    } else if (streql(Variable, "lowlat")) {         SetSysPower(&Cap.DefaultLowLatencyWake);
    } else {
        printf ("Variable not:\n");
        printf ("  pbutt, sbutt, lid, s1, s2, s3, s4, s5\n");
        printf ("  batt, shortterm, acwake, lidwake, rtcwak, lowlat\n");
        exit   (1);
    }
}


#define SEL_NONE    0
#define SEL_AC      1
#define SEL_DC      2
#define SEL_CAP     3
#define SEL_ADMIN   4
#define SEL_PAC     5
#define SEL_PDC     6

VOID
SelectItem(
    IN ULONG    Type
    )
{
    NTSTATUS            Status;

    if (CurType) {
        if (ItemUpdated) {
            if (Verbose2) {
                printf ("%s being set as:\n", CurDesc);
                CurPrint (CurContext);
            }

            Status = NtPowerInformation (
                        CurInfo,
                        CurContext,
                        CurContextSize,
                        CurContext,
                        CurContextSize
                        );

            if (!NT_SUCCESS(Status)) {
                printf ("NtPowerInformation failed with %x\n", Status);
            }

        }

        printf ("%s\n", CurDesc);
        CurPrint (CurContext);
    }

    switch (Type) {
        case SEL_NONE:
            CurPrint = NULL;
            CurAssign = NULL;
            CurContext = NULL;
            break;

        case SEL_AC:
            CurPrint        = PrintPol;
            CurInfo         = SystemPowerPolicyAc;
            CurContext      = &Ac;
            CurContextSize  = sizeof(SYSTEM_POWER_POLICY);
            CurAssign       = AssignPolicySetting;
            CurDesc         = "AC power policy";
            break;

        case SEL_DC:
            CurPrint        = PrintPol;
            CurInfo         = SystemPowerPolicyDc;
            CurContext      = &Dc;
            CurContextSize  = sizeof(SYSTEM_POWER_POLICY);
            CurAssign       = AssignPolicySetting;
            CurDesc         = "DC power policy";
            break;

        case SEL_PAC:
            CurPrint        = PrintPPol;
            CurInfo         = ProcessorPowerPolicyAc;
            CurContext      = &PAc;
            CurContextSize  = sizeof(PROCESSOR_POWER_POLICY);
            CurAssign       = AssignPPolicySetting;
            CurDesc         = "AC processor power policy";
            break;

        case SEL_PDC:
            CurPrint        = PrintPPol;
            CurInfo         = ProcessorPowerPolicyDc;
            CurContext      = &PDc;
            CurContextSize  = sizeof(PROCESSOR_POWER_POLICY);
            CurAssign       = AssignPPolicySetting;
            CurDesc         = "DC processor power policy";
            break;

        case SEL_CAP:
            CurPrint        = PrintCap;
            CurInfo         = SystemPowerCapabilities,
            CurContext      = &Cap;
            CurContextSize  = sizeof(SYSTEM_POWER_CAPABILITIES);
            CurAssign       = AssignCapSetting;
            CurDesc         = "power capabilties";
            break;

        case SEL_ADMIN:
            CurPrint        = PrintAdmin;
            CurInfo         = AdministratorPowerPolicy;
            CurContext      = &Admin;
            CurContextSize  = sizeof(ADMINISTRATOR_POWER_POLICY);
            CurAssign       = AssignAdminSetting;
            CurDesc         = "Admin policy overrides";
            break;
    }

    CurType = Type;
    ItemUpdated = FALSE;
}


VOID
UpdateAdmin (
    VOID
    )
{
    ADMINISTRATOR_POWER_POLICY   AdminPolicy;
    NTSTATUS                     Status;


    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                NULL,
                0,
                &AdminPolicy,
                sizeof (AdminPolicy)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading admin policy %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                &AdminPolicy,
                sizeof (AdminPolicy),
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error writing admin policy %x\n", Status);
        exit (1);
    }
}



VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{
    NTSTATUS                    Status;
    PUCHAR                      p, p1;
    BOOLEAN                     Result;
    HANDLE                      hToken;
    TOKEN_PRIVILEGES            tkp;

    if (argc < 2) {
        printf ("dumppo: cap ps bs admin ac dc pac pdc\n");
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerCapabilities,
                NULL,
                0,
                &Cap,
                sizeof (Cap)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading power capabilities %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                AdministratorPowerPolicy,
                NULL,
                0,
                &Admin,
                sizeof (Admin)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading admin power overrides %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerPolicyAc,
                NULL,
                0,
                &Ac,
                sizeof (Ac)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading AC policies %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                SystemPowerPolicyDc,
                NULL,
                0,
                &Dc,
                sizeof (Dc)
                );

    if (!NT_SUCCESS(Status)) {
        printf ("Error reading DC policies %x\n", Status);
        exit (1);
    }

    Result = (BOOLEAN)GetSystemPowerStatus (&PS);
    if (!Result) {
        printf ("False returned from GetSystemPowerStatus %x\n", GetLastError());
        exit (1);
    }

    Status = NtPowerInformation (
                SystemBatteryState,
                NULL,
                0,
                &Batt,
                sizeof (Batt)
                );
    if (!NT_SUCCESS(Status)) {
        printf ("Error reading system battery status %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation (
                ProcessorPowerPolicyAc,
                NULL,
                0,
                &PAc,
                sizeof (PAc)
                );
    if (!NT_SUCCESS(Status)) {
        printf ("Error reading processor AC policy %x\n", Status);
        exit (1);
    }

    Status = NtPowerInformation(
                ProcessorPowerPolicyDc,
                NULL,
                0,
                &PDc,
                sizeof (PDc)
                );
    if (!NT_SUCCESS(Status)) {
        printf("Error reading processor DC policy %x\n", Status);
        exit (1);
    }

    //
    // Upgrade premissions
    //

    OpenProcessToken (
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        );

    LookupPrivilegeValue (
        NULL,
        SE_SHUTDOWN_NAME,
        &tkp.Privileges[0].Luid
        );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (
        hToken,
        FALSE,
        &tkp,
        0,
        NULL,
        0
    );

    //
    // Process args
    //

    while (argc) {
        argc--;

        if (streql(*argv, "-v")) {
            Verbose1 = TRUE;
        }

        if (streql(*argv, "-V")) {
            Verbose1 = TRUE;
            Verbose2 = TRUE;
        }

        for (p = *argv; *p; p++) {
            if (*p >= 'A' &&  *p <= 'Z') {
                *p += 'a' - 'A';
            }
        }

        p = *argv;
        argv += 1;

        if (streql(p, "ac")) {
            SelectItem(SEL_AC);
        }

        if (streql(p, "dc")) {
            SelectItem(SEL_DC);
        }

        if (streql(p, "cap")) {
            SelectItem(SEL_CAP);
        }

        if (streql(p, "ps")) {
            SelectItem(SEL_NONE);
            PrintPowerStatus ();
        }

        if (streql(p, "bs")) {
            SelectItem(SEL_NONE);
            PrintBattStatus ();
        }

        if (streql(p, "admin")) {
            SelectItem(SEL_ADMIN);
        }

        if (streql(p, "pdc")) {
            SelectItem(SEL_PDC);
        }

        if (streql(p, "pac")) {
            SelectItem(SEL_PAC);
        }

        //
        // Check if this is a assignment
        //

        for (p1=p; *p1; p1++) {
            if (*p1 == '=') {
                *p1 = 0;
                AssignSetting (p, p1+1);
            }
        }
    }

    // flush
    SelectItem(SEL_NONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ech\ech.c ===
#include <stdio.h>
#include <string.h>
#include <cvtoem.h>

int
__cdecl
main (
    int c,
    char *v[]
    )
{
    ConvertAppToOem(c, v);
    while (--c)
        if (!strcmp( *++v, ";" ))
            printf ("\n" );
        else
            printf ("%s ", *v);
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dumpclip\dumpclip.c ===
#include <windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>

__cdecl
main (c, v)
int c;
char *v[];
{
    HANDLE hMem;
    LPSTR lpMem;
    FILE *OutputFile;

    if (c <= 1) {
        OutputFile = stdout;
        }
    else
    if (c == 2) {
        OutputFile = fopen( v[1], "w" );
        if (OutputFile == NULL) {
            fprintf( stderr, "DUMPCLIP: unable to open destination file '%s' (%u)\n", v[1], GetLastError() );
            return 1;
            }
        }

    if (!OpenClipboard( NULL )) {
        fprintf( stderr, "DUMPCLIP: unable to open clipboard (%u)\n", GetLastError() );
        return 1;
        }

    _setmode( _fileno( OutputFile ), _O_BINARY );
    hMem = GetClipboardData( CF_OEMTEXT );
    if (hMem != NULL) {
        lpMem = GlobalLock( hMem );
        if (lpMem) {
            fprintf( OutputFile, "%s", lpMem );
            }
        GlobalUnlock( hMem );
        }
    else {
        fprintf( stderr, "DUMPCLIP: unable to get clipboard data as text (%u)\n", GetLastError() );
        }

    CloseClipboard();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\efinvram\efinvram.c ===
#include "efinvram.h"

PWSTR SystemPartitionNtName;

PBOOT_OPTIONS BootOptions;
ULONG BootOptionsLength;
PBOOT_OPTIONS OriginalBootOptions;
ULONG OriginalBootOptionsLength;

PULONG BootEntryOrder;
ULONG BootEntryOrderCount;
PULONG OriginalBootEntryOrder;
ULONG OriginalBootEntryOrderCount;

LIST_ENTRY BootEntries;
LIST_ENTRY DeletedBootEntries;
LIST_ENTRY ActiveUnorderedBootEntries;
LIST_ENTRY InactiveUnorderedBootEntries;

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST BootEntries
    );

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    );

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    );

VOID
InitializeEfi (
    VOID
    );

NTSTATUS
(*AddBootEntry) (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
(*DeleteBootEntry) (
    IN ULONG Id
    );

NTSTATUS
(*ModifyBootEntry) (
    IN PBOOT_ENTRY BootEntry
    );

NTSTATUS
(*EnumerateBootEntries) (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

NTSTATUS
(*QueryBootEntryOrder) (
    OUT PULONG Ids,
    IN OUT PULONG Count
    );

NTSTATUS
(*SetBootEntryOrder) (
    IN PULONG Ids,
    IN ULONG Count
    );

NTSTATUS
(*QueryBootOptions) (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    );

NTSTATUS
(*SetBootOptions) (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    );

NTSTATUS
(*TranslateFilePath) (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    );

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    InitializeMenuSystem( );

    InitializeEfi( );

    MainMenu( );

    return 0;
}

VOID
ConvertBootEntries (
    PBOOT_ENTRY_LIST NtBootEntries
    )

/*++

Routine Description:

    Convert boot entries read from EFI NVRAM into our internal format.

Arguments:

    None.

Return Value:

    NTSTATUS - Not STATUS_SUCCESS if an unexpected error occurred.

--*/

{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;

    bootEntryList = NtBootEntries;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
        myBootEntry = MemAlloc(length);

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if ( (bootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0 ) {
            InsertTailList( &ActiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &ActiveUnorderedBootEntries;
        } else {
            InsertTailList( &InactiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &InactiveUnorderedBootEntries;
        }

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;
        memcpy(bootEntryCopy, bootEntry, bootEntry->Length);

        //
        // Fill in the base part of the structure.
        //
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->Id = bootEntry->Id;
        myBootEntry->Attributes = bootEntry->Attributes;
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength =
            ((ULONG)wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
            (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

            MBE_SET_IS_NT( myBootEntry );
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength =
                ((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = ADD_OFFSET(osOptions, OsLoadPathOffset);

        } else {

            //
            // Foreign boot entry. Just capture whatever OS options exist.
            //

            myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
            myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    return;

} // ConvertBootEntries

VOID
ConcatenatePaths (
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;
     
    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (
    IN PMY_BOOT_ENTRY OldBootEntry
    )
{
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY newBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {

        //
        // Add in base part of WINDOWS_OS_OPTIONS. Calculate length in
        // bytes of OsLoadOptions and add that in.
        //
        requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        osLoadOptionsLength = OldBootEntry->OsLoadOptionsLength;
        requiredLength += osLoadOptionsLength;

        //
        // Round up to a ULONG boundary for the OS FILE_PATH in the
        // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Calculate length
        // in bytes of FILE_PATH and add that in. Calculate total length of 
        // WINDOWS_OS_OPTIONS.
        // 
        requiredLength = ALIGN_UP(requiredLength, ULONG);
        osLoadPathOffset = requiredLength;
        requiredLength += OldBootEntry->OsFilePath->Length;
        osLoadPathLength = requiredLength - osLoadPathOffset;

    } else {

        //
        // Add in length of foreign OS options.
        //
        requiredLength += OldBootEntry->ForeignOsOptionsLength;

        osLoadOptionsLength = 0;
        osLoadPathOffset = 0;
        osLoadPathLength = 0;
    }

    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = OldBootEntry->FriendlyNameLength;
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Calculate length in bytes of FILE_PATH
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += OldBootEntry->BootFilePath->Length;
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    newBootEntry = MemAlloc(requiredLength);
    ASSERT(newBootEntry != NULL);

    RtlZeroMemory(newBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &newBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)newBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)newBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)newBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    newBootEntry->AllocationEnd = (PUCHAR)newBootEntry + requiredLength;
    newBootEntry->Status = OldBootEntry->Status & MBE_STATUS_IS_NT;
    newBootEntry->Attributes = OldBootEntry->Attributes;
    newBootEntry->Id = OldBootEntry->Id;
    newBootEntry->FriendlyName = friendlyName;
    newBootEntry->FriendlyNameLength = friendlyNameLength;
    newBootEntry->BootFilePath = bootPath;
    if ( MBE_IS_NT( OldBootEntry ) ) {
        newBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        newBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
        newBootEntry->OsFilePath = osLoadPath;
    }

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = OldBootEntry->Attributes;
    ntBootEntry->Id = OldBootEntry->Id;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    if ( MBE_IS_NT( OldBootEntry ) ) {
    
        //
        // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
        // OsLoadOptions.
        //
        strcpy((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
        osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
        osOptions->Length = osOptionsLength;
        osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
        wcscpy(osOptions->OsLoadOptions, OldBootEntry->OsLoadOptions);
    
        //
        // Copy the OS FILE_PATH.
        //
        memcpy( osLoadPath, OldBootEntry->OsFilePath, osLoadPathLength );

    } else {

        //
        // Copy the foreign OS options.
        //

        memcpy( osOptions, OldBootEntry->ForeignOsOptions, osOptionsLength );
    }

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, OldBootEntry->FriendlyName);

    //
    // Copy the boot FILE_PATH.
    //
    memcpy( bootPath, OldBootEntry->BootFilePath, bootPathLength );

    return newBootEntry;

} // CreateBootEntryFromBootEntry

VOID
FreeBootEntry (
    IN PMY_BOOT_ENTRY BootEntry
    )
{
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, FriendlyName );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsLoadOptions );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, BootFilePath );
    FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsFilePath );

    MemFree( BootEntry );

    return;

} // FreeBootEntry

VOID
InitializeEfi (
    VOID
    )
{
    DWORD error;
    NTSTATUS status;
    BOOLEAN wasEnabled;
    HMODULE h;
    WCHAR dllName[MAX_PATH]; 
    ULONG length;
    HKEY key;
    DWORD type;
    PBOOT_ENTRY_LIST ntBootEntries;
    ULONG i;
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    //
    // Enable the privilege that is necessary to query/set NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Insufficient privilege.\n" );
    }

    //
    // Get the NT name of the system partition from the registry.
    //

    error = RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("System\\Setup"), &key );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }

    error = RegQueryValueEx( key, TEXT("SystemPartition"), NULL, &type, NULL, &length );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    if ( type != REG_SZ ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Unable to read SystemPartition registry value: wrong type\n"
            );
    }

    SystemPartitionNtName = MemAlloc( length );

    error = RegQueryValueEx( 
                key,
                TEXT("SystemPartition"),
                NULL,
                &type,
                (PBYTE)SystemPartitionNtName,
                &length
                );
    if ( error != ERROR_SUCCESS ) {
        FatalError( error, L"Unable to read SystemPartition registry value: %d\n", error );
    }
    
    RegCloseKey( key );

    //
    // Load ntdll.dll from the system directory.
    //

    GetSystemDirectory( dllName, MAX_PATH );
    ConcatenatePaths( dllName, TEXT("ntdll.dll"), MAX_PATH );
    h = LoadLibrary( dllName );
    if ( h == NULL ) {
        error = GetLastError();
        FatalError( error, L"Can't load NTDLL.DLL: %d\n", error );
    }

    //
    // Get the addresses of the NVRAM APIs that we need to use. If any of
    // these APIs are not available, this must be a pre-EFI NVRAM build.
    //

    (FARPROC)AddBootEntry = GetProcAddress( h, "NtAddBootEntry" );
    (FARPROC)DeleteBootEntry = GetProcAddress( h, "NtDeleteBootEntry" );
    (FARPROC)ModifyBootEntry = GetProcAddress( h, "NtModifyBootEntry" );
    (FARPROC)EnumerateBootEntries = GetProcAddress( h, "NtEnumerateBootEntries" );
    (FARPROC)QueryBootEntryOrder = GetProcAddress( h, "NtQueryBootEntryOrder" );
    (FARPROC)SetBootEntryOrder = GetProcAddress( h, "NtSetBootEntryOrder" );
    (FARPROC)QueryBootOptions = GetProcAddress( h, "NtQueryBootOptions" );
    (FARPROC)SetBootOptions = GetProcAddress( h, "NtSetBootOptions" );
    (FARPROC)TranslateFilePath = GetProcAddress( h, "NtTranslateFilePath" );

    if ( (AddBootEntry == NULL) ||
         (DeleteBootEntry == NULL) ||
         (ModifyBootEntry == NULL) ||
         (EnumerateBootEntries == NULL) ||
         (QueryBootEntryOrder == NULL) ||
         (SetBootEntryOrder == NULL) ||
         (QueryBootOptions == NULL) ||
         (SetBootOptions == NULL) ||
         (TranslateFilePath == NULL) ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    //
    // Get the global system boot options. If the call fails with
    // STATUS_NOT_IMPLEMENTED, this is not an EFI machine.
    //

    length = 0;
    status = QueryBootOptions( NULL, &length );

    if ( status == STATUS_NOT_IMPLEMENTED ) {
        FatalError( ERROR_OLD_WIN_VERSION, L"This build does not support EFI NVRAM\n" );
    }

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    BootOptions = MemAlloc( length );
    OriginalBootOptions = MemAlloc( length );

    status = QueryBootOptions( BootOptions, &length );
    if ( status != STATUS_SUCCESS ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unexpected error from NtQueryBootOptions: 0x%x\n", status );
    }

    memcpy( OriginalBootOptions, BootOptions, length );
    BootOptionsLength = length;
    OriginalBootOptionsLength = length;

    //
    // Get the system boot order list.
    //

    length = 0;
    status = QueryBootEntryOrder( NULL, &length );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }
    }

    if ( length != 0 ) {

        BootEntryOrder = MemAlloc( length * sizeof(ULONG) );
        OriginalBootEntryOrder = MemAlloc( length * sizeof(ULONG) );

        status = QueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtQueryBootEntryOrder: 0x%x\n", status );
        }

        memcpy( OriginalBootEntryOrder, BootEntryOrder, length * sizeof(ULONG) );
    }

    BootEntryOrderCount = length;
    OriginalBootEntryOrderCount = length;

    //
    // Get all existing boot entries.
    //

    length = 0;
    status = EnumerateBootEntries( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        if ( status == STATUS_SUCCESS ) {
            length = 0;
        } else {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }
    }

    InitializeListHead( &BootEntries );
    InitializeListHead( &DeletedBootEntries );
    InitializeListHead( &ActiveUnorderedBootEntries );
    InitializeListHead( &InactiveUnorderedBootEntries );

    if ( length != 0 ) {
    
        ntBootEntries = MemAlloc( length );

        status = EnumerateBootEntries( ntBootEntries, &length );
        if ( status != STATUS_SUCCESS ) {
            error = RtlNtStatusToDosError( status );
            FatalError( error, L"Unexpected error from NtEnumerateBootEntries: 0x%x\n", status );
        }

        //
        // Convert the boot entries into an internal representation.
        //

        ConvertBootEntries( ntBootEntries );

        //
        // Free the enumeration buffer.
        //

        MemFree( ntBootEntries );
    }

    //
    // Build the ordered boot entry list.
    //

    for ( i = 0; i < BootEntryOrderCount; i++ ) {
        ULONG id = BootEntryOrder[i];
        for ( listEntry = ActiveUnorderedBootEntries.Flink;
              listEntry != &ActiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
        for ( listEntry = InactiveUnorderedBootEntries.Flink;
              listEntry != &InactiveUnorderedBootEntries;
              listEntry = listEntry->Flink ) {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) {
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
    }

    return;

} // InitializeEfi

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    )
{
    NTSTATUS status;
    DWORD error;
    PLIST_ENTRY listHeads[4];
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    ULONG list;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY newBootEntry;
    PMY_BOOT_ENTRY newCurrentBootEntry;
    ULONG count;

    SetStatusLine( L"Saving changes..." );

    //
    // Walk the three lists, updating boot entries in NVRAM.
    //

    newCurrentBootEntry = CurrentBootEntry;

    listHeads[0] = &DeletedBootEntries;
    listHeads[1] = &InactiveUnorderedBootEntries;
    listHeads[2] = &ActiveUnorderedBootEntries;
    listHeads[3] = &BootEntries;

    for ( list = 0; list < 4; list++ ) {
    
        listHead = listHeads[list];

        for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

            //
            // Check first for deleted entries, then for new entries, and
            // finally for modified entries.
            //

            if ( MBE_IS_DELETED( bootEntry ) ) {

                //
                // If it's also marked as new, it's not in NVRAM, so there's
                // nothing to delete.
                //

                if ( !MBE_IS_NEW( bootEntry ) ) {

                    status = DeleteBootEntry( bootEntry->Id );
                    if ( !NT_SUCCESS(status) ) {
                        if ( status != STATUS_VARIABLE_NOT_FOUND ) {
                            error = RtlNtStatusToDosError( status );
                            FatalError( error, L"Unable to delete boot entry: 0x%x\n", status );
                        }
                    }
                }

                //
                // Delete this entry from the list and from memory.
                //

                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                ASSERT( bootEntry != CurrentBootEntry );

            } else if ( MBE_IS_NEW( bootEntry ) ) {

                //
                // We don't support this yet.
                //

                FatalError(
                    ERROR_GEN_FAILURE,
                    L"How did we end up in SaveChanges with a NEW boot entry?!?\n"
                    );

            } else if ( MBE_IS_MODIFIED( bootEntry ) ) {

                //
                // Create a new boot entry structure using the existing one.
                // This is necessary to make an NT BOOT_ENTRY that can be
                // passed to NtModifyBootEntry.
                //

                newBootEntry = CreateBootEntryFromBootEntry( bootEntry );

                status = ModifyBootEntry( &newBootEntry->NtBootEntry );
                if ( !NT_SUCCESS(status) ) {
                    error = RtlNtStatusToDosError( status );
                    FatalError( error, L"Unable to modify boot entry: 0x%x\n", status );
                }

                //
                // Insert the new boot entry in place of the existing one.
                // Free the old one.
                //

                InsertHeadList( &bootEntry->ListEntry, &newBootEntry->ListEntry );
                RemoveEntryList( &bootEntry->ListEntry );

                FreeBootEntry( bootEntry );
                if ( bootEntry == CurrentBootEntry ) {
                    newCurrentBootEntry = newBootEntry;
                }
            }
        }
    }

    //
    // Build and write the new boot entry order list.
    //

    listHead = &BootEntries;

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        count++;
    }

    MemFree( BootEntryOrder );
    BootEntryOrder = MemAlloc( count * sizeof(ULONG) );

    count = 0;
    for ( listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink ) {
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        BootEntryOrder[count++] = bootEntry->Id;
    }

    status = SetBootEntryOrder( BootEntryOrder, count );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot entry order: 0x%x\n", status );
    }

    MemFree( OriginalBootEntryOrder );
    OriginalBootEntryOrder = MemAlloc( count * sizeof(ULONG) );
    memcpy( OriginalBootEntryOrder, BootEntryOrder, count * sizeof(ULONG) );

    //
    // Write the new timeout.
    //

    status = SetBootOptions( BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT );
    if ( !NT_SUCCESS(status) ) {
        error = RtlNtStatusToDosError( status );
        FatalError( error, L"Unable to set boot options: 0x%x\n", status );
    }

    MemFree( OriginalBootOptions );
    OriginalBootOptions = MemAlloc( BootOptionsLength );
    memcpy( OriginalBootOptions, BootOptions, BootOptionsLength );
    OriginalBootOptionsLength = BootOptionsLength;

    return newCurrentBootEntry;

} // SaveChanges

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntPath;
    PWSTR osDeviceNtName;
    PWSTR osDirectoryNtName;
    PWSTR fullNtName;

    length = 0;
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        return NULL;
    }

    ntPath = MemAlloc( length );
    status = TranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntPath,
                &length
                );
    if ( !NT_SUCCESS(status) ) {
        MemFree( ntPath );
        return NULL;
    }

    osDeviceNtName = (PWSTR)ntPath->FilePath;
    osDirectoryNtName = osDeviceNtName + wcslen(osDeviceNtName) + 1;

    length = (ULONG)(wcslen(osDeviceNtName) + wcslen(osDirectoryNtName) + 1) * sizeof(WCHAR);
    fullNtName = MemAlloc( length );

    wcscpy( fullNtName, osDeviceNtName );
    wcscat( fullNtName, osDirectoryNtName );

    MemFree( ntPath );

    return fullNtName;

} // GetNtNameForFilePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\echotime\echotime.c ===
/* echotime - prints current time and input args to stdout
 *
 * HISTORY:
 * 23-Jan-87    danl    added /n switch and ';' processing
 * 23-Nov-87    brianwi Exit code 0
 */

#include <string.h>
#include <time.h>
#include <stdio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

// Function Forward Parameters...
void Usage( void );
int __cdecl main( int, char ** );


const char rgstrUsage[] = {
    "Usage: ECHOTIME [/t] [/WODHMSCYb] [/v] [/n] [/N] [;] text\n"
    " /t  current day, time and year\n"
    " /WODHMSCYb\n"
    "     Weekday, mOnth, Day, Hour, Min, Sec, Century, Yr, blank\n"
    "     other char are themselves\n"
    "     e.g. echotime /O-D-Y this becomes Jan-02-86\n"
    "     e.g. echotime /ObDbY this becomes Jan 02 86\n"
    " /v  volume id of C:\n"
    " /n  no newline after outputting text\n"
    " /N  no trailing blank at end of lines\n"
    " a semicolon surrounded by white space is replaced by a newline\n"};

int fNewline = TRUE;
int fTrailingBlank = TRUE;

void Usage( void )
{
    puts(rgstrUsage);

    exit (1);
}

int
__cdecl
main (
    int c,
    char *v[]
    )
{
    // struct  findType findBuf;
    time_t    now;
    char    *p, *strTime, *p2, *p3, *printstring;
    char    ch;
    int     i, len;
    int     fFirstWord = TRUE;
    char    timestring[1000];           //plenty of room for formatted time string

    ConvertAppToOem( c, v );
    SHIFT( c, v );
    while ( c ) {
        printstring="";                 //default no text for this arg
        if ( !strcmp( *v, "/?" ))
            Usage ();
        if ( !strcmp( *v, "/n" ))
            fNewline = FALSE;
        else if ( !strcmp( *v, "/N" ))
            fTrailingBlank = FALSE;
        else if ( !strcmp( *v, "/v" )) {
            //
            //  It would make more sense to replace by the volume id of the
            //  current drive, but the original code used drive C: and
            //  it is described as so in the help file, so I'll do the same.
            //
            char    VolumeName[MAX_PATH];
            BOOL    StatusOk;

            StatusOk = GetVolumeInformation( "C:\\",
                                             VolumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             0 );
            if (!StatusOk) {
                printstring = "NO_VOL_ID";
            } else {
                printstring = VolumeName;
            }


            }
        else if (**v == '/') {
            *timestring='\0';
            p2 = *v;
            time( &now );
            strTime = _strdup( ctime( &now ) );
            if (!strTime) {
                puts("Out of memory");
                exit(1);
            }
            p = strend( strTime );
            *--p = '\0';
            while ((ch = *++p2)) {
                len = 2;
                switch (ch) {
                    case 'W':   /* Week */
                        len = 3;
                        i = 0;
                        break;
                    case 'O':   /* mOnth */
                        len = 3;
                        i = 4;
                        break;
                    case 'D':   /* Day  */
                        i = 8;
                        break;
                    case 'H':   /* Hour */
                        i = 11;
                        break;
                    case 'M':   /* Min  */
                        i = 14;
                        break;
                    case 'S':   /* Sec  */
                        i = 17;
                        break;
                    case 'C':   /* Century */
                        i = 20;
                        break;
                    case 'Y':   /* Year */
                        i = 22;
                        break;
                    case 'b':   /* Blank */
                        len = 1;
                        i = 3;
                        break;
                    case 't':
                        len = 25;
                        i = 0;
                        break;
                    default:
                        strTime[3] = ch;
                        len = 1;
                        i = 3;
                        break;
                    }
                p = strTime + i;
                p3 = p + len;
                ch = *p3;
                *p3 = '\0';
                strcat(timestring, p);  /* N.B. no trailing blanks */
                *p3 = ch;
                strTime[3] = ' ';
                }
            printstring = timestring;
            }
        else if (!strcmp( *v, ";" )) {
            if (fTrailingBlank)
               printf(" ");
            printf ("\n" );
            fFirstWord = TRUE;
            // printstring remains pointing to empty string
        }
        else
            printstring= *v;

        if (*printstring) {
            if (!fFirstWord)
               printf( " ");
            else
               fFirstWord=FALSE;
            printf("%s", printstring);
        }

        SHIFT( c, v );
        }
    if (fTrailingBlank)
        printf( " ");
    if ( fNewline )
        printf("\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\efinvram\efinvram.h ===
#define UNICODE 1

#include <nt.h>
//#include <ntosp.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4213)   // nonstandard extension used : cast on l-value

#include <stdio.h>
#include <stdlib.h>

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

extern PBOOT_OPTIONS BootOptions;
extern ULONG BootOptionsLength;
extern PBOOT_OPTIONS OriginalBootOptions;
extern ULONG OriginalBootOptionsLength;

extern PULONG BootEntryOrder;
extern ULONG BootEntryOrderCount;
extern PULONG OriginalBootEntryOrder;
extern ULONG OriginalBootEntryOrderCount;

//
// MY_BOOT_ENTRY is the internal representation of an EFI NVRAM boot item.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PUCHAR AllocationEnd;
    ULONG Status;
    ULONG Id;
    ULONG Attributes;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    PUCHAR ForeignOsOptions;
    ULONG ForeignOsOptionsLength;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

#define MBE_STATUS_IS_NT        0x00000001
#define MBE_STATUS_NEW          0x00000002
#define MBE_STATUS_DELETED      0x00000004
#define MBE_STATUS_MODIFIED     0x00000008
#define MBE_STATUS_COMMITTED    0x80000000

#define MBE_IS_NT(_be) (((_be)->Status & MBE_STATUS_IS_NT) != 0)
#define MBE_IS_NEW(_be) (((_be)->Status & MBE_STATUS_NEW) != 0)
#define MBE_IS_DELETED(_be) (((_be)->Status & MBE_STATUS_DELETED) != 0)
#define MBE_IS_MODIFIED(_be) (((_be)->Status & MBE_STATUS_MODIFIED) != 0)
#define MBE_IS_COMMITTED(_be) (((_be)->Status & MBE_STATUS_COMMITTED) != 0)

#define MBE_SET_IS_NT(_be) ((_be)->Status |= MBE_STATUS_IS_NT)
#define MBE_SET_NEW(_be) ((_be)->Status |= MBE_STATUS_NEW)
#define MBE_SET_DELETED(_be) ((_be)->Status |= MBE_STATUS_DELETED)
#define MBE_SET_MODIFIED(_be) ((_be)->Status |= MBE_STATUS_MODIFIED)
#define MBE_SET_COMMITTED(_be) ((_be)->Status |= MBE_STATUS_COMMITTED)

#define MBE_CLEAR_IS_NT(_be) ((_be)->Status &= ~MBE_STATUS_IS_NT)
#define MBE_CLEAR_NEW(_be) ((_be)->Status &= ~MBE_STATUS_NEW)
#define MBE_CLEAR_DELETED(_be) ((_be)->Status &= ~MBE_STATUS_DELETED)
#define MBE_CLEAR_MODIFIED(_be) ((_be)->Status &= ~MBE_STATUS_MODIFIED)
#define MBE_CLEAR_COMMITTED(_be) ((_be)->Status &= ~MBE_STATUS_COMMITTED)

#define MBE_IS_ACTIVE(_be) (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define MBE_SET_ACTIVE(_be) ((_be)->Status |= BOOT_ENTRY_ATTRIBUTE_ACTIVE)
#define MBE_CLEAR_ACTIVE(_be) ((_be)->Status &= ~BOOT_ENTRY_ATTRIBUTE_ACTIVE)

#define IS_SEPARATE_ALLOCATION(_be,_p)                                  \
        ((_be->_p != NULL) &&                                           \
         (((PUCHAR)_be->_p < (PUCHAR)_be) ||                            \
          ((PUCHAR)_be->_p > (PUCHAR)_be->AllocationEnd)))

#define FREE_IF_SEPARATE_ALLOCATION(_be,_p)                             \
        if (IS_SEPARATE_ALLOCATION(_be,_p)) {                           \
            MemFree(_be->_p);                                           \
        }

extern LIST_ENTRY BootEntries;
extern LIST_ENTRY DeletedBootEntries;
extern LIST_ENTRY ActiveUnorderedBootEntries;
extern LIST_ENTRY InactiveUnorderedBootEntries;

PVOID
MemAlloc(
    IN SIZE_T Size
    );

PVOID
MemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    );

VOID
MemFree(
    IN PVOID Block
    );

VOID
InitializeMenuSystem (
    VOID
    );

VOID
MainMenu (
    VOID
    );

VOID
ClearMenuArea (
    VOID
    );

PMY_BOOT_ENTRY
SaveChanges (
    PMY_BOOT_ENTRY CurrentBootEntry
    );

PWSTR
GetNtNameForFilePath (
    IN PFILE_PATH FilePath
    );

VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    );

VOID
SetStatusLine (
    PWSTR Status
    );

VOID
SetStatusLineAndWait (
    PWSTR Status
    );

VOID
SetStatusLine2 (
    PWSTR Status
    );

VOID
SetStatusLine2AndWait (
    PWSTR Status
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\scanlib\precomp.h ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\exe\precomp.h ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <scan.h>

#if SCAN_DEBUG
extern BOOL dprinton;
#define dprintf(_x_) if (dprinton) printf _x_
#else
#define dprintf(_x_)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\exe\emptydirs.c ===
#include "precomp.h"
#pragma hdrstop

#if SCAN_DEBUG
BOOL dprinton = FALSE;
#endif

//
// This flag indicates whether empty directories should be deleted.
//

BOOL DeleteEmptyDirectories = FALSE;
BOOL ContinueOnError = FALSE;
BOOL Quiet = FALSE;
BOOL ShowWriteableFiles = FALSE;

DWORD
NewFile (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingFileData OPTIONAL,
    IN PWIN32_FIND_DATAW NewFileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory finds a file.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Directory containing this file.

    ExistingFileData - Pointer to data describing previous found file with
        same name, if any.

    NewFileData - Pointer to data for this file.

    FileUserData - Pointer to user-controlled data field for the file.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    //
    // Increment the directory/file count for the parent. Set the file's
    // user data pointer to NULL, indicating that we don't need the
    // scan library to remember this file.
    //

    (*(DWORD *)ParentDirectoryUserData)++;
    *FileUserData = NULL;

    dprintf(( "  NF: File %ws\\%ws: parent count %d, file count %d\n",
                Path, NewFileData->cFileName,
                *(DWORD *)ParentDirectoryUserData, *FileUserData ));

    //
    // If we're supposed to show writeable files, check for that now.
    //

    if ( ShowWriteableFiles &&
         ((NewFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) == 0) ) {
        printf( "FILE: %ws\\%ws\n", Path, NewFileData->cFileName );
    }

    return 0;

} // NewFile

DWORD
NewDirectory (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingDirectoryData OPTIONAL,
    IN PWIN32_FIND_DATAW NewDirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory finds a directory.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Directory containing this directory.

    ExistingDirectoryData - Pointer to data describing previous found directory with
        same name, if any.

    NewDirectoryData - Pointer to data for this directory.

    DirectoryUserData - Pointer to user-controlled data field for the directory.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    //
    // Increment the directory/file count for the parent. Set the directory's
    // user data pointer to 1, indicating that the scan library should
    // remember this directory and scan it.
    //

    (*(DWORD *)ParentDirectoryUserData)++;
    *(DWORD *)DirectoryUserData = 1;

    dprintf(( "  ND: Dir  %ws\\%ws: parent count %d, dir  count %d\n",
                Path, NewDirectoryData->cFileName,
                *(DWORD *)ParentDirectoryUserData, *DirectoryUserData ));

    return 0;

} // NewDirectory

DWORD
CheckDirectory (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    )

/*++

Routine Description:

    Called when ScanDirectory has completed the recursive scan for a directory.

Arguments:

    Context - User-supplied context. Not used by emptydirs.

    Path - Path to this directory. (Not to containing directory.)

    DirectoryData - Pointer to data for this directory.

    DirectoryUserData - Pointer to user-controlled data field for the directory.

    ParentDirectoryUserData - Pointer to user-controlled data field for the
        parent directory.

Return Value:

    DWORD - Indicates whether an error occurred.

--*/

{
    BOOL ok;
    DWORD error;

    //
    // If the directory's directory/file count is 1, then the directory
    // contains no files or directories (the count is biased by 1), and
    // is empty.
    //

    if ( *(DWORD *)DirectoryUserData == 1 ) {

        if ( !Quiet ) {
            if ( ShowWriteableFiles ) {
                printf( "DIR:  " );
            }
            printf( "%ws", Path );
        }

        //
        // If requested, delete this empty directory.
        //

        if ( DeleteEmptyDirectories ) {
            ok = RemoveDirectory( Path );
            if ( !ok ) {
                error = GetLastError( );
                if ( !Quiet ) printf( " - error %d\n", error );
                fprintf( stderr, "Error %d deleting %ws\n", error, Path );
                if ( !ContinueOnError ) {
                    return error;
                }
            } else {
                if ( !Quiet ) printf( " - deleted\n" );
            }
        } else {
            if ( !Quiet ) printf( "\n" );
        }

        //
        // Decrement the parent directory's directory/file count.
        //

        (*(DWORD *)ParentDirectoryUserData)--;
    }

    dprintf(( "  CD: Dir  %ws: parent count %d, dir  count %d\n",
                Path, 
                *(DWORD *)ParentDirectoryUserData, *DirectoryUserData ));

    return 0;

} // CheckDirectory

int
__cdecl
wmain (
    int argc,
    WCHAR *argv[]
    )
{
    BOOL ok;
    DWORD error;
    WCHAR directory[MAX_PATH];
    PVOID scanHandle = NULL;

    //
    // Parse switches.
    //

    argc--;
    argv++;

    while ( (argc != 0) && ((argv[0][0] == '-') || (argv[0][0] == '/')) ) {

        argv[0]++;

        switch ( towlower(argv[0][0]) ) {
        case 'c':
            ContinueOnError = TRUE;
            break;
        case 'd':
            DeleteEmptyDirectories = TRUE;
            break;
        case 'q':
            Quiet = TRUE;
            break;
        case 'w':
            ShowWriteableFiles = TRUE;
            break;
        default:
            fprintf( stderr, "usage: emptydirs [-cdqw]\n" );
            return 1;
        }
        argc--;
        argv++;
    }

    //
    // If a directory was specified, CD to it and get its path.
    //

    if ( argc != 0 ) {
        ok = SetCurrentDirectory( argv[0] );
        if ( !ok ) {
            error = GetLastError( );
            fprintf( stderr, "error: Unable to change to specified directory %ws: %d\n", argv[0], error );
            goto cleanup;
        }
    }
    argc--;
    argv++;

    GetCurrentDirectory( MAX_PATH, directory );

    //
    // Initialize the scan library.
    //

    error = ScanInitialize(
                &scanHandle,
                TRUE,           // recurse
                FALSE,          // don't skip root
                NULL
                );
    if (error != 0) {
        fprintf( stderr, "ScanInitialize(%ws) failed %d\n", directory, error );
        error = 1;
        goto cleanup;
    }

    //
    // Scan the specified directory.
    //

    error = ScanDirectory(
                scanHandle,
                directory,
                NULL,
                NewDirectory,
                CheckDirectory,
                NULL,
                NewFile,
                NULL
                );
    if (error != 0) {
        fprintf( stderr, "ScanDirectory(%ws) failed %d\n", directory, error );
        error = 1;
        goto cleanup;
    }

cleanup:

    //
    // Close down the scan library.
    //

    if ( scanHandle != NULL ) {
        ScanTerminate( scanHandle );
    }

    return error;

} // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\efinvram\memory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmemory.c

Abstract:

    Memory allocation routines for text setup.

Author:

    Ted Miller (tedm) 29-July-1993

Revision History:

--*/



#include "efinvram.h"

PVOID
MemAlloc(
    IN SIZE_T Size
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T p;

    //
    // Add space for storing the size of the block.
    //
    p = RtlAllocateHeap( RtlProcessHeap(), 0, Size + sizeof(SIZE_T) );

    if ( p == NULL ) {
        FatalError( ERROR_NOT_ENOUGH_MEMORY, L"Insufficient memory\n" );
    }

    //
    // Store the size of the block, and return the address
    // of the user portion of the block.
    //
    *p++ = Size;

    return p;
}



PVOID
MemRealloc(
    IN PVOID Block,
    IN SIZE_T NewSize
    )

/*++

Routine Description:

    This function is guaranteed to succeed.

Arguments:

Return Value:

--*/

{
    PSIZE_T NewBlock;
    SIZE_T  OldSize;

    //
    // Get the size of the block being reallocated.
    //
    OldSize = ((PSIZE_T)Block)[-1];

    //
    // Allocate a new block of the new size.
    //
    NewBlock = MemAlloc(NewSize);
    ASSERT(NewBlock);

    //
    // Copy the old block to the new block.
    //
    if (NewSize < OldSize) {
        RtlCopyMemory(NewBlock, Block, NewSize);
    } else {
        RtlCopyMemory(NewBlock, Block, OldSize);
    }

    //
    // Free the old block.
    //
    MemFree(Block);

    //
    // Return the address of the new block.
    //
    return(NewBlock);
}


VOID
MemFree(
    IN PVOID Block
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Block == NULL)
        return;

    //
    // Free the block at its real address.
    //
    RtlFreeHeap( RtlProcessHeap(), 0, (PSIZE_T)Block - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\efinvram\menu.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    spmenu.c

Abstract:

    Text setup menu support.

Author:

    Ted Miller (tedm) 8-September-1993

Revision History:

--*/


#include "efinvram.h"

WCHAR line[512];

HANDLE InputHandle;
HANDLE OutputHandle;
HANDLE OriginalOutputHandle = NULL;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
CONSOLE_CURSOR_INFO OriginalCursorInfo;
DWORD OriginalInputMode;
WORD NormalAttribute;
WORD HighlightAttribute;
DWORD NumberOfColumns;
DWORD NumberOfRows;
DWORD NumberOfMenuLines;

#define MENUITEM_NORMAL     0x00000000
#define MENUITEM_STATIC     0x00000001


typedef struct _MENU_ITEM {

    PWSTR Text;

    ULONG Flags;

    ULONG LeftX;

    ULONG_PTR UserData;

    SIZE_T OriginalLength;

} MENU_ITEM, *PMENU_ITEM;


typedef struct _MENU {

    PMENU_ITEM Items;
    ULONG      ItemCount;

    ULONG      TopY;
    ULONG      Height;

    ULONG      LeftX;
    ULONG      Width;

    ULONG      TopDisplayedIndex;

    BOOLEAN    MoreUp,MoreDown;

} MENU, *PMENU;


BOOL
AddItems (
    PVOID Menu,
    PWSTR StaticText,
    PLIST_ENTRY ListHead
    );

VOID
DisplayMainMenuKeys (
    VOID
    );

VOID
DisplayEditMenuKeys (
    VOID
    );

VOID
EditBootEntry (
    IN PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    );

VOID
EditTimeout (
    IN OUT PBOOL ChangesMade
    );

BOOL
PromptToSaveChanges (
    VOID
    );

PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    );

VOID
SpMnDestroy(
    IN PVOID Menu
    );

BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    );

VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  PULONG                 ValidKeys,
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    );

VOID
SpMnClearArea (
    IN ULONG Top,
    IN ULONG Bottom
    );

ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2 OPTIONAL
    );

VOID
WriteConsoleLine (
    ULONG Row,
    ULONG Column,
    PWSTR Text,
    BOOL Highlight
    );

VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    );


PVOID
SpMnCreate(
    IN ULONG   LeftX,
    IN ULONG   TopY,
    IN ULONG   Width,
    IN ULONG   Height
    )

/*++

Routine Description:

    Create a new menu by allocating space for a new menu structure
    and initializing its fields.

Arguments:

    LeftX - supplies the 0-based X coordinate of the leftmost column
        of the menu.

    TopY - supplies the 0-based Y coordinate of the topmost line
        of the menu.

    Width - supplies the maximum displayed width for lines in the menu.

    Height - supplies the maximum displayed height of the menu.
        The menu will scroll if it is too long to fit in the
        allotted space.

Return Value:

    Menu handle (expressed as a pvoid) of NULL if memory couldn't
    be allocated.

--*/

{
    PMENU p;

    p = MemAlloc( sizeof(MENU) );

    RtlZeroMemory( p, sizeof(MENU) );

    p->Items = MemAlloc( 0 );
    p->LeftX = LeftX;
    p->TopY = TopY;
    p->Width = Width;
    p->Height = Height;

    return p;
}


VOID
SpMnDestroy(
    IN PVOID Menu
    )

/*++

Routine Description:

    Destroy a menu, releasing all memory associated with it.

Arguments:

    Menu - supplies handle to menu to destroy.

Return Value:

    None.

--*/

{
    PMENU pMenu = Menu;
    ULONG u;


    for(u=0; u<pMenu->ItemCount; u++) {
        if(pMenu->Items[u].Text) {
            MemFree(pMenu->Items[u].Text);
        }
    }

    MemFree(pMenu->Items);

    MemFree(pMenu);
}



BOOLEAN
SpMnAddItem(
    IN PVOID   Menu,
    IN PWSTR   Text,
    IN ULONG   LeftX,
    IN ULONG   Width,
    IN BOOLEAN Selectable,
    IN ULONG_PTR UserData
    )

/*++

Routine Description:

    Add an item to a menu.

Arguments:

    Menu - supplies handle to menu to which the item is to be added.

    Text - supplies text that comprises the menu selection.  This routine
        will make a copy of the text.

    LeftX - supplies 0-based x coordinate of leftmost character of the text
        when it is displayed.

    Width - supplies width in characters of the field for this selection.
        If this is larger than the number of characters in the text, then
        the text is padded to the right with blanks when highlighted.

    Selectable - if FALSE, then this text is static -- ie, not selectable.

    UserData - supplies a ulong's worth of caller-specific data to be associated
        with this menu item.

Return Value:

    TRUE if the menu item was added successfully; FALSE if insufficient memory.

--*/

{
    PMENU pMenu = Menu;
    PMENU_ITEM p;
    SIZE_T TextLen;
    SIZE_T PaddedLen;
    PWSTR String;
    ULONG u;
    SIZE_T ColumnLen;
    SIZE_T FillLen;

    //
    // Build a string that is padded to the right with blanks to make
    // it the right width.
    //
    TextLen = wcslen(Text);
    PaddedLen = max(TextLen,Width);
    ColumnLen = TextLen;
    FillLen = (PaddedLen <= ColumnLen) ? 0 : PaddedLen - ColumnLen;

    String = MemAlloc((PaddedLen+1)*sizeof(WCHAR));
    if(!String) {
        return(FALSE);
    }

    wcsncpy(String,Text,TextLen);
    for(u=0; u<FillLen; u++) {
        String[TextLen+u] = L' ';
    }
    String[TextLen+u] = 0;

    //
    // Make space for the item.
    //
    if((p = MemRealloc(pMenu->Items,(pMenu->ItemCount+1) * sizeof(MENU_ITEM))) == NULL) {
        MemFree(String);
        return(FALSE);
    }

    pMenu->Items = p;

    //
    // Calculate the address of the new menu item and
    // indicate that there is now an additional item in the menu.
    //
    p = &pMenu->Items[pMenu->ItemCount++];

    //
    // Set the fields of the menu.
    //
    p->LeftX = LeftX;
    p->UserData = UserData;

    p->Flags = Selectable ? MENUITEM_NORMAL : MENUITEM_STATIC;

    p->Text = String;

    p->OriginalLength = TextLen;

    return(TRUE);
}


PWSTR
SpMnGetText(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            return(pMenu->Items[i].Text);
        }
    }

    return(NULL);
}

PWSTR
SpMnGetTextDup(
    IN PVOID Menu,
    IN ULONG_PTR UserData
    )
{
    PMENU pMenu = Menu;
    ULONG i;
    PWSTR p;

    for(i=0; i<pMenu->ItemCount; i++) {
        if(pMenu->Items[i].UserData == UserData) {
            //
            // Make a duplicate; leave off trailing pad spaces.
            //
            p = MemAlloc((pMenu->Items[i].OriginalLength+1)*sizeof(WCHAR));
            wcsncpy(p,pMenu->Items[i].Text,pMenu->Items[i].OriginalLength);
            p[pMenu->Items[i].OriginalLength] = 0;
            return(p);
        }
    }

    return(NULL);
}


VOID
SpMnDisplay(
    IN  PVOID                  Menu,
    IN  ULONG_PTR              UserDataOfHighlightedItem,
    IN  PULONG                 ValidKeys,
    OUT PULONG                 KeyPressed,
    OUT PULONG_PTR             UserDataOfSelectedItem
    )

/*++

Routine Description:

    Display a menu and accept keystrokes.

    When the user presses a menu keystroke (up/down arrow keys), this
    routine automatically updates the highlight and calls a callback function
    to inform the caller that a new item has the highlight.

    When the user presses a keystroke in a list provided by the caller,
    this routine returns, providing information about the key pressed and
    the item that was highlighted when the key was pressed.

Arguments:

    Menu - supplies handle to menu to be displayed.

    UserDataOfHighlightedItem - supplies user data of the menu item which
        is to receive the highlight initially.

    ValidKeys - supplies a list of keystrokes that cause this routine to
        return to the caller.  The list must be terminated with a 0 entry.

    KeyPressed - receives the key press that caused this routine to exit.
        This will be a valid from the ValidKeys array.

    UserDataOfSelectedItem - receives the UserData of the item that had the
        highlight when the user pressed a key in ValidKeys.

Return Value:

    None.

--*/


{
    ULONG ValidMenuKeys[3] = { VK_UP, VK_DOWN, 0 };
    ULONG key;
    PMENU pMenu = Menu;
    ULONG SelectedIndex,OldIndex;
    BOOLEAN FoundNewItem;
    ULONG NewTopDisplayedIndex;
    BOOLEAN MustScroll;
    PWSTR MoreUpText,MoreDownText;
    CONSOLE_CURSOR_INFO cursorInfo;

    cursorInfo = OriginalCursorInfo;
    cursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo( OutputHandle, &cursorInfo );

    //
    // Get the text for the text that indicate that there are more
    // selections.
    //
    MoreUpText =   L"[More above...]";
    MoreDownText = L"[More below...]";

    //
    // Locate the seleccted item.
    //
    for(SelectedIndex=0; SelectedIndex<pMenu->ItemCount; SelectedIndex++) {
        if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)
        && (pMenu->Items[SelectedIndex].UserData == UserDataOfHighlightedItem))
        {
            break;
        }
    }
    ASSERT(SelectedIndex < pMenu->ItemCount);

    //
    // Make sure the selected item will be visible when we draw the menu.
    //
    pMenu->TopDisplayedIndex = 0;
    while(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
        pMenu->TopDisplayedIndex += pMenu->Height;
    }

    //
    // Draw the menu itself.
    //
    pSpMnDrawMenu(pMenu,SelectedIndex,TRUE,MoreUpText,MoreDownText);

    while ( TRUE ) {

        //
        // Wait for a valid keypress.
        //
        key = SpWaitValidKey(ValidKeys,ValidMenuKeys);

        //
        // If the key is a menu keystroke, handle it here.
        //
        FoundNewItem = FALSE;
        MustScroll = FALSE;
        NewTopDisplayedIndex = 0;
        OldIndex = SelectedIndex;

        switch(key) {

        case VK_UP:

            //
            // Locate the previous selectable item.
            //
            if(SelectedIndex) {

                for(SelectedIndex=SelectedIndex-1; (LONG)SelectedIndex>=0; SelectedIndex--) {
                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex < pMenu->TopDisplayedIndex) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = SelectedIndex;
                    }
                } else {
                    //
                    // If the first lines are static text, there might be no
                    // way to get them back on the screen -- the tests above
                    // fail in this case.  So if the user hits the up arrow
                    // when he's at the topmost selectable item but there are
                    // static items above him, we'll simply scroll the menu
                    // so that item #0 is at the top.
                    //
                    FoundNewItem = TRUE;
                    NewTopDisplayedIndex = 0;
                    MustScroll = TRUE;
                    SelectedIndex = OldIndex;
                }
            }
            break;

        case VK_DOWN:

            //
            // Locate the next selectable item.
            //
            if(SelectedIndex < pMenu->ItemCount) {

                for(SelectedIndex=SelectedIndex+1; SelectedIndex < pMenu->ItemCount; SelectedIndex++) {

                    if(!(pMenu->Items[SelectedIndex].Flags & MENUITEM_STATIC)) {
                        FoundNewItem = TRUE;
                        break;
                    }
                }

                if(FoundNewItem) {
                    //
                    // Figure out whether we have to scroll the menu.
                    //
                    if(SelectedIndex >= pMenu->TopDisplayedIndex + pMenu->Height) {
                        MustScroll = TRUE;
                        NewTopDisplayedIndex = pMenu->TopDisplayedIndex + SelectedIndex - OldIndex;
                    }
                }
            }
            break;

        default:

            //
            // User pressed a non-menu key.
            //
            *KeyPressed = key;
            *UserDataOfSelectedItem = pMenu->Items[SelectedIndex].UserData;

            SetConsoleCursorInfo( OutputHandle, &OriginalCursorInfo );
            return;
        }


        if(FoundNewItem) {

            //
            // Unhighlight the currently selected item.
            //
            WriteConsoleLine(
                pMenu->TopY + OldIndex - pMenu->TopDisplayedIndex,
                pMenu->Items[OldIndex].LeftX,
                pMenu->Items[OldIndex].Text,
                FALSE
                );


            //
            // Highlight the newly selected item.  This may involve
            // scrolling the menu.
            //
            if(MustScroll) {
                //
                // Redraw the menu so the newly highlighted line is in view.
                //
                pMenu->TopDisplayedIndex = NewTopDisplayedIndex;

                pSpMnDrawMenu(pMenu,SelectedIndex,TRUE,MoreUpText,MoreDownText);
            }

            //
            // Highlight the newly selected item.
            //
            WriteConsoleLine(
                pMenu->TopY + SelectedIndex - pMenu->TopDisplayedIndex,
                pMenu->Items[SelectedIndex].LeftX,
                pMenu->Items[SelectedIndex].Text,
                TRUE
                );


        } else {
            SelectedIndex = OldIndex;
        }
    }
}


VOID
pSpMnDrawMenu(
    IN PMENU   pMenu,
    IN ULONG   SelectedIndex,
    IN BOOLEAN IndicateMore,
    IN PWSTR   MoreUpText,
    IN PWSTR   MoreDownText
    )
{
    ULONG item;
    BOOLEAN MoreUp,MoreDown,MoreStatusChanged;

    //
    // Blank out the on-screen menu display.
    //
    for ( item = pMenu->TopY; item < (pMenu->TopY + pMenu->Height); item++ ) {
        WriteConsoleLine( item, 0, NULL, FALSE );
    }


    MoreUp = (BOOLEAN)(pMenu->TopDisplayedIndex > 0);
    MoreDown = (BOOLEAN)(pMenu->TopDisplayedIndex + pMenu->Height < pMenu->ItemCount);

    MoreStatusChanged = (BOOLEAN)(    IndicateMore
                                   && (    (pMenu->MoreUp != MoreUp)
                                        || (pMenu->MoreDown != MoreDown)
                                      )
                                 );

    //
    // Draw each item that is currently on-screen.
    //
    ASSERT(pMenu->TopDisplayedIndex < pMenu->ItemCount);
    for(item = pMenu->TopDisplayedIndex;
        item < min(pMenu->TopDisplayedIndex+pMenu->Height,pMenu->ItemCount);
        item++)
    {
        WriteConsoleLine(
            pMenu->TopY + item - pMenu->TopDisplayedIndex,
            pMenu->Items[item].LeftX,
            pMenu->Items[item].Text,
            (BOOLEAN)(item == SelectedIndex)
            );
    }


    //
    // If there are more selections above or below us,
    // indicate so by placing a small bit of text on the frame.
    // Note that the arrow chars can sometimes be DBCS.
    //
    if(MoreStatusChanged) {

        if(MoreUp) {
            WriteConsoleLine(
                pMenu->TopY - 1,
                pMenu->LeftX + 4,
                MoreUpText,
                FALSE
                );
        } else {
            WriteConsoleLine(
                pMenu->TopY - 1,
                0,
                NULL,
                FALSE
                );
        }

        if(MoreDown) {
            WriteConsoleLine(
                pMenu->TopY + pMenu->Height,
                pMenu->LeftX + 4,
                MoreDownText,
                FALSE
                );
        } else {
            WriteConsoleLine(
                pMenu->TopY + pMenu->Height,
                0,
                NULL,
                FALSE
                );
        }

        pMenu->MoreUp = MoreUp;
        pMenu->MoreDown = MoreDown;
    }
}

VOID
InitializeMenuSystem (
    VOID
    )
{
    DWORD error;
    COORD windowSize;
    CONSOLE_CURSOR_INFO cursorInfo;
    cursorInfo = OriginalCursorInfo;
    cursorInfo.bVisible = FALSE;

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    if ( InputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdin handle: %d\n", error );
    }

    if ( !GetConsoleMode( InputHandle, &OriginalInputMode ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdin mode: %d\n", error );
    }

    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    if ( OriginalOutputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get stdout handle: %d\n", error );
    }

    OutputHandle = CreateConsoleScreenBuffer(
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        CONSOLE_TEXTMODE_BUFFER,
                        NULL
                        );
    if ( OutputHandle == NULL ) {
        error = GetLastError( );
        FatalError( error, L"Unable to create console screen buffer: %d\n", error );
    }

    if ( !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get console screen buffer info: %d\n", error );
    }
    
    if ( !GetConsoleCursorInfo( OriginalOutputHandle, &OriginalCursorInfo ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to get console screen buffer info: %d\n", error );
    }
    
    NormalAttribute = 0x1F;
    HighlightAttribute = 0x71;
    NumberOfColumns = OriginalConsoleInfo.srWindow.Right - OriginalConsoleInfo.srWindow.Left + 1;
    NumberOfRows = OriginalConsoleInfo.srWindow.Bottom - OriginalConsoleInfo.srWindow.Top + 1;
    NumberOfMenuLines = NumberOfRows - (3 + 1 + 1 + 1 + 8);
    if ( NumberOfMenuLines > 12 ) {
        NumberOfMenuLines = 12;
    }

    if ( NumberOfRows < 20 ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Please run this program in a console window with 20 or more lines\n"
            );
    }
    if ( NumberOfColumns < 80 ) {
        FatalError(
            ERROR_INVALID_PARAMETER,
            L"Please run this program in a console window with 80 or more columns\n"
            );
    }

    windowSize.X = (SHORT)NumberOfColumns;
    windowSize.Y = (SHORT)NumberOfRows;

    if ( !SetConsoleScreenBufferSize( OutputHandle, windowSize ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set console screen buffer size: %d\n", error );
    }

    if ( !SetConsoleActiveScreenBuffer( OutputHandle ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set active screen buffer: %d\n", error );
    }

    if ( !SetConsoleMode( InputHandle, 0 ) ) {
        error = GetLastError( );
        FatalError( error, L"Unable to set console mode: %d\n", error );
    }

    return;

} // InitializeMenuSystem

VOID
FatalError (
    DWORD Error,
    PWSTR Format,
    ...
    )
{
    va_list marker;

    if ( OutputHandle != NULL ) {
        SetConsoleCursorInfo( OutputHandle, &OriginalCursorInfo );
        CloseHandle( OutputHandle );
        if ( OriginalOutputHandle != NULL ) {
            SetConsoleActiveScreenBuffer( OriginalOutputHandle );
            SetConsoleMode( InputHandle, OriginalInputMode );
        }
    }

    va_start( marker, Format );
    vwprintf( Format, marker );
    va_end( marker );

    if ( Error == NO_ERROR ) {
        Error = ERROR_GEN_FAILURE;
    }
    exit( Error );

} // FatalError

VOID
WriteConsoleLine (
    ULONG Row,
    ULONG Column,
    PWSTR Text,
    BOOL Highlight
    )
{
    BOOL ok;
    DWORD error;
    COORD writeCoord;
    DWORD numberWritten;
    DWORD textLength;

    writeCoord.X = 0;
    writeCoord.Y = (SHORT)Row;

    ok = FillConsoleOutputCharacter(
            OutputHandle,
            ' ',
            NumberOfColumns,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error filling console line: %d\n", error );
    }

    ok = FillConsoleOutputAttribute(
            OutputHandle,
            OriginalConsoleInfo.wAttributes,
            NumberOfColumns,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error filling console attributes: %d\n", error );
    }

    if ( (Text == NULL) || ((textLength = (DWORD)wcslen( Text )) == 0) ) {
        return;
    }

    writeCoord.X = (SHORT)Column;

    ok = WriteConsoleOutputCharacter(
            OutputHandle,
            Text,
            textLength,
            writeCoord,
            &numberWritten
            );
    if ( !ok ) {
        error = GetLastError( );
        FatalError( error, L"Error writing console line: %d\n", error );
    }

    if (Highlight) {

        WORD attr = ((OriginalConsoleInfo.wAttributes & 0xf0) >> 4) +
                    ((OriginalConsoleInfo.wAttributes & 0x0f) << 4);

        ok = FillConsoleOutputAttribute(
                OutputHandle,
                attr,
                textLength,
                writeCoord,
                &numberWritten
                );
        if ( !ok ) {
            error = GetLastError( );
            FatalError( error, L"Error writing console attributes: %d\n", error );
        }
    }

    return;

} // WriteConsoleLine

ULONG
SpWaitValidKey(
    IN PULONG ValidKeys1,
    IN PULONG ValidKeys2 OPTIONAL
    )

/*++

Routine Description:

    Wait for a key to be pressed that appears in a list of valid keys.

Arguments:

    ValidKeys1 - supplies list of valid keystrokes.  The list must be
        terminated with a 0 entry.

    ValidKeys2 - if specified, supplies an additional list of valid keystrokes.

Return Value:

    The key that was pressed (see above).

--*/

{
    ULONG c;
    ULONG i;
    INPUT_RECORD InputRecord;
    ULONG NumberOfInputRecords;

    FlushConsoleInputBuffer( InputHandle );

    while ( TRUE ) {

        WaitForSingleObject( InputHandle, INFINITE );
        if ( ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
             InputRecord.EventType == KEY_EVENT &&
             InputRecord.Event.KeyEvent.bKeyDown ) {

            c = InputRecord.Event.KeyEvent.wVirtualKeyCode;

            //
            // Check for normal key.
            //
    
            for(i=0; ValidKeys1[i]; i++) {
                if(c == ValidKeys1[i]) {
                    return(c);
                }
            }
    
            //
            // Check secondary list.
            //
            if(ValidKeys2) {
                for(i=0; ValidKeys2[i]; i++) {
                    if(c == ValidKeys2[i]) {
                        return(c);
                    }
                }
            }
        }
    }
}

VOID
SpMnClearArea (
    IN ULONG Top,
    IN ULONG Bottom
    )
{
    ULONG row;

    for ( row = Top; row <= Bottom; row++ ) {
        WriteConsoleLine( row, 0, NULL, FALSE );
    }

    return;

} // SpMnClearArea

VOID
MainMenu (
    VOID
    )
{
    BOOL b;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listEntry2;
    PMY_BOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY currentBootEntry;
    ULONG validKeys[] = {
        VK_ESCAPE,
        VK_RETURN,
        VK_PRIOR,
        VK_NEXT,
        VK_HOME,
        VK_END,
        VK_DELETE,
        'Q',
        'U',
        'D',
        'T',
        'B',
        'X',
        'A',
        'O',
        'E',
        'M',
        'S',
        0
        };
    PVOID menu;
    ULONG pressedKey;
    BOOL changesMade = FALSE;

    WriteConsoleLine( 1, 1, L"Windows Whistler EFI NVRAM Editor", FALSE );

    listEntry = BootEntries.Flink;
    if ( listEntry != &BootEntries ) {
        currentBootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
    } else {
        currentBootEntry = NULL;
    }

    while ( TRUE ) {

        menu = SpMnCreate( 4, 4, NumberOfColumns - 4, NumberOfMenuLines );

        b = AddItems(
                menu,
                NULL,
                &BootEntries
                );
        b |= AddItems(
                menu,
                L"The following boot entries are marked active, but are not in the boot order list:",
                &ActiveUnorderedBootEntries
                );
        b |= AddItems(
                menu,
                L"The following boot entries are marked inactive, and are not in the boot order list:",
                &InactiveUnorderedBootEntries
                );

        if ( !b ) {
    
            swprintf( line, L"No boot entries to display" );
            SpMnAddItem(
                menu,
                line,
                4,
                (ULONG)wcslen( line ),
                TRUE,
                (ULONG_PTR)NULL
                );
            currentBootEntry = NULL;
        }
    
        DisplayMainMenuKeys( );

        SpMnDisplay(
            menu,
            (ULONG_PTR)currentBootEntry,
            validKeys,
            &pressedKey,
            (ULONG_PTR *)&bootEntry
            );
    
        SpMnDestroy( menu );

        if ( (pressedKey == 'Q') || (pressedKey == VK_ESCAPE) ) {
            if ( changesMade ) {
                if ( PromptToSaveChanges( ) ) {
                    ClearMenuArea( );
                    SaveChanges( NULL );
                }
            }
            break;
        }

        if ( bootEntry != NULL ) {

            currentBootEntry = bootEntry;

            if ( bootEntry->ListHead == &BootEntries ) {
            
                if ( (pressedKey == 'U') || (pressedKey == VK_PRIOR) ) {
    
                    listEntry2 = bootEntry->ListEntry.Blink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( listEntry2, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'D') || (pressedKey == VK_NEXT) ) {
    
                    listEntry2 = bootEntry->ListEntry.Flink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertHeadList( listEntry2, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'T') || (pressedKey == VK_HOME) ) {
    
                    listEntry2 = bootEntry->ListEntry.Blink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertHeadList( &BootEntries, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
            
                } else if ( (pressedKey == 'B') || (pressedKey == VK_END) ) {
    
                    listEntry2 = bootEntry->ListEntry.Flink;
                    if ( listEntry2 != &BootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &BootEntries, &bootEntry->ListEntry );
                        changesMade = TRUE;
                    }
                    continue;
                }
        
            }

            if ( (pressedKey == 'X') || (pressedKey == VK_DELETE) ) {

                MBE_SET_DELETED( bootEntry );
                listEntry2 = bootEntry->ListEntry.Flink;
                currentBootEntry = CONTAINING_RECORD( listEntry2, MY_BOOT_ENTRY, ListEntry );
                if ( listEntry2 == bootEntry->ListHead ) {
                    listEntry2 = bootEntry->ListEntry.Blink;
                    currentBootEntry = CONTAINING_RECORD( listEntry2, MY_BOOT_ENTRY, ListEntry );
                    if ( listEntry2 == bootEntry->ListHead ) {
                        currentBootEntry = NULL;
                    }
                }
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &DeletedBootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &DeletedBootEntries;
                changesMade = TRUE;

            } else if ( (pressedKey == 'E') || (pressedKey == VK_RETURN) ) {

                EditBootEntry( bootEntry, &changesMade );

            } else if ( pressedKey == 'M' ) {

                EditTimeout( &changesMade );

            } else if ( pressedKey == 'S' ) {

                if ( changesMade ) {
                    ClearMenuArea( );
                    currentBootEntry = SaveChanges( currentBootEntry );
                    changesMade = FALSE;
                }

            } else if ( pressedKey == 'A' ) {

                if ( MBE_IS_ACTIVE( bootEntry ) ) {

                    MBE_CLEAR_ACTIVE( bootEntry );
                    MBE_SET_MODIFIED( bootEntry );
                    if ( bootEntry->ListHead == &ActiveUnorderedBootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &InactiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &InactiveUnorderedBootEntries;
                    }

                } else {

                    MBE_SET_ACTIVE( bootEntry );
                    MBE_SET_MODIFIED( bootEntry );
                    if ( bootEntry->ListHead == &InactiveUnorderedBootEntries ) {
                        RemoveEntryList( &bootEntry->ListEntry );
                        InsertTailList( &ActiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &ActiveUnorderedBootEntries;
                    }
                }
                changesMade = TRUE;

            } else if ( pressedKey == 'O' ) {

                RemoveEntryList( &bootEntry->ListEntry );

                if ( bootEntry->ListHead == &BootEntries ) {

                    if ( MBE_IS_ACTIVE( bootEntry ) ) {
                        InsertTailList( &ActiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &ActiveUnorderedBootEntries;
                    } else {
                        InsertTailList( &InactiveUnorderedBootEntries, &bootEntry->ListEntry );
                        bootEntry->ListHead = &InactiveUnorderedBootEntries;
                    }

                } else {

                    InsertTailList( &BootEntries, &bootEntry->ListEntry );
                    bootEntry->ListHead = &BootEntries;
                }
                changesMade = TRUE;
            }
        }
    }

} // MainMenu

BOOL
AddItems (
    PVOID Menu,
    PWSTR StaticText,
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    if ( ListHead->Flink != ListHead ) {

        if ( ARGUMENT_PRESENT(StaticText) ) {
        
            SpMnAddItem(
                Menu,
                L"",
                4,
                0,
                FALSE,
                (ULONG_PTR)NULL
                );
            SpMnAddItem(
                Menu,
                StaticText,
                4,
                (ULONG)wcslen( StaticText ),
                FALSE,
                (ULONG_PTR)NULL
                );
        }

        for ( listEntry = ListHead->Flink;
              listEntry != ListHead;
              listEntry = listEntry->Flink ) {

            PWSTR osDirectoryNtName = NULL;

            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

            if ( MBE_IS_NT( bootEntry ) ) {

                osDirectoryNtName = GetNtNameForFilePath( bootEntry->OsFilePath );
            }

            if ( osDirectoryNtName != NULL) {
                swprintf(
                    line,
                    L"%-40ws %ws",
                    bootEntry->FriendlyName,
                    osDirectoryNtName
                    );
            } else {
                swprintf(
                    line,
                    L"%ws",
                    bootEntry->FriendlyName
                    );
            }
            SpMnAddItem(
                Menu,
                line,
                6,
                (ULONG)wcslen( line ),
                TRUE,
                (ULONG_PTR)bootEntry
                );

            if ( osDirectoryNtName != NULL ) {
                MemFree( osDirectoryNtName );
            }
        }

        return TRUE;
    }

    return FALSE;

} // AddItems

VOID
EditFriendlyName (
    IN OUT PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current friendly name: %ws", BootEntry->FriendlyName );
    WriteConsoleLine( 4, 4, line, FALSE );

    swprintf( line, L"    New friendly name: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        if ( wcscmp( BootEntry->FriendlyName, line ) != 0 ) {
            FREE_IF_SEPARATE_ALLOCATION( BootEntry, FriendlyName );
            BootEntry->FriendlyNameLength = (numberRead + 1) * sizeof(WCHAR);
            BootEntry->FriendlyName = MemAlloc( BootEntry->FriendlyNameLength );
            wcscpy( BootEntry->FriendlyName, line );
            MBE_SET_MODIFIED( BootEntry );
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditFriendlyName

VOID
EditLoadOptions (
    IN OUT PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current load options: %ws", BootEntry->OsLoadOptions );
    WriteConsoleLine( 4, 4, line, FALSE );

    swprintf( line, L"    New load options: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        if ( wcscmp( BootEntry->OsLoadOptions, line ) != 0 ) {
            FREE_IF_SEPARATE_ALLOCATION( BootEntry, OsLoadOptions );
            BootEntry->OsLoadOptionsLength = (numberRead + 1) * sizeof(WCHAR);
            BootEntry->OsLoadOptions = MemAlloc( BootEntry->OsLoadOptionsLength );
            wcscpy( BootEntry->OsLoadOptions, line );
            MBE_SET_MODIFIED( BootEntry );
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditLoadOptions

VOID
EditBootEntry (
    IN PMY_BOOT_ENTRY BootEntry,
    IN OUT PBOOL ChangesMade
    )
{
    ULONG numValidKeys;
    ULONG validKeys[20];
    PVOID menu;
    ULONG pressedKey;
    ULONG_PTR itemToEdit;

    while ( TRUE ) {

        menu = SpMnCreate( 4, 4, NumberOfColumns - 4, NumberOfMenuLines );

        numValidKeys = 0;
        validKeys[numValidKeys++] = VK_ESCAPE;
        validKeys[numValidKeys++] = 'Q';
        validKeys[numValidKeys++] = VK_RETURN;
        validKeys[numValidKeys++] = 'E';

        swprintf(
            line,
            L"Friendly name: %ws",
            BootEntry->FriendlyName
            );
        SpMnAddItem(
            menu,
            line,
            4,
            (ULONG)wcslen( line ),
            TRUE,
            1
            );
        validKeys[numValidKeys++] = 'F';

        if ( MBE_IS_NT( BootEntry ) ) {
        
            swprintf(
                line,
                L"Load options: %ws",
                BootEntry->OsLoadOptions
                );
            SpMnAddItem(
                menu,
                line,
                4,
                (ULONG)wcslen( line ),
                TRUE,
                2
                );
            validKeys[numValidKeys++] = 'L';
        }
    
        validKeys[numValidKeys] = 0;

        DisplayEditMenuKeys( );

        SpMnDisplay(
            menu,
            1,
            validKeys,
            &pressedKey,
            &itemToEdit
            );
    
        SpMnDestroy( menu );

        if ( (pressedKey == 'Q') || (pressedKey == VK_ESCAPE) ) {
            break;
        }

        if ( (itemToEdit == 1) || (pressedKey == 'F') ) {
            EditFriendlyName( BootEntry, ChangesMade );
        } else if ( (itemToEdit == 2) || (pressedKey == 'L') ) {
            EditLoadOptions( BootEntry, ChangesMade );
        }
    }

    return;

} // EditBootEntry

VOID
EditTimeout (
    IN OUT PBOOL ChangesMade
    )
{
    COORD position;
    DWORD numberRead;
    ULONG timeout;
    ULONG i;
    PWSTR p;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Current timeout: %d", BootOptions->Timeout );
    WriteConsoleLine( 4, 4, line, FALSE );

again:

    swprintf( line, L"    New timeout: " );
    WriteConsoleLine( 6, 4, line, FALSE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );

    SetConsoleMode( InputHandle, OriginalInputMode );
    ReadConsole( InputHandle, line, 511, &numberRead, NULL );
    SetConsoleMode( InputHandle, 0 );

    if ( numberRead >= 2 ) {
        numberRead -= 2;
    }

    if ( numberRead != 0 ) {

        line[numberRead] = 0;

        timeout = 0;
        p = line;

        while ( *p != 0 ) {

            if ( (*p < L'0') || (*p > L'9') ) {
                swprintf( line, L"Invalid characters in number" );
                WriteConsoleLine( 8, 4, line, TRUE );
                goto again;
            }

            i = (timeout * 10) + (*p - L'0');

            if ( i < timeout ) {
                swprintf( line, L"Overflow in number %d %d", i, timeout );
                WriteConsoleLine( 8, 4, line, TRUE );
                goto again;
            }

            timeout = i;

            p++;
        }

        if ( timeout != BootOptions->Timeout ) {
            BootOptions->Timeout = timeout;
            *ChangesMade = TRUE;
        }
    }
    
    return;

} // EditTimeout

BOOL
PromptToSaveChanges (
    VOID
    )
{
    COORD position;
    ULONG keys[] = { 'Y', 'N', 0 };
    ULONG key;

    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );

    swprintf( line, L"Save changes?" );
    WriteConsoleLine( 4, 4, line, TRUE );

    position.X = (USHORT)(4 + wcslen( line ));
    position.Y = 4;
    SetConsoleCursorPosition( OutputHandle, position );

    key = SpWaitValidKey( keys, NULL );

    return (BOOL)(key == 'Y');

} // PromptToSaveChanges

VOID
ClearMenuArea (
    VOID
    )
{
    SpMnClearArea( 3, 3 + NumberOfMenuLines + 1 );
}

VOID
SetStatusLine (
    PWSTR Status
    )
{
    COORD position;

    WriteConsoleLine( 4, 4, Status, TRUE );

    position.X = (USHORT)(4 + wcslen( Status ));
    position.Y = 4;
    SetConsoleCursorPosition( OutputHandle, position );
}

VOID
SetStatusLineAndWait (
    PWSTR Status
    )
{
    ULONG keys[] = { VK_ESCAPE, VK_RETURN, VK_SPACE, 0 };

    SetStatusLine( Status );

    SpWaitValidKey( keys, NULL );
}

VOID
SetStatusLine2 (
    PWSTR Status
    )
{
    COORD position;

    WriteConsoleLine( 6, 4, Status, TRUE );

    position.X = (USHORT)(4 + wcslen( Status ));
    position.Y = 6;
    SetConsoleCursorPosition( OutputHandle, position );
}

VOID
SetStatusLine2AndWait (
    PWSTR Status
    )
{
    ULONG keys[] = { VK_ESCAPE, VK_RETURN, VK_SPACE, 0 };

    SetStatusLine2( Status );

    SpWaitValidKey( keys, NULL );
}

VOID
DisplayMainMenuKeys (
    VOID
    )
{
    ULONG startLine = 3 + 1 + NumberOfMenuLines + 1 + 1;

    SpMnClearArea( startLine, NumberOfRows - 1 );

    WriteConsoleLine(
        startLine,
        1,
        L"PGUP/U = Move up      | HOME/T = Move to top    | DELETE/X = Delete",
        FALSE
        );
    WriteConsoleLine(
        startLine + 1,
        1,
        L"PGDN/D = Move down    |  END/B = Move to bottom | RETURN/E = Edit",
        FALSE
        );

    WriteConsoleLine(
        startLine + 3,
        1,
        L"     A = [De]activate |      O = Remove from/add to boot order",
        FALSE
        );

    WriteConsoleLine(
        startLine + 5,
        1,
        L"     M = Set timeout",
        FALSE
        );

    WriteConsoleLine(
        startLine + 7,
        1,
        L" ESC/Q = Quit         |      S = Save changes",
        FALSE
        );

    return;

} // DisplayMainMenuKeys

VOID
DisplayEditMenuKeys (
    VOID
    )
{
    ULONG startLine = 3 + 1 + NumberOfMenuLines + 1 + 1 + 1;

    SpMnClearArea( startLine, NumberOfRows - 1 );

    WriteConsoleLine(
        startLine + 1,
        1,
        L" ESC/Q = Quit         |                         | RETURN/E = Edit",
        FALSE
        );

    return;

} // DisplayEditMenuKeys
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\scanlib\scan.h ===
#ifndef _SCAN_H_

#define _SCAN_H_

#if SCAN_DEBUG
extern BOOL scan_dprinton;
#endif

typedef struct _SMALL_WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    WCHAR  cAlternateFileName[ 14 ];
    WCHAR  cFileName[ 1 ];
} SMALL_WIN32_FIND_DATAW, *PSMALL_WIN32_FIND_DATAW, *LPSMALL_WIN32_FIND_DATAW;

typedef
VOID
(* PSCAN_FREE_USER_DATA_CALLBACK) (
    IN PVOID UserData
    );

typedef
DWORD
(* PSCAN_NEW_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingFileData OPTIONAL,
    IN PWIN32_FIND_DATAW NewFileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_NEW_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW ExistingDirectoryData OPTIONAL,
    IN PWIN32_FIND_DATAW NewDirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_CHECK_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW FileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_CHECK_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

typedef
DWORD
(* PSCAN_ENUM_FILE_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW FileData,
    IN PVOID *FileUserData,
    IN PVOID *ParentDirectoryUserData
    );

typedef
DWORD
(* PSCAN_ENUM_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

typedef
BOOL
(* PSCAN_RECURSE_DIRECTORY_CALLBACK) (
    IN PVOID Context,
    IN PWCH Path,
    IN PSMALL_WIN32_FIND_DATAW DirectoryData,
    IN PVOID *DirectoryUserData,
    IN PVOID *ParentDirectoryUserData OPTIONAL
    );

DWORD
ScanInitialize (
    OUT PVOID *ScanHandle,
    IN BOOL Recurse,
    IN BOOL SkipRoot,
    IN PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback OPTIONAL
    );

DWORD
ScanDirectory (
    IN PVOID ScanHandle,
    IN PWCH ScanPath,
    IN PVOID Context OPTIONAL,
    IN PSCAN_NEW_DIRECTORY_CALLBACK NewDirectoryCallback OPTIONAL,
    IN PSCAN_CHECK_DIRECTORY_CALLBACK CheckDirectoryCallback OPTIONAL,
    IN PSCAN_RECURSE_DIRECTORY_CALLBACK RecurseDirectoryCallback OPTIONAL,
    IN PSCAN_NEW_FILE_CALLBACK NewFileCallback OPTIONAL,
    IN PSCAN_CHECK_FILE_CALLBACK CheckFileCallback OPTIONAL
    );

DWORD
ScanEnumTree (
    IN PVOID ScanHandle,
    IN PVOID Context,
    IN PSCAN_ENUM_DIRECTORY_CALLBACK EnumDirectoryCallback OPTIONAL,
    IN PSCAN_ENUM_FILE_CALLBACK EnumFileCallback OPTIONAL
    );

VOID
ScanTerminate (
    IN PVOID ScanHandle
    );

DWORD
OpenAndMapFile (
    IN PWCH FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    );

DWORD
OpenAndMapFileA (
    IN PSZ FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    );

VOID
CloseMappedFile (
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID MappedBase
    );

#define SCAN_FILETYPE_TEXT          0
#define SCAN_FILETYPE_UNICODE_TEXT  1
#define SCAN_FILETYPE_BINARY        2
#define SCAN_FILETYPE_MAYBE_BINARY  3

DWORD
DataLooksBinary (
    IN PVOID MappedBase,
    IN DWORD FileSize,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    );

DWORD
FileLooksBinary (
    IN PWCH DirectoryName,
    IN PWCH FileName,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    );

#endif // _SCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\scanlib\scan.c ===
#include "precomp.h"
#pragma hdrstop

#if SCAN_DEBUG
BOOL scan_dprinton = FALSE;
#define dprintf(_x_) if (scan_dprinton) printf _x_
#else
#define dprintf(_x_)
#endif

#define FlagOn(_mask,_flag)  (((_mask) & (_flag)) != 0)
#define FlagOff(_mask,_flag) (((_mask) & (_flag)) == 0)
#define SetFlag(_mask,_flag) ((_mask) |= (_flag))
#define ClearFlag(_mask,_flag) ((_mask) &= ~(_flag))

typedef struct _CONTAINER_ENTRY {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY ContainerList;
    LIST_ENTRY ObjectList;
    struct _CONTAINER_ENTRY *Parent;
    PVOID UserData;
} CONTAINER_ENTRY, *PCONTAINER_ENTRY;

typedef struct _OBJECT_ENTRY {
    LIST_ENTRY SiblingListEntry;
    PVOID UserData;
} OBJECT_ENTRY, *POBJECT_ENTRY;

#define InitializeContainer(_container,_parent) {               \
        InitializeListHead(&(_container)->ContainerList);       \
        InitializeListHead(&(_container)->ObjectList);          \
        (_container)->Parent = (PCONTAINER_ENTRY)(_parent);     \
    }

#define InitializeObject(_object)

#define InsertContainer(_container,_subcontainer)                                           \
        InsertTailList(&(_container)->ContainerList,&(_subcontainer)->SiblingListEntry)

#define InsertObject(_container,_object)                                        \
        InsertTailList(&(_container)->ObjectList,&(_object)->SiblingListEntry)

#define RemoveObject(_object) RemoveEntryList(&(_object)->SiblingListEntry)
#define RemoveContainer(_container) RemoveEntryList(&(_container)->SiblingListEntry)

#define GetFirstObject(_container)                                      \
        ((_container)->ObjectList.Flink != &(_container)->ObjectList ?  \
            CONTAINING_RECORD( (_container)->ObjectList.Flink,          \
                               OBJECT_ENTRY,                            \
                               SiblingListEntry ) : NULL)

#define GetNextObject(_container,_object)                                   \
        ((_object)->SiblingListEntry.Flink != &(_container)->ObjectList ?   \
            CONTAINING_RECORD( (_object)->SiblingListEntry.Flink,           \
                               OBJECT_ENTRY,                                \
                               SiblingListEntry ) : NULL)

#define GetFirstContainer(_container)                                               \
        ((_container)->ContainerList.Flink != &(_container)->ContainerList ?        \
            CONTAINING_RECORD( (_container)->ContainerList.Flink,                   \
                               CONTAINER_ENTRY,                                     \
                               SiblingListEntry ) : NULL)

#define GetNextContainer(_container)                                                        \
        ((_container)->SiblingListEntry.Flink != &(_container)->Parent->ContainerList ?     \
            CONTAINING_RECORD( (_container)->SiblingListEntry.Flink,                        \
                               CONTAINER_ENTRY,                                             \
                               SiblingListEntry ) : NULL)

#define GetParent(_container) ((_container)->Parent)
#define GetParentUserData(_container) &(GetParent(_container))->UserData

typedef struct _DIRECTORY_ENTRY {
    CONTAINER_ENTRY ;
    SMALL_WIN32_FIND_DATAW FindData;
} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;

typedef struct _FILE_ENTRY {
    OBJECT_ENTRY ;
    SMALL_WIN32_FIND_DATAW FindData;
} FILE_ENTRY, *PFILE_ENTRY;

typedef struct _SCAN_PARAMETERS {
    PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback;
    BOOL Recurse;
    BOOL SkipRoot;
    DIRECTORY_ENTRY RootDirectoryEntry;
} SCAN_PARAMETERS, *PSCAN_PARAMETERS;

VOID
ScanFreeChildren (
    IN PSCAN_PARAMETERS Parameters,
    IN PCONTAINER_ENTRY Container
    );

DWORD
ScanInitialize (
    OUT PVOID *ScanHandle,
    IN BOOL Recurse,
    IN BOOL SkipRoot,
    IN PSCAN_FREE_USER_DATA_CALLBACK FreeUserDataCallback OPTIONAL
    )
{
    PSCAN_PARAMETERS params;
    DWORD size;
    DWORD error;

    params = malloc( sizeof(SCAN_PARAMETERS) );
    if ( params == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *ScanHandle = params;

    params->Recurse = Recurse;
    params->SkipRoot = SkipRoot;
    params->FreeUserDataCallback = FreeUserDataCallback;

    InitializeContainer( &params->RootDirectoryEntry, NULL );
    params->RootDirectoryEntry.UserData = NULL;
    params->RootDirectoryEntry.FindData.cFileName[0] = 0;
    
    return NO_ERROR;
}

DWORD
ScanDirectory (
    IN PVOID ScanHandle,
    IN PWCH ScanPath,
    IN PVOID Context OPTIONAL,
    IN PSCAN_NEW_DIRECTORY_CALLBACK NewDirectoryCallback OPTIONAL,
    IN PSCAN_CHECK_DIRECTORY_CALLBACK CheckDirectoryCallback OPTIONAL,
    IN PSCAN_RECURSE_DIRECTORY_CALLBACK RecurseDirectoryCallback OPTIONAL,
    IN PSCAN_NEW_FILE_CALLBACK NewFileCallback OPTIONAL,
    IN PSCAN_CHECK_FILE_CALLBACK CheckFileCallback OPTIONAL
    )
{
    BOOL ok;
    DWORD error;
    PSCAN_PARAMETERS params;
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY newDirectory;
    PFILE_ENTRY newFile;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    PVOID userData;
    WCHAR currentDirectoryName[MAX_PATH + 1];

    params = ScanHandle;
    rootDirectory = &params->RootDirectoryEntry;
    currentDirectory = rootDirectory;
    wcscpy( currentDirectoryName, ScanPath );

    do {

        wcscat( currentDirectoryName, L"\\*" );
        dprintf(( "FindFirst for %ws\n", currentDirectoryName ));
        findHandle = FindFirstFile( currentDirectoryName, &fileData );
        currentDirectoryName[wcslen(currentDirectoryName) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) &&
                     (!params->SkipRoot || (currentDirectory != rootDirectory)) ) {

                    dprintf(( "  found file %ws\\%ws\n", currentDirectoryName, fileData.cFileName ));
                    newFile = (PFILE_ENTRY)GetFirstObject( currentDirectory );
                    while ( newFile != NULL ) {
                        if ( _wcsicmp( newFile->FindData.cFileName, fileData.cFileName ) == 0 ) {
                            break;
                        }
                        newFile = (PFILE_ENTRY)GetNextObject( currentDirectory, newFile );
                    }

                    userData = NULL;
                    if ( newFile != NULL ) {
                        userData = newFile->UserData;
                    }

                    if ( ARGUMENT_PRESENT(NewFileCallback) ) {
                        error = NewFileCallback(
                                    Context,
                                    currentDirectoryName,
                                    (newFile == NULL) ? NULL : &newFile->FindData,
                                    &fileData,
                                    &userData,
                                    &currentDirectory->UserData
                                    );
                        if ( error != NO_ERROR ) {
                            FindClose( findHandle );
                            return error;
                        }
                    }

                    if ( newFile != NULL ) {

                        if ( userData != NULL ) {
                            newFile->UserData = userData;
                        } else {
                            RemoveObject( newFile );
                            free( newFile );
                        }

                    } else if ( userData != NULL ) {

                        newFile = malloc( sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                            ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR)) );
                        if ( newFile == NULL ) {
                            if ( (userData != NULL) &&
                                 (params->FreeUserDataCallback != NULL) ) {
                                params->FreeUserDataCallback( userData );
                            }
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
    
                        InitializeObject( newFile );

                        newFile->FindData.dwFileAttributes = fileData.dwFileAttributes;
                        newFile->FindData.ftCreationTime = fileData.ftCreationTime;
                        newFile->FindData.ftLastAccessTime = fileData.ftLastAccessTime;
                        newFile->FindData.ftLastWriteTime = fileData.ftLastWriteTime;
                        newFile->FindData.nFileSizeHigh = fileData.nFileSizeHigh;
                        newFile->FindData.nFileSizeLow = fileData.nFileSizeLow;
                        wcscpy( newFile->FindData.cAlternateFileName, fileData.cAlternateFileName );
                        wcscpy( newFile->FindData.cFileName, fileData.cFileName );

                        newFile->UserData = userData;

                        InsertObject( currentDirectory, newFile );
                    }

                } else if ( params->Recurse &&
                            (wcscmp(fileData.cFileName,L".") != 0) &&
                            (wcscmp(fileData.cFileName,L"..") != 0) ) {

                    dprintf(( "  found directory %ws\\%ws\n", currentDirectoryName, fileData.cFileName ));
                    newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
                    while ( newDirectory != NULL ) {
                        if ( _wcsicmp( newDirectory->FindData.cFileName, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
                    }

                    userData = NULL;
                    if ( newDirectory != NULL ) {
                        userData = newDirectory->UserData;
                    }

                    if ( ARGUMENT_PRESENT(NewDirectoryCallback) ) {
                        error = NewDirectoryCallback(
                                    Context,
                                    currentDirectoryName,
                                    (newDirectory == NULL) ? NULL : &newDirectory->FindData,
                                    &fileData,
                                    &userData,
                                    &currentDirectory->UserData
                                    );
                        if ( error != NO_ERROR ) {
                            FindClose( findHandle );
                            return error;
                        }
                    }

                    if ( newDirectory != NULL ) {

                        newDirectory->UserData = userData;

                    } else if ( userData != NULL ) {

                        newDirectory = malloc( sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                                 ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR)) );
                        if ( newDirectory == NULL ) {
                            if ( (userData != NULL) &&
                                 (params->FreeUserDataCallback != NULL) ) {
                                params->FreeUserDataCallback( userData );
                            }
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
    
                        InitializeContainer( newDirectory, currentDirectory );

                        newDirectory->FindData.dwFileAttributes = fileData.dwFileAttributes;
                        newDirectory->FindData.ftCreationTime = fileData.ftCreationTime;
                        newDirectory->FindData.ftLastAccessTime = fileData.ftLastAccessTime;
                        newDirectory->FindData.ftLastWriteTime = fileData.ftLastWriteTime;
                        newDirectory->FindData.nFileSizeHigh = fileData.nFileSizeHigh;
                        newDirectory->FindData.nFileSizeLow = fileData.nFileSizeLow;
                        wcscpy( newDirectory->FindData.cAlternateFileName, fileData.cAlternateFileName );
                        wcscpy( newDirectory->FindData.cFileName, fileData.cFileName );

                        newDirectory->UserData = userData;

                        InsertContainer( currentDirectory, newDirectory );
                    }
                }

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        if ( ARGUMENT_PRESENT(CheckFileCallback) ) {
            newFile = (PFILE_ENTRY)GetFirstObject( currentDirectory );
            while ( newFile != NULL ) {
                error = CheckFileCallback(
                            Context,
                            currentDirectoryName,
                            &newFile->FindData,
                            &newFile->UserData,
                            &currentDirectory->UserData
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
                newFile = (PFILE_ENTRY)GetNextObject( currentDirectory, newFile );
            }
        }

        newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( newDirectory != NULL ) {
            if ( !ARGUMENT_PRESENT(RecurseDirectoryCallback) ||
                 RecurseDirectoryCallback(
                    Context,
                    currentDirectoryName,
                    &newDirectory->FindData,
                    &newDirectory->UserData,
                    &currentDirectory->UserData
                    ) ) {
                break;
            }
            newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
        }

        if ( newDirectory != NULL ) {

            currentDirectory = newDirectory;
            wcscat( currentDirectoryName, L"\\" );
            wcscat( currentDirectoryName, currentDirectory->FindData.cFileName );

        } else {

            while ( TRUE ) {

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                if ( ARGUMENT_PRESENT(CheckDirectoryCallback) ) {
                    error = CheckDirectoryCallback(
                                Context,
                                currentDirectoryName,
                                &currentDirectory->FindData,
                                &currentDirectory->UserData,
                                GetParentUserData(currentDirectory)
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }
                                
                *wcsrchr(currentDirectoryName, L'\\') = 0;

                newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );

                while ( newDirectory != NULL ) {
                    if ( !ARGUMENT_PRESENT(RecurseDirectoryCallback) ||
                         RecurseDirectoryCallback(
                            Context,
                            currentDirectoryName,
                            &newDirectory->FindData,
                            &newDirectory->UserData,
                            &currentDirectory->UserData
                            ) ) {
                        break;
                    }
                    newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( newDirectory );
                }

                if ( newDirectory != NULL ) {
                    currentDirectory = newDirectory;
                    wcscat( currentDirectoryName, L"\\" );
                    wcscat( currentDirectoryName, currentDirectory->FindData.cFileName );
                    break;
                } else {
                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return ERROR_SUCCESS;
}

DWORD
ScanEnumTree (
    IN PVOID ScanHandle,
    IN PVOID Context,
    IN PSCAN_ENUM_DIRECTORY_CALLBACK EnumDirectoryCallback OPTIONAL,
    IN PSCAN_ENUM_FILE_CALLBACK EnumFileCallback OPTIONAL
    )
{
    DWORD error;
    PSCAN_PARAMETERS params;
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY directory;
    PFILE_ENTRY file;
    WCHAR relativePath[MAX_PATH + 1];

    params = ScanHandle;
    rootDirectory = (PDIRECTORY_ENTRY)&params->RootDirectoryEntry;
    currentDirectory = rootDirectory;
    relativePath[0] = 0;

    do {

        if ( ARGUMENT_PRESENT(EnumFileCallback) ) {
            file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
            while ( file != NULL ) {
                error = EnumFileCallback(
                            Context,
                            relativePath,
                            &file->FindData,
                            &file->UserData,
                            &currentDirectory->UserData
                            );
                if ( error != ERROR_SUCCESS ) {
                    dprintf(( "EnumFileCallback returned %d\n", error ));
                    return error;
                }
                file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
            }
        }

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );

        if ( directory != NULL ) {

            currentDirectory = directory;
            wcscat( relativePath, L"\\" );
            wcscat( relativePath, currentDirectory->FindData.cFileName );

        } else {

            while ( TRUE ) {

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                *wcsrchr(relativePath, L'\\') = 0;

                if ( ARGUMENT_PRESENT(EnumDirectoryCallback) ) {
                    error = EnumDirectoryCallback(
                                Context,
                                relativePath,
                                &currentDirectory->FindData,
                                &currentDirectory->UserData,
                                GetParentUserData(currentDirectory)
                                );
                    if ( error != ERROR_SUCCESS ) {
                        dprintf(( "EnumDirectoryCallback returned %d\n", error ));
                        return error;
                    }
                }

                directory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );

                if ( directory != NULL ) {

                    currentDirectory = directory;
                    wcscat( relativePath, L"\\" );
                    wcscat( relativePath, currentDirectory->FindData.cFileName );
                    break;

                } else {

                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return ERROR_SUCCESS;
}

VOID
ScanTerminate (
    IN PVOID ScanHandle
    )
{
    PSCAN_PARAMETERS params;

    params = ScanHandle;

    ScanFreeChildren( params, (PCONTAINER_ENTRY)&params->RootDirectoryEntry );
    if ( (params->RootDirectoryEntry.UserData != NULL) &&
         (params->FreeUserDataCallback != NULL) ) {
        params->FreeUserDataCallback( params->RootDirectoryEntry.UserData );
    }
    free( params );

    return;
}

VOID
ScanFreeChildren (
    IN PSCAN_PARAMETERS Parameters,
    IN PCONTAINER_ENTRY RootContainer
    )
{
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    PCONTAINER_ENTRY parent;
    POBJECT_ENTRY object;
#if SCAN_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

#if SCAN_DEBUG
#define CONTAINER_NAME(_container) ((PDIRECTORY_ENTRY)(_container))->FindData.cFileName
#define OBJECT_NAME(_object) ((PFILE_ENTRY)(_object))->FindData.cFileName

    currentPath[0] = 0;
#endif

    currentContainer = RootContainer;

    do {

        object = GetFirstObject( currentContainer );
        while ( object != NULL ) {
#if SCAN_DEBUG
            dprintf(( "Deleting entry for object %ws\\%ws\n", currentPath, OBJECT_NAME(object) ));
#endif
            RemoveObject( object );
            if ( (object->UserData != NULL) &&
                 (Parameters->FreeUserDataCallback != NULL) ) {
                Parameters->FreeUserDataCallback( object->UserData );
            }
            free( object );
            object = GetFirstObject( currentContainer );
        }

        container = GetFirstContainer( currentContainer );
        if ( container != NULL ) {
            currentContainer = container;
#if SCAN_DEBUG
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, CONTAINER_NAME(currentContainer) );
#endif
        } else {
            while ( TRUE ) {
                if ( currentContainer == RootContainer ) {
                    currentContainer = NULL;
                    break;
                }
#if SCAN_DEBUG
                dprintf(( "Deleting entry for container %ws\n", currentPath ));
                *wcsrchr(currentPath, L'\\') = 0;
#endif

                parent = GetParent( currentContainer );
                RemoveContainer( currentContainer );
                if ( (currentContainer->UserData != NULL) &&
                     (Parameters->FreeUserDataCallback != NULL) ) {
                    Parameters->FreeUserDataCallback( currentContainer->UserData );
                }
                free( currentContainer );

                currentContainer = GetFirstContainer( parent );
                if ( currentContainer != NULL ) {
#if SCAN_DEBUG
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, CONTAINER_NAME(currentContainer) );
#endif
                    break;
                } else {
                    currentContainer = parent;
                }
            }
        }

    } while ( currentContainer != NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ethstat\ethstat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ethstat.c

Abstract:

    This module displays counters for ethernet devices.

Author:

    Rod Gamache (rodga) 26-Apr-1995

Revision History:

--*/




#include "ethstat.h"


DEVICE DeviceList[MAX_NIC] = {0};

NTSTATUS
NetStatsClose(
    VOID
    );

NTSTATUS
NetStatsInit(
    OUT LONG *NumberNetCards
    );

NTSTATUS
NetStatsReadSample(
    PNET_SAMPLE_STATISTICS PNetSampleStatistics
    );

//
// The following warning being disabled and the conversions into High and Low
// below are all hacks to get around the fact that we cannot easily print out
// LONGLONGs in the present versions of Windows NT - except for Alpha. This
// should be fixed later, but the code should probably not change for a long
// time, so that we can continue to build and use it on older versions of
// Windows NT.
//

#pragma warning(disable:4244)               // skip warnings about loss of data


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    NET_SAMPLE_STATISTICS NetSampleStatistics[MAX_NIC];
    PDEVICE device;
    ULONG NumberNetCards;
    ULONG i;
    ULONG High;
    ULONG Low;
    ULONG Div = 1000000000;
    ULONGLONG Number;
    ULONGLONG Number2;
    ULONGLONG Number3;


    //
    // Determine the number of net cards in the system and do an open
    // on the driver.
    //
    NumberNetCards = 0;
    NetStatsInit(&NumberNetCards);

    NetStatsReadSample( NetSampleStatistics );

    device = &DeviceList[0];

    for (i = 0; i < NumberNetCards; i++) {
        printf("\n\nCounters for Network Card: %s\n\n", device->DeviceName);
        Number = NetSampleStatistics[i].OidGenDirectedFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Frames Received:              %0.0u%u\n", High, Low);
        Number = NetSampleStatistics[i].OidGenMulticastFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Frames Received:    %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastFramesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Frames Received:    %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Frames Transmitted:           %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Frames Transmitted: %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastFramesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Frames Transmitted: %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Bytes Received:               %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Bytes Received:     %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastBytesRcv;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Bytes Received:     %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        Number3 = NetSampleStatistics[i].OidGenDirectedFramesRcv;
        Number = Number2 / Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Per Receive Frame:      %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Bytes Transmitted:            %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMulticastBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Multicast Bytes Transmitted:  %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenBroadcastBytesXmit;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Broadcast Bytes Transmitted:  %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        Number3 = NetSampleStatistics[i].OidGenDirectedFramesXmit;
        Number = Number2 / Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Per Transmit Frame:     %0.0u%u\n", High, Low);

        Number2 = NetSampleStatistics[i].OidGenDirectedBytesRcv;
        Number3 = NetSampleStatistics[i].OidGenDirectedBytesXmit;
        Number = Number2 + Number3;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number2 != -1 && Number3 != -1 ) printf("Bytes Total (xmt + rcv):      %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenMediaInUse;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Media In Use:                 %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenLinkSpeed;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Link Speed:                   %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenXmitError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Errors:              %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Errors:               %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvNoBuffer;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive No Buffer Avail:      %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].OidGenRcvCrcError;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive CRC Errors:           %0.0u%u\n\n", High, Low);

        Number = NetSampleStatistics[i].OidGenTransmitQueueLength;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Queue Length:        %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3RcvErrorAlignment;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Error Alignment:      %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitOneCollision;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit One Collision:       %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitMoreCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Multiple Collisions: %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitDeferred;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmits Deferred:           %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitMaxCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmits Max Collisions:     %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3RcvOverRun;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Receive Over Runs:            %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitUnderRun;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Under Runs:          %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitTimesCrsLost;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Carrier Lost:        %0.0u%u\n", High, Low);

        Number = NetSampleStatistics[i].Oid802_3XmitLateCollisions;
        High = (ULONG) (Number / Div);
        Low = (ULONG) (Number % Div);
        if ( Number != -1 ) printf("Transmit Late Collisions:     %0.0u%u\n\n\n", High, Low);

        device += 1;
    }

    NetStatsClose();

    return 0;

}   // end of main
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ethstat\ethstat.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ethstat.h

Abstract:


Author: Rod Gamache (rodga)


Revision History:

--*/

#ifndef _ETHSTAT_
#define _ETHSTAT_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <memory.h>
#include <string.h>
#include <ctype.h>
#include <ntddndis.h>



#define MAX_NIC 8


typedef struct {
    char DeviceName[64];
    HANDLE Handle;
} DEVICE, *PDEVICE;


typedef struct _NET_SAMPLE_STATISTICS {
    ULONGLONG OidGenMediaInUse;
    ULONGLONG OidGenLinkSpeed;
    ULONGLONG OidGenXmitError;
    ULONGLONG OidGenRcvError;
    ULONGLONG OidGenRcvNoBuffer;
    ULONGLONG OidGenDirectedBytesXmit;
    ULONGLONG OidGenDirectedFramesXmit;
    ULONGLONG OidGenDirectedBytesRcv;
    ULONGLONG OidGenDirectedFramesRcv;
    ULONGLONG OidGenMulticastBytesXmit;
    ULONGLONG OidGenMulticastFramesXmit;
    ULONGLONG OidGenBroadcastBytesXmit;
    ULONGLONG OidGenBroadcastFramesXmit;
    ULONGLONG OidGenMulticastBytesRcv;
    ULONGLONG OidGenMulticastFramesRcv;
    ULONGLONG OidGenBroadcastBytesRcv;
    ULONGLONG OidGenBroadcastFramesRcv;
    ULONGLONG OidGenRcvCrcError;
    ULONGLONG OidGenTransmitQueueLength;
    ULONGLONG Oid802_3RcvErrorAlignment;
    ULONGLONG Oid802_3XmitOneCollision;
    ULONGLONG Oid802_3XmitMoreCollisions;
    ULONGLONG Oid802_3XmitDeferred;
    ULONGLONG Oid802_3XmitMaxCollisions;
    ULONGLONG Oid802_3RcvOverRun;
    ULONGLONG Oid802_3XmitUnderRun;
    ULONGLONG Oid802_3XmitTimesCrsLost;
    ULONGLONG Oid802_3XmitLateCollisions;
} NET_SAMPLE_STATISTICS, *PNET_SAMPLE_STATISTICS;



extern char *NetworkMedium[];


#endif // _ETHSTAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\emptydirs\scanlib\utils.c ===
#include "precomp.h"
#pragma hdrstop

DWORD
pOpenAndMapFile (
    IN PVOID FileName,
    IN BOOL NameIsUnicode,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    BOOL ok;
    DWORD error;
    LARGE_INTEGER Zero;

    *MappingHandle = NULL;
    *MappedBase = NULL;

    if ( NameIsUnicode ) {
        *FileHandle = CreateFile(
                        FileName,
                        DesiredAccess,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    } else {
        *FileHandle = CreateFileA(
                        FileName,
                        DesiredAccess,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    }
    if ( *FileHandle == INVALID_HANDLE_VALUE ) {
        error = GetLastError( );
        goto cleanup;
    }

    Zero.QuadPart = 0;
    ok = SetFilePointerEx( *FileHandle, Zero, Size, FILE_END );
    if ( !ok ) {
        error = GetLastError( );
        goto cleanup;
    }
    if ( Size->QuadPart == 0 ) {
        error = NO_ERROR;
        goto cleanup;
    }

    *MappingHandle = CreateFileMapping(
                        *FileHandle,
                        NULL,
                        (DesiredAccess == GENERIC_READ) ? PAGE_READONLY : PAGE_READWRITE,
                        Size->HighPart,
                        Size->LowPart,
                        NULL
                        );
    if ( *MappingHandle == NULL ) {
        error = GetLastError( );
        goto cleanup;
    }

    *MappedBase = MapViewOfFile(
                    *MappingHandle,
                    (DesiredAccess == GENERIC_READ) ? FILE_MAP_READ : (FILE_MAP_READ | FILE_MAP_WRITE),
                    0,
                    0,
                    Size->LowPart
                    );
    if ( *MappedBase == NULL ) {
        error = GetLastError( );
        goto cleanup;
    }

    return NO_ERROR;

cleanup:

    if ( *MappedBase != NULL ) {
        UnmapViewOfFile( *MappedBase );
        *MappedBase = NULL;
    }
    if ( *MappingHandle != NULL ) {
        CloseHandle( *MappingHandle );
        *MappingHandle = NULL;
    }
    if ( *FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( *FileHandle );
        *FileHandle = INVALID_HANDLE_VALUE;
    }

    return error;
}

DWORD
OpenAndMapFile (
    IN PWCH FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    return pOpenAndMapFile(
                FileName,
                TRUE,
                DesiredAccess,
                FileHandle,
                Size,
                MappingHandle,
                MappedBase
                );
}

DWORD
OpenAndMapFileA (
    IN PSZ FileName,
    IN DWORD DesiredAccess,
    OUT PHANDLE FileHandle,
    OUT PLARGE_INTEGER Size,
    OUT PHANDLE MappingHandle,
    OUT PVOID *MappedBase
    )
{
    return pOpenAndMapFile(
                FileName,
                FALSE,
                DesiredAccess,
                FileHandle,
                Size,
                MappingHandle,
                MappedBase
                );
}

VOID
CloseMappedFile (
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID MappedBase
    )
{
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        if ( MappedBase != NULL ) {
            UnmapViewOfFile( MappedBase );
        }
        if ( MappingHandle != NULL ) {
            CloseHandle( MappingHandle );
        }
        CloseHandle( FileHandle );
    }

    return;
}

DWORD
DataLooksBinary (
    IN PVOID MappedBase,
    IN DWORD FileSize,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    )
{
    DWORD nBytes;
    DWORD nBinary;
    DWORD offset;
    DWORD i;
    PUCHAR p;
    UCHAR c;
    DWORD previousBinary;
    BOOL anyBinaryFound;

    if ( IsTextUnicode( MappedBase, FileSize < 512 ? FileSize : 512, NULL ) ) {
        return SCAN_FILETYPE_UNICODE_TEXT;
    }

    anyBinaryFound = FALSE;

    for ( offset = 0;
          offset < FileSize;
          offset += nBytes ) {
    
        previousBinary = MAXULONG;
        nBinary = 0;

        nBytes = 512;
        if ( offset + nBytes > FileSize ) {
            nBytes = FileSize - offset;
        }

        for ( i = 0, p = (PUCHAR)MappedBase + offset;
              i < nBytes;
              i++, p++ ) {
    
            c = *p;
            switch ( c ) {
            
            case '\a':  // ignore all BELL for this test
            case '\b':  //            BS
            case '\f':  //            FF
            case '\n':  //            LF
            case '\r':  //            CR
            case '\t':  //            tab
            case '\v':  //            VT
            case 0x1A:  //            ^Z
                break;
    
            default:
                if ( (c < ' ') || (c > '~') ) {   // worry about DBCS?
                    nBinary++;
                    if ( previousBinary == MAXULONG ) {
                        if ( ARGUMENT_PRESENT(BinaryData) ) {
                            *BinaryData = c;
                        }
                        if ( ARGUMENT_PRESENT(BinaryDataOffset) ) {
                            *BinaryDataOffset = offset + i;
                        }
                        previousBinary = c;
                    }
                }
                break;
            }
        }

        if ( nBinary != 0 ) {
            anyBinaryFound = TRUE;
            if ( nBinary > (nBytes / 5) ) {
                return SCAN_FILETYPE_BINARY;
            }
        }
    }

    if ( anyBinaryFound ) {
        return SCAN_FILETYPE_MAYBE_BINARY;
    }
    return SCAN_FILETYPE_TEXT;

} // DataLooksBinary

DWORD
FileLooksBinary (
    PWCH DirectoryName,
    PWCH FileName,
    OUT PUCHAR BinaryData OPTIONAL,
    OUT PDWORD BinaryDataOffset OPTIONAL
    )
{
    DWORD error;
    LARGE_INTEGER size;
    HANDLE fileHandle;
    HANDLE mappingHandle;
    PVOID mappedBase;
    WCHAR fullName[MAX_PATH+1];
    DWORD i;

    wcscpy( fullName, DirectoryName );
    wcscat( fullName, L"\\" );
    wcscat( fullName, FileName );

    error = OpenAndMapFile (
                fullName,
                GENERIC_READ,
                &fileHandle,
                &size,
                &mappingHandle,
                &mappedBase
                );
    if ( error != NO_ERROR ) {
        return SCAN_FILETYPE_TEXT;
    }

    if ( size.QuadPart == 0 ) {
        return SCAN_FILETYPE_TEXT;
    }

    i = DataLooksBinary(
            mappedBase,
            size.HighPart == 0 ? size.LowPart : MAXULONG,
            BinaryData,
            BinaryDataOffset
            );

    CloseMappedFile( fileHandle, mappingHandle, mappedBase );

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\exctrdlg.h ===
// exctrdlg.h : header file
//

#define RESERVED    0L
#define  OLD_VERSION 0x010000

#define ENABLE_PERF_CTR_QUERY   0
#define ENABLE_PERF_CTR_ENABLE  1
#define ENABLE_PERF_CTR_DISABLE 2

#define SORT_ORDER_LIBRARY  1
#define SORT_ORDER_SERVICE  2
#define SORT_ORDER_ID       3

typedef struct _REG_NOTIFY_THREAD_INFO {
    HKEY    hKeyToMonitor;
    HWND    hWndToNotify;
} REG_NOTIFY_THREAD_INFO, *PREG_NOTIFY_THREAD_INFO;

/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg dialog

class CExctrlstDlg : public CDialog
{
// Construction
public:
    CExctrlstDlg(CWnd* pParent = NULL); // standard constructor
    ~CExctrlstDlg (void);               // destructor

// Dialog Data
    //{{AFX_DATA(CExctrlstDlg)
    enum { IDD = IDD_EXCTRLST_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CExctrlstDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CExctrlstDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnSelchangeExtList();
    afx_msg void OnDestroy();
    afx_msg void OnRefresh();
    afx_msg void OnAbout();
    afx_msg void OnKillfocusMachineName();
    afx_msg void OnSortButton();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnEnablePerf();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL    IndexHasString (DWORD   dwIndex);
    void    ScanForExtensibleCounters();
    void    UpdateDllInfo();
    void    UpdateSystemInfo();
    void    ResetListBox();
    void    SetSortButtons();
    DWORD   EnablePerfCounters (HKEY hKeyItem, DWORD dwNewValue);
    HKEY    hKeyMachine;
    HKEY    hKeyServices;
    TCHAR   szThisComputerName[MAX_PATH];
    TCHAR   szComputerName[MAX_PATH];
    REG_NOTIFY_THREAD_INFO  rntInfo;
    DWORD   dwSortOrder;
    BOOL    bReadWriteAccess;
    DWORD   dwRegAccessMask;
    LPWSTR  *pNameTable;
    DWORD   dwLastElement;
    DWORD   dwListBoxHorizExtent;
    DWORD   dwTabStopCount;
    DWORD   dwTabStopArray[1];
    // 0 = Last Counter ID from Reg
    // 1 = Last Counter ID from text
    // 2 = Last Help ID from reg
    // 3 = Last Help ID from text
    DWORD   dwIdArray[4];   
};
/////////////////////////////////////////////////////////////////////////////
// CAbout dialog

class CAbout : public CDialog
{
// Construction
public:
	CAbout(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAbout)
	enum { IDD = IDD_ABOUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAbout)
        virtual BOOL OnInitDialog();
        // NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ethstat\netstats.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    netstats.c

Abstract:

    This module reads the netcard statistics.

Author:

    David Orbits (davidor) 22-March-1995

Revision History:

    Rod Gamache (rodga) 10-May-1995
    Slight mods for using with Ethstat main program.

--*/



#include "ethstat.h"


NTSTATUS
ReadNetCardNames(
    IN OUT char DeviceNameString[],
    IN LONG DeviceNameLength
    );


char *OidListName[] = {
    "OID_GEN_MEDIA_IN_USE",
    "OID_GEN_LINK_SPEED",
    "OID_GEN_XMIT_ERROR",
    "OID_GEN_RCV_ERROR",
    "OID_GEN_RCV_NO_BUFFER",
    "OID_GEN_DIRECTED_BYTES_XMIT",
    "OID_GEN_DIRECTED_FRAMES_XMIT",
    "OID_GEN_DIRECTED_BYTES_RCV",
    "OID_GEN_DIRECTED_FRAMES_RCV",
    "OID_GEN_MULTICAST_BYTES_XMIT",
    "OID_GEN_MULTICAST_FRAMES_XMIT",
    "OID_GEN_BROADCAST_BYTES_XMIT",
    "OID_GEN_BROADCAST_FRAMES_XMIT",
    "OID_GEN_MULTICAST_BYTES_RCV",
    "OID_GEN_MULTICAST_FRAMES_RCV",
    "OID_GEN_BROADCAST_BYTES_RCV",
    "OID_GEN_BROADCAST_FRAMES_RCV",
    "OID_GEN_RCV_CRC_ERROR",
    "OID_GEN_TRANSMIT_QUEUE_LENGTH",
    "OID_802_3_RCV_ERROR_ALIGNMENT",
    "OID_802_3_XMIT_ONE_COLLISION",
    "OID_802_3_XMIT_MORE_COLLISIONS",
    "OID_802_3_XMIT_DEFERRED",
    "OID_802_3_XMIT_MAX_COLLISIONS",
    "OID_802_3_RCV_OVERRUN",
    "OID_802_3_XMIT_UNDERRUN",
    "OID_802_3_XMIT_TIMES_CRS_LOST",
    "OID_802_3_XMIT_LATE_COLLISIONS"
    };

NDIS_OID OidList[] = {
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_LINK_SPEED,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS
};



LONG OpenNetDevices = 0;
extern DEVICE DeviceList[MAX_NIC];





NTSTATUS
NetStatsInit(
    OUT LONG *NumberNetCards
    )
{

    PDEVICE device;
    NTSTATUS Status;
    char DeviceNameString[64];
    char FullDeviceName[256];
    LONG i;

    *NumberNetCards = 0;
    i = 0;

    Status = ReadNetCardNames(DeviceNameString, sizeof(DeviceNameString));


    if (!NT_SUCCESS(Status)) {
        printf( "NetStatsInit: No netcard devices found.\n" );
        return STATUS_UNSUCCESSFUL;
    }

    device = &DeviceList[0];

    while ( NT_SUCCESS(Status) ) {

        strcpy(device->DeviceName, DeviceNameString);

        //
        // First create a symbolic link to the driver.
        //

        strcpy( FullDeviceName, "\\Device\\" );
        strcat( FullDeviceName, DeviceNameString );

        if (!DefineDosDevice(DDD_RAW_TARGET_PATH, DeviceNameString, FullDeviceName)) {
            printf("\nNetStatsInit: DefineDosDevice (%s, %s) failed\n",
                   DeviceNameString,
                   FullDeviceName );
            return STATUS_UNSUCCESSFUL;
        }


        //
        // Next, try to open the device.
        //

        strcpy( FullDeviceName, "\\\\.\\" );
        strcat( FullDeviceName, DeviceNameString );

        device->Handle = CreateFile(FullDeviceName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

        if ( device->Handle == (HANDLE)-1 ) {
            printf("NetStatsInit: Can't get a handle to %s (%s)\n",
                    DeviceNameString,
                    FullDeviceName );
            DefineDosDevice( DDD_REMOVE_DEFINITION, DeviceNameString, NULL );
        } else {

            if (OpenNetDevices == MAX_NIC) {
                printf( "NetStatsInit: Too many netcard devices.\n" );
                printf( "NetStatsInit: Only first %d will be monitored.\n", OpenNetDevices);
                CloseHandle( device->Handle );
                DefineDosDevice( DDD_REMOVE_DEFINITION, DeviceNameString, NULL );
                break;
            }

            OpenNetDevices += 1;
            device += 1;
        }

        //
        // Get next netcard device name.
        //
        Status = ReadNetCardNames(DeviceNameString, sizeof(DeviceNameString));

    }

    *NumberNetCards = OpenNetDevices;

#ifdef debug
    printf("\nNetcard devices found -- %d\n", OpenNetDevices);
    for ( i = 0; i < OpenNetDevices; i++ ) {
        device = &DeviceList[i];
        printf("%s  ", device->DeviceName);
    }
    printf("\n\n");
#endif

    return STATUS_SUCCESS;
}



NTSTATUS
NetStatsReadSample(
    PNET_SAMPLE_STATISTICS PNetSampleStatistics
    )
{

    ULONG Status;
    PDEVICE device;
    LONG i;
    ULONG j;
    DWORD cbReturned;
    PLONGLONG PCounter;
    PNET_SAMPLE_STATISTICS PDeviceSampleStatistics = PNetSampleStatistics;

	memset(PDeviceSampleStatistics, 0, sizeof(NET_SAMPLE_STATISTICS));

    for ( i = 0; i < OpenNetDevices; i++ ) {

        device = &DeviceList[i];
        PCounter = (PLONGLONG) PDeviceSampleStatistics;

        //
        // Now loop through each of our potential OIDs.
        //
        for ( j = 0; j < sizeof(OidList)/sizeof(NDIS_OID); j++ ) {

            *PCounter = 0;
            if ( !(Status = DeviceIoControl(
                    device->Handle,
                    (DWORD)IOCTL_NDIS_QUERY_GLOBAL_STATS,
                    (PVOID)&OidList[j],
                    sizeof(NDIS_OID),
                    (PVOID)PCounter,
                    sizeof(LONGLONG),
                    &cbReturned,
                    0
                    )) ) {
#ifdef debug
                printf("DeviceIoControl Failed!, Status = 0x%lx, OID: %s\n", Status, OidListName[j]);
#endif
                *PCounter = (LONGLONG)-1;
            }
            PCounter += 1;
        }

        PDeviceSampleStatistics += 1;
    }

#ifdef debug
    printf("\n                                 ");
    for ( i = 0; i < OpenNetDevices; i++ ) {
        device = &DeviceList[i];
        printf("  %12s", device->DeviceName);
    }
    printf("\n\n");

    for ( j = 0; j < sizeof(OidList)/sizeof(NDIS_OID); j++ ) {
        printf( "%-30s:  ", OidListName[j]);
        PCounter = (PLONGLONG) PNetSampleStatistics + j;

        for ( i = 0; i < OpenNetDevices; i++ ) {
            device = &DeviceList[i];
            if (OidList[j] != OID_GEN_MEDIA_IN_USE) {
                printf("  %d", *PCounter );
            } else {
                printf("  Media in use problem\n");
            }
            (PNET_SAMPLE_STATISTICS) PCounter += 1;
        }
        printf("\n");
    }
#endif

    return STATUS_SUCCESS;

}


NTSTATUS
NetStatsClose(
    VOID
    )
{

    PDEVICE device;
    LONG i;

    for ( i = 0; i < OpenNetDevices; i++ ) {

        device = &DeviceList[i];

        if ( device->Handle != (HANDLE)-1 ) {
            CloseHandle( device->Handle );
        }

        DefineDosDevice( DDD_REMOVE_DEFINITION, device->DeviceName, NULL );

    }

    return STATUS_SUCCESS;

}



NTSTATUS
ReadNetCardNames(
    IN OUT char DeviceNameString[],
    IN LONG DeviceNameLength
    )

{
    int i;
    LONG Result;
    HKEY Key;
    DWORD Size;
    char KeyString[128];
    static LONG RegNetCardNumber = 0;

    //
    // Scan registry for installed netcards.
    //
    RegNetCardNumber++;

    while (RegNetCardNumber < 32) {

        sprintf(KeyString,
                "software\\microsoft\\windows nt\\currentversion\\networkcards\\%d",
                RegNetCardNumber);

        Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              KeyString,
                              0,
                              KEY_QUERY_VALUE,
                              &Key);

        if (Result == ERROR_SUCCESS) {
            //
            // Query out the value we are interested in
            //
            Size = DeviceNameLength;
            Result = RegQueryValueEx(Key,
                                     "ServiceName",
                                     0,
                                     NULL,
                                     (LPBYTE)DeviceNameString,
                                     &Size);
            RegCloseKey(Key);

            if (Result == ERROR_SUCCESS) {
                //printf("%s    netcard = %s\n", KeyString, DeviceNameString);
                return STATUS_SUCCESS;

            } else {
                printf("%s\n", KeyString);
                printf("reg query failed, status = %08X\n", Result);
            }

        } else {
            //printf("%s\n", KeyString);
            //printf("reg open key failed, status = %08X\n", Result);
        }

        RegNetCardNumber++;
    }

    return STATUS_UNSUCCESSFUL;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\exctrlst.cpp ===
// exctrlst.cpp : Defines the class behaviors for the application.
//

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#include "stdafx.h"
#include "exctrlst.h"
#include "exctrdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp

BEGIN_MESSAGE_MAP(CExctrlstApp, CWinApp)
    //{{AFX_MSG_MAP(CExctrlstApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp construction

CExctrlstApp::CExctrlstApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CExctrlstApp object

CExctrlstApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp initialization

BOOL CExctrlstApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    Enable3dControls();
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    CExctrlstDlg dlg;
    m_pMainWnd = &dlg;
    INT_PTR nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\exctrdlg.cpp ===
// exctrdlg.cpp : implementation file
//

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#include "stdafx.h"
#include "exctrlst.h"
#include "exctrdlg.h"
#include "tchar.h"

// string constants
// displayed strings
static const TCHAR  cszNotFound[] = {TEXT("Not Found")};
static const TCHAR  cszNA[] = {TEXT("N/A")};
// strings that are not displayed
static const WCHAR  cszDisablePerformanceCounters[] = {L"Disable Performance Counters"};
static const WCHAR  cszDefaultLangId[] = {L"009"};
static const TCHAR  cszDoubleBackslash[] = {TEXT("\\\\")};
static const TCHAR  cszSpace[] = {TEXT(" ")};
static const TCHAR  cszSplat[] = {TEXT("*")};
static const TCHAR  cszServIdFmt[] = {TEXT("%d %s")};
static const TCHAR  cszOpen[] = {TEXT("Open")};
static const TCHAR  cszCollect[] = {TEXT("Collect")};
static const TCHAR  cszClose[] = {TEXT("Close")};
static const TCHAR  cszIdFmt[] = {TEXT("0x%8.8x  (%d) %s")};
static const TCHAR  cszSortIdFmt[] = {TEXT("0x%8.8x\t%s")};
static const TCHAR  cszTab[] = {TEXT("\t")};
static const TCHAR  cszFirstCounter[] = {TEXT("First Counter")};
static const TCHAR  cszLastCounter[] = {TEXT("Last Counter")};
static const TCHAR  cszFirstHelp[] = {TEXT("First Help")};
static const TCHAR  cszLastHelp[] = {TEXT("Last Help")};
static const TCHAR  cszLibrary[] = {TEXT("Library")};
static const TCHAR  cszPerformance[] = {TEXT("\\Performance")};
static const TCHAR  cszServiceKeyName[] = {TEXT("SYSTEM\\CurrentControlSet\\Services")};
static const TCHAR  cszNamesKey[] = {TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib")};
static const TCHAR  cszSlash[] = {TEXT("\\")};
static const WCHAR  cszVersionName[] = {L"Version"};
static const WCHAR  cszCounterName[] = {L"Counter "};
static const WCHAR  cszHelpName[] = {L"Explain "};
static const WCHAR  cszCounters[] = {L"Counters"};
static const TCHAR  cszHelp[] = {TEXT("Help")};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL CExctrlstDlg::IndexHasString (
    DWORD   dwIndex
)
{
    if ((dwIndex <= dwLastElement) && (pNameTable != NULL)) {
        if (pNameTable[dwIndex] != NULL) {
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

static
LPWSTR
*BuildNameTable(
    LPCWSTR szMachineName,
    LPCWSTR lpszLangIdArg,     // unicode value of Language subkey
    PDWORD  pdwLastItem,     // size of array in elements
    PDWORD  pdwIdArray      // array for index ID's
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    HKEY    hKeyRegistry;   // handle to registry db with counter names

    LPWSTR  *lpReturnValue;
    LPCWSTR lpszLangId;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    if (szMachineName != NULL) {
        lWin32Status = RegConnectRegistryW (szMachineName,
            HKEY_LOCAL_MACHINE,
            &hKeyRegistry);
    } else {
        lWin32Status = ERROR_SUCCESS;
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    }

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangIdArg) {
        lpszLangId = cszDefaultLangId;
    } else {
        lpszLangId = lpszLangIdArg;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        cszNamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszLastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    pdwIdArray[2] = dwLastHelpId;

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszLastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }
    
    pdwIdArray[0] = dwLastId;
    
    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        cszVersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
        // reset the error status
        lWin32Status = ERROR_SUCCESS;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = (LPWSTR)HeapAlloc (GetProcessHeap(), 0,
            lstrlen(cszNamesKey) * sizeof (WCHAR) +
            lstrlen(cszSlash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));
        
        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, cszNamesKey);
        lstrcat (lpValueNameString, cszSlash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szMachineName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            lWin32Status = RegConnectRegistry (szMachineName,
                HKEY_PERFORMANCE_DATA,
                &hKeyNames);
        }
        lstrcpy (CounterNameBuffer, cszCounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, cszHelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }
    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == (DWORD)OLD_VERSION ? cszCounters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == (DWORD)OLD_VERSION ? cszHelp : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = (LPWSTR *)HeapAlloc (GetProcessHeap(), 0,dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? cszCounters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPBYTE)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? cszHelp : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPBYTE)lpHelpText,
        &dwBufferSize);
                            
    if (!lpReturnValue) {
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    pdwIdArray[1] = dwLastCounterIdUsed;

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) {
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    pdwIdArray[3] = dwLastHelpIdUsed;

    dwLastId = dwLastHelpIdUsed;
    if (dwLastId < dwLastCounterIdUsed) dwLastId = dwLastCounterIdUsed;

    if (pdwLastItem) *pdwLastItem = dwLastId;

    HeapFree (GetProcessHeap(), 0, (LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
//    if (dwSystemVersion == OLD_VERSION)
    RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        HeapFree (GetProcessHeap(), 0, (LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        HeapFree (GetProcessHeap(), 0, (LPVOID)lpReturnValue);
    }
    
    if (hKeyValue) RegCloseKey (hKeyValue);

//    if (dwSystemVersion == OLD_VERSION &&
//        hKeyNames) 
       RegCloseKey (hKeyNames);


    return NULL;
}

static
BOOL
IsMsObject(CString *pLibraryName)
{
    CString LocalLibraryName;

    LocalLibraryName = *pLibraryName;
    LocalLibraryName.MakeLower();

    // for now this just compares known DLL names. valid as of
    // NT v4.0
    if (LocalLibraryName.Find((LPCWSTR)L"perfctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"ftpctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"rasctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"winsctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"sfmctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"atkctrs.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"bhmon.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"tapictrs.dll") >= 0) return TRUE;
    // NT v5.0
    if (LocalLibraryName.Find((LPCWSTR)L"perfdisk.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfos.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfproc.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"perfnet.dll") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"winspool.drv") >= 0) return TRUE;
    if (LocalLibraryName.Find((LPCWSTR)L"tapiperf.dll") >= 0) return TRUE;

    return FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg dialog

CExctrlstDlg::CExctrlstDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CExctrlstDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CExctrlstDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    hKeyMachine = HKEY_LOCAL_MACHINE;
    hKeyServices = NULL;
    dwSortOrder = SORT_ORDER_SERVICE;
    bReadWriteAccess = TRUE;
    dwRegAccessMask = KEY_READ | KEY_WRITE;
    pNameTable = NULL;
    dwLastElement = 0;
    dwListBoxHorizExtent = 0;
    dwTabStopCount = 1;
    dwTabStopArray[0] = 85;
    memset (&dwIdArray[0], 0, sizeof(dwIdArray));
}

CExctrlstDlg::~CExctrlstDlg()
{
    if (pNameTable != NULL) {
        HeapFree (GetProcessHeap(), 0, pNameTable);
        pNameTable = NULL;
        dwLastElement = 0;
    }
}

void CExctrlstDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CExctrlstDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CExctrlstDlg, CDialog)
    //{{AFX_MSG_MAP(CExctrlstDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_LBN_SELCHANGE(IDC_EXT_LIST, OnSelchangeExtList)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
    ON_BN_CLICKED(IDC_ABOUT, OnAbout)
    ON_EN_KILLFOCUS(IDC_MACHINE_NAME, OnKillfocusMachineName)
    ON_BN_CLICKED(IDC_SORT_LIBRARY, OnSortButton)
    ON_BN_CLICKED(IDC_SORT_SERVICE, OnSortButton)
    ON_BN_CLICKED(IDC_SORT_ID, OnSortButton)
    ON_BN_CLICKED(IDC_ENABLED_BTN, OnEnablePerf)
    ON_WM_SYSCOMMAND()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CExctrlstDlg::EnablePerfCounters (HKEY hKeyItem, DWORD dwNewValue)
{
    DWORD   dwStatus;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwSize;
    DWORD   dwReturn;
    
    switch (dwNewValue) {
        case ENABLE_PERF_CTR_QUERY:
            dwType = 0;
            dwSize = sizeof (dwValue);
            dwValue = 0;
            dwStatus = RegQueryValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwSize);

            if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                switch (dwValue) {
                    case 0: dwReturn = ENABLE_PERF_CTR_ENABLE; break;
                    case 1: dwReturn = ENABLE_PERF_CTR_DISABLE; break;
                    default: dwReturn = 0; break;
                }
            } else {
                // if the value is not present, or not = 1, then the perfctrs
                // are enabled
                dwReturn = ENABLE_PERF_CTR_ENABLE;
            }
            break;

        case ENABLE_PERF_CTR_ENABLE:
            dwType = REG_DWORD;
            dwSize = sizeof (dwValue);
            dwValue = 0;
            dwStatus = RegSetValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                0L,
                dwType,
                (LPBYTE)&dwValue,
                dwSize);
            if (dwStatus == ERROR_SUCCESS) {
                dwReturn = ENABLE_PERF_CTR_ENABLE;
            } else {
                dwReturn = 0;
            }
            break;

        case ENABLE_PERF_CTR_DISABLE:
            dwType = REG_DWORD;
            dwSize = sizeof (dwValue);
            dwValue = 1;
            dwStatus = RegSetValueExW (
                hKeyItem,
                cszDisablePerformanceCounters,
                0L,
                dwType,
                (LPBYTE)&dwValue,
                dwSize);
            if (dwStatus == ERROR_SUCCESS) {
                dwReturn = ENABLE_PERF_CTR_DISABLE;
            } else {
                dwReturn = 0;
            }
            break;

        default:
            dwReturn = 0;
    }
    return dwReturn;
}

void CExctrlstDlg::ScanForExtensibleCounters ()
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex;
    TCHAR   szServiceSubKeyName[MAX_PATH];
    TCHAR   szPerfSubKeyName[MAX_PATH+20];
    TCHAR   szItemText[MAX_PATH];
    TCHAR   szListText[MAX_PATH*2];
    DWORD   dwNameSize;
    HKEY    hKeyPerformance;
    UINT_PTR nListBoxEntry;
    DWORD   dwItemSize, dwType, dwValue;
    HCURSOR hOldCursor;
    DWORD   dwThisExtent;
    HDC     hDcListBox;
    CWnd    *pCWndListBox;

    hOldCursor = ::SetCursor (LoadCursor(NULL, IDC_WAIT));

    ResetListBox();
    
    if (hKeyServices == NULL) {
        // try read/write access
        lStatus = RegOpenKeyEx (hKeyMachine,
            cszServiceKeyName,
            0L,
            dwRegAccessMask,
            &hKeyServices);
        if (lStatus != ERROR_SUCCESS) {
            // try read-only then
            dwRegAccessMask = KEY_READ;
            bReadWriteAccess = FALSE;
            lStatus = RegOpenKeyEx (hKeyMachine,
                cszServiceKeyName,
                0L,
                dwRegAccessMask,
                &hKeyServices);
            if (lStatus != ERROR_SUCCESS) {
                // display Read Only message
                AfxMessageBox (IDS_READ_ONLY);
            } else {
                // fall through with error code
                // display no access message
                AfxMessageBox (IDS_NO_ACCESS);
            }
        }
    } else {
        lStatus = ERROR_SUCCESS;
    }
        
    if (lStatus == ERROR_SUCCESS) {
        pCWndListBox = GetDlgItem (IDC_EXT_LIST);
        hDcListBox = ::GetDC (pCWndListBox->m_hWnd);
        if (hDcListBox == NULL) {
            return;
        }
        dwServiceIndex = 0;
        dwNameSize = MAX_PATH;
        while ((lEnumStatus = RegEnumKeyEx (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            lStatus = RegOpenKeyEx (
                hKeyServices,
                szPerfSubKeyName,
                0L,
                dwRegAccessMask,
                &hKeyPerformance);

            if (lStatus == ERROR_SUCCESS) {
                // look up the library name

                dwItemSize = MAX_PATH * sizeof(TCHAR);
                dwType = 0;
                lStatus = RegQueryValueEx (
                     hKeyPerformance,
                     cszLibrary,
                     NULL,
                     &dwType,
                     (LPBYTE)&szItemText[0],
                     &dwItemSize);

                if ((lStatus != ERROR_SUCCESS) ||
                    ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
                    lstrcpy (szItemText, cszNotFound);
                }

                dwItemSize = sizeof(DWORD);
                dwType = 0;
                dwValue = 0;
                lStatus = RegQueryValueEx (
                     hKeyPerformance,
                     cszFirstCounter,
                     NULL,
                     &dwType,
                     (LPBYTE)&dwValue,
                     &dwItemSize);

                if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwValue = 0;
                }

                // make the string for the list box here depending
                // on the selected sort order.

                if (dwSortOrder == SORT_ORDER_LIBRARY) {
                    lstrcpy(szListText, szItemText);
                    lstrcat(szListText, cszTab);
                    lstrcat(szListText, szServiceSubKeyName);
                } else if (dwSortOrder == SORT_ORDER_ID) {
                    _stprintf (szListText, cszSortIdFmt,
                        dwValue, szServiceSubKeyName);
                } else { // default is sort by service
                    lstrcpy(szListText, szServiceSubKeyName);
                    lstrcat(szListText, cszTab);
                    lstrcat(szListText, szItemText);
                }

                // add this name to the list box
                nListBoxEntry = SendDlgItemMessage(IDC_EXT_LIST,
                    LB_ADDSTRING, 0, (LPARAM)&szListText);                

                if (nListBoxEntry != LB_ERR) {
                    dwThisExtent = GetTabbedTextExtent (
                        hDcListBox,
                        szListText,
                        lstrlen(szListText),
                        (int)dwTabStopCount,
                        (int *)&dwTabStopArray[0]);

                    if (dwThisExtent > dwListBoxHorizExtent) {
                        dwListBoxHorizExtent = dwThisExtent;
                        SendDlgItemMessage(IDC_EXT_LIST,
                            LB_SETHORIZONTALEXTENT, 
                            (WPARAM)LOWORD(dwListBoxHorizExtent), (LPARAM)0);                
                    }
                    // save key to this entry in the registry
                    SendDlgItemMessage (IDC_EXT_LIST,
                        LB_SETITEMDATA, (WPARAM)nListBoxEntry,
                        (LPARAM)hKeyPerformance);
                } else {
                    // close the key since there's no point in
                    // keeping it open
                    RegCloseKey (hKeyPerformance);
                }
            }
            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        }
        ::ReleaseDC (pCWndListBox->m_hWnd, hDcListBox);
    }
    nListBoxEntry = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCOUNT);
    if (nListBoxEntry > 0) {
        SendDlgItemMessage (IDC_EXT_LIST, LB_SETCURSEL, 0, 0);
    }
    ::SetCursor (hOldCursor);

}

void CExctrlstDlg::UpdateSystemInfo () {
    TCHAR   szItemText[MAX_PATH];

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[0], dwIdArray[0], cszSpace);
    SetDlgItemText (IDC_LAST_COUNTER_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[1], dwIdArray[1],
        dwIdArray[1] != dwIdArray[0] ? cszSplat : cszSpace);
    SetDlgItemText (IDC_LAST_TEXT_COUNTER_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[2], dwIdArray[2], cszSpace);
    SetDlgItemText (IDC_LAST_HELP_VALUE, szItemText);

    _stprintf (szItemText, cszIdFmt, 
        dwIdArray[3], dwIdArray[3],
        dwIdArray[3] != dwIdArray[2] ? cszSplat : cszSpace);
    SetDlgItemText (IDC_LAST_TEXT_HELP_VALUE, szItemText);

}

void CExctrlstDlg::UpdateDllInfo () {
    HKEY    hKeyItem;
    TCHAR   szItemText[MAX_PATH];
    UINT_PTR nSelectedItem;
    LONG    lStatus;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwItemSize;
    BOOL    bNoIndexValues = FALSE;
    DWORD   dwEnabled;

    CString OpenProcName;
    CString LibraryName;
    
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (LoadCursor(NULL, IDC_WAIT));

    OpenProcName.Empty();
    LibraryName.Empty();
    // update the performance counter information

    nSelectedItem = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCURSEL);

    if (nSelectedItem != LB_ERR) {
        // get registry key for the selected item
        hKeyItem = (HKEY)SendDlgItemMessage (IDC_EXT_LIST, LB_GETITEMDATA,
            (WPARAM)nSelectedItem, 0);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszLibrary,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            LibraryName = szItemText;
        }
        SetDlgItemText (IDC_DLL_NAME, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszOpen,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            OpenProcName = szItemText;
        }
        SetDlgItemText (IDC_OPEN_PROC, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszCollect,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        }
        SetDlgItemText (IDC_COLLECT_PROC, szItemText);

        dwItemSize = MAX_PATH * sizeof(TCHAR);
        dwType = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszClose,
             NULL,
             &dwType,
             (LPBYTE)&szItemText[0],
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) ||
            ((dwType != REG_SZ) && dwType != REG_EXPAND_SZ)) {
            lstrcpy (szItemText, cszNotFound);
        }
        SetDlgItemText (IDC_CLOSE_PROC, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszFirstCounter,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
            bNoIndexValues = TRUE;
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_FIRST_CTR_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszLastCounter,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_LAST_CTR_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszFirstHelp,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
            bNoIndexValues = TRUE;
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_FIRST_HELP_ID, szItemText);

        dwItemSize = sizeof(DWORD);
        dwType = 0;
        dwValue = 0;
        lStatus = RegQueryValueEx (
             hKeyItem,
             cszLastHelp,
             NULL,
             &dwType,
             (LPBYTE)&dwValue,
             &dwItemSize);

        if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
            lstrcpy (szItemText, cszNotFound);
        } else {
            _stprintf (szItemText, cszServIdFmt, dwValue, IndexHasString (dwValue) ? cszSpace : cszSplat);
        }
        SetDlgItemText (IDC_LAST_HELP_ID, szItemText);

        if (bNoIndexValues) {
            // test to see if this is a "standard" i.e. Microsoft provided
            // extensible counter or simply one that hasn't been completely
            // installed
            if (IsMsObject(&LibraryName)) {
                SetDlgItemText (IDC_FIRST_HELP_ID, cszNA);
                SetDlgItemText (IDC_LAST_HELP_ID, cszNA);
                SetDlgItemText (IDC_FIRST_CTR_ID, cszNA);
                SetDlgItemText (IDC_LAST_CTR_ID, cszNA);
            }
        }

        GetDlgItem(IDC_ENABLED_BTN)->ShowWindow (bReadWriteAccess ? SW_SHOW : SW_HIDE);
        GetDlgItem(IDC_ENABLED_BTN)->EnableWindow (bReadWriteAccess);

        dwEnabled = EnablePerfCounters (hKeyItem, ENABLE_PERF_CTR_QUERY);

        if (bReadWriteAccess) {
            // then set the check box
            CheckDlgButton (IDC_ENABLED_BTN, dwEnabled == ENABLE_PERF_CTR_ENABLE ? 1 : 0);
            GetDlgItem(IDC_DISABLED_TEXT)->ShowWindow (SW_HIDE);
        } else {
            // update the text message
            GetDlgItem(IDC_DISABLED_TEXT)->ShowWindow (
                (!(dwEnabled == ENABLE_PERF_CTR_ENABLE))  ?
                    SW_SHOW : SW_HIDE);
            GetDlgItem(IDC_DISABLED_TEXT)->EnableWindow (TRUE);
        }


    }
    ::SetCursor (hOldCursor);
}

void CExctrlstDlg::ResetListBox ()
{
    INT_PTR nItemCount;
    INT nThisItem;
    HKEY    hKeyItem;
    
    nItemCount = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCOUNT);
    nThisItem = 0;
    while (nThisItem > nItemCount) {
        hKeyItem = (HKEY) SendDlgItemMessage (IDC_EXT_LIST,
            LB_GETITEMDATA, (WPARAM)nThisItem);
        RegCloseKey (hKeyItem);
        nThisItem++;
    }
    SendDlgItemMessage (IDC_EXT_LIST, LB_RESETCONTENT);
    dwListBoxHorizExtent = 0;
    SendDlgItemMessage(IDC_EXT_LIST,
        LB_SETHORIZONTALEXTENT, 
        (WPARAM)LOWORD(dwListBoxHorizExtent), (LPARAM)0);                
}

void    CExctrlstDlg::SetSortButtons()
{
    DWORD   dwBtn;
   
    switch (dwSortOrder) {
        case SORT_ORDER_LIBRARY: dwBtn = IDC_SORT_LIBRARY; break;
        case SORT_ORDER_SERVICE: dwBtn = IDC_SORT_SERVICE; break;
        case SORT_ORDER_ID:      dwBtn = IDC_SORT_ID; break;
        default:                 dwBtn = IDC_SORT_SERVICE; break;
    }

    CheckRadioButton (
        IDC_SORT_LIBRARY,
        IDC_SORT_ID,
        dwBtn);
}
/////////////////////////////////////////////////////////////////////////////
// CExctrlstDlg message handlers

BOOL CExctrlstDlg::OnInitDialog()
{
    HCURSOR hOldCursor;
    DWORD   dwLength;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    CDialog::OnInitDialog();
    CenterWindow();

    lstrcpy (szThisComputerName, cszDoubleBackslash);
    dwLength = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (&szThisComputerName[2], &dwLength);

    lstrcpy (szComputerName, szThisComputerName);

    SetDlgItemText (IDC_MACHINE_NAME, szComputerName);

    hKeyMachine = HKEY_LOCAL_MACHINE;

    pNameTable = BuildNameTable (
        szComputerName,
        cszDefaultLangId,
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

    SendDlgItemMessage (IDC_MACHINE_NAME, EM_LIMITTEXT,
        (WPARAM)MAX_COMPUTERNAME_LENGTH+2, 0);   // include 2 leading backslash

    SendDlgItemMessage (IDC_EXT_LIST, LB_SETTABSTOPS,
        (WPARAM)dwTabStopCount, (LPARAM)&dwTabStopArray[0]);

    SetSortButtons();

    ScanForExtensibleCounters(); //.checks for access to the registry

    UpdateSystemInfo();

    // set the check box to the appropriate state

    UpdateDllInfo ();   
    
    ::SetCursor(hOldCursor);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CExctrlstDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CExctrlstDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CExctrlstDlg::OnSelchangeExtList()
{
    UpdateDllInfo ();   
}

void CExctrlstDlg::OnDestroy()
{
    ResetListBox();
    CDialog::OnDestroy();
}

void CExctrlstDlg::OnAbout()
{
    CAbout dlg;
    dlg.DoModal();
}

void CExctrlstDlg::OnRefresh()
{
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    ScanForExtensibleCounters();
    if (pNameTable != NULL) {
        HeapFree (GetProcessHeap(), 0, pNameTable);
        pNameTable = NULL;
        dwLastElement = 0;
    }

    pNameTable = BuildNameTable (
        szComputerName,
        cszDefaultLangId,
        &dwLastElement,     // size of array in elements
        &dwIdArray[0]);

    UpdateSystemInfo();

    UpdateDllInfo ();
    ::SetCursor(hOldCursor);
}

void CExctrlstDlg::OnKillfocusMachineName()
{
    TCHAR   szNewMachineName[MAX_PATH];
    HKEY    hKeyNewMachine;
    LONG    lStatus;
    HCURSOR hOldCursor;

    hOldCursor = ::SetCursor (::LoadCursor (NULL, IDC_WAIT));

    GetDlgItemText (IDC_MACHINE_NAME, szNewMachineName, MAX_PATH);

    if (lstrcmpi(szComputerName, szNewMachineName) != 0) {
        // a new computer has been entered so try to connect to it
        lStatus = RegConnectRegistry (szNewMachineName,
            HKEY_LOCAL_MACHINE, &hKeyNewMachine);
        if (lStatus == ERROR_SUCCESS) {
            RegCloseKey (hKeyServices); // close the old key
            hKeyServices = NULL;        // clear it
            bReadWriteAccess = TRUE;                // reset the access variables
            dwRegAccessMask = KEY_READ | KEY_WRITE;
            RegCloseKey (hKeyMachine);  // close the old machine
            hKeyMachine = hKeyNewMachine; // update to the new machine  
            lstrcpy (szComputerName, szNewMachineName); // update the name
            OnRefresh();                // get new counters
        } else {
            SetDlgItemText (IDC_MACHINE_NAME, szComputerName);
        }
    } else {
        // the machine name has not changed
    }
    ::SetCursor (hOldCursor);
}

void CExctrlstDlg::OnSortButton()
{
    if (IsDlgButtonChecked(IDC_SORT_LIBRARY)) {
        dwSortOrder = SORT_ORDER_LIBRARY;
    } else if (IsDlgButtonChecked(IDC_SORT_SERVICE)) {
        dwSortOrder = SORT_ORDER_SERVICE;
    } else if (IsDlgButtonChecked(IDC_SORT_ID)) {
        dwSortOrder = SORT_ORDER_ID;
    }
    ScanForExtensibleCounters();
    UpdateDllInfo ();   
}

void CExctrlstDlg::OnEnablePerf()
{
    HKEY    hKeyItem;
    UINT_PTR    nSelectedItem;
    DWORD   dwNewValue;
                    
    nSelectedItem = SendDlgItemMessage (IDC_EXT_LIST, LB_GETCURSEL);

    if (nSelectedItem != LB_ERR) {
        // get registry key for the selected item
        hKeyItem = (HKEY)SendDlgItemMessage (IDC_EXT_LIST, LB_GETITEMDATA,
            (WPARAM)nSelectedItem, 0);

        // get selected perf item and the corre
        dwNewValue = IsDlgButtonChecked(IDC_ENABLED_BTN) ?
                        ENABLE_PERF_CTR_ENABLE :
                        ENABLE_PERF_CTR_DISABLE;

        if (EnablePerfCounters (hKeyItem, dwNewValue) == 0) {
            MessageBeep(0xFFFFFFFF);
            // then it failed so reset to the curent value
            dwNewValue = EnablePerfCounters (hKeyItem, ENABLE_PERF_CTR_QUERY);
            CheckDlgButton (IDC_ENABLED_BTN, dwNewValue == ENABLE_PERF_CTR_ENABLE ? 1 : 0);
        }
    }
}

void CExctrlstDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID) {
    case SC_CLOSE:
        EndDialog(IDOK);
        break;

    default:
        CDialog::OnSysCommand (nID, lParam);
        break;
    }
}
/////////////////////////////////////////////////////////////////////////////
// CAbout dialog


CAbout::CAbout(CWnd* pParent /*=NULL*/)
	: CDialog(CAbout::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAbout)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAbout)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL CAbout::OnInitDialog()
{
	CDialog::OnInitDialog();

    TCHAR buffer[512];
    TCHAR strProgram[1024];
    TCHAR strMicrosoft[1024];
    DWORD dw;
    BYTE* pVersionInfo;
    LPTSTR pVersion = NULL;
    LPTSTR pProduct = NULL;
    LPTSTR pCopyRight = NULL;

    dw = GetModuleFileName(NULL, strProgram, 1024);

    if( dw>0 ){

        dw = GetFileVersionInfoSize( strProgram, &dw );
        if( dw > 0 ){
     
            pVersionInfo = (BYTE*)malloc(dw);
            if( NULL != pVersionInfo ){
                if(GetFileVersionInfo( strProgram, 0, dw, pVersionInfo )){
                    LPDWORD lptr = NULL;
                    VerQueryValue( pVersionInfo, _T("\\VarFileInfo\\Translation"), (void**)&lptr, (UINT*)&dw );
                    if( lptr != NULL ){
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("ProductVersion") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pVersion, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("OriginalFilename") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pProduct, (UINT*)&dw );
                        _stprintf( buffer, _T("\\StringFileInfo\\%04x%04x\\%s"), LOWORD(*lptr), HIWORD(*lptr), _T("LegalCopyright") );
                        VerQueryValue( pVersionInfo, buffer, (void**)&pCopyRight, (UINT*)&dw );
                    }
                
                    if( pProduct != NULL && pVersion != NULL && pCopyRight != NULL ){
                        GetDlgItem(IDC_COPYRIGHT)->SetWindowText( pCopyRight );
                        GetDlgItem(IDC_VERSION)->SetWindowText( pVersion );
                    }
                }
                free( pVersionInfo );
            }
        }
    }

    return TRUE;
}


BEGIN_MESSAGE_MAP(CAbout, CDialog)
	//{{AFX_MSG_MAP(CAbout)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAbout message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\exctrlst.h ===
// exctrlst.h : main header file for the EXCTRLST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CExctrlstApp:
// See exctrlst.cpp for the implementation of this class
//

class CExctrlstApp : public CWinApp
{
public:
	CExctrlstApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExctrlstApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CExctrlstApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by exctrlst.rc
//
#define IDC_REFRESH                     2
#define IDD_EXCTRLST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_ABOUT                       129
#define IDC_EXT_LIST                    1001
#define IDC_MACHINE_NAME                1002
#define IDC_DLL_NAME                    1003
#define IDC_OPEN_PROC                   1004
#define IDC_COLLECT_PROC                1005
#define IDC_CLOSE_PROC                  1006
#define IDC_FIRST_CTR_ID                1007
#define IDC_LAST_CTR_ID                 1008
#define IDC_FIRST_HELP_ID               1009
#define IDC_LAST_HELP_ID                1010
#define IDC_SORT_LIBRARY                1011
#define IDC_SORT_SERVICE                1012
#define IDC_SORT_ID                     1013
#define IDC_ENABLED_BTN                 1014
#define IDC_DISABLED_TEXT               1015
#define IDC_LAST_COUNTER_CAPTION        1017
#define IDC_LAST_HELP_CAPTION           1018
#define IDC_LAST_TEXT_ID_CAPTION        1019
#define IDC_LAST_HELP_ID_CAPTION        1020
#define IDC_LAST_COUNTER_VALUE          1021
#define IDC_LAST_TEXT_COUNTER_VALUE     1022
#define IDC_LAST_HELP_VALUE             1023
#define IDC_LAST_TEXT_HELP_VALUE        1024
#define IDC_ABOUT                       1025
#define IDC_VERSION                     1026
#define IDC_COPYRIGHT                   1027
#define IDS_READ_ONLY                   59142
#define IDS_NO_ACCESS                   59143

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exctrlst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	exctrlst.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\exp\exp.c ===
/*** EXP.C - expunge deleted files deleted with the rm program ****************
*
*       Copyright (c) 1986-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  Exp command line syntax:
*
*   EXP [options] [path ...]
*
*  where the [options] are :-
*
*       /r      Recursively expunge from path specified
*       /q      Quiet mode; no extraneous messages
*       /help   spawn Qh if possible, else issue a Usage message
*
* Revision History:
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  20-Dec-1989 SB Add check for return code of 3 for qh
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 BW Add Version number. Fix usage syntax. Update copyright.
*  15-May-1989 WB Add /help
*  06-Apr-1987 BW Add copyright notice to Usage().
*  22-Jul-1986 DL Make test for flag case insensitive, add /q
*
******************************************************************************/

/* I N C L U D E    Files */

#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>

#include <string.h>


/* D E F I N E s */

#define CopyRightYrs "1987-90"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3


/* G L O B A L s */

flagType fRecurse = FALSE;
FILE *pFile;
char cd[MAX_PATH];


/*
 * Forward Function Declarations...
 */
void DoExp( char *, struct findType *, void *);
void Usage( void );

void
DoExp(p, b, dummy)
char *p;
struct findType *b;
void *dummy;
{
    if (b == NULL ||
            (_strcmpi(b->fbuf.cFileName, "deleted") && TESTFLAG(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY) &&
            strcmp(b->fbuf.cFileName, ".") && strcmp(b->fbuf.cFileName, ".."))) {
        fexpunge(p, pFile);
        if (fRecurse) {
            if (!fPathChr(*(strend(p)-1)))
                strcat(p, "\\");
            strcat(p, "*.*");
            forfile(p, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, DoExp, NULL);
        }
    }
    dummy;
}

void
Usage()
{
    printf(
"Microsoft File Expunge Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s.  All rights reserved.\n\n"
"Usage: EXP [/help] [/rq] [{dir}*]\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);

    exit( 1 );
}


__cdecl main(c, v)
int c;
char *v[];
{
    char *p;
    intptr_t iRetCode;

    pFile = stdout;
    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while( c && fSwitChr( *( p = *v ) ) ) {
        while (*++p) {
            switch (tolower(*p)) {
                case 'r':
                    fRecurse = TRUE;
                    break;
                case 'q':
                    pFile = NULL;
                    break;
                case 'h':
                    if (!_strcmpi(p, "help")) {
                        iRetCode = _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                           "exp.exe", NULL);
                        /* qh returns QH_TOPIC_NOT_FOUND and
                         *            -1 is returned when the spawn fails
                         */
                        if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                            exit(0);
                    }
                    /*
                     * else fall thru...
                     */

                default:
                    Usage();
            }
        }
        SHIFT(c,v);
    }
    if (!c) {
        rootpath(".", cd);
        DoExp(cd, NULL, NULL);
    }
    else
        while (c) {
            strcpy(cd, *v);
            DoExp(cd, NULL, NULL);
            SHIFT(c,v);
        }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\extag\extag.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       extag.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-17-96   RichardW   Created
//
//----------------------------------------------------------------------------

#define UNICODE
#include <windows.h>
#include <wchar.h>
#include <stdio.h>

WCHAR   ExportTag[] = L"Export Version";
WCHAR   DomesticTag[] = L"US/Canada Only, Not for Export";
WCHAR   OldDomesticTag[] = L"Domestic Use Only";
DWORD   DefLang = 0x04b00409;

#define BINARY_TYPE_UNKNOWN         0
#define BINARY_TYPE_CONTROLLED      1
#define BINARY_TYPE_OPEN            2
#define BINARY_TYPE_CONTROLLED_OLD  3


BOOL
CheckIfControlled(
    LPWSTR  Path,
    DWORD   Flags)
{
    PUCHAR  pData;
    DWORD   cbData;
    DWORD   Zero;
    PWSTR   Description;
    WCHAR   ValueTag[64];
    PDWORD  pdwTranslation;
    DWORD   uLen;

    cbData = GetFileVersionInfoSize( Path, &Zero );

    if ( cbData == 0 )
    {
        return( BINARY_TYPE_UNKNOWN );
    }

    pData = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cbData );

    if ( !pData )
    {
        return( BINARY_TYPE_UNKNOWN );
    }

    if ( ! GetFileVersionInfo( Path, 0, cbData, pData ) )
    {
        LocalFree( pData );
        return( BINARY_TYPE_UNKNOWN );
    }

    if(!VerQueryValue(pData, L"\\VarFileInfo\\Translation", &pdwTranslation, &uLen))
    {
        pdwTranslation = &DefLang;

        uLen = sizeof(DWORD);
    }

    swprintf( ValueTag, L"\\StringFileInfo\\%04x%04x\\FileDescription",
                LOWORD( *pdwTranslation ), HIWORD( *pdwTranslation ) );

    // L"\\StringFileInfo\\040904b0\\FileDescription",
    if (VerQueryValue(  pData,
                        ValueTag,
                        &Description,
                        &cbData ) )
    {
        if (wcsstr( Description, DomesticTag ) )
        {
            LocalFree( pData );
            return( BINARY_TYPE_CONTROLLED );
        }

        if (wcsstr( Description, OldDomesticTag ) )
        {
            LocalFree( pData );
            return( BINARY_TYPE_CONTROLLED_OLD );
        }

        if ( wcsstr( Description, ExportTag ) )
        {
            LocalFree( pData );

            return( BINARY_TYPE_OPEN );
        }

        LocalFree( pData );

        return( BINARY_TYPE_UNKNOWN );

    }

    return( BINARY_TYPE_UNKNOWN );

}

VOID
Usage( PWSTR Me )
{
    printf("%ws: usage\n", Me);
    printf("  %ws file\tCheck file for export / domestic tags\n", Me);
    printf("  %ws dir\tCheck all files in directory\n", Me);

}

int
__cdecl
wmain(
    int argc,
    WCHAR * argv[] )
{
    DWORD   Result;
    PWSTR   Path;
    WCHAR   FullPath[ MAX_PATH ];
    WCHAR   SearchPath[ MAX_PATH ];
    PWSTR   FilePart;
    DWORD   Attrs;
    WIN32_FIND_DATA Results;
    HANDLE  SearchHandle;
    DWORD   Error;
    DWORD   FileCount;
    DWORD   FileErrors;
    DWORD   FileControlled;
    DWORD   FileExport;
    DWORD   FileUntagged;


    if ( argc < 2 )
    {
        Path = TEXT(".");
    }
    else
    {
        if ((wcscmp(argv[1], L"-?") == 0) ||
            (wcscmp(argv[1], L"/?") == 0) )
        {
            Usage( argv[0] );
            return( 0 );
        }
        Path = argv[1];
    }

    //
    // Expand it:

    if( GetFullPathName(Path,
                        MAX_PATH,
                        FullPath,
                        &FilePart))
    {
        Path = FullPath;
    }

    Result = wcslen( Path );

    if ( Path[Result - 1] == '\\' )
    {
        Path[Result - 1] = '\0';
    }

    Attrs = GetFileAttributes( Path );

    if ( Attrs == (DWORD) -1 )
    {
        Attrs = 0;
    }

    if ( Attrs & FILE_ATTRIBUTE_DIRECTORY )
    {
        //
        // Yikes!
        //

        printf("Searching path %ws ...\n\n", Path );

        FileCount = 0;
        FileErrors = 0;
        FileControlled = 0;
        FileExport = 0;
        FileUntagged = 0;

        swprintf( SearchPath, TEXT("%s\\*.*"), Path );

        SearchHandle = FindFirstFile( SearchPath, &Results );

        if (SearchHandle == INVALID_HANDLE_VALUE)
        {
            return( 0 );
        }

        do
        {
            if ( Results.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                continue;
            }

            FileCount++;

            swprintf( SearchPath, TEXT("%s\\%s"), Path, Results.cFileName );

            Result = CheckIfControlled( SearchPath, 0 );

            switch ( Result )
            {
                case BINARY_TYPE_UNKNOWN :
                    Error = GetLastError();
                    if ( Error )
                    {
                        FileErrors++;
                        if ((Error == ERROR_RESOURCE_DATA_NOT_FOUND) ||
                            (Error == ERROR_RESOURCE_TYPE_NOT_FOUND) )
                        {
                            printf( "File %ws:  expected resource data not found\n", SearchPath );
                        }
                        else
                        {
                            printf( "Error %d while accessing %ws\n", Error, SearchPath );
                        }

                    }
                    else
                    {
                        FileUntagged++;
                    }
                    break;

                case BINARY_TYPE_CONTROLLED:
                    printf("%ws is DOMESTIC USE ONLY\n", SearchPath );
                    FileControlled++;
                    break;

                case BINARY_TYPE_CONTROLLED_OLD:
                    printf("%ws is DOMESTIC USE ONLY (Old Style Tag)\n", SearchPath );
                    FileControlled++;
                    break;

                case BINARY_TYPE_OPEN:
                    FileExport++;
                    printf("%ws tagged as okay for export\n", SearchPath );
                    break;

            }

        } while ( FindNextFile( SearchHandle, &Results ) );

        FindClose( SearchHandle );

        //
        // Dump Stats:
        //

        printf("\n%d files scanned in directory %ws\n", FileCount, Path );
        printf("  %5d file(s) were tagged as export controlled\n", FileControlled );
        printf("  %5d file(s) were tagged as okay for export\n", FileExport);
        printf("  %5d file(s) were not tagged\n", FileUntagged );
        if ( FileErrors )
        {
            printf("  %5d files(s) could not be checked due to errors\n", FileErrors );
        }

    }
    else
    {

        Result = CheckIfControlled( Path, 0 ) ;

        switch ( Result )
        {
            case BINARY_TYPE_UNKNOWN :
                Error = GetLastError();
                if ( Error )
                {
                    if ((Error == ERROR_RESOURCE_DATA_NOT_FOUND) ||
                        (Error == ERROR_RESOURCE_TYPE_NOT_FOUND) )
                    {
                        printf( "File %ws:  expected resource data not found\n", Path );
                    }
                    else
                    {
                        printf( "Error %d while accessing %ws\n", Error, Path );
                    }
                }
                else
                {
                    printf("Image untagged\n");
                }
                break;

            case BINARY_TYPE_CONTROLLED:
                printf("%ws is DOMESTIC USE ONLY\n", Path );
                break;

            case BINARY_TYPE_CONTROLLED_OLD:
                printf("%ws is DOMESTIC USE ONLY (Old Style Tag)\n", Path );
                break;

            case BINARY_TYPE_OPEN:
                printf("%ws is okay for export\n", Path );
                break;

        }
    }

    return( Result );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fcom\fcom.c ===
/* fcom.c - file compare
 *
 *  4/30/86  daniel lipkie  LineCompare, at end, if NOT Same then error
 *  5/01/86  daniel lipkie  SYM files treaded as binary
 *                           if (quiet mode) then exit(1) on FIRST difference
 *  27-May-1986 mz          Make line arrays dynamically allocated at read
 *                          time.
 *                          Make default size be 300 lines.
 *  05-Aug-1986 DANL        MAX default line size 255
 *  10-Feb-1987 mz          Make /m imply /t
 *  10-Jun-1987 danl        fill -> fillbuf
 *  09-Nov-1987 mz          Fix 0D0D0A bug
 *                          Fix different at line 2 bug
 *  25-Nov-1987 mz          All errors to stderr
 *  30-Nov-1987 mz          Resync fails dumps entire file
 *  21-Jul-1988 bw          Don't GP fault on empty test files
 *  06-Aug-1990 davegi      Changed Move to memmove (OS/2 2.0)
 *
 *  Fcom compares two files in either a line-by-line mode or in a strict
 *  byte-by-byte mode.
 *
 *  The byte-by-byte mode is simple; merely read both files and print the
 *  offsets where they differ and the contents.
 *
 *  The line compare mode attempts to isolate differences in ranges of lines.
 *  Two buffers of lines are read and compared.  No hashing of lines needs
 *  to be done; hashing only speedily tells you when things are different,
 *  not the same.  Most files run through this are expected to be largely
 *  the same.  Thus, hashing buys nothing.
 *
 *  [0]     Fill buffers
 *  [1]     If both buffers are empty then
 *  [1.1]       Done
 *  [2]     Adjust buffers so 1st differing lines are at top.
 *  [3]     If buffers are empty then
 *  [3.1]       Goto [0]
 *
 *  This is the difficult part.  We assume that there is a sequence of inserts,
 *  deletes and replacements that will bring the buffers back into alignment.
 *
 *  [4]     xd = yd = FALSE
 *  [5]     xc = yc = 1
 *  [6]     xp = yp = 1
 *  [7]     If buffer1[xc] and buffer2[yp] begin a "sync" range then
 *  [7.1]       Output lines 1 through xc-1 in buffer 1
 *  [7.2]       Output lines 1 through yp-1 in buffer 2
 *  [7.3]       Adjust buffer 1 so line xc is at beginning
 *  [7.4]       Adjust buffer 2 so line yp is at beginning
 *  [7.5]       Goto [0]
 *  [8]     If buffer1[xp] and buffer2[yc] begin a "sync" range then
 *  [8.1]       Output lines 1 through xp-1 in buffer 1
 *  [8.2]       Output lines 1 through yc-1 in buffer 2
 *  [8.3]       Adjust buffer 1 so line xp is at beginning
 *  [8.4]       Adjust buffer 2 so line yc is at beginning
 *  [8.5]       Goto [0]
 *  [9]     xp = xp + 1
 *  [10]    if xp > xc then
 *  [10.1]      xp = 1
 *  [10.2]      xc = xc + 1
 *  [10.3]      if xc > number of lines in buffer 1 then
 *  [10.4]          xc = number of lines
 *  [10.5]          xd = TRUE
 *  [11]    if yp > yc then
 *  [11.1]      yp = 1
 *  [11.2]      yc = yc + 1
 *  [11.3]      if yc > number of lines in buffer 2 then
 *  [11.4]          yc = number of lines
 *  [11.5]          yd = TRUE
 *  [12]    if not xd or not yd then
 *  [12.1]      goto [6]
 *
 *  At this point there is no possible match between the buffers.  For
 *  simplicity, we punt.
 *
 *  [13]    Display error message.
 *
 *  Certain flags may be set to modify the behavior of the comparison:
 *
 *  -a      abbreviated output.  Rather than displaying all of the modified
 *          ranges, just display the beginning, ... and the ending difference
 *  -b      compare the files in binary (or byte-by-byte) mode.  This mode is
 *          default on .EXE, .OBJ, .SYM, .LIB, .COM, .BIN, and .SYS files
 *  -c      ignore case on compare (cmp = strcmpi instead of strcmp)
 *  -l      compare files in line-by-line mode
 *  -lb n   set the size of the internal line buffer to n lines from default
 *          of 300
 *  -m      merge the input files into one for output.  Use extention to
 *          indicate what kind of separators to use.
 *  -n      output the line number also
 *  -NNNN   set the number of lines to resynchronize to NNNN which defaults
 *          to 2
 *  -w      ignore blank lines and white space (ignore len 0, use strcmps)
 *  -t      do not untabify (use fgets instead of fgetl)
 */

#include <malloc.h>

#include <stdio.h>
#include <string.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>


int ctSync  =   -1;                     /* number of lines required to sync  */
int cLine = -1;                         /* number of lines in internal buffs */
flagType fAbbrev = FALSE;               /* abbreviated output                */
flagType fBinary = FALSE;               /* binary comparison                 */
flagType fLine   = FALSE;               /* line comparison                   */
flagType fNumb   = FALSE;               /* display line numbers              */
flagType fCase   = TRUE;                /* case is significant               */
flagType fIgnore = FALSE;               /* ignore spaces and blank lines     */
flagType fQuiet  = FALSE;               /* TRUE => no messages output        */
flagType fMerge  = FALSE;               /* TRUE => merge files onto stdout   */

int debug;
#define D_COMP      0x0001
#define D_CCALL     0x0002
#define D_RESYNC    0x0004
#define D_CALL      0x0008
#define D_SYNC      0x0010

struct lineType {
    int     line;                       /* line number                       */
    char    *text;                      /* body of line                      */
};

struct lineType *buffer1, *buffer2;

/*
 * Forward Function Declarations
 */
void usage( char *, int );
int fillbuf( struct lineType *, FILE *, int, int * );
flagType compare( int, int, int, register int, register int);
int BinaryCompare( char *, char * );
void pline(struct lineType *);
void dump(struct lineType *, int, int);
int adjust (struct lineType *, int, int);
void LineCompare (char *, char *);

char * (__cdecl *funcRead) (char *, int, FILE *);
					/* function to use to read lines */

int (__cdecl *fCmp)(const char *, const char *);
					/* function to use to compare lines */

char line[MAXLINELEN];                  /* single line buffer                */

char *extBin[]  = { ".EXE", ".OBJ", ".SYM", ".LIB", ".COM", ".BIN",
                    ".SYS", NULL };


void
usage (p, erc)
char *p;
int erc;
{
    if (!fQuiet) {
        if (p)
            fprintf (stderr, "fcom: %s\n", p);
        else
            fprintf (stderr, "usage: fcom [/a] [/b] [/c] [/l] [/lb n] [/m] [/n] [/NNNN] [/w] [/t] file1 file2\n");
        }
    exit(erc);
}

/*  return number of lines read in
 *
 *  pl          line buffer to fill
 *  fh          handle to read
 *  ct          max number to read
 *  plnum       line number counter to use
 *
 *  returns     number of lines read
 */
int fillbuf( struct lineType *pl, FILE *fh, int ct, int *plnum )
{
    char *line;
    int i, l;

    if ((line = malloc (MAXLINELEN)) == NULL)
        usage ("out of memory", 2);

    if (TESTFLAG (debug, D_CALL))
        printf ("fillbuf  (%p, %p, %d)\n", pl, fh, ct);
    i = 0;
    while (ct-- && (*funcRead) (line, MAXLINELEN, fh) != NULL) {
        if (pl->text != NULL)
            free (pl->text);
        l = strlen (line);
        if ((pl->text = malloc (l+1)) == NULL)
            usage ("out of memory", 2);
// djg  Move ((char far *)line, (char far *) (pl->text), l+1);
        memmove ((char *) (pl->text), (char *)line, l+1);
	if (funcRead == fgets)
            pl->text[l-2] = 0;
        if (fIgnore && !strcmps (pl->text, ""))
            pl->text[0] = 0;
        if (l != 0 || !fIgnore) {
            pl->line = ++*plnum;
            pl++;
            i++;
            }
        }
    if (TESTFLAG (debug, D_CALL))
        printf ("fillbuf  returns %d\n", i);
    free (line);
    return i;
}

/*  compare a range of lines
 *
 *  l1, l2      number of lines in each line buffer
 *  s1, s2      beginning location in each buffer to begin compare
 *  ct          number of contiguous lines to compare
 */
flagType compare (l1, s1, l2, s2, ct)
int l1, l2, ct;
register int s1, s2;
{
    if (TESTFLAG (debug, D_CCALL))
        printf ("compare (%d, %d, %d, %d, %d)\n", l1, s1, l2, s2, ct);
    if (ct <= 0 || s1+ct > l1 || s2+ct > l2)
        return FALSE;
    while (ct--) {
        if (TESTFLAG (debug, D_COMP))
            printf ("'%s' == '%s'? ", buffer1[s1].text, buffer2[s2].text);
        if ((*fCmp)(buffer1[s1++].text, buffer2[s2++].text)) {
            if (TESTFLAG (debug, D_CCALL))
                printf ("No\n");
            return FALSE;
            }
        }
    if (TESTFLAG (debug, D_CCALL))
        printf ("Yes\n");
    return TRUE;
}



BinaryCompare (f1, f2)
char *f1, *f2;
{
    register int c1, c2;
    long pos;
    FILE *fh1, *fh2;
    flagType fSame;

    fSame = TRUE;
    if ((fh1 = fopen (f1, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f1, error ());
        usage (line, 2);
        }
    if ((fh2 = fopen (f2, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f2, error ());
        usage (line, 2);
        }
    pos = 0L;
    while (TRUE) {
        if ((c1 = getc (fh1)) != EOF)
            if ((c2 = getc (fh2)) != EOF)
                if (c1 == c2)
                    ;
                else {
                    fSame = FALSE;
                    if (fQuiet)
                        exit(1);
                    else
                        printf ("%08lx: %02x %02x\n", pos, c1, c2);
                    }
            else {
                sprintf (line, "%s longer than %s", f1, f2);
                usage (line, 1);
                }
        else
        if ((c2 = getc (fh2)) == EOF)
            if (fSame)
                usage ("no differences encountered", 0);
            else
                exit (1);
        else {
            sprintf (line, "%s longer than %s", f2, f1);
            usage (line, 1);
            }
        pos++;
        }
    return( 0 );
}

/* print out a single line */
void pline (pl)
struct lineType *pl;
{
    if (fNumb)
        printf ("%5d:  ", pl->line);
    printf ("%s\n", pl->text);
}

/* output a range of lines */
void dump( struct lineType *pl, int start, int end )
{
    if (fAbbrev && end-start > 2) {
        pline (pl+start);
        printf ("...\n");
        pline (pl+end);
        }
    else
        while (start <= end)
            pline (pl+start++);
}

/*  adjust returns number of lines in buffer
 *
 *  pl          line buffer to be adjusted
 *  ml          number of line in line buffer
 *  lt          number of lines to scroll
 */
adjust( struct lineType *pl, int ml, int lt)
{
    int i;

    if (TESTFLAG (debug, D_CALL))
        printf ("adjust (%p, %d, %d) = ", pl, ml, lt);
    if (TESTFLAG (debug, D_CALL))
        printf ("%d\n", ml-lt);
    if (ml <= lt)
        return 0;
    if (TESTFLAG (debug, D_CALL))
        printf ("move (%p, %p, %04x)\n", &pl[lt], &pl[0], sizeof (*pl)*(ml-lt));
    /*  buffer has 0..lt-1 lt..ml
     *  we free 0..lt-1
     */
    for (i = 0; i < lt; i++)
        if (pl[i].text != NULL)
            free (pl[i].text);
    /*  buffer is 0..0 lt..ml
     *  compact to lt..ml ???
     */
// djg  Move ((char far *)&pl[lt], (char far *)&pl[0], sizeof (*pl)*(ml-lt));
    memmove ((char *)&pl[0], (char *)&pl[lt], sizeof (*pl)*(ml-lt));
    /*  buffer is lt..ml ??
     *  fill to be lt..ml 0..0
     */
    for (i = ml-lt; i < ml; i++)
        pl[i].text = NULL;
    return ml-lt;
}


void LineCompare (f1, f2)
char *f1, *f2;
{
    FILE *fh1, *fh2;
    int l1, l2, i, xp, yp, xc, yc;
    flagType xd, yd, fSame, fFirstLineDifferent;
    int line1, line2;

    fFirstLineDifferent = TRUE;
    fSame = TRUE;
    if ((fh1 = fopen (f1, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f1, error ());
        usage (line, 2);
        }
    if ((fh2 = fopen (f2, "rb")) == NULL) {
        sprintf (line, "cannot open %s - %s", f2, error ());
        usage (line, 2);
        }
    if ((buffer1 = (struct lineType *)calloc (cLine, sizeof *buffer1)) == NULL ||
        (buffer2 = (struct lineType *)calloc (cLine, sizeof *buffer1)) == NULL)
        usage ("out of memory\n", 2);
    l1 = l2 = 0;
    line1 = line2 = 0;

l0: if (TESTFLAG (debug, D_SYNC))
        printf ("At scan beginning\n");
    if (fQuiet && !fSame)
        exit(1);
    l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1);
    l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2);
    if (l1 == 0 && l2 == 0) {
        if (fSame)
            usage ("no differences encountered", 0);
        else
            usage ("differences encountered", 1);
        }

    /*  find first line that differs in buffer
     */
    xc = min (l1, l2);
    for (i=0; i < xc; i++)
        if (!compare (l1, i, l2, i, 1))
            break;
    if (fMerge)
        dump (buffer2, 0, i-1);

    /*  If we are different at a place other than at the top then we know
     *  that there will be a matching line at the head of the buffer
     */
    if (i != 0)
        fFirstLineDifferent = FALSE;

    /*  if we found one at all, then adjust all buffers so last matching
     *  line is at top.  Note that if we are doing this for the first buffers
     *  worth in the file then the top lines WON'T MATCH
     */
    if (i != xc)
        i = max (i-1, 0);

    l1 = adjust (buffer1, l1, i);
    l2 = adjust (buffer2, l2, i);

    /*  if we've matched the entire buffers-worth then go back and fill some
     *  more
     */
    if (l1 == 0 && l2 == 0) {
        fFirstLineDifferent = FALSE;
        goto l0;
        }

    /*  Fill up the buffers as much as possible; the next match may occur
     *  AFTER the current set of buffers
     */
    l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1);
    l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2);
    if (TESTFLAG (debug, D_SYNC))
        printf ("buffers are adjusted, %d, %d remain\n", l1, l2);
    xd = yd = FALSE;
    xc = yc = 1;
    xp = yp = 1;

    /*  begin trying to match the buffers
     */
l6: if (TESTFLAG (debug, D_RESYNC))
        printf ("Trying resync %d,%d  %d,%d\n", xc, xp, yc, yp);
    i = min (l1-xc,l2-yp);
    i = min (i, ctSync);
    if (compare (l1, xc, l2, yp, i)) {
        fSame = FALSE;
        if (fMerge) {
            printf ("#if OLDVERSION\n");
            dump (buffer1, fFirstLineDifferent ? 0 : 1, xc-1);
            printf ("#else\n");
            dump (buffer2, fFirstLineDifferent ? 0 : 1, yp-1);
            printf ("#endif\n");
            }
        else
        if (!fQuiet) {
            printf ("***** %s\n", f1);
            dump (buffer1, 0, xc);
            printf ("***** %s\n", f2);
            dump (buffer2, 0, yp);
            printf ("*****\n\n");
            }
        if (TESTFLAG (debug, D_SYNC))
            printf ("Sync at %d,%d\n", xc, yp);
        l1 = adjust (buffer1, l1, xc);
        l2 = adjust (buffer2, l2, yp);
        fFirstLineDifferent = FALSE;
        goto l0;
        }
    i = min (l1-xp, l2-yc);
    i = min (i, ctSync);
    if (compare (l1, xp, l2, yc, i)) {
        fSame = FALSE;
        if (fMerge) {
            printf ("#if OLDVERSION\n");
            dump (buffer1, fFirstLineDifferent ? 0 : 1, xp-1);
            printf ("#else\n");
            dump (buffer2, fFirstLineDifferent ? 0 : 1, yc-1);
            printf ("#endif\n");
            }
        else
        if (!fQuiet) {
            printf ("***** %s\n", f1);
            dump (buffer1, 0, xp);
            printf ("***** %s\n", f2);
            dump (buffer2, 0, yc);
            printf ("*****\n\n");
            }
        if (TESTFLAG (debug, D_SYNC))
            printf ("Sync at %d,%d\n", xp, yc);
        l1 = adjust (buffer1, l1, xp);
        l2 = adjust (buffer2, l2, yc);
        fFirstLineDifferent = FALSE;
        goto l0;
        }
    if (++xp > xc) {
        xp = 1;
        if (++xc >= l1) {
            xc = l1;
            xd = TRUE;
            }
        }
    if (++yp > yc) {
        yp = 1;
        if (++yc >= l2) {
            yc = l1;
            yd = TRUE;
            }
        }
    if (!xd || !yd)
        goto l6;
    fSame = FALSE;
    if (fMerge) {
        if (l1 >= cLine || l2 >= cLine)
            fprintf (stderr, "resync failed.  Files are too different\n");
        printf ("#if OLDVERSION\n");
        do {
            dump (buffer1, 0, l1-1);
            l1 = adjust (buffer1, l1, l1);
        } while (l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1));
        printf ("#else\n");
        do {
            dump (buffer2, 0, l2-1);
            l2 = adjust (buffer2, l2, l2);
        } while (l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2));
        printf ("#endif\n");
        }
    else
    if (!fQuiet) {
        if (l1 >= cLine || l2 >= cLine)
            fprintf (stderr, "resync failed.  Files are too different\n");
        printf ("***** %s\n", f1);
        do {
            dump (buffer1, 0, l1-1);
            l1 = adjust (buffer1, l1, l1);
        } while (l1 += fillbuf  (buffer1+l1, fh1, cLine-l1, &line1));
        printf ("***** %s\n", f2);
        do {
            dump (buffer2, 0, l2-1);
            l2 = adjust (buffer2, l2, l2);
        } while (l2 += fillbuf  (buffer2+l2, fh2, cLine-l2, &line2));
        printf ("*****\n\n");
        }
    exit (1);
}

__cdecl main (c, v)
int c;
char *v[];
{
    int i;

    funcRead = fgetl;

    ConvertAppToOem( c, v );
    if (c == 1)
        usage (NULL, 2);
    SHIFT(c,v);
    while (fSwitChr (**v)) {
        if (!strcmp (*v+1, "a"))
            fAbbrev = TRUE;
        else
        if (!strcmp (*v+1, "b"))
            fBinary = TRUE;
        else
        if (!strcmp (*v+1, "c"))
            fCase = FALSE;
        else
        if (!strncmp (*v+1, "d", 1))
            debug = atoi (*v+2);
        else
        if (!strcmp (*v+1, "l"))
            fLine = TRUE;
        else
        if (!strcmp (*v+1, "lb")) {
            SHIFT(c,v);
            cLine = ntoi (*v, 10);
            }
        else
        if (!strcmp (*v+1, "m")) {
            fMerge = TRUE;
	    funcRead = fgets;
            }
        else
        if (!strcmp (*v+1, "n"))
            fNumb = TRUE;
        else
        if (!strcmp (*v+1, "q"))
            fQuiet = TRUE;
        else
        if (*strbskip (*v+1, "0123456789") == '\0')
            ctSync = ntoi (*v+1, 10);
        else
        if (!strcmp (*v+1, "t"))
	    funcRead = fgets;
        else
        if (!strcmp (*v+1, "w"))
            fIgnore = TRUE;
        else
            usage (NULL, 2);
        SHIFT(c,v);
        }
    if (c != 2)
        usage (NULL, 2);
    if (ctSync != -1)
        fLine = TRUE;
    else
        ctSync = 2;
    if (cLine == -1)
        cLine = 300;
    if (!fBinary && !fLine) {
        extention (v[0], line);
        for (i = 0; extBin[i]; i++)
            if (!_strcmpi (extBin[i], line))
                fBinary = TRUE;
        if (!fBinary)
            fLine = TRUE;
        }
    if (fBinary && (fLine || fNumb))
        usage ("incompatable switches", 2);
    if (fIgnore)
        if (fCase)
	    fCmp = strcmps;
        else
	    fCmp = strcmpis;
    else
    if (fCase)
	fCmp = strcmp;
    else
	fCmp = _strcmpi;
    if (fBinary)
        BinaryCompare (v[0], v[1]);
    else
        LineCompare (v[0], v[1]);
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\frespace\frespace.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>

void DiskFreeSpace(char *DirectoryName)
{

 ULARGE_INTEGER freeBytesAvailableToCaller;
 ULARGE_INTEGER totalNumberOfBytes;
 ULARGE_INTEGER totalNumberOfFreeBytes;
 HINSTANCE FHandle;
 FARPROC PAddress;



 FHandle = LoadLibrary("Kernel32");
 PAddress = GetProcAddress(FHandle,"GetDiskFreeSpaceEx");

 if (GetDiskFreeSpaceEx(DirectoryName, &freeBytesAvailableToCaller, &totalNumberOfBytes, &totalNumberOfFreeBytes))
 {
	 /*printf("Total number of free bytes (low): %f\n", totalNumberOfFreeBytes.LowPart/1048576.0);
	 printf("Total number of free bytes (high): %lu\n", totalNumberOfFreeBytes.HighPart*4096);*/
	 printf("%f", totalNumberOfFreeBytes.LowPart/1048576.0 + totalNumberOfFreeBytes.HighPart*4096.0);
	 /*printf("Free bytes available to caller(low): %f\n", freeBytesAvailableToCaller.LowPart/1048576.0);
	 printf("Free bytes available to caller(high): %lu\n", freeBytesAvailableToCaller.HighPart*4096);*/
	 /*printf("Free bytes available to caller: %f MB\n", freeBytesAvailableToCaller.LowPart/1048576.0 + freeBytesAvailableToCaller.HighPart*4096.0);
	 /*printf("Total number of bytes (low): %f\n", totalNumberOfBytes.LowPart/1048576.0);
	 printf("Total number of bytes (high): %lu\n", totalNumberOfBytes.HighPart*4096);
	 printf("Total number of bytes: %f MB\n",totalNumberOfBytes.LowPart/1048576.0 + freeBytesAvailableToCaller.HighPart*4096.0);*/
	
 }
 else
 {
	 printf("Error");
 }

}

void __cdecl main(int arc, char *argv[])
{

  char *Path;

  /* Path is the second argument in the command line when calling the executable "freespace" */
  Path = argv[1];

  DiskFreeSpace(Path);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\filever\filever.c ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>

#include "filever.h"

// command line flags
UINT    fFlags = 0;

VOID
usage(CHAR *szProgName)
{
    puts  ("Prints file version information.\n");
    printf("%s [/S] [/V] [/E] [/X] [/B] [/A] [/D] [[drive:][path][filename]]\n", szProgName);
    puts  ("\n"
           "/S\tDisplays files in specified directory and all subdirectories.\n"
           "/V\tList verbose version information if available.\n"
           "/E\tList executables only.\n"
           "/X\tDisplays short names generated for non-8dot3 file names.\n"
           "/B\tUses bare format (no dir listing).\n"
           "/A\tDon't display file attributes.\n"
           "/D\tDon't display file date and time."
#ifdef DEBUG
           "\n/z\tPrint debug messages."
#endif
          );
}

int __cdecl
main(INT argc, CHAR **argv)
{
    INT     i;
    LPTSTR  szT;
    UINT    cDirs = 0;

    if (argc < 2)
    {
        usage(argv[0]);
        exit(0);
    }

    // Loop through and process all the args
    for(i = 1; i < argc; ++i)
    {
        if(argv[i][0] != '/' && argv[i][0] != '-')
        {
            cDirs++;
            continue;
        }

        for(szT = &argv[i][1]; *szT; ++szT)
        {
            switch(*szT)
            {
#ifdef DEBUG
            case 'z':
                fFlags |= FSTR_DEBUG;
                break;
#endif
            case 'l':
            case 'L':
                // provided for compatability (list format is default now)
                break;
            case 'd':
            case 'D':
                fFlags |= FSTR_NODATETIME;
                break;
            case 'a':
            case 'A':
                fFlags |= FSTR_NOATTRS;
                break;
            case 'b':
            case 'B':
                fFlags |= FSTR_BAREFORMAT;
                break;
            case 'x':
            case 'X':
                fFlags |= FSTR_SHORTNAME;
                break;
            case 'S':
            case 's':
                fFlags |= (FSTR_RECURSE | FSTR_PRINTDIR);
                break;
            case 'V':
            case 'v':
                fFlags |= FSTR_VERBOSE;
                break;
            case 'e':
            case 'E':
                fFlags |= FSTR_EXESONLY;
                break;
            case '?':
            case 'h':
            case 'H':
                usage(argv[0]);
                exit(0);
            default:
                printf("Invalid flag specified: (-%c)\n", *szT);
                usage(argv[0]);
                exit(-1);
            }
        }
    }

#ifdef DEBUG
    if(fFlags & FSTR_DEBUG)
        printf("DBG> Command line dir count: %d\n", cDirs);
#endif

    // If they didn't specify a dir, default to current one
    if(!cDirs)
    {
        argc = 2;
        argv[1] = ".";
    }
    else if(cDirs > 1)
    {
        // turn on dir printing if we have more than one dir
        fFlags |= FSTR_PRINTDIR;
    }

    // if we have bareformat on, turn dir printing off
    if(fFlags & FSTR_BAREFORMAT)
        fFlags &= ~FSTR_PRINTDIR;

    for(i = 1; i < argc; ++i)
    {
        DWORD   dwAttr;
        LPTSTR  szDir = NULL;
        LPTSTR  szPat = NULL;
        TCHAR   szFullPath[MAX_PATH + 1];
        TCHAR   szPattern[MAX_PATH + 1];

        // skip flags
        if(argv[i][0] == '/' || argv[i][0] == '-')
            continue;

        // Grab de dir
        szDir = argv[i];

        // get the full path to our dir
        if(GetFullPathName(szDir, MAX_PATH, szFullPath, &szT)) {
            szDir = szFullPath;
        } else {
            lstrcpy(szFullPath, szDir);
            szDir = szFullPath;
        }

        dwAttr = GetFileAttributes(szDir);

#ifdef NEVER
        // If it's not a directory or -1, assume a single file and flip on verbose
        if(!(fFlags & FSTR_RECURSE) && !FA_DIR(dwAttr))
            fFlags |= FSTR_VERBOSE;
#endif

        // If GetFileAttributes failed or it isn't a directory, grab the pattern
        if((dwAttr == (DWORD)-1) || !FA_DIR(dwAttr))
        {
            for(szT = szDir; *szT; szT++)
            {
                if(*szT == '\\')
                    szPat = szT;
            }

            if(szPat)
                *szPat++ = 0;
        }

        // make sure we have a pattern
        if(!szPat || !*szPat)
            szPat = "*.*";
        lstrcpy(szPattern, szPat);

        FListFiles(szDir, szPattern);
    }

    return 0;
}


BOOL
FListFiles(LPTSTR szDir, LPTSTR szPat)
{
    HANDLE          hf;
    WIN32_FIND_DATA fd;
    UINT            cchDir;
    TCHAR           szFileName[MAX_PATH + 1];
    BOOL            fPrintedDir = !(fFlags & FSTR_PRINTDIR);

#ifdef DEBUG
    if(fFlags & FSTR_DEBUG)
        printf("DBG> FListFiles('%s', '%s')\n", szDir, szPat);
#endif

    // Get short name if that's what they want
    if(fFlags & FSTR_SHORTNAME)
        GetShortPathName(szDir, szDir, MAX_PATH);

    // Get dir length and add trailing '\' if not there
    cchDir = lstrlen(szDir);
    if(szDir[cchDir - 1] != '\\')
    {
        szDir[cchDir++] = '\\';
        szDir[cchDir] = 0;
    }

    // Concat pattern to dir
    CharLower(szDir);
    lstrcpy(szFileName, szDir);
    lstrcpy(&szFileName[cchDir], szPat);

    // list all the files
    hf = FindFirstFile(szFileName, &fd);
    if(hf != INVALID_HANDLE_VALUE)
    {
        do
        {
            DWORD   lBinaryType;
            BOOL    fIsDir = FA_DIR(fd.dwFileAttributes);

            if(fIsDir && (fd.cFileName[0] == '.'))
            {
                // skip . and ..
                if(!fd.cFileName[1] ||
                    ((fd.cFileName[1] == '.') && !fd.cFileName[2]))
                        continue;
            }

            CharLower(fd.cFileName);
            lstrcpy(&szFileName[cchDir], fd.cFileName);

            // get type of file
            lBinaryType = MyGetBinaryType(szFileName);
            if(!(fFlags & FSTR_EXESONLY) || (lBinaryType != SCS_UNKOWN))
            {
                // Print out our dir name
                if(!fPrintedDir)
                {
                    printf("\t%s%s\n", szDir, szPat);
                    fPrintedDir = TRUE;
                }

                // file attributes
                if(!(fFlags & FSTR_NOATTRS))
                    PrintFileAttributes(fd.dwFileAttributes);
                // file type
                PrintFileType(lBinaryType);
                // version
                PrintFileVersion(szFileName);
                // size & date
                if(!(fFlags & FSTR_NODATETIME))
                    PrintFileSizeAndDate(&fd);
                // print file name
                printf(fIsDir ? " [%s%s]\n" : " %s%s\n",
                    fFlags & FSTR_BAREFORMAT ? szDir : "",
                    ((fFlags & FSTR_SHORTNAME) && fd.cAlternateFileName[0]) ?
                    fd.cAlternateFileName : fd.cFileName);

                // print verbose info if this isn't a dir
                // Win95 also craps out on dos files so ignore those too
                if((fFlags & FSTR_VERBOSE) &&
                    (lBinaryType != SCS_UNKOWN) &&
                    (lBinaryType != SCS_DOS_BINARY))
                        GetVersionStuff(szFileName, NULL, NULL);
            }
        } while(FindNextFile(hf, &fd));

        FindClose(hf);
    }

    // dive into all the subdirs
    if(fFlags & FSTR_RECURSE)
    {
        // Concat pattern to dir
        lstrcpy(&szFileName[cchDir], "*.*");

        hf = FindFirstFile(szFileName, &fd);
        if(hf != INVALID_HANDLE_VALUE)
        {
            do
            {
                if(FA_DIR(fd.dwFileAttributes))
                {
                    if(fd.cFileName[0] == '.')
                    {
                        if(!fd.cFileName[1] ||
                            ((fd.cFileName[1] == '.') && !fd.cFileName[2]))
                                continue;
                    }

                    // create new dir name and dive in
                    lstrcpy(&szFileName[cchDir], fd.cFileName);
                    FListFiles(szFileName, szPat);
                }
            } while(FindNextFile(hf, &fd));

            FindClose(hf);
        }
    }

    return TRUE;
}

#define PrintFlagsMap(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) & _structname[iType].dwTypeMask) \
            printf(" %s", _structname[iType].szFullStr); \
    }

#define PrintFlagsVal(_structname, _flags) \
    for(iType = 0; iType < sizeof(_structname)/sizeof(TypeTag); iType++) \
    { \
        if((_flags) == _structname[iType].dwTypeMask) \
        { \
            printf(" %s", _structname[iType].szFullStr); \
            break; \
        } \
    }

VOID
PrintFixedFileInfo(VS_FIXEDFILEINFO *pvs)
{
    UINT    iType;

    printf("\tVS_FIXEDFILEINFO:\n");
    printf("\tSignature:\t%08.8lx\n", pvs->dwSignature);
    printf("\tStruc Ver:\t%08.8lx\n", pvs->dwStrucVersion);
    printf("\tFileVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwFileVersionMS, pvs->dwFileVersionLS,
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS));
    printf("\tProdVer:\t%08.8lx:%08.8lx (%d.%d:%d.%d)\n",
        pvs->dwProductVersionMS, pvs->dwProductVersionLS,
        HIWORD(pvs->dwProductVersionMS), LOWORD(pvs->dwProductVersionMS),
        HIWORD(pvs->dwProductVersionLS), LOWORD(pvs->dwProductVersionLS));

    printf("\tFlagMask:\t%08.8lx\n", pvs->dwFileFlagsMask);
    printf("\tFlags:\t\t%08.8lx", pvs->dwFileFlags);
    PrintFlagsMap(ttFileFlags, pvs->dwFileFlags);

    printf("\n\tOS:\t\t%08.8lx", pvs->dwFileOS);
    PrintFlagsVal(ttFileOsHi, pvs->dwFileOS & 0xffff000);
    PrintFlagsVal(ttFileOsLo, LOWORD(pvs->dwFileOS));

    printf("\n\tFileType:\t%08.8lx", pvs->dwFileType);
    PrintFlagsVal(ttFType, pvs->dwFileType);

    printf("\n\tSubType:\t%08.8lx", pvs->dwFileSubtype);
    if(pvs->dwFileType == VFT_FONT)
    {
        PrintFlagsVal(ttFTypeFont, pvs->dwFileSubtype);
    }
    else if(pvs->dwFileType == VFT_DRV)
    {
        PrintFlagsVal(ttFTypeDrv, pvs->dwFileSubtype);
    }
    printf("\n\tFileDate:\t%08.8lx:%08.8lx\n", pvs->dwFileDateMS, pvs->dwFileDateLS);
}


typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
 *  [alanau]
 *
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is a local function, it allocates the memory which is freed by the caller.
 *   This makes it slightly more efficient than a GetFileVersionInfoSize/GetFileVersionInfo pair.
 */
BOOL
MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    UINT              uiBytes = 0;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    DWORD             dwHandle;
    DWORD             dwLength;

    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Cleanup;

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL)
        goto Cleanup;

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL)
        goto Cleanup;

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);
    __try {

        hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
        if (hVerRes == NULL)
        {
            // Probably a 16-bit file.  Fall back to system APIs.
            if(!(dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle)))
            {
                if(!GetLastError())
                    SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
                __leave;
            }

            if(!(*lpVersionInfo = GlobalAllocPtr(GHND, dwLength)))
                __leave;

            if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
                __leave;

            bResult = TRUE;
            __leave;
        }

        pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
        if (pVerHead == NULL)
            __leave;

        *lpVersionInfo = GlobalAllocPtr(GHND, pVerHead->wTotLen + pVerHead->wTotLen/2);
        if (*lpVersionInfo == NULL)
            __leave;

        memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
        bResult = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);
    if (*lpVersionInfo && bResult == FALSE)
        GlobalFreePtr(*lpVersionInfo);

    return bResult;
}


DWORD
GetVersionStuff(LPTSTR szFileName, DWORD *pdwLangRet, VS_FIXEDFILEINFO *pvsRet)
{
    LPVOID              lpInfo;
    TCHAR               key[80];
    DWORD               dwLength;
    LPVOID              lpvData = NULL;
    DWORD               *pdwTranslation;
    UINT                i, iType, cch, uLen;
    VS_FIXEDFILEINFO    *pvs;
    DWORD               dwDefLang = 0x409;

    if(!MyGetFileVersionInfo(szFileName, &lpvData))
        goto err;

    if(!VerQueryValue(lpvData, "\\VarFileInfo\\Translation", &pdwTranslation, &uLen))
    {
        if(!pdwLangRet)
            printf("\t- No \\VarFileInfo\\Translation, assuming %08lx\n", dwDefLang);
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    if(pdwLangRet)
    {
        *pdwLangRet = *pdwTranslation;
        goto fixedfileinfo;
    }

    while(uLen)
    {
        // Language
        printf("\tLanguage\t0x%04x", LOWORD(*pdwTranslation));
        if(VerLanguageName(LOWORD(*pdwTranslation), key, sizeof(key) / sizeof(TCHAR)))
            printf(" (%s)", key);
        printf("\n");

        // CharSet
        printf("\tCharSet\t\t0x%04x", HIWORD(*pdwTranslation));
        for(iType = 0; iType < sizeof(ltCharSet)/sizeof(CharSetTag); iType++)
        {
            if(HIWORD(*pdwTranslation) == ltCharSet[iType].wCharSetId)
                printf(" %s", ltCharSet[iType].szDesc);
        }
        printf("\n");

tryagain:
        wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
            LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

        lstrcat(key, "OleSelfRegister");
        printf("\t%s\t%s\n", "OleSelfRegister",
            VerQueryValue(lpvData, key, &lpInfo, &cch) ? "Enabled" : "Disabled");

        for(i = 0; i < (sizeof(VersionKeys) / sizeof(VersionKeys[0])); i++)
        {
            wsprintf(key, "\\StringFileInfo\\%04x%04x\\",
                LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));
            lstrcat(key, VersionKeys[i]);

            if(VerQueryValue(lpvData, key, &lpInfo, &cch))
            {
                lstrcpy(key, VersionKeys[i]);
                key[15] = 0;
                printf("\t%s\t%s\n", key, lpInfo);
            }
        }

        // if the Lang is neutral, go try again with the default lang
        // (this seems to work with msspell32.dll)
        if(LOWORD(*pdwTranslation) == 0)
        {
            pdwTranslation = &dwDefLang;
            goto tryagain;
        }

        uLen -= sizeof(DWORD);
        pdwTranslation++;
        printf("\n");
    }

fixedfileinfo:
    if(!VerQueryValue(lpvData, "\\", (LPVOID *)&pvs, &uLen))
        goto err;

    if(pvsRet)
        *pvsRet = *pvs;
    else
        PrintFixedFileInfo(pvs);

err:
    dwLength = GetLastError();
    if(dwLength &&
      (dwLength != ERROR_RESOURCE_DATA_NOT_FOUND) &&
      (dwLength != ERROR_RESOURCE_TYPE_NOT_FOUND) &&
      !pvsRet)
    {
        PrintErrorMessage(dwLength, NULL);
    }

    if(lpvData)
        GlobalFreePtr(lpvData);
    return dwLength;
}

DWORD
MyGetBinaryType(LPTSTR szFileName)
{
    HANDLE              hFile;
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    DWORD               lFileType = SCS_UNKOWN;

    if((hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
            goto err;

    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL))
        goto err;

    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
        goto err;
    lFileType = SCS_DOS_BINARY;

    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == -1)
        goto err;
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL))
        goto err;
    if((img_nt_hdrs.Signature & 0xffff) == IMAGE_OS2_SIGNATURE)
    {
        pimg_os2_hdr = (PIMAGE_OS2_HEADER)&img_nt_hdrs;
        switch(pimg_os2_hdr->ne_exetyp)
        {
        case NE_OS2:
            lFileType = SCS_OS216_BINARY;
            break;
        case NE_DEV386:
        case NE_WINDOWS:
            lFileType = SCS_WOW_BINARY;
            break;
        case NE_DOS4:
        case NE_UNKNOWN:
        default:
            // lFileType = SCS_DOS_BINARY;
            break;
        }
    }
    else if(img_nt_hdrs.Signature == IMAGE_NT_SIGNATURE)
    {
        switch(img_nt_hdrs.OptionalHeader.Subsystem)
        {
        case IMAGE_SUBSYSTEM_OS2_CUI:
            lFileType = SCS_OS216_BINARY;
            break;
        case IMAGE_SUBSYSTEM_POSIX_CUI:
            lFileType = SCS_POSIX_BINARY;
            break;
        case IMAGE_SUBSYSTEM_NATIVE:
        case IMAGE_SUBSYSTEM_WINDOWS_GUI:
        case IMAGE_SUBSYSTEM_WINDOWS_CUI:
        default:
            switch(img_nt_hdrs.FileHeader.Machine)
            {
            case IMAGE_FILE_MACHINE_I386:
                lFileType = SCS_32BIT_BINARY_INTEL;
                break;
            case IMAGE_FILE_MACHINE_R3000:
            case IMAGE_FILE_MACHINE_R4000:
                lFileType = SCS_32BIT_BINARY_MIPS;
                break;
            case IMAGE_FILE_MACHINE_ALPHA:
                lFileType = SCS_32BIT_BINARY_ALPHA;
                break;
            case IMAGE_FILE_MACHINE_ALPHA64:
                lFileType = SCS_32BIT_BINARY_AXP64;
                break;
            case IMAGE_FILE_MACHINE_IA64:
                lFileType = SCS_32BIT_BINARY_IA64;
                break;
            case IMAGE_FILE_MACHINE_POWERPC:
                lFileType = SCS_32BIT_BINARY_PPC;
                break;
            default:
            case IMAGE_FILE_MACHINE_UNKNOWN:
                lFileType = SCS_32BIT_BINARY;
                break;
            }
            break;
        }
    }

err:
    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    return lFileType;
}

VOID __cdecl
PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...)
{
    LPTSTR  szT;
    va_list arglist;
    LPTSTR  szErrMessage = NULL;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, dwError, 0/*LANG_USER_DEFAULT*/, (LPTSTR)&szErrMessage, 0, NULL);
    if(szFmt && szErrMessage)
    {
        for(szT = szErrMessage; *szT; szT++)
        {
            if(*szT == '\r' || *szT == '\n')
                *szT = 0;
        }
    }

    printf("Error 0x%08lx. %s", dwError, szErrMessage ? szErrMessage : "");

    if(szFmt)
    {
        va_start(arglist, szFmt);
        vprintf(szFmt, arglist);
        va_end(arglist);
    }

    if(szErrMessage)
        LocalFree((HLOCAL)szErrMessage);
}

VOID
PrintFileType(DWORD lBinaryType)
{
    LPCTSTR szFmtFileType = "   - ";

    if(lBinaryType < (sizeof(szType) / sizeof(szType[0])))
        szFmtFileType = szType[lBinaryType];
    printf("%s", szFmtFileType);
}

VOID
PrintFileAttributes(DWORD dwAttr)
{
    DWORD   dwT;
    static const FileAttr attrs[] =
       {{FILE_ATTRIBUTE_DIRECTORY, 'd'},
        {FILE_ATTRIBUTE_READONLY,  'r'},
        {FILE_ATTRIBUTE_ARCHIVE,   'a'},
        {FILE_ATTRIBUTE_HIDDEN,    'h'},
        {FILE_ATTRIBUTE_SYSTEM,    's'} };
    TCHAR   szAttr[(sizeof(attrs) / sizeof(attrs[0])) + 1];

    for(dwT = 0; dwT < (sizeof(attrs) / sizeof(attrs[0])); dwT++)
        szAttr[dwT] = (dwAttr & attrs[dwT].dwAttr) ? attrs[dwT].ch : '-';
    szAttr[dwT] = 0;

    printf("%s ", szAttr);
}

VOID
PrintFileSizeAndDate(WIN32_FIND_DATA *pfd)
{
    FILETIME    ft;
    SYSTEMTIME  st = {0};
    TCHAR       szSize[15];

    szSize[0] = 0;
    if(FileTimeToLocalFileTime(&pfd->ftLastWriteTime, &ft) &&
        FileTimeToSystemTime(&ft, &st))
    {
        TCHAR       szVal[15];
        NUMBERFMT   numfmt = {0, 0, 3, "", ",", 0};

        wsprintf(szVal, "%ld", pfd->nFileSizeLow); //$ SPEED
        GetNumberFormat(GetUserDefaultLCID(), 0, szVal, &numfmt, szSize, 15);
    }

    printf(" %10s %02d-%02d-%02d", szSize, st.wMonth, st.wDay, st.wYear);
}

VOID
PrintFileVersion(LPTSTR szFileName)
{
    VS_FIXEDFILEINFO    vs = {0};
    INT                 iType;
    DWORD               dwLang;
    TCHAR               szBuffer[100];

    dwLang = (DWORD)-1;
    vs.dwFileVersionMS = (DWORD)-1;
    vs.dwFileVersionLS = (DWORD)-1;
    GetVersionStuff(szFileName, &dwLang, &vs);
    dwLang = LOWORD(dwLang);

    szBuffer[0] = 0;
    for(iType = 0; iType < sizeof(ttFType) / sizeof(TypeTag); iType++)
    {
        if(vs.dwFileType == ttFType[iType].dwTypeMask)
        {
            printf("%3.3s ", ttFType[iType].szTypeStr);
            break;
        }
    }
    if(iType == (sizeof(ttFType) / sizeof(TypeTag)))
        printf("  - ");

    for(iType = 0; iType < sizeof(ltLang) / sizeof(LangTag); iType++)
    {
        if(dwLang == ltLang[iType].wLangId)
        {
            printf("%3.3s ", ltLang[iType].szKey);
            break;
        }
    }
    if(iType == (sizeof(ltLang) / sizeof(LangTag)))
        printf("  - ");

    if(vs.dwFileVersionMS != (DWORD)-1)
    {
        wsprintf(szBuffer, "%u.%u.%u.%u %s",
                HIWORD(vs.dwFileVersionMS),
                LOWORD(vs.dwFileVersionMS),
                HIWORD(vs.dwFileVersionLS),
                LOWORD(vs.dwFileVersionLS),
                vs.dwFileFlags & VS_FF_DEBUG ? "dbg" : "shp");
    }
    else
    {
        lstrcpy(szBuffer, "-   -");
    }

    printf(" %18.18s", szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\filever\filever.h ===
// function prototypes
DWORD GetVersionStuff(LPTSTR szFileName, DWORD *pdwLangRet, VS_FIXEDFILEINFO *pvsRet);

VOID PrintFileType(DWORD lBinaryType);
VOID PrintFileAttributes(DWORD dwAttr);
VOID PrintFileSizeAndDate(WIN32_FIND_DATA *pfd);
VOID PrintFileVersion(LPTSTR szFileName);

BOOL FListFiles(LPTSTR szDir, LPTSTR szPat);
DWORD MyGetBinaryType(LPTSTR szFileName);
VOID __cdecl PrintErrorMessage(DWORD dwError, LPTSTR szFmt, ...);

#define FA_DIR(_x)    ((_x) & FILE_ATTRIBUTE_DIRECTORY)

// filever cmd line flags
#define FSTR_RECURSE    0x0001
#define FSTR_VERBOSE    0x0002
#define FSTR_EXESONLY   0x0004
#define FSTR_SHORTNAME  0x0008
#define FSTR_BAREFORMAT 0x0010
#define FSTR_PRINTDIR   0x0020
#define FSTR_NOATTRS    0x0040
#define FSTR_NODATETIME 0x0080
#ifdef DEBUG
#define FSTR_DEBUG      0x8000
#endif

// PrintFileAttr struct
typedef struct _FileAttr
{
    DWORD dwAttr;
    TCHAR ch;
} FileAttr;

// MyGetBinaryType exe type defines
#define NE_UNKNOWN  0x0     /* Unknown (any "new-format" OS) */
#define NE_OS2      0x1     /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS  0x2     /* Microsoft Windows */
#define NE_DOS4     0x3     /* Microsoft MS-DOS 4.x */
#define NE_DEV386   0x4     /* Microsoft Windows 386 */

// MyGetBinaryType return values
enum {
    // SCS_32BIT_BINARY,
    // SCS_DOS_BINARY,
    // SCS_WOW_BINARY,
    // SCS_PIF_BINARY,
    // SCS_POSIX_BINARY,
    // SCS_OS216_BINARY,
    SCS_32BIT_BINARY_INTEL = SCS_OS216_BINARY + 1,
    SCS_32BIT_BINARY_MIPS,
    SCS_32BIT_BINARY_ALPHA,
    SCS_32BIT_BINARY_PPC,
    SCS_32BIT_BINARY_AXP64,
    SCS_32BIT_BINARY_IA64
};
#define SCS_UNKOWN      (DWORD)-1

static const TCHAR   *szType[] = {
    "W32    ",
    "DOS    ",
    "W16    ",
    "PIF    ",
    "PSX    ",
    "OS2    ",
    "W32i   ",
    "W32m   ",
    "W32a   ",
    "W32p   ",
    "W32a64 ",
    "W32i64 ",
};

CONST static TCHAR *VersionKeys[] =
{
    TEXT("CompanyName"),
    TEXT("FileDescription"),
    TEXT("InternalName"),
    TEXT("OriginalFilename"),
    TEXT("ProductName"),
    TEXT("ProductVersion"),
    TEXT("FileVersion"),
    TEXT("LegalCopyright"),
    TEXT("LegalTrademarks"),
    TEXT("PrivateBuild"),
    TEXT("SpecialBuild"),
    TEXT("Comments")
};

// languages map
typedef struct _LangTag {
	WORD		wLangId;
	LPSTR		szName;
	LPSTR		szDesc;
	LPSTR		szKey;
} LangTag;

CONST static LangTag ltLang[] =
{
	{0x0406,"Danish","Danish","DAN"},
	{0x0413,"Dutch","Dutch (Standard)","NLD"},
	{0x0813,"Dutch","Belgian (Flemish)","NLB"},
	{0x0409,"English","American","ENU"},
	{0x0809,"English","British","ENG"},
	{0x0c09,"English","Australian","ENA"},
	{0x1009,"English","Canadian","ENC"},
	{0x1409,"English","New Zealand","ENZ"},
	{0x1809,"English","Ireland","ENI"},
	{0x040b,"Finnish","Finnish","FIN"},
	{0x040c,"French","French (Standard)","FRA"},
	{0x080c,"French","Belgian","FRB"},
	{0x0c0c,"French","Canadian","FRC"},
	{0x100c,"French","Swiss","FRS"},
	{0x0407,"German","German (Standard)","DEU"},
	{0x0807,"German","Swiss","DES"},
	{0x0c07,"German","Austrian","DEA"},
	{0x040f,"Icelandic","Icelandic","ISL"},
	{0x0410,"Italian","Italian (Standard)","ITA"},
	{0x0810,"Italian","Swiss","ITS"},
	{0x0414,"Norwegian","Norwegian (Bokmal)","NOR"},
	{0x0814,"Norwegian","Norwegian (Nynorsk)","NON"},
	{0x0416,"Portuguese","Portuguese (Brazilian)","PTB"},
	{0x0816,"Portuguese","Portuguese (Standard)","PTG"},
	{0x041D,"Swedish","Swedish","SVE"},
	{0x040a,"Spanish","Spanish (Standard/Traditional)","ESP"},
	{0x080a,"Spanish","Mexican","ESM"},
	{0x0c0a,"Spanish","Spanish (Modern)","ESN"},
	{0x041f,"Turkish","TRK","TRK"},
	{0x0415,"Polish","PLK","PLK"},
	{0x0405,"Czech","CSY","CSY"},
	{0x041b,"Slovak","SKY","SKY"},
	{0x040e,"Hungarian","HUN","HUN"},
	{0x0419,"Russian","RUS","RUS"},
	{0x0408,"Greek","ELL","ELL"},
	{0x0804,"Chinese","CHS","CHS"},
	{0x0404,"Taiwan","CHT","CHT"},
	{0x0411,"Japan","JPN","JPN"},
	{0x0412,"Korea","KOR","KOR"}
};

// languages map
typedef struct _CharSetTag {
	WORD		wCharSetId;
	LPSTR		szDesc;
} CharSetTag;

CONST static CharSetTag ltCharSet[] =
{
	{0, "7-bit ASCII"},
	{932, "Windows, Japan (Shift  JIS X-0208)"},
	{949, "Windows, Korea (Shift  KSC 5601)"},
	{950, "Windows, Taiwan (GB5)"},
	{1200, "Unicode"},
	{1250, "Windows, Latin-2 (Eastern European)"},
	{1251, "Windows, Cyrillic"},
	{1252, "Windows, Multilingual"},
	{1253, "Windows, Greek"},
	{1254, "Windows, Turkish"},
	{1255, "Windows, Hebrew"},
	{1256, "Windows, Arabic"}
};

typedef struct  _ffTypeTag {
    DWORD   dwTypeMask;
    LPSTR   szTypeStr;
    LPSTR   szFullStr;
} TypeTag;

// file flags map

TypeTag  ttFileFlags[]= {
    { VS_FF_DEBUG,       "D",   "debug"},
    { VS_FF_PRERELEASE,  "P",   "prerelease"},
    { VS_FF_PATCHED,     "A",   "patched"},
    { VS_FF_PRIVATEBUILD,"I",   "private"},
    { VS_FF_INFOINFERRED,"F",   "infoInferred"},
    { VS_FF_SPECIALBUILD,"S",   "special"}
};

// file OS map

TypeTag ttFileOsHi[] = {
    { VOS_DOS,          "DOS",  "MS-DOS"},
    { VOS_OS216,        "O16",  "OS2/16"},
    { VOS_OS232,        "O32",  "OS2/32"},
    { VOS_NT,           "NT",   "NT"},
};

TypeTag ttFileOsLo[] = {
    { VOS__WINDOWS16,   "Win16","Win16"},
    { VOS__PM16,        "PM16", "PM16"},
    { VOS__PM32,        "PM32", "PM32"},
    { VOS__WINDOWS32,   "Win32","Win32"}
};

// type map
TypeTag  ttFType[] = {
    { VFT_APP,          "APP",  "App"},
    { VFT_DLL,          "DLL",  "Dll"},
    { VFT_DRV,          "DRV",  "Driver"},
    { VFT_FONT,         "FNT",  "Font"},
    { VFT_VXD,          "VXD",  "VXD"},
    { VFT_STATIC_LIB,   "LIB",  "lib"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
TypeTag ttFTypeDrv[] = {
	{ VFT2_DRV_PRINTER, "", "PrinterDrv"},
	{ VFT2_DRV_KEYBOARD, "", "KeyBoardDrv"},
	{ VFT2_DRV_LANGUAGE, "", "LangDrv"},
	{ VFT2_DRV_DISPLAY, "", "DisplayDrv"},
	{ VFT2_DRV_MOUSE, "", "MouseDrv"},
	{ VFT2_DRV_NETWORK, "", "NetworkDrv"},
	{ VFT2_DRV_SYSTEM, "", "SystemDrv"},
	{ VFT2_DRV_INSTALLABLE, "", "InstallableDrv"},
	{ VFT2_DRV_SOUND, "", "SoundDrv"},
	{ VFT2_DRV_COMM, "", "CommDrv"}
};

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
TypeTag ttFTypeFont[] = {
	{ VFT2_FONT_RASTER, "", "Raster"},
	{ VFT2_FONT_VECTOR, "", "Vectore"},
	{ VFT2_FONT_TRUETYPE, "", "Truetype"}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\bsfixalloc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.h

Abstract:

    Adapted rom MFC fixalloc.h

Author:

    Stefan R. Steiner   [ssteiner]        04-10-2000

Revision History:

--*/

#ifndef __H_BSFIXALLOC_
#define __H_BSFIXALLOC_

// fixalloc.h - declarations for fixed block allocator

#pragma pack(push, 8)

struct CBsPlex     // warning variable length structure
{
	CBsPlex* pNext;
	DWORD dwReserved[1];    // align on 8 byte boundary
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CBsPlex* PASCAL Create(CBsPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

class CBsFixedAlloc
{
// Constructors
public:
	CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize = 64);

// Attributes
	UINT GetAllocSize() { return m_nAllocSize; }

// Operations
public:
	void* Alloc();  // return a chunk of memory of nAllocSize
	void Free(void* p); // free chunk of memory returned from Alloc
	void FreeAll(); // free everything allocated from this allocator

// Implementation
public:
	~CBsFixedAlloc();

protected:
	struct CNode
	{
		CNode* pNext;   // only valid when in free list
	};

	UINT m_nAllocSize;  // size of each block from Alloc
	UINT m_nBlockSize;  // number of blocks to get at a time
	CBsPlex* m_pBlocks;   // linked list of blocks (is nBlocks*nAllocSize)
	CNode* m_pNodeFree; // first free node (NULL if no free nodes)
	CRITICAL_SECTION m_protect;
};

#ifndef _DEBUG

// DECLARE_FIXED_ALLOC -- used in class definition
#define DECLARE_FIXED_ALLOC(class_name) \
public: \
	void* operator new(size_t size) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
	void* operator new(size_t, void* p) \
		{ return p; } \
	void operator delete(void* p) { s_alloc.Free(p); } \
	void* operator new(size_t size, LPCSTR, int) \
	{ \
		ASSERT(size == s_alloc.GetAllocSize()); \
		UNUSED(size); \
		return s_alloc.Alloc(); \
	} \
protected: \
	static CBsFixedAlloc s_alloc \

// IMPLEMENT_FIXED_ALLOC -- used in class implementation file
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size) \
CBsFixedAlloc class_name::s_alloc(sizeof(class_name), block_size) \

#else //!_DEBUG

#define DECLARE_FIXED_ALLOC(class_name)     // nothing in debug
#define IMPLEMENT_FIXED_ALLOC(class_name, block_size)   // nothing in debug

#endif //!_DEBUG

#endif // __H_BSFIXALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\engine.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Header file for the file system dump utility engine

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

--*/

#ifndef __H_ENGINE_
#define __H_ENGINE_

class CFsdVolumeStateManager;
class CFsdVolumeState;

class CDumpEngine
{
public:
    CDumpEngine(
        IN CBsString cwsDirFileSpec,
        IN CDumpParameters &cDumpParameters
        ) : m_pcParams( &cDumpParameters ),
            m_ullNumDirs( 0 ),
            m_ullNumMountpoints( 0 ),
            m_ullNumBytesChecksummed( 0 ),
            m_ullNumBytesTotalUnnamedStream( 0 ),
            m_ullNumBytesTotalNamedDataStream( 0 ),
            m_ullNumReparsePoints( 0 ),
            m_ullNumFiles( 0 ),
            m_bShareName( FALSE ),
            m_ullNumFilesExcluded( 0 ),
            m_ullNumHardLinks( 0 ),
            m_ullNumDiscreteDACEs( 0 ),
            m_ullNumDiscreteSACEs( 0 ),
            m_ullNumEncryptedFiles( 0 ),
            m_ullNumFilesWithObjectIds( 0 )
    { 
        assert( cwsDirFileSpec.GetLength() >= 1 );

        //
        //  Let's do a bunch of stuff to normalize the given directory path.  Windows doesn't
        //  make this easy....
        //
        BOOL bPathIsInLongPathForm = FALSE;

        if ( cwsDirFileSpec.Left( 4 ) == L"\\\\?\\" || cwsDirFileSpec.Left( 4 ) == L"\\\\.\\" )
        {
            //
            //  Switch . with ? if it is there
            //
            cwsDirFileSpec.SetAt( 2, L'?' );
            bPathIsInLongPathForm = TRUE;
        } 
        else if ( cwsDirFileSpec.Left( 2 ) == L"\\\\"  )
        {
            // 
            //  Remote path
            //
            m_bShareName = TRUE;
        }
        else if ( cwsDirFileSpec.GetLength() == 2 && cwsDirFileSpec[1] == L':' )
        {
            //
            //  Just the drive letter and :.  GetFullPathNameW thinks that means
            //  the current directory on the drive whereas I mean for it to be the
            //  entire volume, i.e. L:\
            //
            cwsDirFileSpec += L'\\';
        }
        
        //
        //  Let's get the full path
        //
        LPWSTR pwszFileName;
        
        if ( ::GetFullPathNameW( 
                cwsDirFileSpec,
                FSD_MAX_PATH,
                m_cwsDirFileSpec.GetBufferSetLength( FSD_MAX_PATH ),
                &pwszFileName ) == 0 )
        {
            m_pcParams->ErrPrint( L"ERROR - Unable to get full path name of '%s', dwRet: %d, trying with relative pathname", 
                cwsDirFileSpec.c_str(), ::GetLastError() );
            m_cwsDirFileSpec.ReleaseBuffer() ;
            m_cwsDirFileSpec = cwsDirFileSpec;
        }
        else
        {
            m_cwsDirFileSpec.ReleaseBuffer();
        }
        
        //
        //  Must prepare the path to support > MAX_PATH file path by
        //  tacking on \\?\ on the front of the path.  Shares have 
        //  a slightly different format.
        //
        if ( !( m_pcParams->m_bDisableLongPaths || bPathIsInLongPathForm ) )
        {
            if ( m_bShareName )
            {
                //  BUGBUG: When the bug in GetVolumePathNameW() is fixed, uncomment the
                //  following:
                // m_cwsDirFileSpec  = L"\\\\?\\UNC";
                // m_cwsDirFileSpec += cwsDirFileSpec.c_str() + 1; // Have to chop off one '\'
            }
            else
            {
                m_cwsDirFileSpec  = L"\\\\?\\" + m_cwsDirFileSpec;
            }
        }

        //
        //  Add a trailing '\' if necessary
        //
        if (    m_pcParams->m_eFsDumpType != eFsDumpFile 
             && m_cwsDirFileSpec.Right( 1 ) != L"\\" )
            m_cwsDirFileSpec += L'\\';

        //
        //  Finally done mucking with paths...
        //
    }
    
    virtual ~CDumpEngine()
    {
    }

    DWORD PerformDump();

    static LPCSTR GetHeaderInformation();
    
private:
    DWORD ProcessDir( 
        IN CFsdVolumeStateManager *pcFsdVolStateManager,
        IN CFsdVolumeState *pcFsdVolState,
        IN const CBsString& cwsDirPath,
        IN INT cDirFileSpecLength,
        IN INT cVolMountPointOffset
        );

    VOID PrintEntry(
        IN CFsdVolumeState *pcFsdVolState,
        IN const CBsString& cwsDirPath,    
        IN INT cDirFileSpecLength,    
        IN SDirectoryEntry *psDirEntry,
        IN BOOL bSingleEntryOutput = FALSE
        );
    
    CBsString       m_cwsDirFileSpec;
    CDumpParameters *m_pcParams;
    ULONGLONG       m_ullNumDirs;
    ULONGLONG       m_ullNumFiles;
    ULONGLONG       m_ullNumMountpoints;
    ULONGLONG       m_ullNumReparsePoints;
    ULONGLONG       m_ullNumBytesChecksummed;
    ULONGLONG       m_ullNumBytesTotalUnnamedStream;
    ULONGLONG       m_ullNumBytesTotalNamedDataStream;
    ULONGLONG       m_ullNumFilesExcluded;
    ULONGLONG       m_ullNumHardLinks;
    ULONGLONG       m_ullNumDiscreteDACEs;
    ULONGLONG       m_ullNumDiscreteSACEs;
    ULONGLONG       m_ullNumEncryptedFiles;
    ULONGLONG       m_ullNumFilesWithObjectIds;
    BOOL            m_bShareName;
};

#endif // __H_ENGINE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\cli\fsdump.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsdump.cpp

Abstract:

    Main entry point for the fsdump utility

Author:

    Stefan R. Steiner   [ssteiner]        02-17-2000

Revision History:

    ssteiner    08-15-2000
        Fixed bugs:
            154375 - Short name support
            153050 - Better handling of RSS files
            154363 - Dump security descriptor control word
            157042 - Handle the case where hard-link file attributes are stale
--*/

#include <windows.h>

#include "bsstring.h"
#include "params.h"
#include "direntrs.h"
#include "engine.h"

//
//  Forward defines
//
VOID PrintUsage();
VOID PrintHeaderInformation();

INT ProcessCommandLine( 
    IN INT argc,
    IN WCHAR *argv[],
    OUT CDumpParameters *pcDumpParameters,
    OUT WCHAR **ppwszFileDirSpecList[],
    OUT DWORD *pdwDirSpecListSize
    );
    
/*++

Routine Description:

    The main entry point into the fsdump utility.

Arguments:

Return Value:

    <Enter return values here>

--*/
extern "C" INT __cdecl wmain( 
    IN INT argc, 
    IN WCHAR *argv[] )
{
    BOOL bDebugMode = FALSE;

    try
    {
        INT iRc;
        CDumpParameters cDumpParameters( 0 );
        WCHAR **pwszFileDirSpecList;
        DWORD dwDirSpecListSize;

        //
        //  Process the command line and get back the dump parameters and list
        //  of volumes, directories and files to dump.
        //
        iRc = ::ProcessCommandLine( 
            argc, 
            argv, 
            &cDumpParameters, 
            &pwszFileDirSpecList, 
            &dwDirSpecListSize );
        if ( iRc != 0 )
            return iRc;
        
        bDebugMode = cDumpParameters.m_bPrintDebugInfo;
        
        //
        //  Setup the error log and dump streams
        //
        iRc = cDumpParameters.Initialize( argc, argv );
        if ( iRc != 0 )
            return iRc;
            
        //
        //  Now loop through the list, dumping each.
        //
        for ( DWORD dwIdx = 0; dwIdx < dwDirSpecListSize; ++dwIdx )
        {
            CDumpEngine cEngine( pwszFileDirSpecList[ dwIdx ], cDumpParameters );
            cEngine.PerformDump();
        }

        delete [] pwszFileDirSpecList;
    }
    catch ( HRESULT hr )
    {
        if ( hr == E_OUTOFMEMORY )
            fwprintf( stderr, L"wmain::Out of memory\n" );
        else
            fwprintf( stderr, L"wmain::Unexpected hr exception: 0x%08x\n", hr );
        
        return hr;                        
    }
    catch ( ... )
    {
        fwprintf( stderr, L"ERROR - fsdump::wmain, caught unexpected exception\n" );
    }
    
    if ( bDebugMode )
    {
        fwprintf( stderr, L"Press <enter> to end program...\n" );
        getchar();
    }
    
    return 0;
}

VOID PrintUsage()
{
    fprintf( stdout, 
        "fsdump.exe - File system dump facility - Version 1.3g - 8/23/2000\n"
        "Copyright (c) Microsoft Corporation, 2000.\n\n"
        "fsdump [-dv|-dd[n]|-df] [-f DumpFileName] [-l ErrorLogFileName] [-h]\n"
        "       [-a:XXXX] [-e[r]] [i[a|c|s[d]] [-p] [-t] [-z] [-x]\n"
        "       [-o:[c][d][h][l][m][n][o][s][u][x][z]]\n"
        "       [DirFileSpec [...]]\n"
        "   Note: Options can be before and/or after DirFileSpec entries.\n"
        "         fsdump is mostly useful for NTFS volumes.\n"
        "         fsdump by default dumps in Excel CSV (comma-delimited format) see -o:n\n"
        "\t-dv  - Dump entries in DirFileSpec volume - Default\n"
        "\t       (DirFileSpec format - D: or E:\\xxxx\\MountPoint - no wildcards)\n"
        "\t-dd  - Dump entries in DirFileSpec directory branch\n"
        "\t       (DirFileSpec format - D:\\foo - no wildcard chars)\n"
        "\t-ddn - Dump entries in DirFileSpec directory with no subdir traversal\n"
        "\t       (DirFileSpec format - D:\\foo - no wildcard chars)\n"
        "\t-df  - Dump DirFileSpec file\n"
        "\t       (DirFileSpec format - D:\\foo\\file - no wildcard chars)\n"
        "\t-f   - Dump file name.  If not specified, dumps to stdout\n"
        "\t-l   - Error log file name.  If not specified, dumps to stderr\n"
        "\t-h   - This usage information\n\n"
        "\t-a:  - Specify a hex mask of file attributes to mask in the output\n"
        "\t       The default mask is 00A0 - masks archive and normal attributes\n"
        "\t-e   - Exclude files in dump based on FilesNotToBackup reg key and\n"
        "\t       .exclude files in the same directory as the fsdump executable.\n"
        "\t       Also if the fsdump.exe is on NTFS, a data stream named\n"
        "\t       :ExcludeList will also be checked for existence.  If it exists\n"
        "\t       it too will be read for exclusion rules.\n"
        "\t-er  - Same as -e but does not include the FilesNotToBackup reg keys.\n"
        "\t-ia  - Info about file attribute bits\n"
        "\t-ic  - Info on the column names\n"
        "\t-is  - Info about the security descriptor control word bits\n"
        "\t-isd - Detailed info about the security descriptor control word bits\n"
        "\t-o:  - Output options:\n"
        "\t        c - No file data checksums\n"
        "\t        d - Show directory timestamps\n"
        "\t        h - Only dumps file info with no header or summary info\n"
        "\t        l - Checksum high latency data (HSM migrated data)\n"
        "\t        m - Add millisecs to timestamps\n"
        "\t        n - Dumps entries in an easy to read format instead of CSV\n"
        "\t        o - Enable Object Id extended data checksums\n"
        "\t        s - Convert SIDs to symbolic DOMAIN\\ACCOUNTNAME format\n"
        "\t        u - Dump file and error log in Unicode format\n"
        "\t        x - Hexidecimal size values (decimal default)\n"
        "\t        z - Disable special handling of certain reparse points\n"
        "\t            (i.e. RSS)\n"
        "\t-p   - Disable long path support (the use of \\\\?\\ in front of paths)\n"
        "\t-t   - Don't traverse mountpoints\n"
        "\t-z   - Print debug information to stdout\n\n" );
}

VOID PrintFileAttributesInformation()
{
    fprintf( stdout, "Information about file attribute types (in hex):\n"
        "\t0001 - Read-only\n"
        "\t0002 - Hidden\n"
        "\t0004 - System\n"
        "\t0010 - Directory\n"
        "\t0020 - Archive - Masked out by fsdump by default\n"
        "\t0040 - Device\n"
        "\t0080 - Normal - Masked out by fsdump by default\n"
        "\t0100 - Temporary\n"
        "\t0200 - Sparse\n"
        "\t0400 - Reparse point\n"
        "\t0800 - Compressed\n"
        "\t1000 - Offline\n"
        "\t2000 - Not content indexed\n"
        "\t4000 - Encrypted\n" );
}

VOID PrintSecDescControlWordInformation(
    IN BOOL bDetailed
    )
{
    if ( bDetailed )
    {
        fprintf( stdout, "Detailed information about the Security Descriptor control word bits (in hex):\n"
            "\t0001 - SE_OWNER_DEFAULTED\n"
            "\t\tIndicates that the SID pointed to by the Owner field was\n"
            "\t\tprovided by a defaulting mechanism rather than explicitly\n"
            "\t\tprovided by the original provider of the security descriptor.\n"
            "\t\tThis may affect the treatment of the SID with respect to\n"
            "\t\tinheritence of an owner.\n"
            "\t0002 - SE_GROUP_DEFAULTED\n"
            "\t\tIndicates that the SID in the Group field was provided by a\n"
            "\t\tdefaulting mechanism rather than explicitly provided by the\n"
            "\t\toriginal provider of the security descriptor.  This may affect\n"
            "\t\tthe treatment of the SID with respect to inheritence of a\n"
            "\t\tprimary group.\n"
            "\t0004 - SE_DACL_PRESENT\n"
            "\t\tIndicates a security descriptor that has a DACL. If this flag\n"
            "\t\tis not set, or if this flag is set and the DACL is NULL, the\n"
            "\t\tsecurity descriptor allows full access to everyone.\n"
            "\t0008 - SE_DACL_DEFAULTED\n"
            "\t\tIndicates that the DACL was provided by a defaulting mechanism\n"
            "\t\trather than explicitly provided by the original provider of the\n"
            "\t\tsecurity descriptor.  This may affect the treatment of the ACL\n"
            "\t\twith respect to inheritence of an ACL. This flag is ignored if\n"
            "\t\tthe SE_DACL_PRESENT flag is not set.\n"
            "\t0010 - SE_SACL_PRESENT\n"
            "\t\tIndicates that the security descriptor contains a system ACL.\n"
            "\t\tIf this flag is set and the SACL is NULL, then an empty (but\n"
            "\t\tpresent) ACL is being specified.\n"
            "\t0020 - SE_SACL_DEFAULTED\n"
            "\t\tIndicates that the SACL was provided by a defaulting mechanism\n"
            "\t\trather than explicitly provided by the original provider of the\n"
            "\t\tsecurity descriptor.  This may affect the treatment of the ACL\n"
            "\t\twith respect to inheritence of an ACL. This flag is ignored if\n"
            "\t\tthe SE_SACL_PRESENT flag is not set.\n"
            "\t0040 - SE_DACL_UNTRUSTED\n"
            "\t\tIndicates that the DACL was not provided by a trusted source\n"
            "\t\tand does not require any editing of compound ACEs.  If this\n"
            "\t\tflag is set and a compound ACE is encountered, the system will\n"
            "\t\tsubstitute known valid SIDs for the server SIDs in the ACEs.\n"
            "\t0080 - SE_SERVER_SECURITY\n"
            "\t\tIndicates that the caller wishes the system to create a Server\n"
            "\t\tACL based on the input ACL, regardess of its source (explicit\n"
            "\t\tor defaulting).  This is done by replacing all of the GRANT\n"
            "\t\tACEs with compound ACEs granting the current server.  This flag\n"
            "\t\tis only meaningful if the subject is impersonating.\n"
            "\t0100 - SE_DACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t\tRequests that the provider for the object protected by the\n"
            "\t\tsecurity descriptor automatically propagate the DACL to\n"
            "\t\texisting child objects. If the provider supports automatic\n"
            "\t\tinheritance, it propagates the DACL to any existing child\n"
            "\t\tobjects, and sets the SE_DACL_AUTO_INHERITED bit in the\n"
            "\t\tsecurity descriptors of the object and its child objects.\n"
            "\t0200 - SE_SACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t\tRequests that the provider for the object protected by the\n"
            "\t\tsecurity descriptor automatically propagate the SACL to\n"
            "\t\texisting child objects. If the provider supports automatic\n"
            "\t\tinheritance, it propagates the SACL to any existing child\n"
            "\t\tobjects, and sets the SE_SACL_AUTO_INHERITED bit in the\n"
            "\t\tsecurity descriptors of the object and its child objects.\n"
            "\t0400 - SE_DACL_AUTO_INHERITED (Win2K and above)\n"
            "\t\tIndicates a security descriptor in which the DACL is set up to\n"
            "\t\tsupport automatic propagation of inheritable ACEs to existing\n"
            "\t\tchild objects. This bit is set only if the automatic\n"
            "\t\tinheritance algorithm has been performed for the object and\n"
            "\t\tits existing child objects.\n"
            "\t0800 - SE_SACL_AUTO_INHERITED (Win2K and above)\n"
            "\t\tIndicates a security descriptor in which the SACL is set up to\n"
            "\t\tsupport automatic propagation of inheritable ACEs to existing\n"
            "\t\tchild objects. This bit is set only if the automatic\n"
            "\t\tinheritance algorithm has been performed for the object and its\n"
            "\t\texisting child objects.\n"
            "\t1000 - SE_DACL_PROTECTED (Win2K and above)\n"
            "\t\tProtects the DACL of the security descriptor from being\n"
            "\t\tmodified by inheritable ACEs.\n"
            "\t2000 - SE_SACL_PROTECTED (Win2K and above)\n"
            "\t\tProtects the SACL of the security descriptor from being\n"
            "\t\tmodified by inheritable ACEs.\n"
            "\t4000 - SE_RM_CONTROL_VALID\n"
            "\t\t???\n"
            "\t8000 - SE_SELF_RELATIVE - This bit is masked out by fsdump\n" 
            "\t\tIndicates a security descriptor in self-relative format with\n"
            "\t\tall the security information in a contiguous block of memory.\n"
            "\t\tIf this flag is not set, the security descriptor is in\n"
            "\t\tabsolute format.\n" );
    }
    else
    {
        fprintf( stdout, "Information about the Security Descriptor control word bits (in hex):\n"
            "\t0001 - SE_OWNER_DEFAULTED\n"
            "\t0002 - SE_GROUP_DEFAULTED\n"
            "\t0004 - SE_DACL_PRESENT\n"
            "\t0008 - SE_DACL_DEFAULTED\n"
            "\t0010 - SE_SACL_PRESENT\n"
            "\t0020 - SE_SACL_DEFAULTED\n"
            "\t0040 - SE_DACL_UNTRUSTED\n"
            "\t0080 - SE_SERVER_SECURITY\n"
            "\t0100 - SE_DACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t0200 - SE_SACL_AUTO_INHERIT_REQ - Never set, informational only\n"
            "\t0400 - SE_DACL_AUTO_INHERITED (Win2K and above)\n"
            "\t0800 - SE_SACL_AUTO_INHERITED (Win2K and above)\n"
            "\t1000 - SE_DACL_PROTECTED (Win2K and above)\n"
            "\t2000 - SE_SACL_PROTECTED (Win2K and above)\n"
            "\t4000 - SE_RM_CONTROL_VALID\n"
            "\t8000 - SE_SELF_RELATIVE - This bit is masked out by fsdump\n" );
    }
}
    
VOID PrintHeaderInformation()
{
    fprintf( stdout, "Information about the column names in the dump:\n" );
    fprintf( stdout, "%s", CDumpEngine::GetHeaderInformation() );
}

INT ProcessCommandLine( 
    IN INT argc,
    IN WCHAR *argv[],
    OUT CDumpParameters *pcDumpParameters,
    OUT WCHAR **ppwszFileDirSpecList[],
    OUT DWORD *pdwDirSpecListSize
    )
{
    pcDumpParameters->m_cwsArgv0 = argv[0];

    if ( argc < 2 )
    {
        PrintUsage();
        return 1;
    }

    *ppwszFileDirSpecList = new LPWSTR[ argc - 1 ];
    if ( *ppwszFileDirSpecList == NULL )  // Prefix #118831
        throw E_OUTOFMEMORY;
    
    *pdwDirSpecListSize = 0;
    
    INT i = 1;
    for ( ; i < argc; ++i )
    {
        if ( argv[ i ][ 0 ] != L'-' && argv[ i ][ 0 ] != L'/' )
        {
            ( *ppwszFileDirSpecList )[ *pdwDirSpecListSize ] = argv[ i ];
            ++*pdwDirSpecListSize;
        }
        else
        {
            ::_wcslwr( argv[ i ] );
            switch ( argv[ i ][ 1 ] )
            {
                case L'd': // type of dump
                    if ( argv[ i ][ 2 ] == L'v' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpVolume;
                    else if ( argv[ i ][ 2 ] == L'd' && argv[ i ][ 3 ] == L'\0' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpDirTraverse;
                    else if ( argv[ i ][ 2 ] == L'd' && argv[ i ][ 3 ] == L'n' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpDirNoTraverse;
                    else if ( argv[ i ][ 2 ] == L'f' )
                        pcDumpParameters->m_eFsDumpType = eFsDumpFile;
                    else
                    {
                        PrintUsage();
                        return 2;
                    }
                    break;
                case L'l': // error log name
                    ++i;
                    if ( i < argc )
                        pcDumpParameters->m_cwsErrLogFileName = argv[ i ];
                    else
                    {
                        PrintUsage();
                        return 3;
                    }
                    break;
                case L'f': // dump file name
                    ++i;
                    if ( i < argc )
                        pcDumpParameters->m_cwsDumpFileName = argv[ i ];
                    else
                    {
                        PrintUsage();
                        return 4;
                    }
                    break;
                case L't':
                    pcDumpParameters->m_bDontTraverseMountpoints = TRUE;
                    break;
                case L'e':
                    pcDumpParameters->m_bUseExcludeProcessor = TRUE;
                    if ( argv[ i ][ 2 ] != L'\0' )
                    {
                        if ( argv[ i ][ 2 ] == L'r' )
                           pcDumpParameters->m_bDontUseRegistryExcludes = TRUE;                        
                        else
                        {
                            PrintUsage();
                            return 5;
                        }
                    }
                    break;
                case L'p':
                    pcDumpParameters->m_bDisableLongPaths = TRUE;
                    break;
                    
                case L'x':  // TEMPORARY
                    pcDumpParameters->m_bEnableSDCtrlWordDump = FALSE;
                    wprintf( L"***** Enabling Secrurity Descriptor Control Word dump****\n" );
                    break;
                    
                case L'z':
                    pcDumpParameters->m_bPrintDebugInfo = TRUE;
                    break;
                case L'a':
                    {
                        if ( argv[ i ][ 2 ] == L'\0' )
                        {
                            PrintFileAttributesInformation();
                            return 11;
                        }
                        if ( argv[ i ][ 2 ] != L':' )
                        {
                            PrintUsage();
                            return 10;
                        }
                        if ( argv[ i ][ 3 ] == L'\0' )
                        {
                            pcDumpParameters->m_dwFileAttributesMask = 0;
                            break;
                        }
                        
                        LPWSTR pwstrEnd;
                        pcDumpParameters->m_dwFileAttributesMask = ( DWORD )::wcstol( &argv[ i ][ 3 ], &pwstrEnd, 16 );
                        if ( pwstrEnd[ 0 ] != L'\0' )
                        {
                            fprintf( stderr, " ERROR - File attributes mask contain non-hex characters\n" );
                            PrintUsage();
                            return 11;
                        }
                    }
                    break;                            
                                            
                case L'o':
                    {
                        if ( argv[ i ][ 2 ] != L':' )
                        {
                            PrintUsage();
                            return 10;
                        }
                        for ( INT j = 3; argv[ i ][ j ] != L'\0'; ++j )
                        {
                            switch ( argv[ i ][ j ] )
                            {
                            case L'c':
                                pcDumpParameters->m_bNoChecksums = TRUE;
                                break;
                            case L'u':
                                pcDumpParameters->m_bUnicode = TRUE;
                                break;
                            case L'x':
                                pcDumpParameters->m_bHex = TRUE;
                                break;
                            case L'l':
                                pcDumpParameters->m_bDontChecksumHighLatencyData = FALSE;
                                break;
                            case L'm':
                                pcDumpParameters->m_bAddMillisecsToTimestamps = TRUE;
                                break;
                            case L'o':
                                pcDumpParameters->m_bEnableObjectIdExtendedDataChecksums = TRUE;
                                break;
                            case L'd':
                                pcDumpParameters->m_bDontShowDirectoryTimestamps = FALSE;
                                break;
                            case L's':
                                pcDumpParameters->m_bShowSymbolicSIDNames = TRUE;
                                break;
                            case L'e': // legacy
                                pcDumpParameters->m_bDumpCommaDelimited = TRUE;
                                pcDumpParameters->m_bNoHeaderFooter     = TRUE;
                                break;
                            case L'n':
                                pcDumpParameters->m_bDumpCommaDelimited = FALSE;
                                pcDumpParameters->m_bNoHeaderFooter     = FALSE;
                                break;
                            case L'h':
                                pcDumpParameters->m_bNoHeaderFooter = TRUE;
                                break;
                            case L'z':
                                pcDumpParameters->m_bNoSpecialReparsePointProcessing = TRUE;
                                break;                                
                            default:
                                PrintUsage();
                                return 5;
                            }
                        }
                    }
                    break;
                case L'c':
                    PrintHeaderInformation();
                    return 20;
                    break;
                case L'i':
                    switch ( argv[ i ][ 2 ] )
                    {
                    case L'a':
                        PrintFileAttributesInformation();                       
                        break;
                    case L'c':
                        PrintHeaderInformation();
                        break;
                    case L's':
                        PrintSecDescControlWordInformation( argv[i ][ 3 ] == L'd' );
                        break;
                    default:
                        PrintUsage();
                        return 22;
                    }
                    return 21;
                    break;
                case L'?':
                case L'h':
                    PrintUsage();
                    return 5;
                    break;
                default:
                    PrintUsage();
                    return 5;
                    break;
            }
        }                    
    }

    if ( *pdwDirSpecListSize == 0 )
    {
        PrintUsage();
        return 6;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\direntrs.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    direntrs.h

Abstract:

    Definition of the directory entries class.  Given a path to a directory, 
    creates two linked lists, one a list of all sub-directories (including 
    mountpoints) and another a list of non-directories.


Author:

    Stefan R. Steiner   [ssteiner]        02-21-2000

Revision History:

--*/

#ifndef __H_DIRENTRS_
#define __H_DIRENTRS_

#pragma once

#include "vs_list.h"

//
//  The structure filled in per file/dir.
//  
//
struct SDirectoryEntry
{
    CBsString &GetFileName() { return m_cwsFileName; }
    CBsString &GetShortName() { return m_cwsShortName; }
    
    CBsString m_cwsFileName;
    CBsString m_cwsShortName;
    WIN32_FILE_ATTRIBUTE_DATA m_sFindData;
};

//
//  The linked list iterator type definition
//
typedef CVssDLListIterator< SDirectoryEntry * > CDirectoryEntriesIterator;

//
//  Class: CDirectoryEntries
//
class CDirectoryEntries
{
public:
    CDirectoryEntries(
        IN CDumpParameters *pcDumpParameters,        
        IN const CBsString& cwsDirPath
        );
    
    virtual ~CDirectoryEntries();

    CDirectoryEntriesIterator *GetDirListIterator() 
    { 
        CVssDLListIterator< SDirectoryEntry * > *pcListIter;
        pcListIter = new CDirectoryEntriesIterator( m_cDirList );
        if ( pcListIter == NULL )  // fix future prefix bug
            throw E_OUTOFMEMORY;
        
        return pcListIter;
    }
    
    CDirectoryEntriesIterator *GetFileListIterator() 
    { 
        CVssDLListIterator< SDirectoryEntry * > *pcListIter;
        pcListIter = new CDirectoryEntriesIterator( m_cFileList );
        if ( pcListIter == NULL )  // fix future prefix bug
            throw E_OUTOFMEMORY;
        
        return pcListIter;
    }
    
private:
    DWORD GetDirectoryEntries();

    CBsString m_cwsDirPath;
    CVssDLList< SDirectoryEntry * > m_cDirList;
    CVssDLList< SDirectoryEntry * > m_cFileList;    
    CDumpParameters *m_pcParams;
};

#endif // __H_DIRENTRS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\exclproc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exclproc.h

Abstract:

    Exclude processing mechanism.  Processes the FilesNotToBackup key and
    zero or more exclude files with exclude rules.

Author:

    Stefan R. Steiner   [ssteiner]        03-21-2000

Revision History:

--*/

#ifndef __H_EXCLPROC_
#define __H_EXCLPROC_

#define FSD_REG_EXCLUDE_PATH L"SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"

struct SFsdVolumeId;

//
//  Structure definition of one exclude rule
//
class SFsdExcludeRule
{
public:
    CBsString cwsExcludeFromSource; // File name or key name
    CBsString cwsExcludeDescription;    //  Description of the exclusion rule
    CBsString cwsExcludeRule;   // The actual exclude pattern    
    
    // Compiled match string fields follow:
    BOOL      bInvalidRule; //  If TRUE, rule was deemed invalid by pattern compiler
    BOOL      bAnyVol;  //  If TRUE, matches any volume in the system
    SFsdVolumeId *psVolId;    //  If bAnyVol is FALSE, volid of the file system
    CBsString cwsDirPath;   //  Directory path relative to volume mountpoint (no \ at start of string, \ at end of string)
    CBsString cwsFileNamePattern;   //  File name pattern; may include * and ? chars (no \ at start of string)
    BOOL    bInclSubDirs;   //  If TRUE, include subdirectories under cwsDirPath
    BOOL    bWCInFileName;  //  If TRUE, Wildcard chars in the file name
    CVssDLList< CBsString > cExcludedFileList;  //  List of files excluded by this rule
    
    SFsdExcludeRule() : bAnyVol( FALSE ),
                        bInclSubDirs( FALSE ),
                        bWCInFileName( FALSE ),
                        psVolId( NULL ),
                        bInvalidRule( FALSE ) {}
    virtual ~SFsdExcludeRule();
    
    VOID PrintRule(
        IN FILE *fpOut,
        IN BOOL bInvalidRulePrint
        );
};

class CFsdFileSystemExcludeProcessor;

//
//  Class that maintains the complete list of exclusion rules.  There should be one of
//  these objects per base mountpoint.  This object will manage mountpoints within that
//  mountpoint.  
//
class CFsdExclusionManager
{
public:
    CFsdExclusionManager(
        IN CDumpParameters *pcDumpParameters
        );
    
    virtual ~CFsdExclusionManager();

    VOID GetFileSystemExcludeProcessor(
        IN CBsString cwsVolumePath,
        IN SFsdVolumeId *psVolId,
        OUT CFsdFileSystemExcludeProcessor **ppcFSExcludeProcessor
        );

    VOID PrintExclusionInformation();
    
private:
    VOID ProcessRegistryExcludes( 
        IN HKEY hKey,
        IN LPCWSTR pwszFromSource
        );
    
    VOID ProcessExcludeFiles( 
        IN const CBsString& cwsPathToExcludeFiles
        );
    
    BOOL ProcessOneExcludeFile(
        IN const CBsString& cwsExcludeFileName
        );
    
    VOID CompileExclusionRules();
    
    CDumpParameters *m_pcParams;
    CVssDLList< SFsdExcludeRule * > m_cCompleteExcludeList;  // pointers cleaned up in destructor
};

//
//  Class that maintains the list of exclusion rules for one particular file system.
//
class CFsdFileSystemExcludeProcessor
{
friend class CFsdExclusionManager;

public:
    CFsdFileSystemExcludeProcessor(
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsVolumePath,
        IN SFsdVolumeId *psVolId
        );
    
    virtual ~CFsdFileSystemExcludeProcessor();

    BOOL IsExcludedFile(
        IN const CBsString &cwsFullDirPath,
        IN DWORD dwEndOfVolMountPointOffset,
        IN const CBsString &cwsFileName
        );
    
private:
    CDumpParameters *m_pcParams;
    CBsString m_cwsVolumePath;
    SFsdVolumeId *m_psVolId;
    CVssDLList< SFsdExcludeRule * > m_cFSExcludeList;            
};

#endif // __H_EXCLPROC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\bsstring.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.h

Abstract:

    This module defines the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.
    Added methods in addition to CString:
        c_str() - returns a C string pointer ala the STL string class
        size()  - returns length of string ala the STL string class

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code

--*/

#ifndef __H_BSSTRING_
#define __H_BSSTRING_

#ifndef __cplusplus
	#error requires C++ compilation
#endif

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif
#ifndef _INC_ASSERT
	#include <assert.h>
#endif

#ifndef ASSERT
    #define ASSERT assert
#endif

#include "bsfixalloc.h"

class CBsString;

//
//  The purpose of this class is to generate a compiler error when different string classes
//  are used in bad contexts (example: CBsWString used if _UNICODE is not defined)
//
//  [aoltean] I introduce this small class to hide a class of LINT warnings.
//
class CBsStringErrorGenerator 
{};                     // Private constructor

// CBsString only operates on string that are TCHAR arrays.  Programs should use 
// the following types to make sure they are getting what they are expecting.
#ifdef _UNICODE
    #define CBsWString CBsString
    #define CBsAString CBsStringErrorGenerator   // trigger a compile time bug
#else
    #define CBsAString CBsString
    #define CBsWString CBsStringErrorGenerator   // trigger a compile time bug
#endif

#include <tchar.h>

#ifndef BSAFXAPI
    #define BSAFXAPI __cdecl
    #define BSAFX_CDECL __cdecl
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall
#endif

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the BSAFX include files
#ifndef ALL_WARNINGS
// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for TRACE/ASSERT
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in release version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _BSAFXDLL version
#ifdef _BSAFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#ifdef _BSAFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif
#endif //!ALL_WARNINGS

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CBsStringData
{
	long nRefs;             // reference count
	int nDataLength;        // length of data (including terminator)
	int nAllocLength;       // length of allocation
	// TCHAR data[nAllocLength]

	TCHAR* data()           // TCHAR* to managed data
		{ return (TCHAR*)(this+1); }
};

class CBsString
{
public:
// Constructors

	// constructs empty CBsString
	CBsString();
	// copy constructor
	CBsString(const CBsString& stringSrc);
	// from a single character
	CBsString(TCHAR ch, int nRepeat = 1);
	// from an ANSI string (converts to TCHAR)
	CBsString(LPCSTR lpsz);
	// from a UNICODE string (converts to TCHAR)
	CBsString(LPCWSTR lpsz);
	// subset of characters from an ANSI string (converts to TCHAR)
	CBsString(LPCSTR lpch, int nLength);
	// subset of characters from a UNICODE string (converts to TCHAR)
	CBsString(LPCWSTR lpch, int nLength);
	// from unsigned characters
	CBsString(const unsigned char* psz);
	CBsString(GUID guid);

// Attributes & Operations

	// get data length
	int GetLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();
	int size() const;                   // ala STL string class size()

	// return single character at zero-based index
	TCHAR GetAt(int nIndex) const;
	// return single character at zero-based index
	TCHAR operator[](int nIndex) const;
	// set a single character at zero-based index
	void SetAt(int nIndex, TCHAR ch);
	// return pointer to const string
	operator LPCTSTR() const;
    const LPCTSTR c_str() const;        // as a C string in STL string style

	// overloaded assignment

	// ref-counted copy from another CBsString
	const CBsString& operator=(const CBsString& stringSrc);
	// set string content to single character
	const CBsString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CBsString& operator=(char ch);
#endif
	// copy string content from ANSI string (converts to TCHAR)
	const CBsString& operator=(LPCSTR lpsz);
	// copy string content from UNICODE string (converts to TCHAR)
	const CBsString& operator=(LPCWSTR lpsz);
	// copy string content from unsigned chars
	const CBsString& operator=(const unsigned char* psz);

	// string concatenation

	// concatenate from another CBsString
	const CBsString& operator+=(const CBsString& string);

	// concatenate a single character
	const CBsString& operator+=(TCHAR ch);
#ifdef _UNICODE
	// concatenate an ANSI character after converting it to TCHAR
	const CBsString& operator+=(char ch);
#endif
	// concatenate a UNICODE character after converting it to TCHAR
	const CBsString& operator+=(LPCTSTR lpsz);

	friend CBsString BSAFXAPI operator+(const CBsString& string1,
			const CBsString& string2);
	friend CBsString BSAFXAPI operator+(const CBsString& string, TCHAR ch);
	friend CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string);
#ifdef _UNICODE
	friend CBsString BSAFXAPI operator+(const CBsString& string, char ch);
	friend CBsString BSAFXAPI operator+(char ch, const CBsString& string);
#endif
	friend CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz);
	friend CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string);

	// string comparison

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
	// compare ignoring case
	int CompareNoCase(LPCTSTR lpsz) const;
	// NLS aware comparison, case sensitive
	int Collate(LPCTSTR lpsz) const;
	// NLS aware comparison, case insensitive
	int CollateNoCase(LPCTSTR lpsz) const;

	// simple sub-string extraction

	// return nCount characters starting at zero-based nFirst
	CBsString Mid(int nFirst, int nCount) const;
	// return all characters starting at zero-based nFirst
	CBsString Mid(int nFirst) const;
	// return first nCount characters in string
	CBsString Left(int nCount) const;
	// return nCount characters from end of string
	CBsString Right(int nCount) const;

	//  characters from beginning that are also in passed string
	CBsString SpanIncluding(LPCTSTR lpszCharSet) const;
	// characters from beginning that are not also in passed string
	CBsString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion

	// NLS aware conversion to uppercase
	void MakeUpper();
	// NLS aware conversion to lowercase
	void MakeLower();
	// reverse string right-to-left
	void MakeReverse();

	// trimming whitespace (either side)

	// remove whitespace starting from right edge
	void TrimRight();
	// remove whitespace starting from left side
	void TrimLeft();

	// trimming anything (either side)

	// remove continuous occurrences of chTarget starting from right
	void TrimRight(TCHAR chTarget);
	// remove continuous occcurrences of characters in passed string,
	// starting from right
	void TrimRight(LPCTSTR lpszTargets);
	// remove continuous occurrences of chTarget starting from left
	void TrimLeft(TCHAR chTarget);
	// remove continuous occcurrences of characters in
	// passed string, starting from left
	void TrimLeft(LPCTSTR lpszTargets);

	// advanced manipulation

	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching

	// find character starting at left, -1 if not found
	int Find(TCHAR ch) const;
	// find character starting at right
	int ReverseFind(TCHAR ch) const;
	// find character starting at zero-based index and going right
	int Find(TCHAR ch, int nStart) const;
	// find first instance of any character in passed string
	int FindOneOf(LPCTSTR lpszCharSet) const;
	// find first instance of substring
	int Find(LPCTSTR lpszSub) const;
	// find first instance of substring starting at zero-based index
	int Find(LPCTSTR lpszSub, int nStart) const;

	// simple formatting

	// printf-like formatting using passed string
	void BSAFX_CDECL Format(LPCTSTR lpszFormat, ...);
	// printf-like formatting using variable arguments parameter
	void FormatV(LPCTSTR lpszFormat, va_list argList);

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)

	// convert string from ANSI to OEM in-place
	void AnsiToOem();
	// convert string from OEM to ANSI in-place
	void OemToAnsi();
#endif

#ifndef _BSAFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)

	// return a BSTR initialized with this CBsString's data
	BSTR AllocSysString() const;
	// reallocates the passed BSTR, copies content of this CBsString to it
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array

	// get pointer to modifiable buffer at least as long as nMinBufLength
	LPTSTR GetBuffer(int nMinBufLength);
	// release buffer, setting length to nNewLength (or to first nul if -1)
	void ReleaseBuffer(int nNewLength = -1);
	// get pointer to modifiable buffer exactly as long as nNewLength
	LPTSTR GetBufferSetLength(int nNewLength);
	// release memory allocated to but unused by string
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off

	// turn refcounting back on
	LPTSTR LockBuffer();
	// turn refcounting off
	void UnlockBuffer();

// Implementation
public:
	~CBsString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // Pointer to ref counted string data.  This is actually
                        // a pointer to memory after the CBsStringData structure.

	// implementation helpers
	CBsStringData* GetData() const;
	void Init();
	void AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CBsStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
	static void FASTCALL FreeData(CBsStringData* pData);
};

// Compare helpers
bool BSAFXAPI operator==(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator==(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator==(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator!=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator!=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator!=(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator<(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator<(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator<(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator>(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator>(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator>(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator<=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator<=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator<=(LPCTSTR s1, const CBsString& s2);
bool BSAFXAPI operator>=(const CBsString& s1, const CBsString& s2);
bool BSAFXAPI operator>=(const CBsString& s1, LPCTSTR s2);
bool BSAFXAPI operator>=(LPCTSTR s1, const CBsString& s2);

// conversion helpers
int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// valid address test helpers
BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength = -1);
BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);

// Globals
extern TCHAR bsafxChNil;
const CBsString& BSAFXAPI BsAfxGetEmptyString();
#define bsafxEmptyString BsAfxGetEmptyString()

inline CBsStringData* CBsString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CBsStringData*)m_pchData)-1; }
inline void CBsString::Init()
	{ m_pchData = bsafxEmptyString.m_pchData; }
inline CBsString::CBsString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CBsString& CBsString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CBsString& CBsString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CBsString& CBsString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CBsString BSAFXAPI operator+(const CBsString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CBsString BSAFXAPI operator+(char ch, const CBsString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CBsString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CBsString::size() const
	{ return GetData()->nDataLength; }
inline int CBsString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CBsString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CBsString::operator LPCTSTR() const
	{ return m_pchData; }
inline const LPCTSTR CBsString::c_str() const
	{ return m_pchData; }
inline int PASCAL CBsString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CBsString support (windows specific)
inline int CBsString::Compare(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CBsString::CompareNoCase(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CBsString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CBsString::Collate(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline int CBsString::CollateNoCase(LPCTSTR lpsz) const
	{ ASSERT(BsAfxIsValidString(lpsz)); return _tcsicoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CBsString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CBsString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool BSAFXAPI operator==(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool BSAFXAPI operator==(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool BSAFXAPI operator==(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool BSAFXAPI operator!=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool BSAFXAPI operator!=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool BSAFXAPI operator!=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool BSAFXAPI operator<(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool BSAFXAPI operator<(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool BSAFXAPI operator<(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool BSAFXAPI operator>(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool BSAFXAPI operator>(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool BSAFXAPI operator>(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool BSAFXAPI operator<=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool BSAFXAPI operator<=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool BSAFXAPI operator<=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool BSAFXAPI operator>=(const CBsString& s1, const CBsString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool BSAFXAPI operator>=(const CBsString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool BSAFXAPI operator>=(LPCTSTR s1, const CBsString& s2)
	{ return s2.Compare(s1) <= 0; }

#endif // __H_BSSTRING_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\params.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    params.h

Abstract:

    Header of class that manages the dump parameters.

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

--*/

#ifndef __H_PARAMS_
#define __H_PARAMS_

#define FSD_MAX_PATH ( 8 * 1024 )

enum EFsDumpType
{
    eFsDumpVolume = 1,
    eFsDumpDirTraverse,
    eFsDumpDirNoTraverse,
    eFsDumpFile,
    eFsDump_Last
};

#define FSDMP_DEFAULT_MASKED_ATTRIBS ( FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL )
//
//  The dump parameters and methods to write to the dump file and error log
//  file.
//
class CDumpParameters
{
public:
    //  Set up defaults for the parameters
    CDumpParameters(
        IN DWORD dwReserved
        ) : m_eFsDumpType( eFsDumpVolume ),
            m_fpErrLog( stderr ),
            m_fpDump( stdout ),
            m_fpExtraInfoDump( stdout ),
            m_bNoChecksums( FALSE ),
            m_bHex( FALSE ),
            m_bDontTraverseMountpoints( FALSE ),
            m_bDontChecksumHighLatencyData( TRUE ),
            m_bNoSpecialReparsePointProcessing( FALSE ),
            m_bAddMillisecsToTimestamps( FALSE ),
            m_bDontShowDirectoryTimestamps( TRUE ),
            m_bUnicode( FALSE),
            m_bNoHeaderFooter( TRUE ),
            m_bDumpCommaDelimited( TRUE ),
            m_bUseExcludeProcessor( FALSE ),
            m_bDontUseRegistryExcludes( FALSE ),
            m_bPrintDebugInfo( FALSE ),
            m_bHaveSecurityPrivilege( TRUE ),
            m_dwFileAttributesMask( FSDMP_DEFAULT_MASKED_ATTRIBS ),
            m_bDisableLongPaths( FALSE ),
            m_bEnableSDCtrlWordDump( TRUE ),
            m_bEnableObjectIdExtendedDataChecksums( FALSE ),
            m_bShowSymbolicSIDNames( FALSE ) { ; }

    virtual ~CDumpParameters();

    WCHAR       m_pwszULongHexFmt[16];  // Checksum printf style format
    EFsDumpType m_eFsDumpType;
    CBsString   m_cwsErrLogFileName;
    CBsString   m_cwsDumpFileName;
    CBsString   m_cwsArgv0;
    CBsString   m_cwsFullPathToEXE;
    BOOL        m_bNoChecksums;
    BOOL        m_bUnicode;
    BOOL        m_bHex;
    BOOL        m_bDontTraverseMountpoints;
    BOOL        m_bDontChecksumHighLatencyData;
    BOOL        m_bNoSpecialReparsePointProcessing;
    BOOL        m_bAddMillisecsToTimestamps;
    BOOL        m_bDontShowDirectoryTimestamps;
    BOOL        m_bShowSymbolicSIDNames;
    BOOL        m_bNoHeaderFooter;
    BOOL        m_bDumpCommaDelimited;
    BOOL        m_bUseExcludeProcessor;
    BOOL        m_bDontUseRegistryExcludes;
    BOOL        m_bPrintDebugInfo;
    BOOL        m_bDisableLongPaths;
    BOOL        m_bHaveSecurityPrivilege;
    BOOL        m_bEnableObjectIdExtendedDataChecksums;
    BOOL        m_bEnableSDCtrlWordDump;    //  This is a temporary flag
    DWORD       m_dwFileAttributesMask;

    INT
    Initialize(
        IN INT argc,
        IN WCHAR *argv[]
        );

    //  Adds a wprintf style string to the error log file, automatically puts
    //  a CR-LF at the end of each line
    inline VOID ErrPrint(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        ::fwprintf( m_fpErrLog, L"  *** ERROR: " );
        va_list marker;
        va_start( marker, pwszMsgFormat );
        ::vfwprintf( m_fpErrLog, pwszMsgFormat, marker );
        va_end( marker );
        ::fwprintf( m_fpErrLog, m_bUnicode ? L"\r\n" : L"\n" );
    }

    //  Adds a wprintf style string to the dump file, automatically puts
    //  a CR-LF at the end of each line
    inline VOID DumpPrintAlways(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        va_list marker;
        va_start( marker, pwszMsgFormat );
        ::vfwprintf( m_fpDump, pwszMsgFormat, marker );
        va_end( marker );
        ::fwprintf( m_fpDump, m_bUnicode ? L"\r\n" : L"\n" );
    }

    inline VOID DumpPrint(
        IN LPCWSTR pwszMsgFormat,
        IN ...
        )
    {
        if ( m_fpExtraInfoDump != NULL )
        {
            va_list marker;
            va_start( marker, pwszMsgFormat );
            ::vfwprintf( m_fpExtraInfoDump, pwszMsgFormat, marker );
            va_end( marker );
            ::fwprintf( m_fpExtraInfoDump, m_bUnicode ? L"\r\n" : L"\n" );
        }
    }

    inline FILE *GetDumpFile() { return m_fpExtraInfoDump; }
    inline FILE *GetDumpAlwaysFile() { return m_fpDump; }
    inline FILE *GEtErrLogFile() { return m_fpErrLog; }

private:
    CDumpParameters() {}   //  Disallow copying
    FILE *m_fpErrLog;
    FILE *m_fpDump;
    FILE *m_fpExtraInfoDump;
};

#endif // __H_PARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\bsfixalloc.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.cpp

Abstract:

    Adapted from MFC 6 SR 1 release of fixalloc.cpp.  Removed all MFC stuff.

Author:

    Stefan R. Steiner   [ssteiner]        4-10-2000

Revision History:

--*/

// fixalloc.cpp - implementation of fixed block allocator

#include "stdafx.h"
#include "bsfixalloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

// #define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

CBsFixedAlloc::CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize)
{
	ASSERT(nAllocSize >= sizeof(CNode));
	ASSERT(nBlockSize > 1);
    //wprintf( L"CBsFixedAlloc called, nAllocSize: %d, nBlockSize: %d\n", nAllocSize, nBlockSize );
	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
	InitializeCriticalSection(&m_protect);
}

CBsFixedAlloc::~CBsFixedAlloc()
{
	FreeAll();
	DeleteCriticalSection(&m_protect);
}

void CBsFixedAlloc::FreeAll()
{
	EnterCriticalSection(&m_protect);
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
	LeaveCriticalSection(&m_protect);
}

void* CBsFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	if (m_pNodeFree == NULL)
	{
		CBsPlex* pNewBlock = NULL;
		try
		{
			// add another block
			pNewBlock = CBsPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);
            //wprintf( L"Alloc getting more core, nAllocSize: %d\n", m_nAllocSize );
		}
		catch( ... )
		{
			LeaveCriticalSection(&m_protect);
			throw;
		}

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;

	LeaveCriticalSection(&m_protect);
	return pNode;
}

void CBsFixedAlloc::Free(void* p)
{
	if (p != NULL)
	{
		EnterCriticalSection(&m_protect);

		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
		LeaveCriticalSection(&m_protect);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBsPlex
// throws E_OUTOFMEMORY

CBsPlex* PASCAL CBsPlex::Create(CBsPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CBsPlex* p = (CBsPlex*) new BYTE[sizeof(CBsPlex) + nMax * cbElement];
	if ( p == NULL )    //  prefix #118827
	    throw E_OUTOFMEMORY;
	
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CBsPlex::FreeDataChain()     // free this one and links
{
	CBsPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CBsPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\vs_hash.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bshash.h

Abstract:

    Template for a hash table class.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    3/9/2000    SSteiner    Converted it for use with fsdump
	10/27/1999	aoltean		Took it from bscommon and remove the critical section.

--*/


#ifndef _H_BS_HASH_
#define _H_BS_HASH_

#define BSHASHMAP_NO_ERROR 0
#define BSHASHMAP_ALREADY_EXISTS 1
#define BSHASHMAP_OUT_OF_MEMORY 2
//
//  Forward defines
//

template< class KeyType, class ValueType > class TBsHashMapBucket;
template< class KeyType, class ValueType > class TBsHashMapBucketElem;

//
//  The equality test
//
inline BOOL AreKeysEqual( const PSID& lhK, const PSID& rhK )
{
    return ( ::EqualSid( lhK, rhK ) );
}

inline BOOL AreKeysEqual( const LPCWSTR& lhK, const LPCWSTR& rhK ) 
{ 
    return (::wcscmp(lhK, rhK) == 0); 
}

template < class KeyType >
inline BOOL AreKeysEqual( const KeyType& lhK, const KeyType& rhK ) 
{ 
    return ( ::memcmp( &lhK, &rhK, sizeof KeyType ) == 0 );
//    return lhK == rhK; 
}

//
//  Some possible hash table sizes
//
#define BSHASHMAP_HUGE 65521
#define BSHASHMAP_LARGE 4091
#define BSHASHMAP_MEDIUM 211
#define BSHASHMAP_SMALL 23

//
//  template< class KeyType, class ValueType > class bshashmap
//
//  TBsHashMap template.  Uses a hash table to maintain a mapping of KeyType
//  keys to ValueType values.
//
//template < class KeyType, class ValueType > typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

/*
Hash table class. methods hash the key value to the correct bucket, the bucket
class methods then operate on the element list associated with the bucket.
*/
template < class KeyType, class ValueType >
class TBsHashMap 
{
public:
    typedef LONG ( *PFN_HASH_FUNC )( const KeyType& Key, LONG NumBuckets );
    typedef TBsHashMapBucket< KeyType, ValueType > BucketType;
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

    TBsHashMap( LONG NumBuckets = BSHASHMAP_SMALL, PFN_HASH_FUNC pfHashFunc = DefaultHashFunc )
        : m_pfHashFunc( pfHashFunc ), 
          m_cNumBuckets( NumBuckets ), 
          m_cNumElems( 0 ) 
    { 
        m_pHashTab = new BucketType [ m_cNumBuckets ];
        if ( m_pHashTab == NULL ) {
            m_cNumBuckets = 0;
            throw E_OUTOFMEMORY;    // fix future prefix bug
        }
        m_pElemEnum = NULL;
        m_bInEnum = FALSE;
    }
    
    virtual ~TBsHashMap() 
    {
                

        Unlock();  // unlock the CS from either StartEnum() or TryEnterCriticalSection()

        //
		// First go through the double-linked list and delete all of the elements
		//

        for ( ElemType *pElem = m_ElemChainHead.m_pForward, *pNextElem = pElem->m_pForward;
              pElem != &m_ElemChainHead;
              pElem = pNextElem, pNextElem = pNextElem->m_pForward )
            delete pElem;
        delete [] m_pHashTab;
    }

    //  Clear all entries
    void Clear() 
    {
        if ( m_cNumElems == 0 )
            return; // no work to do
        Lock();
        for ( ElemType *pElem = m_ElemChainHead.m_pForward, *pNextElem = pElem->m_pForward;
              pElem != &m_ElemChainHead;
              pElem = pNextElem, pNextElem = pNextElem->m_pForward )
            delete pElem;
        delete [] m_pHashTab;
        m_pHashTab = new BucketType [ m_cNumBuckets ];
        if ( m_pHashTab == NULL ) {
            m_cNumBuckets = 0;
            throw E_OUTOFMEMORY;    // fix future prefix bug
        }
        m_pElemEnum = NULL;
        m_cNumElems = 0;
        Unlock();
    }

    // returns:
    //   BSHASHMAP_NO_ERROR - successful completion
    //   BSHASHMAP_OUT_OF_MEMORY - out of memory
    //   BSHASHMAP_ALREADY_EXISTS - Key already exists in map.  Old value is
    //       replaced by passed in Value.
    
	LONG Insert( 
	    IN const KeyType& Key, 
	    IN const ValueType& Value,
	    OUT void **ppCookie = NULL
	    ) 
	{
        Lock();
        LONG status;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );

        assert( hashVal % m_cNumBuckets == hashVal );

        status = m_pHashTab[ hashVal ].Insert( Key, Value, &m_ElemChainHead );

        if ( status == BSHASHMAP_NO_ERROR ) {
            ++m_cNumElems;
            if ( ppCookie != NULL )
                *ppCookie = ( void * )m_ElemChainHead.m_pBackward;
        }
        Unlock();
        return status;
    }

    // Erase an entry. Returns TRUE if it succeeds.
    BOOL Erase( const KeyType& Key ) 
    {
        Lock();
        BOOL erased = FALSE;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        
        assert( hashVal % m_cNumBuckets == hashVal );

        erased = m_pHashTab[ hashVal ].Erase( Key, &m_ElemChainHead );
        if ( erased ) {
            --m_cNumElems;
        }
        Unlock();
        return erased;
    }

    // Erase by cookie
    BOOL EraseByCookie( void *pCookie ) 
    {
        Lock();
        
        BucketType::EraseElement( ( ElemType *)pCookie );
        --m_cNumElems;
        
        Unlock();
        return TRUE;
    }
   
    // Find an entry.  Returns TRUE if it succeeds.  pValue may be NULL, in
    // which case this method is just a test of existence
    BOOL Find( const KeyType& Key, ValueType *pValue = NULL ) 
    {
        Lock();
        ElemType *pElem;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        BOOL found = FALSE;

        assert( hashVal % m_cNumBuckets == hashVal );

        found = m_pHashTab[ hashVal ].Find( Key, &pElem );
        if ( found && pValue != NULL ) {
            *pValue = pElem->m_Value;
        }
        Unlock();
        return found;
    }

    // Find an entry and return a pointer to the value to allow inplace update.  The
    // caller must call Unlock() when finished with the Value item.  If the item is
    // not found, this method returns FALSE and hash table is not locked.
    BOOL FindForUpdate( const KeyType& Key, ValueType **ppValue ) 
    {
        Lock();
        ElemType *pElem;
        LONG hashVal = (*m_pfHashFunc)( Key, m_cNumBuckets );
        BOOL found = FALSE;

        assert( hashVal % m_cNumBuckets == hashVal );

        found = m_pHashTab[ hashVal ].Find( Key, &pElem );
        if ( found ) {
            *ppValue = &(pElem->m_Value);
        } else
            Unlock();   //  Item not found so unlock the table
        return found;
    }

    // Default hash function
    static LONG DefaultHashFunc( const KeyType &Key, LONG NumBuckets ) 
    {
        const BYTE *pByteKey = (BYTE *)&Key;
        LONG dwHashVal = 0;
    
        for ( LONG i = 0; i < sizeof KeyType; ++i ) {
            dwHashVal += pByteKey[i];
        }
//        wprintf( L"Key: dwSerialNum: %u, hashed to: %u\n", Key.m_dwVolSerialNumber, dwHashVal % NumBuckets );
        // cout << "Key: " << Key << " hashed to: " << dwHashVal % NumBuckets << endl;
        return dwHashVal % NumBuckets;
    }

    // Start enumerating all entries in the hash table. Always returns TRUE.
	// Sets the index to the first element in the list. Lock() calls 
	// EnteringCriticalSection.
    BOOL StartEnum() 
    {
        assert( m_bInEnum == FALSE );
        Lock(); // Enumerating the table locks out all other threads
        m_pElemEnum = m_ElemChainHead.m_pForward; // Start at the head of the double-linked list
        m_bInEnum = TRUE;
        return TRUE;
    }

    // Returns the value of the current entry, and then moves the index
	// to the next item in the list. Must call StartEnum() first.
    BOOL GetNextEnum( KeyType *pKey, ValueType *pValue ) 
    {
        assert( m_bInEnum == TRUE );
        if ( m_pElemEnum == &m_ElemChainHead )
            return FALSE;  // Finished enumerating
        *pKey       = m_pElemEnum->m_Key;
        *pValue     = m_pElemEnum->m_Value;
        m_pElemEnum = m_pElemEnum->m_pForward;
        return TRUE;
    }

    // End enumerating the table.  This function must be called when finished, 
	// otherwise other threads will not be able to get past the critical section,
	// because the Unlock() call below, calls LeavingCriticalSection().
    BOOL EndEnum() 
    {
        assert( m_bInEnum == TRUE );
        m_pElemEnum = NULL;
        m_bInEnum = FALSE;
        Unlock();
        return TRUE;
    }

    LONG Size() 
    { 
        return m_cNumElems; 
    }
    
    LONG NumBuckets() 
    { 
        return m_cNumBuckets; 
    }
    
    inline void Lock() 
    { 
    }
    
    inline void Unlock() 
    { 
    }

private:
    BucketType *m_pHashTab;
    LONG m_cNumBuckets;
    LONG m_cNumElems;
    ElemType m_ElemChainHead;  // head of double-linked list of all elements
    ElemType *m_pElemEnum; // Current position of the enumeration
    BOOL m_bInEnum; // true StartEnum() was called and EndEnum() hasn't
    PFN_HASH_FUNC m_pfHashFunc;
};

/* 
Hash bucket class. Methods operate on the element list associated with the hash bucket
*/
template < class KeyType, class ValueType >
class TBsHashMapBucket {
    friend class TBsHashMap< KeyType, ValueType >;

private:
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;
    TBsHashMapBucket( )
    { 
        m_pHead = NULL; // done here to allow for easier debugging
    }
    
    virtual ~TBsHashMapBucket( ) 
    { 
        ; 
    }  // -- not really needed; however, if commented out, memory exception occurs during destruction
    
	
	/*
	Adds an element to the hash table. If the Key for the new element already 
	exists, in the table, set the key's vvalue to this new value, in the table.
	*/
	LONG Insert( const KeyType &Key, const ValueType &Val, ElemType *pElemChainHead ) 
	{        
		ElemType *pElem;
        
		//
		// if the element exists in this hash bucket's element list, set the new value
		//
		
		if ( Find( Key, &pElem ) == TRUE ) {
            pElem->m_Value = Val;
            return BSHASHMAP_ALREADY_EXISTS;
        }
        
		//
		// if the element doesn't exist, create a new element
		//

        ElemType *pVal = new ElemType( Key, Val );
        if ( pVal == NULL ) {
            return BSHASHMAP_OUT_OF_MEMORY;
        }
        
		//
		// Add the element into the hash bucket list
		//

        if ( m_pHead != NULL )
            m_pHead->m_ppPrevious = &(pVal->m_pNext);
        pVal->m_pNext      = m_pHead;
        m_pHead            = pVal;
        pVal->m_ppPrevious = &m_pHead;
        
		//
		// Set the back pointer -  double-linked list of elements
		//

        pVal->m_pBackward = pElemChainHead->m_pBackward;
        pVal->m_pForward  = pElemChainHead;
        pVal->m_pBackward->m_pForward  = pVal;
        pElemChainHead->m_pBackward = pVal;
        return BSHASHMAP_NO_ERROR;
    }

	/*
	Deletes an element from this hash bucket's list, within the hash table. 
	*/
    BOOL Erase( const KeyType &Key, ElemType *pElemChainHead ) 
    {
		//
		// Walk the list of elements for this hash bucket
		//

        for ( ElemType *pElem = m_pHead; pElem != NULL; pElem = pElem->m_pNext ) {
            
			//
			// if the key is found, delete it from the hash bucket's list.
			//
			
			if ( AreKeysEqual( pElem->m_Key, Key ) ) {
			    EraseElement( pElem );
                return TRUE;
            }
        }
        return FALSE;
    }

    /*
    Erases one element from the two chains
    */
    inline static void EraseElement( ElemType *pElem )
    {
        assert( pElem->IsValid() );
        
        // remove it from the hash chain
        if ( pElem->m_pNext != NULL )
            pElem->m_pNext->m_ppPrevious = pElem->m_ppPrevious;
        *( pElem->m_ppPrevious ) = pElem->m_pNext;

        // remove it from the double-linked list of elements
        pElem->m_pBackward->m_pForward = pElem->m_pForward;
        pElem->m_pForward->m_pBackward = pElem->m_pBackward;
        delete pElem;
    }
    
	/*
	Looks for an element in the list associated with this hash bucket. 
	*/
    BOOL Find( const KeyType &Key, ElemType **ppElemFound ) 
    {
		//
		// Walk the list for this bucket, looking for the key.
		//

        for ( ElemType *pElem = m_pHead; pElem != NULL; pElem = pElem->m_pNext ) {
            if ( AreKeysEqual( pElem->m_Key,  Key ) ) {
                *ppElemFound = pElem;
                return TRUE;
            }
        }
        *ppElemFound = NULL;
        return FALSE;
    }

private:
    ElemType *m_pHead;    
};

//
//  template< class KeyType, class ValueType > class TBsHashMapBucketElem
//
//  Template for individual elements in a bucket of a CMap
//
#define BS_HASH_ELEM_SIGNATURE "ELEMTYPE"
#define BS_HASH_ELEM_SIGNATURE_LEN 8

template< class KeyType, class ValueType >
class TBsHashMapBucketElem {
    friend class TBsHashMapBucket< KeyType, ValueType >;
    friend class TBsHashMap< KeyType, ValueType >;

private:
    typedef TBsHashMapBucketElem< KeyType, ValueType > ElemType;

    TBsHashMapBucketElem() : m_ppPrevious( NULL ),
                            m_pNext( NULL )
    {
        m_pForward  = this;
        m_pBackward = this;
    }

    TBsHashMapBucketElem( const KeyType K, const ValueType V ) : m_Key( K ), m_Value( V )
    { 
#ifdef _DEBUG
        memcpy( m_sSignature, BS_HASH_ELEM_SIGNATURE, sizeof( m_sSignature ) / sizeof( char ) );
#endif       
    }

    BOOL
    IsValid()
    {
        assert( this != NULL );
#ifdef _DEBUG
        return( memcmp( m_sSignature, BS_HASH_ELEM_SIGNATURE, sizeof( m_sSignature ) / sizeof( char ) ) == 0 );
#else
        return TRUE;
#endif  
    }
    
    virtual ~TBsHashMapBucketElem() 
    { 
#ifdef _DEBUG   // make sure reuse of list will cause errors
        m_pNext     = NULL;
        m_pForward  = NULL;
        m_pBackward = NULL;
        memset( m_sSignature, 0xAA, sizeof( m_sSignature ) / sizeof( char ) );
#endif
    }

#ifdef _DEBUG
    char       m_sSignature[BS_HASH_ELEM_SIGNATURE_LEN];
#endif
    ElemType **m_ppPrevious; // pointer to previous reference
    ElemType  *m_pNext;      // pointer to next element in bucket
    ElemType  *m_pForward;   // forward pointer to next element in double-link list of all elements
    ElemType  *m_pBackward;  // backward pointer to next element in double-link list of all elements
    KeyType    m_Key;
    ValueType  m_Value;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\vs_list.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    vs_list.h

Abstract:

    CVssDLList definition

Author:

    Adi Oltean  [aoltean]  11/23/1999

Revision History:

    Stefan Steiner  [ssteiner]  02-21-2000
        Removed VolSnapshot specific code to reuse for fsdump.  Added
        the optional compiling of the signature checking code.
        
--*/

#ifndef __VSS_DLLIST_HXX__
#define __VSS_DLLIST_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

typedef PVOID VS_COOKIE;

/////////////////////////////////////////////////////////////////////////////
// Constants

const VS_COOKIE VS_NULL_COOKIE = NULL;

const DWORD VS_ELEMENT_SIGNATURE = 0x47e347e4;


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CVssDLList;
template <class T> class CVssDLListIterator;
template <class T> class CVssDLListElement;


/////////////////////////////////////////////////////////////////////////////
// CVssDLList


template <class T>
class CVssDLList
{
// Constructors& Destructors
private:
	CVssDLList(const CVssDLList&);

public:
	CVssDLList(): 
		m_pFirst(NULL), m_pLast(NULL), m_dwNumElements( 0 ) {};

	~CVssDLList()
	{
		ClearAll();
	}

// Attributes
public:

	bool IsEmpty() const;

    DWORD Size() { return m_dwNumElements; }
    
// Operations
public:

	VS_COOKIE Add( 
		IN	const T& object
		);

	VS_COOKIE AddTail( 
		IN	const T& object
		);

	bool Extract( 
		OUT	T& refObject
		);

	bool ExtractTail( 
		OUT	T& refObject
		);

	void ExtractByCookie( 
		IN	VS_COOKIE cookie,
		OUT	T& refObject
		);

	void ClearAll();

private:

	bool IsValid() const;

// Data members
private:
	CVssDLListElement<T>* m_pFirst;
	CVssDLListElement<T>* m_pLast;
    DWORD m_dwNumElements;
	friend class CVssDLListIterator<T>;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLListIterator

template <class T> 
class CVssDLListIterator
{
private:
	CVssDLListIterator();
	CVssDLListIterator(const CVssDLListIterator&);

public:

	CVssDLListIterator(const CVssDLList<T>& list): 
		m_List(list),
		m_pNextInEnum(list.m_pFirst)
	{};

	bool GetNext( OUT T& refObject );

    VOID Reset() { m_pNextInEnum = m_List.m_pFirst; }
private:
	const CVssDLList<T>& m_List;
	const CVssDLListElement<T>* m_pNextInEnum;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLListElement


template <class T>
class CVssDLListElement
{
// Constructors& Destructors
private:
	CVssDLListElement();
	CVssDLListElement(const CVssDLListElement&);

public:
	CVssDLListElement( IN	const T& object ): 
		m_Object(object), 
		m_pNext(NULL), 
		m_pPrev(NULL) 
		{
#ifndef NDEBUG
		m_dwSignature = VS_ELEMENT_SIGNATURE;
#endif		
		};

// Attributes
public:

	bool IsValid()	const 
	{ 
#ifndef NDEBUG
		return (m_dwSignature == VS_ELEMENT_SIGNATURE);
#else
        return ( TRUE );
#endif
	};

// Data members
public:
#ifndef NDEBUG
	DWORD m_dwSignature;
#endif
	CVssDLListElement* m_pPrev;
	CVssDLListElement* m_pNext;
	T m_Object;
};


/////////////////////////////////////////////////////////////////////////////
// CVssDLList implementation


template <class T>
bool CVssDLList<T>::IsEmpty() const
{
	assert(IsValid());

	return (m_pFirst == NULL);
}


template <class T>
VS_COOKIE CVssDLList<T>::Add( 
	IN	const T& object
	)
{
	assert(IsValid());

	CVssDLListElement<T>* pElement = new CVssDLListElement<T>(object);
	if (pElement == NULL)
		return VS_NULL_COOKIE;

	// Setting neighbour element links
	if (m_pFirst)
	{
		assert(m_pFirst->m_pPrev == NULL);
		m_pFirst->m_pPrev = pElement;
	}

	// Setting element links
	assert(pElement->m_pNext == NULL);
	assert(pElement->m_pPrev == NULL);
	if (m_pFirst)
		pElement->m_pNext = m_pFirst;

	// Setting list head links
	m_pFirst = pElement;
	if (m_pLast == NULL)
		m_pLast = pElement;

    ++m_dwNumElements;
    
	return reinterpret_cast<VS_COOKIE>(pElement);
}


template <class T>
VS_COOKIE CVssDLList<T>::AddTail( 
	IN	const T& object
	)
{
	assert(IsValid());

	CVssDLListElement<T>* pElement = new CVssDLListElement<T>(object);
	if (pElement == NULL)
		return VS_NULL_COOKIE;

	// Setting neighbour element links
	if (m_pLast)
	{
		assert(m_pLast->m_pNext == NULL);
		m_pLast->m_pNext = pElement;
	}

	// Setting element links
	assert(pElement->m_pNext == NULL);
	assert(pElement->m_pPrev == NULL);
	if (m_pLast)
		pElement->m_pPrev = m_pLast;

	// Setting list head links
	if (m_pFirst == NULL)
		m_pFirst = pElement;
	m_pLast = pElement;

    ++m_dwNumElements;
    
	return reinterpret_cast<VS_COOKIE>(pElement);
}


template <class T>
void CVssDLList<T>::ExtractByCookie( 
	IN	VS_COOKIE cookie,
	OUT	T& refObject
	)
{
	if (cookie == VS_NULL_COOKIE)
		return;

	CVssDLListElement<T>* pElement = 
		reinterpret_cast<CVssDLListElement<T>*>(cookie);

	assert(pElement);
	assert(pElement->IsValid());

	// Setting neighbours links
	if (pElement->m_pPrev)
		pElement->m_pPrev->m_pNext = pElement->m_pNext;
	if (pElement->m_pNext)
		pElement->m_pNext->m_pPrev = pElement->m_pPrev;

	// Setting list head links 
	if (m_pFirst == pElement)
		m_pFirst = pElement->m_pNext;
	if (m_pLast == pElement)
		m_pLast = pElement->m_pPrev;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;
	--m_dwNumElements;
}


template <class T>
bool CVssDLList<T>::Extract( 
	OUT	T& refObject
	)
{
	CVssDLListElement<T>* pElement = m_pFirst;
	if (pElement == NULL)
		return false;

	assert(pElement->IsValid());

	// Setting neighbours links
	assert(pElement->m_pPrev == NULL);
	if (pElement->m_pNext)
		pElement->m_pNext->m_pPrev = NULL;

	// Setting list head links 
	m_pFirst = pElement->m_pNext;
	if (m_pLast == pElement)
		m_pLast = NULL;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;

	--m_dwNumElements;
	return true;
}


template <class T>
bool CVssDLList<T>::ExtractTail( 
	OUT	T& refObject
	)
{
	CVssDLListElement<T>* pElement = m_pLast;
	if (pElement == NULL)
		return false;

	assert(pElement->IsValid());

	// Setting neighbours links
	assert(pElement->m_pNext == NULL);
	if (pElement->m_pPrev)
		pElement->m_pPrev->m_pNext = NULL;

	// Setting list head links 
	m_pLast = pElement->m_pPrev;
	if (m_pFirst == pElement)
		m_pFirst = NULL;

	// Destroying the element after getting the original object.
	refObject = pElement->m_Object;
	delete pElement;

	--m_dwNumElements;
	return true;
}


template <class T>
void CVssDLList<T>::ClearAll( 
	)
{
    CVssDLListElement<T>* pElement = m_pFirst;
    CVssDLListElement<T>* pNextElem;	
	while( pElement != NULL )
	{
	    pNextElem = pElement->m_pNext;
	    delete pElement;
	    pElement = pNextElem;
	}

	m_pFirst = NULL;
	m_pLast  = NULL;
	m_dwNumElements = 0;
}


template <class T>
bool CVssDLList<T>::IsValid()	const
{
	if ((m_pFirst == NULL) && (m_pLast == NULL))
		return true;
	if ((m_pFirst != NULL) && (m_pLast != NULL))
		return (m_pFirst->IsValid() && m_pLast->IsValid());
	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CVssDLListIterator implementation


template <class T>
bool CVssDLListIterator<T>::GetNext( OUT T& object )
{
	if (m_pNextInEnum == NULL)
		return false;
	else
	{
		object = m_pNextInEnum->m_Object;
		m_pNextInEnum = m_pNextInEnum->m_pNext;
		return true;
	}
}


#endif // __VSS_DLLIST_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\inc\volstate.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volstate.h

Abstract:

    Contains definition of the volume state class.  This class
    maintains state about one volume.

Author:

    Stefan R. Steiner   [ssteiner]        03-14-2000

Revision History:

--*/

#ifndef __H_VOLSTATE_
#define __H_VOLSTATE_

#include "exclproc.h"
#include "vs_hash.h"
#include "hardlink.h"

//
//  Definition of the volume id
//
struct SFsdVolumeId
{
    DWORD m_dwVolSerialNumber;

    inline BOOL IsEqual(
        IN SFsdVolumeId *psVolid
        )
    {
        return m_dwVolSerialNumber == psVolid->m_dwVolSerialNumber;
    }
};

//
//  Forward define
//
class CFsdVolumeState;

//
//  Definition of the list of volume state objects with SFsdVolumeId key.
//
typedef TBsHashMap< SFsdVolumeId, CFsdVolumeState * > FSD_VOLUME_STATE_LIST;

class CFsdVolumeStateManager
{
public:
    CFsdVolumeStateManager(
        IN CDumpParameters *pcDumpParameters
        );

    virtual ~CFsdVolumeStateManager();
    
    DWORD GetVolumeState(
        IN const CBsString& cwsVolumePath,
        OUT CFsdVolumeState **ppcVolState
        );

    VOID PrintExclusionInformation()
    {
        //  Pass the buck...
        m_pcExclManager->PrintExclusionInformation();
    }

    VOID PrintHardLinkInfo();
    
    static DWORD CFsdVolumeStateManager::GetVolumeIdAndPath( 
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsPathOnVolume,
        OUT SFsdVolumeId *psVolId,
        OUT CBsString& cwsVolPath
        );
    
private:
    CDumpParameters *m_pcParams;
    CFsdExclusionManager *m_pcExclManager;
    FSD_VOLUME_STATE_LIST m_cVolumeStateList;
};

class CFsdVolumeState
{
friend class CFsdVolumeStateManager;
public:
    CFsdVolumeState(
        IN CDumpParameters *pcDumpParameters,
        IN const CBsString& cwsVolumePath
        ) : m_pcParams( pcDumpParameters ),
            m_cHardLinkManager( pcDumpParameters, cwsVolumePath.GetLength() ),
            m_cwsVolumePath( cwsVolumePath ),
            m_pcFSExclProcessor( NULL ),
            m_dwFileSystemFlags( 0 ),
            m_dwMaxComponentLength( 0 ),
            m_dwVolSerialNumber( 0 ) { }
    
    virtual ~CFsdVolumeState() 
    {
        delete m_pcFSExclProcessor;
    }

    //
    //  DirPath is relative to this volume
    //
    inline BOOL IsExcludedFile(
        IN const CBsString &cwsFullDirPath,
        IN DWORD dwEndOfVolMountPointOffset,
        IN const CBsString &cwsFileName
        )
    {
        if ( m_pcFSExclProcessor == NULL )
            return FALSE;
        return m_pcFSExclProcessor->IsExcludedFile( cwsFullDirPath, dwEndOfVolMountPointOffset, cwsFileName );
    }
    
    inline BOOL IsNtfs() { return ( m_dwFileSystemFlags & FS_PERSISTENT_ACLS ); }
    inline LPCWSTR GetFileSystemName() { return m_cwsFileSystemName.c_str(); }
    inline LPCWSTR GetVolumePath() { return m_cwsVolumePath.c_str(); }

    BOOL IsHardLinkInList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        OUT SFileExtendedInfo *psExtendedInfo
        )
    {
        return m_cHardLinkManager.IsHardLinkInList( ullFileIndex, cwsDirPath, cwsFileName, psFileAttributeData, psExtendedInfo );
    }

    VOID AddHardLinkToList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        )
    {
        m_cHardLinkManager.AddHardLinkToList( ullFileIndex, cwsDirPath, cwsFileName, psFileAttributeData, psExtendedInfo );
    }

    VOID PrintHardLinkInfo()
    {
        //
        //  Pass it on...
        //
        m_cHardLinkManager.PrintHardLinkInfo();
    }
    
private:
    CFsdVolumeState();  //  No copying please
    CDumpParameters *m_pcParams; 
    CBsString m_cwsVolumePath;    // Path to the volume
    CBsString m_cwsFileSystemName;
    CFsdHardLinkManager m_cHardLinkManager;
    CFsdFileSystemExcludeProcessor *m_pcFSExclProcessor;
    DWORD m_dwFileSystemFlags;    // GetVolumeInformation() fs flags
    DWORD m_dwMaxComponentLength;
    DWORD m_dwVolSerialNumber;    // Should be volume GUID
};

#endif // __H_VOLSTATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\engine.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    engine.cpp

Abstract:

    The file system dump utility engine.

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

--*/

#include "stdafx.h"

#include "direntrs.h"
#include "extattr.h"

#include "engine.h"

static VOID 
TimeString(
    IN FILETIME *pFileTime,
    IN BOOL bAddMillisecsToTimestamps,
    OUT LPWSTR pwszTimeStr
    );

/*++

Routine Description:

    Performs the actual dump of the directory or file.

Arguments:

Return Value:

    <Enter return values here>

--*/
DWORD
CDumpEngine::PerformDump()
{
    //
    //  Perform the actual dump
    //
    DWORD dwRet;

    //
    //  Kind of a hack, set the no data string if we want something other than dashes
    //
    if ( m_pcParams->m_bDumpCommaDelimited )
        FsdEaSetNoDataString( L"" );
    
    //
    //  Volume state manager manages all state about all volumes that are encountered during
    //  the dump.
    //
    CFsdVolumeStateManager cFsdVolStateManager( m_pcParams );
    
    //
    //  Get information about the volume
    //
    CFsdVolumeState *pcFsdVolState;
    
    dwRet = cFsdVolStateManager.GetVolumeState( m_cwsDirFileSpec, &pcFsdVolState );
    assert( dwRet != ERROR_ALREADY_EXISTS );
    if ( dwRet != ERROR_SUCCESS )
        return dwRet;

    if ( m_pcParams->m_bDumpCommaDelimited )
    {
        m_pcParams->DumpPrintAlways( L"File name,Short Name,Creation date,Last modification date,File size,Attr,DACE,SACE,SDCtl,UNamChkS,DStr,DStrSize,DStrChkS,Prop,RPTag,RPSize,RPChkS,EncrChkS,DACLSize,DACLChkS,SACLSize,SACLChkS,NLnk,ObjectId,OIDChkS,FS,Owner Sid,Group Sid" );

        //
        //  Put the current time into the CSV dump file for easy detection of when
        //  dumps are taken
        //
        FILETIME sSysFT, sLocalFT;
        ::GetSystemTimeAsFileTime( &sSysFT );
        ::FileTimeToLocalFileTime( &sSysFT, &sLocalFT );
        WCHAR wszCurrentTime[32];    
        ::TimeString( &sLocalFT, FALSE, wszCurrentTime );        
        m_pcParams->DumpPrintAlways( L"Dump time: %s", wszCurrentTime );        
    }
    else
    {
//        if ( ( m_pcParams->m_eFsDumpType == eFsDumpVolume ) && 
//             ( m_cwsDirFileSpec != pcFsdVolState->GetVolumePath() ) )
//        {
//            m_pcParams->ErrPrint( L"'%s' is not a drive specifier or mountpoint, use -dd instead",
//                m_cwsDirFileSpec.c_str() );
//            return 1;
//        }
        
        m_pcParams->DumpPrintAlways( L"\nDumping: '%s' on volume '%s'", m_cwsDirFileSpec.c_str(), pcFsdVolState->GetVolumePath() );
        
        if ( m_pcParams->m_bAddMillisecsToTimestamps )
            m_pcParams->DumpPrintAlways( 
                L"   Creation date           Last modification date   FileSize        Attr FileName                         ShortName    DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
        else
            m_pcParams->DumpPrintAlways( L"   Creation date       Last mod. date       FileSize        Attr FileName                         ShortName    DACE SACE SDCtl UNamChkS DStr DStrSize DStrChkS Prop RPTag    RPSize RPChkS   EncrChkS DACLSize DACLChkS SACLSize SACLChkS NLnk ObjectId                             OIDChkS OwnerSid/GroupSid" );
    }


    ////////////////////////////////////////////////////////////////////
    //
    //  Get the file info for the root dir or file
    //  Bug # 157915
    //
    ////////////////////////////////////////////////////////////////////
    bool bRootIsADir = true;
    CBsString cwsDirFileSpecWithoutSlash( m_cwsDirFileSpec );
    if ( cwsDirFileSpecWithoutSlash.Right( 1 ) == L"\\" )
        cwsDirFileSpecWithoutSlash = cwsDirFileSpecWithoutSlash.Left( cwsDirFileSpecWithoutSlash.GetLength() - 1 );
    try
    {
        CDirectoryEntries cRootEntry( 
            m_pcParams, 
            cwsDirFileSpecWithoutSlash
            );

        //
        //  Only one entry should be returned in either the directory list or file list
        //
        SDirectoryEntry *psDirEntry;
        
        //
        //  See if it is file entry
        //
        CDirectoryEntriesIterator *pListIter;
        pListIter = cRootEntry.GetFileListIterator();
        if ( pListIter->GetNext( psDirEntry ) )
        {
            bRootIsADir = false;
            ++m_ullNumFiles;
            m_ullNumBytesTotalUnnamedStream += ( ( ( ULONGLONG )psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) |
                                  psDirEntry->m_sFindData.nFileSizeLow;

            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED )
                ++m_ullNumEncryptedFiles;
            
            PrintEntry( pcFsdVolState, cwsDirFileSpecWithoutSlash, 
                cwsDirFileSpecWithoutSlash.GetLength(), psDirEntry, TRUE );

            ASSERT( pListIter->GetNext( psDirEntry ) == false );
        }
        delete pListIter;        

        //
        //  See if it is a directory entry
        //
        pListIter = cRootEntry.GetDirListIterator();
        if ( pListIter->GetNext( psDirEntry ) )
        {
            ASSERT( bRootIsADir );
            //  It is
            ++m_ullNumDirs;
            PrintEntry( pcFsdVolState, cwsDirFileSpecWithoutSlash, 
                cwsDirFileSpecWithoutSlash.GetLength(), psDirEntry, TRUE );

            ASSERT( pListIter->GetNext( psDirEntry ) == false );
        }
        delete pListIter;        
    }
    catch ( DWORD dwRet )
    {
        if ( dwRet == ERROR_INVALID_NAME || dwRet == ERROR_BAD_NET_NAME )
        {
            //
            //  Must be working with the root of the drive letter name space which
            //  means we do things slightly differently.
            //
            SDirectoryEntry sDirEntry;
            ::memset( &sDirEntry.m_sFindData, 0x00, sizeof( sDirEntry.m_sFindData ) );
            PrintEntry( pcFsdVolState, m_cwsDirFileSpec, 
                m_cwsDirFileSpec.GetLength(), &sDirEntry, TRUE );            
        }
        else
            m_pcParams->ErrPrint( L"PerformDump: Unexpected error trying to process '%s', dwRet: %d", 
                m_cwsDirFileSpec.c_str(), dwRet );            
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"ProcessDir() Caught an unexpected exception processing file: '%s', Last dwRet: %d", 
            m_cwsDirFileSpec.c_str(), ::GetLastError() );
    }
            
    //
    //  Now traverse into the volume/directory if necessary
    //
    if ( m_pcParams->m_eFsDumpType != eFsDumpFile )
    {
        if ( bRootIsADir )
        {
            dwRet = ProcessDir( 
                &cFsdVolStateManager, 
                pcFsdVolState, 
                m_cwsDirFileSpec, 
                m_cwsDirFileSpec.GetLength(),
                ::wcslen( pcFsdVolState->GetVolumePath() ) );
        }
        
        //
        //  Print out some stats about the dump
        //
        m_pcParams->DumpPrint( L"\nSTATISTICS for '%s':", m_cwsDirFileSpec.c_str() );
        if ( m_pcParams->m_bHex )
        {
            m_pcParams->DumpPrint( L"  Number of directories (including mountpoints):    %16I64x(hex)", m_ullNumDirs );
            m_pcParams->DumpPrint( L"  Number of files:                                  %16I64x(hex)", m_ullNumFiles );
            m_pcParams->DumpPrint( L"  Number of mountpoints:                            %16I64x(hex)", m_ullNumMountpoints );
            m_pcParams->DumpPrint( L"  Number of reparse points (excluding mountpoints): %16I64x(hex)", m_ullNumReparsePoints );
            m_pcParams->DumpPrint( L"  Number of hard-linked files:                      %16I64x(hex)", m_ullNumHardLinks );
            m_pcParams->DumpPrint( L"  Number of discrete DACL ACEs:                     %16I64x(hex)", m_ullNumDiscreteDACEs );
            m_pcParams->DumpPrint( L"  Number of discrete SACL ACEs:                     %16I64x(hex)", m_ullNumDiscreteSACEs );
            m_pcParams->DumpPrint( L"  Number of encrypted files:                        %16I64x(hex)", m_ullNumEncryptedFiles );
            m_pcParams->DumpPrint( L"  Number of files with object ids:                  %16I64x(hex)", m_ullNumFilesWithObjectIds );
            if ( m_pcParams->m_bUseExcludeProcessor )
                m_pcParams->DumpPrint( L"  Number of files excluded due to exclusion rules:  %16I64x(hex)", m_ullNumFilesExcluded );
            m_pcParams->DumpPrint( L"  Total bytes of checksummed data:                  %16I64x(hex)", m_ullNumBytesChecksummed );
            m_pcParams->DumpPrint( L"  Total bytes of unnamed stream data:               %16I64x(hex)", m_ullNumBytesTotalUnnamedStream );
            m_pcParams->DumpPrint( L"  Total bytes of named data stream data:            %16I64x(hex)", m_ullNumBytesTotalNamedDataStream );
        }
        else
        {
            m_pcParams->DumpPrint( L"  Number of directories (including mountpoints):    %16I64u", m_ullNumDirs );
            m_pcParams->DumpPrint( L"  Number of files:                                  %16I64u", m_ullNumFiles );
            m_pcParams->DumpPrint( L"  Number of mountpoints:                            %16I64u", m_ullNumMountpoints );
            m_pcParams->DumpPrint( L"  Number of reparse points (excluding mountpoints): %16I64u", m_ullNumReparsePoints );
            m_pcParams->DumpPrint( L"  Number of hard-linked files:                      %16I64u", m_ullNumHardLinks );
            m_pcParams->DumpPrint( L"  Number of discrete DACL ACEs:                     %16I64u", m_ullNumDiscreteDACEs );
            m_pcParams->DumpPrint( L"  Number of discrete SACL ACEs:                     %16I64u", m_ullNumDiscreteSACEs );
            m_pcParams->DumpPrint( L"  Number of encrypted files:                        %16I64u", m_ullNumEncryptedFiles );
            m_pcParams->DumpPrint( L"  Number of files with object ids:                  %16I64u", m_ullNumFilesWithObjectIds );
            if ( m_pcParams->m_bUseExcludeProcessor )
                m_pcParams->DumpPrint( L"  Number of files excluded due to exclusion rules:  %16I64u", m_ullNumFilesExcluded );
            m_pcParams->DumpPrint( L"  Total bytes of checksummed data:                  %16I64u", m_ullNumBytesChecksummed );
            m_pcParams->DumpPrint( L"  Total bytes of unnamed stream data:               %16I64u", m_ullNumBytesTotalUnnamedStream );
            m_pcParams->DumpPrint( L"  Total bytes of named data stream data:            %16I64u", m_ullNumBytesTotalNamedDataStream );
        }

        if ( m_pcParams->m_bUseExcludeProcessor )
        {
            //
            //  Print out exclusion information
            //
            cFsdVolStateManager.PrintExclusionInformation();
        }
        cFsdVolStateManager.PrintHardLinkInfo();
    }   
    
    return dwRet;
}


/*++

Routine Description:

    Traverses into a directory and dumps all the information about the dir.
    NOTE: This is a recursive function.
    
Arguments:

    cwsDirPath - The directory path or file to dump information about
    
Return Value:

    <Enter return values here>

--*/
DWORD 
CDumpEngine::ProcessDir( 
    IN CFsdVolumeStateManager *pcFsdVolStateManager,        
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN INT cDirFileSpecLength,
    IN INT cVolMountPointOffset
    )
{
    DWORD dwRet = ERROR_SUCCESS;

    try 
    {
        if ( !m_pcParams->m_bDumpCommaDelimited )
        {
            if ( cwsDirPath.GetLength() == cDirFileSpecLength )
            {
                //
                //  This is the root of the directory
                //
                m_pcParams->DumpPrintAlways( L"'.\\' - %s", ( pcFsdVolState != NULL ) ? pcFsdVolState->GetFileSystemName() : L"???" );
            }
            else
            {
                m_pcParams->DumpPrintAlways( L"'%s' - %s", cwsDirPath.c_str() + cDirFileSpecLength,
                    ( pcFsdVolState != NULL ) ? pcFsdVolState->GetFileSystemName() : L"???" );       
            }
        }
        
        //
        //  Get the directory entries for the directory/file
        //
        CDirectoryEntries cDirEntries( 
            m_pcParams, 
            cwsDirPath + L"*"
            );

        SDirectoryEntry *psDirEntry;

        //
        //  First dump out the sub-directory entries
        //
        CDirectoryEntriesIterator *pDirListIter;
        pDirListIter = cDirEntries.GetDirListIterator();
        while ( pDirListIter->GetNext( psDirEntry ) )
        {
            ++m_ullNumDirs;
            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
            {
                ++m_ullNumMountpoints;
            }
            PrintEntry( pcFsdVolState, cwsDirPath, cDirFileSpecLength, psDirEntry );
        }

        //
        //  Next dump out the non-sub-directory entries
        //
        CDirectoryEntriesIterator *pFileListIter;
        pFileListIter = cDirEntries.GetFileListIterator();
        while ( pFileListIter->GetNext( psDirEntry ) )
        {
            ++m_ullNumFiles;
            m_ullNumBytesTotalUnnamedStream += ( ( ( ULONGLONG )psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) |
                                  psDirEntry->m_sFindData.nFileSizeLow;

            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                ++m_ullNumReparsePoints;
            if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED )
                ++m_ullNumEncryptedFiles;
            
            //
            //  Check to see if we should exclude the file
            //
            if ( pcFsdVolState->IsExcludedFile( cwsDirPath, cVolMountPointOffset, psDirEntry->GetFileName() ) )
                ++m_ullNumFilesExcluded;
            else
                PrintEntry( pcFsdVolState, cwsDirPath, cDirFileSpecLength, psDirEntry );
        }
        delete pFileListIter;

        if (    m_pcParams->m_eFsDumpType == eFsDumpVolume 
             || m_pcParams->m_eFsDumpType == eFsDumpDirTraverse )
        {
            //
            //  Now traverse into each sub-directory
            //
            pDirListIter->Reset();
            CBsString cwsTraversePath;
            while ( pDirListIter->GetNext( psDirEntry ) )
            {
                if (    m_pcParams->m_bDontTraverseMountpoints
                     && psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                    continue;
                cwsTraversePath = cwsDirPath + psDirEntry->GetFileName();
                cwsTraversePath += L'\\';
                
                //
                //  Now go into recursion mode
                //
                if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                {
                    //
                    //  Traversing into another volume, get it's state
                    //
                    CFsdVolumeState *pcNewFsdVolState;
                    DWORD dwRet;
                    
                    dwRet = pcFsdVolStateManager->GetVolumeState( cwsTraversePath, &pcNewFsdVolState );
                    if ( dwRet == ERROR_ALREADY_EXISTS )
                    {
                        //
                        //  Mountpoint cycle, stop traversing.  Need to print the fully qualified
                        //  path if the traversal mountpoint is the same as the mountpoint
                        //  we started with, otherwise we AV.
                        //
                        INT cVolStateSpecLength;                        
                        cVolStateSpecLength = ( ::wcslen( pcNewFsdVolState->GetVolumePath() ) <= (size_t)cDirFileSpecLength )
                                               ? 0 : cDirFileSpecLength;
                        m_pcParams->DumpPrint( L"'%s' - Not traversing, already traversed through '%s' mountpoint", 
                            cwsTraversePath.c_str() + cDirFileSpecLength, pcNewFsdVolState->GetVolumePath() + cVolStateSpecLength );
                    }
                    else if ( dwRet == ERROR_SUCCESS )
                    {
                        ProcessDir( 
                            pcFsdVolStateManager, 
                            pcNewFsdVolState, 
                            cwsTraversePath, 
                            cDirFileSpecLength,
                            ::wcslen( pcNewFsdVolState->GetVolumePath() ) );
                    }
                    else
                    {
                        //
                        //  Error message already printed out
                        //
                    }
                }
                else
                {
                    ProcessDir( 
                        pcFsdVolStateManager, 
                        pcFsdVolState, 
                        cwsTraversePath, 
                        cDirFileSpecLength,
                        cVolMountPointOffset );
                }
            }
        }
        
        delete pDirListIter;
    }    
    catch ( DWORD dwRet )
    {
        m_pcParams->ErrPrint( L"ProcessDir: Error trying to process '%s' directory, dwRet: %d", cwsDirPath.c_str(), dwRet );
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"ProcessDir() Caught an unexpected exception processing dir: '%s', Last dwRet: %d", 
            cwsDirPath.c_str(), ::GetLastError() );
    }
    
    return 0;
}


//
//  printf style format strings which format each line
//
#define DIR_STR      L"<DIR>"
#define JUNCTION_STR L"<JUNCTION>"
#define FMT_DIR_STR_HEX  L"   %s %s %-16s %04x %-32s %-12s %4d %4d  %04x -------- %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %%s/%s"
#define FMT_DIR_STR      L"   %s %s %-16s %04x %-32s %-12s %4d %4d  %04x -------- %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define FMT_FILE_STR_HEX L"   %s %s %16I64x %04x %-32s %-12s %4d %4d  %04x %s %4d %8I64x %s %4d %s %6hx %s %s %8hx %s %8hx %s %4d %36s %s %s/%s"
#define FMT_FILE_STR     L"   %s %s %16I64d %04x %-32s %-12s %4d %4d  %04x %s %4d %8I64d %s %4d %s %6hu %s %s %8hd %s %8hd %s %4d %36s %s %s/%s"
#define BLANKTIMESTAMPWITHOUTMS L"                   "
#define BLANKTIMESTAMPWITHMS    L"                       "

#define FMT_CSV_DIR_STR      L"\"'%s%s\\'\",%s,%s,%s,%s,0x%04x,%d,%d,0x%04x,,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s"
#define FMT_CSV_FILE_STR     L"\"'%s%s'\",%s,%s,%s,%I64d,0x%04x,%d,%d,0x%04x,%s,%d,%I64d,%s,%d,%s,%hu,%s,%s,%hd,%s,%hd,%s,%d,%s,%s,%s,%s,%s"

/*++

Routine Description:

    Prints out all the information about one directory entry.

Arguments:

    cwsDirPath - The path leading up to the entry

    psDirEntry - The directory entry information
    
Return Value:

    NONE

--*/
VOID 
CDumpEngine::PrintEntry(
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN INT cDirFileSpecLength,
    IN SDirectoryEntry *psDirEntry,
    IN BOOL bSingleEntryOutput    
    )
{
    WIN32_FILE_ATTRIBUTE_DATA *pFD = &psDirEntry->m_sFindData;
    LPWSTR pwszFmtStr;
    WCHAR wszCreationTime[32];    
    WCHAR wszLastWriteTime[32];    
 
    //
    //  Get the additional information about the file/dir
    //
    SFileExtendedInfo sExtendedInfo;
    ::GetExtendedFileInfo( m_pcParams, pcFsdVolState, cwsDirPath, bSingleEntryOutput, psDirEntry, &sExtendedInfo );

    //
    //  Convert the timestamps into formatted strings
    //
    if (    pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY 
         && m_pcParams->m_bDontShowDirectoryTimestamps )
    {
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            wszCreationTime[0]  = L'\0';
            wszLastWriteTime[0] = L'\0';
        }
        else if ( m_pcParams->m_bAddMillisecsToTimestamps )
        {
            ::wcscpy( wszCreationTime, BLANKTIMESTAMPWITHMS );
            ::wcscpy( wszLastWriteTime, BLANKTIMESTAMPWITHMS );
        }
        else
        {
            ::wcscpy( wszCreationTime, BLANKTIMESTAMPWITHOUTMS );
            ::wcscpy( wszLastWriteTime, BLANKTIMESTAMPWITHOUTMS );
        }   
    }
    else
    {
        TimeString( &psDirEntry->m_sFindData.ftCreationTime, 
            m_pcParams->m_bAddMillisecsToTimestamps, 
            wszCreationTime );
        TimeString( &psDirEntry->m_sFindData.ftLastWriteTime, 
            m_pcParams->m_bAddMillisecsToTimestamps, 
            wszLastWriteTime );
    }
    
    //
    //  Mask out the requested file attribute bits
    //
    pFD->dwFileAttributes &= ~m_pcParams->m_dwFileAttributesMask;
 
    m_ullNumBytesChecksummed          += sExtendedInfo.ullTotalBytesChecksummed;
    m_ullNumBytesTotalNamedDataStream += sExtendedInfo.ullTotalBytesNamedDataStream;
    if ( sExtendedInfo.lNumberOfLinks > 1 )
        ++m_ullNumHardLinks;
    if ( sExtendedInfo.lNumDACEs != -1 )
        m_ullNumDiscreteDACEs += sExtendedInfo.lNumDACEs;
    if ( sExtendedInfo.lNumSACEs != -1 )
        m_ullNumDiscreteSACEs += sExtendedInfo.lNumSACEs;
    if ( !sExtendedInfo.cwsObjectId.IsEmpty() )
        ++m_ullNumFilesWithObjectIds;
    
    WCHAR wszReparsePointTag[32];
    
    if ( sExtendedInfo.ulReparsePointTag == 0 )
    {
        if ( m_pcParams->m_bDumpCommaDelimited )
            wszReparsePointTag[0] = L'\0';
        else
            ::memcpy( wszReparsePointTag, L"--------", sizeof( WCHAR ) * 9 );
    }
    else
    {
        wsprintf( wszReparsePointTag, m_pcParams->m_pwszULongHexFmt, sExtendedInfo.ulReparsePointTag );
    }
    
    if ( pFD->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        LPWSTR pwszDirType;
        if ( pFD->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
            pwszDirType = JUNCTION_STR;
        else
            pwszDirType = DIR_STR;
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            //
            //  If single file output mode, then processing the root directory
            //
            if ( bSingleEntryOutput )
                psDirEntry->m_cwsFileName = L".";
            
            CBsString cwsFixedShortName;
            if ( !psDirEntry->GetShortName().IsEmpty() )
            {
                cwsFixedShortName = L"\"'" + psDirEntry->GetShortName() + L"'\"";
            }
            
            m_pcParams->DumpPrintAlways( FMT_CSV_DIR_STR, 
                            cwsDirPath.c_str() + cDirFileSpecLength,
                            LPCWSTR( psDirEntry->GetFileName() ),
                            LPCWSTR( cwsFixedShortName ),
                            wszCreationTime,
                            wszLastWriteTime,
                            pwszDirType,
                            pFD->dwFileAttributes,
                            sExtendedInfo.lNumDACEs,
                            sExtendedInfo.lNumSACEs,
                            sExtendedInfo.wSecurityDescriptorControl,
                            sExtendedInfo.lNumNamedDataStreams,
                            sExtendedInfo.ullTotalBytesNamedDataStream,
                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
                            sExtendedInfo.lNumPropertyStreams,
                            wszReparsePointTag,
                            sExtendedInfo.wReparsePointDataSize,
                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
                            sExtendedInfo.wDACLSize,
                            sExtendedInfo.cwsDACLChecksum.c_str(),
                            sExtendedInfo.wSACLSize,
                            sExtendedInfo.cwsSACLChecksum.c_str(),
                            sExtendedInfo.lNumberOfLinks,
                            sExtendedInfo.cwsObjectId.c_str(),
                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
                            pcFsdVolState->GetFileSystemName(),
                            sExtendedInfo.cwsOwnerSid.c_str(),
                            sExtendedInfo.cwsGroupSid.c_str() );
        }
        else
        {
            //
            //  If single file output mode, then processing the root directory
            //
            if ( bSingleEntryOutput )
                psDirEntry->m_cwsFileName = L".";
            
            //
            //  Print with quotes around the file name
            //
            WCHAR wszNameWithQuotes[ MAX_PATH + 2 ];
            wszNameWithQuotes[ 0 ] = L'\'';
            ::wcscpy( wszNameWithQuotes + 1, psDirEntry->GetFileName() );
            ::wcscat( wszNameWithQuotes, L"\\\'" );
    
            if ( m_pcParams->m_bHex )
                pwszFmtStr = FMT_DIR_STR_HEX;
            else
                pwszFmtStr = FMT_DIR_STR;
            m_pcParams->DumpPrintAlways( pwszFmtStr, 
                            wszCreationTime,
                            wszLastWriteTime,
                            pwszDirType,
                            pFD->dwFileAttributes,
                            wszNameWithQuotes,
                            LPCWSTR( psDirEntry->GetShortName() ),
                            sExtendedInfo.lNumDACEs,
                            sExtendedInfo.lNumSACEs,
                            sExtendedInfo.wSecurityDescriptorControl,
                            sExtendedInfo.lNumNamedDataStreams,
                            sExtendedInfo.ullTotalBytesNamedDataStream,
                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
                            sExtendedInfo.lNumPropertyStreams,
                            wszReparsePointTag,
                            sExtendedInfo.wReparsePointDataSize,
                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
                            sExtendedInfo.wDACLSize,
                            sExtendedInfo.cwsDACLChecksum.c_str(),
                            sExtendedInfo.wSACLSize,
                            sExtendedInfo.cwsSACLChecksum.c_str(),
                            sExtendedInfo.lNumberOfLinks,
                            sExtendedInfo.cwsObjectId.c_str(),
                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
                            sExtendedInfo.cwsOwnerSid.c_str(),
                            sExtendedInfo.cwsGroupSid.c_str() );
        }
    }
    else
    {        
        ULONGLONG ullFileSize = ( ( (ULONGLONG)pFD->nFileSizeHigh ) << 32 ) + pFD->nFileSizeLow;
        
        if ( m_pcParams->m_bDumpCommaDelimited )
        {
            CBsString cwsFixedShortName;
            if ( !psDirEntry->GetShortName().IsEmpty() )
            {
                cwsFixedShortName = L"\"'" + psDirEntry->GetShortName() + L"'\"";
            }
            
            m_pcParams->DumpPrintAlways( FMT_CSV_FILE_STR, 
                            cwsDirPath.c_str() + cDirFileSpecLength,
                            LPCWSTR( psDirEntry->GetFileName() ),
                            LPCWSTR( cwsFixedShortName ),
                            wszCreationTime,
                            wszLastWriteTime,
                            ullFileSize,
                            pFD->dwFileAttributes,
                            sExtendedInfo.lNumDACEs,
                            sExtendedInfo.lNumSACEs,
                            sExtendedInfo.wSecurityDescriptorControl,
                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
                            sExtendedInfo.lNumNamedDataStreams,
                            sExtendedInfo.ullTotalBytesNamedDataStream,
                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
                            sExtendedInfo.lNumPropertyStreams,
                            wszReparsePointTag,
                            sExtendedInfo.wReparsePointDataSize,
                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
                            sExtendedInfo.wDACLSize,
                            sExtendedInfo.cwsDACLChecksum.c_str(),
                            sExtendedInfo.wSACLSize,
                            sExtendedInfo.cwsSACLChecksum.c_str(),
                            sExtendedInfo.lNumberOfLinks,
                            sExtendedInfo.cwsObjectId.c_str(),
                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
                            pcFsdVolState->GetFileSystemName(),
                            sExtendedInfo.cwsOwnerSid.c_str(),
                            sExtendedInfo.cwsGroupSid.c_str() );
        }
        else
        {
            //
            //  Print with quotes around the file name
            //
            WCHAR wszNameWithQuotes[ MAX_PATH + 2 ];
            wszNameWithQuotes[ 0 ] = L'\'';
            ::wcscpy( wszNameWithQuotes + 1, psDirEntry->GetFileName() );
            ::wcscat( wszNameWithQuotes, L"\'" );

            if ( m_pcParams->m_bHex )
                pwszFmtStr = FMT_FILE_STR_HEX;
            else
                pwszFmtStr = FMT_FILE_STR;

            m_pcParams->DumpPrintAlways( pwszFmtStr, 
                            wszCreationTime,
                            wszLastWriteTime,
                            ullFileSize,
                            pFD->dwFileAttributes,
                            wszNameWithQuotes,
                            LPCWSTR( psDirEntry->GetShortName() ),
                            sExtendedInfo.lNumDACEs,
                            sExtendedInfo.lNumSACEs,
                            sExtendedInfo.wSecurityDescriptorControl,
                            sExtendedInfo.cwsUnnamedStreamChecksum.c_str(),
                            sExtendedInfo.lNumNamedDataStreams,
                            sExtendedInfo.ullTotalBytesNamedDataStream,
                            sExtendedInfo.cwsNamedDataStreamChecksum.c_str(),
                            sExtendedInfo.lNumPropertyStreams,
                            wszReparsePointTag,
                            sExtendedInfo.wReparsePointDataSize,
                            sExtendedInfo.cwsReparsePointDataChecksum.c_str(),
                            sExtendedInfo.cwsEncryptedRawDataChecksum.c_str(),
                            sExtendedInfo.wDACLSize,
                            sExtendedInfo.cwsDACLChecksum.c_str(),
                            sExtendedInfo.wSACLSize,
                            sExtendedInfo.cwsSACLChecksum.c_str(),
                            sExtendedInfo.lNumberOfLinks,
                            sExtendedInfo.cwsObjectId.c_str(),
                            sExtendedInfo.cwsObjectIdExtendedDataChecksum.c_str(),                            
                            sExtendedInfo.cwsOwnerSid.c_str(),
                            sExtendedInfo.cwsGroupSid.c_str() );
        }
    }
    
}


/*++

Routine Description:

    Formats dates into a common string format.

Arguments:

Return Value:

    <Enter return values here>

--*/
static VOID 
TimeString(
    IN FILETIME *pFileTime,
    IN BOOL bAddMillisecsToTimestamps,
    OUT LPWSTR pwszTimeStr
    )
{
    SYSTEMTIME szTime;
        
    ::FileTimeToSystemTime( pFileTime, &szTime );
    if ( bAddMillisecsToTimestamps )
    {
    	wsprintf( pwszTimeStr,
    	        L"%02d/%02d/%02d %02d:%02d:%02d.%03d",
                szTime.wMonth,
                szTime.wDay,
                szTime.wYear,
                szTime.wHour,
                szTime.wMinute,
                szTime.wSecond,
                szTime.wMilliseconds );
    }
    else
    {
    	wsprintf( pwszTimeStr,
    	        L"%02d/%02d/%02d %02d:%02d:%02d",
                szTime.wMonth,
                szTime.wDay,
                szTime.wYear,
                szTime.wHour,
                szTime.wMinute,
                szTime.wSecond );
    }
}

LPCSTR 
CDumpEngine::GetHeaderInformation()
{
    LPSTR pszHeaderInfo = 
        "Creation date     - Creation date of the file/dir\n"
        "Last mod. date    - Last modification date of the file/dir\n"
        "FileSize          - Size of the unnamed data stream if a file\n"
        "Attr              - File attributes with Archive and Normal bits masked by\n"
        "                    default (hex)\n"
        "FileName          - Name of the file in single quotes\n"
        "ShortName         - The classic 8.3 file name.  If <->, FileName is in\n"
        "                    classic format\n"
        "DACE              - Number of discretionary ACL entries\n"
        "SACE              - Number of system ACL entries\n"
        "SDCtl             - Security Descripter control word (hex)\n"
        "UNamChkS          - Data checksum of the unnamed data stream (hex)\n"
        "DStr              - Number of named data streams\n"
        "DStrSize          - Size of all of the named data streams\n"
        "DStrChkS          - Data checksum of all named data streams including their\n"
        "                    names (hex)\n"
        "Prop              - Number of property data streams\n"
        "RPTag             - Reparse point tag value (hex)\n"
        "RPSize            - Size of reparse point data\n"
        "RPChkS            - Checksum of the reparse point data (hex)\n"
        "EncrChkS          - Raw encrypted data checksum (hex)\n"
        "DACLSize          - Size of the complete discretionary ACL\n"
        "DACLChkS          - Checksum of the complete discretionary ACL (hex)\n"
        "SACLSize          - Size of the complete system ACL\n"
        "SACLChkS          - Checksum of the complete system ACL (hex)\n"
        "NLnk              - Number of hard links\n"
        "ObjectId          - Object Id GUID on the file if it has one\n"
        "OIDChkS           - Object Id extended data checksum\n"
        "FS                - Type of file system (in CSV format only)\n"
        "OwnerSid/GroupSid - The owner and group sid values\n";
    
    return pszHeaderInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\exclproc.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exclproc.cpp

Abstract:

    Exclude processing mechanism.  Processes the FilesNotToBackup key and
    zero or more exclude files with exclude rules.

Author:

    Stefan R. Steiner   [ssteiner]        03-21-2000

Revision History:

--*/

#include "stdafx.h"
#include "match.h"

#include <shlobj.h>

static VOID 
FsdExpandEnvironmentStrings( 
    IN LPCWSTR pwszInput, 
    OUT CBsString &cwsExpandedStr
    );

static BOOL
FsdEnsureLongNames(
    IN OUT CBsString& exclude_spec 
    );

SFsdExcludeRule::~SFsdExcludeRule()
{ 
    delete( psVolId ); 
    psVolId = NULL;
}

/*++

Routine Description:

    Prints out information about one rule.  If the rule caused files to be excluded
    it prints out those file too.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
SFsdExcludeRule::PrintRule(
    IN FILE *fpOut,
    IN BOOL bInvalidRulePrint
    )
{
    if ( bInvalidRulePrint )
    {
        if ( bInvalidRule )
            fwprintf( fpOut, L"%-24s  %-32s '%s'\n", 
                cwsExcludeFromSource.c_str(), cwsExcludeDescription.c_str(), cwsExcludeRule.c_str() );
    }
    else
    {
        //
        //  Iterate though excluded file list
        //
        CBsString cwsExcludedFile;
        CVssDLListIterator< CBsString > cExcludedFilesIter( cExcludedFileList );
        if ( cExcludedFilesIter.GetNext( cwsExcludedFile ) )
        {
            //
            //  At least one file excluded, print the header for the rule
            //
            fwprintf( fpOut, L"%-24s  %-32s '%s'\n", 
                cwsExcludeFromSource.c_str(), cwsExcludeDescription.c_str(), cwsExcludeRule.c_str() );

            //
            //  Now iterate
            //
            do 
            {
                fwprintf( fpOut, L"\t%s\n", cwsExcludedFile.c_str() );
            } while( cExcludedFilesIter.GetNext( cwsExcludedFile ) );
        }
    }
}
    
CFsdExclusionManager::CFsdExclusionManager(
        IN CDumpParameters *pcDumpParameters
        ) : m_pcParams( pcDumpParameters )
{
    if ( !m_pcParams->m_bDontUseRegistryExcludes )
    {
        ProcessRegistryExcludes( HKEY_LOCAL_MACHINE, L"HKEY_LOCAL_MACHINE" );
        ProcessRegistryExcludes( HKEY_CURRENT_USER,  L"HKEY_CURRENT_USER" );
    }
    
    CBsString cwsEXEFileStreamExcludeFile( m_pcParams->m_cwsArgv0 + L":ExcludeList" );
    if ( ProcessOneExcludeFile( cwsEXEFileStreamExcludeFile ) == FALSE )
        m_pcParams->DumpPrint( L"        NOTE: Exclude file: '%s' not found", 
            cwsEXEFileStreamExcludeFile.c_str() );
       
    ProcessExcludeFiles( m_pcParams->m_cwsFullPathToEXE );
    
    CompileExclusionRules();
}

CFsdExclusionManager::~CFsdExclusionManager()
{
    SFsdExcludeRule *pER;

    //
    //  Iterate through the exclude rule list and delete each element
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    while( cExclRuleIter.GetNext( pER ) )
        delete pER;
}

VOID
CFsdExclusionManager::ProcessRegistryExcludes( 
    IN HKEY hKey,
    IN LPCWSTR pwszFromSource
    )
{
    LPWSTR buffer ;
    HKEY   key = NULL ;
    DWORD  stat ;
    DWORD  dwDisposition ;
    DWORD  dwDataSize;
    DWORD  dwIndex = 0;
    HRESULT hr = S_OK;
    
    m_pcParams->DumpPrint( L"        Processing FilesNotToBackup reg key in %s", pwszFromSource );

    buffer = new WCHAR[ FSD_MAX_PATH ];
    if ( buffer == NULL )
        throw E_OUTOFMEMORY;

    try
    {
        stat = ::RegOpenKeyEx( hKey,
                    FSD_REG_EXCLUDE_PATH,
                    0,
                    KEY_READ,
                    &key ) ;

        dwIndex = 0 ;
        while ( stat == ERROR_SUCCESS ) 
        {
            WCHAR pwszValue[ MAX_PATH ];
            DWORD dwValSize = MAX_PATH;  // prefix #118830
            DWORD dwType;

            dwDataSize = FSD_MAX_PATH; // prefix #118830

            stat = ::RegEnumValueW( key,
                        dwIndex,
                        pwszValue,
                        &dwValSize,
                        NULL,
                        &dwType,
                        (LPBYTE)buffer, 
                        &dwDataSize ) ;
            dwIndex++;

            if ( ( stat == ERROR_SUCCESS ) && ( dwType == REG_MULTI_SZ ) ) 
            {
                LPWSTR p = buffer;
                while ( *p ) 
                {
                    SFsdExcludeRule *psExclRule;

                    //
                    //  Now load up the exclude rule with the unprocessed 
                    //  information
                    //
                    psExclRule = new SFsdExcludeRule;
                    if ( psExclRule == NULL )
                        throw E_OUTOFMEMORY;                
                    psExclRule->cwsExcludeFromSource = pwszFromSource;
                    psExclRule->cwsExcludeDescription = pwszValue;
                    psExclRule->cwsExcludeRule = p;
                    
                    if ( m_pcParams->m_bPrintDebugInfo || m_pcParams->m_bNoHeaderFooter )
                    {
                        m_pcParams->DumpPrint( L"            \"%s\" \"%s\"", 
                            pwszValue, p );
                    }
                    
                    m_cCompleteExcludeList.AddTail( psExclRule );                    
                    p += ::wcslen( p ) + 1;
                }
            }

        }
    }
    catch ( HRESULT hrCaught )
    {
        hr = hrCaught;
    }
    catch ( ... )
    {
        hr = E_UNEXPECTED;
    }
    
    if ( key != NULL )
    {
        ::RegCloseKey( key ) ;
        key = NULL ;
    }

    delete [] buffer ;

    if ( FAILED( hr ) )
        throw hr;
}


VOID 
CFsdExclusionManager::ProcessExcludeFiles( 
    IN const CBsString& cwsPathToExcludeFiles
    )
{
    HANDLE hFind = INVALID_HANDLE_VALUE;    

    try
    {
        //
        //  Iterate through all files in the directory looking for
        //  files with .exclude extensions
        //
        DWORD dwRet;
        WIN32_FIND_DATAW sFindData;
        hFind = ::FindFirstFileExW( 
                    cwsPathToExcludeFiles + L"*.exclude",
                    FindExInfoStandard,
                    &sFindData,
                    FindExSearchNameMatch,
                    NULL,
                    0 );
        if ( hFind == INVALID_HANDLE_VALUE )
        {
            dwRet = ::GetLastError();
            if ( dwRet == ERROR_NO_MORE_FILES || dwRet == ERROR_FILE_NOT_FOUND )
                return;
            else
            {
                m_pcParams->ErrPrint( L"CFsdExclusionManager::ProcessExcludeFiles - FindFirstFileEx( '%s' ) returned: dwRet: %d, skipping looking for .exclude files", 
                    cwsPathToExcludeFiles.c_str(), ::GetLastError() );
                return;
            }
        }

        //
        //  Now run through the directory
        //
        do
        {
            //  Check and make sure the file such as ".", ".." and dirs are not considered
    	    if( ::wcscmp( sFindData.cFileName, L".") != 0 &&
    	        ::wcscmp( sFindData.cFileName, L"..") != 0 &&
                !( sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    	        {
    	            ProcessOneExcludeFile( cwsPathToExcludeFiles + sFindData.cFileName );
    	        }
        } while ( ::FindNextFile( hFind, &sFindData ) );
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"CFsdExclusionManager::ProcessExcludeFiles: Caught an unknown exception, dirPath: '%s'", cwsPathToExcludeFiles.c_str() );
    }

    if ( hFind != INVALID_HANDLE_VALUE )
        ::FindClose( hFind );
}


BOOL 
CFsdExclusionManager::ProcessOneExcludeFile(
    IN const CBsString& cwsExcludeFileName
    )
{
    FILE *fpExclFile;
    
    fpExclFile = ::_wfopen( cwsExcludeFileName, L"r" );
    if ( fpExclFile == NULL )
    {
        return FALSE;
    }
    
    m_pcParams->DumpPrint( L"        Processing exclude file: '%s'", cwsExcludeFileName.c_str() );

    CBsString cwsInputLine;
    while( ::fgetws( cwsInputLine.GetBuffer( FSD_MAX_PATH), FSD_MAX_PATH, fpExclFile ) )
    {
        cwsInputLine.ReleaseBuffer();
        cwsInputLine = cwsInputLine.Left( cwsInputLine.GetLength() - 1 );  //  get rid of '\n'
        cwsInputLine.TrimLeft();
        cwsInputLine.TrimRight();

        //
        //  See if it is a comment, either // or #
        //
        if ( cwsInputLine[ 0 ] == L'#' || cwsInputLine.Left( 2 ) == L"//" 
             || cwsInputLine.IsEmpty() )
            continue;
        
        if ( m_pcParams->m_bPrintDebugInfo || m_pcParams->m_bNoHeaderFooter )
        {
            m_pcParams->DumpPrint( L"            %s", cwsInputLine.c_str() );
        }

        CBsString cwsLine( cwsInputLine );
        SFsdExcludeRule *psExclRule;
        psExclRule = new SFsdExcludeRule;
        if ( psExclRule == NULL )
        {
            ::fclose( fpExclFile );
            throw E_OUTOFMEMORY;
        }
        
        INT iLeft;
        INT iRight;
        //
        //  This is gross.  With the updated string class, this can
        //  be simplified.
        //
        iLeft = cwsLine.Find( L'\"' );
        if ( iLeft != -1 )
        {
            cwsLine = cwsLine.Mid( iLeft + 1 );
            iRight = cwsLine.Find( L'\"' );
            if ( iRight != -1 )
            {
                psExclRule->cwsExcludeDescription = cwsLine.Left( iRight );
                cwsLine = cwsLine.Mid( iRight + 1 );
                iLeft = cwsLine.Find( L'\"' );
                if ( iLeft != -1 )
                {
                    cwsLine = cwsLine.Mid( iLeft + 1 );
                    iRight = cwsLine.Find( L'\"' );
                    if ( iRight != -1 )
                    {
                        psExclRule->cwsExcludeRule = cwsLine.Left( iRight );
                        psExclRule->cwsExcludeFromSource = cwsExcludeFileName.c_str() + cwsExcludeFileName.ReverseFind( L'\\' ) + 1;
                        m_cCompleteExcludeList.AddTail( psExclRule );                    
                        continue;                        
                    }
                }
            }
        }
        else
        {
            m_pcParams->ErrPrint( L"Parse error in exclusion rule file '%s', rule text '%s', skipping", 
                cwsExcludeFileName.c_str(), cwsInputLine.c_str() );
        }
        
        delete psExclRule;
    }

    ::fclose( fpExclFile );

    return TRUE;
}


VOID
CFsdExclusionManager::CompileExclusionRules()
{
    SFsdExcludeRule *psER;

    //
    //  Iterate through the exclude rule list and compile each rule
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    CBsString cws;
    
    if ( m_pcParams->m_bPrintDebugInfo )
        wprintf( L"Exclusion rule debug info:\n" );
    
    while( cExclRuleIter.GetNext( psER ) )
    {
        INT i;
        
        ::FsdExpandEnvironmentStrings( psER->cwsExcludeRule, cws );

        if ( m_pcParams->m_bPrintDebugInfo )
        {
            wprintf( L"\t%s : %s : %s : %s", psER->cwsExcludeFromSource.c_str(),
                psER->cwsExcludeDescription.c_str(), psER->cwsExcludeRule.c_str(),
                cws.c_str() );
        }
        
        //
        //  Get rid of leading spaces and lower case the whole mess
        //
        cws.TrimLeft();
        cws.MakeUpper();
        
        //
        //  First see if /s is at end of string
        //
        i = cws.Find( L"/S" );
        if ( i > 0 )
        {
            cws = cws.Left( i );
            psER->bInclSubDirs = TRUE;
        }
        cws.TrimRight();

        //
        //  Now see if there are any wildcards
        //
        i = cws.FindOneOf( L"*?" );
        if ( i != -1 )
        {
            psER->bWCInFileName = TRUE;
        }

        //
        //  Now see if this is for any volume
        //
        if ( cws.GetLength() >= 2 && cws[0] == L'\\' && cws[1] != L'\\' )
            psER->bAnyVol = TRUE;
        else if ( cws.GetLength() >= 2 && cws[1] != L':' )
            psER->bAnyVol = TRUE;

        if ( psER->bAnyVol )
        {
            if ( cws[0] == L'\\' )
            {
                //  Get rid of first '\'
                cws = cws.Mid( 1 );
            }
        }
        else
        {
            //
            //  Specific volume case
            //
            CBsString cwsVolPath;
            
            psER->psVolId = new SFsdVolumeId;
            if ( psER->psVolId == NULL )  // Prefix 118832
            {
                m_pcParams->ErrPrint( L"CFsdExclusionManager::CompileExclusionRules - out of memory" );
                throw E_OUTOFMEMORY;  // Prefix #118832
            }
            
            if ( CFsdVolumeStateManager::GetVolumeIdAndPath( m_pcParams, cws, psER->psVolId, cwsVolPath ) != ERROR_SUCCESS )
                psER->bInvalidRule = TRUE;            
            else
            {
                //
                //  Slice off the volume part of the path
                //
                cws = cws.Mid( cwsVolPath.GetLength() );                
            }
        }
            
        INT iFileNameOffset;
        iFileNameOffset = cws.ReverseFind( L'\\' );
        if ( iFileNameOffset == -1 )
        {
            //
            //  No dirpath
            //
            // psER->cwsDirPath = L"\\";
            psER->cwsFileNamePattern = cws;
        }
        else
        {
            psER->cwsFileNamePattern = cws.Mid( iFileNameOffset + 1 );
            psER->cwsDirPath = cws.Left( iFileNameOffset + 1 );
        }                        

        //
        //  Now convert the file name pattern into a form that the pattern matcher
        //  can use.
        //
        ::FsdRtlConvertWildCards( psER->cwsFileNamePattern );
        
        if ( m_pcParams->m_bPrintDebugInfo )
        {
            if ( psER->bInclSubDirs )
                wprintf( L" - SubDir" );
            
            if ( psER->bWCInFileName )
                wprintf( L" - WC" );
                
            if ( psER->bAnyVol )
                wprintf( L" - AnyVol" );
            
            wprintf( L" - VolId: 0x%08x,  DirPath: '%s', FileName: '%s'", 
                ( psER->psVolId ) ? psER->psVolId->m_dwVolSerialNumber : 0xFFFFFFFF,
                psER->cwsDirPath.c_str(), psER->cwsFileNamePattern.c_str() );

            if ( psER->bInvalidRule )
                wprintf( L" - ERROR, invalid rule" );
            wprintf( L"\n" );
        }        
    }

}

VOID 
CFsdExclusionManager::GetFileSystemExcludeProcessor(
    IN CBsString cwsVolumePath,
    IN SFsdVolumeId *psVolId,
    OUT CFsdFileSystemExcludeProcessor **ppcFSExcludeProcessor
    )
{
    CFsdFileSystemExcludeProcessor *pExclProc;
    *ppcFSExcludeProcessor = NULL;
    
    //
    //  Get a new exclude processor for the file system
    //
    pExclProc = new CFsdFileSystemExcludeProcessor( m_pcParams, cwsVolumePath, psVolId );
    if ( pExclProc == NULL )
    {
        m_pcParams->ErrPrint( L"CFsdExclusionManager::CFsdGetFileSystemExcludeProcessor - Could not new a CFsdFileSystemExcludeProcessor object" );
        throw E_OUTOFMEMORY;
    }
        
    SFsdExcludeRule *pER;

    //
    //  Now go through the complete exclude list to find exclude rules that are relevant to
    //  this file system
    //
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );
    while( cExclRuleIter.GetNext( pER ) )
    {
        if ( !pER->bInvalidRule )
        {
            if ( pER->bAnyVol || pER->psVolId->IsEqual( psVolId ) )
            {
                pExclProc->m_cFSExcludeList.AddTail( pER );
            }
        }
    }

    *ppcFSExcludeProcessor = pExclProc;
}   


/*++

Routine Description:

    Goes through the list of exclusion rules and dumps information about each.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
CFsdExclusionManager::PrintExclusionInformation()
{
    SFsdExcludeRule *pER;

    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cCompleteExcludeList );

    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"Invalid exclusion rules (invalid because volume not found or parsing error)" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"From                      Application                      Exclusion rule" );
    while( cExclRuleIter.GetNext( pER ) )
        pER->PrintRule( m_pcParams->GetDumpFile(), TRUE );
    
    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"Files excluded by valid exclusion rule" );  
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"From                      Application                      Exclusion rule" );
    cExclRuleIter.Reset();
    while( cExclRuleIter.GetNext( pER ) )
        pER->PrintRule( m_pcParams->GetDumpFile(), FALSE );
}


CFsdFileSystemExcludeProcessor::CFsdFileSystemExcludeProcessor(
    IN CDumpParameters *pcDumpParameters,
    IN const CBsString& cwsVolumePath,
    IN SFsdVolumeId *psVolId 
    ) : m_pcParams( pcDumpParameters ),
        m_cwsVolumePath( cwsVolumePath),
        m_psVolId( NULL )
{
    m_psVolId = new SFsdVolumeId;
    if ( m_psVolId == NULL )  // Prefix #118829
        throw E_OUTOFMEMORY;
    *m_psVolId = *psVolId;
}

CFsdFileSystemExcludeProcessor::~CFsdFileSystemExcludeProcessor()
{
    delete m_psVolId;
}

BOOL 
CFsdFileSystemExcludeProcessor::IsExcludedFile(
    IN const CBsString &cwsFullDirPath,
    IN DWORD dwEndOfVolMountPointOffset,
    IN const CBsString &cwsFileName
    )
{
    BOOL bFoundMatch = FALSE;
    SFsdExcludeRule *pER;
    CBsString cwsUpperFileName( cwsFileName );
    CBsString cwsDirPath( cwsFullDirPath.Mid( dwEndOfVolMountPointOffset ) );
    cwsUpperFileName.MakeUpper();    //  Make uppercased for match check
    cwsDirPath.MakeUpper();
    
    //  wprintf( L"Exclude proc: DirPath: %s, fileName: %s\n", cwsDirPath.c_str(), cwsUpperFileName.c_str() );
    CVssDLListIterator< SFsdExcludeRule * > cExclRuleIter( m_cFSExcludeList );
    while( !bFoundMatch && cExclRuleIter.GetNext( pER ) )
    {
        if ( pER->bInclSubDirs )
        {
            //
            //  First check most common case \XXX /s
            //
            if ( pER->cwsDirPath.GetLength() != 0 )
            {
                if ( ::wcsncmp( pER->cwsDirPath.c_str(), cwsDirPath.c_str(), pER->cwsDirPath.GetLength() ) != 0 )
                    continue;                    
            }
        }
        else
        {
            //
            //  Fixed path check
            //
            if ( pER->cwsDirPath != cwsDirPath )
            {
                continue;
            }
        }
        
        if ( pER->bWCInFileName )
        {
            //
            //  Pattern match check
            //
            if ( ::FsdRtlIsNameInExpression( pER->cwsFileNamePattern, cwsUpperFileName ) )
                bFoundMatch = TRUE;
        }
        else
        {
            //
            //  Constant string match
            //
            if ( pER->cwsFileNamePattern == cwsUpperFileName )
                bFoundMatch = TRUE;
        }
    }

    if ( bFoundMatch )
    {
        pER->cExcludedFileList.AddTail( cwsFullDirPath + cwsFileName );
        if ( m_pcParams->m_bPrintDebugInfo )
            wprintf( L"  EXCLUDING: %s%s\n", cwsFullDirPath.c_str(), cwsFileName.c_str() );
    }
    return bFoundMatch;
}

static VOID 
FsdExpandEnvironmentStrings( 
    IN LPCWSTR pwszInput, 
    OUT CBsString &cwsExpandedStr
    )
{
    BOOL isOK = FALSE;
          
    LPWSTR pwszBuffer;
    DWORD  dwSize = ::ExpandEnvironmentStringsW( pwszInput, NULL, 0 ) ;

    if ( pwszBuffer = cwsExpandedStr.GetBufferSetLength( dwSize + 1 ) )
    {
        isOK = ( 0 != ::ExpandEnvironmentStringsW( pwszInput, pwszBuffer, dwSize ) ) ;
        cwsExpandedStr.ReleaseBuffer( ) ;
    }

    if ( !isOK )
    {
        // have never seen ExpandEnvironmentStrings fail... even with undefined env var... but just in case 
        cwsExpandedStr = pwszInput ;
    }

    ::FsdEnsureLongNames( cwsExpandedStr );
}


/*++

Routine Description:

    Originally from NtBackup.
    This takes a path with short name components and expands them to long
    name components.  The path obviously has to exist on the system to expand
    short names.
    Uses a little shell magic (yuck) to translate it into a long name.
    
Arguments:

Return Value:

    TRUE if expanded properly

--*/
static BOOL
FsdEnsureLongNames(
    IN OUT CBsString& exclude_spec 
    )
{
    IShellFolder * desktop ;
    ITEMIDLIST *   id_list ;
    ULONG          parsed_ct = 0 ;
    BOOL           isOK = FALSE ;  //  initialize it, prefix bug # 180281
    CBsString      path ;
    int            last_slash ;

    // strip off the filename, and all that other detritus...
    path = exclude_spec ;
    if ( -1 != ( last_slash = path.ReverseFind( TEXT( '\\' ) ) ) )
    {
        path = path.Left( last_slash ) ;

        if ( SUCCEEDED( SHGetDesktopFolder( &desktop ) ) )
        {
            WCHAR *    ptr = path.GetBufferSetLength( FSD_MAX_PATH ) ;

            if ( SUCCEEDED( desktop->ParseDisplayName( NULL, NULL, ptr, &parsed_ct, &id_list, NULL ) ) )
            {
                IMalloc * imalloc ;

                isOK = SHGetPathFromIDList( id_list, ptr ) ;

                SHGetMalloc( &imalloc ) ;
                imalloc->Free( id_list ) ;
                imalloc->Release( ) ;
            }

            path.ReleaseBuffer( ) ;
            desktop->Release( ) ;
        }

        if ( isOK )
        {
            // put it back together with the new & improved path...
            exclude_spec = path + exclude_spec.Mid( last_slash ) ;
        }
    }

    return isOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\direntrs.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    direntrs.cpp

Abstract:

    Implementation of the directory entries class.  Given a path to a directory, 
    creates two linked lists, one a list of all sub-directories (including 
    mountpoints) and another a list of non-directories.

Author:

    Stefan R. Steiner   [ssteiner]        02-21-2000

Revision History:

--*/

#include "stdafx.h"

#include "direntrs.h"

/*++

Routine Description:

    Constructor for CDirectoryEntries.

Arguments:

    pcDumpParameters - The command-line dump parameters block

    cwsDirPath - The path to the directory or file to get the directory
        entries for.
        
Return Value:

    Can throw an exception.  DWORD Win32 error only.

--*/
CDirectoryEntries::CDirectoryEntries(
    IN CDumpParameters *pcDumpParameters,
    IN const CBsString& cwsDirPath
    ) : m_pcParams( pcDumpParameters ),
        m_cwsDirPath( cwsDirPath )
{
    DWORD dwRet;
    
    dwRet = GetDirectoryEntries();
    if ( dwRet != ERROR_SUCCESS )
        throw( dwRet );
}


/*++

Routine Description:

    Destructor for the CDirectoryEntries class

Arguments:

    NONE
    
Return Value:

    NONE

--*/
CDirectoryEntries::~CDirectoryEntries()
{
    SDirectoryEntry *pDE;

    //
    //  Iterate through the sub-directory list and delete each element
    //
    CVssDLListIterator< SDirectoryEntry * > cDirListIter( m_cDirList );
    while( cDirListIter.GetNext( pDE ) )
        delete pDE;    

    //
    //  Iterate through the file list and delete each element
    //
    CVssDLListIterator< SDirectoryEntry * > cFileListIter( m_cFileList );
    while( cFileListIter.GetNext( pDE ) )
        delete pDE;
}


/*++

Routine Description:

    Performs the actual retrieval of directory entries.    

Arguments:

    NONE
    
Return Value:

    Any DWORD WIN32 error

--*/
DWORD
CDirectoryEntries::GetDirectoryEntries()
{
    DWORD dwRet = ERROR_SUCCESS;
    HANDLE hFind;

    try
    {
        WIN32_FIND_DATAW sFindData;
                
        //
        //  Now enumerate the directory list
        //
        hFind = ::FindFirstFileEx( 
                    m_cwsDirPath,
                    FindExInfoStandard,
                    &sFindData,
                    FindExSearchNameMatch,
                    NULL,
                    0 );
        if ( hFind == INVALID_HANDLE_VALUE )
        {
            dwRet = ::GetLastError();
            if ( dwRet == ERROR_NO_MORE_FILES || dwRet == ERROR_FILE_NOT_FOUND )
                return 0;
            else
            {
                //  Calling code will print out an error message if necessary
                return dwRet;
            }
        }

        //
        //  Now run through the directory
        //
        do
        {
            //  Check and make sure the file such as "." and ".." are not considered
    	    if( ::wcscmp( sFindData.cFileName, L".") != 0 &&
    	        ::wcscmp( sFindData.cFileName, L"..") != 0 )
    	    {
                SDirectoryEntry *psDirEntry;
                psDirEntry = new SDirectoryEntry;
                if ( psDirEntry == NULL )
                {
                    dwRet = ::GetLastError();
                    m_pcParams->ErrPrint( L"GetDirectoryEntries: dirPath: '%s', new() returned dwRet: %d", m_cwsDirPath.c_str(), dwRet );
                    ::FindClose( hFind );    
                    return dwRet;
                }

                //
                //  NOTE!!  The following cast makes the assumption that WIN32_FILE_ATTRIBUTE_DATA
                //  is a subset of WIN32_FIND_DATAW
                //
                psDirEntry->m_sFindData = *( WIN32_FILE_ATTRIBUTE_DATA * )&sFindData;
                
                psDirEntry->m_cwsFileName = sFindData.cFileName;

                //
                //  Short name is empty if the file name is a conformant 8.3 name.
                //
                if ( sFindData.cAlternateFileName[0] != L'\0' )
                    psDirEntry->m_cwsShortName = sFindData.cAlternateFileName;                    
                
    	        if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    	        {
    	            //
    	            //  Add to directory list
    	            //
    	            m_cDirList.AddTail( psDirEntry );
    	        }
    	        else
    	        {
    	            //
    	            //  Add to file list
    	            //
    	            m_cFileList.AddTail( psDirEntry );    	            
    	        }
     	    }
        } while ( ::FindNextFile( hFind, &sFindData ) );

        dwRet = ::GetLastError();
        if ( dwRet == ERROR_NO_MORE_FILES )
            dwRet = ERROR_SUCCESS;
        else
            m_pcParams->ErrPrint( L"GetDirectoryEntries: Got an unexpected error, FindNextFile('%s'), dwRet: %d", m_cwsDirPath.c_str(), dwRet );
    }
    catch ( DWORD dwRetThrown )
    {
        dwRet = dwRetThrown;
        m_pcParams->ErrPrint( L"GetDirectoryEntries: Caught an exception, dirPath: '%s', dwRet: %d", m_cwsDirPath.c_str(), dwRet );
    }
    catch ( ... )
    {
        dwRet = ::GetLastError();
        m_pcParams->ErrPrint( L"GetDirectoryEntries: Caught an unknown exception, dirPath: '%s'", m_cwsDirPath.c_str() );
    }

    ::FindClose( hFind );    

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\bsstring.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cpp

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

#include "stdafx.h"
#include "bsstring.h"
#include "malloc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)), 1024);
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)), 512);
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)), 256);
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
// Throws E_OUTOFMEMORY when out of memory
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
			if ( pData == NULL )    // Prefix #118828
			    throw E_OUTOFMEMORY;
			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CBsString CBsString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CBsString CBsString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	return Left((INT)_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CBsString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CBsString::Find(LPCTSTR lpszSub) const
{
	return Find(lpszSub, 0);
}

int CBsString::Find(LPCTSTR lpszSub, int nStart) const
{
	ASSERT(BsAfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return -1;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CBsString formatting

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#ifdef _X86_
	#define DOUBLE_ARG  _BSAFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64		0x40000

void CBsString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += (INT)_tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if (_tcsncmp(lpsz, _T("I64"), 3) == 0)
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
#if !defined(_X86_) && !defined(_ALPHA_)
			// __int64 is only available on X86 and ALPHA platforms
			ASSERT(FALSE);
#endif
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = _tcsinc(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = _tcsinc(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = _tcsinc(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
			{
				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = lstrlen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 'S':
			{
#ifndef _UNICODE
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6;  // "(null)"
				else
				{
				   nItemLen = wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#else
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
#endif
			}
			break;

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
			{
				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = lstrlenA(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
			{
				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
				if (pstrNextArg == NULL)
				   nItemLen = 6; // "(null)"
				else
				{
				   nItemLen = (INT)wcslen(pstrNextArg);
				   nItemLen = max(1, nItemLen);
				}
			}
			break;
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
			nItemLen = max(nItemLen, nWidth);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312+nPrecision+6));

					f = va_arg(argList, double);
					_stprintf( pszTemp, _T( "%*.*f" ), nWidth, nPrecision+6, f );
					nItemLen = _tcslen(pszTemp);
				}
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	INT i = _vstprintf(m_pchData, lpszFormat, argListSave);
	ASSERT( i <= GetAllocLength() );
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void BSAFX_CDECL CBsString::Format(LPCTSTR lpszFormat, ...)
{
	ASSERT(BsAfxIsValidString(lpszFormat));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CBsString::TrimRight(LPCTSTR lpszTargetList)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargetList, *lpsz) != NULL)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimRight(TCHAR chTarget)
{
	// find beginning of trailing matches
	// by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;

	while (*lpsz != '\0')
	{
		if (*lpsz == chTarget)
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at left-most matching character
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}


void CBsString::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)

	CopyBeforeWrite();
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CBsString::TrimLeft(LPCTSTR lpszTargets)
{
	// if we're not trimming anything, we're not doing any work
	if (SafeStrlen(lpszTargets) == 0)
		return;

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (*lpsz != '\0')
	{
		if (_tcschr(lpszTargets, *lpsz) == NULL)
			break;
		lpsz = _tcsinc(lpsz);
	}

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft(TCHAR chTarget)
{
	// find first non-matching character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;

	while (chTarget == *lpsz)
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
		// fix up data and length
		int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
		memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
		GetData()->nDataLength = nDataLength;
	}
}

void CBsString::TrimLeft()
{
	// find first non-space character

	CopyBeforeWrite();
	LPCTSTR lpsz = m_pchData;
	
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	if (lpsz != m_pchData)
	{
    	// fix up data and length
    	int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    	GetData()->nDataLength = nDataLength;
	}
}


//
//  From validadd.cpp
//

BOOL BSAFXAPI BsAfxIsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL BSAFXAPI BsAfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\extattr.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    extattr.h

Abstract:

    Get's additional file attributes beyond what you get with
    FindFirstFile/FindNextFile.

Author:

    Stefan R. Steiner   [ssteiner]        02-27-2000

Revision History:

--*/

#ifndef __H_EXTATTR_
#define __H_EXTATTR_

class CFsdVolumeState;
struct SDirectoryEntry;

static CBsString cwsFsdNoData = L"--------";

inline VOID FsdEaSetNoDataString( 
    IN LPCWSTR pwszStr
    )
{
    cwsFsdNoData = pwszStr;
}

struct SFileExtendedInfo
{   
    CBsString cwsOwnerSid;
    CBsString cwsGroupSid;
    ULONGLONG ullTotalBytesChecksummed;
    ULONGLONG ullTotalBytesNamedDataStream;
    ULONGLONG ullFileIndex;
    LONG      lNumberOfLinks;  // hard links
    LONG      lNumDACEs;
    LONG      lNumSACEs;
    LONG      lNumNamedDataStreams;
    LONG      lNumPropertyStreams;
    WORD      wReparsePointDataSize;
    WORD      wDACLSize;
    WORD      wSACLSize;
    WORD      wSecurityDescriptorControl;
    ULONG     ulReparsePointTag;
    CBsString cwsReparsePointDataChecksum;
    CBsString cwsUnnamedStreamChecksum;
    CBsString cwsNamedDataStreamChecksum;
    CBsString cwsDACLChecksum;
    CBsString cwsSACLChecksum;
    CBsString cwsEncryptedRawDataChecksum;
    CBsString cwsObjectId;
    CBsString cwsObjectIdExtendedDataChecksum;
    SFileExtendedInfo() : lNumDACEs( 0 ),
                          lNumSACEs( 0 ),
                          lNumNamedDataStreams( 0 ),
                          lNumPropertyStreams( 0 ),
                          ulReparsePointTag( 0 ),
                          ullTotalBytesChecksummed( 0 ),
                          ullTotalBytesNamedDataStream( 0 ),
                          ullFileIndex( 0 ),
                          lNumberOfLinks( 0 ),
                          wReparsePointDataSize( 0 ),
                          wDACLSize( 0 ),
                          wSACLSize( 0 ),
                          wSecurityDescriptorControl( 0 ),
                          cwsReparsePointDataChecksum( cwsFsdNoData ),
                          cwsUnnamedStreamChecksum( cwsFsdNoData ),
                          cwsNamedDataStreamChecksum( cwsFsdNoData ),
                          cwsDACLChecksum( cwsFsdNoData ),
                          cwsSACLChecksum( cwsFsdNoData ),
                          cwsObjectIdExtendedDataChecksum( cwsFsdNoData ),
                          cwsEncryptedRawDataChecksum( cwsFsdNoData ) { }
};


VOID 
GetExtendedFileInfo(
    IN CDumpParameters *pcParams,
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN BOOL bSingleEntryOutput,        
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo    
    );

#endif // __H_EXTATTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\extattr.cpp ===
/*

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    extattr.cpp

Abstract:

    Get's additional file attributes beyond what you get with
    FindFirstFile/FindNextFile.

Author:

    Stefan R. Steiner   [ssteiner]        02-27-2000

Revision History:

--*/

#include "stdafx.h"
#include <ntioapi.h>

#include <aclapi.h>
#include <sddl.h>

#include "direntrs.h"
#include "extattr.h"
#include "hardlink.h"

#define READ_BUF_SIZE ( 1024 * 1024 )
#define FSD_SHARE_MODE ( FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE )

#define FSD_MS_HSM_REPARSE_TAG 0xC0000004

static VOID
eaGetSecurityInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetFileInformationByHandle(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetAlternateStreamInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static VOID
eaGetReparsePointInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    );

static BOOL
eaChecksumRawEncryptedData(
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsFileName,
    IN OUT SFileExtendedInfo *psExtendedInfo
    );

static BOOL
eaChecksumStream(
    IN const CBsString& cwsStreamPath,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT DWORD *pdwRunningCheckSum
    );

static DWORD
eaChecksumBlock(
    IN DWORD dwRunningChecksum,
    IN LPBYTE pBuffer,
    IN DWORD dwBufSize
    );

static VOID
eaConvertUserSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static VOID
eaConvertGroupSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static VOID
eaConvertSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    );

static DWORD
eaChecksumHSMReparsePoint(
    IN CDumpParameters *pcParams,
    IN PREPARSE_DATA_BUFFER pReparseData,
    IN DWORD dwTotalSize  // Size of reparse point data
    );

static VOID
eaGetObjectIdInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    );

/*++

Routine Description:

    Performs all of the checksums, and retrieves the security info for one file.

Arguments:

Return Value:

--*/
VOID
GetExtendedFileInfo(
    IN CDumpParameters *pcParams,
    IN CFsdVolumeState *pcFsdVolState,
    IN const CBsString& cwsDirPath,
    IN BOOL bSingleEntryOutput,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    CBsString cwsFullPath( cwsDirPath );

    //
    //  If we are dumping an individual file's data, cwsDirPath has the complete
    //  path to the file, otherwise glue the filename from the find data structure
    //  to the path.
    //
	if ( !bSingleEntryOutput )
	{
		cwsFullPath += psDirEntry->GetFileName();
	}

    //
    //  Get the information that retrieved from GetFileInformationByHandle
    //
    ::eaGetFileInformationByHandle( pcParams, cwsFullPath, psDirEntry, psExtendedInfo );

    if ( psExtendedInfo->lNumberOfLinks > 1 && pcParams->m_eFsDumpType != eFsDumpFile )
    {
        if ( pcFsdVolState->IsHardLinkInList(
                psExtendedInfo->ullFileIndex,
                cwsDirPath,
                psDirEntry->GetFileName(),
                &psDirEntry->m_sFindData,
                psExtendedInfo ) )
        {
            //
            //  Found the link in the list, return with the previous link's information, except
            //  zero out the number of bytes checksummed so that total counts remain accurate.
            //
            psExtendedInfo->ullTotalBytesChecksummed     = 0;
            psExtendedInfo->ullTotalBytesNamedDataStream = 0;
            return;
        }
    }

    //
    //  Get the security information.
    //
    ::eaGetSecurityInfo( pcParams, cwsFullPath, psExtendedInfo );

    eaGetObjectIdInfo(
        pcParams,
        cwsFullPath,
        &psExtendedInfo->ullTotalBytesChecksummed,
        psDirEntry,
        psExtendedInfo );

    //
    //  Get the reparse point information if necessary
    //
    if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
        ::eaGetReparsePointInfo(
            pcParams,
            cwsFullPath,
            &psExtendedInfo->ullTotalBytesChecksummed,
            psDirEntry,
            psExtendedInfo );

    //
    //  Get the raw encryption data checksum if necessary
    //
    if (    !pcParams->m_bNoChecksums
         && psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED
         && !( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
        ::eaChecksumRawEncryptedData(
            pcParams,
            cwsFullPath,
            psExtendedInfo );

    //
    //  Checksum the unnamed datastream if this is not a directory
    //
    if (    !pcParams->m_bNoChecksums
         && !( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        DWORD dwChecksum = 0;
        ULONGLONG ullFileSize = ( ( ULONGLONG )( psDirEntry->m_sFindData.nFileSizeHigh ) << 32 ) + psDirEntry->m_sFindData.nFileSizeLow;

        if ( ullFileSize == 0 )
        {
            //
            //  In this case the default value for checksum of -------- is correct.
            //
        }
        else if ( psDirEntry->m_sFindData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE
             && pcParams->m_bDontChecksumHighLatencyData )
        {
            psExtendedInfo->cwsUnnamedStreamChecksum = L"HighLtcy";
        }
        else if ( ::eaChecksumStream( cwsFullPath,
                                &psExtendedInfo->ullTotalBytesChecksummed,
                                &dwChecksum ) )
        {
            psExtendedInfo->cwsUnnamedStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
        }
        else
        {
            psExtendedInfo->cwsUnnamedStreamChecksum.Format( L"<%6d>", ::GetLastError() );
        }
    }

    //
    //  Get info on and checksum the named data streams
    //
    ::eaGetAlternateStreamInfo( pcParams, cwsFullPath, psExtendedInfo );

    //
    //  If this file is multiply linked, add it to the hard-link file list
    //
    if ( psExtendedInfo->lNumberOfLinks > 1 && pcParams->m_eFsDumpType != eFsDumpFile )
    {
        pcFsdVolState->AddHardLinkToList(
                psExtendedInfo->ullFileIndex,
                cwsDirPath,
                psDirEntry->GetFileName(),
                &psDirEntry->m_sFindData,
                psExtendedInfo );
    }
}


/*++

Routine Description:

    Gets the security information for a file

Arguments:

Return Value:

--*/
static VOID
eaGetSecurityInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    //
    //  Now get the security information
    //
    PACL psDacl = NULL, psSacl = NULL;
    PSID pOwnerSid = NULL, pGroupSid = NULL;
    DWORD dwRet;
    DWORD dwSaclErrorRetCode = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR pDesc = NULL;

    try
    {
        dwRet = ::GetNamedSecurityInfoW(
            ( LPWSTR )cwsFileName.c_str(),  // strange API, should ask for const
            SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION
            | SACL_SECURITY_INFORMATION
            | OWNER_SECURITY_INFORMATION
            | GROUP_SECURITY_INFORMATION,
            &pOwnerSid,
            &pGroupSid,
            &psDacl,
            &psSacl,
            &pDesc );

        //
        //  If it didn't work, try again without the Sacl information
        //
        if ( dwRet != ERROR_SUCCESS )
        {
            dwSaclErrorRetCode = dwRet;
            psSacl  = NULL;
            dwRet = ::GetNamedSecurityInfoW(
                ( LPWSTR )cwsFileName.c_str(),  // strange API, should ask for const
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION
                | OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION,
                &pOwnerSid,
                &pGroupSid,
                &psDacl,
                NULL,
                &pDesc );
        }

#if 0
    //
    //  Test code to find security API problem
    //
        pDesc = ::LocalAlloc( LMEM_FIXED, 4096 );
        DWORD dwLengthNeeded;
        dwRet = ERROR_SUCCESS;

        if ( !::GetFileSecurityW(
                cwsFileName,
//                DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                DACL_SECURITY_INFORMATION, // | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                pDesc,
                4096,
                &dwLengthNeeded ) )
            dwRet = ::GetLastError();
if ( dwRet == ERROR_SUCCESS )
    wprintf( L"Got security descripter for '%s'\n", cwsFileName.c_str() );
else
    wprintf( L"Error getting descripter for '%s', dwRet: %d\n", cwsFileName.c_str(), dwRet );
#endif

        if ( dwRet == ERROR_SUCCESS )
        {
            if ( pDesc && pcParams->m_bEnableSDCtrlWordDump )
            {
                SECURITY_DESCRIPTOR_CONTROL sdc;
                DWORD dwDescRevision;
                if ( ::GetSecurityDescriptorControl( pDesc, &sdc, &dwDescRevision ) )
                    psExtendedInfo->wSecurityDescriptorControl = ( WORD )( sdc & ~SE_SELF_RELATIVE );
                else
                    psExtendedInfo->wSecurityDescriptorControl = -1;
            }
            else
                psExtendedInfo->wSecurityDescriptorControl = -1;

            if ( psDacl )
            {
                psExtendedInfo->lNumDACEs = 0;
                psExtendedInfo->wDACLSize = 0;
                //
                //  Checksum the DACL data if necessary.
                //  n.b. We only take into account ACEs that are inherited.
                //
                if ( psDacl->AclSize > 0 )
                {
                    DWORD dwChecksum = 0;
                    //
                    //  The first ACE is right after the ACL header
                    //
                    PACE_HEADER pAceHeader = ( PACE_HEADER )( psDacl + 1 );
                    for ( USHORT aceNum = 0; aceNum < psDacl->AceCount; ++aceNum )
                    {
                        //
                        //  Skip if an inherited ACE
                        //
                        if ( !( pAceHeader->AceFlags & INHERITED_ACE ) )
                        {
                            dwChecksum += ::eaChecksumBlock(
                                            dwChecksum,
                                            ( LPBYTE )pAceHeader,
                                            pAceHeader->AceSize );
                            ++psExtendedInfo->lNumDACEs;
                            psExtendedInfo->wDACLSize += pAceHeader->AceSize;
                            if ( pcParams->m_bPrintDebugInfo )
                                wprintf( L"\t%d: f: %04x, t: %04x, s: %u\n", aceNum,
                                    pAceHeader->AceFlags, pAceHeader->AceType, pAceHeader->AceSize );
                        }
                        pAceHeader = ( PACE_HEADER )( ( ( LPBYTE )pAceHeader ) + pAceHeader->AceSize );
                    }
                    if ( psExtendedInfo->wDACLSize > 0 )
                    {
                        psExtendedInfo->cwsDACLChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                        psExtendedInfo->ullTotalBytesChecksummed += psExtendedInfo->wDACLSize;
                    }
                }
            }
            else
                psExtendedInfo->lNumDACEs = 0; // probably FAT or CDROM fs

            if ( psSacl )
            {
                psExtendedInfo->lNumSACEs = 0;
                psExtendedInfo->wSACLSize = 0;

                //
                //  Checksum the SACL data if necessary
                //  n.b. We only take into account ACEs that are inherited.
                //
                if ( psSacl->AclSize > 0 )
                {
                    DWORD dwChecksum = 0;
                    //
                    //  The first ACE is right after the ACL header
                    //
                    PACE_HEADER pAceHeader = ( PACE_HEADER )( psSacl + 1 );
                    for ( USHORT aceNum = 0; aceNum < psSacl->AceCount; ++aceNum )
                    {
                        //
                        //  Skip if an inherited ACE
                        //
                        if ( !( pAceHeader->AceFlags & INHERITED_ACE ) )
                        {
                            dwChecksum += ::eaChecksumBlock(
                                            dwChecksum,
                                            ( LPBYTE )pAceHeader,
                                            pAceHeader->AceSize );
                            ++psExtendedInfo->lNumSACEs;
                            psExtendedInfo->wSACLSize += pAceHeader->AceSize;
                            if ( pcParams->m_bPrintDebugInfo )
                                wprintf( L"\ts%d: f: %04x, t: %04x, s: %u\n", aceNum,
                                    ( DWORD)( pAceHeader->AceFlags ), pAceHeader->AceType, (DWORD)( pAceHeader->AceSize ) );
                        }
                        pAceHeader = ( PACE_HEADER )( ( ( LPBYTE )pAceHeader ) + pAceHeader->AceSize );
                    }
                    if ( psExtendedInfo->wSACLSize > 0 )
                    {
                        psExtendedInfo->cwsSACLChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                        psExtendedInfo->ullTotalBytesChecksummed += psExtendedInfo->wSACLSize;
                    }
                }
            }
            else if ( dwSaclErrorRetCode != ERROR_SUCCESS )
            {
                psExtendedInfo->lNumSACEs = -1;
                psExtendedInfo->wSACLSize = -1;
                psExtendedInfo->cwsSACLChecksum.Format( L"<%6d>", dwSaclErrorRetCode );
            }
            else
                psExtendedInfo->lNumSACEs = 0; // none

            eaConvertUserSidToString( pcParams, pOwnerSid, &psExtendedInfo->cwsOwnerSid );
            eaConvertGroupSidToString( pcParams, pGroupSid, &psExtendedInfo->cwsGroupSid );

            ::LocalFree( pDesc );						
        }
        else
        {
            //
            //  Error getting security information
            //
            psExtendedInfo->lNumDACEs = -1;
            psExtendedInfo->lNumSACEs = -1;
            psExtendedInfo->wDACLSize = -1;
            psExtendedInfo->wSACLSize = -1;
            psExtendedInfo->cwsDACLChecksum.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsSACLChecksum.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsOwnerSid.Format( L"<%6d>", dwRet );
            psExtendedInfo->cwsGroupSid.Format( L"<%6d>", dwRet );
        }
    }
    catch( ... )
    {
        psExtendedInfo->lNumDACEs = -1;
        psExtendedInfo->lNumSACEs = -1;
        psExtendedInfo->wDACLSize = -1;
        psExtendedInfo->wSACLSize = -1;
        psExtendedInfo->cwsOwnerSid.Format( L"<%6d>", ::GetLastError() );
        psExtendedInfo->cwsGroupSid.Format( L"<%6d>", ::GetLastError() );
    }
}


static VOID
eaGetFileInformationByHandle(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT SDirectoryEntry *psDirEntry,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile;

    //
    //  Note that while we do have to open the file, not even read access is needed
    //
    hFile = ::CreateFileW(
                cwsFileName,
                0,
                FSD_SHARE_MODE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        psExtendedInfo->lNumberOfLinks = -1;
        return;
    }

    //
    //  Now get the additional attributes
    //
    BY_HANDLE_FILE_INFORMATION sFileInfo;
    if ( ::GetFileInformationByHandle( hFile, &sFileInfo ) )
    {
        psExtendedInfo->lNumberOfLinks = ( LONG )sFileInfo.nNumberOfLinks;
        psExtendedInfo->ullFileIndex   = ( ( ULONGLONG )sFileInfo.nFileIndexHigh << 32 ) + sFileInfo.nFileIndexLow;
        if ( psExtendedInfo->lNumberOfLinks > 1 || psDirEntry->m_sFindData.ftLastWriteTime.dwLowDateTime == 0 )
        {
            //
            //  Expect that the FindFirst/NextFile dir entry is stale or non-existant.  Use information
            //  from this call.
            //
            psDirEntry->m_sFindData.dwFileAttributes = sFileInfo.dwFileAttributes;
            psDirEntry->m_sFindData.ftCreationTime   = sFileInfo.ftCreationTime;
            psDirEntry->m_sFindData.ftLastAccessTime = sFileInfo.ftLastAccessTime;
            psDirEntry->m_sFindData.ftLastWriteTime  = sFileInfo.ftLastWriteTime;
            psDirEntry->m_sFindData.nFileSizeHigh    = sFileInfo.nFileSizeHigh;
            psDirEntry->m_sFindData.nFileSizeLow     = sFileInfo.nFileSizeLow;
        }
    }
    else
        psExtendedInfo->lNumberOfLinks = -1;

    ::CloseHandle( hFile );
}


static VOID
eaGetAlternateStreamInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    NTSTATUS Status;
    HANDLE hFile;

    //
    //  Note that while we do have to open the file, not even read access is needed
    //
    hFile = CreateFileW(
                cwsFileName,
                FILE_GENERIC_READ, // | ACCESS_SYSTEM_SECURITY,
                FSD_SHARE_MODE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        psExtendedInfo->lNumNamedDataStreams      = -1;
        psExtendedInfo->lNumPropertyStreams       = -1;
        psExtendedInfo->cwsNamedDataStreamChecksum.Format( L"<%6d>", ::GetLastError() );
        return;
    }

    //
    //  Loop until we read the file information
    //
    LPBYTE pBuffer = NULL;
    ULONG ulBuffSize = 1024;
    IO_STATUS_BLOCK iosb;
    static const WCHAR * const pwszDefaultStreamName = L"::$DATA";
    static const ULONG ulDefaultStreamNameLength = 7;

    while ( TRUE )
    {
        pBuffer = new BYTE[ ulBuffSize ];
        if ( pBuffer == NULL )
            throw E_OUTOFMEMORY;

        Status = ::NtQueryInformationFile(
                    hFile,
                    &iosb,
                    pBuffer,
                    ulBuffSize,
                    FileStreamInformation );
        //
        //  If we succeeded in getting data, when have the data so party on and get out of
        //  the loop
        //
        if ( NT_SUCCESS( Status ) && iosb.Information != 0 )
        {
            break;
        }

        //
        //  If the error isn't overflow, get out
        //
        if ( Status != STATUS_BUFFER_OVERFLOW && Status != STATUS_BUFFER_TOO_SMALL )
        {
            //
            //  NOTE: If status is successful, we didn't get any data but it's not
            //  an error.  Happens a lot with directories since they don't have a default
            //  unnamed stream.
            //
            if ( !NT_SUCCESS( Status ) )
            {
                //
                //  Another kind of error
                //  BUGBUG: if not NTFS, C000000D occurs.  Should not try this on
                //          a non-NTFS volume
                //psExtendedInfo->lNumNamedDataStreams      = -1;
                //psExtendedInfo->dwNamedDataStreamChecksum = ::GetLastError();
                //psExtendedInfo->bNamedDataStreamHadError  = TRUE;
            }
            delete [] pBuffer;
            ::CloseHandle( hFile );
            return;
        }

        //
        //  Increase the size of the buffer
        //
        ulBuffSize <<= 1;   // double it each try
        delete [] pBuffer;
        pBuffer = NULL;
    }

    //
    //  If we are here, we have a valid FileStreamInformation buffer
    //
    ::CloseHandle( hFile );

    PFILE_STREAM_INFORMATION pFSI;
    pFSI = ( PFILE_STREAM_INFORMATION ) pBuffer;

    BOOL bHadError = FALSE;
    DWORD dwChecksum = 0;

    //
    //  Now loop through the named streams.
    //
    while ( TRUE )
    {
        if ( pFSI->StreamNameLength != sizeof( WCHAR ) * ulDefaultStreamNameLength ||
            wcsncmp( pFSI->StreamName, pwszDefaultStreamName, ulDefaultStreamNameLength ) != 0 )
        {
            LPWSTR pwszDataStr;

            pwszDataStr = ::wcsstr( pFSI->StreamName, L":$DATA" );
            if ( pwszDataStr != NULL )
            {
                pwszDataStr[0] = L'\0';  //  Strip off the :$DATA off of name
                ++psExtendedInfo->lNumNamedDataStreams;
//                wprintf( L"  %8I64u  '%-*.*s' : %d\n", pFSI->StreamSize, pFSI->StreamNameLength / 2,
//                    pFSI->StreamNameLength / 2, pFSI->StreamName, pFSI->StreamNameLength );

                psExtendedInfo->ullTotalBytesNamedDataStream += ( ULONGLONG )pFSI->StreamSize.QuadPart;

                if ( !pcParams->m_bNoChecksums && !bHadError )
                {
                    //
                    //  Put into the checksum the name of the stream
                    //
                    dwChecksum = ::eaChecksumBlock(
                                    dwChecksum,
                                    ( LPBYTE )pFSI->StreamName,
                                    ::wcslen( pFSI->StreamName ) * sizeof WCHAR );
                    //
                    //  Now checksum the data in the stream
                    //
                    if ( ::eaChecksumStream( cwsFileName + pFSI->StreamName,
                                           &psExtendedInfo->ullTotalBytesChecksummed,
                                           &dwChecksum ) )
                    {
                        psExtendedInfo->cwsNamedDataStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
                    }
                    else
                    {
                        psExtendedInfo->cwsNamedDataStreamChecksum.Format( L"<%6d>", ::GetLastError() );
                        bHadError = TRUE;
                    }
                }
            }
            else
            {
                //
                //  Not an named data stream, probably a property stream
                //  BUGBUG: need to verify that this is a property stream
                //
                ++psExtendedInfo->lNumPropertyStreams;
            }
        }

        if ( pFSI->NextEntryOffset == 0 )
            break;
        pFSI = ( PFILE_STREAM_INFORMATION )( pFSI->NextEntryOffset + ( PBYTE ) pFSI );
    }

    if ( !bHadError && !pcParams->m_bNoChecksums && psExtendedInfo->lNumNamedDataStreams > 0 )
    {
        psExtendedInfo->cwsNamedDataStreamChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );
    }

    if ( pBuffer != NULL )
        delete [] pBuffer;

}

static VOID
eaGetReparsePointInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    BOOL bRet           = TRUE;
    LPBYTE pReadBuffer  = NULL;
    DWORD dwChecksum    = 0;

    try
    {
        //
        //  Now get the reparse point data buffer
        //
        pReadBuffer = ( LPBYTE )::VirtualAlloc(
                                    NULL,
                                    MAXIMUM_REPARSE_DATA_BUFFER_SIZE,
                                    MEM_COMMIT,
                                    PAGE_READWRITE );
        if ( pReadBuffer == NULL )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Open the file in order to read reparse point data
        //
        hFile = ::CreateFileW(
                    cwsFileName,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Now get the reparse point data
        //
        DWORD dwBytesReturned;
        if ( !::DeviceIoControl(
                hFile,
                FSCTL_GET_REPARSE_POINT,
                NULL,                       // lpInBuffer; must be NULL
                0,                          // nInBufferSize; must be zero
                ( LPVOID )pReadBuffer,      // pointer to output buffer
                MAXIMUM_REPARSE_DATA_BUFFER_SIZE,   // size of output buffer
                &dwBytesReturned,           // receives number of bytes returned
                NULL                        // pointer to OVERLAPPED structure
                ) )
        {
            bRet = FALSE;
            goto EXIT;
        }

        PREPARSE_DATA_BUFFER pReparseData;
        pReparseData = ( PREPARSE_DATA_BUFFER )pReadBuffer ;
        psExtendedInfo->ulReparsePointTag = pReparseData->ReparseTag;
        psExtendedInfo->wReparsePointDataSize = ( WORD )dwBytesReturned;

        if ( !pcParams->m_bNoSpecialReparsePointProcessing &&
             psExtendedInfo->ulReparsePointTag == FSD_MS_HSM_REPARSE_TAG )
        {
            //
            //  To make sure that dumps don't get many miscompares we
            //  need to tweak the attributes.  Raid #153050
            //
            if ( pcParams->m_bDontChecksumHighLatencyData )
            {
                //
                //  Need to always make this file look like it is offline.
                //  In this case, we need to always enable the FILE_ATTRIBUTE_OFFLINE
                //  flag.
                //
                psDirEntry->m_sFindData.dwFileAttributes |= FILE_ATTRIBUTE_OFFLINE;
            }
            else
            {
                //
                //  Need to always make this file look like it is cached.
                //  In this case, we need to always disable the FILE_ATTRIBUTE_OFFLINE
                //  flag.
                //
                psDirEntry->m_sFindData.dwFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
            }

            //
            //  Call a special HSM checksum function which filters out certain
            //  dynamic fields before checksumming the data.
            //
            dwChecksum = eaChecksumHSMReparsePoint( pcParams, pReparseData, dwBytesReturned );
        }
        else
        {
            //
            //  Now checksum all of the reparse point data
            //
            dwChecksum = ::eaChecksumBlock( 0, pReadBuffer, dwBytesReturned );
        }

        psExtendedInfo->cwsReparsePointDataChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );

        *pullBytesChecksummed += dwBytesReturned;
    }
    catch( ... )
    {
        bRet = FALSE;
    }
EXIT:

    if ( pReadBuffer != NULL )
        ::VirtualFree( pReadBuffer, 0, MEM_RELEASE );

    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

    if ( bRet == FALSE )
        psExtendedInfo->cwsReparsePointDataChecksum.Format( L"<%6d>", ::GetLastError() );
}

static BOOL
eaChecksumStream(
    IN const CBsString& cwsStreamPath,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT DWORD *pdwRunningCheckSum
    )
{
    LPBYTE pReadBuffer;
    BOOL bRet = TRUE;

    pReadBuffer = ( LPBYTE )::VirtualAlloc( NULL, READ_BUF_SIZE, MEM_COMMIT, PAGE_READWRITE );
    if ( pReadBuffer == NULL )
        return FALSE;

    //
    //  Open file with NO_BUFFERING.
    //
    HANDLE hFile = INVALID_HANDLE_VALUE;
    try
    {
        hFile = ::CreateFileW(
                    cwsStreamPath,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_NO_BUFFERING
                    | FILE_FLAG_BACKUP_SEMANTICS
                    | FILE_FLAG_OPEN_NO_RECALL
                    | FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        DWORD dwBytesRead;
        while ( ::ReadFile(
                    hFile,
                    pReadBuffer,
                    READ_BUF_SIZE,
                    &dwBytesRead,
                    NULL ) )
        {
            if ( dwBytesRead == 0 )
                break;
            *pdwRunningCheckSum = ::eaChecksumBlock(
                    *pdwRunningCheckSum,
                    pReadBuffer,
                    dwBytesRead );
            *pullBytesChecksummed += dwBytesRead;
        }
        if ( ::GetLastError() != ERROR_SUCCESS )
            bRet = FALSE;
    }
    catch( ... )
    {
        bRet = FALSE;
    }

EXIT:
    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

    ::VirtualFree( pReadBuffer, 0, MEM_RELEASE );

    return bRet;
}

//
//  This class maintains the encryption context
//
class CFsdEncryptionContext
{
public:
    CFsdEncryptionContext()
        : m_hDoneEvent( NULL ),
          m_dwChecksum( 0 ),
          m_ullBytesRead( 0 )
    {
        m_hDoneEvent = ::CreateEventW( NULL, TRUE, FALSE, NULL );
        if ( m_hDoneEvent == NULL )
            throw ::GetLastError();
    }

    ~CFsdEncryptionContext()
    {
        if ( m_hDoneEvent != NULL )
            ::CloseHandle( m_hDoneEvent );
    }

    DWORD WaitForDoneEvent()
    {
        DWORD dwRet;

        dwRet = ::WaitForSingleObject( m_hDoneEvent, INFINITE );
        if ( dwRet == WAIT_OBJECT_0 )
            return ERROR_SUCCESS;
        else if ( dwRet == WAIT_TIMEOUT )
            return ERROR_TIMEOUT;
        return ::GetLastError();
    }

    VOID FireDoneEvent()
    {
        ::SetEvent( m_hDoneEvent );
    }

    DWORD GetChecksum()
    {
        return m_dwChecksum;
    }

    ULONGLONG GetBytesRead()
    {
        return m_ullBytesRead;
    }

    static DWORD WINAPI ExportCallback(
        IN PBYTE pbData,
        IN PVOID pvCallbackContext,
        IN ULONG ulLength
        )
    {
        CFsdEncryptionContext *pcThis =
            static_cast< CFsdEncryptionContext * >( pvCallbackContext );
        pcThis->m_dwChecksum = ::eaChecksumBlock(
                pcThis->m_dwChecksum,
                pbData,
                ulLength );
        pcThis->m_ullBytesRead += ulLength;
        return ERROR_SUCCESS;
    }

private:
    HANDLE m_hDoneEvent;
    DWORD m_dwChecksum;
    ULONGLONG m_ullBytesRead;
};


static BOOL
eaChecksumRawEncryptedData(
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsFileName,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    PVOID pvContext = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    CFsdEncryptionContext cEncryptionContext;

    try
    {
        //
        //  Open this puppy up
        //
        dwRet = ::OpenEncryptedFileRawW( cwsFileName, 0, &pvContext );
        if ( dwRet == ERROR_SUCCESS )
        {
            //wprintf( L"**** Opened encrypted file '%s'\n", cwsFileName.c_str() );
            dwRet = ::ReadEncryptedFileRaw( CFsdEncryptionContext::ExportCallback, &cEncryptionContext, pvContext );
            if ( dwRet == ERROR_SUCCESS )
            {
                //wprintf( L"**** Called read on encrypted file, bytes read: %u, checksum: %u\n",
                //    cEncryptionContext.GetBytesRead(), cEncryptionContext.GetChecksum() );
                psExtendedInfo->cwsEncryptedRawDataChecksum.Format( pcParams->m_pwszULongHexFmt,
                    cEncryptionContext.GetChecksum() );
                psExtendedInfo->ullTotalBytesChecksummed += cEncryptionContext.GetBytesRead();
            }
        }
    }
    catch( ... )
    {
        dwRet = ERROR_EXCEPTION_IN_SERVICE;    // ???
    }

    if ( pvContext != NULL )
        ::CloseEncryptedFileRaw( pvContext );

    if ( dwRet != ERROR_SUCCESS )
        psExtendedInfo->cwsEncryptedRawDataChecksum.Format( L"<%6d>", dwRet );

    return dwRet == ERROR_SUCCESS;
}


/*++

Routine Description:

    Checksums a block of data.  The block needs to be DWORD aligned for performance and
    correctness since this function assumes it can zero out up to 3 bytes beyond the
    end of the buffer.  Also, only the last buffer in a series of buffers can have
    unaligned data at the end of the buffer.

Arguments:

    dwRunningChecksum - The previous checksum from a previous call.  Should be zero if
        this is the first block to checksum in a series of blocks.

    pBuffer - Pointer to the buffer to checksum.

    dwBufSize - This should always be a multiple of a DWORD, except for the last block
        in a series.

Return Value:

    The checksum.

--*/
static DWORD
eaChecksumBlock(
    IN DWORD dwRunningChecksum,
    IN LPBYTE pBuffer,
    IN DWORD dwBufSize
    )
{
    //
    //  Need to zero out any additional bytes not aligned.
    //
    DWORD dwBytesToZero;
    DWORD dwBufSizeInDWords;

    dwBytesToZero     = dwBufSize % sizeof( DWORD );
    dwBufSizeInDWords = ( dwBufSize + ( sizeof( DWORD ) - 1 ) ) / sizeof( DWORD ); // int div

    while ( dwBytesToZero-- )
        pBuffer[ dwBufSize + dwBytesToZero ] = 0;

    LPDWORD pdwBuf = ( LPDWORD )pBuffer;

    // BUGBUG: Need better checksum
    for ( DWORD dwIdx = 0; dwIdx < dwBufSizeInDWords; ++dwIdx )
        dwRunningChecksum += ( dwRunningChecksum << 1 ) | pdwBuf[ dwIdx ];

    return dwRunningChecksum;
}


/*++

Routine Description:

    Converts a user SID to a string.  Has a simple one element cache to speed
    up conversions.  This is especially useful when the user wants the symbolic
    DOMAIN\ACCOUNT strings.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertUserSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    static CBsString cwsCachedSidString;
    static PSID pCachedSid = NULL;

    //
    //  Is the cached SID the same as the passed in one.  If so,
    //  return the cached sid string.
    //
    if (    pCachedSid != NULL
         && ::EqualSid( pSid, pCachedSid ) )
    {
        *pcwsSid = cwsCachedSidString;
        return;
    }

    //
    //  Convert the SID into a string
    //
    ::eaConvertSidToString( pcParams, pSid, pcwsSid );

    //
    //  Now cache the sid
    //
    cwsCachedSidString = *pcwsSid;
    if ( pCachedSid != NULL )
        free( pCachedSid );
    size_t cSidLength = ( size_t )::GetLengthSid( pSid );
    pCachedSid = ( PSID )malloc( cSidLength );
    if ( pCachedSid == NULL )   //  prefix #171666
    {
        pcParams->ErrPrint( L"eaConvertUserSidToString - Can't allocate memory, out of memory" );
        throw E_OUTOFMEMORY;
    }
    ::CopySid( ( DWORD )cSidLength, pCachedSid, pSid );
}


/*++

Routine Description:

    Converts a group SID to a string.  Has a simple one element cache to speed
    up conversions.  This is especially useful when the user wants the symbolic
    DOMAIN\ACCOUNT strings.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertGroupSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    static CBsString cwsCachedSidString;
    static PSID pCachedSid = NULL;

    //
    //  Is the cached SID the same as the passed in one.  If so,
    //  return the cached sid string.
    //
    if (    pCachedSid != NULL
         && ::EqualSid( pSid, pCachedSid ) )
    {
        *pcwsSid = cwsCachedSidString;
        return;
    }

    //
    //  Convert the SID into a string
    //
    ::eaConvertSidToString( pcParams, pSid, pcwsSid );

    //
    //  Now cache the sid
    //
    cwsCachedSidString = *pcwsSid;
    if ( pCachedSid != NULL )
        free( pCachedSid );
    size_t cSidLength = ( size_t )::GetLengthSid( pSid );
    pCachedSid = ( PSID )malloc( cSidLength );
    if ( pCachedSid == NULL )   //  prefix #171665
    {
        pcParams->ErrPrint( L"eaConvertGroupSidToString - Can't allocate memory, out of memory" );
        throw E_OUTOFMEMORY;
    }
    ::CopySid( ( DWORD )cSidLength, pCachedSid, pSid );
}


/*++

Routine Description:

    Converts a SID to a string.

Arguments:

Return Value:

    NONE

--*/
static VOID
eaConvertSidToString (
    IN CDumpParameters *pcParams,
    IN PSID pSid,
    OUT CBsString *pcwsSid
    )
{
    if ( pcParams->m_bShowSymbolicSIDNames )
    {
        CBsString cwsAccountName;
        CBsString cwsDomainName;
        SID_NAME_USE eSidNameUse;
        DWORD dwAccountNameSize = 1024;
        DWORD dwDomainNameSize  = 1024;

        if ( ::LookupAccountSidW(
            NULL,
            pSid,
            cwsAccountName.GetBufferSetLength( dwAccountNameSize ),
            &dwAccountNameSize,
            cwsDomainName.GetBufferSetLength( dwDomainNameSize ),
            &dwDomainNameSize,
            &eSidNameUse ) )
        {
            cwsAccountName.ReleaseBuffer();
            cwsDomainName.ReleaseBuffer();
            *pcwsSid = L"'";
            *pcwsSid += cwsDomainName;
            *pcwsSid += L"\\";
            *pcwsSid += cwsAccountName;
            *pcwsSid += L"'";
            return;
        }
    }
    LPWSTR pwszSid;

    if ( ::ConvertSidToStringSid( pSid, &pwszSid ) )
    {
        *pcwsSid = pwszSid;
        ::LocalFree( pwszSid );
    }
    else
    {
        pcwsSid->Format( L"<%6d>", ::GetLastError() );
    }
}

///////////////////////////////////////////////////////////////////////////
//
//   FROM: base\fs\hsm\inc\rpdata.h
//
//////////////////////////////////////////////////////////////////////////

#define RP_RESV_SIZE 52

//
// Placeholder data - all versions unioned together
//
typedef struct _RP_PRIVATE_DATA {
   CHAR           reserved[RP_RESV_SIZE];        // Must be 0
   ULONG          bitFlags;            // bitflags indicating status of the segment
   LARGE_INTEGER  migrationTime;       // When migration occurred
   GUID           hsmId;
   GUID           bagId;
   LARGE_INTEGER  fileStart;
   LARGE_INTEGER  fileSize;
   LARGE_INTEGER  dataStart;
   LARGE_INTEGER  dataSize;
   LARGE_INTEGER  fileVersionId;
   LARGE_INTEGER  verificationData;
   ULONG          verificationType;
   ULONG          recallCount;
   LARGE_INTEGER  recallTime;
   LARGE_INTEGER  dataStreamStart;
   LARGE_INTEGER  dataStreamSize;
   ULONG          dataStream;
   ULONG          dataStreamCRCType;
   LARGE_INTEGER  dataStreamCRC;
} RP_PRIVATE_DATA, *PRP_PRIVATE_DATA;

typedef struct _RP_DATA {
   GUID              vendorId;         // Unique HSM vendor ID -- This is first to match REPARSE_GUID_DATA_BUFFER
   ULONG             qualifier;        // Used to checksum the data
   ULONG             version;          // Version of the structure
   ULONG             globalBitFlags;   // bitflags indicating status of the file
   ULONG             numPrivateData;   // number of private data entries
   GUID              fileIdentifier;   // Unique file ID
   RP_PRIVATE_DATA   data;             // Vendor specific data
} RP_DATA, *PRP_DATA;

//
//  This function specifically zero's out certain HSM reparse point
//  fields before computing the checksum.  The fields which are
//  zero'ed out are dynamic values and can cause miscompares.
//
static DWORD
eaChecksumHSMReparsePoint(
    IN CDumpParameters *pcParams,
    IN PREPARSE_DATA_BUFFER pReparseData,
    IN DWORD dwTotalSize  // Size of reparse point data
    )
{
    if ( dwTotalSize >= 8 && pReparseData->ReparseDataLength >= sizeof RP_DATA )
    {
        //
        //  If structure is not at least as large as the HSM RP_DATA structure,
        //  then it doesn't appear to be a valid HSM RP_DATA structure.
        //
        PRP_DATA pRpData = ( PRP_DATA ) pReparseData->GenericReparseBuffer.DataBuffer;

        //
        //  Zero out the proper fields
        //
        pRpData->qualifier                 = 0;
        pRpData->globalBitFlags            = 0;
        pRpData->data.bitFlags             = 0;
        pRpData->data.recallCount          = 0;
        pRpData->data.recallTime.LowPart   = 0;
        pRpData->data.recallTime.HighPart  = 0;
    }
    else
    {
        pcParams->ErrPrint( L"Warning, HSM reparse point not valid, size: %u\n", dwTotalSize );
    }

    return ::eaChecksumBlock( 0, ( LPBYTE )pReparseData, dwTotalSize );
}

static VOID
eaGetObjectIdInfo(
    IN CDumpParameters *pcParams,
    IN const CBsString &cwsFileName,
    IN OUT ULONGLONG *pullBytesChecksummed,
    IN OUT SDirectoryEntry *psDirEntry,
    IN OUT SFileExtendedInfo *psExtendedInfo
    )
{
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    BOOL bRet           = TRUE;
    DWORD dwChecksum    = 0;

    try
    {
        //
        //  Open the file in order to read the object id
        //
        hFile = ::CreateFileW(
                    cwsFileName,
                    GENERIC_READ,
                    FSD_SHARE_MODE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_BACKUP_SEMANTICS,
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            bRet = FALSE;
            goto EXIT;
        }

        FILE_OBJECTID_BUFFER sObjIdBuffer;
        DWORD dwBytesReturned;

        //
        //  Now get the object id info
        //
        if ( !::DeviceIoControl(
                hFile,
                FSCTL_GET_OBJECT_ID,
                NULL,                       // lpInBuffer; must be NULL
                0,                          // nInBufferSize; must be zero
                ( LPVOID )&sObjIdBuffer,     // pointer to output buffer
                sizeof FILE_OBJECTID_BUFFER,// size of output buffer
                &dwBytesReturned,           // receives number of bytes returned
                NULL                        // pointer to OVERLAPPED structure
                ) )
        {
            bRet = FALSE;
            goto EXIT;
        }

        //
        //  Load up the object id
        //
        LPWSTR pwszObjIdGuid;

        //  Check for RPC_S_OK added for Prefix bug #192596
        if ( ::UuidToStringW( (GUID *)sObjIdBuffer.ObjectId,
                              ( unsigned short ** )&pwszObjIdGuid ) == RPC_S_OK )
        {
            psExtendedInfo->cwsObjectId = pwszObjIdGuid;
            ::RpcStringFreeW( ( unsigned short ** )&pwszObjIdGuid );
        }

        //
        //  Now checksum all of the extended object id data if necessary
        //
        if ( pcParams->m_bEnableObjectIdExtendedDataChecksums )
        {
            dwChecksum = ::eaChecksumBlock( 0, sObjIdBuffer.ExtendedInfo, sizeof( sObjIdBuffer.ExtendedInfo ) );
            psExtendedInfo->cwsObjectIdExtendedDataChecksum.Format( pcParams->m_pwszULongHexFmt, dwChecksum );

            *pullBytesChecksummed += sizeof( sObjIdBuffer.ExtendedInfo );
        }
    }
    catch( ... )
    {
        bRet = FALSE;
    }
EXIT:

    if ( hFile != INVALID_HANDLE_VALUE )
        ::CloseHandle( hFile );

//    if ( bRet == FALSE )
//        psExtendedInfo->cwsReparsePointDataChecksum.Format( L"<%6d>", ::GetLastError() );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\match.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    match.h

    Originally from name.c by Gary Kimura

Author:

    Stefan R. Steiner   [ssteiner]        ??-??-2000

Revision History:

--*/

#ifndef __H_MATCH_
#define __H_MATCH_

BOOLEAN
FsdRtlIsNameInExpression (
    IN const CBsString& Expression,    //  Must be uppercased
    IN const CBsString& Name           //  Must be uppercased
    );

VOID
FsdRtlConvertWildCards(
    IN OUT CBsString &FileName
    );

#endif // __H_MATCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Precompiled header file

Author:

    Stefan R. Steiner   [ssteiner]        02-17-2000

Revision History:

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#if _MSC_VER > 1000
#pragma once
#endif

#define RTL_USE_AVL_TABLES 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntioapi.h>
#include <windows.h>

#include "bsstring.h"
#include "params.h"
#include "vs_list.h"
#include "volstate.h"


#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\hardlink.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hardlink.cpp

Abstract:

    The class that manages hardlinks for one volume.  Assumes one class object
    will be created per volume.

Author:

    Stefan R. Steiner   [ssteiner]        3-30-2000

Revision History:

--*/

#include "stdafx.h"
#include "hardlink.h"
 
VOID
CFsdHardLinkListEntry::AddFile(
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName
    )
{
    SFsdHLFileName sFileName;
    sFileName.cwsDirPath  = cwsDirPath;
    sFileName.cwsFileName = cwsFileName;
    m_cFilesLinkedTogetherList.AddTail( sFileName );
}

VOID 
CFsdHardLinkListEntry::PrintEntry(
    IN FILE *fpOut,
    IN INT cVolMountPointOffset
    )
{
    fwprintf( fpOut, L"\tLinks to file: %u, links found: %u %s\n", m_sExtendedInfo.lNumberOfLinks,
        m_cFilesLinkedTogetherList.Size(), 
        m_sExtendedInfo.lNumberOfLinks == (LONG)m_cFilesLinkedTogetherList.Size() ? L"" : L" - MISMATCH" );

    SFsdHLFileName sFileName;

    CVssDLListIterator< SFsdHLFileName > cListEntryIter( m_cFilesLinkedTogetherList );
    while( cListEntryIter.GetNext( sFileName ) )
        fwprintf( fpOut, L"\t\t%s%s\n", sFileName.cwsDirPath.c_str() + cVolMountPointOffset, 
            sFileName.cwsFileName.c_str() );
}


CFsdHardLinkManager::~CFsdHardLinkManager()
{
    //
    //  Need to delete all CFsdHardLinkListEntry objects
    //
    ULONGLONG ullFileIndex;
    CFsdHardLinkListEntry *pcListEntry;

    m_cHardLinkFilesList.StartEnum();
    while ( m_cHardLinkFilesList.GetNextEnum( &ullFileIndex, &pcListEntry ) )
    {
        delete pcListEntry;
    }    
    m_cHardLinkFilesList.EndEnum();
}

VOID 
CFsdHardLinkManager::PrintHardLinkInfo()
{
    //
    //  Need to iterate through all hard link entries
    //
    ULONGLONG ullFileIndex;
    CFsdHardLinkListEntry *pcListEntry;

    m_cHardLinkFilesList.StartEnum();
    while ( m_cHardLinkFilesList.GetNextEnum( &ullFileIndex, &pcListEntry ) )
    {
        pcListEntry->PrintEntry( m_pcParams->GetDumpFile(), m_cVolMountPointOffset );
    }    
    m_cHardLinkFilesList.EndEnum();
}


BOOL 
CFsdHardLinkManager::IsHardLinkInList(
    IN ULONGLONG ullFileIndex,
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName,
    OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
    OUT SFileExtendedInfo *psExtendedInfo
    )
{
    //
    //  Search the hard link list to see if the file index is already in
    //  the list.
    //
    CFsdHardLinkListEntry *pcLinkEntry;
    
    if ( m_cHardLinkFilesList.Find( ullFileIndex, &pcLinkEntry ) )
    {
        //
        //  Found it.  Add file name to the entry and get the stored attributes.
        //
        pcLinkEntry->AddFile( cwsDirPath, cwsFileName );
        pcLinkEntry->GetAttributes( psFileAttributeData, psExtendedInfo );

        if ( m_pcParams->m_bPrintDebugInfo )
            wprintf( L"IsHardLinkInList: FOUND ullFileIndex: %016I64x, file '%s%s', num in list: %u, num lnks: %d\n",
                ullFileIndex, cwsDirPath.c_str(), cwsFileName.c_str(), pcLinkEntry->m_cFilesLinkedTogetherList.Size(), 
                psExtendedInfo->lNumberOfLinks );

        return TRUE;
    }
    
    return FALSE;
}


VOID 
CFsdHardLinkManager::AddHardLinkToList(
    IN ULONGLONG ullFileIndex,
    IN const CBsString& cwsDirPath,
    IN const CBsString& cwsFileName,
    IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
    IN SFileExtendedInfo *psExtendedInfo
    )
{
    CFsdHardLinkListEntry *pcLinkEntry;

    //
    //  Add it.  Create a new entry and add the entry to the list
    //
    pcLinkEntry = new CFsdHardLinkListEntry( 
                        cwsDirPath, 
                        cwsFileName, 
                        psFileAttributeData, 
                        psExtendedInfo );
    if ( pcLinkEntry == NULL )
        throw E_OUTOFMEMORY;
    
    if ( m_cHardLinkFilesList.Insert( ullFileIndex, pcLinkEntry ) != BSHASHMAP_NO_ERROR )
        m_pcParams->ErrPrint( L"CFsdHardLinkManager::AddHardLinkToList - Error adding to hard-link file list" );

    if ( m_pcParams->m_bPrintDebugInfo )
        wprintf( L"  AddHardLinkToList: ullFileIndex: %016I64x, file '%s%s', num lnks: %d\n",
            ullFileIndex, cwsDirPath.c_str(), cwsFileName.c_str(), psExtendedInfo->lNumberOfLinks );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\hardlink.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hardlink.h

Abstract:

    The class that manages hardlinks for one volume.  Assumes one class object
    will be created per volume.

Author:

    Stefan R. Steiner   [ssteiner]        3-30-2000

Revision History:

--*/

#ifndef __H_HARDLINK_
#define __H_HARDLINK_

#include "extattr.h"

//
//  Structure is defined to reduce the amount of space required
//  to store the file names in the hard-link linked-list with 
//  the assumption that a number of hard-linked files exist in
//  a directory.  Uses CBsString ref counting.
//
struct SFsdHLFileName
{
    CBsString cwsDirPath;
    CBsString cwsFileName;
};

//
//  Manages one set of hard-linked files
//
class CFsdHardLinkListEntry
{
public:
    //  Create link entry and add the first file name
    CFsdHardLinkListEntry(
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        ) : m_sFileAttributeData( *psFileAttributeData ),
            m_sExtendedInfo( *psExtendedInfo )
        {
            AddFile( cwsDirPath, cwsFileName );
        }

    virtual ~CFsdHardLinkListEntry() {}

    //  Adds an additional file name to the link
    VOID AddFile(
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName
        );

    inline VOID GetAttributes( 
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttribData,
        OUT SFileExtendedInfo *psExtInfo
        )
    {
        *psFileAttribData = m_sFileAttributeData;
        *psExtInfo        = m_sExtendedInfo;
    }
    
    VOID PrintEntry(
        IN FILE *fpOut,
        IN INT cVolMountPointOffset
        );
    
    CVssDLList< SFsdHLFileName > m_cFilesLinkedTogetherList;
    
private:
    WIN32_FILE_ATTRIBUTE_DATA m_sFileAttributeData;
    SFileExtendedInfo m_sExtendedInfo;
};


typedef TBsHashMap< ULONGLONG, CFsdHardLinkListEntry * > FSD_HARD_LINK_LIST;

//
//  Manages all of the hard-link files in one volume
//
class CFsdHardLinkManager
{
public:
    CFsdHardLinkManager(
        IN CDumpParameters *pcParams,
        IN INT cVolMountPointOffset
        ) : m_pcParams( pcParams ),
            m_cVolMountPointOffset( cVolMountPointOffset ),
            m_cHardLinkFilesList( BSHASHMAP_HUGE) {}
    
    virtual ~CFsdHardLinkManager();

    //  Dumps all hardlink information out to dump file
    VOID PrintHardLinkInfo();
    
    //  Looks to see if the hardlink is already in the list, if
    //  so, adds the file name to the list
    BOOL IsHardLinkInList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        OUT WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        OUT SFileExtendedInfo *psExtendedInfo
        );

    //  Adds a new link to the list
    VOID AddHardLinkToList(
        IN ULONGLONG ullFileIndex,
        IN const CBsString& cwsDirPath,
        IN const CBsString& cwsFileName,
        IN WIN32_FILE_ATTRIBUTE_DATA *psFileAttributeData,
        IN SFileExtendedInfo *psExtendedInfo
        );
    
private:
    CDumpParameters *m_pcParams;
    INT m_cVolMountPointOffset;
    FSD_HARD_LINK_LIST m_cHardLinkFilesList;
};

#endif // __H_HARDLINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\match.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    match.cpp

    Originally name.c by Gary Kimura

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  FsRtlDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FsRtlColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

    Stefan Steiner  [SSteiner]  23-Mar-2000
        For use with fsdump - I tried to do as little changes to the actual
        matching code as possible.
        
--*/

#include "stdafx.h"

//
//  Local support routine prototypes
//

static BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN const CBsString& InExpression,
    IN const CBsString& InName,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );

static BOOLEAN
FsRtlDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    INT i;

    //
    //  The wildcards include the standard FsRtl wildcard characters
    //

	LPWSTR lpsz = ::wcspbrk( Name->Buffer, L"*?\"<>" );
	return (lpsz == NULL) ? FALSE : TRUE;
}
    
//
//  The following routine is just a wrapper around
//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FsdRtlIsNameInExpression (
    IN const CBsString& Expression,    //  Must be uppercased
    IN const CBsString& Name           //  Must be uppercased
    )
{
    BOOLEAN Result;

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    Result = FsRtlIsNameInExpressionPrivate( Expression,
                                             Name,
                                             FALSE,
                                             NULL );
    
    return Result;
}

#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

static BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN const CBsString& InExpression,
    IN const CBsString& InName,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    // The following code is to make use of most of this function without many
    // changes.
    UNICODE_STRING sExpression;
    UNICODE_STRING sName;
    PUNICODE_STRING Expression = &sExpression;
    PUNICODE_STRING Name = &sName;
    sExpression.Length        = ( USHORT )( InExpression.GetLength() * sizeof( WCHAR ) );
    sExpression.MaximumLength = sExpression.Length;
    sExpression.Buffer        = ( PWSTR )InExpression.c_str();
    sName.Length        = ( USHORT )( InName.GetLength() * sizeof( WCHAR ) );
    sName.MaximumLength = sName.Length;
    sName.Buffer        = ( PWSTR )InName.c_str();
    
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);

                    AuxBuffer = ( USHORT *)malloc(
                                                    (ExpressionChars+1) *
                                                    sizeof(USHORT)*2*2 );
                    if ( AuxBuffer == NULL )    //  fix a future prefix bug
                        throw E_OUTOFMEMORY;
                    
                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { free( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { free( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}


/*++

Routine Description:

    Converts some wildcard chars to FsRtl special wildcards
    in order to use FsRtlIsNameInExpressionPrivate.
    Code originally from filefind.c in Win32 subsystem by MarkL.

Arguments:

Return Value:

    <Enter return values here>

--*/
VOID
FsdRtlConvertWildCards(
    IN OUT CBsString &FileName
    )
{
    //
    //  Special case *.* to * since it is so common.  Otherwise transmogrify
    //  the input name according to the following rules:
    //
    //  - Change all ? to DOS_QM
    //  - Change all . followed by ? or * to DOS_DOT
    //  - Change all * followed by a . into DOS_STAR
    //
    //  These transmogrifications are all done in place.
    //

    if ( FileName == L"*.*") {

        FileName = L"*";

    } else {

        INT Index;
        WCHAR *NameChar;
        
        for ( Index = 0, NameChar = (WCHAR *)FileName.c_str();
              Index < FileName.GetLength();
              Index += 1, NameChar += 1) {

            if (Index && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar - 1) = DOS_STAR;
            }

            if ((*NameChar == L'?') || (*NameChar == L'*')) {

                if (*NameChar == L'?') 
                { 
                    *NameChar = DOS_QM; 
                }

                if (Index && *(NameChar-1) == L'.') 
                { 
                    *(NameChar-1) = DOS_DOT; 
                }
            }
        }

        if ( ( FileName.Right( 1 ) == L"." ) && *(NameChar - 1) == L'*') 
        { 
            *(NameChar-1) = DOS_STAR; 
        }
    }
}                


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\params.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

    Class the manages the dump parameters

Author:

    Stefan R. Steiner   [ssteiner]        02-18-2000

Revision History:

--*/

#include "stdafx.h"

#define VERSION_INFO1 L"FsDumplib.lib Version 1.3g - 8/23/2000"
#define VERSION_INFO2 L"  Checksum version 2 - 2/22/2000"

// Forward defines
static BOOL 
AssertPrivilege( 
    IN LPCWSTR privName 
    );


/*++

Routine Description:

    Based on the class variables, sets up the utility to write to the
    correct files and gets backup privs.

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
INT 
CDumpParameters::Initialize(
    IN INT argc,
    IN WCHAR *argv[]
    )
{
    LPWSTR pwszFileName;
    
    //
    //  Get the directory the fsdump.exe lives in.  For use for finding .exclude files amoung
    //  other things.
    //
    if ( ::GetFullPathName( 
            m_cwsArgv0,
            FSD_MAX_PATH,
            m_cwsFullPathToEXE.GetBufferSetLength( FSD_MAX_PATH ),
            &pwszFileName ) == 0 )
    {
        ::fwprintf( stderr, L"ERROR getting full path for '%s', won't be able to find .include files\n", m_cwsArgv0.c_str() );
        m_cwsFullPathToEXE.ReleaseBuffer();
    }
    else
    {
        m_cwsFullPathToEXE.ReleaseBuffer();
        m_cwsArgv0 = m_cwsFullPathToEXE;    //  Keep the full path version
        CBsString m_cwsRight4 = m_cwsArgv0.Right( 4 );
        m_cwsRight4.MakeLower();
        if ( m_cwsRight4 != L".exe" )
            m_cwsArgv0 += L".exe";
        m_cwsFullPathToEXE = m_cwsFullPathToEXE.Left( m_cwsFullPathToEXE.GetLength() - ::wcslen( pwszFileName ) );
    }
    
    //
    //  Set up checksum format
    //
    if ( m_bDumpCommaDelimited )
        ::wcscpy( m_pwszULongHexFmt, L"0x%08x" );
    else
        ::wcscpy( m_pwszULongHexFmt, L"%08x" );
    
    //
    //  Set up the dump file
    //
    if ( m_cwsDumpFileName.IsEmpty() )
    {
        wprintf( L"fsdump: Printing dump information to 'stdout'\n" );
    }
    else
    {
        CBsString cwsFullPath;        
        LPWSTR pwszFileName;
        
        //
        //  Get the full path name for the dump file in case we change the working
        //  directory later.
        //
        if ( ::GetFullPathName( 
                m_cwsDumpFileName,
                FSD_MAX_PATH,
                cwsFullPath.GetBufferSetLength( FSD_MAX_PATH ),
                &pwszFileName ) == 0 )
        {
            ::fwprintf( stderr, L"ERROR - Unable to get full path name of dump file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 10;
        }
        cwsFullPath.ReleaseBuffer();
        m_cwsDumpFileName = cwsFullPath;
        
        m_fpDump = ::_wfopen( m_cwsDumpFileName, m_bUnicode ? L"wb" : L"w" );
        if ( m_fpDump == NULL )
        {
            ::fwprintf( stderr, L"ERROR - Unable to open dump file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 10;
        }
        if ( m_bNoHeaderFooter )
        {
            //
            //  Try to create a named stream with the header and summary information
            //
            m_fpExtraInfoDump = ::_wfopen( m_cwsDumpFileName + L":Info", m_bUnicode ? L"wb" : L"w" );
            if ( m_fpExtraInfoDump != NULL )
            {
                wprintf( L"fsdump: Printing dump header and summary information to NTFS stream '%s'\n", (m_cwsDumpFileName + L":Info").c_str() );
            }
            else
            {
                m_fpExtraInfoDump = ::_wfopen( m_cwsDumpFileName + L".Info", m_bUnicode ? L"wb" : L"w" );
                if ( m_fpExtraInfoDump != NULL )
                {
                    wprintf( L"fsdump: Printing dump header and summary information to file '%s'\n", (m_cwsDumpFileName + L".Info").c_str() );
                }
                else
                {
                    wprintf( L"fsdump: Unable to create dump header and summary information file '%s'\n", (m_cwsDumpFileName + L".Info").c_str() );
                }
            }
        }
        else
            m_fpExtraInfoDump = m_fpDump;
        wprintf( L"fsdump: Printing dump information to '%s'\n", m_cwsDumpFileName.c_str() );
    }
    
    //
    //  Set up the error log file
    //
    if ( m_cwsErrLogFileName.IsEmpty() )
    {
        wprintf( L"fsdump: Printing errors to 'stderr'\n" );
    }
    else
    {
        CBsString cwsFullPath;        
        LPWSTR pwszFileName;

        //
        //  Get the full path name for the dump file in case we change the working
        //  directory later.
        //
        if ( ::GetFullPathName( 
                m_cwsErrLogFileName,
                1024,
                cwsFullPath.GetBufferSetLength( 1024 ),
                &pwszFileName ) == 0 )
        {
            fwprintf( stderr, L"ERROR - Unable to get full path name of error log file '%s' for write\n", m_cwsDumpFileName.c_str() );
            return 11;
        }
        cwsFullPath.ReleaseBuffer();
        m_cwsErrLogFileName = cwsFullPath;

        m_fpErrLog = ::_wfopen( m_cwsErrLogFileName, m_bUnicode ? L"wb" : L"w" );
        if ( m_fpErrLog == NULL )
        {
            ::fwprintf( stderr, L"ERROR - Unable to open error log file '%s' for write\n", m_cwsErrLogFileName.c_str() );
            return 11;
        }
        ::wprintf( L"fsdump: Printing errors to '%s'\n", m_cwsErrLogFileName.c_str() );
    }

    //
    //  Print out a header in the dump file so that it is easy to determine
    //  if dump formats are the same.
    //
    DumpPrint( VERSION_INFO1 );
    DumpPrint( VERSION_INFO2 );

    //
    //  Dump out the command-line
    //
    CBsString cwsCommandLine;
    for ( INT idx = 0; idx < argc; ++idx )
    {
        cwsCommandLine += L" \"";
        cwsCommandLine += argv[ idx ];
        cwsCommandLine += L"\"";
    }
    DumpPrint( L"  Command-line: %s", cwsCommandLine.c_str() );
    
    //
    //  Enable backup and security privs
    //
    if ( !::AssertPrivilege( SE_BACKUP_NAME ) )
        DumpPrint( L"  n.b. could not get SE_BACKUP_NAME Privilege (%d), will be unable to get certain information",
            ::GetLastError() );
    if ( !::AssertPrivilege( SE_SECURITY_NAME ) )
    {
        DumpPrint( L"  n.b. could not get SE_SECURITY_NAME Privilege (%d), SACL entries information will be invalid",
            ::GetLastError() );
        m_bHaveSecurityPrivilege = FALSE;
    }
    
    DumpPrint( L"  File attributes masked: %04x", m_dwFileAttributesMask );
    DumpPrint( L"  Command line options enabled:" );
    if ( m_bHex )
        DumpPrint( L"    Printing sizes in hexidecimal" );
    if ( m_bNoChecksums )
        DumpPrint( L"    Checksums disabled" );
    if ( m_bUnicode )
        DumpPrint( L"    Unicode output" );
    if ( m_bDontTraverseMountpoints )
        DumpPrint( L"    Mountpoint traversal disabled" );
    if ( !m_bDontChecksumHighLatencyData )
        DumpPrint( L"    High latency data checksum enabled" );
    if ( m_bAddMillisecsToTimestamps )
        DumpPrint( L"    Adding millsecs to timestamps" );
    if ( m_bShowSymbolicSIDNames )
        DumpPrint( L"    Converting SIDs to symbolic DOMAIN\\ACCOUNTNAME format" );
    if ( !m_bDontShowDirectoryTimestamps )
        DumpPrint( L"    Dumping directory timestamps" );
    if ( m_bUseExcludeProcessor )
    {
        if ( m_bDontUseRegistryExcludes )
            DumpPrint( L"    Excluding file based on exclude files" );
        else
            DumpPrint( L"    Excluding file based on FilesNotToBackup reg keys and exclude files" );
    }
    if ( m_bDisableLongPaths )
        DumpPrint( L"    Long path support disabled" );
    if ( m_bEnableObjectIdExtendedDataChecksums )
        DumpPrint( L"    Object Id extended data checksums Enabled" );
    DumpPrint( L"" );
    fflush( GetDumpFile() );
    return 0;
}

/*++

Routine Description:

    Destructor for the CDumpParameters class

Arguments:

    None

Return Value:

    <Enter return values here>

--*/
CDumpParameters::~CDumpParameters()
{
    if ( m_fpDump != NULL && m_fpDump != stdout )
        ::fclose( m_fpDump );
    
    if ( m_fpExtraInfoDump != NULL && m_fpExtraInfoDump != m_fpDump )
        ::fclose( m_fpExtraInfoDump );

    if ( m_fpErrLog != NULL && m_fpErrLog != stderr )
        ::fclose( m_fpErrLog );
}

/*++

Routine Description:

    Enables an NT privilege.  Used to get backup privs in the utility.

Arguments:

    privName - The privilege name.
    
Return Value:

    <Enter return values here>

--*/
static BOOL 
AssertPrivilege( 
    IN LPCWSTR privName 
    )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ftc\ftc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:      ftc.cxx
//
//  Contents:  Fast multi-threaded tree copy program.
//
//  History:   ?-?-94       IsaacHe     Created
//             11-Jun-96    BruceFo     Fixed bugs, put this header here.
//
//--------------------------------------------------------------------------

#if defined( UNICODE )
#undef UNICODE
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <direct.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <conio.h>
#include <errno.h>
#include <process.h>
#include <ctype.h>

#define MAXQUEUE    10000
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/*
 * These are the attributes we use to compare for file attribute identity
 */
const DWORD FILE_ATTRIBUTE_MASK = FILE_ATTRIBUTE_READONLY |
                                  FILE_ATTRIBUTE_HIDDEN   |
                                  FILE_ATTRIBUTE_SYSTEM   |
                                  FILE_ATTRIBUTE_ARCHIVE;

class CProtectedLong
{
    CRITICAL_SECTION    _cs;
    LONG                _value;

public:
    CProtectedLong() { InitializeCriticalSection( &_cs ); _value = 0; }
    LONG operator++(int) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = _value++;
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator--( int ) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = _value--;
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator+=( LONG incr ) {
                        EnterCriticalSection( &_cs );
                        LONG tmp = (_value += incr );
                        LeaveCriticalSection( &_cs );
                        return tmp;
                        }
    LONG operator=( LONG val ) {
                        EnterCriticalSection( &_cs );
                        _value = val;
                        LeaveCriticalSection( &_cs );
                        return val;
                        }
    operator LONG() { return _value; }
    operator int()  { return _value; }
};

class CHandle
{
    HANDLE _h;

public:
    CHandle() : _h(INVALID_HANDLE_VALUE) { }
    ~CHandle();
    HANDLE operator=( HANDLE h );
    BOOL operator==( HANDLE h ) { return (h == _h) ? TRUE : FALSE; }
    BOOL operator!=( HANDLE h ) { return (h != _h) ? TRUE : FALSE; }
    operator HANDLE() { return _h; }
};

CHandle::~CHandle()
{
    if( _h != INVALID_HANDLE_VALUE && _h != NULL )
        CloseHandle( _h );
}

HANDLE
CHandle::operator=( HANDLE h )
{
    if( _h != INVALID_HANDLE_VALUE && _h != NULL )
        CloseHandle( _h );
    return _h = h;
}

DWORD dwElapsedTime;            // time we've been copying data
CProtectedLong ulTotalBytesCopied;     // running total count of bytes
CProtectedLong ulTotalBytesSkipped;    // obvious?
CProtectedLong ulTotalBytesScanned;
CProtectedLong nFilesOnQueue;   // number of files to copy or examine
CProtectedLong nFcopy;          // number of files copied
CProtectedLong nSkipped;        // number of files skipped over
CProtectedLong nMappedCopy;     // number of files copied using MapFile...
CProtectedLong nCopyFile;       // number of files copied using CopyFile()...
CProtectedLong nInProgress;     // number of copies currently in progress
CProtectedLong MaxThreads;      // Max number of threads for copying
DWORD ExitCode = 0;             // each thread's exit code

BOOL bThreadStop = FALSE;       // are we trying to exit?
BOOL bWorkListComplete = FALSE; // have we scanned all the directories yet?

BOOL tFlag = FALSE;             // only copy if newer
BOOL iFlag = FALSE;             // skip seemingly identical files
BOOL rFlag = FALSE;             // replace read-only files
BOOL vFlag = FALSE;             // verbose
BOOL AFlag = FALSE;             // keep going even if there are errors
BOOL FFlag = FALSE;             // just produce file list.  No copies
BOOL oFlag = TRUE;              // should we overwrite files already at dest?
BOOL wFlag = FALSE;             // should we wait for the source to show up?
BOOL qFlag = FALSE;             // quiet mode?
BOOL yFlag = FALSE;             // no recurse on target?
BOOL zFlag = FALSE;             // no recurse on source?

BOOL pFlag = FALSE;             // pattern?
CHAR szPattern[100];            // pattern string, if pFlag is TRUE

struct WorkList                 // copy file at 'src' to 'dest'
{
    struct WorkList *next;
    char *src;                   // Pathname relative to the source
    WIN32_FIND_DATA srcfind;
    char *dest;
} *WorkList = NULL;
struct WorkList* WorkListTail = NULL; // always add files to copy to the *tail*
                                // of the work list. This is to make
                                // sure we always do work in order, instead
                                // of starting on a directory but finishing
                                // it much much much later, because we've
                                // pushed all the work to the deep tail of
                                // the list and never returned to it!

CHandle hWorkAvailSem;           // signalled whenever there's work on the list
CHandle hMaxWorkQueueSem;        // used to control lenght of work queue

CRITICAL_SECTION csMsg;         // used to serialize screen output
CRITICAL_SECTION csWorkList;    // used when manipulating the linked list
CRITICAL_SECTION csSourceList;  // used when manipulating the source list

struct SourceList
{
    char    *name;              // pathname of the source.  Ends in '\'
    LONG    count;              // number of files currently being copied
    LONG    ulTotalFiles;       // total for the entire copy
    struct {
        unsigned valid : 1;     // do we know that the source is valid?
    } flags;
} SourceList[ 20 ];
int MaxSources = 0;

char *DirectoryExcludeList[ 50 ];
int MaxDirectoryExcludes = 0;

char OldConsoleTitle[ 100 ];

void
__cdecl
errormsg( char const *pszfmt, ... )
{
    va_list ArgList;
    va_start( ArgList, pszfmt );

    if( bThreadStop == FALSE && pszfmt != NULL ) {
        EnterCriticalSection( &csMsg );
        vprintf( pszfmt, ArgList );
        LeaveCriticalSection( &csMsg );
    }

    va_end( ArgList );
}

DWORD __stdcall
StatusWorker( void *arg )
{
    char ostatbuf[ 100 ];
    char nstatbuf[ 100 ];

    while( bThreadStop == FALSE ) {
        ULONG Remaining = (int)ulTotalBytesScanned - (int)ulTotalBytesCopied - (int)ulTotalBytesSkipped;
        if (Remaining < 1000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d",
                 (int)nFilesOnQueue,
                 Remaining);
        } else if (Remaining < 1000000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000,
                 Remaining % 1000);
        } else if (Remaining < 1000000000) {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000000,
                 (Remaining / 1000) % 1000,
                 Remaining % 1000,
                 Remaining);
        } else {
            sprintf(nstatbuf,
                 "Remaining Files %d Bytes %d,%03.3d,%03.3d,%03.3d",
                 (int)nFilesOnQueue,
                 Remaining / 1000000000,
                 (Remaining / 1000000) % 1000,
                 (Remaining / 1000) % 1000,
                 Remaining % 1000);
        }

         if( strcmp( ostatbuf, nstatbuf ) ) {
             SetConsoleTitle( nstatbuf );
             strcpy( ostatbuf, nstatbuf );
         }
         Sleep( 1 * 1000 );
    }

    SetConsoleTitle( OldConsoleTitle );
    ExitThread( ExitCode );
    arg = arg;
    return 0;
}

void
__cdecl
msg( char const *pszfmt, ... )
{
    if( qFlag )
        return;

    va_list ArgList;
    va_start( ArgList, pszfmt );

    EnterCriticalSection( &csMsg );
    vprintf( pszfmt, ArgList );
    LeaveCriticalSection( &csMsg );
    va_end( ArgList );
}

void
__cdecl
errorexit (char const *pszfmt, ... )
{

    if( bThreadStop == FALSE && pszfmt != NULL ) {
        va_list ArgList;
        va_start( ArgList, pszfmt );

        EnterCriticalSection( &csMsg );
        vprintf( pszfmt, ArgList );
        LeaveCriticalSection( &csMsg );

        va_end( ArgList );
    }

    if( AFlag == FALSE ) {
        bThreadStop = TRUE;

        EnterCriticalSection( &csWorkList );
        WorkList = NULL;
        WorkListTail = NULL;
        LeaveCriticalSection( &csWorkList );

        if( hWorkAvailSem != NULL )
            ReleaseSemaphore( hWorkAvailSem, (int)MaxThreads+1, NULL );

        if( hMaxWorkQueueSem != NULL )
            ReleaseSemaphore( hMaxWorkQueueSem, 1, NULL );

        SetConsoleTitle( OldConsoleTitle );
        ExitThread (ExitCode = 1);
    }
}

DWORD
fcopy( char *src, WIN32_FIND_DATA *srcfind, char *dst, char *errorbuf )
{
    CHandle srcfh;
    CHandle dstfh;
    CHandle hsrc;
    DWORD nBytesWritten, totalbytes;
    char *result = NULL;
    char *psrc;
    BOOL ret = TRUE;
    char dostatus = 0;
    DWORD errcode;

    *errorbuf = '\0';

    if( srcfind->nFileSizeHigh != 0 ) {
        if( CopyFile( src, dst, TRUE ) == FALSE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "CopyFile failed, error %d", errcode );
            return errcode;
        }
        nCopyFile++;

    } else {

        srcfh = CreateFile( src, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
        if( srcfh == INVALID_HANDLE_VALUE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "Unable to open source file, error %d", errcode);
            return errcode;
        }

        dstfh = CreateFile( dst, GENERIC_WRITE, FILE_SHARE_WRITE,NULL,
                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, srcfh);

        if( dstfh == INVALID_HANDLE_VALUE ) {
            errcode = GetLastError();
            sprintf( errorbuf, "Unable to create dest file, error %d", errcode);
            return errcode;
        }

        if( srcfind->nFileSizeLow != 0 ) {
            hsrc = CreateFileMapping( srcfh, NULL, PAGE_READONLY, 0,
                    srcfind->nFileSizeLow, NULL );
            if( hsrc == NULL ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "Unable to create file mapping, and CopyFile failed, error %d", errcode );
                    return errcode;
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }
            if( (psrc = (char *)MapViewOfFile( hsrc, FILE_MAP_READ, 0, 0, 0 )) == NULL){
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "Unable to map source file, and CopyFile failed: error %d", errcode );
                    return errcode;
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }
            totalbytes = 0;
            while( !bThreadStop && totalbytes < srcfind->nFileSizeLow && ret == TRUE ) {
                ret = WriteFile( dstfh,
                    psrc + totalbytes,
                    min( 64*1024, srcfind->nFileSizeLow - totalbytes ),
                    &nBytesWritten, NULL );
                totalbytes += nBytesWritten;
                ulTotalBytesCopied += nBytesWritten;
            }
            errcode = GetLastError();
            UnmapViewOfFile( psrc );

            if( bThreadStop == TRUE ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                *errorbuf = '\0';
                return errcode;
            }

            if( ret == FALSE ) {
                dstfh = INVALID_HANDLE_VALUE;
                DeleteFile( dst );
                if( CopyFile( src, dst, TRUE ) == FALSE ) {
                    errcode = GetLastError();
                    sprintf( errorbuf, "%s: CopyFile failed: error %d", dst, errcode);
                    return GetLastError();
                }
                nCopyFile++;
                ulTotalBytesCopied += srcfind->nFileSizeLow;
                goto DoTime;
            }

            nMappedCopy++;
        }
    }

DoTime:
    if( dstfh == INVALID_HANDLE_VALUE ) {
        dstfh = CreateFile( dst, GENERIC_WRITE,
                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                 0, NULL );
    }

    if( dstfh == INVALID_HANDLE_VALUE ) {
        errcode = GetLastError();
        DeleteFile( dst );
        sprintf( errorbuf,  "Unable to open destination file to set time, error %d", errcode );
        return errcode;
    }

    if( !SetFileTime( dstfh, &srcfind->ftCreationTime,
         &srcfind->ftLastAccessTime, &srcfind->ftLastWriteTime )) {
             errcode = GetLastError();
             sprintf( errorbuf, "Unable to set destination file times, error %d\n", errcode );
            return errcode;
    }

    nFcopy++;
    return 0;
}

/*
 * Pick the source having the fewest outstanding operations at the moment.
 */
int
SelectSource()
{
    int index = -1;
    struct SourceList *psl;
    struct SourceList *opsl;
    static min;

    EnterCriticalSection( &csSourceList );

    //
    // Find the first valid source
    //
    for( opsl = SourceList; opsl < &SourceList[ MaxSources ]; opsl++ )
            if( opsl->flags.valid == TRUE )
                break;

    //
    // Now locate the source having the fewest pending operations right now
    //
    for( psl = opsl+1; psl < &SourceList[ MaxSources ]; psl++ ) {
        if( psl->flags.valid == TRUE && psl->count < opsl->count )
            opsl = psl;
    }

    if( opsl->flags.valid == TRUE ) {
        opsl->count++;
        index = (int)(opsl - SourceList);
    }

    LeaveCriticalSection( &csSourceList );

    return index;
}

/*
 * We've completed the operation on source 'index'
 */
void
SourceCopyComplete( int index, BOOL fFile )
{
    EnterCriticalSection( &csSourceList );
    SourceList[ index ].count--;
    if (fFile) SourceList[ index ].ulTotalFiles++;
    LeaveCriticalSection( &csSourceList );
}

void
DisableSource( int index )
{
    if( index >= 0 && index < MaxSources ) {
        EnterCriticalSection( &csSourceList );
        if( SourceList[ index ].flags.valid == TRUE ) {
            errormsg( "Disabling %s\n", SourceList[ index ].name );
            SourceList[ index ].flags.valid = FALSE;
        }
        LeaveCriticalSection( &csSourceList );
    }
}
BOOL
FileTimesEqual( CONST FILETIME *pt1, CONST FILETIME *pt2 )
{
    SYSTEMTIME s1, s2;

    if( !FileTimeToSystemTime( pt1, &s1 ) || !FileTimeToSystemTime( pt2, &s2 ) )
        return FALSE;

    return  s1.wHour == s2.wHour &&
            s1.wMinute == s2.wMinute &&
            s1.wMonth == s2.wMonth &&
            s1.wDay == s2.wDay &&
            s1.wYear == s2.wYear;
}
void
PrintFileTime( char *str, CONST FILETIME *ft )
{
    SYSTEMTIME st;

    if( FileTimeToSystemTime( ft, &st ) == FALSE ) {
        errormsg( "????\n" );
        return;
    }

    msg( "%s %u:%u.%u.%u  %u/%u/%u\n", str,
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
        st.wMonth, st.wDay, st.wYear );
}

DWORD __stdcall
ThreadWorker( void *arg )
{
    struct WorkList *pdl = NULL;
    HANDLE hdestfind;
    WIN32_FIND_DATA destfind;
    int index = 0;
    char errorbuf[ 100 ];
    char pathbuf[ MAX_PATH ];
    DWORD errcode;

    MaxThreads++;

    while( 1 ) {
        if( pdl != NULL ) {
            free( pdl->src );
            free( pdl->dest );
            free( pdl );
            pdl = NULL;
        }

        if( bThreadStop == TRUE )
            break;

        // Poll for new stuff every 2 seconds. If the thread is set to stop,
        // then go away.
        DWORD dwWait;
        while( 1 )
        {
            dwWait = WaitForSingleObject( hWorkAvailSem, 1000 );
            if( dwWait == WAIT_OBJECT_0 ) {
                break;
            }

            if( dwWait == WAIT_TIMEOUT ) {
                if( bThreadStop == TRUE )
                    break;
            } else {
                errormsg( "Thread %p: Semaphore wait failed\n", arg );
                break;
            }
        }
        if ( dwWait != WAIT_OBJECT_0 ) {
            break;
        }

        // pick an item off the head of the work list
        EnterCriticalSection( &csWorkList );
        pdl = WorkList;
        if( pdl != NULL ) {
            WorkList = pdl->next;
            if (NULL == WorkList) {
                // just pulled off the tail entry
                WorkListTail = NULL;
            }
        }
        LeaveCriticalSection( &csWorkList );
        ReleaseSemaphore( hMaxWorkQueueSem, 1, NULL );

        if( pdl == NULL )
            break;

        nFilesOnQueue--;

        if( pdl->srcfind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                errormsg( "Logic Error:  Directory on work list!\n" );
                continue;
        }

        pdl->srcfind.dwFileAttributes &= FILE_ATTRIBUTE_MASK;

        hdestfind = FindFirstFile( pdl->dest, &destfind );
        if( hdestfind != INVALID_HANDLE_VALUE ) {
            FindClose( hdestfind );
            destfind.dwFileAttributes &= FILE_ATTRIBUTE_MASK;

            /*
             * Destination file exists.  What should we do?
             */

            if( oFlag == FALSE ) {
                /*
                 * We should not overwrite the existing file at the dest
                 */
                if( vFlag )
                    msg( "%s [SKIP: exists]\n", pdl->dest );
                ulTotalBytesSkipped += destfind.nFileSizeLow;
                nSkipped++;
                continue;
            }

            if( iFlag && vFlag ) {

                if( destfind.dwFileAttributes !=pdl->srcfind.dwFileAttributes)
                    msg( "%s [ ATTRIBUTES differ ]\n", pdl->dest );
                if(!FileTimesEqual( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime)) {
                    EnterCriticalSection( &csMsg );
                    msg( "%s [ TIMES differ ]\n", pdl->dest );
                    PrintFileTime( "Dest: ", &destfind.ftLastWriteTime );
                    PrintFileTime( "Src: ", &pdl->srcfind.ftLastWriteTime );
                    LeaveCriticalSection( &csMsg );
                }
                if( (destfind.nFileSizeHigh != pdl->srcfind.nFileSizeHigh) ||
                (destfind.nFileSizeLow != pdl->srcfind.nFileSizeLow) )
                    msg( "%s [ SIZES differ ]\n", pdl->dest );
            }

            if( iFlag &&
                (destfind.dwFileAttributes == pdl->srcfind.dwFileAttributes) &&
                FileTimesEqual( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime) &&
                (destfind.nFileSizeHigh == pdl->srcfind.nFileSizeHigh) &&
                (destfind.nFileSizeLow == pdl->srcfind.nFileSizeLow) ) {
                    if( vFlag )
                        msg("%s [SKIP: same atts, time, size]\n",pdl->dest);
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
            }

            if( tFlag &&
                CompareFileTime( &destfind.ftLastWriteTime, &pdl->srcfind.ftLastWriteTime) >= 0 ) {
                    if( vFlag )
                        msg("%s [SKIP: same or newer time]\n", pdl->dest );
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
            }

            if( destfind.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
                if( rFlag == FALSE && bThreadStop == FALSE ) {
                    if( vFlag )
                        msg( "%s [SKIP: readonly]\n", pdl->dest );
                    ulTotalBytesSkipped += destfind.nFileSizeLow;
                    nSkipped++;
                    continue;
                }

            /*
             * Delete the destination file
             */
            if( destfind.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) {
                destfind.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes( pdl->dest, destfind.dwFileAttributes );
            }

            if( FFlag == FALSE )
                (void)DeleteFile( pdl->dest );

        }

        if( FFlag == FALSE ) {
            while( bThreadStop == FALSE && (index = SelectSource()) >= 0 ) {
                strcpy( pathbuf, SourceList[index].name );
                strcat( pathbuf, pdl->src );

                nInProgress++;
                errcode = fcopy( pathbuf,&pdl->srcfind,pdl->dest,errorbuf);
                nInProgress--;

                if( errcode == 0 ) {
                    SourceCopyComplete( index, TRUE );
                    msg("%s -> %s [OK]\n", pathbuf, pdl->dest );
                    SetFileAttributes(pdl->dest,pdl->srcfind.dwFileAttributes);
                    break;
                }

                if( errcode == ERROR_SWAPERROR ) {
                    errormsg( "%s [ SWAP ERROR, will try again... ]\n",pathbuf);
                    Sleep( 5 * 1000 * 60 );
                    continue;
                }
                if( bThreadStop == FALSE )
                    errormsg( "%s [FAILED: %s ]\n", pathbuf, errorbuf );
                if( AFlag == TRUE )
                    break;
                DisableSource( index );
            }
        } else {
            msg( "%s\n", pdl->dest );
        }

        if( AFlag == FALSE && index < 0 )
            errorexit( "%s [FAILED completely]\n", pdl->dest );
    }

    if( pdl != NULL ) {
        free( pdl->src );
        free( pdl->dest );
        free( pdl );
    }

    if( MaxThreads-- == 1 ) {
        if( ExitCode == 0 ) {
            dwElapsedTime = GetTickCount() - dwElapsedTime;
            dwElapsedTime /= 1000;
            BOOL oldqFlag = qFlag;
            qFlag = FALSE;
            msg( "%u files copied (%u memory mappped, %u CopyFile )\n",
                   (int)nFcopy, (int)nMappedCopy, (int)nCopyFile );
            msg( "%u files skipped\n", (int)nSkipped);
            msg( "%lu bytes in %u seconds: %lu bits/sec\n",
                   (int)ulTotalBytesCopied, dwElapsedTime,
                   dwElapsedTime ? (LONG)(((LONG)ulTotalBytesCopied*8L)/dwElapsedTime) : 0L );

            qFlag = oldqFlag;
            EnterCriticalSection( &csSourceList );
            for (int i = 0; i < MaxSources; i++)
            {
               if (TRUE == SourceList[i].flags.valid)
               {
                   msg( "%s %5lu files\n", SourceList[i].name, SourceList[i].ulTotalFiles);
               }
            }
            LeaveCriticalSection( &csSourceList );
        }
        SetConsoleTitle( OldConsoleTitle );
        ExitProcess( ExitCode );
    }

    ExitThread( ExitCode );
    return 0;
}

void
AddToWorkList(  char *src, char *dest, WIN32_FIND_DATA *pfind )
{
    struct WorkList *pdl;

    if( WaitForSingleObject( hMaxWorkQueueSem, INFINITE ) != WAIT_OBJECT_0 ) {
        errormsg( "Semaphore wait failed, can't add to work list\n" );
        return;
    }

    if( bThreadStop == TRUE )
        return;

    if( (pdl = (struct WorkList *)malloc( sizeof( struct WorkList ) ) ) == NULL ){
        errorexit( "Out of Memory!\n" );
        return;
    }

    if( (pdl->dest = _strdup( dest )) == NULL ) {
        errorexit( "Out of memory!\n" );
        free( pdl );
        return;
    }

    if( (pdl->src = _strdup( src )) == NULL ) {
        errorexit( "Out of memory!\n" );
        free( pdl->dest );
        free( pdl );
        return;
    }

    pdl->srcfind = *pfind;
    pdl->next = NULL;

    EnterCriticalSection( &csWorkList );
    if (NULL == WorkList) {
        WorkListTail = WorkList = pdl;
    } else {
        WorkListTail->next = pdl;   // point the tail to the new entry
        WorkListTail = pdl;         // the new entry becomes the tail
    }
    LeaveCriticalSection( &csWorkList );

    nFilesOnQueue++;
    ReleaseSemaphore( hWorkAvailSem, 1, NULL );
}

void
ScanDirectory(
    char            *relpath,
    char            *dest
    );

void
ScanDirectoryHelp(
    char            *relpath,          // path relative to the source
    char            *dest,             // resulting destination directory
    BOOL            fOnlyDirectories,  // TRUE if we only want to look for dirs
    BOOL            fOnlyFiles         // TRUE if we only want to look for files
    )
{
    int index;
    int destlen = strlen( dest );
    int rellen = strlen( relpath );
    WIN32_FIND_DATA fbuf;
    HANDLE hfind = INVALID_HANDLE_VALUE;
    char SourceName[ MAX_PATH ];

    while( 1 ) {
        if( (index = SelectSource()) < 0 )
            return;
        /*
         * FindFirst/Next is such low overhead on the server that we shouldn't
         * really count it as a load on the server...
         */
        SourceCopyComplete( index, FALSE );

        strcpy( SourceName, SourceList[ index ].name );
        if( rellen ) {
            strcat( SourceName, relpath );
            strcat( SourceName, "\\" );
        }

        strcat( SourceName,
                fOnlyDirectories
                    ? "*.*"
                    : (pFlag ? szPattern : "*.*" ) );

        hfind = FindFirstFile( SourceName, &fbuf );
        if( hfind != INVALID_HANDLE_VALUE )
            break;

        if (pFlag && ERROR_FILE_NOT_FOUND == GetLastError()) {
            // simply no files that match the pattern in the directory
            return;
        }

        errormsg( "Dir scan of %s failed, error %d [DISABLING]\n", SourceName, GetLastError() );
        DisableSource( index );
    }

    do {
        if( !strcmp( fbuf.cFileName, "." ) || !strcmp( fbuf.cFileName, ".." ) )
            continue;

        sprintf( &dest[ destlen ], "%s%s",
            dest[destlen-1] == '\\' ? "" : "\\", fbuf.cFileName );

        if((fbuf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
            //
            // Not a directory
            //

            if (fOnlyDirectories) {
                continue;
            }

            /*
             * Queue this file into the work queue!
             */
            if( rellen ) {
                strcpy( SourceName, relpath );
                strcat( SourceName, "\\" );
            } else
                SourceName[0] = '\0';

            strcat( SourceName, fbuf.cFileName );
            ulTotalBytesScanned += fbuf.nFileSizeLow;
            AddToWorkList( SourceName, dest, &fbuf );
            continue;
        }

        /*
         * We've found a directory.  Descend into it and scan (if we're
         * not excluding it)
         */

        if (fOnlyFiles) {
            continue;
        }

        if (zFlag) { // no recurse on source: ignore it!
            continue;
        }

        for( int i=0; i < MaxDirectoryExcludes; i++ )
            if( !_stricmp( DirectoryExcludeList[i], fbuf.cFileName ) )
                break;

        if( i != MaxDirectoryExcludes ) {
            if( vFlag )
                msg( "Directory: %s [EXCLUDED]\n", dest );
            nSkipped++;
            continue;
        }

        sprintf( &relpath[ rellen ], "%s%s", rellen ? "\\":"", fbuf.cFileName );
        if (yFlag) { // no recurse on target: nuke end of dest (the new dir)
            dest[ destlen ] = '\0';
        }
        ScanDirectory( relpath, dest );
        relpath[ rellen ] = '\0';

    } while( !bThreadStop && FindNextFile( hfind, &fbuf ) == TRUE );

    dest[ destlen ] = '\0';

    FindClose( hfind );
}

void
ScanDirectory(
    char            *relpath,           // path relative to the source
    char            *dest               // resulting destination directory
    )
{
    DWORD dwattrs;

    if( (dwattrs = GetFileAttributes( dest )) == 0xFFFFFFFF ) {
        msg( "Creating Directory: %s\n", dest );
        if( FFlag == FALSE && CreateDirectory( dest, NULL ) == FALSE ) {
            errorexit( "Can not create directory: %s\n", dest );
            return;
        }

    } else if( !(dwattrs & FILE_ATTRIBUTE_DIRECTORY) ) {
            errorexit( "Not a directory: %s\n", dest );
            return;
    }

    if (pFlag) {
        // two passes: one looking for files, one looking for directories

        ScanDirectoryHelp(relpath, dest, FALSE, TRUE);
        ScanDirectoryHelp(relpath, dest, TRUE,  FALSE);
    } else {
        ScanDirectoryHelp(relpath, dest, FALSE, FALSE);
    }
}

static void
appendslash( char *p )
{
    if( p[ strlen(p) - 1 ] != '\\' )
        strcat( p, "\\" );
}

BOOL
rootpath( char *src, char *dst )
{
    char* FilePart;
    char *p;

    if( src == NULL || *src == '\0' )
        return FALSE;

    if( GetFullPathName( src, MAX_PATH, dst, &FilePart ) == 0 )
        return FALSE;

    p = src + strlen(src) - 1;
    if( *p == '.' )
        if( p > src ) {
            p--;
            if( *p != '.' && *p != ':' && (*p == '\\' || *p == '/') )
                strcat( dst, "." );
        }

    return TRUE;
}

static void
Usage( char *s )
{
    errormsg( "Usage: %s [flags] [-p pattern] [src ...] dest\n", s );
    errormsg( "Flags:\n" );

    errormsg( "\t-i   Skip seemingly identical files (time, attrs, size agree)\n" );
    errormsg( "\t-l   Execute at lower priority\n" );
    errormsg( "\t-o   Do not overwrite any files that are already at dest\n" );
    errormsg( "\t-p pattern  Only files matching the pattern are copied\n" );
    errormsg( "\t-q   Quiet mode\n" );
    errormsg( "\t-r   Overwrite read-only files at dest\n" );
    errormsg( "\t-t   Copy only newer files to dest\n" );
    errormsg( "\t-v   Verbose\n" );
    errormsg( "\t-y   Don't recurse on target\n" );
    errormsg( "\t-z   Don't recurse on source\n" );
    errormsg( "\t-A   Keep going even if there are errors\n" );
    errormsg( "\t-F   Don't actually copy files or create directories\n" );
    errormsg( "\t~dir Skip any directory named 'dir'\n" );
    errormsg( "\nIf environment variable FTC_PARANOID is set, then the meaning of -o is\n" );
    errormsg( "reversed: no -o means don't overwrite, -o means go ahead and overwrite.\n" );

    errormsg( "\nExamples:\n" );
    errormsg( "    Copy from two sources, no 'obj' dir:    ftc ~obj \\\\foo\\dir \\\\bar\\dir dest\n" );
    ExitProcess( 1 );
}

BOOL __stdcall
ControlHandlerRoutine( DWORD dwCtrlType )
{
    msg( "Interrupted!\n" );
    bThreadStop = TRUE;
    ExitCode = 1;
    return TRUE;
}


int
__cdecl
main(int argc, char *argv[])
{
    char *p;
    SECURITY_ATTRIBUTES sa;
    int i, argno;
    DWORD IDThread;
    char dest[ MAX_PATH ];
    char relpath[ MAX_PATH ];
    BOOL lFlag = FALSE;             // low priority?
    BOOL fParanoid = FALSE;         // is FTC_PARANOID set in the environment?
    SYSTEM_INFO si;
    CHandle CThread;

    InitializeCriticalSection( &csMsg );
    InitializeCriticalSection( &csWorkList );
    InitializeCriticalSection( &csSourceList );
    ZeroMemory(&si, sizeof( si ));
    GetConsoleTitle( OldConsoleTitle, sizeof( OldConsoleTitle ) );

    TCHAR szParanoid[100];
    DWORD len = GetEnvironmentVariable(TEXT("FTC_PARANOID"), szParanoid, ARRAYLEN(szParanoid));
    if (len > 0)
    {
        fParanoid = TRUE;
    }

    if (fParanoid)
    {
        oFlag = FALSE;
    }
    else
    {
        oFlag = TRUE;
    }

    for( argno = 1;
         argno < argc && (argv[argno][0] == '-' || argv[argno][0] == '/' || argv[argno][0] == '~') ;
         argno++ )
    {
        if( argv[argno][0] == '~' )
        {
            DirectoryExcludeList[ MaxDirectoryExcludes++ ] = &argv[argno][1];

        }
        else for( int j=1; argv[argno][j]; j++ )
        {
            switch( argv[argno][j] ) {
            case 'l':
                lFlag = TRUE;
                break;
            case 'q':
                qFlag = TRUE;
                break;
            case 'y':
                yFlag = TRUE;
                break;
            case 'z':
                zFlag = TRUE;
                break;
            case 'w':
                wFlag = TRUE;
                break;
            case 'o':
                if (fParanoid)
                {
                    oFlag = TRUE;
                }
                else
                {
                    oFlag = FALSE;
                }
                break;
            case 'F':
                FFlag = TRUE;
                break;
            case 'A':
                AFlag = TRUE;
                break;
            case 'p':
                if( j == 1 ) {
                    if ( strcmp( &argv[argno][j], "p" ) == 0 ) {
                        if (argno + 1 < argc) {
                            pFlag = TRUE;
                            strcpy( szPattern, argv[++argno] );
                            goto nextarg;  // go to next argument
                        } else Usage( argv[0] );
                    } else Usage( argv[0] );
                } else Usage( argv[0] );
                break;
            case 'v':
                vFlag = TRUE;
                break;
            case 'r':
                rFlag = TRUE;
                break;
            case 'i':
                iFlag = TRUE;
                break;
            case 't':
                tFlag = TRUE;
                break;
            default:
            case '?':
                Usage( argv[0] );
                break;

            }
        }

nextarg:
        ;

    }

    for( ; argno < argc-1; argno++ ) {
        if( rootpath( argv[argno], dest ) == FALSE ) {
            errorexit( "invalid source\n" );
            ExitProcess(1);
        }
        for( p = dest; *p; p++ )
            if( *p == '/' )
                *p = '\\';
        if( (SourceList[ MaxSources ].name = (char *)malloc( strlen( dest ) + 2 )) == NULL ) {
            errorexit( "Out of memory!\n" );
            ExitProcess(1);
        }
        strcpy( SourceList[ MaxSources++ ].name, dest );
    }

    if( MaxSources == 0 )
        Usage( argv[0] );

    for( i=0; i < MaxDirectoryExcludes; i++ )
        msg( "Exclude Directory: %s\n", DirectoryExcludeList[i] );

    while( 1 ) {
        char statusbuffer[ MAX_PATH ];

        for( i=0; i < MaxSources; i++ ) {
            appendslash( SourceList[i].name );
            if( vFlag == TRUE || wFlag == FALSE )
                msg( "Validating %s....", SourceList[i].name );
            sprintf( statusbuffer, "Validating %s", SourceList[i].name );
            SetConsoleTitle( statusbuffer );
            if( GetFileAttributes( SourceList[i].name ) == 0xFFFFFFFF ) {
                if( vFlag == TRUE || wFlag == FALSE )
                    msg( "[DISABLING %s]\n", SourceList[i].name );
                SourceList[i].flags.valid = FALSE;
            } else {
                SourceList[i].flags.valid = TRUE;
                if( vFlag == TRUE || wFlag == FALSE )
                    msg( "[OK]\n" );
            }
        }

        for( i=0; i < MaxSources; i++ )
            if( SourceList[i].flags.valid == TRUE )
                break;

        if( i != MaxSources )
            break;

        if( wFlag == TRUE ) {
            SetConsoleTitle( "Sleeping awhile..." );
            Sleep( 3 * 1000 * 60 );
        } else {
            SetConsoleTitle( OldConsoleTitle );
            ExitProcess(1);
        }
    }

    SetConsoleTitle( "Sources Present" );
    LONG cThreads = (MaxSources * 3) + 1;

    /*
     * hack for ftc -w -678 to exit when the release shares are available
     */
    if( argno == argc && wFlag )
        ExitProcess( 0 );

    if ( argno != argc - 1 ) {
            Usage( argv[0] );
    } else if (rootpath (argv[argno], dest) == FALSE ) {
            errorexit( "Invalid destination\n" );
            ExitProcess(1);
    }

    for( p = dest; *p; p++ )
        if( *p == '/' )
            *p = '\\';

    for( i=0; i < MaxSources; i++ )
          if (!strcmp(SourceList[i].name, dest)) {
              errorexit("Source == dest == %s", SourceList[i].name );
              ExitThread(1);
          }

    /*
     * Create the semaphores for the work lists
     */
    sa.nLength = sizeof( sa );
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    if( (hWorkAvailSem = CreateSemaphore( &sa, 0, 100000, NULL)) == NULL ) {
        errorexit( "Unable to create semaphore (err %u)!\n", GetLastError() );
        ExitProcess(1);
    }

    hMaxWorkQueueSem = CreateSemaphore( &sa, MAXQUEUE, MAXQUEUE, NULL );
    if( hMaxWorkQueueSem == NULL ) {
        errorexit( "Unable to create queue length semaphore (err %u)!\n", GetLastError() );
        ExitProcess( 1 );
    }

    /*
     * Create the thread pool to do the copies
     */
    for( i=0; i < cThreads - 1; i++ ) {
        CThread = CreateThread( (LPSECURITY_ATTRIBUTES)NULL, 0,
              ThreadWorker, (LPVOID *)IntToPtr(i), 0, &IDThread );
        if( CThread == NULL || CThread == INVALID_HANDLE_VALUE )
            break;
        SetThreadPriority( CThread, THREAD_PRIORITY_NORMAL );
        CThread = INVALID_HANDLE_VALUE;
    }

    /*
     * Create the 'update status' thread
     */
    CThread = CreateThread( (LPSECURITY_ATTRIBUTES)NULL, 0,
                            StatusWorker,(LPVOID *)0,0,&IDThread );
    if( CThread != NULL && CThread != INVALID_HANDLE_VALUE ) {
//        SetThreadPriority( CThread, THREAD_PRIORITY_BELOW_NORMAL );
        CThread = INVALID_HANDLE_VALUE;
    }

    SetConsoleCtrlHandler( ControlHandlerRoutine, TRUE );

    /*
     * Produce the directory list
     */
    relpath[0] = '\0';
    dwElapsedTime = GetTickCount();

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );
    ScanDirectory( relpath, dest );

    if( lFlag )
        SetPriorityClass( GetCurrentProcess(), IDLE_PRIORITY_CLASS );

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL );

    // OK, now hWorkAvailSem has a count for every item to copy. But when they
    // finish copying, each thread waits on this semaphore again. At the end,
    // everyone will still be waiting! So, add the number of threads to the
    // count, so each thread notices, one by one, that everything's done.
    ReleaseSemaphore( hWorkAvailSem, (int)cThreads+1, NULL );

    if( bThreadStop == FALSE )
        ThreadWorker( 0 );

    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\genlvl\genlvl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    genlvl.c

Abstract:

    This module implements a program which generates the debug print filter
    component id enumeration and the system filter table that are used by
    various components in the system to dynamically filter debug print
    output.

    Two files are generated by this program. A header file that declares an
    enumeration of debug print filter component id, and a source file that
    declares and initializes the individual component filter variables.

Author:

    David N. Cutler (davec) 7-Jan-2000

Environment:

    User mode.

Revision History:

    None.

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

//
// Increment this everytime a change to this file is made.
//

#define GENLVL_VERSION "1.0"

//
// Define component name table.
//

#define MAXIMUM_NAMES 4096

PCHAR ComponentNameTable[MAXIMUM_NAMES + 1] = {NULL};

//
// Define forward referenced prototypes.
//

ULONG
InsertName(
    IN PCHAR NewName
    );

ULONG
GenerateCmHeaderFile(
    FILE *OutputFile
    );

ULONG
GenerateCmSourceFile(
    FILE *OutputFile
    );

ULONG
GenerateKdSourceFile(
    FILE *OutputFile
    );

ULONG
GenerateNtHeaderFile(
    FILE *OutputFile
    );

//
// Main program.
//

int __cdecl
main(
    int argc,
    char *argv[]
    )

{

    CHAR Buffer[132];
    CHAR CmHeaderFileName[128];
    FILE *CmHeaderFile;
    CHAR CmSourceFileName[128];
    FILE *CmSourceFile;
    ULONG Count;
    PCHAR ComponentDirectory;
    FILE *ComponentFile = NULL;
    CHAR ComponentFileName[128];
    int ExitCode = 0;
    CHAR NtHeaderFileName[128];
    FILE *NtHeaderFile = NULL;
    FILE *KdSourceFile = NULL;
    CHAR KdSourceFileName[128];
    PCHAR TargetDirectory;

    //
    //  Parse arguments.
    //

    if (argc == 2 && (!strcmp(argv[1],"-?") || !strcmp(argv[1],"/?"))) {
        goto PrintUsage;
    }

    //
    // Determine name of target directory for generated files. This requires
    // the -t switch be specified and that the argument after the switch is
    // the target directory name. If no -t switch is specfied, then default
    // to ".".
    //

    if (argc >= 3 && !_stricmp(argv[1],"-t")) {
        TargetDirectory = argv[2];
        argc -= 2;
        argv += 2;

    } else {
        TargetDirectory = ".";
    }

    //
    // Determine name of the component id directory. This is the last input
    // command line argument. If a component id directory is not specified,
    // then default to ".".
    //

    if (argc >= 2) {
        ComponentDirectory = argv[1];
        argc -= 1;
        argv += 1;

    } else {
        ComponentDirectory = ".";
    }

    //
    // There should be no more arguments.
    //

    if (argc != 1) {
        printf("\n  Manformed command line\n");
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the component id input file.
    //

    sprintf(&ComponentFileName[0], "%s\\componentid.tab", ComponentDirectory);
    ComponentFile = fopen(&ComponentFileName[0], "r");
    if (!ComponentFile) {
        printf("\n  Unable to open component id file %s\n", &ComponentFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the kernel debugger source output file.
    //

    sprintf(&KdSourceFileName[0], "%s\\dpfilter.c", TargetDirectory);
    KdSourceFile = fopen(&KdSourceFileName[0], "w");
    if (!KdSourceFile) {
        printf("\n  Unable to open filter source file %s\n", &KdSourceFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the configuration manager header output file.
    //

    sprintf(&CmHeaderFileName[0], "%s\\dpfiltercm.h", TargetDirectory);
    CmHeaderFile = fopen(&CmHeaderFileName[0], "w");
    if (!CmHeaderFile) {
        printf("\n  Unable to open filter source file %s\n", &CmHeaderFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the configuration manager source output file.
    //

    sprintf(&CmSourceFileName[0], "%s\\dpfiltercm.c", TargetDirectory);
    CmSourceFile = fopen(&CmSourceFileName[0], "w");
    if (!CmSourceFile) {
        printf("\n  Unable to open filter source file %s\n", &CmSourceFileName[0]);
        ExitCode = 1;
        goto PrintUsage;
    }

    //
    // Open the ntrtl.w append header output file.
    //

    sprintf(&NtHeaderFileName[0], "%s\\dpfilter.h", TargetDirectory);
    NtHeaderFile = fopen(&NtHeaderFileName[0], "w");
    if (!NtHeaderFile) {
        printf("\n  Unable to open filter header file %s\n", &NtHeaderFileName[0]);
        ExitCode = 1;
PrintUsage:
        printf("GENLVL: Debug Print Filter Generator. Version " GENLVL_VERSION "\n");
        printf(" Usage: genlvl [-t target directory] [componentid.tab directory]\n");
        goto Exit;
    }

    //
    // Read component id table.
    //

    Count = 0;
    while (fgets(&Buffer[0], 132, ComponentFile) != NULL) {

        //
        // If the the line is null, begins with a blank, or begins with
        // a semicolon, then skip it.
        //

        if ((Buffer[0] == 0) ||
            (Buffer[0] == '\n') ||
            (Buffer[0] == ' ') ||
            (Buffer[0] == ';')) {
            continue;
        }

        //
        // Insert the component name in the component name table.
        //

        Count += InsertName(&Buffer[0]);
        if (Count >= MAXIMUM_NAMES) {
            printf(" Component name table overflow at name %s\n", &Buffer[0]);
            ExitCode = 1;
            goto Exit;
        }
    }

    //
    // Check to determine if an error of eof was encountered.
    //

    if (feof(ComponentFile) == 0) {
        printf(" Error encountered while reading component name file\n");
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate configuration manager header file.
    //

    if (GenerateCmHeaderFile(CmHeaderFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate configuration manager source file.
    //

    if (GenerateCmSourceFile(CmSourceFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate kernel debugger source file.
    //

    if (GenerateKdSourceFile(KdSourceFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Generate ntrtl.w append header file.
    //

    if (GenerateNtHeaderFile(NtHeaderFile) == 0) {
        ExitCode = 1;
        goto Exit;
    }

    //
    // Common program exit.
    //
    // Close any files that are open and exit with appropriate exit code.
    //

Exit:
    if (CmHeaderFile != NULL) {
       fclose(CmHeaderFile);
    }

    if (CmSourceFile != NULL) {
        fclose(CmSourceFile);
    }

    if (ComponentFile != NULL) {
        fclose(ComponentFile);
    }

    if (KdSourceFile != NULL) {
        fclose(KdSourceFile);
    }

    if (NtHeaderFile != NULL) {
       fclose(NtHeaderFile);
    }

    return ExitCode;
}

ULONG
GenerateCmHeaderFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// External component filter level definitions.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "extern ULONG Kd_%s_Mask;\n", Name);
        Count += 1;
    }

    fprintf(OutputFile, "\n");
    return TRUE;
}

ULONG
GenerateCmSourceFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Debug print filter level initialization.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    { L\"Session Manager\\\\Debug Print Filter\",\n");
        fprintf(OutputFile, "      L\"%s\",\n", Name);
        fprintf(OutputFile, "      &Kd_%s_Mask,\n", Name);
        fprintf(OutputFile, "      NULL,\n");
        fprintf(OutputFile, "      NULL\n");
        fprintf(OutputFile, "    },\n");
        fprintf(OutputFile, "\n");
        Count += 1;
    }

    return TRUE;
}

ULONG
GenerateKdSourceFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments and typedef.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component filter levels.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");

    //
    // Output all the component variable names with initialization.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "ULONG Kd_%s_Mask = 0;\n", Name);
        Count += 1;
    }

    fprintf(OutputFile, "ULONG Kd_ENDOFTABLE_Mask = 0;\n");

    //
    // Output the initialization of the component variable table.
    //

    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component debug print filter table.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "PULONG KdComponentTable[] = {\n");
    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    &Kd_%s_Mask,\n", Name);
        Count += 1;
    }

    //
    // Output one final dummy entry and close the initialization.
    //

    fprintf(OutputFile, "    &Kd_ENDOFTABLE_Mask\n");
    fprintf(OutputFile, "};\n");
    fprintf(OutputFile, "\n");
    return TRUE;
}

ULONG
GenerateNtHeaderFile(
    FILE *OutputFile
    )

{

    ULONG Count;
    PCHAR Name;

    //
    // Generate opening comments and typedef.
    //

    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "// Component name filter id enumeration and levels.\n");
    fprintf(OutputFile, "//\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "#define DPFLTR_ERROR_LEVEL 0\n");
    fprintf(OutputFile, "#define DPFLTR_WARNING_LEVEL 1\n");
    fprintf(OutputFile, "#define DPFLTR_TRACE_LEVEL 2\n");
    fprintf(OutputFile, "#define DPFLTR_INFO_LEVEL 3\n");
    fprintf(OutputFile, "#define DPFLTR_MASK 0x80000000\n");
    fprintf(OutputFile, "\n");
    fprintf(OutputFile, "typedef enum _DPFLTR_TYPE {\n");

    //
    // Output all the enumerations.
    //

    Count = 0;
    while ((Name = ComponentNameTable[Count]) != NULL) {
        fprintf(OutputFile, "    DPFLTR_%s_ID = %d,\n", Name, Count);
        Count += 1;
    }

    //
    // Output one final dummy entry and close the enumeration.
    //

    fprintf(OutputFile, "    DPFLTR_ENDOFTABLE_ID\n");
    fprintf(OutputFile, "} DPFLTR_TYPE;\n");
    fprintf(OutputFile, "\n");
    return TRUE;
}

//
// Insert component name in component name table.
//

ULONG
InsertName(
    IN PCHAR NewName
    )

{

    ULONG Index;
    ULONG Length;
    PCHAR OldName;

    //
    // Convert the input string to upper case.
    //

    Length = 0;
    while (NewName[Length] != 0) {
        if (NewName[Length] == '\n') {
            NewName[Length] = 0;
            break;
        }

        NewName[Length] = (CHAR)toupper(NewName[Length]);
        Length += 1;
    }

    //
    // Search for a duplicate name in the component name table.
    //

    Index = 0;
    while ((OldName = ComponentNameTable[Index]) != NULL) {
        if (strcmp(OldName, NewName) == 0) {
            printf(" Duplicate component name %s ignored.\n", NewName);
            return 0;
        }

        Index += 1;
    }

    //
    // Allocate a new table entry, copy the new name to the entry, and
    // insert the new entry in the table.
    //

    OldName = malloc(Length + 1);
    if (!OldName) {
        printf("Out of memory\n");
        return 0;
    }
    strcpy(OldName, NewName);
    ComponentNameTable[Index] = OldName;
    ComponentNameTable[Index + 1] = NULL;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\generr\generr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

Author:

    David N. Cutler (davec) 2-Dec-1992

Revision History:

--*/

#include <windows.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG UNALIGNED *CodePairs;
ULONG TableSize;

//
// Define run table entry structure.
//

typedef struct _RUN_ENTRY {
    ULONG BaseCode;
    USHORT RunLength;
    USHORT CodeSize;
} RUN_ENTRY, *PRUN_ENTRY;

//
// Define forward referenced procedure prptotypes.
//

ULONG
ComputeCodeSize (
    IN ULONG Start,
    IN ULONG Length
    );

ULONG
ComputeRunLength (
    IN ULONG Start
    );

LONG UNALIGNED *
ReadErrorTable(
    IN FILE *InFile,
    OUT PULONG TableSize
    );


//
// This program generates a header file that is included by the error
// translation module in ntos/rtl.
//

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];

{

    ULONG Count;
    ULONG Index1;
    ULONG Index2;
    ULONG Length;
    FILE *OutFile;
    PCHAR OutName;
    FILE *InFile;
    PCHAR InName;
    RUN_ENTRY *RunTable;
    ULONG Size;
    ULONG Temp;

    if (argc != 3) {
        fprintf(stderr, "Usage: GENERR <input_obj> <output_h>\n");
        perror("GENERR");
        exit(1);
    }

    //
    // Open file for input.
    //

    InName = argv[1];
    InFile = fopen(InName, "rb");
    if (InFile == NULL) {
        fprintf(stderr, "GENERR: Cannot open %s for reading.\n", InName);
        perror("GENERR");
        exit(1);
    }

    CodePairs = ReadErrorTable( InFile, &TableSize );
    if (CodePairs == NULL) {
        fprintf(stderr, "CodePairs[] not found in %s.\n", InName);
        perror("GENERR");
        exit(1);
    }

    fclose(InFile);

    RunTable = malloc(TableSize / 4);
    if (RunTable == NULL) {
        fprintf(stderr, "Out of memory.\n");
        perror("GENERR");
        exit(1);
    }

    //
    // Create file for output.
    //

    OutName = argv[2];
    fprintf(stderr, "GENERR: Writing %s header file.\n", OutName );
    OutFile = fopen(OutName, "w");
    if (OutFile == NULL) {
        fprintf(stderr, "GENERR: Cannot open %s for writing.\n", OutName);
        perror("GENERR");
        exit(1);
    }

    //
    // Sort the code translation table.
    //

    for (Index1 = 0; Index1 < (TableSize / 4); Index1 += 2) {
        for (Index2 = Index1; Index2 < (TableSize / 4); Index2 += 2) {
            if ((ULONG)CodePairs[Index2] < (ULONG)CodePairs[Index1]) {
                Temp = CodePairs[Index1];
                CodePairs[Index1] = CodePairs[Index2];
                CodePairs[Index2] = Temp;
                Temp = CodePairs[Index1 + 1];
                CodePairs[Index1 + 1] = CodePairs[Index2 + 1];
                CodePairs[Index2 + 1] = Temp;
            }
        }
    }

    //
    // Output the initial structure definitions and the translation
    // table declaration.
    //

    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Define run length table entry structure type.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "typedef struct _RUN_ENTRY {\n");
    fprintf(OutFile, "    ULONG BaseCode;\n");
    fprintf(OutFile, "    USHORT RunLength;\n");
    fprintf(OutFile, "    USHORT CodeSize;\n");
    fprintf(OutFile, "} RUN_ENTRY, *PRUN_ENTRY;\n");

    fprintf(OutFile, "\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Declare translation table array.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "CONST USHORT RtlpStatusTable[] = {");
    fprintf(OutFile, "\n    ");

    //
    // Calculate the run length entries and output the translation table
    // entries.
    //

    Count = 0;
    Index1 = 0;
    Index2 = 0;
    do {
        Length = ComputeRunLength(Index1);
        Size = ComputeCodeSize(Index1, Length);
        RunTable[Index2].BaseCode = CodePairs[Index1];
        RunTable[Index2].RunLength = (USHORT)Length;
        RunTable[Index2].CodeSize = (USHORT)Size;
        Index2 += 1;
        do {
            if (Size == 1) {
                Count += 1;
                fprintf(OutFile,
                        "0x%04lx, ",
                        CodePairs[Index1 + 1]);

            } else {
                Count += 2;
                fprintf(OutFile,
                        "0x%04lx, 0x%04lx, ",
                        CodePairs[Index1 + 1] & 0xffff,
                        (ULONG)CodePairs[Index1 + 1] >> 16);
            }

            if (Count > 6) {
                Count = 0;
                fprintf(OutFile, "\n    ");
            }

            Index1 += 2;
            Length -= 1;
        } while (Length > 0);
    } while (Index1 < (TableSize / 4));

    fprintf(OutFile, "0x0};\n");

    //
    // Output the run length table declaration.
    //

    fprintf(OutFile, "\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "// Declare run length table array.\n");
    fprintf(OutFile, "//\n");
    fprintf(OutFile, "\n");
    fprintf(OutFile, "CONST RUN_ENTRY RtlpRunTable[] = {");
    fprintf(OutFile, "\n");

    //
    // Output the run length table entires.
    //

    for (Index1 = 0; Index1 < Index2; Index1 += 1) {
        fprintf(OutFile,
                "    {0x%08lx, 0x%04lx, 0x%04lx},\n",
                RunTable[Index1].BaseCode,
                RunTable[Index1].RunLength,
                RunTable[Index1].CodeSize);
    }

    fprintf(OutFile, "    {0x0, 0x0, 0x0}};\n");

    //
    // Close output file.
    //

    fclose(OutFile);
    return 0;
}

ULONG
ComputeCodeSize (
    IN ULONG Start,
    IN ULONG Length
    )

//
// This function computes the size of the code entries required for the
// specified run and returns the length in words.
//

{

    ULONG Index;

    for (Index = Start; Index < (Start + (Length * 2)); Index += 2) {
        if (((ULONG)CodePairs[Index + 1] >> 16) != 0) {
            return 2;
        }
    }

    return 1;
}

ULONG
ComputeRunLength (
    IN ULONG Start
    )

//
// This function locates the next set of monotonically increasing status
// codes values and returns the length of the run.
//

{

    ULONG Index;
    ULONG Length;

    Length = 1;
    for (Index = Start + 2; Index < (TableSize / 4); Index += 2) {
        if ((ULONG)CodePairs[Index] != ((ULONG)CodePairs[Index - 2] + 1)) {
            break;
        }

        Length += 1;
    }

    return Length;
}

LONG UNALIGNED *
ReadErrorTable(
    IN FILE *InFile,
    OUT PULONG TableSize
    )
{
    ULONG fileSize;
    PLONG fileBuf;
    LONG UNALIGNED *searchEnd;
    LONG pattern[4] = { 'Begi','n ge','nerr',' tbl' };
    LONG UNALIGNED *p;
    ULONG result;
    ULONG i;
    LONG UNALIGNED *tableStart;

    //
    // Get the file size and allocate a buffer large enough for it.
    //

    if (fseek( InFile, 0, SEEK_END ) == -1)  {
        return NULL;
    }
    fileSize = ftell( InFile );
    if (fileSize == 0) {
        return NULL;
    }

    fileBuf = malloc( fileSize );
    if (fileBuf == NULL) {
        return NULL;
    }

    //
    // Read the file into the buffer
    //

    if (fseek( InFile, 0, SEEK_SET ) == -1) {
        free (fileBuf);
        return NULL;
    }
    result = fread( fileBuf, fileSize, 1, InFile );
    if (result != 1) {
        free (fileBuf);
        return NULL;
    }
    searchEnd = fileBuf + (fileSize - sizeof(pattern)) / sizeof(ULONG);

    //
    // Step through the buffer looking for our pattern.
    //

    p = fileBuf;
    while (p < searchEnd) {

        //
        // Match in this position?
        //

        for (i = 0; i < 4; i++) {

            if (*(p + i) != pattern[i]) {

                //
                // No match here
                //

                break;
            }
        }

        if (i == 4) {

            //
            // Found the pattern.  Now find out how big the table is.  We
            // do this by searching for the last pair, which has
            // 0xffffffff as its first element.
            //

            p += 4;

            tableStart = p;
            while (p < searchEnd) {

                if (*p == 0xffffffff) {

                    //
                    // Found the terminating pair.
                    //

                    *TableSize = (ULONG)((p - tableStart + 2) * sizeof(ULONG));
                    return tableStart;
                }

                p += 2;
            }

            free (fileBuf);
            return NULL;
        }

        //
        // Next position
        //

        p = (PLONG)((ULONG_PTR)p + 1);
    }

    free (fileBuf);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gensrv\gensrv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    gensrv.c

Abstract:

    This module implements a program which generates the system service
    dispatch table that is used by the trap handler and the system service
    stub procedures which are used to call the services. These files are
    both generated as text files that must be run through the assembler
    to produce the actual files.

    This program can also be used to generate the user mode system service
    stub procedures.

    If the -P switch is provided, it will also generate Profile
    in the user mode system service stub procedures.

Author:

    David N. Cutler (davec) 29-Apr-1989

Environment:

    User mode.

Revision History:

    Russ Blake (russbl) 23-Apr-1991 - add Profile switch

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

CHAR InputFileNameBuffer[ 128 ];
CHAR StubFileNameBuffer[ 128 ];
CHAR TableFileNameBuffer[ 128 ];
CHAR StubHeaderNameBuffer[ 128 ];
CHAR TableHeaderNameBuffer[ 128 ];
CHAR ProfFileNameBuffer[ 128 ];
CHAR ProfHeaderNameBuffer[ 128 ];
CHAR ProfDotHFileNameBuffer[ 128 ];
CHAR ProfIncFileNameBuffer[ 128 ];
CHAR ProfTblFileNameBuffer[ 128 ];
CHAR InputRecord[132];
CHAR OutputRecord[132];
#define GENSRV_MAXSERVICES 1000
CHAR MemoryArgs[GENSRV_MAXSERVICES];
CHAR ErrorReturns[GENSRV_MAXSERVICES];

// Increment this everytime a change to this file is made
#define GENSRV_VERSION "1.3"

#define GENSRV_MACRONAME "STUBS_ENTRY%d"
#define GENSRV_MACROARGS " %d, %s, %d"
PCHAR UsrStbsFmtMacroName = "USR" GENSRV_MACRONAME;
#define USRSTUBS_MAXARGS 8

PCHAR SysStbsFmtMacroName = "SYS" GENSRV_MACRONAME;

PCHAR StbFmtMacroArgs = GENSRV_MACROARGS;

PCHAR TableEntryFmtNB = "TABLE_ENTRY  %s, %d, %d \n";
PCHAR TableEntryFmtB = "TABLE_ENTRY( %s, %d, %d )\n";
PCHAR TableEntryFmt;

PCHAR ProfTblFmt = "\t\t\"%s\",\n";

PCHAR ProfDotHFmt = "#define NAP_API_COUNT %d \n";

PCHAR ProfIncFmt = "NapCounterServiceNumber\tEQU\t%d\n";

PCHAR ProfTblPrefixFmt = "#include <nt.h>\n\n"
                         "PCHAR NapNames[] = {\n\t\t\"NapCalibrationData\",\n";
PCHAR ProfTblSuffixFmt = "\t\t\"NapTerminalEntry\" };\n";

VOID
ClearArchiveBit(
    PCHAR FileName
    );

SHORT ParseAndSkipShort(
    CHAR **ppBuffer
    );

VOID
PrintStubLine (
    FILE * pf,
    SHORT Index1,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT ArgIndex,
    SHORT *Arguments,
    SHORT Braces);

VOID
GenerateTable(
    FILE * pf,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT Args,
    SHORT Braces
    );



int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{

    LONG InRegisterArgCount;
    SHORT Index1;
    SHORT Index2;
    SHORT Limit;
    FILE *InputFile;
    CHAR *Ipr;
    CHAR *Opr;
    SHORT ServiceNumber = 0;
    SHORT TotalArgs = 0;
    SHORT NapCounterServiceNumber;
    FILE *StubFile;
    FILE *TableFile;
    FILE *DebugFile;
    FILE *StubHeaderFile;
    FILE *TableHeaderFile;
    FILE *DefFile;
    FILE *ProfFile;
    FILE *ProfHeaderFile;
    FILE *ProfDotHFile;
    FILE *ProfIncFile;
    FILE *ProfTblFile;
    CHAR Terminal;
    CHAR *GenDirectory;
    CHAR *AltOutputDirectory;
    CHAR *StubDirectory;
    CHAR *InputFileName;
    CHAR *StubFileName = NULL;
    CHAR *TableFileName;
    CHAR *StubHeaderName = NULL;
    CHAR *TableHeaderName = NULL;
    CHAR *TargetDirectory;
    CHAR *TargetExtension;
    CHAR *DefFileData;
    CHAR *ProfFileName;
    CHAR *ProfHeaderName;
    CHAR *ProfDotHFileName;
    CHAR *ProfIncFileName;
    CHAR *ProfTblFileName;
    SHORT Braces;
    SHORT DispatchCount;
    SHORT Profile;
    SHORT LineStart;
    SHORT LineEnd;
    SHORT Arguments[ USRSTUBS_MAXARGS ];
    SHORT ArgIndex;
    SHORT ErrorReturnTable;


    if (argc == 2 && (!strcmp(argv[1],"-?") || !strcmp(argv[1],"/?"))) {
PrintUsage:
        printf("GENSRV: System Service Dispatch Table Generator. Version " GENSRV_VERSION "\n");
        printf("Usage: gensrv [-d targetdir] [-e targetext] [-f defdata] [-B] [-P] [-C] [-R] [-a altoutputdir] [-s stubdir] [services.tab directory]\n");
        printf("-B Use braces\n");
        printf("-P Generate profile stubs data\n");
        printf("-C Spew dispatch count\n");
        printf("-R Generate ConvertToGui error return table\n");
        exit(1);
    }

    //
    // Determine name of target directory for output files.  Requires that
    // the -d switch be specified and that the argument after the switch is
    // the target directory name.  If no -d switch then defaults to "."
    //


    if (argc >= 3 && !strcmp(argv[1],"-d")) {
        TargetDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        TargetDirectory = ".";
    }

    //
    // Determine name of target extension for output files.  Requires that
    // the -e switch be specified and that the argument after the switch is
    // the target extension string.  If no -e switch then defaults to "s"
    //

    if (argc >= 3 && !strcmp(argv[1],"-e")) {
        TargetExtension = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        TargetExtension = "s";
    }

    //
    // Determine if def file data is to be generated
    //

    if (argc >= 3 && !strcmp(argv[1],"-f")) {
        DefFileData = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        DefFileData = NULL;
    }

    //
    // Change default directory used for generated files.
    //

    if (argc >= 3 && !strcmp(argv[1],"-g")) {
        GenDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        GenDirectory = ".";
    }


    //
    // Change name of usrstubs.s
    //

    if (argc >= 3 && !strcmp(argv[1],"-stubs")) {
        StubFileName = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // Change name of services.stb
    //

    if (argc >= 3 && !strcmp(argv[1],"-sstb")) {
        StubHeaderName = argv[2];
        argc -= 2;
        argv += 2;
    }

    if (argc >= 3 && !strcmp(argv[1],"-stable")) {
        TableHeaderName = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // Determine if braces are to be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-B")) {
        Braces = 1;
        argc -= 1;
        argv += 1;
    } else {
        Braces = 0;
    }

    //
    // Determine if services Profile stubs data is to be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-P")) {
        Profile = 1;
        argc -= 1;
        argv += 1;
    } else {
        Profile = 0;
    }

    //
    // Determine if dispatch count should be spewed
    //

    if (argc >= 2 && !strcmp(argv[1],"-C")) {
        DispatchCount = 1;
        argc -= 1;
        argv += 1;
    } else {
        DispatchCount = 0;
    }

    //
    // Determine if error return table should be generated
    //

    if (argc >= 2 && !strcmp(argv[1],"-R")) {
        ErrorReturnTable = 1;
        argc -= 1;
        argv += 1;
    } else {
        ErrorReturnTable = 0;
    }

    //
    // ALT_PROJECT output directory.
    //
    if (argc >= 3 && !strcmp(argv[1],"-a")) {
        AltOutputDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        AltOutputDirectory = GenDirectory;
    }

    //
    // table.stb and services.stb directory.
    //
    if (argc >= 3 && !strcmp(argv[1],"-s")) {
        StubDirectory = argv[2];
        argc -= 2;
        argv += 2;
    } else {
        StubDirectory = GenDirectory;
    }


    //
    // Determine name of input and output files, based on the argument
    // to the program.  If no argument other than program name, then
    // generate the kernel mode system service files (stubs and dispatch
    // table).  Otherwise, expect a single argument that is the path name
    // of the services.tab file and produce output file(s), which
    // contain the user mode system service stubs (and profiled stubs if
    // selected.)
    //

    if (argc == 1) {
        if (DefFileData) {
            goto PrintUsage;
        }

        sprintf(InputFileName = InputFileNameBuffer,
                "%s\\services.tab",GenDirectory);
        sprintf(StubFileName = StubFileNameBuffer,
                "%s\\sysstubs.%s",AltOutputDirectory,TargetExtension);
        sprintf(TableFileName = TableFileNameBuffer,
                "%s\\systable.%s",AltOutputDirectory,TargetExtension);
        if (TableHeaderName == NULL) {
            sprintf(TableHeaderName = TableHeaderNameBuffer,
                    "%s\\table.stb",StubDirectory);
        }
        if (StubHeaderName == NULL) {
            sprintf(StubHeaderName = StubHeaderNameBuffer,
                    "%s\\services.stb",StubDirectory);
        }
    } else {
        if (argc == 2) {
            if (StubDirectory == GenDirectory) {
                StubDirectory = argv[1];
            }

            sprintf(InputFileName = InputFileNameBuffer,
                    "%s\\services.tab",argv[1]);
            if (DefFileData == NULL) {
                if (StubFileName == NULL) {
                    sprintf(StubFileName = StubFileNameBuffer,
                            "%s\\usrstubs.%s",TargetDirectory,TargetExtension);
                }
                if (StubHeaderName == NULL) {
                    sprintf(StubHeaderName = StubHeaderNameBuffer,
                            "%s\\services.stb",StubDirectory);
                }
                if (Profile) {
                    sprintf(ProfFileName = ProfFileNameBuffer,
                            "%s\\napstubs.%s",TargetDirectory,TargetExtension);
                    sprintf(ProfHeaderName = ProfHeaderNameBuffer,
                            "%s\\%s\\services.nap",argv[1],TargetDirectory);
                    sprintf(ProfDotHFileName = ProfDotHFileNameBuffer,
                            ".\\ntnapdef.h");
                    sprintf(ProfIncFileName = ProfIncFileNameBuffer,
                            "%s\\ntnap.inc",TargetDirectory);
                    sprintf(ProfTblFileName = ProfTblFileNameBuffer,
                            ".\\ntnaptbl.c");
                }
            }
            TableFileName = NULL;
        } else {
            goto PrintUsage;
        }
    }


    //
    // Open input and output files.
    //

    InputFile = fopen(InputFileName, "r");
    if (!InputFile) {
        printf("\nfatal error  Unable to open system services file %s\n", InputFileName);
        goto PrintUsage;
    }

    if (DefFileData == NULL) {
        StubFile = fopen(StubFileName, "w");
        if (!StubFile) {
            printf("\nfatal error  Unable to open system services file %s\n", StubFileName);
            fclose(InputFile);
            exit(1);
        }

        StubHeaderFile = fopen(StubHeaderName, "r");
        if (!StubHeaderFile) {
            printf("\nfatal error  Unable to open system services stub file %s\n", StubHeaderName);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }

        if (Profile) {
            ProfHeaderFile = fopen(ProfHeaderName, "r");
            if (!ProfHeaderFile) {
                printf("\nfatal error  Unable to open system services profiling stub file %s\n", ProfHeaderName);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfFile = fopen(ProfFileName, "w");
            if (!ProfFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfDotHFile = fopen(ProfDotHFileName, "w");
            if (!ProfDotHFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfIncFile = fopen(ProfIncFileName, "w");
            if (!ProfIncFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
            ProfTblFile = fopen(ProfTblFileName, "w");
            if (!ProfTblFile) {
                printf("\nfatal error  Unable to open system services file %s\n", ProfFileName);
                fclose(ProfIncFile);
                fclose(ProfDotHFile);
                fclose(ProfFile);
                fclose(ProfHeaderFile);
                fclose(StubHeaderFile);
                fclose(StubFile);
                fclose(InputFile);
                exit(1);
            }
        }
    }

    if (TableFileName != NULL) {
        TableFile = fopen(TableFileName, "w");
        if (!TableFile) {
            printf("\nfatal error  Unable to open system services file %s\n",
                   TableFileName);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
        TableHeaderFile = fopen(TableHeaderName, "r");
        if (!TableHeaderFile) {
            printf("\nfatal error  Unable to open system services stub file %s\n",
                   TableHeaderName);
            fclose(TableFile);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
    } else {
        TableFile = NULL;
        TableHeaderFile = NULL;
    }

    if ( DefFileData ) {
        DefFile = fopen(DefFileData, "w");
        if (!DefFile) {
            printf("\nfatal error  Unable to open def file data file %s\n", DefFileData);
            if ( TableFile ) {
                fclose(TableHeaderFile);
                fclose(TableFile);
            }
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }
    } else {
        DefFile = NULL;
    }

    //
    // Output header information to the stubs file and table file. This
    // information is obtained from the Services stub file and from the
    // table stub file.
    //

    if (DefFile == NULL) {
        while( fgets(InputRecord, 132, StubHeaderFile) ) {
            fputs(InputRecord, StubFile);
        }
        if (Profile) {
            while( fgets(InputRecord, 132, ProfHeaderFile) ) {
                fputs(InputRecord, ProfFile);
            }
            fputs(ProfTblPrefixFmt, ProfTblFile);
        }
    }

    if (TableFile != NULL) {
        if (!fgets(InputRecord, 132, TableHeaderFile) ) {
            printf("\nfatal error  Format Error in table stub file %s\n", TableHeaderName);
            fclose(TableHeaderFile);
            fclose(TableFile);
            fclose(StubHeaderFile);
            fclose(StubFile);
            fclose(InputFile);
            exit(1);
        }

        InRegisterArgCount = atol(InputRecord);

        while( fgets(InputRecord, 132, TableHeaderFile) ) {
            fputs(InputRecord, TableFile);
        }
    } else {
        InRegisterArgCount = 0;
    }

    if (Braces) {
        TableEntryFmt = TableEntryFmtB;
    } else {
        TableEntryFmt = TableEntryFmtNB;
    }

    //
    // Read service name table and generate file data.
    //

    while ( fgets(InputRecord, 132, InputFile) ){


        //
        // Generate stub file entry.
        //

        Ipr = &InputRecord[0];
        Opr = &OutputRecord[0];

        //
        // If services.tab was generated by C_PREPROCESSOR, there might
        //  be empty lines in this file. Using the preprocessor allows
        //  people to use #ifdef, #includes, etc in the original services.tab
        //
        switch (*Ipr) {
            case '\n':
            case ' ':
                continue;
        }


        while ((*Ipr != '\n') && (*Ipr != ',')) {
            *Opr++ = *Ipr++;
        }
        *Opr = '\0';


        //
        // If the input record ended in ',', then the service has inmemory
        // arguments and the number of in memory arguments follows the comma.
        //

        MemoryArgs[ServiceNumber] = 0;
        Terminal = *Ipr;
        *Ipr++ = 0;
        if (Terminal == ',') {
            MemoryArgs[ServiceNumber] = (char) atoi(Ipr);
        }

        // Move to the end of the line or past the next comma
        while (*Ipr != '\n') {
            if (*Ipr++ == ',') {
                break ;
            }
        }
        //
        // If an error return value table is to be generated, then the following value
        // might follow:
        //    0 = return 0
        //   -1 = return -1
        //    1 = return status code. (This is the default if no value is specified)
        //
        // This table is used by the dispatcher when convertion to GUI fails.
        //
        if (ErrorReturnTable) {
            if (*Ipr != '\n') {
                ErrorReturns[ServiceNumber] = (char)ParseAndSkipShort(&Ipr);
            } else {
                ErrorReturns[ServiceNumber] = 1;
            }
        }

        //
        //
        // If there are more arguments, then this stub doesn't use the default code (lines 1 to 8)
        // The following format is expected:
        //       LineStart,LineEnd,Argument1[,Argument2[,Argument3]....]
        //
        ArgIndex = 0;
        if (*Ipr != '\n') {
            LineStart = ParseAndSkipShort(&Ipr);
            LineEnd = ParseAndSkipShort(&Ipr);
            while ((ArgIndex < USRSTUBS_MAXARGS) && (*Ipr != '\n')) {
                Arguments[ ArgIndex++ ] = ParseAndSkipShort(&Ipr);
            }
        } else {
            LineStart = 1;
            LineEnd = 8;
        }


        TotalArgs += MemoryArgs[ServiceNumber];

        if ( MemoryArgs[ServiceNumber] > InRegisterArgCount ) {
            MemoryArgs[ServiceNumber] -= (CHAR)InRegisterArgCount;
        } else {
            MemoryArgs[ServiceNumber] = 0;
        }

        if ( DefFile ) {
            fprintf(DefFile,"    Zw%s\n",OutputRecord);
            fprintf(DefFile,"    Nt%s\n",OutputRecord);
        } else {
            for (Index1=LineStart; Index1<=LineEnd; Index1++) {
                if (!TableFile) {
                    PrintStubLine(StubFile, Index1, UsrStbsFmtMacroName,
                                    ServiceNumber, ArgIndex, Arguments, Braces);

                    if (Profile) {
                        PrintStubLine(ProfFile, Index1, UsrStbsFmtMacroName,
                                        ServiceNumber, ArgIndex, Arguments, Braces);

                        if (Index1 == LineStart) {
                            fprintf(ProfTblFile,ProfTblFmt,
                                    OutputRecord,
                                    MemoryArgs[ServiceNumber]);
                            if (!strcmp(OutputRecord,
                                        "QueryPerformanceCounter")) {
                                NapCounterServiceNumber = ServiceNumber;
                            }
                        }
                    }
                } else {

                  PrintStubLine(StubFile, Index1, SysStbsFmtMacroName,
                                    ServiceNumber, ArgIndex, Arguments, Braces);
                }
            }


        }

        //
        // Generate table file entry and update service number.
        //

        if (TableFile != NULL) {

            fprintf(TableFile,
                    TableEntryFmt,
                    InputRecord,
                    (MemoryArgs[ServiceNumber] ? 1 : 0 ),
                    MemoryArgs[ServiceNumber]);

        }
        ServiceNumber = ServiceNumber + 1;
    }

    if (TableFile == NULL) {
        DebugFile = StubFile;
    } else {
        DebugFile = TableFile;
    }

    //
    // Generate Error Return table if required.
    // This table must be concatenated at the end of the  system call service table.
    //
    if (ErrorReturnTable && (TableFile != NULL)) {
        GenerateTable(TableFile, "ERRTBL", ServiceNumber, FALSE, Braces);
    }

    if (DispatchCount ) {
        if ( Braces ) {
            fprintf(DebugFile, "\n\nDECLARE_DISPATCH_COUNT( %d, %d )\n", ServiceNumber, TotalArgs);
        } else {
            fprintf(DebugFile, "\n\nDECLARE_DISPATCH_COUNT 0%xh, 0%xh\n", ServiceNumber, TotalArgs);
        }
    }

    if (TableFile != NULL) {
        //
        // Generate highest service number.
        //

        if ( Braces )
            fprintf(TableFile, "\nTABLE_END( %d )\n", ServiceNumber - 1);
        else
            fprintf(TableFile, "\nTABLE_END %d \n", ServiceNumber - 1);

        //
        // Generate number of arguments in memory table.
        //
        GenerateTable(TableFile, "ARGTBL", ServiceNumber, TRUE, Braces);

        fclose(TableHeaderFile);
        fclose(TableFile);
    }

    if (!DefFile) {
        fprintf(StubFile, "\nSTUBS_END\n");
        fclose(StubHeaderFile);
        fclose(StubFile);
        if (Profile) {
            fprintf(ProfFile, "\nSTUBS_END\n");
            fprintf(ProfTblFile, ProfTblSuffixFmt);
            fprintf(ProfDotHFile, ProfDotHFmt, ServiceNumber);
            fprintf(ProfIncFile, ProfIncFmt, NapCounterServiceNumber);
            fclose(ProfHeaderFile);
            fclose(ProfFile);
            fclose(ProfDotHFile);
            fclose(ProfTblFile);
        }
    }

    fclose(InputFile);

    //
    // Clear the Archive bit for all the files created, since they are
    // generated, there is no reason to back them up.
    //
    ClearArchiveBit(TableFileName);
    ClearArchiveBit(StubFileName);
    if (DefFile) {
        ClearArchiveBit(DefFileData);
    }
    if (Profile) {
        ClearArchiveBit(ProfFileName);
        ClearArchiveBit(ProfDotHFileName);
        ClearArchiveBit(ProfIncFileName);
        ClearArchiveBit(ProfTblFileName);
    }
    return (0);

}

VOID
PrintStubLine (
    FILE * pf,
    SHORT Index1,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT ArgIndex,
    SHORT *Arguments,
    SHORT Braces
    )
{
    SHORT Index2;

    fprintf(pf, pszMacro, Index1);

    fprintf(pf, Braces ? "(" : " ");

    fprintf(pf, StbFmtMacroArgs, ServiceNumber,
            OutputRecord, MemoryArgs[ServiceNumber]);

    for (Index2=0; Index2<ArgIndex; Index2++) {
        fprintf(pf, ", %d", Arguments[Index2]);
    }

    fprintf(pf, Braces ? " )\n" : " \n");
}

SHORT
ParseAndSkipShort(
    CHAR **ppBuffer
    )
{
    SHORT s = (SHORT)atoi(*ppBuffer);
    while (**ppBuffer != '\n') {
        if (*(*ppBuffer)++ == ',') {
            break;
        }
    }
    return s;
}

VOID
ClearArchiveBit(
    PCHAR FileName
    )
{
    DWORD Attributes;

    Attributes = GetFileAttributes(FileName);
    if (Attributes != -1 && (Attributes & FILE_ATTRIBUTE_ARCHIVE)) {
        SetFileAttributes(FileName, Attributes & ~FILE_ATTRIBUTE_ARCHIVE);
    }

    return;
}

VOID
GenerateTable(
    FILE * pf,
    PCHAR pszMacro,
    SHORT ServiceNumber,
    SHORT Args,
    SHORT Braces
    )
{
    SHORT Index1, Index2, Limit, Value;
    PCHAR pValues = (Args ? MemoryArgs : ErrorReturns);

    fprintf(pf, "\n%s_BEGIN\n", pszMacro);

    for (Index1 = 0; Index1 <= ServiceNumber - 1; Index1 += 8) {

        fprintf(pf, "%s_ENTRY%s", pszMacro, Braces ? "(" : " ");

        Limit = ServiceNumber - Index1 - 1;
        if (Limit >= 7) {
            Limit = 7;
        }
        for (Index2 = 0; Index2 <= Limit; Index2 += 1) {
            Value = *(pValues + Index1 + Index2);
            if (Args) {
                Value *= 4;
            }
            fprintf(pf, Index2 == Limit ? "%d" : "%d,", Value);
        }

        if (Limit < 7) {
            while(Index2 <= 7) {
                fprintf(pf, ",0");
                Index2++;
            }
        }

        fprintf(pf, Braces ? ")\n" : " \n");

    }

    fprintf(pf, "\n%s_END\n", pszMacro);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\fsdump\lib\volstate.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volstate.cpp

Abstract:

    Contains implementation of the volume state class.  This class
    maintains state about one volume.


Author:

    Stefan R. Steiner   [ssteiner]        03-14-2000

Revision History:

--*/

#include "stdafx.h"

CFsdVolumeStateManager::CFsdVolumeStateManager(
    IN CDumpParameters *pcDumpParameters
    ) : m_cVolumeStateList( BSHASHMAP_MEDIUM ),
        m_pcParams( pcDumpParameters ),
        m_pcExclManager( NULL )
{ 
    if ( m_pcParams->m_bUseExcludeProcessor )
    {        
        m_pcExclManager = new CFsdExclusionManager( m_pcParams );
        if ( m_pcExclManager == NULL )
        {
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::CFsdVolumeStateManager - Can't init CFsdExclusionManager, out of memory" );
            throw E_OUTOFMEMORY;
        }
    }
}

CFsdVolumeStateManager::~CFsdVolumeStateManager() 
{
    //
    //  Need to delete all volume state objects
    //
    
    SFsdVolumeId sFsdId;
    CFsdVolumeState *pcVolState;

    m_cVolumeStateList.StartEnum();
    while ( m_cVolumeStateList.GetNextEnum( &sFsdId, &pcVolState ) )
    {
        delete pcVolState;
    }    
    m_cVolumeStateList.EndEnum();

    delete m_pcExclManager;
}

VOID 
CFsdVolumeStateManager::PrintHardLinkInfo()
{
    //
    //  Let's iterate through all of the volumes managed by this
    //  manager.
    //
    SFsdVolumeId sFsdId;
    CFsdVolumeState *pcVolState;
    
    m_pcParams->DumpPrint( L"" );
    m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
    m_pcParams->DumpPrint( L"HardLink Information" );
    
    m_cVolumeStateList.StartEnum();
    while ( m_cVolumeStateList.GetNextEnum( &sFsdId, &pcVolState ) )
    {
        m_pcParams->DumpPrint( L"----------------------------------------------------------------------------" );
        m_pcParams->DumpPrint( L"For volume: '%s'", pcVolState->GetVolumePath() );
        pcVolState->PrintHardLinkInfo();
    }    
    m_cVolumeStateList.EndEnum();
}


/*++

Routine Description:

    <Enter description here>

Arguments:

Return Value:

    ERROR_ALREADY_EXISTS - The volume already exists.  The returned 
        volume state object pointer is valid.
    ERROR_CAN_NOT_COMPLETE - Unexpected error
    
--*/
DWORD
CFsdVolumeStateManager::GetVolumeState(
   IN const CBsString& cwsVolumePath,
   OUT CFsdVolumeState **ppcVolState
   )
{
    *ppcVolState = NULL;
    
    try
    {
        WCHAR wszVolumePath[ FSD_MAX_PATH ];

        //
        //  Temporary workaround for bug in GetVolumeInformationW()
        //     
        BOOL bFixed = FALSE;
        if ( cwsVolumePath.Left( 2 ) == L"\\\\" && cwsVolumePath.Left( 4 ) != L"\\\\?\\" )
        {
            //
            //  reduce to the minimal \\machine\sharename\ form
            //
            ::wcscpy( wszVolumePath, cwsVolumePath );
            LPWSTR pswz;

            pswz = ::wcschr( wszVolumePath + 2, L'\\' );
            if ( pswz != NULL )
            {
                pswz = ::wcschr( pswz + 1, L'\\' );
                if ( pswz != NULL )
                {
                    pswz[1] = '\0';
                    bFixed = TRUE;
                }                                    
            }
        }
        if ( bFixed == FALSE )
        {
            //
            //  Get the volume path that contains this volume
            //
            if ( !::GetVolumePathNameW(
                    cwsVolumePath,
                    wszVolumePath,
                    FSD_MAX_PATH ) )
            {
                m_pcParams->ErrPrint( L"CFsdVolumeStateManager - GetVolumePathName( '%s', ... ) returned dwRet: %d",
                    cwsVolumePath.c_str(), ::GetLastError() );
                return ::GetLastError();
            }            
        }
        
        //
        //  Initialize a new volume state object
        //
        CFsdVolumeState *pcFsdVolumeState;        
        pcFsdVolumeState = new CFsdVolumeState( m_pcParams, wszVolumePath );
        if ( pcFsdVolumeState == NULL )
        {
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager, out of memory, can't get volume information" );
            return  ::GetLastError();
        }

        //
        //  Now get the information about the volume. 
        //  BUGBUG: Note that GetVolumeInformationW returns 
        //  ERROR_DIR_NOT_ROOT when encountering a junction on a 
        //  remote share.
        //
        if ( !::GetVolumeInformationW(
                wszVolumePath,
                NULL,
                0,
                &pcFsdVolumeState->m_dwVolSerialNumber,
                &pcFsdVolumeState->m_dwMaxComponentLength,
                &pcFsdVolumeState->m_dwFileSystemFlags,
                pcFsdVolumeState->m_cwsFileSystemName.GetBufferSetLength( 64 ),
                64 ) )
        {
            pcFsdVolumeState->m_cwsFileSystemName.ReleaseBuffer();
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager - GetVolumeInformation( '%s', ... ) returned dwRet: %d "
                L"(if 144 probably hit bug in GetVolumeInformation when accessing remote mountpoints)",
                wszVolumePath, ::GetLastError() );
            delete pcFsdVolumeState;
            return ::GetLastError();
        }
        pcFsdVolumeState->m_cwsFileSystemName.ReleaseBuffer();

#if 0
        SFsdVolumeId sVolIdTest;
        CBsString cwsRealVolumePath;
        GetVolumeIdAndPath( m_pcParams, cwsVolumePath, &sVolIdTest, cwsRealVolumePath );
        assert( sVolIdTest.m_dwVolSerialNumber == pcFsdVolumeState->m_dwVolSerialNumber );
        printf("VolumeSerialNumber: 0x%08x, 0x%08x\n", pcFsdVolumeState->m_dwVolSerialNumber, 
            sVolIdTest.m_dwVolSerialNumber );
#endif
        
        //
        //  Now see if this volume already exists in the list of volume states
        //
        LONG lRet;
        SFsdVolumeId sVolId;
        sVolId.m_dwVolSerialNumber = pcFsdVolumeState->m_dwVolSerialNumber;
        if ( m_cVolumeStateList.Find( sVolId, ppcVolState ) == TRUE )
        {
            //
            //  Already exists in the list, return it.  Also delete the vol state 
            //  object that's not needed.
            //            
            delete pcFsdVolumeState;
            return ERROR_ALREADY_EXISTS;
        }

        //
        //  Not found, insert it into the list
        //
        lRet = m_cVolumeStateList.Insert( sVolId, pcFsdVolumeState );
        if ( lRet != BSHASHMAP_NO_ERROR )
        {
            assert( lRet != BSHASHMAP_ALREADY_EXISTS );
            delete pcFsdVolumeState;
            return ERROR_CAN_NOT_COMPLETE;
        }

        //
        //  Now get the exclusion processor for this volume if necessary
        //
        if ( m_pcExclManager != NULL )
        {
            m_pcExclManager->GetFileSystemExcludeProcessor( cwsVolumePath, &sVolId, &pcFsdVolumeState->m_pcFSExclProcessor );
        }
        
        CFsdVolumeState *pcFindFsdVolumeState;
        *ppcVolState = pcFsdVolumeState;
        return ERROR_SUCCESS;
    } 
    catch ( HRESULT hr )
    {
        if ( hr == E_OUTOFMEMORY )
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - Out of memory ( '%s' )",
                cwsVolumePath.c_str() );
        else
            m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - Unexpected hr exception: 0x%08x ( '%s )",
                hr, cwsVolumePath.c_str() );
        
        return ERROR_CAN_NOT_COMPLETE;                        
    }
    catch ( ... )
    {
        m_pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeState - '%s' caught an unexpected exception",
            cwsVolumePath.c_str() );
        return ERROR_CAN_NOT_COMPLETE;
    }    
}


/*++

Routine Description:

    Gets the ID of the volume containing any file.

Arguments:

Return Value:

    ERROR_CAN_NOT_COMPLETE - General error

--*/
DWORD 
CFsdVolumeStateManager::GetVolumeIdAndPath( 
    IN CDumpParameters *pcParams,
    IN const CBsString& cwsPathOnVolume,
    OUT SFsdVolumeId *psVolId,
    OUT CBsString& cwsVolPath
    )
{    
    try
    {      
        psVolId->m_dwVolSerialNumber = 0;
        WCHAR wszVolumePath[ FSD_MAX_PATH ];

        //
        //  First get the mountpoint of the volume
        //
        if ( !GetVolumePathNameW(
                cwsPathOnVolume,
                wszVolumePath,
                FSD_MAX_PATH ) )
        {
            pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - GetVolumePathName( '%s', ... ) returned dwRet: %d",
                cwsPathOnVolume.c_str(), ::GetLastError() );
            return ::GetLastError();
        }

        //
        //  Now open the volume in order to query filesystem info
        //
        HANDLE hFile;
        hFile = ::CreateFileW( 
                    wszVolumePath, 
                    FILE_GENERIC_READ,
                    FILE_SHARE_READ, 
                    NULL,
                    OPEN_EXISTING, 
                    FILE_FLAG_BACKUP_SEMANTICS, 
                    NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            //pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - CreateFile( '%s', ... ) returned dwRet: %d",
            //    wszVolumePath, ::GetLastError() );
            return ::GetLastError();
        }
        
        IO_STATUS_BLOCK iosb ;
        BYTE buffer[1024] ;
        FILE_FS_VOLUME_INFORMATION *fsinfo = (FILE_FS_VOLUME_INFORMATION *)buffer;

        fsinfo->VolumeSerialNumber = 0;
        NTSTATUS ntStat;
        ntStat = ::NtQueryVolumeInformationFile( hFile, &iosb, fsinfo, sizeof(buffer), FileFsVolumeInformation );
        ::CloseHandle( hFile );
        if ( ntStat != STATUS_SUCCESS )
        {
            pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - NtQueryVolumeInformationFile( '%s', ... ) returned dwRet: %0x08x",
                wszVolumePath, ntStat );
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        psVolId->m_dwVolSerialNumber = fsinfo->VolumeSerialNumber;
        
        cwsVolPath = wszVolumePath;        
    }
    catch ( ... )
    {
        pcParams->ErrPrint( L"CFsdVolumeStateManager::GetVolumeIdAndPath - '%s' caught an unexpected exception",
            cwsPathOnVolume.c_str() );
        return ERROR_CAN_NOT_COMPLETE;
    }    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\getbin\getbin.h ===
#define IDD_SOURCE          100
#define IDD_DEST            101
#define IDD_SYMS            102


#define IDD_REG_COPY        110
#define IDD_RENAME          111
#define IDD_POLL            112
#define IDD_REBOOT          113

#define IDD_SAVEPREVIOUS    120
#define IDD_SAVEEXTENSION   121
#define IDD_RESTORECMD      122
#define IDD_DBGTOO          123

#define IDD_COPY_COMMAND    130
#define IDD_COPY_DATE       131
#define IDD_COPY_LIST       132
#define IDD_LIST            133

#define IDD_COPYEXTENSION   140
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gflags\makefile.inc ===
gflags.rc: gflags.dlg gflags.h

$(O)\gflags.res: gflags.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\getbin\getbin.c ===
#include <nt.h>    // For shutdown privilege.
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include "getbin.h"

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <locale.h>
#include <process.h>
#include <windows.h>

#define MV_FLAGS (MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT)

#define CCH_BUF             512
#define RES_DLGOPTIONS      1

#define VerbosePrintf   if (gbVerbose) printf

char *gszVERSION = "16.1";
INT_PTR CALLBACK OptionsDlgProc (HWND, UINT, WPARAM, LPARAM);


CONST CHAR szDEFSAVEEXT[] = "lst";
CONST CHAR szSAVEEXT[] = "SaveExtension";
CONST CHAR szDEFCOPYEXT[] = "dll";
CONST CHAR szJUNKEXT[] = "yuk";
CONST CHAR szDEST[] = "Dest";
CONST CHAR szSYMS[] = "Symbols";
CONST CHAR szSOURCE[] = "Source";
CONST CHAR szSYSTEM32[] = "SYSTEM32";
CONST CHAR szSYMBOLS[] = "SYMBOLS";
CONST CHAR szGETBIN[] = "Getbin";
CONST CHAR szGETBINDIR[] = "GetbinSourceDir";
CONST CHAR szWINDIR[] = "windir";

CHAR szTRYRENAME[] = "TryRename";
CHAR szTRYCOPY[] = "TryCopy";
CHAR szPOLL[] = "Poll";
CHAR szREBOOT[] = "Reboot";
CHAR szSAVEPREVIOUS[] = "SavePrevious";
CHAR szRESTORECMD[] = "Restore.Cmd";
CHAR szCOPYDBGTOO[] = "CopyDbgToo";
CHAR szCOPYSOURCETYPE[] = "CopySourceType";

BOOL gbTryRename = TRUE;
BOOL gbDelayCopy = FALSE;
BOOL gbTryCopy = TRUE;
BOOL gbPoll = FALSE;
BOOL gbVerbose = FALSE;
BOOL gbReboot = FALSE;
BOOL gbSavePrevious = FALSE;
BOOL gbRestoreCmd = FALSE;
BOOL gbCopyDbgToo = FALSE;
BOOL gbForceTempCopy = FALSE;
HANDLE ghRestoreCmd = NULL; // file handle for Restore.Cmd

BOOL giCopySourceType = IDD_COPY_COMMAND;

CHAR gszDestDir[CCH_BUF];          // typically "c:\winnt\system32"
CHAR gszDriverDestDir[CCH_BUF+8];  // typically "c:\winnt\system32\drivers"
CHAR gszSymsDir[CCH_BUF];
CHAR gszSourceDir[CCH_BUF];
CHAR gszWinDir[CCH_BUF];
CHAR gszSaveExtension[4];
CHAR gszCopyExtension[4];

#define GB_FILE_ITSELF         0
#define GB_ASSOCIATED_DBG_FILE 1
#define GB_ASSOCIATED_PDB_FILE 2

BOOL DoGetbin(LPSTR szFileName, DWORD dwAssociatedFile);

void PrintUsage(void) {
    printf("Getbin version %s\n", gszVERSION);
    printf("usage: getbin [-c] [-d] [-D] [-l] [-r] [-t] [-w] <filename> [[-w] <filename>]...\n");
    printf("    -c create Restore.Cmd\n");
    printf("    -d delay copy until reboot\n");
    printf("    -D copy DBG/PDB files too\n");
    printf("    -l copy old file to *.lst\n");
    printf("    -w <filename> : wait for <filename> to be updated\n");
    printf("    -r reboot after copy\n");
    printf("    -t copy when date of src is newer\n");
    printf("    -T Force temp copy when using -d\n");
    printf("    -v old-style verbose output\n");
    printf("usage: getbin -o\n");
    printf("       GUI biset options\n");

}

int __cdecl main (int argc, char *argv[])
{
    DWORD dwRet;
    int iArg = 1;
    int nFiles = 0;
    UINT Codepage;
    char achCodepage[6] = ".OCP";


    if (argc <= 1) {
        PrintUsage();
        ActivateKeyboardLayout((HKL)(HKL_NEXT), KLF_SETFORPROCESS);
        exit(0);
    }

    /*
     * This is mainly here as a good example of how to set a character-mode
     * application's codepage.
     * This affects C-runtime routines such as mbtowc(), mbstowcs(), wctomb(),
     * wcstombs(), mblen(), _mbstrlen(), isprint(), isalpha() etc.
     * To make sure these C-runtimes come from msvcrt.dll, use TARGETLIBS in
     * the sources file, together with TARGETTYPE=PROGRAM (and not UMAPPL?)
     */
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%3.4d", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    /*
     * chcp to a different codepage and test what isalpha() determines.
     *  cp437:d0 is not a char (Box Drawings Up Double And Horizontal Single)
     *  cp850:d0 is a char     (Latin Small Letter Eth)
     *  cp852:d0 is a char     (Latin Small Letter D With Stroke)
     * cp1251:d0 is a char     (Cyrillic Capital Letter Er)
     * cp1252:d0 is a char     (Latin Capital Letter Eth)
     */
    isalpha(0xd0);

    dwRet = GetEnvironmentVariable( szWINDIR, gszWinDir, sizeof(gszWinDir)/sizeof(gszWinDir[0]));
    if (!dwRet) {
        gszWinDir[0] = '\0';
    }

    /*
     * Get the defaults
     *
     * Destination Directory
     */
    if (GetProfileString(szGETBIN, szDEST, "", gszDestDir, sizeof(gszDestDir)) < 2) {
        if (gszWinDir[0] == '\0') {
            printf("Getbin: can not read environment string %s.\n", szWINDIR);
            exit(0);
        }
        sprintf(gszDestDir, "%s\\%s", gszWinDir, szSYSTEM32);
    }
    _strupr(gszDestDir);
    strcpy(gszDriverDestDir, gszDestDir);
    strcat(gszDriverDestDir, "\\drivers");

    if (GetProfileString(szGETBIN, szSYMS, "", gszSymsDir, sizeof(gszSymsDir)) < 2) {
        if (szWINDIR[0] == '\0') {
            printf("Getbin: can not read environment string %s.\n", szWINDIR);
            exit(0);
        }
        sprintf(gszSymsDir, "%s\\%s", gszWinDir, szSYMBOLS);
    }
    _strupr(gszSymsDir);

    GetProfileString(szGETBIN, szSOURCE, "", gszSourceDir, sizeof(gszSourceDir));

    gbTryRename = GetProfileInt(szGETBIN, szTRYRENAME, gbTryRename);
    gbTryCopy = GetProfileInt(szGETBIN, szTRYCOPY, gbTryCopy);
    gbPoll = GetProfileInt(szGETBIN, szPOLL, gbPoll);
    gbReboot = GetProfileInt(szGETBIN, szREBOOT, gbReboot);
    gbSavePrevious = GetProfileInt(szGETBIN, szSAVEPREVIOUS, gbSavePrevious);
    gbRestoreCmd = GetProfileInt(szGETBIN, szRESTORECMD, gbRestoreCmd);
    if (gbRestoreCmd) {
        gbSavePrevious = TRUE;
    }

    gbCopyDbgToo = GetProfileInt(szGETBIN, szCOPYDBGTOO, gbCopyDbgToo);
    giCopySourceType = GetProfileInt(szGETBIN, szCOPYSOURCETYPE, giCopySourceType);
    GetProfileString(szGETBIN, szSAVEEXT, szDEFSAVEEXT, gszSaveExtension, sizeof(gszSaveExtension));

    /*
     * Compute the flags
     */

// printf("argc %lX %s %s %s\n", argc, argv[0], argv[1], argv[2] );
    for (iArg=1; iArg<argc; iArg++) {
        if (argv[iArg][0] == '-') {
            switch (argv[iArg][1]) {
            case 'c':
                gbRestoreCmd = TRUE;
                // need to save the previous files then!
                gbSavePrevious = TRUE;
                break;
            case 'D':
                gbCopyDbgToo = TRUE;
                break;
            case 'd':
                gbDelayCopy = TRUE;
                break;
            case 'r':
                gbReboot = TRUE;
                break;
            case 'l':
                gbSavePrevious = TRUE;
                break;
            case 't':
                giCopySourceType;   //!!!
                break;
            case 'T':
                gbForceTempCopy = TRUE;
                break;
            case 'o':
                DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(RES_DLGOPTIONS), NULL, OptionsDlgProc);
                return 1;
                break;
            case 'v':
                gbVerbose = TRUE;
                break;
            case 'w':
                gbPoll = TRUE;
                break;

            default:
                printf("ERROR: Invalid flag %c\n", argv[iArg][1]);
            case '?':
                PrintUsage();
                exit(0);
                break;
            }
        } else {
            if (!DoGetbin(argv[iArg], GB_FILE_ITSELF)) {
                gbReboot = FALSE;
            } else if (gbCopyDbgToo) {
                // got the binary, so now get the DBG & PDB file
                BOOL bGotDbg, bGotPdb;

                bGotDbg = DoGetbin(argv[iArg], GB_ASSOCIATED_DBG_FILE);
                bGotPdb = DoGetbin(argv[iArg], GB_ASSOCIATED_PDB_FILE);
                if (!bGotDbg && !bGotPdb) {
                    // if we didn't get either, then fail to reboot.
                    gbReboot = FALSE;
                }
            }
            nFiles++;
        }
    }

    if (nFiles == 0) {
        printf("ERROR: No files specified\n");
        PrintUsage();
        exit(0);
    }

    /*
     * Reboot if requested
     */
    if (gbReboot) {
        BOOLEAN PreviousPriv;

        printf("\nRebooting system\n");
        Sleep(5000);
        RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE, TRUE, FALSE, &PreviousPriv);
        ExitWindowsEx(EWX_FORCE|EWX_REBOOT, 0);
    }

    CloseHandle(ghRestoreCmd);

    return 1;
}

#define ENTER 0x0d

BOOL fConfirm(char *pszQuestion)
{
    int ch, chLast;

    chLast = 0;
    printf ("%s [yn] ", pszQuestion);
    while ( TRUE ) {

        ch = _getch();
        ch = tolower( ch );

        if (ch == ENTER && (chLast == 'y' || chLast == 'n')) {
            putchar('\n');
            return (chLast == 'y');
        }

        if (ch != 0) {
            if (ch == 'y' || ch == 'n') {
                putchar(ch);
                putchar('\b');
            }
        }
        chLast = ch;
    }
}

#define F_TIME 0x01
#define F_DATE 0x02

LPWSTR DateTimeString(
    CONST FILETIME *pft,
    DWORD Flags)
{
    SYSTEMTIME DateTime;
    FILETIME LocalFileTime;
    static WCHAR wszDateTime[80];
    int cch;

    FileTimeToLocalFileTime(pft, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &DateTime);

    if (Flags == 0) {
        Flags = F_TIME;
    }
    if (Flags & F_DATE) {
        cch = GetDateFormatW(LOCALE_USER_DEFAULT,
                             LOCALE_NOUSEROVERRIDE,
                             &DateTime,
                             NULL,
                             wszDateTime,
                             sizeof(wszDateTime)/sizeof(wszDateTime[0]) - 1);
        wszDateTime[cch-1] = '\t';
    } else {
        cch = 0;
    }

    if (Flags & F_TIME) {
        GetTimeFormatW(LOCALE_USER_DEFAULT,
                       LOCALE_NOUSEROVERRIDE,
                       &DateTime,
                       NULL,
                       &wszDateTime[cch],
                       sizeof(wszDateTime)/sizeof(wszDateTime[0]) - cch);
    }
    return wszDateTime;
}

DWORD PrintFileSize(
    CONST LPSTR pszFile)
{
    HANDLE hFindNext;
    WIN32_FIND_DATA FindFileData;

    hFindNext = FindFirstFile(pszFile, &FindFileData);
    if (hFindNext != INVALID_HANDLE_VALUE) {
        FindClose(hFindNext);
    }
    printf("Size %ld\n", FindFileData.nFileSizeLow);
    return FindFileData.nFileSizeLow;
}

/*
 * Poll for a file, returns TRUE when the file is ready to be fetched, FALSE if not
 */
BOOL PollForFile(
    CONST LPSTR szSrc,
    CONST LPSTR szDest,
    CONST LPSTR szSourceFile)  // just for re-printing the name when !gbVerbose
{
    FILETIME ftLastWriteSrc = {0, 0};
    FILETIME ftLastWriteDest = {0, 0};
    HANDLE hFindNext;
    WIN32_FIND_DATA FindFileData;
    FILETIME ft;
    SYSTEMTIME DateTime;
    OFSTRUCT OpenBuff;

    /*
     * Get last write time of destination (ftLastWriteDest)
     */
    hFindNext = FindFirstFile(szDest, &FindFileData);
    if (hFindNext != INVALID_HANDLE_VALUE) {
        FindClose(hFindNext);
        ftLastWriteDest = FindFileData.ftLastWriteTime;
        printf("\n  Time of destination = %ws\n",
               DateTimeString(&ftLastWriteDest, F_DATE|F_TIME));
    } else {
        printf("Can't find destination %s\n", szDest);
    }

    /*
     * Give the user a chance to pull down the current source if it is already
     * more recent than the destination.
     * If they want an even more recent source, Wait until the source file
     * starts getting updated.
     */
    while (TRUE) {
        hFindNext = FindFirstFile(szSrc, &FindFileData);
        if (hFindNext != INVALID_HANDLE_VALUE) {
            FindClose(hFindNext);
            if ((ftLastWriteSrc.dwHighDateTime | ftLastWriteSrc.dwLowDateTime) == 0) {
                ftLastWriteSrc = FindFileData.ftLastWriteTime;
                printf("  Time of source      = %ws\n",
                       DateTimeString(&ftLastWriteSrc, F_DATE|F_TIME));
                if (CompareFileTime(&ftLastWriteSrc, &ftLastWriteDest) > 0) {
                    // Source is more recent!
                    if (fConfirm("  Source is more recent, fetch it now?")) {
                        return TRUE;
                    }
                }
                printf("  Polling for a new %s", szSrc);
                fflush(stdout);
            } else {
                if (CompareFileTime(&FindFileData.ftLastWriteTime, &ftLastWriteSrc) > 0) {
                    // it got updated!
                    break;
                }
            }
        } else {
            /*
             * Source not there yet, we want to grab it as soon as it is ready
             */
            ftLastWriteSrc.dwLowDateTime = 1;
        }
        printf(".");
        Sleep(1000);
    }

    /*
     * The source is being written, so wait until the write stops
     * (When the write has finished, we will be able to open it exclusively)
     */
    do {
        HANDLE hTmp;
#ifdef DBG_POLL
        /*
         * This debug stuff show if & how the source file's timestamps & size
         * vary each time we go around the loop.
         */
        DWORD dwSizeH, dwSizeL;
        FILETIME ftC, ftA, ftW;
        ftC = FindFileData.ftCreationTime;
        ftA = FindFileData.ftLastAccessTime;
        ftW = FindFileData.ftLastWriteTime;
        dwSizeH = FindFileData.nFileSizeHigh;
        dwSizeL = FindFileData.nFileSizeLow;

        hFindNext = FindFirstFile(szSrc, &FindFileData);
        if (hFindNext == INVALID_HANDLE_VALUE) {
            break;
        }
        FindClose(hFindNext);

        /*
         * Some debug output each time we see that the src file has
         * changed size or timestamps.
         */
        if ((CompareFileTime(&ftA, &FindFileData.ftLastAccessTime) != 0) ||
            (CompareFileTime(&ftW, &FindFileData.ftLastWriteTime) != 0) ||
            (CompareFileTime(&ftC, &FindFileData.ftCreationTime) != 0) ||
            (dwSizeH != FindFileData.nFileSizeHigh) ||
            (dwSizeL != FindFileData.nFileSizeLow)) {
            printf("Create %ws   ",
                   DateTimeString(&FindFileData.ftCreationTime, F_TIME));
            printf("Access %ws   ",
                   DateTimeString(&FindFileData.ftLastAccessTime, F_TIME));
            ft = FindFileData.ftLastWriteTime;
            printf("Write %ws   ", DateTimeString(&ft, F_TIME));
            printf("Size %ld\n", dwSizeL);
        }
#endif

        /*
         * If we can open the file for writing, no other process has it open
         */
        hTmp = CreateFileA(
                          szSrc,
                          GENERIC_READ | GENERIC_WRITE,  // write access
                          0,                             // no sharing
                          NULL,                          // no Security Attributes
                          OPEN_EXISTING,                 // of course
                          FILE_ATTRIBUTE_NORMAL |        // whatever
                          FILE_FLAG_NO_BUFFERING,        // why not?
                          NULL);                         // no template
        if (hTmp != INVALID_HANDLE_VALUE) {
            CloseHandle(hTmp);
            break;
        }

        /*
         * If the share is read-only, the trick above won't work so we wait
         * for 1 second and then take it.
         */
        if (GetLastError() == ERROR_ACCESS_DENIED) {
            int i;
            printf("\n  %s is read-only, delay 5 seconds", szSrc);
            fflush(stdout);
            for (i = 0; i < 5; i++) {
                Sleep(1000);
                printf(".");
            }
            break;
        }
        printf("+");
        Sleep(500);
    } while (TRUE);

    /*
     * One last delay (for splitsym etc.)
     */
    Sleep(500);

    /*
     * Find out how big the file is now, just for the heck of it.
     */
    hFindNext = FindFirstFile(szSrc, &FindFileData);
    if (hFindNext != INVALID_HANDLE_VALUE) {
        FindClose(hFindNext);
    }
    VerbosePrintf("  Size %ld\n", FindFileData.nFileSizeLow);
    if (!gbVerbose) {
        printf("\n%s", szSourceFile);
        fflush(stdout);
    }
    return TRUE;
}

BOOL DoGetbin(
     LPSTR szFileName,
     DWORD dwAssociatedFile)
{
    BOOL bNetDrive = FALSE;
    BOOL bRet;
    BOOL bSkipDebugFiles = FALSE;
    DWORD dwRet;
    CHAR szDest[CCH_BUF];  // !! to go
    CHAR szTempFile[CCH_BUF];
    CHAR szSrc[CCH_BUF];
    CHAR szBackup[CCH_BUF];
    CHAR szSourceFile[CCH_BUF];
    CHAR szExt[10];
    PCHAR pszSrc = szSrc;
    PCHAR pszDot;
    WIN32_FIND_DATA FindFileData;

    /*
     * Get the source and destination files
     */
    strcpy( szSourceFile, szFileName );

    /*
     * Add the default extension if no extension of this file
     */
    pszDot = strrchr(szSourceFile, '.');
    if (pszDot == NULL) {
        pszDot = szSourceFile + strlen(szSourceFile);
        *pszDot = '.';
        strcpy( pszDot+1, szDEFCOPYEXT);
    }
    strcpy( szExt, pszDot+1);

    if ((_stricmp(szSourceFile, "win32k.sys") == 0) ||
            (_stricmp(szSourceFile, "user.exe") == 0)) {
        bSkipDebugFiles = TRUE;
    }

    switch (dwAssociatedFile) {
    case GB_ASSOCIATED_DBG_FILE:
        strcpy(pszDot+1, "dbg");
        sprintf(szDest, "%s\\%s\\%s", gszSymsDir, szExt, szSourceFile);
        sprintf(szSrc,  "%s\\symbols\\retail\\%s\\%s", gszSourceDir, szExt, szSourceFile);
        break;

    case GB_ASSOCIATED_PDB_FILE:
        strcpy(pszDot+1, "pdb");
        sprintf(szDest, "%s\\%s\\%s", gszSymsDir, szExt, szSourceFile);
        sprintf(szSrc,  "%s\\symbols\\retail\\%s\\%s", gszSourceDir, szExt, szSourceFile);
        break;

    case GB_FILE_ITSELF:
        if ((_stricmp(szExt, "sys") == 0) && !bSkipDebugFiles) {
            // seems like it's a driver, but not win32k.sys
            sprintf(szDest, "%s\\%s", gszDriverDestDir, szSourceFile);
        } else {
            sprintf(szDest, "%s\\%s", gszDestDir, szSourceFile);
        }
        sprintf(szSrc,  "%s\\%s", gszSourceDir, szSourceFile);
        break;

    default:
        printf("Internal error in Getbin() - bad dwAssociatedFile %d\n",
               dwAssociatedFile);
        return FALSE;
    }


    /*
     * Source -> Dest
     */
    if (gbVerbose) {
        printf("%s -> %s", szSrc, szDest);
    } else {
        printf("%s", szSourceFile);
    }
    fflush(stdout);

    if ((bSkipDebugFiles) && (dwAssociatedFile != GB_FILE_ITSELF)) {
        if (gbVerbose) {
            VerbosePrintf("  not copying %s\n", szSourceFile);
            return TRUE;
        } else {
            printf(" Skipped\n");
            return TRUE;
        }
    }

    /*
     * Backup the original if requested
     */
    if (gbSavePrevious) {
        PCHAR pch;

        strcpy(szBackup, szDest);
        // find LAST dot
        pch = strrchr(szBackup, '.');
        pch++;

        strcpy(pch, gszSaveExtension);

        if (pch) {
            bRet = CopyFile(szDest, szBackup, FALSE);
            if (!bRet) {
                dwRet = GetLastError();
                if (dwRet == ERROR_FILE_NOT_FOUND) {
                    if (gbVerbose) {
                        printf("\n  No existing file to back up, continuing anyway\n");
                    } else {
                        printf(" [Can't backup]");
                    }
                } else {
                    printf("\n  Unable to make backup copy  %ld\n", dwRet);

                    // don't worry about failing to back up DBG/PDB files
                    if (dwAssociatedFile == GB_FILE_ITSELF) {
                        printf("\n");
                        return FALSE;
                    }
                }
            } else {
                if (gbVerbose) {
                    printf("\n  Backed up to: %s", szBackup);
                } else {
                    printf(" [Backed up]", szBackup);
                }
            }
        }
        fflush(stdout);
    }


    if (gbDelayCopy) {
        gbTryCopy = FALSE;
        gbTryRename = FALSE;
    }

    if (gbPoll) {
        PollForFile(szSrc, szDest, szSourceFile);
        gbPoll = FALSE;
    }

    /*
     * Try a regular copy
     */
    if (gbTryCopy) {
        VerbosePrintf("\n  Try Reg copy... ");
        fflush(stdout);
TryCopy:

        bRet = CopyFile(szSrc, szDest, FALSE);

        if (bRet) {
            if (gbVerbose) {
                PrintFileSize(szSrc);
                printf("\n  ==== Succeeded ====\n");
            } else {
                printf(" COPIED\n");
            }
            return TRUE;
        } else {
            dwRet = GetLastError();

            switch (dwRet) {
            case ERROR_FILE_NOT_FOUND:
                printf(" ERROR: File not found\n");
                return FALSE;

            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                // Need to do delay copy
                break;

            default:
                printf("\n  ERROR: CopyFile(%s, %s, FALSE) Failed %ld\n",
                       szSrc, szDest, dwRet);
                return FALSE;
            }
        }
    }

    /*
     * Try a rename copy
     */
    if (gbTryRename) {
        VerbosePrintf("  Try Rename");
        bRet = MoveFileEx(szDest, szJUNKEXT, MOVEFILE_REPLACE_EXISTING);
        if (bRet) {
            if (!gbVerbose) {
                printf("[Renamed]");
            }
            fflush(stdout);
            gbTryRename = FALSE;
            goto TryCopy;
        } else {
            VerbosePrintf("\n");
            dwRet = GetLastError();

            switch (dwRet) {
            case ERROR_FILE_NOT_FOUND:
                printf(" ERROR: File not found\n");
                return FALSE;

            case ERROR_ACCESS_DENIED:
            case ERROR_SHARING_VIOLATION:
                // Need to do delay copy
                break;

            default:
                printf("\n  ERROR: Rename: MoveFileEx(%s, %s, MOVEFILE_REPLACE_EXISTING) failed %d\n",
                       szDest, szJUNKEXT, dwRet);
                return FALSE;
            }
        }
    }

    VerbosePrintf("\n  Trying delayed copy... ");
    if (_strnicmp(szFileName, "ntoskrnl", 8) == 0) {
        printf("\n"
               "  ===================== WARNING =====================\n");
        printf("  !Delayed copy of ntoskrnl.exe requires TWO reboots!\n");
        printf("  ===================================================\n");
    }

    if (!gbForceTempCopy) {
        /*
         * Determine source drive type
         */
        if (szSrc[0] == '\\' && szSrc[0] == '\\') {
            bNetDrive = TRUE;
        } else if (szSrc[1] == ':') {
            CHAR szRoot[5];

            szRoot[0] = szSrc[0];
            szRoot[1] = ':';
            szRoot[1] = '\\';

            if (GetDriveType(szRoot) == DRIVE_REMOTE)
                bNetDrive = TRUE;
        }
    }

    /*
     * If the source is a network path then copy it locally to temp file
     */
    if (gbForceTempCopy || bNetDrive) {
//        if (!GetTempPath(sizeof(szTempPath)/sizeof(szTempPath[0]), szTempPath)) {
//            printf("ERROR; GetTempPath Failed %ld\n", GetLastError());
//            return FALSE;
//        }

        if (!GetTempFileName(gszDestDir, "upd", 0, szTempFile)) {
            printf("ERROR; GetTempFileName Failed %ld\n", GetLastError());
            return FALSE;
        }

        bRet = CopyFile(szSrc, szTempFile, FALSE);
        if (!bRet) {
            dwRet = GetLastError();

            switch (dwRet) {
            case ERROR_FILE_NOT_FOUND:
                printf(" ERROR: File not found\n");
                return FALSE;

            default:
                printf("\n  ERROR: CopyFile(%s, %s, FALSE) failed %ld\n",
                       szSrc, szTempFile, dwRet);
                return FALSE;
            }
        }
        pszSrc = szTempFile;
        VerbosePrintf("  (temp file: %s)\n", pszSrc);
    }

    bRet = MoveFileEx(pszSrc, szDest, MV_FLAGS);

    if (bRet) {
        if (gbVerbose) {
            printf("  ==== Succeeded ====  (file will be copied during reboot)\n");
        } else {
            printf(" COPIED\n");
        }
    } else {
        printf("\n  ERROR: MoveFileEx(%s, %s, 0x%x) failed %ld\n",
               pszSrc, szDest, MV_FLAGS, GetLastError());
        return FALSE;
    }

    /*
     * Create the Restore.Cmd file if requested.
     */
    if (gbRestoreCmd) {
        char szBuff[CCH_BUF * 2];
        DWORD nb, nbWritten;

        if (ghRestoreCmd == NULL) {
            sprintf(szBuff, "%s\\%s", gszWinDir, szRESTORECMD);
            ghRestoreCmd = CreateFile(szBuff, GENERIC_WRITE, 0,
                                      (LPSECURITY_ATTRIBUTES)NULL, CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      (HANDLE)NULL);
            if (ghRestoreCmd == INVALID_HANDLE_VALUE) {
                printf("ERROR: Create file failed: %ld\n", GetLastError());
                return FALSE;
            }
        }
        nb = sprintf(szBuff, "del %s\nmv %s %s\n", szDest, szBackup, szDest);
        bRet = WriteFile(ghRestoreCmd, szBuff, nb, &nbWritten, NULL);
        if (!bRet) {
            printf("  ERROR: WriteFile failed %ld\n", GetLastError());
        }
    }

    return bRet;
}


INT_PTR CALLBACK OptionsDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHAR szNew[CCH_BUF];
    BOOL fRet;

    switch (msg) {
    case WM_INITDIALOG:
        SendDlgItemMessage( hDlg, IDD_DEST, WM_SETTEXT, 0, (LPARAM)gszDestDir);
        SetDlgItemText( hDlg, IDD_SOURCE, gszSourceDir);
        SetDlgItemText( hDlg, IDD_SYMS, gszSymsDir);

        if (gbTryRename)
            CheckDlgButton( hDlg, IDD_RENAME, TRUE);
        if (gbTryCopy)
            CheckDlgButton( hDlg, IDD_REG_COPY, TRUE);
        if (gbPoll)
            CheckDlgButton( hDlg, IDD_POLL, TRUE);
        if (gbReboot)
            CheckDlgButton( hDlg, IDD_REBOOT, TRUE);

        CheckDlgButton( hDlg, giCopySourceType, TRUE);

        SetDlgItemText( hDlg, IDD_SAVEEXTENSION, gszSaveExtension);
        SetDlgItemText( hDlg, IDD_COPYEXTENSION, szDEFCOPYEXT);
        if (gbSavePrevious) {
            if (gbRestoreCmd) {
                CheckDlgButton( hDlg, IDD_RESTORECMD, TRUE);
            }
            CheckDlgButton( hDlg, IDD_SAVEPREVIOUS, TRUE);
        } else {
            EnableWindow( GetDlgItem( hDlg, IDD_SAVEEXTENSION), FALSE);
            CheckDlgButton( hDlg, IDD_RESTORECMD, FALSE);
            EnableWindow( GetDlgItem( hDlg, IDD_RESTORECMD), FALSE);
            gbRestoreCmd = FALSE;
        }
        if (gbCopyDbgToo) {
            CheckDlgButton( hDlg, IDD_DBGTOO, TRUE);
        }
        SendDlgItemMessage( hDlg, IDD_SAVEEXTENSION, EM_LIMITTEXT, sizeof(gszSaveExtension)-1, 0);
        SendDlgItemMessage( hDlg, IDD_COPYEXTENSION, EM_LIMITTEXT, sizeof(gszCopyExtension)-1, 0);

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
        CHAR szString[8];

        case IDOK:

            // Write out the new defaults
            if (GetDlgItemText(hDlg, IDD_SOURCE, szNew, sizeof(szNew))) {
                _strupr(szNew);
                WriteProfileString(szGETBIN, szSOURCE, szNew);
            }

            if (GetDlgItemText(hDlg, IDD_DEST, szNew, sizeof(szNew))) {
                _strupr(szNew);
                WriteProfileString(szGETBIN, szDEST, szNew);
            }

            if (GetDlgItemText(hDlg, IDD_SYMS, szNew, sizeof(szNew))) {
                _strupr(szNew);
                WriteProfileString(szGETBIN, szSYMS, szNew);
            }

            fRet = IsDlgButtonChecked( hDlg, IDD_RENAME);
            WriteProfileString(szGETBIN, szTRYRENAME, fRet ? "1" : "0");

            fRet = IsDlgButtonChecked( hDlg, IDD_REG_COPY);
            WriteProfileString(szGETBIN, szTRYCOPY, fRet ? "1" : "0");

            fRet = IsDlgButtonChecked( hDlg, IDD_POLL);
            WriteProfileString(szGETBIN, szPOLL, fRet ? "1" : "0");

            fRet = IsDlgButtonChecked( hDlg, IDD_REBOOT);
            WriteProfileString(szGETBIN, szREBOOT, fRet ? "1" : "0");

            fRet = IsDlgButtonChecked( hDlg, IDD_SAVEPREVIOUS);
            WriteProfileString(szGETBIN, szSAVEPREVIOUS, fRet ? "1" : "0");
            if (fRet && GetDlgItemText(hDlg, IDD_SAVEEXTENSION, szNew, sizeof(szNew))) {
                _strupr(szNew);
                WriteProfileString(szGETBIN, szSAVEEXT, szNew);
            }

            fRet = IsDlgButtonChecked( hDlg, IDD_RESTORECMD);
            WriteProfileString(szGETBIN, szRESTORECMD, fRet ? "1" : "0");


            fRet = IsDlgButtonChecked( hDlg, IDD_DBGTOO);
            WriteProfileString(szGETBIN, szCOPYDBGTOO, fRet ? "1" : "0");


            if (IsDlgButtonChecked( hDlg, IDD_COPY_DATE)) {
                giCopySourceType = IDD_COPY_DATE;
            } else if (IsDlgButtonChecked( hDlg, IDD_COPY_LIST)) {
                giCopySourceType = IDD_COPY_LIST;
            } else {
                giCopySourceType = IDD_COPY_COMMAND;
            }

            _itoa(giCopySourceType, szString, 10);
            WriteProfileString(szGETBIN, szCOPYSOURCETYPE, szString);

            // FALL THROUGH!

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDD_SAVEPREVIOUS:
            if (HIWORD(wParam) == BN_CLICKED) {
                fRet = IsDlgButtonChecked( hDlg, IDD_SAVEPREVIOUS);
                EnableWindow( GetDlgItem( hDlg, IDD_SAVEEXTENSION), fRet);

                if (!fRet) {
                    CheckDlgButton( hDlg, IDD_RESTORECMD, FALSE);
                }
                EnableWindow( GetDlgItem( hDlg, IDD_RESTORECMD), fRet);
            }
            break;

        default:
            return (FALSE);
        }
        break;
        break;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gflags\gflags.h ===
#define DID_GFLAGS                  100
#define ID_FLAG_BASE                200
#define ID_FLAG_1                   201
#define ID_FLAG_2                   202
#define ID_FLAG_3                   203
#define ID_FLAG_4                   204
#define ID_FLAG_5                   205
#define ID_FLAG_6                   206
#define ID_FLAG_7                   207
#define ID_FLAG_8                   208
#define ID_FLAG_9                   209
#define ID_FLAG_10                  210
#define ID_FLAG_11                  211
#define ID_FLAG_12                  212
#define ID_FLAG_13                  213
//                                  214
#define ID_FLAG_15                  215
#define ID_FLAG_16                  216
#define ID_FLAG_17                  217
#define ID_FLAG_18                  218
#define ID_FLAG_19                  219
#define ID_FLAG_20                  220
#define ID_FLAG_21                  221
#define ID_FLAG_22                  222
#define ID_FLAG_23                  223
#define ID_FLAG_24                  224
#define ID_FLAG_25                  225
#define ID_FLAG_26                  226
#define ID_FLAG_27                  227
#define ID_FLAG_28                  228
#define ID_FLAG_29                  229
#define ID_FLAG_30                  230
#define ID_FLAG_31                  231
#define ID_FLAG_32                  232
#define ID_SYSTEM_REGISTRY          233
#define ID_KERNEL_MODE              234
#define ID_IMAGE_FILE_OPTIONS       235
#define ID_IMAGE_FILE_NAME          236
#define ID_DESTINATION_GROUP        237
#define ID_IMAGE_FILE_NAME_LABEL    238
#define ID_LAUNCH                   101
#define ID_COMMAND_LINE             103
#define ID_APPLY                    104
#define ID_MAX_STACK_DEPTH          105

#define ID_SPECIAL_POOL_GROUP        239
#define ID_SPECIAL_POOL_IS_TEXT      240
#define ID_SPECIAL_POOL_IS_NUMBER    241
#define ID_SPECIAL_POOL_TAG          242
#define ID_SPECIAL_POOL_VERIFY_START 243
#define ID_SPECIAL_POOL_VERIFY_END   244

#define ID_IMAGE_DEBUGGER_BUTTON    250
#define ID_IMAGE_DEBUGGER_VALUE     251
#define ID_IMAGE_DEBUGGER_GROUP     252

#define DID_PAGED_HEAP_WARNING      1000
#define ID_PAGEDHEAP_STATIC         1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gflags\gflags.cxx ===
/*++


Copyright (c) 1994-1999  Microsoft Corporation

--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.dbg>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "gflags.h"

CHAR GflagsHelpText[] = 
    "                                                                  \n"
    "usage: GFLAGS [-r [<Flags>] |                                     \n"
    "              [-k [<Flags>]] |                                    \n"
    "              [-i <ImageFileName> [<Flags>]] |                    \n"
    "              [-i <ImageFileName> -tracedb <SizeInMb>] |          \n"
    "              [-p <PageHeapOptions>] (use `-p ?' for help)        \n"
    "                                                                  \n"
    "where: <Flags> is a 32 bit hex number (0x12345678) that specifies \n"
    "       one or more global flags to set.                           \n"
    "       -r operates on system registry settings.                   \n"
    "       -k operates on kernel settings of the running system.      \n"
    "       -i operates on settings for a specific image file.         \n"
    "                                                                  \n"
    "       If only the switch is specified, then current settings     \n"
    "       are displayed, not modified.  If flags specified for -i    \n"
    "       option are FFFFFFFF, then registry entry for that image    \n"
    "       is deleted                                                 \n"
    "                                                                  \n"
    "The `-tracedb' option is used to set the size of the stack trace  \n"
    "database used to store runtime stack traces. The actual database  \n"
    "will be created if the `+ust' flag is set in a previous command.  \n"
    "`-tracedb 0' will revert to the default size for the database.    \n"
    "                                                                  \n"
    "If no arguments are specified to GFLAGS then it displays          \n"
    "a dialog box that allows the user to modify the global            \n"
    "flag settings.                                                    \n"
    "                                                                  \n"
    "Flags may either be a single hex number that specifies all        \n"
    "32-bits of the GlobalFlags value, or it can be one or more        \n"
    "arguments, each beginning with a + or -, where the + means        \n"
    "to set the corresponding bit(s) in the GlobalFlags and a =        \n"
    "means to clear the corresponding bit(s).  After the + or =        \n"
    "may be either a hex number or a three letter abbreviation         \n"
    "for a GlobalFlag.  Valid abbreviations are:                       \n"
    "                                                                  \n";

#define _PART_OF_GFLAGS_ 1
#include "..\pageheap\pageheap.cxx"

#if defined(_X86_)

//
// Use function pointers for ntdll import functions so gflags
// can fail with a user friendly message on win9x.
//

#define RtlIntegerToChar            pRtlIntegerToChar
#define NtQueryInformationProcess   pNtQueryInformationProcess
#define RtlCharToInteger            pRtlCharToInteger
#define NtSetSystemInformation      pNtSetSystemInformation
#define NtQuerySystemInformation    pNtQuerySystemInformation

typedef NTSTATUS (NTAPI *PRTLINTEGERTOCHAR)(
    ULONG,
    ULONG,
    LONG,
    PSZ
    );

typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS) (
    IN HANDLE,
    IN PROCESSINFOCLASS,
    OUT PVOID,
    IN ULONG,
    OUT PULONG
    );

typedef NTSTATUS (NTAPI * PRTLCHARTOINTEGER) (
    PCSZ,
    ULONG,
    PULONG
    );

typedef NTSTATUS (NTAPI * PNTSETSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS,
    IN PVOID,
    IN ULONG
    );


typedef NTSTATUS (NTAPI * PNTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS,
    OUT PVOID,
    IN ULONG,
    OUT PULONG
    );

PRTLINTEGERTOCHAR pRtlIntegerToChar;
PNTQUERYINFORMATIONPROCESS pNtQueryInformationProcess;
PRTLCHARTOINTEGER pRtlCharToInteger;
PNTSETSYSTEMINFORMATION pNtSetSystemInformation;
PNTQUERYSYSTEMINFORMATION pNtQuerySystemInformation;

#endif


BOOL
GflagsSetTraceDatabaseSize (
    PCHAR ApplicationName,
    ULONG SizeInMb,
    PULONG RealSize
    );

INT_PTR  APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL
EnableDebugPrivilege( VOID );

BOOL
OkToEnablePagedHeap( VOID );

HWND hwndMain;
HWND hwndPagedHeapDlg;

HKEY hSmKey, hMmKey;
DWORD InitialSetFlags;
DWORD LastSetFlags;

//
// Special pool management
//

#define SPECIAL_POOL_OVERRUNS_CHECK_FORWARD   1
#define SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD  0

DWORD LastSetSpecialPoolTag;
DWORD LastSetSpecialPoolOverruns = SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;

TCHAR SpecialPoolRenderBuffer[8 + 1];



DWORD InitialMaxStackTraceDepth;
CHAR LastDebuggerValue[ MAX_PATH ];

UINT SpecialPool[] = {
        ID_SPECIAL_POOL_GROUP,
        ID_SPECIAL_POOL_IS_TEXT,
        ID_SPECIAL_POOL_IS_NUMBER,
        ID_SPECIAL_POOL_TAG,
        ID_SPECIAL_POOL_VERIFY_START,
        ID_SPECIAL_POOL_VERIFY_END,
        ID_MAX_STACK_DEPTH,
        0
        };

UINT Debugger[] = {
        ID_IMAGE_DEBUGGER_GROUP,
        ID_IMAGE_DEBUGGER_VALUE,
        ID_IMAGE_DEBUGGER_BUTTON,
        0
        };

PCHAR SystemProcesses[] = {
        "csrss.exe",
        "winlogon.exe",
        "services.exe",
        "lsass.exe",
        "svchost.exe",
        "ntmssvc.exe",
        "rpcss.exe",
        "spoolsv.exe"
        };



EnableSetOfControls(
    HWND hDlg,
    UINT * Controls,
    BOOL Enable
    )
{
    UINT Control ;
    HWND hWnd ;

    Control = *Controls++ ;
    while ( Control )
    {
        hWnd = GetDlgItem( hDlg, Control );

        EnableWindow( hWnd, Enable );

        ShowWindow( hWnd, Enable ? SW_NORMAL : SW_HIDE );

        Control = *Controls++ ;
    }

    return 0;
}

DWORD
GetSystemRegistryFlags( VOID )
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                      0,
                      KEY_READ | KEY_WRITE,
                      &hSmKey
                    ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Open Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager", MB_OK );
        ExitProcess( 0 );
        }

    cbKey = sizeof( GFlags );
    if (RegQueryValueEx( hSmKey,
                         "GlobalFlag",
                         0,
                         &type,
                         (LPBYTE)&GFlags,
                         &cbKey
                       ) != ERROR_SUCCESS ||
        type != REG_DWORD
       ) {
        MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\GlobalFlag", MB_OK );
        RegCloseKey( hSmKey );
        ExitProcess( 0 );
        }

    cbKey = sizeof( InitialMaxStackTraceDepth );
    if (RegQueryValueEx( hSmKey,
                         "MaxStackTraceDepth",
                         0,
                         &type,
                         (LPBYTE)&InitialMaxStackTraceDepth,
                         &cbKey
                       ) != ERROR_SUCCESS ||
        type != REG_DWORD
       ) {
        InitialMaxStackTraceDepth = 16;
        }

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
                      0,
                      KEY_READ | KEY_WRITE,
                      &hMmKey
                    ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Open Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", MB_OK );
        RegCloseKey( hSmKey );
        ExitProcess( 0 );
        }

    cbKey = sizeof( LastSetSpecialPoolTag );
    if (RegQueryValueEx( hMmKey,
                         "PoolTag",
                         0,
                         &type,
                         (LPBYTE)&LastSetSpecialPoolTag,
                         &cbKey
                       ) == ERROR_SUCCESS
        ) {

        if (type != REG_DWORD) {
            MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\PoolTag", MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }
    } else {
        LastSetSpecialPoolTag = 0;
    }

    cbKey = sizeof( LastSetSpecialPoolOverruns );
    if (RegQueryValueEx( hMmKey,
                         "PoolTagOverruns",
                         0,
                         &type,
                         (LPBYTE)&LastSetSpecialPoolOverruns,
                         &cbKey
                       ) == ERROR_SUCCESS
        ) {

        if (type != REG_DWORD) {

            MessageBox( hwndMain,
                        "Value Type Error",
                        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
                        "\\PoolTagOverruns",
                        MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }

        //
        // The only legal values are 0, 1.
        //

        if (LastSetSpecialPoolOverruns != SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD &&
            LastSetSpecialPoolOverruns != SPECIAL_POOL_OVERRUNS_CHECK_FORWARD) {

            MessageBox( hwndMain,
                        "Value Data Error",
                        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
                        "\\PoolTagOverruns",
                        MB_OK );
            RegCloseKey( hSmKey );
            RegCloseKey( hMmKey );
            ExitProcess( 0 );
        }

    } else {
        LastSetSpecialPoolOverruns = SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
    }

    return GFlags;
}

BOOLEAN
SetSystemRegistryFlags(
    DWORD GFlags,
    DWORD MaxStackTraceDepth,
    DWORD SpecialPoolTag,
    DWORD SpecialPoolOverruns
    )
{
    if (RegSetValueEx( hSmKey,
                       "GlobalFlag",
                       0,
                       REG_DWORD,
                       (LPBYTE)&GFlags,
                       sizeof( GFlags )
                     ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\GlobalFlag", MB_OK );
        RegCloseKey( hSmKey );
        RegCloseKey( hMmKey );
        ExitProcess( 0 );
        }

    if (RegSetValueEx( hSmKey,
                       "MaxStackTraceDepth",
                       0,
                       REG_DWORD,
                       (LPBYTE)&MaxStackTraceDepth,
                       sizeof( MaxStackTraceDepth )
                     ) != ERROR_SUCCESS
       ) {
        MessageBox( hwndMain, "Value Error", "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\MaxStackTraceDepth", MB_OK );
        RegCloseKey( hSmKey );
        RegCloseKey( hMmKey );
        ExitProcess( 0 );
        }

    //
    //  Only modify special pool if we went to GUI mode
    //

    if (hwndMain) {

        if (SpecialPoolTag) {

            if (RegSetValueEx( hMmKey,
                               "PoolTag",
                               0,
                               REG_DWORD,
                               (LPBYTE)&SpecialPoolTag,
                               sizeof( SpecialPoolTag )
                               ) != ERROR_SUCCESS
                ) {
                MessageBox( hwndMain,
                            "Value Error",
                            "SYSTEM\\CurrentControlSet\\Control\\Session Manager"
                            "\\Memory Management\\PoolTag",
                            MB_OK );
                RegCloseKey( hSmKey );
                RegCloseKey( hMmKey );
                ExitProcess( 0 );
            }

            if (RegSetValueEx( hMmKey,
                               "PoolTagOverruns",
                               0,
                               REG_DWORD,
                               (LPBYTE)&SpecialPoolOverruns,
                               sizeof( SpecialPoolOverruns )
                               ) != ERROR_SUCCESS
                ) {
                MessageBox( hwndMain,
                            "Value Error",
                            "SYSTEM\\CurrentControlSet\\Control\\Session Manager"
                            "\\Memory Management\\PoolTag",
                            MB_OK );
                RegCloseKey( hSmKey );
                RegCloseKey( hMmKey );
                ExitProcess( 0 );
            }


        } else {

            RegDeleteValue( hMmKey,
                            "PoolTag"
                          );

            RegDeleteValue( hMmKey,
                            "PoolTagOverruns"
                          );
        }
    }

    InitialMaxStackTraceDepth = MaxStackTraceDepth;
    LastSetFlags = GFlags;

    LastSetSpecialPoolTag = SpecialPoolTag;
    LastSetSpecialPoolOverruns = SpecialPoolOverruns;

    return TRUE;
}

DWORD
GetKernelModeFlags( VOID )
{
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;

    Status = NtQuerySystemInformation( SystemFlagsInformation,
                                       &SystemInformation,
                                       sizeof( SystemInformation ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        MessageBox( hwndMain, "Value Error", "Kernel Mode Flags", MB_OK );
        ExitProcess( 0 );
        }

    return SystemInformation.Flags;
}

BOOLEAN
AddImageNameToUSTString(
    PCHAR ImageFileName
    )
{
    CHAR RegKey[ MAX_PATH ];
    CHAR *Enabled = NULL;
    HKEY hKey;
    DWORD Result;
    DWORD Length;

    if (strlen( ImageFileName ) == 0)
        return FALSE;

    // Open the Key
    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                            );

    if (Result == ERROR_SUCCESS) {
        // Get the current length of the registry key
        Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, NULL, &Length );

        if (Result == ERROR_SUCCESS){
            // Get a buffer big enough for current key, a ';', and our new name.
            Enabled = (PCHAR)malloc(Length + strlen(ImageFileName)+ 1);

            if (Enabled) {
                // Get the current key value
                Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, (PBYTE)Enabled, &Length );

                if (Result == ERROR_SUCCESS) {
                    // If we are not currently in there, let add ourselves
                    if (!strstr(Enabled, ImageFileName)) {
                        //Watch for a trailing ';'
                        if (Enabled[strlen(Enabled) - 1] != ';')
                            strcat(Enabled, ";");

                        strcat(Enabled, ImageFileName);

                        Result = RegSetValueEx( hKey,
                                                "USTEnabled",
                                                0,
                                                REG_SZ,
                                                (PBYTE)Enabled,
                                                (strlen(Enabled) + 1));
                    }
                }

                free(Enabled);
            } // if enabled
        } // Result == ERROR_SUCCESS on RegQueryValue
        else if (Result == ERROR_FILE_NOT_FOUND) {
                // Key doesnt currently exist so lets just set it.
                Result = RegSetValueEx( hKey,
                                        "USTEnabled",
                                        0,
                                        REG_SZ,
                                        (PBYTE)ImageFileName,
                                        (strlen(ImageFileName) + 1));
        } // Result == ERROR_FILE_NOT_FOUND on RegQueryValue

        RegCloseKey( hKey );
    } // Result == ERROR_SUCCESS on RegCreateKeyEx

    // Did we succeed or not
    if (Result != ERROR_SUCCESS) {
        MessageBox( hwndMain,
                    "Failure adding or accessing User Stack Trace Registry Key",
                    ImageFileName,
                    MB_OK
                  );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
DelImageNameFromUSTString(
    PCHAR ImageFileName
    )
{
    CHAR RegKey[ MAX_PATH ];
    CHAR *Enabled = NULL;
    CHAR *NameStart = NULL, *NameEnd = NULL;
    HKEY hKey;
    DWORD Result;
    DWORD Length;

    if (strlen( ImageFileName ) == 0)
        return FALSE;

    // Open the Key
    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL
                            );

    if (Result == ERROR_SUCCESS) {
        // Get the current length of the registry key
        Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, NULL, &Length );

        if (Result == ERROR_SUCCESS) {
            if (Length != 0) {
                 // Get a buffer big enough for current key
                Enabled = (PCHAR)malloc(Length);
                if (Enabled) {
                    // Get the current key value
                    Result = RegQueryValueEx( hKey, "USTEnabled", NULL, NULL, (PBYTE)Enabled, &Length );

                    if (Result == ERROR_SUCCESS) {

                        // If we are currently in there, delete ourselves
                        if (NameStart = strstr(Enabled, ImageFileName)) {
                            NameEnd = NameStart + strlen(ImageFileName);

                            if (*NameEnd == ';'){
                                NameEnd++;
                                strcpy(NameStart, NameEnd);
                            }
                            else
                                *NameStart = '\0';

                            //Knock off any trailing ';'
                            if (Enabled[strlen(Enabled) - 1] == ';')
                                Enabled[strlen(Enabled) - 1] = '\0';

                            if (strlen(Enabled)) {
                                Result = RegSetValueEx( hKey,
                                                        "USTEnabled",
                                                        0,
                                                        REG_SZ,
                                                        (PBYTE)Enabled,
                                                        (strlen(Enabled) + 1));
                            }
                            else{
                                Result = RegDeleteValue( hKey, "USTEnabled");
                            }
                        }
                    }

                    free(Enabled);
                }
            }
        }
        else if (Result == ERROR_FILE_NOT_FOUND) {
            // This is a case where the registry key does not already exist
            Result = ERROR_SUCCESS;
        }
        RegCloseKey( hKey );
    }

    // Did we succeed or not
    if (Result != ERROR_SUCCESS) {
        MessageBox( hwndMain,
                    "Failure accessing or deleting User Stack Trace Registry Key",
                    ImageFileName,
                    MB_OK
                  );

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SetKernelModeFlags(
    DWORD GFlags
    )
{
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;

    if (!EnableDebugPrivilege()) {
        MessageBox( hwndMain, "Access Denied", "Unable to enable debug privilege", MB_OK );
        ExitProcess( 0 );
        }

    SystemInformation.Flags = GFlags;
    Status = NtSetSystemInformation( SystemFlagsInformation,
                                     &SystemInformation,
                                     sizeof( SystemInformation )
                                   );
    if (!NT_SUCCESS( Status )) {
        MessageBox( hwndMain, "Value Error", "Kernel Mode Flags", MB_OK );
        ExitProcess( 0 );
        }

    LastSetFlags = GFlags;
    return TRUE;
}

DWORD
GetImageFileNameFlags(
    PCHAR ImageFileName
    )
{
    CHAR Buffer[ MAX_PATH ];
    CHAR RegKey[ MAX_PATH ];
    DWORD Length = MAX_PATH;
    DWORD GFlags;
    HKEY hKey;

    GFlags = 0;
    if (strlen( ImageFileName ) != 0) {
        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {
            if (RegQueryValueEx( hKey, "GlobalFlag", NULL, NULL, (PBYTE)Buffer, &Length ) == ERROR_SUCCESS ) {
                RtlCharToInteger( Buffer, 0, &GFlags );
                }

            RegCloseKey( hKey );
            }

        }

    return GFlags;
}

BOOL
GetImageFileNameDebugger(
    PCHAR ImageFileName,
    PCHAR Debugger
    )
{
    CHAR RegKey[ MAX_PATH ];
    DWORD Length = MAX_PATH;
    DWORD GFlags;
    HKEY hKey;
    BOOL Success = FALSE;

    GFlags = 0;
    if (strlen( ImageFileName ) != 0) {
        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {

            if (RegQueryValueEx( hKey, "Debugger", NULL, NULL, (PBYTE)Debugger, &Length ) == ERROR_SUCCESS ) {
                Success = TRUE ;
                }

            RegCloseKey( hKey );
            }

        }

    return Success ;
}


BOOLEAN
SetImageFileNameFlags(
    PCHAR ImageFileName,
    DWORD GFlags
    )
{
    CHAR Buffer[ MAX_PATH ];
    CHAR RegKey[ MAX_PATH ];
    HKEY hKey;
    DWORD Result;
    DWORD Length;
    DWORD Disposition;

    if (strlen( ImageFileName ) != 0) {

        sprintf( RegKey,
            "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
            ImageFileName
            );

        Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
            RegKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &Disposition
            );

        if (Result == ERROR_SUCCESS) {
            if (GFlags == (DWORD)-1) {
                Result = RegDeleteValue( hKey,
                    "GlobalFlag"
                    );
                DelImageNameFromUSTString(ImageFileName);
            }
            else {
                Length = sprintf( Buffer, "0x%08x", GFlags ) + 1;
                Result = RegSetValueEx( hKey,
                    "GlobalFlag",
                    0,
                    REG_SZ,
                    (PBYTE)Buffer,
                    Length
                    );

                if (GFlags&FLG_USER_STACK_TRACE_DB)
                    AddImageNameToUSTString(ImageFileName);
                else
                    DelImageNameFromUSTString(ImageFileName);

                //
                // If we enable page heap for a single application
                // then we will avoid default behavior which is
                // page heap light (only normal allocations) and
                // we will enable the page heap full power.
                // Note that we do not do this for system wide
                // settings because this will make the machine
                // unbootable.
                //

                if ((GFlags & FLG_HEAP_PAGE_ALLOCS)) {

                    Length = sprintf( Buffer, "0x%08x", 0x03 ) + 1;

                    Result = RegSetValueEx(
                        hKey,
                        "PageHeapFlags",
                        0,
                        REG_SZ,
                        (PBYTE)Buffer,
                        Length
                        );
                }
            }

            RegCloseKey( hKey );
        }

        if (Result != ERROR_SUCCESS) {
            MessageBox( hwndMain,
                (GFlags == (DWORD)-1) ?
                "Failed to delete registry value" :
            "Failed to set registry value",
                ImageFileName,
                MB_OK
                );
            return FALSE;
        }

        LastSetFlags = GFlags;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
SetImageFileNameDebugger(
    PCHAR ImageFileName,
    PCHAR Debugger
    )
{
    CHAR RegKey[ MAX_PATH ];
    HKEY hKey;
    DWORD Result;
    DWORD Length;
    DWORD Disposition;

    if (strlen( ImageFileName ) != 0) {

        sprintf( RegKey,
                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
                 ImageFileName
               );

        Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                 RegKey,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_ALL_ACCESS,
                                 NULL,
                                 &hKey,
                                 &Disposition
                               );

        if (Result == ERROR_SUCCESS) {
            if ( *Debugger  )
            {
                Result = RegSetValueEx( hKey,
                                        "Debugger",
                                        0,
                                        REG_SZ,
                                        (PBYTE)Debugger,
                                        strlen( Debugger ) + 1 );

            }
            else
            {
                Result = RegDeleteValue( hKey, "Debugger" );
            }

            RegCloseKey( hKey );
            }

        if (Result != ERROR_SUCCESS) {
            MessageBox( hwndMain,
                        ( *Debugger ) ?
                            "Failed to delete registry value" :
                            "Failed to set registry value",
                        ImageFileName,
                        MB_OK
                      );
            return FALSE;
            }

        return TRUE;
        }

    return FALSE;
}


BOOLEAN fRegistrySettings;
BOOLEAN fKernelSettings;
BOOLEAN fImageFileSettings;
BOOLEAN fDisplaySettings;
BOOLEAN fLaunchCommand;
BOOLEAN fFlushImageSettings;
PUCHAR ImageFileName;
DWORD GlobalFlagMask;
DWORD GlobalFlagSetting;
DWORD MaxDepthSetting;
DWORD OldGlobalFlags;
DWORD NewGlobalFlags;
DWORD NewGlobalFlagsValidMask;
DWORD NewGlobalFlagsIgnored;

void
DisplayFlags(
    PCHAR Msg,
    DWORD Flags,
    DWORD FlagsIgnored
    )
{
    int i;

    if (Flags == 0xFFFFFFFF) {
        printf( "No %s\n", Msg );
        return;
    }

    printf( "Current %s are: %08x\n", Msg, Flags );
    for (i=0; i<32; i++) {
        if (GlobalFlagInfo[i].Abbreviation != NULL &&
            (Flags & GlobalFlagInfo[i].Flag)
            ) {

            if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, "Enable page heap");
            }
            else {

                printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
            }
        }
    }

    if (FlagsIgnored) {
        printf( "Following settings were ignored: %08x\n", FlagsIgnored );
        for (i=0; i<32; i++) {
            if (GlobalFlagInfo[i].Abbreviation != NULL &&
                (FlagsIgnored & GlobalFlagInfo[i].Flag)
                ) {

                if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                    printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, "Enable page heap");
                }
                else {

                    printf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
                }
            }
        }
    }
}


BOOL
IsCmdlineOption (
    PCHAR Option,
    PCHAR Name,
    PCHAR NameEx
    )
{
    if (_stricmp (Option, Name) == 0 || _stricmp (Option, NameEx) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    MSG msg;
    CHAR c;
    PCHAR s;
    BOOLEAN fUsage, fExpectingFlags, fExpectingDepth;
    ULONG i;
    CHAR Settings[ 2*MAX_PATH ];

#if defined(_X86_)

    OSVERSIONINFO VersionInfo;
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );
    if ( VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ) {
        MessageBox( NULL,
            "Global flags only runs on Windows NT and Windows 2000.  The glfags command was ignored.",
            "Global Flags Error",
            0 );
        exit(0);
    }
    else {
        HMODULE hDll;
        hDll = GetModuleHandle("ntdll");
        if (hDll != NULL) {
            pRtlIntegerToChar = ( PRTLINTEGERTOCHAR )
            GetProcAddress(
                hDll,
                "RtlIntegerToChar"
                );
            pNtQueryInformationProcess = ( PNTQUERYINFORMATIONPROCESS )
            GetProcAddress(
                hDll,
                "NtQueryInformationProcess"
                );
            pRtlCharToInteger = ( PRTLCHARTOINTEGER )
            GetProcAddress(
                hDll,
                "RtlCharToInteger"
                );
            pNtSetSystemInformation = ( PNTSETSYSTEMINFORMATION )
            GetProcAddress(
                hDll,
                "NtSetSystemInformation"
                );
            pNtQuerySystemInformation = ( PNTQUERYSYSTEMINFORMATION )
            GetProcAddress(
                hDll,
                "NtQuerySystemInformation"
                );
        }
    }
#endif

    //
    // Check if we need to redirect the whole command line to the page heap
    // command line parser.
    //

    if (argc >= 2 && IsCmdlineOption (argv[1], "/p", "-p")) {

        PageHeapMain (argc - 1, argv + 1);
        exit(0);
    }
                                                                
    //
    // Check forst for `-i APP -tracedb SIZE' option
    //

    if (argc == 5 && 
        IsCmdlineOption (argv[3], "/tracedb", "-tracedb") &&
        IsCmdlineOption (argv[1], "/i", "-i")) {
        
        ULONG RealSize;

        if (GflagsSetTraceDatabaseSize (argv[2], atoi (argv[4]), &RealSize) == FALSE) {
            
            printf("Failed to set the trace database size for `%s' \n", argv[2]);
            exit(5);
        }
        else {

            if (RealSize > 0) {
                printf("Trace database size for `%s' set to %u Mb.\n", argv[2], RealSize);
            }
            else {
                printf("Will use default size for the trace database. \n");
            }
            exit(0);
        }
    }

    //
    // Continue ...
    //

    hwndMain = NULL;
    fUsage = FALSE;
    fExpectingFlags = FALSE;
    fExpectingDepth = FALSE;
    GlobalFlagMask = 0xFFFFFFFF;
    GlobalFlagSetting = 0;
    while (--argc) {
        s = *++argv;
        if (!fExpectingFlags && (*s == '-' || *s == '/')) {
            while (*++s) {
                c = (char)tolower(*s);
                switch (c) {
                    case 'r':
                    case 'k':
                    case 'i':
                        if (fRegistrySettings || fKernelSettings || fImageFileSettings) {
                            fprintf( stderr, "GFLAG: may only specify one of -r, -k or -i\n" );
                            fUsage = TRUE;
                        }
                        else {
                            fExpectingFlags = TRUE;
                            fDisplaySettings = TRUE;
                            if (c == 'r') {
                                fRegistrySettings = TRUE;
                                fExpectingDepth = TRUE;
                                OldGlobalFlags = GetSystemRegistryFlags();
                                NewGlobalFlagsValidMask = VALID_SYSTEM_REGISTRY_FLAGS;
                                strcpy( Settings, "Boot Registry Settings" );
                            }
                            else
                                if (c == 'k') {
                                fKernelSettings = TRUE;
                                NewGlobalFlagsValidMask = VALID_KERNEL_MODE_FLAGS;
                                OldGlobalFlags = GetKernelModeFlags();
                                strcpy( Settings, "Running Kernel Settings" );
                            }
                            else {
                                fImageFileSettings = TRUE;
                                NewGlobalFlagsValidMask = VALID_IMAGE_FILE_NAME_FLAGS;
                                if (!--argc) {
                                    fprintf( stderr, "GFLAGS: ImageFileName missing after -i switch\n" );
                                    fUsage = TRUE;
                                    exit( 0 ); // 179741 - JHH
                                }
                                else {
                                    ImageFileName = (PUCHAR)(*++argv);
                                    OldGlobalFlags = GetImageFileNameFlags( (PCHAR)ImageFileName );
                                    sprintf( Settings, "Registry Settings for %s executable", ImageFileName );
                                }
                            }
                        }
                        break;

                    case 'l':
                        fLaunchCommand = TRUE;
                        fExpectingFlags = TRUE;
                        break;

                    default:
                        fUsage = TRUE;
                        break;
                }
            }
        }
        else {
            if (fExpectingFlags) {

                fDisplaySettings = FALSE;

                if (*s == '+' || *s == '-') {

                    if (strlen(s+1) == 3) {

                        for (i = 0; i < 32; i += 1) {

                            if ((NewGlobalFlagsValidMask & GlobalFlagInfo[i].Flag) &&
                                (GlobalFlagInfo[i].Abbreviation != NULL) &&
                                _stricmp( GlobalFlagInfo[i].Abbreviation, s+1 ) == NULL) {

                                if (fKernelSettings) {

                                    if (_stricmp(GlobalFlagInfo[i].Abbreviation, "ptg") == NULL) {
                                        fprintf (stderr, 
                                                 "Ignoring `ptg' flag. It can be used only with registry "
                                                 "settings (`-r') because it requires a reboot.\n");
                                        continue;
                                    }

                                    if (_stricmp(GlobalFlagInfo[i].Abbreviation, "kst") == NULL) {
                                        fprintf (stderr, 
                                                 "Ignoring `kst' flag. It can be used only with registry "
                                                 "settings (`-r') because it requires a reboot.\n");
                                        continue;
                                    }
                                }

                                if (*s == '-') {
                                    GlobalFlagMask &= ~GlobalFlagInfo[i].Flag;
                                }
                                else {
                                    GlobalFlagSetting |= GlobalFlagInfo[i].Flag;
                                }

                                s += 4;
                                break;
                            }
                        }
                    }

                    if (*s != '\0') {
                        if (*s++ == '-') {
                            GlobalFlagMask &= ~strtoul( s, &s, 16 );
                        }
                        else {
                            GlobalFlagSetting |= strtoul( s, &s, 16 );
                        }
                    }
                }
                else {
                    fExpectingFlags = FALSE;
                    GlobalFlagSetting = strtoul( s, &s, 16 );
                }

                if (fLaunchCommand) {
                    exit( 0 );
                }

                if (fImageFileSettings && OldGlobalFlags == 0xFFFFFFFF) {
                    OldGlobalFlags = 0;
                }
            }
            else
                if (fExpectingDepth) {
                MaxDepthSetting = strtoul( s, &s, 10 );
                fExpectingDepth = FALSE;
            }
            else {
                fprintf( stderr, "GFLAGS: Unexpected argument - '%s'\n", s );
                fUsage = TRUE;
            }
        }
    }

    if (fUsage) {
        
        fputs(GflagsHelpText,
              stderr);

        for (i=0; i<32; i++) {

            if (GlobalFlagInfo[i].Abbreviation != NULL) {

                if (_stricmp(GlobalFlagInfo[i].Abbreviation, "hpa") == 0) {

                    fprintf( stderr, "    %s - %s\n",
                        GlobalFlagInfo[i].Abbreviation,
                        "Enable page heap");
                } 
                else {

                    fprintf( stderr, "    %s - %s\n",
                        GlobalFlagInfo[i].Abbreviation,
                        GlobalFlagInfo[i].Description);
                }
            }
        }

        fprintf( stderr, "\nAll images with ust enabled can be accessed in the\n" );
        fprintf( stderr, "USTEnabled key under 'Image File Options'.\n" );
        exit( 1 );
    }

    NewGlobalFlags = (OldGlobalFlags & GlobalFlagMask) | GlobalFlagSetting;
    if (!fImageFileSettings || NewGlobalFlags != 0xFFFFFFFF) {
        NewGlobalFlagsIgnored = ~NewGlobalFlagsValidMask & NewGlobalFlags;
        NewGlobalFlags &= NewGlobalFlagsValidMask;
    }

    if (fDisplaySettings) {
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    if (fRegistrySettings) {
        SetSystemRegistryFlags( NewGlobalFlags,
            fExpectingDepth ? InitialMaxStackTraceDepth : MaxDepthSetting,
            0,
            SPECIAL_POOL_OVERRUNS_CHECK_FORWARD
            );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    else
        if (fKernelSettings) {
        SetKernelModeFlags( NewGlobalFlags );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }
    else
        if (fImageFileSettings) {
        SetImageFileNameFlags( (PCHAR)ImageFileName, NewGlobalFlags );
        DisplayFlags( Settings, NewGlobalFlags, NewGlobalFlagsIgnored );
        exit( 0 );
    }

    CreateDialog( NULL,
        (LPSTR)DID_GFLAGS,
        NULL,
        MainWndProc
        );
    if (!hwndMain) {
        MessageBox( hwndMain, "Main Error", "Cant create dialog", MB_OK );
        ExitProcess( 0 );
    }

    while (GetMessage( &msg, 0, 0, 0 )) {
        if (!IsDialogMessage( hwndMain, &msg )) {
            DispatchMessage( &msg );
        }
    }

    exit( 0 );
    return 0;
}


VOID
SetCheckBoxesFromFlags(
    DWORD GFlags,
    DWORD ValidFlags
    )
{
    int iBit;

    GFlags &= ValidFlags;
    LastSetFlags = GFlags;
    for (iBit=0; iBit < 32; iBit++) {
        CheckDlgButton( hwndMain,
                        ID_FLAG_1 + iBit,
                        (GFlags & (1 << iBit)) ? 1 : 0
                      );

        ShowWindow( GetDlgItem( hwndMain, ID_FLAG_1 + iBit ),
                    (ValidFlags & (1 << iBit)) ? SW_SHOWNORMAL : SW_HIDE
                  );
        }
}

DWORD
GetFlagsFromCheckBoxes( VOID )
{
    DWORD GFlags;
    int iBit;

    GFlags = 0;
    for (iBit=0; iBit < 32; iBit++) {
        if (IsDlgButtonChecked( hwndMain, ID_FLAG_1 + iBit )) {
            GFlags |= (1 << iBit);
            }
        }

    return GFlags;
}


VOID
DoLaunch(
    PCHAR CommandLine,
    DWORD GFlags
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;
    BOOLEAN ReadImageFileExecOptions;

    memset( &StartupInfo, 0, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof( StartupInfo );
    if (CreateProcess( NULL,
                       CommandLine,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_SUSPENDED,
                       NULL,
                       NULL,
                       &StartupInfo,
                       &ProcessInformation
                     )
       ) {
        Status = NtQueryInformationProcess( ProcessInformation.hProcess,
                                            ProcessBasicInformation,
                                            &BasicInformation,
                                            sizeof( BasicInformation ),
                                            NULL
                                          );
        if (NT_SUCCESS( Status )) {
            ReadImageFileExecOptions = TRUE;
            if (!WriteProcessMemory( ProcessInformation.hProcess,
                                     &BasicInformation.PebBaseAddress->ReadImageFileExecOptions,
                                     &ReadImageFileExecOptions,
                                     sizeof( ReadImageFileExecOptions ),
                                     NULL
                                   ) ||
                !WriteProcessMemory( ProcessInformation.hProcess,
                                     &BasicInformation.PebBaseAddress->NtGlobalFlag,
                                     &GFlags,
                                     sizeof( GFlags ),
                                     NULL
                                   )
               ) {
                Status = STATUS_UNSUCCESSFUL;
                }
            }


        if (!NT_SUCCESS( Status )) {
            MessageBox( hwndMain,
                        "Launch Command Line",
                        "Unable to pass flags to process - terminating",
                        MB_OK
                      );
            TerminateProcess( ProcessInformation.hProcess, 1 );
            }

        ResumeThread( ProcessInformation.hThread );
        CloseHandle( ProcessInformation.hThread );
        MsgWaitForMultipleObjects( 1,
                                   &ProcessInformation.hProcess,
                                   FALSE,
                                   NMPWAIT_WAIT_FOREVER,
                                   QS_ALLINPUT
                                 );
        CloseHandle( ProcessInformation.hProcess );
        }
    else {
        MessageBox( hwndMain, "Launch Command Line", "Unable to create process", MB_OK );
        }

    return;
}


DWORD LastRadioButtonId;
DWORD SpecialPoolModeId;
DWORD SpecialPoolOverrunsId;

BOOLEAN
CheckSpecialPoolTagItem(
    HWND hwnd,
    BOOLEAN ForApply
    )
{
    DWORD NumChars;
    DWORD i;
    BOOLEAN IsIllegal = FALSE;
    BOOLEAN IsAmbiguous = FALSE;

    NumChars = GetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer, sizeof( SpecialPoolRenderBuffer ));

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            //
            //  Check for illegal characters.
            //

            if (NumChars > 8) {

                IsIllegal = TRUE;

            } else {

                for (i = 0; i < NumChars; i++) {

                    if (!((SpecialPoolRenderBuffer[i] >= '0' &&
                           SpecialPoolRenderBuffer[i] <= '9') ||

                          (SpecialPoolRenderBuffer[i] >= 'a' &&
                           SpecialPoolRenderBuffer[i] <= 'f') ||

                          (SpecialPoolRenderBuffer[i] >= 'A' &&
                           SpecialPoolRenderBuffer[i] <= 'F'))) {

                        IsIllegal = TRUE;
                        break;
                    }
                }
            }

        } else {

            //
            //  Check for too many characters.
            //

            if (NumChars > sizeof(DWORD)) {

                IsIllegal = TRUE;
            }

            //
            //  We check a few more things when the user is really writing back.
            //

            if (!IsIllegal && ForApply) {

                //
                //  If this is not four characters and does not end in a '*',
                //  it is usually the case that the user really wanted a space
                //  at the end of the tag 'Gh1 ', not 'Gh1'.  Make sure they
                //  get a little feedback.
                //

                if (NumChars != sizeof(DWORD)  && SpecialPoolRenderBuffer[NumChars - 1] != '*') {

                    MessageBox( hwnd,
                                "The specified tag is less than 4 characters, but most\n"
                                "are really padded out with spaces.  Please check and\n"
                                "add spaces if neccesary.",
                                "Possibly ambiguous special pool tag",
                                MB_OK );

                }
            }
        }
    }

    if (IsIllegal) {

        MessageBox( hwnd, (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER ? "Must be a hexadecimal DWORD" :
                                                                            "Must be at most 4 characters"),
                    "Illegal characters in special pool tag",
                    MB_OK );
    }

    return !IsIllegal;
}

DWORD
GetSpecialPoolTagItem(
    HWND hwnd
    )
{
    DWORD NumChars;
    DWORD Tag = 0;

    //
    //  We assume that the field is has been retrieved and checked.
    //

    NumChars = strlen( SpecialPoolRenderBuffer );

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            RtlCharToInteger( SpecialPoolRenderBuffer, 16, &Tag );

        } else {

            //
            //  Just drop the bytes into the DWORD - endianess is correct as is.
            //

            RtlCopyMemory( &Tag,
                           SpecialPoolRenderBuffer,
                           NumChars );
        }
    }

    return Tag;
}

DWORD
GetSpecialPoolOverrunsItem(
    HWND hwnd
    )
{
    switch (SpecialPoolOverrunsId) {

        case ID_SPECIAL_POOL_VERIFY_END: return SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
        case ID_SPECIAL_POOL_VERIFY_START: return SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD;

        default: return SPECIAL_POOL_OVERRUNS_CHECK_FORWARD;
    }
}

VOID
ReRenderSpecialPoolTagItem(
    HWND hwnd
    )
{
    DWORD NumChars;
    DWORD Tag = 0;

    //
    //  We assume that the field is has been retrieved and checked.
    //

    NumChars = strlen( SpecialPoolRenderBuffer );

    //
    //  Assume that the dialog contents are of the previous mode. Switch it.
    //

    if (NumChars != 0) {

        if (SpecialPoolModeId == ID_SPECIAL_POOL_IS_NUMBER) {

            RtlCopyMemory( &Tag,
                           SpecialPoolRenderBuffer,
                           NumChars );
            RtlIntegerToChar( Tag, 16, sizeof( SpecialPoolRenderBuffer ), SpecialPoolRenderBuffer);

        } else {

            RtlCharToInteger( SpecialPoolRenderBuffer, 16, &Tag );
            RtlCopyMemory( SpecialPoolRenderBuffer,
                           &Tag,
                           sizeof( Tag ));
            SpecialPoolRenderBuffer[sizeof( Tag )] = '\0';
        }
    }

    SetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer );
}

BOOLEAN
CheckForUnsaved(
    HWND hwnd
    )
{
    BOOL b;

    //
    //  Appropriate to the mode we are leaving, see if there were unsaved changes.
    //  Return TRUE if there are unsaved changes.
    //

    if (GetFlagsFromCheckBoxes() != LastSetFlags ||
           (fFlushImageSettings && (LastRadioButtonId == ID_IMAGE_FILE_OPTIONS)) ||
        (LastRadioButtonId == ID_SYSTEM_REGISTRY &&
         (!CheckSpecialPoolTagItem( hwnd, FALSE ) ||
          (GetSpecialPoolTagItem( hwnd ) != LastSetSpecialPoolTag) ||
          (GetSpecialPoolOverrunsItem( hwnd ) != LastSetSpecialPoolOverruns)) ||
         GetDlgItemInt( hwnd, ID_MAX_STACK_DEPTH, &b, FALSE ) != InitialMaxStackTraceDepth)) {


        if (MessageBox( hwndMain,
                        "You didn't click 'apply' - did you want to discard current changes??",
                        "Warning",
                        MB_YESNO
                        ) == IDNO
            ) {

            return TRUE;
        }
    }

    return FALSE;
}


INT_PTR
APIENTRY
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD NewFlags;
    CHAR ImageFileName[ MAX_PATH ];
    CHAR CommandLine[ MAX_PATH ];
    BOOL b, bCancelDiscard;
    int i;

    bCancelDiscard = FALSE;

    switch (message) {

        case WM_INITDIALOG:

            hwndMain = hwnd;
            LastRadioButtonId = ID_SYSTEM_REGISTRY;
            CheckRadioButton( hwnd,
                ID_SYSTEM_REGISTRY,
                ID_IMAGE_FILE_OPTIONS,
                LastRadioButtonId
                );

            EnableSetOfControls( hwnd, SpecialPool, TRUE );
            EnableSetOfControls( hwnd, Debugger, FALSE );

            SetCheckBoxesFromFlags( GetSystemRegistryFlags(), VALID_SYSTEM_REGISTRY_FLAGS );
            SetDlgItemInt( hwnd, ID_MAX_STACK_DEPTH, InitialMaxStackTraceDepth, FALSE );

            //
            //  Make a not so wild guess about what kind of tag it is.
            //

            if (LastSetSpecialPoolTag && LastSetSpecialPoolTag < 0x2000) {

                SpecialPoolModeId = ID_SPECIAL_POOL_IS_NUMBER;
                RtlIntegerToChar( LastSetSpecialPoolTag,
                    16,
                    sizeof( SpecialPoolRenderBuffer ),
                    SpecialPoolRenderBuffer );
            }
            else {

                SpecialPoolModeId = ID_SPECIAL_POOL_IS_TEXT;
                RtlCopyMemory( SpecialPoolRenderBuffer,
                    &LastSetSpecialPoolTag,
                    sizeof( LastSetSpecialPoolTag ));
                SpecialPoolRenderBuffer[sizeof(LastSetSpecialPoolTag)] = '\0';
            }

            CheckRadioButton( hwnd,
                ID_SPECIAL_POOL_IS_TEXT,
                ID_SPECIAL_POOL_IS_NUMBER,
                SpecialPoolModeId
                );
            SetDlgItemText( hwnd, ID_SPECIAL_POOL_TAG, SpecialPoolRenderBuffer );

            //
            // Initial state for the special pool overrun radio buttons.
            //

            switch (LastSetSpecialPoolOverruns) {

                case SPECIAL_POOL_OVERRUNS_CHECK_FORWARD:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_END;
                    break;

                case SPECIAL_POOL_OVERRUNS_CHECK_BACKWARD:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_START;
                    break;

                default:
                    SpecialPoolOverrunsId = ID_SPECIAL_POOL_VERIFY_END;
                    break;
            }

            CheckRadioButton( hwnd,
                ID_SPECIAL_POOL_VERIFY_START,
                ID_SPECIAL_POOL_VERIFY_END,
                SpecialPoolOverrunsId
                );

            return(TRUE);

        case WM_COMMAND:

            switch ( LOWORD(wParam) ) {

                case ID_LAUNCH:

                    GetDlgItemText( hwnd, ID_COMMAND_LINE, CommandLine, sizeof( CommandLine ) );
                    if (strlen( ImageFileName ) == 0) {
                        MessageBox( hwndMain, "Launch Command Line", "Must fill in command line first", MB_OK );
                        SetFocus( GetDlgItem( hwnd, ID_COMMAND_LINE ) );
                        break;
                    }

                    // fall through

                case ID_APPLY:

                    if (IsDlgButtonChecked( hwnd, ID_SYSTEM_REGISTRY )) {

                        //
                        // System wide settings
                        //

                        if (CheckSpecialPoolTagItem( hwnd, TRUE )) {

                            NewFlags = GetFlagsFromCheckBoxes();

                            SetSystemRegistryFlags(
                                NewFlags,
                                GetDlgItemInt( hwnd, ID_MAX_STACK_DEPTH, &b, FALSE ),
                                GetSpecialPoolTagItem( hwnd ),
                                GetSpecialPoolOverrunsItem (hwnd));
                        }
                    }
                    else if (IsDlgButtonChecked( hwnd, ID_KERNEL_MODE )) {

                        //
                        // Kernel mode settings
                        //
                        // N.B. This will set flags on the fly. It does not touch
                        // the registry and does not require a reboot.
                        //

                        NewFlags = GetFlagsFromCheckBoxes();

                        SetKernelModeFlags( NewFlags );
                    }
                    else if (IsDlgButtonChecked( hwnd, ID_IMAGE_FILE_OPTIONS )) {

                        //
                        // Application specific settings
                        //

                        GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, sizeof( ImageFileName ) );
                        if (strlen( ImageFileName ) == 0) {
                            MessageBox( hwnd, "Missing Image File Name", "Must set image file name", MB_OK );
                            SetFocus( GetDlgItem( hwnd, ID_IMAGE_FILE_NAME ) );
                            break;
                        }

                        SetImageFileNameFlags( ImageFileName, GetFlagsFromCheckBoxes() );
                        if ( fFlushImageSettings ) {

                            GetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, LastDebuggerValue, MAX_PATH );

                            SetImageFileNameDebugger( ImageFileName, LastDebuggerValue );

                            fFlushImageSettings = FALSE ;

                        }
                    }

                    if (LOWORD(wParam) == ID_LAUNCH) {
                        DoLaunch( CommandLine,
                            GetFlagsFromCheckBoxes()
                            );
                    }
                    break;

                case IDOK:
                    if (CheckForUnsaved( hwnd )) {
                        break;
                    }

                    // fall through

                case IDCANCEL:
                    PostQuitMessage(0);
                    DestroyWindow( hwnd );
                    break;

                case ID_SPECIAL_POOL_IS_TEXT:
                case ID_SPECIAL_POOL_IS_NUMBER:

                    if (CheckSpecialPoolTagItem( hwnd, FALSE )) {

                        if (LOWORD(wParam) != SpecialPoolModeId) {

                            SpecialPoolModeId = LOWORD(wParam);
                            CheckRadioButton( hwnd,
                                ID_SPECIAL_POOL_IS_TEXT,
                                ID_SPECIAL_POOL_IS_NUMBER,
                                SpecialPoolModeId
                                );

                            ReRenderSpecialPoolTagItem( hwnd );
                        }
                    }
                    else {

                        //
                        //  Always treat this as a cancel.
                        //

                        bCancelDiscard = TRUE;
                    }

                    break;

                case ID_SPECIAL_POOL_VERIFY_START:
                case ID_SPECIAL_POOL_VERIFY_END:

                    if (LOWORD(wParam) != SpecialPoolOverrunsId) {

                        SpecialPoolOverrunsId = LOWORD(wParam);
                        CheckRadioButton( hwnd,
                            ID_SPECIAL_POOL_VERIFY_START,
                            ID_SPECIAL_POOL_VERIFY_END,
                            SpecialPoolOverrunsId
                            );
                    }

                    break;

                case ID_IMAGE_DEBUGGER_BUTTON:
                    if (IsDlgButtonChecked( hwnd, ID_IMAGE_DEBUGGER_BUTTON ) == BST_CHECKED ) {
                        EnableWindow( GetDlgItem( hwnd, ID_IMAGE_DEBUGGER_VALUE ), TRUE );

                        GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, MAX_PATH );

                        for ( i = 0 ; i < sizeof( SystemProcesses ) / sizeof( PCHAR ) ; i++ ) {
                            if (_stricmp( ImageFileName, SystemProcesses[i] ) == 0 ) {
                                SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, "ntsd -d -g -G" );
                                break;
                            }
                        }

                    }
                    else {
                        SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, "" );
                        EnableWindow( GetDlgItem( hwnd, ID_IMAGE_DEBUGGER_VALUE ), FALSE );
                    }
                    fFlushImageSettings = TRUE ;
                    break;

                case ID_SYSTEM_REGISTRY:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    LastRadioButtonId = ID_SYSTEM_REGISTRY;
                    SetCheckBoxesFromFlags( GetSystemRegistryFlags(), VALID_SYSTEM_REGISTRY_FLAGS );
                    EnableSetOfControls( hwnd, SpecialPool, TRUE );
                    EnableSetOfControls( hwnd, Debugger, FALSE );


                    break;

                case ID_KERNEL_MODE:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    LastRadioButtonId = ID_KERNEL_MODE;
                    SetCheckBoxesFromFlags( GetKernelModeFlags(), VALID_KERNEL_MODE_FLAGS );
                    EnableSetOfControls( hwnd, SpecialPool, FALSE );
                    EnableSetOfControls( hwnd, Debugger, FALSE );

                    break;

                case ID_IMAGE_FILE_OPTIONS:
                    if (CheckForUnsaved( hwnd )) {
                        bCancelDiscard = TRUE;
                        break;
                    }

                    GetDlgItemText( hwnd, ID_IMAGE_FILE_NAME, ImageFileName, sizeof( ImageFileName ) );
                    if (strlen( ImageFileName ) == 0) {
                        MessageBox( hwndMain, "Image File Name Missing", "Must fill in image file name first", MB_OK );
                        CheckRadioButton( hwnd,
                            ID_SYSTEM_REGISTRY,
                            ID_IMAGE_FILE_OPTIONS,
                            LastRadioButtonId
                            );
                        SetCheckBoxesFromFlags( GetSystemRegistryFlags(), VALID_SYSTEM_REGISTRY_FLAGS );
                        SetFocus( GetDlgItem( hwnd, ID_IMAGE_FILE_NAME ) );
                        break;
                    }
                    else {
                        LastRadioButtonId = ID_IMAGE_FILE_OPTIONS;
                        SetCheckBoxesFromFlags( GetImageFileNameFlags( ImageFileName ),
                            VALID_IMAGE_FILE_NAME_FLAGS
                            );

                        if ( GetImageFileNameDebugger( ImageFileName, LastDebuggerValue ) ) {
                            SetDlgItemText( hwnd, ID_IMAGE_DEBUGGER_VALUE, LastDebuggerValue );
                            CheckDlgButton( hwnd, ID_IMAGE_DEBUGGER_BUTTON, 1 );

                        }

                        EnableSetOfControls( hwnd, SpecialPool, FALSE );
                        EnableSetOfControls( hwnd, Debugger, TRUE );

                    }
                    break;

                default:
                    break;
            }
            break;

        case WM_CLOSE:
            PostQuitMessage(0);
            DestroyWindow( hwnd );
            break;

    }

    if (bCancelDiscard) {

        //
        //  Recheck the right radio buttons 'cause the user didn't
        //  *really* mean it.
        //

        CheckRadioButton( hwnd,
            ID_SYSTEM_REGISTRY,
            ID_IMAGE_FILE_OPTIONS,
            LastRadioButtonId
            );
        CheckRadioButton( hwnd,
            ID_SPECIAL_POOL_IS_TEXT,
            ID_SPECIAL_POOL_IS_NUMBER,
            SpecialPoolModeId
            );

        CheckRadioButton( hwnd,
            ID_SPECIAL_POOL_VERIFY_START,
            ID_SPECIAL_POOL_VERIFY_END,
            SpecialPoolOverrunsId
            );

    }

    return 0;
}


BOOL
EnableDebugPrivilege( VOID )
{
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    BYTE                OldPriv[ 1024 ];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    BOOL                fRc;
    LUID                LuidPrivilege;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token
                         )
       ) {
        return FALSE;
        }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &LuidPrivilege );
    NewPrivileges = (PTOKEN_PRIVILEGES)HeapAlloc( GetProcessHeap(), 0,
                                                  sizeof(TOKEN_PRIVILEGES) +
                                                   (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES)
                                                );
    if (NewPrivileges == NULL) {
        CloseHandle( Token );
        return FALSE;
        }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    pbOldPriv = OldPriv;
    fRc = AdjustTokenPrivileges( Token,
                                 FALSE,
                                 NewPrivileges,
                                 sizeof( OldPriv ),
                                 (PTOKEN_PRIVILEGES)pbOldPriv,
                                 &cbNeeded
                               );
    if (!fRc) {
        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            pbOldPriv = (PBYTE)HeapAlloc( GetProcessHeap(), 0, cbNeeded );
            if (pbOldPriv == NULL) {
                CloseHandle( Token );
                return FALSE;
                }

            fRc = AdjustTokenPrivileges( Token,
                                         FALSE,
                                         NewPrivileges,
                                         cbNeeded,
                                         (PTOKEN_PRIVILEGES)pbOldPriv,
                                         &cbNeeded
                                       );
            }
        }

    return fRc;
}

VOID
CenterDialog( HWND hWndDialog )
{
    RECT rectWindow;
    POINT pointCenter;
    POINT pointNewCornerChild;
    INT nChildWidth;
    INT nChildHeight;
    HWND hWndParent;

    hWndParent = GetParent( hWndDialog );

    //
    // parent window's rectangle
    //

    GetWindowRect( hWndParent, &rectWindow );

    //
    // the center, in screen coordinates
    //

    pointCenter.x = rectWindow.left + ( rectWindow.right - rectWindow.left ) / 2;
    pointCenter.y = rectWindow.top + ( rectWindow.bottom - rectWindow.top ) / 2;

    //
    // chils window's rectangle, in screen coordinates
    //

    GetWindowRect( hWndDialog, &rectWindow );

    nChildWidth = rectWindow.right - rectWindow.left ;
    nChildHeight = rectWindow.bottom - rectWindow.top;

    //
    // the new top-left corner of the child
    //

    pointNewCornerChild.x = pointCenter.x - nChildWidth / 2;
    pointNewCornerChild.y = pointCenter.y - nChildHeight / 2;

    //
    // move the child window
    //

    MoveWindow(
        hWndDialog,
        pointNewCornerChild.x,
        pointNewCornerChild.y,
        nChildWidth,
        nChildHeight,
        TRUE );
}


INT_PTR
APIENTRY
PagedHeapDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR nResult;

	nResult = FALSE;

    switch ( message ) {

        case WM_INITDIALOG:
			hwndPagedHeapDlg = hwnd;

            //
            // center this dialog
            //

            CenterDialog( hwndPagedHeapDlg );

			break;

        case WM_COMMAND:
            switch( LOWORD(wParam) ) {
                case IDYES:
                    EndDialog( hwndPagedHeapDlg, IDYES );
                    break;

                case IDNO:
                    EndDialog( hwndPagedHeapDlg, IDNO );
                    break;
            }
            break;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:
            EndDialog(hwndPagedHeapDlg,IDNO);
            nResult = TRUE;
            break;

        default:
            break;
    }

    return nResult;
}

BOOL
OkToEnablePagedHeap( VOID )
{
    MEMORYSTATUS MemoryStatus;

    GlobalMemoryStatus( &MemoryStatus );

    if( MemoryStatus.dwTotalPhys < 512 * 1024 * 1024 ) {

        //
        // less than 512 Mb of RAM
        //

        return ( DialogBoxParam(
                    NULL,
                    (LPCTSTR)( MAKEINTRESOURCE(DID_PAGED_HEAP_WARNING) ),
                    hwndMain,
                    PagedHeapDlgProc,
                    0 ) == IDYES );
    }

    return TRUE;
}


BOOL
GflagsSetTraceDatabaseSize (
    PCHAR ApplicationName,
    ULONG SizeInMb,
    PULONG RealSize
    )
{
    HKEY ImageKey;
    CHAR ImageKeyName[ MAX_PATH ];
    LONG Result;

    CHAR Buffer[ MAX_PATH ];
    DWORD Length = MAX_PATH;
    DWORD TraceDatabaseSize;

    *RealSize = 0;

    if (ApplicationName == NULL) {
        return FALSE;
    }

    sprintf (ImageKeyName,
             "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s",
             ApplicationName);

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                           ImageKeyName, 
                           0, 
                           KEY_QUERY_VALUE | KEY_SET_VALUE, 
                           &ImageKey);

    if (Result != ERROR_SUCCESS) {
        return FALSE;
    }

    if (SizeInMb == 0) {
        
        Result = RegDeleteValue (ImageKey,
                                 "StackTraceDatabaseSizeInMb");

        if (Result != ERROR_SUCCESS) {
            RegCloseKey (ImageKey);
            return FALSE;
        }
    }
    else {

        if (SizeInMb < 8) {
            
            TraceDatabaseSize = 8;
        } 
        else {

            TraceDatabaseSize = SizeInMb;
        }

        Result = RegSetValueEx (ImageKey,
                                "StackTraceDatabaseSizeInMb",
                                0,
                                REG_DWORD,
                                (PBYTE)(&TraceDatabaseSize),
                                sizeof TraceDatabaseSize);

        if (Result != ERROR_SUCCESS) {
            RegCloseKey (ImageKey);
            return FALSE;
        }

        *RealSize = TraceDatabaseSize;
    }

    RegCloseKey (ImageKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gdate.c ===
/*
 * Gutils - 
 *
 * - date conversion functions
 *
 * Geraint, 22 May, 28 Oct 91.
 */

#include "windows.h"
#include "gutils.h"

#include <string.h>

BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
};

/*--public functions--------------------------------------*/

void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
	int years;
	int nleaps;
	int month;
	int mdays;

	/* get number of completed years and calc leap days */
	years = (int) (days / 365);
	days = days % 365;
	nleaps = (years / 4) - (years / 100) + (years / 400);
	while (nleaps > days) {
		days += 365;
		years--;
		nleaps = (years / 4) - (years / 100) + (years / 400);
	}
	days -= nleaps;

	/* add one year for current (non-complete) year */
	years++;


	/* current month */
	for (month = 0; month < 12; month++) {
		mdays = monthdays[month];
		if (gdi_isleap(years) && (month == 1)) {
			mdays++;
		}
		if (days == mdays) {
			days = 0;
			month++;
			break;
		} else if (days < mdays) {
			break;
		} else {
			days -= mdays;
		}
	}
	/* conv month from 0-11 to 1-12 */
	if (monthp != NULL) {
		*monthp = month+1;
	}
	if (dayp != NULL) {
		*dayp = (int) days + 1;
	}
	if (yrp != NULL) {
		*yrp = years;
	}
}


LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
	int nleaps;
	int i;
	long ndays;

	/* exclude the current year */
	yr--;
	nleaps = (yr / 4) - (yr / 100) + (yr / 400);

	/* in any given year, day 0 is jan1 */
	month--;
	day--;
	ndays = 0;
	for (i = 0; i < month ; i++) {
		ndays += monthdays[i];
		if (gdi_isleap(yr+1) && (i == 1)) {
			ndays++;
		}
	}
	ndays = ndays + day + nleaps + (yr * 365L);
	return(ndays);
}

int APIENTRY
gdate_monthdays(int month, int year)
{
	int ndays;

	ndays = monthdays[month - 1];
	if (gdi_isleap(year) && (month == 2)) {
		ndays++;
	}
	return(ndays);
}

int APIENTRY
gdate_weekday(long daynr)
{
	return((int) ((daynr + 1) % 7));
}

/* internal functions-----------------------------------------*/

BOOL
gdi_isleap(LONG year)
{
	if ( ((year % 4) == 0) &&
		(((year % 100) != 0) ||
		((year % 400) == 0))) {
			return TRUE;
	} else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gbit.c ===
/*
 * bitmap allocation routines.
 *
 * utility routines to manage a bit-mapped free list, and find
 * free sections
 */

#include "windows.h"
#include "gutils.h"

#ifdef REWRITE
Timings on windiff indicated that not much time was spent here, so it wasn't
worth the rewrite. BUT - could do much better.  To find the first bit in
a dword mask it with FFFF0000 to see which half the bit is in and then
go on by five binary chops.  (You need to wory about the byte order and bit order
of the bitmap - and I haven't - but the code is something like
bitnum = 0
if (dw&0xffff0000) {bitnum +=16; dw >>=16}
if (dw&0x0000ff00) {bitnum +=8;  dw >>=8}
if (dw&0x000000f0) {bitnum +=4;  dw >>=4}
if (dw&0x0000000c) {bitnum +=2;  dw >>=2}
if (dw&0x00000002) {bitnum +=1;  dw >>=1}

Forget the "find the biggest section" stuff - change the spec and just
return(a place if we find enough it or fail.
Special case to search more efficiently for sections of up to 32 bits.
(For mamory heap usage this means that we will have one heap that handles
requests from (say) 16 to 512 bytes (16 bytes per bit) and another heap
for requests (say) 513 to 4096 bytes (128 bits per byte) and so on.

In this case create a mask in a dword with the number of bits set that
we are looking for (keep this we might need it again), shift it the
number of bits to correspond to the start bit that we found (it's two
dwords by now as it will likely shift across a dword boundary) and then
just mask to see if all those bits are on i.e. if ((mask & dw)==mask)

Later.  Maybe.
Laurie

#endif //REWRITE


/* routines to manage bitmapped freelists. Each map is an array
 * of unsigned longs where bit 0 of the first long represents
 * block 1
 */

BOOL gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set);

/* initialise a pre-allocated map of ulongs to represent a free
* area of nblks
*/
void APIENTRY
gbit_init(DWORD FAR * map, long nblks)
{
	long i;
	long leftover = nblks % 32;
	long blks = nblks / 32;
	DWORD last = 0;

	for (i=0; i < blks; i++) {
		map[i] = 0xffffffff;
	}
	for (i = 0; i < leftover; i++) {
		last = (last << 1) | 1;
	}
	if(leftover)
		map[blks] = last;
}

/* mark a region starting at blknr for nblks, as busy (ie 0) */
BOOL APIENTRY
gbit_alloc(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, FALSE));
}


/* mark region - if op_set, to 1s, otherwise to 0s */
BOOL
gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set)
{
	long first;
	long last;
	long fullwords;
	long startbit, startword;
	long i;
	DWORD dword = 0;

	blknr--;
	first = min(32 - (blknr % 32), nblks);
	nblks -= first;
	last = nblks % 32;
	fullwords = (nblks - last) / 32;
	
	startword = blknr / 32;
	startbit = blknr % 32;
	for (i = 0; i < first; i++) {
		dword = (dword << 1) | 1;
	}
	dword <<= startbit;
	if (op_set) {
		map[startword] |= dword;
		dword = 0xffffffff;
	} else {
		map[startword] &= ~dword;
		dword = 0;
	}
	startword++;
	for (i = 0; i < fullwords; i++) {
		map[startword+i] = dword;
	}
	startword += fullwords;
	for(i = 0, dword = 0; i < last; i++) {
		dword = (dword << 1) | 1;
	}
	if (last) {
		if (op_set) {
			map[startword] |= dword;
		} else {
			map[startword] &= ~dword;
		}
	}

	return(TRUE);
}

/* mark region of nblks starting at blknr to 0s - ie not busy */
BOOL APIENTRY
gbit_free(DWORD FAR * map, long blknr, long nblks)
{
	return(gbit_set(map, blknr, nblks, TRUE));
}


/* find a free segment (ie contiguous sequence of 1s) of nblks in length.
 * If not found, find longest sequence. Store address of segment in *blknr.
 *
 * Return value is nr of blks in sequence found. Region is *not* marked busy.
 */
long APIENTRY
gbit_findfree(DWORD FAR* map, long nblks, long mapsize, long FAR * blknr)
{
	long curblk, startblk, len, i;
	long startbit, nfull, nlast, nbitsleft;
	DWORD mask;
	long mapblks = (mapsize + 31) / 32;
	long aubegin = 0, aulen = 0;
	long curbit = 0;

	/* main loop looking at segments */
	for (curblk = 0; curblk < mapblks; ) {
loop:
		/* loop finding first 1 */
		for (; curblk < mapblks; curblk++, curbit = 0) {
			if (map[curblk] > 0) {
				break;
			}
		}
		if (curblk >= mapblks)
			break;
		
		/* find first 1 in this long */
		startblk = curblk;
		for (mask = 1, i = 0; i < curbit; i++) {
			mask <<= 1;
		}
		for(; curbit < 32; curbit++, mask <<= 1) {
			if (map[curblk] & mask) {
				break;
			}
		}
		if (curbit >= 32) {
			/* abandon this word - start again with next word */
			curblk++;
			curbit = 0;
			goto loop;
		}

		/* we've now found a 1 - calc remaining
		 * bits in this word, complete words etc required.
		 */
		startbit = curbit;
		nbitsleft = min( (32 - curbit), nblks);
		nfull = (nblks - nbitsleft) / 32;
		nlast = (nblks - nbitsleft) % 32;

		/* check for required sequence within this word */

		for (i = 0; i < nbitsleft; i++, curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				/* abandon and start again - start
				 * next pass at curbit in same word
				 */
				/* store free region if longest yet */
				if (i > aulen) {
					aulen = i;
					aubegin = curblk * 32 + startbit +1;
				}
				goto loop;
			}
		}
		
		/* check for nfull full words */
		for (curblk++; curblk <= startblk + nfull; curblk++) {
			if (curblk >= mapblks) {
				/* end of map - abandon here and exit at top
				 * of loop
				 */
				len = nbitsleft +
					((curblk - (startblk + 1)) * 32);
				if (len > aulen) {
					aubegin = startblk * 32 + startbit + 1;
					aulen = len;
				}
				goto loop;
			}
			if (map[curblk] != 0xffffffff) {
				/* not a full word - start again at this bit */
				len = 0;
				curbit = 0;
				for (mask = 1; mask & map[curblk]; mask <<= 1) {
					len++;
					curbit++;
				}
				len += nbitsleft +
					(curblk - (startblk+ 1)) * 32;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				/* continue with current blk, bit */
				goto loop;
			}
		}

		/* left-over bits required in last word */
		mask = 1;
		for (curbit = 0; curbit < nlast;  curbit++, mask <<= 1) {
			if ((map[curblk] & mask) == 0) {
				len = nbitsleft + (nfull * 32);
				len += curbit;
				if (len > aulen) {
					aulen = len;
					aubegin = startblk * 32 + startbit + 1;
				}
				goto loop;
			}
		}
		/* ok - found a block big enough! */
		aubegin = startblk * 32 + startbit + 1;
		*blknr = aubegin;
		return(nblks);
	}

	/* end of map - return longest sequence */
	*blknr = aubegin;
	return(aulen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gfile.c ===
/*
 * File Open/Create dialogs
 *
 */

/*
 * these dialog functions exist because they were written and
 * used before the commmon dialogs existed.
 *
 * they have now been reduced to just calls to the common file dialog
 * functions
 */



/*---includes-----------------------------------------------------------*/
#include "windows.h"
#include "commdlg.h"
#include "gutilsrc.h"
#include "gutils.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

/*--functions----------------------------------------------------------*/

/*
 * gfile_open
 *     	dialog asking the user to select an existing file to open.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	osp    - OFSTRUCT representing file, if successfully open.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully opened,
 *	     for reading and then closed again.
 */

BOOL FAR PASCAL
gfile_open(HWND hwnd, LPSTR prompt, LPSTR ext, LPSTR spec, OFSTRUCT FAR *osp, LPSTR fn)
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH];
    char achPath[MAX_PATH];
    LPSTR chp;
    int fh;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times. remember double null at end of list of strings.
     */
    lstrcpy(achFilters, spec);         // filter + null
    chp = &achFilters[lstrlen(achFilters)+1];      //2nd string just after null
    lstrcpy(chp, spec);            // filter name (+null)
    chp[lstrlen(chp)+1] = '\0';        // double null at end of list

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    achPath[0] = '\0';
    ofn.lpstrFile = achPath;        // we need to get the full path to open
    ofn.nMaxFile = sizeof(achPath);
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_FILEMUSTEXIST |
                OFN_HIDEREADONLY |
                OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can open
     */
    do {
        if (!GetOpenFileName(&ofn)) {
            return(FALSE);
        }

        fh = OpenFile(achPath, osp, OF_READ);

        if (fh == HFILE_ERROR) {
            if (MessageBox(NULL, "File Could Not Be Opened", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == HFILE_ERROR);

    _lclose(fh);

    return(TRUE);
}





/*
 * gfile_new
 *     	dialog asking the user to name a file for writing to.
 *
 * parameters
 *
 *	prompt - message to user indicating purpose of file
 *		 (to be displayed somewhere in dialog box.
 *
 *	ext    - default file extension if user enters file without
 *		 extension.
 *
 *	spec   - default file spec (eg *.*)
 *
 *	osp    - OFSTRUCT representing file, if successfully created.
 *
 *	fn     - buffer where filename (just final element) is returned.
 *
 * returns - true if file selected and exists (tested with OF_EXIST).
 *	     FALSE if dialog cancelled. If user selects a file that we cannot
 *	     open, we complain and restart the dialog.
 *
 *	     if TRUE is returned, the file will have been successfully
 *	     created and opened for writing and then closed again.
 */

BOOL FAR PASCAL
gfile_new(LPSTR prompt, LPSTR ext, LPSTR spec, OFSTRUCT FAR *osp, LPSTR fn)
{
    OPENFILENAME ofn;
    char achFilters[MAX_PATH];
    LPSTR chp;
    char achPath[MAX_PATH];
    int fh;

    /* build filter-pair buffer to contain one pair - the spec filter,
     * twice (one of the pair should be the filter, the second should be
     * the title of the filter - we don't have a title so we use the
     * filter both times. remember double null at end of list of strings.
     */
    lstrcpy(achFilters, spec);         // filter + null
    chp = &achFilters[lstrlen(achFilters)+1];      //2nd string just after null
    lstrcpy(chp, spec);            // filter name (+null)
    chp[lstrlen(chp)+1] = '\0';        // double null at end of list

    /*
     * initialise arguments to dialog proc
     */
    memset(&ofn, 0, sizeof(ofn));
    // GetOpenFileName ang GetSaveFileName unfortunately
    // validate the size of the structue.  So we need to lie to
    // the function if we were built for >=Win2000 and
    // running on an earlier OS
#if (_WIN32_WINNT >= 0x0500) 
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#else
    ofn.lStructSize = sizeof(OPENFILENAME);
#endif
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = achFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;       // first filter pair in list
    achPath[0] = '\0';
    ofn.lpstrFile = achPath;        // we need to get the full path to open
    ofn.nMaxFile = sizeof(achPath);
    ofn.lpstrFileTitle = fn;        // return final elem of name here
    ofn.nMaxFileTitle = 13;     // assume just big enough for 8.3+null
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = prompt;        // dialog title is good place for prompt text
    ofn.Flags = OFN_HIDEREADONLY;
    ofn.lpstrDefExt = ext;

    /*
     * loop until the user cancels, or selects a file that we can create/write
     */
    do {
        if (!GetSaveFileName(&ofn)) {
            return(FALSE);
        }

        fh = OpenFile(achPath, osp, OF_CREATE|OF_READWRITE);

        if (fh == HFILE_ERROR) {
            if (MessageBox(NULL, "File Could Not Be Created", "File Open",
                           MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) {
                return(FALSE);
            }
        }
    } while (fh == HFILE_ERROR);

    _lclose(fh);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gmem.c ===
/*
 * memory utility functions
 *
 * global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces
 * and breaking them up.
 *
 * We get memory allocations in units of ALLOCSIZE and hand out blocks
 * in units of BLKSIZE.  Each allocation has a bitmap (segmap) with one
 * bit per block to track the blocks in the allocation that have been
 * handed out.  All the allocations together are referred to as the heap.
 * The bitmap maps the entire allocation, so the first thing done is to
 * set the bits to say that the header (including the bitmap itself) has
 * already gone.  Each allocation contains a count of the number of free
 * blocks left in it.  This allows us to avoid searching allocations that
 * cannot possibly have enough room.
 *
 * Whenever we hand out some blocks we store the HGLOBAL of that allocation
 * immediately before the bit we hand out.  This means that the HGLOBAL
 * gets stored in a lot of places, but we can always find it from the
 * pointer that the caller has.  (Obviously we add a handle size to the
 * bytes asked for to allow for this).  For historical reasons HGLOBALs are
 * often referred to as seg handles.  The caller knows about the handle to
 * the whole heap.  Only we know about these other handles.
 * All allocations are kept locked.
 *
 * Requests for more than MAXGALLOC bytes are passed on to GlobalAlloc and
 * so have none of this.  Likewise when they are freed.
 *
 * The allocations are chained up so that we can look for free space in all
 * of them - BUT to keep speed
 * 1. we keep track of the number of free blocks in an allocation and
 * only look at the bitmap if it might win.
 * 2. When we fail to find free space and so get a new allocation, we chain
 * it on the front, so we will then normally allocate from this new first block.
 * We only * look further down the chain when the first block fails us.
 *
 * Multithread safe.  An allocation contains a critical section, so
 * multiple simultaneous calls to gmem_get and gmem_free will be
 * protected.
 *
 * gmem_freeall should not be called until all other users have finished
 * with the heap.
 */

#include <windows.h>
#include <memory.h>

#include "gutils.h"
#include "gutilsrc.h"                   /* for string id */
extern HANDLE hLibInst;

/*
 * out-of-memory is not something we regard as normal.
 * - if we cannot allocate memory - we put up an abort-retry-ignore
 * error, and only return from the function if the user selects ignore.
 */

int gmem_panic(void);


/* ensure BLKSIZE is multiple of sizeof(DWORD) */
#define BLKSIZE         16                /* block size in bytes to hand out */
#define ALLOCSIZE       32768             /* allocation size in bytes to get */
#define NBLKS           (ALLOCSIZE / BLKSIZE)            /* blocks per alloc */
#define MAPSIZE         (NBLKS / 8)                /* bytes of bitmap needed */
#define MAPLONGS        (MAPSIZE / sizeof(DWORD)) /* DWORDS of bitmap needed */

/* Macro to convert a request in bytes to a (rounded up) number of blocks */
#define TO_BLKS(x)      (((x) + BLKSIZE - 1) / BLKSIZE)


typedef struct seghdr {
    HANDLE hseg;                       /* The HGLOBAL of this allocation */
    CRITICAL_SECTION critsec;          /* Critsec for this allocation */
    struct seghdr FAR * pnext;         /* Next allocation */
    long nblocks;                      /* num free blocks left in this alloc */
    DWORD segmap[MAPLONGS];            /* The bitmap */
    /* The available storage in an allocation follows immediately */
} SEGHDR, FAR * SEGHDRP;


/* Anything above this size, we alloc directly from global
   This must be smaller than ALLOCSIZE - sizeof(SEGHDR) - sizeof(HANDLE)
*/
#define MAXGALLOC       20000


/*
 * init heap - create first segment.
   Return the locked HGLOBAL of the new, initialised heap or NULL if it fails.
 */
HANDLE APIENTRY
gmem_init(void)
{
    HANDLE hNew;
    SEGHDRP hp;

    /* Try to allocate.  If fails, call gmem_panic.
       If user says IGNORE, return NULL, else go round again.
    */
    do {
        hNew = GlobalAlloc(GHND, ALLOCSIZE);/* moveable and Zero-init */
        if (hNew == NULL) {
            if (gmem_panic() == IDIGNORE) {
                return(NULL);
            }
        }
    } while (hNew == NULL);

    /* Lock it - or return NULL (unexpected) if it won't */
    hp = (SEGHDRP) GlobalLock(hNew);
    if (hp == NULL) {
        GlobalFree(hNew);
        return(NULL);
    }

    hp->hseg = hNew;
    InitializeCriticalSection(&hp->critsec);
    hp->pnext = NULL;
    gbit_init(hp->segmap, NBLKS);
    gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
    hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));

    return(hNew);
} /* gmem_init */


LONG gmemTime = 0;  /* time used in musec */
LONG gmemTot = 0;   /* number of calls */

LONG APIENTRY gmem_time(void)
{  return MulDiv(gmemTime, 1, gmemTot);
}

#ifdef TIMING
LPSTR APIENTRY gmem_get_internal(HANDLE hHeap, int len);

LPSTR APIENTRY
gmem_get(HANDLE hHeap, int len)
{
    LPSTR Ret;
    LARGE_INTEGER time1, time2, freq;
    LONG t1, t2;

    QueryPerformanceFrequency(&freq);
    if (gmemTot==0) {
        char msg[80];
        LONG temp = freq.LowPart;
        wsprintf(msg, "QPF gave %d", temp);
        Trace_Error(NULL, msg, FALSE);
    }
    ++gmemTot;
    QueryPerformanceCounter(&time1);
    Ret = gmem_get_internal(hHeap, len);
    QueryPerformanceCounter(&time2);

    t1 = time1.LowPart;
    t2 = time2.LowPart;
    gmemTime += t2-t1;

    return Ret;
}

#else
/* cause gmem_get_internal to actually be the real gmem_get */
    #define gmem_get_internal gmem_get
#endif


/* Return an LPSTR pointing to room for len bytes.  Try allocatng
   initially from hHeap, but reserve the right to get it from elsewhere.
   Return NULL if it fails.
*/
LPSTR APIENTRY
gmem_get_internal(HANDLE hHeap, int len)
{
    SEGHDRP chainp;
    HANDLE hNew;
    SEGHDRP hp;
    LPSTR chp;
    long nblks;
    long start;
    long nfound;

    chp = NULL;   /* eliminate spurious compiler warning - generate worse code. */

    //{   char msg[80];
    //    wsprintf(msg, "gmem_get %d bytes", len);
    //    Trace_File(msg);
    //}

    /* Zero bytes?  Address zero is an adequate place! */
    if (len < 1) {
        return(NULL);
    }

    /* The heap is always locked (in gmem_init).
       Lock it again to get the pointer then we can safely unlock it.
     */
    chainp = (SEGHDRP) GlobalLock(hHeap);
    GlobalUnlock(hHeap);

    /*
     * Too big to be worth allocing from heap? - get from globalalloc.
     */
    if (len > MAXGALLOC) {
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, len);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        chp = GlobalLock(hNew);
        if (chp == NULL) {
            GlobalFree(hNew);
            return(NULL);
        }

        //{   char msg[80];
        //    wsprintf(msg, " gmem_get direct address ==> %8x", chp);
        //    Trace_File(msg);
        //}
        return(chp);
    }


    /*
     * get critical section during all access to the heap itself
     */
    EnterCriticalSection(&chainp->critsec);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    for (hp = chainp; hp !=NULL; hp = hp->pnext) {
        if (hp->nblocks >= nblks) {
            nfound = gbit_findfree(hp->segmap, nblks,NBLKS, &start);
            if (nfound >= nblks) {
                gbit_alloc(hp->segmap, start, nblks);
                hp->nblocks -= nblks;

                /* convert blocknr to pointer
                 * store seg handle in block
                 * Prepare to return pointer to just after handle.
                 */
                chp = (LPSTR) hp;
                chp = &chp[ (start-1) * BLKSIZE];
                * ( (HANDLE FAR *) chp) = hp->hseg;
                chp += sizeof(HANDLE);

                break;
            }
        }
    }
    if (hp == NULL) {

        // Trace_File("<gmen-get new block>");
        /* Try to allocate.  If fails, call gmem_panic.
           If user says IGNORE, return NULL, else go round again.
        */
        do {
            hNew = GlobalAlloc(GHND, ALLOCSIZE);
            if (hNew == NULL) {
                if (gmem_panic() == IDIGNORE) {
                    LeaveCriticalSection(&chainp->critsec);
                    return(NULL);
                }
            }
        } while (hNew == NULL);

        hp = (SEGHDRP) GlobalLock(hNew);
        if (hp == NULL) {
            LeaveCriticalSection(&chainp->critsec);
            GlobalFree(hNew);
            return(NULL);
        }
        hp->pnext = chainp->pnext;
        hp->hseg = hNew;
        chainp->pnext = hp;
        gbit_init(hp->segmap, NBLKS);
        gbit_alloc(hp->segmap, 1, TO_BLKS(sizeof(SEGHDR)));
        hp->nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR));
        nfound = gbit_findfree(hp->segmap, nblks, NBLKS, &start);
        if (nfound >= nblks) {
            gbit_alloc(hp->segmap, start, nblks);
            hp->nblocks -= nblks;

            /* convert block nr to pointer */
            chp = (LPSTR) hp;
            chp = &chp[ (start-1) * BLKSIZE];
            /* add a handle into the block and skip past */
            * ( (HANDLE FAR *) chp) = hp->hseg;
            chp += sizeof(HANDLE);
        }
    }

    /* ASSERT - by now we MUST have found a block.  chp cannot be garbage.
       This requires that MAXGALLOC is not too large.
    */
    //{   char msg[80];
    //    wsprintf(msg, " gmem_get suballoc address ==> %8x\n", chp);
    //    Trace_File(msg);
    //}


    LeaveCriticalSection(&chainp->critsec);
    memset(chp, 0, len);   /* We ask for ZEROINIT memory, but it could have
                              been already affected by gmem_get; use; gmem_free
                           */
    return(chp);
} /* gmem_get */

void APIENTRY
gmem_free(HANDLE hHeap, LPSTR ptr, int len)
{
    SEGHDRP chainp;
    SEGHDRP hp;
    HANDLE hmem;
    long nblks, blknr;
    LPSTR chp;

    //{   char msg[80];
    //    wsprintf(msg, " gmem_free address ==> %8x, len %d \n", ptr, len);
    //    Trace_File(msg);
    //}

    if (len < 1) {
        return;
    }

    /* In Windiff, things are run on different threads and Exit can result
       in a general cleanup.  It is possible that the creation of stuff is
       in an in-between state at this point.  The dogma is that when we
       allocate a new structure and tie it into a List or whatever that
       will need to be freed later:
       EITHER all pointers within the allocated structure are made NULL
              before it is chained in
       OR the caller of Gmem services undertakes not to try to free any
          garbage pointers that are not yet quite built
       For this reason, if ptr is NULL, we go home peacefully.
    */
    if (ptr==NULL) return;

    /*
     * allocs greater than MAXGALLOC were too big to be worth
     * allocing from the heap - they will have been allocated
     * directly from globalalloc
     */
    if (len > MAXGALLOC) {
        hmem = GlobalHandle( (LPSTR) ptr);
        GlobalUnlock(hmem);
        GlobalFree(hmem);
        return;
    }

    chainp = (SEGHDRP) GlobalLock(hHeap);
    EnterCriticalSection(&chainp->critsec);


    /* just before the ptr we gave the user, is the handle to
     * the block.
     */
    chp = (LPSTR) ptr;
    chp -= sizeof(HANDLE);
    hmem = * ((HANDLE FAR *) chp);
    hp = (SEGHDRP) GlobalLock(hmem);

    nblks = TO_BLKS(len + sizeof(HANDLE));

    /* convert ptr to block nr */
    blknr = TO_BLKS( (unsigned) (chp - (LPSTR) hp) ) + 1;

    gbit_free(hp->segmap, blknr, nblks);
    hp->nblocks += nblks;

    GlobalUnlock(hmem);

    LeaveCriticalSection(&chainp->critsec);
    GlobalUnlock(hHeap);
}

void APIENTRY
gmem_freeall(HANDLE hHeap)
{
    SEGHDRP chainp;
    HANDLE hSeg;

    chainp = (SEGHDRP) GlobalLock(hHeap);
    /* this segment is always locked - so we need to unlock
     * it here as well as below
     */
    GlobalUnlock(hHeap);

    /* finished with the critical section  -
     * caller must ensure that at this point there is no
     * longer any contention
     */
    DeleteCriticalSection(&chainp->critsec);

    while (chainp != NULL) {
        hSeg = chainp->hseg;
        chainp = chainp->pnext;
        GlobalUnlock(hSeg);
        GlobalFree(hSeg);
    }
}

/*
 * a memory allocation attempt has failed. return IDIGNORE to ignore the
 * error and return NULL to the caller, and IDRETRY to retry the allocation
 * attempt.
 */
int
gmem_panic(void)
{
    int code;

    TCHAR szBuff1[MAX_PATH];
    TCHAR szBuff2[MAX_PATH];

    LoadString(hLibInst,
               IDS_MEMORY_ALLOC_FAIL,
               szBuff1,
               sizeof(szBuff1)/sizeof(szBuff1[0]));
    LoadString(hLibInst,
               IDS_OUT_OF_MEMORY,
               szBuff2,
               sizeof(szBuff2)/sizeof(szBuff2[0]));
    code = MessageBox(NULL, szBuff1, szBuff2,
                      MB_ICONSTOP|MB_ABORTRETRYIGNORE);
    if (code == IDABORT) {
        /* abort this whole process */
        ExitProcess(1);
    } else {
        return(code);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gutilsrc.h ===
#define IDC_LPAGENR   102

#define IDC_LFNAME    201
#define IDC_FNAME     202
#define IDC_PROMPT    203
#define IDC_LFILES    204
#define IDC_LSDIR     205
#define IDC_SDIR      206
#define IDC_LDIRS     207
#define IDC_FILES     208
#define IDC_DIRS      209
#define IDC_OPEN      210
#define IDC_CANCEL    211

#define IDD_LABEL     301
#define IDD_FILE      302

#define IDS_MEMORY_ALLOC_FAIL  401
#define IDS_OUT_OF_MEMORY      402
#define IDS_PAGE_STR           403
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\libentry.asm ===
PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           LPSTR  lpszCmdLine);
;        
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        extrn LibMain:far         ; the C routine to be called
	extrn LocalInit:far       ; Windows heap init routine
        extrn __acrtused:abs      ; ensures that Win DLL startup code is linked

        public LibEntry           ; entry point for the DLL

INIT_TEXT segment byte public 'CODE'
        assume cs:INIT_TEXT

LibEntry proc far
        
	push	di		 ; handle of the module instance
        push    ds               ; library data segment
	push	cx		 ; heap size
	push	es		 ; command line segment
	push	si		 ; command line offset

	; if we have some heap then initialize it
	jcxz	callc		 ; jump if no heap specified

	; call the Windows function LocalInit() to set up the heap
	; LocalInit((LPSTR)start, WORD cbHeap);

	push	ds		 ; Heap segment
        xor     ax,ax
	push	ax		 ; Heap start offset in segment
	push	cx		 ; Heap end offset in segment
	call	LocalInit	 ; try to initialize it
	or	ax,ax		 ; did it do it ok ?
	jz	nocall		 ; quit if it failed

	; invoke the C routine to do any special initialization

callc:
	call	LibMain		 ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

nocall:                          ; clean up passed params
        pop     si               ; if LocalInit fails. 
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:
	ret			 ; return the result

LibEntry endp

INIT_TEXT       ends

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\list.h ===
/*----------------------
                   |         List          |
                    ----------------------*/
/* Laurie Griffiths, C version  5/12/91                                */
/* worth also looking at nt\public\sdk\inc\ntrtl.h which also has some
|  low level list pointer chaining stuff in it
*/
/* Note here that Modula-2 style comments (*like this*) are used
   within examples which are already within C comments to indicate
   where comments should go in the examples
*/

/*------------------------------------------------------------------------
| Abstract data type LIST OF (*untyped*) object.
| Different lists can have different types of object in them
| Different items in a list can have different types of object in them.
| The price of this lack of typing is that you have a slightly more
| awkward syntax and you get no help from the compiler if you try to
| put the wrong type of data into the list.
|
| The list is implemented as a collection of items.  Within the item
| somewhere is the object.
|
| Objects are stored UNALIGNED within items.
|
| Use:
|
|   #include <list.h>
|   . . .
|   LIST MyList; (* or LIST liMyList for Hungarians *)
|   . . .
|   MyList = List_Create();
|   List_AddLast(MyList,&MyObject,sizeof(OBJECT));
|
| In the abstract a LIST is a list of objects.  The representation
| is a linked collection of items.  The manner of the linking is
| implementation dependent (as I write this it's linear but when you
| read it it might be a tree (See Knuth for why a tree)).
|
| A LIST is a "handle" for a list which may be thought of as a POINTER
| (whether it is really a pointer or not is implementation dependent)
| so that it can be copied at the risk of creating an alias. e.g.
|
|   L = List_Create();
|   L1 = L;             (* L and L1 are both healthy and empty *)
|   List_AddFirst(L, &elem, sizeof(elem));
|   (* L1 may also appear to have one object, there again it may be sick *)
|   L1 = L;               (* Now they both surely see the one element *)
|   List_Destroy(&L1);    (* L is almost certainly sick now too *)
|   L1 = List_Create();   (* All bets off as to what L is like now
|                            but L1 is empty and healthy
|                         *)
|
| If two handles compare equal then the lists must be equal, but
| unequal handles could address two similar lists i.e. the same list
| of objects held in two different LISTs of items (like pointers).
|
| A LIST can be transferred from one variable to another like this:
|
|   NewList = OldList;           (* copy the handle *)
|   OldList = List_Create();     (* kill the old alias *)
|
| and the Create statement can be omitted if OldList is never touched again.
|
| Items are identified by Cursors.  A cursor is the address of an object
| within an item in the list. i.e. it is the address of the piece of your
| data that you had inserted.  (It is probably NOT the address of the item).
| It is typed as pointer to void here, but you should declare it as a pointer
| to whatever sort of object you are putting in the LIST.
|
| The operations AddFirst, AddLast, AddAfter and AddBefore
| all copy elements by direct assignment.  If an element is itself
| a complex structure (say a tree) then this will only copy a pointer
| or an anchor block or whatever and give all the usual problems of
| aliases.  Clear will make the list empty, but will only free the
| storage that it can "see" directly.  SplitBefore or Split After may
| also perform a Clear operation.  To deal with fancy data structures
| use New rather than Add calls and copy the data yourself
|   e.g.  P = List_NewLast(MyList, sizeof(MyArray[14])*(23-14+1));
|         CopyArraySlice(P, MyArray, 14, 23);
|
| The operations NewFirst, NewLast, NewAfter, NewBefore, First and Last
| all return pointers to elements and thus allow you to do any copying.
| This is how you might copy a whole list of fancy structures:
|
|    void CopyFancyList(LIST * To, LIST From)
|             (* Assumes that To has been Created and is empty *)
|    { PELEMENT Cursor;
|      PELEMENT P;
|
|      List_TRAVERSE(From, Cursor);
|      { P = List_NewLast(To, sizeof(element) );
|        FancyCopy(P, Cursor);    (* Copy so that *Cursor==*P afterwords *)
|      }
|    }
 --------------------------------------------------------------------*/

  typedef struct item_tag FAR * LIST;
  typedef LIST FAR * PLIST;

  void APIENTRY List_Init(void);
  /* MUST BE CALLED BEFORE ANY OF THE OTHER FUNCTIONS. Don't ask, just do it */

  void APIENTRY List_Term(void);
  /* Call at end of application (does some checking and resource freeing) */

  void APIENTRY List_Dump(LPSTR Header, LIST lst);
  /* Dump the internals to current output stream -- debug only */

  void APIENTRY List_Show(LIST lst);
  /* Dump hex representation of handle to current out stream -- debug only */

  LIST APIENTRY List_Create(void);
  /* Create a list.  It will be initially empty */

  void APIENTRY List_Destroy(PLIST plst);
  /* Destroy *plst.  It does not need to be empty first.
  |  All storage directly in the list wil be freed.
  */

  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the beginning of * plst */

  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen);
  /* Return the address of the place for Len bytes of data in a new
  |  item at the start of *plst.
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteFirst(LIST lst);
  /* Delete the first item in lst.  Error if lst is empty */

  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen);
  /* Add an item holding Object to the end of lst */

  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen);
  /* Return the address of the place for uLen bytes of data in a new
  |  item at the end of lst
  |  The storage is zeroed BEFORE chaining it in.
  */

  void APIENTRY List_DeleteLast(LIST lst);
  /* Delete the last item in lst.  Error if lst is empty */

  void APIENTRY List_AddAfter( LIST lst
                    , LPVOID Curs
                    , LPVOID pObject
                    , UINT uLen
                    );
  /*--------------------------------------------------------------------
  | Add an item holding *pObject to lst immediately after Curs.
  | List_AddAfter(lst, NULL, pObject, Len) adds it to the start of the lst
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen);
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately after Curs.
  | List_NewAfter(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new first element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

  void APIENTRY List_AddBefore( LIST lst
                     , LPVOID Curs
                     , LPVOID pObject
                     , UINT uLen
                     );
  /*--------------------------------------------------------------------
  | Add an item holding Object to lst immediately before Curs.
  | List_AddBefore(Lst, NULL, Object, uLen) adds it to the end of the list
   ---------------------------------------------------------------------*/

  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen );
  /*--------------------------------------------------------------------
  | Return the address of the place for uLen bytes of data in a new
  | item immediately before Curs.
  | List_NewBefore(Lst, NULL, uLen) returns a pointer
  | to space for uLen bytes in a new last element.
  | The storage is zeroed BEFORE chaining it in.
   ---------------------------------------------------------------------*/

#if 0
// these functions are not actually defined...

  void APIENTRY List_DeleteAndNext(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Next item */

  void APIENTRY List_DeleteAndPrev(LPVOID * pCurs);
  /* Delete the item that *pCurs identifies and move *pCurs to the Prev item */
#endif

  void APIENTRY List_Delete(LPVOID Curs);
  /*------------------------------------------------------------------
  | Delete the item that Curs identifies.
  | I'm not too sure about this:
  | This will be only a few (maybe as little as 3) machine instructions
  | quicker than DeleteAndNext or DeleteAndPrev but leaves Curs dangling.
  | It is therefore NOT usually to be preferred.
  | It may be useful when you have a function which returns an LPVOID
  | since the argument does not need to be a variable.
  |     Trivial example: List_Delete(List_First(L));
  | I am not sure which is more damaging, a dangling pointer which points
  | at garbage or one that points at something that is real live data.
   -------------------------------------------------------------------*/

  int APIENTRY List_ItemLength(LPVOID Curs);
  /* Return the length of the object identified by the cursor Curs */

  /*------------------------------------------------------------------
  | TRAVERSING THE ULIST
  |
  | LIST lst;
  | object * Curs;
  | . . .
  | Curs = List_First(lst);
  | while (Curs!=NULL)
  | {  DoSomething(*Curs);   (* Curs points to YOUR data not to chain ptrs *)
  |    Curs = List_Next(Curs);
  | }
  |
  | This is identically equal to
  | List_TRAVERSE(lst, Curs)  // note NO SEMI COLON!
  | {  DoSomething(*Curs); }
   -------------------------------------------------------------------*/

  #define List_TRAVERSE(lst, curs)  for(  curs=List_First(lst)            \
                                       ;  curs!=NULL                      \
                                       ;  curs = List_Next((LPVOID)curs)  \
                                       )
  #define List_REVERSETRAVERSE(lst, curs)  for(  curs=List_Last(lst)             \
                                              ;  curs!=NULL                      \
                                              ;  curs = List_Prev((LPVOID)curs)  \
                                              )

  LPVOID APIENTRY List_First(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the first object in lst
  |  If lst is empty then Return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Last(LIST lst);
  /*------------------------------------------------------------------
  | Return the address of the last object in lst
  | If lst is empty then return NULL.
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Next(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
  | List_Next(List_Prev(curs)) is illegal if curs identifies first el
  --------------------------------------------------------------------*/

  LPVOID APIENTRY List_Prev(LPVOID Curs);
  /*------------------------------------------------------------------
  | Return the address of the object after Curs^.
  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
  | List_Prev(List_Next(curs)) is illegal if curs identifies last el
  --------------------------------------------------------------------*/

  /*------------------------------------------------------------------
  |  Whole list operations
   -----------------------------------------------------------------*/
  void APIENTRY List_Clear(LIST lst);
  /* arrange that lst is empty after this */

  BOOL APIENTRY List_IsEmpty(LIST lst);
  /* Return TRUE if and only if lst is empty */

  void APIENTRY List_Join(LIST l1, LIST l2);
  /*-----------------------------------------------------------------------
  | l1 := l1||l2; l2 := empty
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets all the elements of l1 in their original order followed by
  | all the elements of l2 in the order they were in in l2.
  | l2 becomes empty.
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs] || l2 || l1[Curs+1...]; l2 := empty
  | Curs=NULL means insert l2 at the start of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to and including the element
  | that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1
   ------------------------------------------------------------------------*/

  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
  | Curs=NULL means insert l2 at the end of l1
  | The elements themselves are not moved, so pointers to them remain valid.
  |
  | l1 gets the elements of l1 from the start up to but not including the
  | element that Curs points at, in their original order,
  | followed by all the elements that were in l2, in their original order,
  | followed by the rest of l1.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs);
  /*-----------------------------------------------------------------------
  | Let l1 be l1 and l2 be l2
  | Split l2 off from the front of l1:    final l2,l1 = original l1
  |
  | Split l1 into l2: objects of l1 up to and including Curs object
  |               l1: objects of l1 after Curs
  | Any original contents of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
  | The elements themselves are not moved.
   ------------------------------------------------------------------------*/

  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs);
  /*----------------------------------------------------------------------
  | Split l2 off from the back of l1:  final l1,l2 = original l1
  |
  | Split l1 into l1: objects of l1 up to but not including Curs object
  |               l2: objects of l1 from Curs onwards
  | Any original contants of l2 are freed.
  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
  | The elements themselves are not moved.
   -----------------------------------------------------------------------*/

  int APIENTRY List_Card(LIST lst);
  /* Return the number of items in L */

  /*------------------------------------------------------------------
  | Error handling.
  |
  | Each list has within it a flag which indicates whether any illegal
  | operation has been detected (e.g. DeleteFirst when empty).
  | Rather than have a flag on every operation, there is a flag held
  | within the list that can be queried when convenient.  Many operations
  | do not have enough redundancy to allow any meaningful check.  This
  | is a design compromise (for instance to allow P = List_Next(P);
  | rather than P = List_Next(L, P); which is more awkward, especially
  | if L is actually a lengthy phrase).
  |
  | List_IsOK tests this flag (so is a very simple, quick operation).
  | MakeOK sets the flag to TRUE, in other words to accept the current
  | state of the list.
  |
  | It is possible for a list to be damaged (whether or not the flag
  | says OK) for instance by the storage being overwritten.
  |
  | List_Check attempts to verify that the list is sound (for instance where
  | there are both forward and backward pointers they should agree).
  |
  | List_Recover attempts to make a sound list out of whatever debris is left.
  | If the list is damaged, Recover may trap (e.g. address error) but
  | if the list was damaged then ANY operation on it may trap.
  | If Check succeeds without trapping then so will Recover.
   -----------------------------------------------------------------*/

  BOOL APIENTRY List_IsOK(LIST lst);
  /* Check return code */

  void APIENTRY List_MakeOK(LIST lst);
  /* Set return code to good */

  BOOL APIENTRY List_Check(LIST lst);
  /* Attempt to validate the chains */

  void APIENTRY List_Recover(PLIST plst);
  /* Desperate stuff.  Attempt to reconstruct something */

/*------------------------------------------------------------------
|  It is designed to be as easy to USE as possible, consistent
|  only with being an opaque type.
|
|  In particular, the decision to use the address of an object a list cursor
|  means that there is a small amount of extra arithmetic (in the
|  IMPLEMENTATION) in cursor operations (e.g. Next and Prev).
|  and spurious arguments are avoided whenever possible, even though
|  it would allow greater error checking.
|
| Of the "whole list" operations, Clear is given because it seems to be
| a common operation, even though the caller can implement it with almost
| the same efficiency as the List implementation module.
| Join, Split and InsertListXxx cannot be implemented efficiently without
| knowing the representation.
 --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gutils.c ===
#include <windows.h>
#include "gutils.h"
#include "gutilsrc.h"

/* dll global data */
HANDLE hLibInst;
extern void gtab_init(void);
extern BOOL StatusInit(HANDLE);

#ifdef WIN32
BOOL WINAPI LibMain(HANDLE hInstance, DWORD dwReason, LPVOID reserved)
{
        if (dwReason == DLL_PROCESS_ATTACH) {
                hLibInst = hInstance;
                gtab_init();
                StatusInit(hLibInst);
        }
        return(TRUE);
}

#else

WORD wLibDataSeg;


BOOL FAR PASCAL
LibMain(HANDLE hInstance, WORD   wDataSeg, WORD   cbHeap, LPSTR  lpszCmdLine)
{
	hLibInst = hInstance;
	wLibDataSeg = wDataSeg;

	gtab_init();
	StatusInit(hLibInst);
	return(TRUE);

}
#endif

/* needed for win16 - but does no harm in NT */
int FAR PASCAL
WEP (int bSystemExit)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\sockets.c ===
/*************************************************************************************************\
 *
 * SOCKETS.C
 *
 * This file contains routines used for establishing Sockets connections.
 *
\*************************************************************************************************/


#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>
#include "gutils.h"


/* ---- Local variables and #defines ----
 */

WSADATA WSAData;


#define MAX_PENDING_CONNECTS 4  /* The backlog allowed for listen() */

static PCHAR DBG_WSAERRORTEXT = "%s failed at line %d in %s: Error %d\n";

#define WSAERROR(func)  \
//      ERROR(( DBG_WSAERRORTEXT, func, __LINE__, __FILE__, WSAGetLastError() ))



/* Error message macro:
 */
#ifdef SOCKETS
#undef SOCKETS
#endif
#define SOCKETS( args ) DBGMSG( DBG_SOCKETS, args )


/* ---- Local function prototypes ----
 */



/* ---- Function definitions ----
 */

/****************************************************************************\
*
*    FUNCTION:  FillAddr(HWND, PSOCKADDR_IN, LPSTR)
*
*    PURPOSE:  Retrieves the IP address and port number.
*
*    COMMENTS:
*        This function is called in two conditions.
*            1.) When a client is preparing to call connect(), or
*            2.) When a server host is going to call bind(), listen() and
*                accept().
*        In both situations, a SOCKADDR_IN structure is filled.
*        However, different fields are filled depending on the condition.
*
*   ASSUMPTION:
*      bConnect determines if the socket address is being set up for a listen()
*      (bConnect == TRUE) or a connect() (bConnect == FALSE)
*
*
*\***************************************************************************/
BOOL
FillAddr(
    HWND hWnd,
    PSOCKADDR_IN psin,
    LPSTR pServerName
    )
{
   DWORD dwSize;
   PHOSTENT phe;
   char szTemp[200];
   CHAR szBuff[80];

   psin->sin_family = AF_INET;

   /*
   **  If we are setting up for a listen() call (pServerName == NULL),
   **  fill servent with our address.
   */
   if (!pServerName)
   {
      /*
      **  Retrieve my ip address.  Assuming the hosts file in
      **  in %systemroot%/system/drivers/etc/hosts contains my computer name.
      */

      dwSize = sizeof(szBuff);
      GetComputerName(szBuff, &dwSize);
      CharLowerBuff( szBuff, dwSize );

   }

   /* gethostbyname() fails if the remote name is in upper-case characters!
    */
   else
   {
       strcpy( szBuff, pServerName );
       CharLowerBuff( szBuff, strlen( szBuff ) );
   }

   phe = gethostbyname(szBuff);
   if (phe == NULL) {

      wsprintf( szTemp, "%d is the error. Make sure '%s' is"
                " listed in the hosts file.", WSAGetLastError(), szBuff );
      MessageBox(hWnd, szTemp, "gethostbyname() failed.", MB_OK);
      return FALSE;
   }

   memcpy((char FAR *)&(psin->sin_addr), phe->h_addr, phe->h_length);

   return TRUE;
}



/* SocketConnect
 *
 * The counterpart to SocketListen.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then connects to a listening server.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN dest_sin;  /* DESTination Socket INternet */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    if (!FillAddr( NULL, &dest_sin, pstrServerName ) )
    {
        return FALSE;
    }

    dest_sin.sin_port = htons( TCPPort );

    /* Someone must be listen()ing for this to succeed:
     */
    if (connect( Socket, (PSOCKADDR)&dest_sin, sizeof( dest_sin)) == SOCKET_ERROR)
    {
        closesocket( Socket );
        WSAERROR("connect()");
        MessageBox(NULL,
                   "ERROR: Could not connect the socket. "
                     "It may be that the hardcoded Sleep() value "
                     "on the caller's side is not long enough.",
                   "Video Conferencing Prototype", MB_OK);
        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}



/* SocketListen
 *
 * The counterpart to SocketConnect.
 * Creates a socket and initializes it with the supplied TCP/IP
 * port address, then listens for a connecting client.
 * The returned socket can be used to send() and recv() data.
 *
 * Parameters: TCPPort - The port to use.
 *             pSocket - A pointer to a SOCKET, which will be filled in
 *                 if the call succeeds.
 *
 * Returns:    TRUE if successful.
 *
 *
 * Created 16 November 1993 (andrewbe)
 *
 */
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket )
{
    SOCKET Socket;
    SOCKADDR_IN local_sin;  /* Local socket - internet style */
    SOCKADDR_IN acc_sin;    /* Accept socket address - internet style */
    int acc_sin_len;        /* Accept socket address length */

    /* Create a socket:
     */
    Socket = socket( AF_INET, SOCK_STREAM, 0);

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "socket()");

        return FALSE;
    }

    /*
    **  Retrieve the IP address and TCP Port number
    */

    if (!FillAddr(NULL, &local_sin, NULL ))
    {
        return FALSE;
    }

    /*
    **  Associate an address with a socket. (bind)
    */
    local_sin.sin_port = htons( TCPPort );

    if (bind( Socket, (struct sockaddr FAR *)&local_sin, sizeof(local_sin)) == SOCKET_ERROR)
    {
        WSAERROR( "bind()" );

        return FALSE;
    }


    if (listen( Socket, MAX_PENDING_CONNECTS ) == SOCKET_ERROR)
    {
        WSAERROR( "listen()" );

        return FALSE;
    }

    acc_sin_len = sizeof(acc_sin);

    Socket = accept( Socket, (struct sockaddr *)&acc_sin, (int *)&acc_sin_len );

    if (Socket == INVALID_SOCKET)
    {
        WSAERROR( "accept()" );

        return FALSE;
    }

    *pSocket = Socket;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\list.c ===
/* Laurie Griffiths C version 05/12/91 */
/* Storage allocation scheme customised */

#include <memory.h>
#include <windows.h>
#include "gutils.h"
#include "list.h"
#include <stdio.h>

// use the standard Trace_Error function, but we have no
// parent window to pass for these errors.
#define TRACE_ERROR(a, b)	Trace_Error(NULL, a, b)


char msg[80];  /* a temp for building up snprintf messages in */

/* Under windows, malloc and GlobalAlloc each seem to give about the
** same number of allocations before they run out of steam, and on my
** laptop it's only about 1600 odd, despite 3M of memory.  Furthermore,
** the number doesn't change much if you allocate in lumps of 30 bytes or
** 1500 bytes.  Alas, it looks as though (one more time, one more operating
** system) we get to do our own allocation scheme.  Sigh.  When will they
** ever learn.
** So we need a List_Init function and a List_Term function.
** In between, we have a current block which is a K or two long and we
** allocate storage from inside it unless there's no room, in which case
** we move onto the next block.  We retain a count of the number of
** allocations within a block.  We make no attempt to reclaim storage
** until the whole block's free (count gone back to 0), then we free it.
** The block holds its handle.  Individual allocations hold a pointer
** to the block start.
**
** Purely for checking purposes, the blocks are all chained together.
** List_Term (which has no function other than checking) checks that
** this chain is empty.  Apart from this we do not keep track of the
** allocations. We just hand them out and let the calling program keep track.
*/
#define BLOCKSIZE 25000
typedef struct blockTag {
    struct blockTag * PrevBlock; /* backward link (NULL terminated doubly linked chain of blocks) */
    struct blockTag * NextBlock; /* forward link (pCurrent points to last in chain) */
    HANDLE hMem;     /* memory handle for this block */
    int iInUse;      /* number of allocations taken out of it.  0 => free it */
    SIZE_T iNext;       /* next byte to use */
    char chData[BLOCKSIZE];
} BLOCK, *PBLOCK;

CRITICAL_SECTION CritSec;  /* to protect pCurrent */

PBLOCK pCurrent = NULL;  /* block currently in use */
/* must always be either NULL or valid */

/* Allocate storage for List elements.  n.b. after a call to this
   you MUST record the value of pCurrent as you need to hand that in
   to Free.  You don't hand in the value of the actual storage.
   See screed above.
   This function Enters the critical section.  The caller must Leave it.
*/
LPVOID
list_Alloc(
          SIZE_T size
          )
{
    HANDLE hMem;
    LPVOID pRet;
    PBLOCK pb;
    EnterCriticalSection(&CritSec);
    if ((pCurrent==NULL)||(pCurrent->iNext+size>BLOCKSIZE+1)) {
        hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT,(DWORD)(sizeof(BLOCK)));
        if (hMem==NULL) {pCurrent = NULL;
            OutputDebugString("GlobalAlloc failed!!\n");
            return NULL;
        }
        pb = pCurrent;
        pCurrent = (PBLOCK)GlobalLock(hMem);
        if (pCurrent==NULL) {OutputDebugString("GlobalLock failed!!\n");
            return NULL;
        }
        pCurrent->PrevBlock = pb;
        pCurrent->NextBlock = NULL;
        pCurrent->hMem = hMem;
        pCurrent->iInUse = 0;
        pCurrent->iNext = 0;
        if (pb==NULL)
            ;
        else
            pb->NextBlock = pCurrent;
    }
    pRet = &(pCurrent->chData[pCurrent->iNext]);
    ++(pCurrent->iInUse);
    pCurrent->iNext += size;

    /* for MIPS we must also ensure that the data is aligned 4 byte*/
    pCurrent->iNext = ((pCurrent->iNext + (sizeof(void *)-1)) & ~(sizeof(void *) - 1));

    return pRet;
}

void
list_Free(
         PBLOCK pBlock,
         LPVOID p
         )
{
    HANDLE hMem;
    EnterCriticalSection(&CritSec);
    --pBlock->iInUse;
    if (pBlock->iInUse<=0) {if (pBlock->iInUse<0) {_snprintf(msg,sizeof(msg),"Bug in List code. Tell LaurieGr!\nList block allocation negative (%d)", pBlock->iInUse);
            TRACE_ERROR(msg, FALSE);
        }
        if (pCurrent==pBlock) pCurrent = pBlock->PrevBlock; /* defend the invariant */
        /* loop it out of the chain */
        if (pBlock->PrevBlock!=NULL) pBlock->PrevBlock->NextBlock = pBlock->NextBlock;
        if (pBlock->NextBlock!=NULL) pBlock->NextBlock->PrevBlock = pBlock->PrevBlock;
        hMem = pBlock->hMem;
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    LeaveCriticalSection(&CritSec);
}



/* The following definition tells the truth about what an ITEM is.  The
|  header file says only that there's a structure with the tag item_tag and
|  that a LIST is a pointer to one.  Here we spell out what that structure
|  is (and a LIST is still a pointer to one).  A PLIST is defined as a
|  pointer to one of those, but is only really used because the C
|  parameter mechanism demands an extra level of indirection for a
|  parameter that can be updated.  (Modula-2 VAR parameter).
*/
typedef struct item_tag {
    struct item_tag *pitNext;    /* to next in circular list */
    struct item_tag *pitPrev;    /* to prev in circular list */
    PBLOCK pBlock;               /* to memory block */
    BOOL bAnchor;                /* TRUE iff an anchor block */
    BOOL bOK;                    /* true unless a list op has failed */
    int iLen;                    /* length of data only */
    char *Data[1];               /* the caller's data.  The '1' is a lie */
} ITEM;

/* For an anchor block, only the fields pitNext thru bAnchor are allocated.
|  For a normal list element, Data may well be longer than 1 byte.
|  The bOK flag is to support a style of programming where several
|  successive operations can be done without having to check the return
|  code at each stage.  At the end, the list can be examined to see if
|  the data in it is valid or if it has been made invalid by the failure
|  of any of the previous operations.  Certain operations may result in
|  having no list at all if they fail (e.g. create) and for these, you'd
|  better check the result at once!
|  ??? Some of this screed belongs in the header!!!
*/

static SIZE_T iAnchorSize;      /* Size of anchor block (no data, no dummy) */
static SIZE_T iHeaderSize;      /* Size of data block not counting Data
                                and offset from cursor back to item.
                             */
static BOOL bInited = FALSE; /* TRUE <=> iAnchorSize and iHeaderSize are OK*/

#define MOVEBACK(Curs)                                               \
   { Curs = ((char *)Curs-iHeaderSize); } /*move from Data to pitNext*/

/*==================================================================
|| Lists are circular, doubly linked with an anchor block which holds
|| pointers to both ends.  Every block has a flag which shows whether
|| it's an anchor or not.
||
|| Empty list:
||
||      -------------
||     |             |
||     |   Anchor    |
||     v   -------   |
||  Ul--->| Next--+--|
||        |-------|  |
||        | Prev--+--
||         -------
||
|| One entry list:
||
||      ------------------------------------
||     |                                    |
||     |   Anchor                           |
||     v   -------                ------    |
||  Ul--->| Next--+------------->| Next-+---|
||        |-------|    |         |------|   |
||        | Prev--+----          | Prev-+---
||         -------               |------|
||                               | Len  |
||                               |------|
||                               | Data |
||                                ------
|| Two entry list:
||
||      -------------------------------------------------
||     | ---------------    ---------------              |
||     ||               |  |               |             |
||     ||  Anchor       |  |               |             |
||     vv  --------     |  v    ------     |    ------   |
||  Ul--->| Next--+-----+----->| Next-+----+-->| Next-+--
||        |-------|     |      |------|  | |   |------|
||        | Prev--+--    ------+-Prev |  |  ---+-Prev |
||         -------   |         |------|  |     |------|
||                   |         | Len  |  |     | Len  |
||                   |         |------|  |     |------|<----Cursor
||                   |         | Data |  |     | Data |
||                   |          ------   |      ------
||                   |                   |
||                    -------------------
||
|| etc.
||
|| Note that an external cursor (i.e one which is seen by the caller)
|| points to the Data field, not to the start of the structure.
|| This allows easy access to the data by the user at the cost of a
|| slightly slower traverse.
|| Within this module, we may sometimes traverse a list with  a cursor
|| that points to the start of an item.  This is called an item cursor.
===================================================================*/

/*------------------------------------------------------------------
| Set iAnchorSize and iHeaderSize.  Implementation independent!
 -------------------------------------------------------------------*/
void
APIENTRY
List_Init(
         void
         )
{
    LIST P;
    P = (LIST)&P;                  /* really any old address will do */
    iAnchorSize = (char *)&(P->iLen) - (char *)&(P->pitNext);
    iHeaderSize = (char *)&(P->Data) - (char *)&(P->pitNext);
    InitializeCriticalSection(&CritSec);
    /* assumes layout in storage is linear */
}


void
APIENTRY
List_Term(
         void
         )
{
    if (pCurrent!=NULL)
        TRACE_ERROR("List storage not cleared out properly", FALSE);
}



/* Dump the internals to the debugger. */
void
APIENTRY
List_Dump(
         LPSTR Header,
         LIST lst
         )
{
    LIST pit;
    char msg[250];

    OutputDebugString(Header);  OutputDebugString("\n");
    pit = lst;
    do {
        _snprintf(msg,sizeof(msg), "%8p %8p %8p %ld %s "
                 , pit, pit->pitNext, pit->pitPrev, pit->iLen
                 , (pit->bAnchor ? "Anchor" : "Data")
                );
        OutputDebugString(msg);
        if (pit->pitNext->pitPrev != pit)
            OutputDebugString(" Next Prev error!!");
        if (pit->pitPrev->pitNext != pit)
            OutputDebugString(" Prev Next error!!");
        OutputDebugString("\n");
        pit = pit->pitNext;
    } while (pit!=lst);
    OutputDebugString("End of list dump\n");
}

/* Dump hex representation of handle to debugger */
void
APIENTRY
List_Show(
         LIST lst
         )
{
    char msg[50];
    _snprintf(msg, sizeof(msg), "%p", lst);
    OutputDebugString(msg);
}

/*------------------------------------------------------------------
| Create a list.  It will be initially empty
 -------------------------------------------------------------------*/
LIST
APIENTRY
List_Create(
           void
           )
{
    LIST lst;
    if (!bInited) {
        List_Init();            /* prevent some strange errors */
    }
    lst = list_Alloc(iAnchorSize);

    if (lst==NULL) {
        return NULL;
    }
    lst->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
    lst->bAnchor = TRUE;
    /* no length field set in an anchor block */
    return lst;
}

/*------------------------------------------------------------------
| Destroy *plst.  It does not need to be empty first
 -------------------------------------------------------------------*/
void
APIENTRY
List_Destroy(
            PLIST plst
            )
{
    LIST pitP;    /* item cursor on * plst */
    LIST pitQ;    /* item cursor runs one step ahead of pitQ */

    if (plst==NULL) {
        TRACE_ERROR("Bug:Attempt to destroy NULL list.  Continuing...", FALSE);
        return;
    }

    /* There is at least an anchor block to destroy */
    pitP = *plst;
    do {
        pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }while (pitP != *plst);
    *plst = NULL;
}

/*------------------------------------------------------------------
| Add an item holding Object to the beginning of * plst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddFirst(
             LIST lst,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pit;      /* newly allocated item */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddFirst to bogus list.  Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for Len bytes of data in a new
| item at the start of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewFirst(
             LIST lst,
             UINT uLen
             )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewFirst to bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitPrev = lst;
    pit->pitNext = lst->pitNext;
    lst->pitNext->pitPrev = pit; /* for empty list that set lst->pitPrev */
    lst->pitNext = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the first item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteFirst(
                LIST lst
                )
{
    LIST pit;

    if (lst==NULL) {TRACE_ERROR("Bug: List_DeleteFirst from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitNext;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*------------------------------------------------------------------
| Add an item holding Object to the end of lst
 -------------------------------------------------------------------*/
void
APIENTRY
List_AddLast(
            LIST lst,
            LPVOID pObject,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddLast to bogus list. Continuing...", FALSE);
        return;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    memcpy( &(pit->Data), pObject, uLen );
}

/*------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
|  item at the end of lst
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewLast(
            LIST lst,
            UINT uLen
            )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewLast in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    pit = list_Alloc(iHeaderSize+uLen);
    if (pit==NULL) {
        lst->bOK = FALSE;
        return NULL;
    }
    pit->pBlock = pCurrent;
    LeaveCriticalSection(&CritSec);
    pit->iLen = uLen;
    pit->pitNext = lst;
    pit->pitPrev = lst->pitPrev;
    lst->pitPrev->pitNext = pit; /* for empty list that set lst->pitNext */
    lst->pitPrev = pit;
    pit->bAnchor = FALSE;
    return (char *)&(pit->Data);
}

/*------------------------------------------------------------------
| Delete the last item in lst.  Error if lst is empty
 -------------------------------------------------------------------*/
void
APIENTRY
List_DeleteLast(
               LIST lst
               )
{
    LIST pit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_DeleteLast from bogus list.  Continuing...", FALSE);
        return;
    }
    /* attempting to delete the anchor block! */
    if (lst->pitNext==lst) {
        lst->bOK = FALSE;
    } else {
        pit = lst->pitPrev;
        pit->pitNext->pitPrev = pit->pitPrev;
        pit->pitPrev->pitNext = pit->pitNext;
        list_Free(pit->pBlock, pit);
    }
}

/*--------------------------------------------------------------------
| Add an item holding * pObject to lst immediately after Curs.
| List_AddAfter(lst,NULL,pObject,Len) adds it to the start of the lst
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddAfter(
             LIST lst,
             LPVOID Curs,
             LPVOID pObject,
             UINT uLen
             )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddAfter in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddFirst(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately after Curs.
| List_NewAfter(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new first element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewAfter(
              LIST lst,
              LPVOID Curs,
              UINT uLen
              )
{
    LIST pitNew;
    LIST pitAfter;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewAfter in bogus list. Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewFirst(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitAfter = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitPrev = pitAfter;
        pitNew->pitNext = pitAfter->pitNext;
        pitAfter->pitNext->pitPrev = pitNew;
        pitAfter->pitNext = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *)&(pitNew->Data);
    }
}

/*--------------------------------------------------------------------
| Add an item holding Object to lst immediately before Curs.
| List_AddBefore(Lst,NULL,Object,uLen) adds it to the end of the list
 ---------------------------------------------------------------------*/
void
APIENTRY
List_AddBefore(
               LIST lst,
               LPVOID Curs,
               LPVOID pObject,
               UINT uLen
                            )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_AddBefore in bogus list.  Continuing...", FALSE);
        return;
    }
    if (Curs==NULL) {
        List_AddLast(lst, pObject, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        memcpy( &(pitNew->Data), pObject, uLen );
    }
}

/*--------------------------------------------------------------------
| Return the address of the place for uLen bytes of data in a new
| item immediately before Curs.
| List_NewBefore(Lst,NULL,uLen) returns a pointer
| to space for uLen bytes in a new last element.
 ---------------------------------------------------------------------*/
LPVOID
APIENTRY
List_NewBefore(
               LIST lst,
               LPVOID Curs,
               UINT uLen
               )
{
    LIST pitNew;
    LIST pitBefore;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_NewBefore in bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (Curs==NULL) {
        return List_NewLast(lst, uLen);
    } else {
        MOVEBACK(Curs);
        pitBefore = (LIST)Curs;
        pitNew = list_Alloc(iHeaderSize+uLen);
        if (pitNew==NULL) {
            lst->bOK = FALSE;
            return NULL;
        }
        pitNew->pBlock = pCurrent;
        LeaveCriticalSection(&CritSec);
        pitNew->iLen = uLen;
        pitNew->pitNext = pitBefore;
        pitNew->pitPrev = pitBefore->pitPrev;
        pitBefore->pitPrev->pitNext = pitNew;
        pitBefore->pitPrev = pitNew;
        pitNew->bAnchor = FALSE;
        return (char *) &(pitNew->Data);
    }
}

/*------------------------------------------------------------------
| Delete the item that Curs identifies.
| This will be only a few (maybe as little as 3) machine instructions
| quicker than DeleteForwards or DeleteBackwards but leaves Curs dangling.
| It is therefore NOT usually to be preferred.
| It may be useful when you have a function which returns an LPVOID
| since the argument does not need to be a variable.
|     Trivial example: List_Delete(List_First(L));
 -------------------------------------------------------------------*/
void
APIENTRY
List_Delete(
            LPVOID Curs
            )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Delete NULL item", FALSE);
        return;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit->pitNext->pitPrev = pit->pitPrev;
    pit->pitPrev->pitNext = pit->pitNext;
    list_Free(pit->pBlock, pit);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the next item (NULL if already on last)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteForwards(
                    LPVOID Curs
                    )
{
    LIST pitDel;  /* the item to delete */
    LIST pitN;    /* the item after (could be anchor) */
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_DeleteForwards NULL cursor. Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitN = pitDel->pitNext;

    pitN->pitPrev = pitDel->pitPrev;
    pitDel->pitPrev->pitNext = pitN;
    list_Free(pitDel->pBlock, pitDel);
    if (pitN->bAnchor)
        return NULL;
    else
        return (char *)&(pitN->Data);
}

/*-----------------------------------------------------------------------
| Delete the item that Curs identifies and return a cursor that
| identifies the previous item (NULL if already on first)
 ------------------------------------------------------------------------*/
LPVOID
APIENTRY
List_DeleteBackwards(
                     LPVOID Curs
                     )
{
    LIST pitDel;  /* the one to delete */
    LIST pitB;    /* the one before */

    if (Curs==NULL) {
        TRACE_ERROR("List_DeleteBackwards NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pitDel = (LIST)Curs;
    pitB = pitDel->pitPrev;
    pitDel->pitNext->pitPrev = pitB;
    pitB->pitNext = pitDel->pitNext;
    list_Free(pitDel->pBlock, pitDel);
    if (pitB->bAnchor)
        return NULL;
    else
        return (char *)&(pitB->Data);
}

/*-------------------------------------------------------------------
| Return the length of the object identified by the cursor Curs
 -------------------------------------------------------------------*/
int
APIENTRY
List_ItemLength(
                LPVOID Curs
                )
{
    LIST pit;
    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_ItemLength NULL cursor.  Continuing...", FALSE);
        return 0;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    return pit->iLen;
}

/*------------------------------------------------------------------
| Return the address of the first object in lst
|  If lst is empty then Return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_First(
           LIST lst
           )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_First of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitNext->Data);
}

/*------------------------------------------------------------------
| Return the address of the last object in lst
| If lst is empty then return NULL.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Last(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Last of bogus list.  Continuing...", FALSE);
        return NULL;
    }
    if (lst->pitNext==lst) {
        return NULL;
    }
    return &(lst->pitPrev->Data);
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Next(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Next of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitNext;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*------------------------------------------------------------------
| Return the address of the object after Curs^.
| List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error.
 -------------------------------------------------------------------*/
LPVOID
APIENTRY
List_Prev(
          LPVOID Curs
          )
{
    LIST pit;

    if (Curs==NULL) {
        TRACE_ERROR("Bug: List_Prev of NULL cursor.  Continuing...", FALSE);
        return NULL;
    }
    MOVEBACK(Curs)
    pit = (LIST)Curs;
    pit = pit->pitPrev;
    if (pit->bAnchor) {
        return NULL;
    } else {
        return &(pit->Data);
    }
}

/*-------------------------------------------------------------------
| Arrange that lst is empty after this call
 --------------------------------------------------------------------*/
void
APIENTRY
List_Clear(
           LIST lst
           )
{
    LIST pitP;   /* item cursor on List, points to element starts */
    LIST pitQ;   /* runs one step ahead of pitP                   */

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Clear of bogus list.  Continuing...", FALSE);
        return;
    }
    pitP = lst->pitNext;   /* first element of list proper */
    while (pitP!=lst) {      /* while not wrapped onto anchor */pitQ = pitP->pitNext;
        list_Free(pitP->pBlock, pitP);
        pitP = pitQ;
    }
    lst->bOK = TRUE;
    lst->pitNext = lst;
    lst->pitPrev = lst;
}

/*---------------------------------------------------------------------
| Return TRUE if and only if lst is empty
 ----------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsEmpty(
             LIST lst
             )
{  if (lst==NULL) {TRACE_ERROR("Bug: List_IsEmpty of bogus list.  Continuing...", FALSE);
        return TRUE;   /* well it's sort of true isn't it? */
    }
    return lst->pitNext ==lst;
} /* List_IsEmpty */

/*------------------------------------------------------------------
| l1 had better be empty.  l1 then acquires all the elements from l2
 -------------------------------------------------------------------*/
void
APIENTRY
SwitchLists(
            LIST l1,
            LIST l2
            )
{
    /* connect l1 to l2's elements, l1 had better be initially empty */
    l1->pitPrev = l2->pitPrev;
    l1->pitNext = l2->pitNext;
    /* connect the elements to l1 anchor block. */
    l1->pitPrev->pitNext = l1;
    l1->pitNext->pitPrev = l1;
    /* make l2 empty */
    l2->pitPrev = l2;
    l2->pitNext = l2;
}

/*-----------------------------------------------------------------------
| l1 := l1||l2; l2 := empty
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets all the elements of l1 in their original order followed by
| all the elements of l2 in the order they were in in l2.
| l2 becomes empty.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_Join(
          LIST l1,
          LIST l2
          )
{
    if ((l1==NULL)||(l2==NULL)) {
        TRACE_ERROR("Bug: List_Join of bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK &&l2->bOK;  /* result OK if both inputs OK */
    l2->bOK = TRUE;               /* as l2 always becomes empty */
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if (l2->pitNext==l2) {
        SwitchLists(l1,l2);
        return;
    } else {
        l2->pitNext->pitPrev = l1->pitPrev;
        l1->pitPrev->pitNext = l2->pitNext;
        l1->pitPrev = l2->pitPrev;
        l1->pitPrev->pitNext = l1;
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}

/*-----------------------------------------------------------------------
| Let L1 be *pl1 and L2 be *pl2
| L1 := L1[...Curs] || L2 || L1[Curs+1...]; L2 := empty
| Curs=NULL means insert L2 at the start of L1
| The elements themselves are not moved, so pointers to them remain valid.
|
| L1 gets the elements of L1 from the start up to and including the element
| that Curs points at, in their original order,
| followed by all the elements that were in L2, in their original order,
| followed by the rest of L1
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListAfter(
                     LIST l1,
                     LIST l2,
                     LPVOID Curs
                     )
{
    LIST pitA;     /* The element after Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                   |  or the anchor block if Curs==NULL
                   */

    if ( (l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListAfter with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no elements need moving */
    } else if ( l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }
        /* pit points to a block to insert after, could be anchor */
        pitA = pit->pitNext;           /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pit;    /*  P<-- elems-of-l2    A */
        l2->pitPrev->pitNext = pitA;   /*  P<-- elems-of-l2 -->A */
        pit->pitNext = l2->pitNext;    /*  P<-->elems-of-l2 -->A */
        pitA->pitPrev = l2->pitPrev;   /*  P<-->elems-of-l2<-->A */

        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty
| Curs=NULL means insert l2 at the end of l1
| The elements themselves are not moved, so pointers to them remain valid.
|
| l1 gets the elements of l1 from the start up to but not including the
| element that Curs points at, in their original order,
| followed by all the elements that were in l2, in their original order,
| followed by the rest of l1.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_InsertListBefore(
                      LIST l1,
                      LIST l2,
                      LPVOID Curs
                      )
{
    LIST pitB;     /* The element before Curs, could be anchor */
    LIST pit;      /* The start of the element that Curs points at
                    |  or the anchor block if Curs==NULL
                    */

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_InsertListBefore with bogus list.  Continuing...", FALSE);
        return;
    }
    l1->bOK = l1->bOK && l2->bOK;
    l2 ->bOK = TRUE;
    if (l2->pitNext==l2) {
        /* no action needed */
    } else if (l1->pitNext==l1) {
        /* the easy way to code this would be simply to switch the two
        |  pointers l1 and l2, but they are value parameters and we don't
        |  want to change that.
        */
        SwitchLists(l1,l2);
        return;
    } else {
        if (Curs==NULL) {
            pit = l1;
        } else {
            MOVEBACK(Curs)
            pit = (LIST)Curs;
        }

        /* P points to a block to insert before, could be anchor */
        pitB = pit->pitPrev;       /* Cannot be same as P, already checked */
        l2->pitNext->pitPrev = pitB; /*  B<-- elems-of-L2    P */
        l2->pitPrev->pitNext = pit;  /*  B<-- elems-of-L2 -->P */
        pitB->pitNext = l2->pitNext; /*  B<-->elems-of-L2 -->P */
        pit->pitPrev = l2->pitPrev;  /*  B<-->elems-of-L2<-->P */
        l2->pitNext = l2;
        l2->pitPrev = l2;
    }
}


/*-----------------------------------------------------------------------
| Let l1 be l1 and l2 be l2
| Split l2 off from the front of l1:    final l2,l1 = original l1
|
| Split l1 into l2: objects of l1 up to and including Curs object
|               l1: objects of l1 after Curs
| Any original contents of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all.
| The elements themselves are not moved.
 ------------------------------------------------------------------------*/
void
APIENTRY
List_SplitAfter(
                LIST l1,
                LIST l2,
                LPVOID Curs
                )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitAfter bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    };
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in l1! l2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitNext==l1) {
            /* transfer whole of l2 to l1 */
            SwitchLists(l2,l1);
            return;
        }
        l2->pitPrev = pit;
        l2->pitNext = l1->pitNext;
        l1->pitNext = pit->pitNext;
        pit->pitNext = l2;
        l2->pitNext->pitPrev = l2;
        l1->pitNext->pitPrev = l1;
    }
}

/*----------------------------------------------------------------------
| Split l2 off from the back of l1:  final l1,l2 = original l1
|
| Split l1 into l1: objects of l1 up to but not including Curs object
|               l2: objects of l1 from Curs onwards
| Any original contants of l2 are freed.
| List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all.
| The elements themselves are not moved.
 -----------------------------------------------------------------------*/
void
APIENTRY
List_SplitBefore(
                 LIST l1,
                 LIST l2,
                 LPVOID Curs
                 )
{
    LIST pit;

    if ((l1==NULL) || (l2==NULL)) {
        TRACE_ERROR("Bug: List_SplitBefore bogus list.  Continuing...", FALSE);
        return;
    }
    if (l2->pitNext!=l2) {
        List_Clear(l2);
    }
    if (Curs!=NULL) {
        MOVEBACK(Curs)
        pit = (LIST)Curs;
        /* Curs had better be an item in L1! L2 had better be created! */
        if (pit==l1) {
            l1->bOK = FALSE;
            l2->bOK = FALSE;
            return;
        }
        if (pit->pitPrev==l1) {
            SwitchLists(l2,l1);
            return;
        }
        l2->pitNext = pit;
        l2->pitPrev = l1->pitPrev;
        l1->pitPrev = pit->pitPrev;
        pit->pitPrev = l2;
        l2->pitPrev->pitNext = l2;
        l1->pitPrev->pitNext = l1;
    }
}

/*------------------------------------------------------------------
| Return the number of items in L
 -------------------------------------------------------------------*/
int
APIENTRY
List_Card(
          LIST lst
          )
{
    LIST pit;     /* item cursor on lst */
    int cit;

    if (lst==NULL) {
        TRACE_ERROR("Bug: List_Card of bogus list.  Continuing...", FALSE);
        return 0;    /* well it is sort of 0 */
    }
    pit = lst->pitNext;
    cit = 0;
    while (pit!=lst) {
        cit++;
        pit = pit->pitNext;
    }
    return cit;
}

/*------------------------------------------------------------------
| Check return code
 -------------------------------------------------------------------*/
BOOL
APIENTRY
List_IsOK(
          LIST lst
          )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_IsOK of bogus list.  Continuing...", FALSE);
        return FALSE;       /* well it is sick ain't it! */
    }
    return lst->bOK;
}

/*------------------------------------------------------------------
| Set return code to good
 -------------------------------------------------------------------*/
void
APIENTRY
List_MakeOK(
            LIST lst
            )
{
    if (lst==NULL) {
        TRACE_ERROR("Bug: List_MakeOK of bogus list.  Continuing...", FALSE);
        return;
    }
    lst->bOK = TRUE;
}

BOOL
APIENTRY
List_Check(
           LIST lst
           )
{
    LIST pel;
    BOOL bOK;
    /*-----------------------------------------------------------------
    | Check the anchor block has the Anchor flag set.
    | Run through the LIST using the Anchor flag (which should be FALSE)
    | to mark where we have been (to test for loops in the chain)
    | and carry on until we see the Anchor flag again.  Check that this
    | is the anchor block that we started from.  Now do another pass
    | turning the Anchor flags off again and checking the Prev pointers.
     -------------------------------------------------------------------*/
    if (lst==NULL)
        return FALSE;  /* Should we trap?  Arguable */
    bOK = lst->bAnchor;
    pel = lst->pitNext;
    while (! pel->bAnchor) {
        pel->bAnchor = TRUE;
        pel = pel->pitNext;
    }
    bOK = bOK && (pel==lst);
    if (bOK) {
        /* Turn all the bAnchor flags off */
        pel = lst;
        do {pel->bAnchor = FALSE;
            bOK = bOK & (pel->pitNext->pitPrev==pel);
            pel = pel->pitNext;
        } while (pel!=lst);
        lst->bAnchor = TRUE;  /* except the real one */
    } else { /* just turn off those that we set on */
        pel = lst->pitNext;
        while (pel->bAnchor) {
            pel->bAnchor = FALSE;
            pel = pel->pitNext;
        }
        lst->bAnchor = TRUE;
    }
    return bOK;
}


void
APIENTRY
List_Recover(
             PLIST plst
             )
{
    LIST Last, P,Q;
    BOOL OK;
    /* For no particular reason we presume that the forward chain
       is good and reconstruct the back chain from it.  A better
       algorithm would do the kind of things that List_Check does
       to figure out where the problems lie.  This just steps along
       until it sees either an address that it has already seen or
       else the anchor block.  (It's an n-squared algorithm).
       It links the last good block found back to the anchor and
       fixes all the Anchor flags.
    */
    if (plst==NULL)
        return;
    if (*plst==NULL) {
        *plst = List_Create();
        return;
    }
    (*plst)->bAnchor = TRUE;
    P = (*plst)->pitNext;
    Last = *plst;
    for (; ; ) {if (P==*plst) break;
        Last = P;
        if (P->pitNext!=*plst) {OK = TRUE;
            Q = *plst;
            for (; ; ) {
                OK &= (P->pitNext!=Q);
                if (Q==P) break;
                Q = Q->pitNext;
            }
            if (!OK) break;
        }
        P = P->pitNext;
    }
    P = *plst;
    while (P!=Last) {P->pitNext->pitPrev = P;
        P->bAnchor = FALSE;
        P = P->pitNext;
    }
    Last->pitNext = *plst;
    (*plst)->pitPrev = Last;
    (*plst)->bAnchor = TRUE;
    (*plst)->bOK = TRUE;   /* Here's hoping! */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\gutils.h ===
/* standard header for gutils.dll library functions
 * include after windows.h
 */

#define DimensionOf(x) (sizeof(x) / sizeof(x[0]))

/*--------win-16 win-32 porting macros etc ----------------------------*/

/* win32 msg crackers */
#define GET_WM_COMMAND_ID(w, l) (LOWORD(w))
#define GET_WM_COMMAND_CMD(w, l) (HIWORD(w))
#define GET_WM_COMMAND_HWND(w, l) (l)
#define GET_SCROLL_OPCODE(w, l)     (LOWORD(w))
#define GET_SCROLL_POS(w, l)        (HIWORD(w))

/* use of WNDPROC and FARPROC don't match up in definitions of
 * Win 3.1 functions vs NT functions. WINPROCTYPE matches WNDPROC
 * in NT and FARPROC in Win 3.1 so there are no warnings in either.
 * Places that use FARPROC in both APIs continue to use FARPROC.
 */
#define WINPROCTYPE     WNDPROC
// #define DLGPROC              WNDPROC  Doesn't wash on MIPS!!

/* ------- memory allocator ------------------------------------------*/

/* global heap functions - allocate and free many small
 * pieces of memory by calling global alloc for large pieces -
 * avoids using too many selectors
 *
 * DOGMA:
 * If you go running things on different threads and then try to EXIT
 * and hence gmem_free everything on one thread while still allocating
 * and hooking things up on another, things can get a little out of hand!
 * In particular, you may traverse a structure and hence try to FREE
 * a sub-structure to which there is a pointer, but which itself is not yet
 * allocated!
 *
 * The dogma is that when you allocate a new structure and tie it into a List
 * or whatever
 * EITHER all pointers within the allocated structure are made NULL
 *        before it is chained in
 * OR the caller of Gmem services undertakes not to try to free any
 *    garbage pointers that are not yet quite built.
 * It is SAFE to attempt to gmem_free a NULL pointer.  It's a no-op.
 * Note that List_NewXxxx(...) zeros the storage before chaining it in.
 * Note that List_AddXxxx(...) obviously doesn't!
 */
HANDLE APIENTRY gmem_init(void);
LPSTR APIENTRY gmem_get(HANDLE hHeap, int len);
void APIENTRY gmem_free(HANDLE hHeap, LPSTR ptr, int len);
void APIENTRY gmem_freeall(HANDLE hHeap);


/* return total time consumed doing gmem_get */
LONG APIENTRY gmem_time(void);

/* ---- file open/save common dialogs ---------------------------*/

/*
 * these functions now rely on to calls to the common dialog libraries.
 *
 * parameters:
 *      prompt - user prompt text (eg for dialog title)
 *      ext    - default extension (eg ".txt")
 *      spec   - default file spec (eg "*.*")
 *      osp    - file will be opened with this ofstruct before returning
 *      fn     - last component of file name will be copied here.
 * returns - TRUE if user selected a file that could be opened for
 *           reading (gfile_open) or created and opened for writing (gfile_new)
 *           FALSE if user canceled. if user selects a file that cannot be
 *           opened, a message box is put up and the dialog re-shown.
 */
BOOL APIENTRY gfile_open(HWND hwnd, LPSTR prompt, LPSTR ext, LPSTR spec,
                         OFSTRUCT FAR *osp, LPSTR fn);
BOOL APIENTRY gfile_new(LPSTR prompt, LPSTR ext, LPSTR spec,
                        OFSTRUCT FAR *osp, LPSTR fn);


/* --------- date conversion functions    -----------------------*/
/* days (which is actually days measured from a notional Jan 1st 0000)
   is a convenient way to store the date in a single LONG.  Use
   dmytoday to generate the LONG, use daytodmy to convert back
*/
void APIENTRY gdate_daytodmy(LONG days,
                             int FAR* yrp, int FAR* monthp, int FAR* dayp);

LONG APIENTRY gdate_dmytoday(int yr, int month, int day);

/* number of days in given month (Jan===1) in given year (e.g. 1993) */
int APIENTRY gdate_monthdays(int month, int year);

/* daynr is our standard LONG day number.  Returns day of the week.
   Weekdays are numbered from 0 to 6, Sunday==0
*/
int APIENTRY gdate_weekday(long daynr);


/* --- status line window class ---------------------------------- */
/* The status line is a bar across the top or bottom of the window.
 * It can hold a number of fields which can be either static text
 * or buttons.  The so called "static" text can be changed at any time.
 * The fields can be left or right aligned (default is RIGHT).
 * If the text is marked as VAR then the screen real estate allocated
 * for it will be adjusted whenever the text changes.  VAR fields
 * can be given minimum or maximum sizes (but not both).
 *
 * STATIC text fields can be drawn as raised or lowered rectangles (using
 * shades of grey), or (default) without a border. BUTTON fields will
 * always be drawn as raised rectangles, and will lower when pressed.
 *
 * Button fields will send WM_COMMAND messages when clicked including the
 * field id and the WM_LBUTTONUP notification code. Note that that this
 * is not a full implementation of the button class, and no other messages
 * will be sent. In general, none of the fields of a status bar are
 * implemented as separate windows, so GetDlgItem() and similar calls will not
 * work. Buttons only respond to mouse down events, and there is no handling
 * of the focus or of keyboard events.
 *
 * To use:
 *    call StatusAlloc giving the number of items you are going to add to the
 *    status bar. This returns a handle to use in subsequent calls.
 *
 *    Then call StatusAddItem to define each item in turn.
 *    Buttons are placed in order of definition along the bar starting from
 *    the left (SF_LEFT) and from the right (SF_RIGHT) until the two
 *    sides meet.
 *
 *    Call StatusHeight to find the expected height of this status bar, and
 *    set its position within the parent window, then call StatusCreate to
 *    create the window.
 *
 * Having created the window, send SM_SETTEXT messages to set the new
 * text of a field (static or button), or SM_NEW with a handle (obtained from
 * StatusAlloc) to change the contents of the status line.
 */

/* values for type argument to StatusAddItem */
#define SF_BUTTON       1
#define SF_STATIC       2

/* bits in flags argument to StatusAddItem */
#define SF_RAISE        1       /* paint static as raised 3D rectangle */
#define SF_LOWER        2       /* paint static as lowered 3D rectangle */
#define SF_LEFT         4       /* align field on left of status bar */
#define SF_RIGHT        8       /* align field on right (DEFAULT) */
#define SF_VAR          0x10    /* size of field depends on actual text extent*/
#define SF_SZMAX        0x20    /* (with SF_VAR): width argument is maximum */
#define SF_SZMIN        0x40    /* (with SF_VAR) width arg is minimum size */

/* interfaces */
HWND APIENTRY StatusCreate(HANDLE hInst, HWND hParent, INT_PTR id,
                           LPRECT rcp, HANDLE hmem);

/* return the recommended height in device units of the given status bar */
int APIENTRY StatusHeight(HANDLE hmem);

/* alloc the status bar data structures and return handle*/
HANDLE APIENTRY StatusAlloc(int nitems);

/* set the attributes of a field.
 *
 * hmem obtained from StatusAlloc. itemnr must be less than the nitems
 * passed to StatusAlloc.
 *
 * the width argument is the width of the field in characters (average
 * character width).
 */
BOOL APIENTRY StatusAddItem(HANDLE hmem, int itemnr, int type, int flags,
                            int id, int width, LPSTR text);

/* send these window messages to the class */

#define SM_NEW          (WM_USER+1)     /* wParam handle for new status line */
#define SM_SETTEXT      (WM_USER+2)     /* wparam: item id, lparam new label*/

/* --- bit-map freelist management functions -------------------------------*/

/* init a pre-allocated array of longs to map nblks - set all to free
   you should allocate 1 DWORD in map for every 32 blocks of storage
   you wish to control.
*/
void APIENTRY gbit_init(DWORD FAR * map, long nblks);

/* mark a range of nblks starting at blknr to be busy */
BOOL APIENTRY gbit_alloc(DWORD FAR * map, long blknr, long nblks);

/* mark a range of nblks starting at blknr to be free */
BOOL APIENTRY gbit_free(DWORD FAR * map, long blknr, long nblks);

/* find a free section nblks long, or the biggest found in the map if all
 * are less than nblks long. returns size of region found as return value,
 * and sets blknr to the starting blk of region. Region is *not* marked
 * busy
 */
long APIENTRY gbit_findfree(DWORD FAR* map, long nblks,
                            long mapsize, long FAR * blknr);


/* ----- buffered line input ----------------------------------*/

/*
 * functions for reading a file, one line at a time, with some buffering
 * to make the operation reasonably efficient.
 *
 * call readfile_new to initialise the buffer and give it a handle to
 * an open file. Call readfile_next to get a pointer to the next line.
 * This discards the previous line and gives you a pointer to the line
 * IN THE BUFFER. Make your own copy before calling readfile_next again.
 *
 * call readfile_delete once you have finished with this file. That will close
 * the file and free up any memory.
 */

// MAX_LINE_LENGTH is the max number of physical characters we allow in a line
#define MAX_LINE_LENGTH         (512)
// BUFFER_SIZE is expressed in bytes, and is large enough to read in
// MAX_LINE_LENGTH wide chars, and also hold MAX_LINE_LENGTH 5-byte hex code
// representations of the chars.
#define BUFFER_SIZE             (MAX_LINE_LENGTH * 5)

/* handle to a file buffer */
typedef struct filebuffer FAR * FILEBUFFER;

/* initialise the buffering for an open file */
FILEBUFFER APIENTRY readfile_new(int fh, BOOL *pfUnicode);

/* return a pointer to the next line in this file. line must be shorter than
 * buffer size (currently 1024 bytes). Line is not null-terminated: *plen
 * is set to the length of the line including the \n. This call will
 * discard any previous line, so ensure that you have made a copy of one line
 * before you call readfile_next again.
 * MUST CALL readfile_setdelims FIRST!
 */
LPSTR APIENTRY readfile_next(FILEBUFFER fb, int FAR * plen, LPWSTR *ppwz, int *pcwch);

/* set the delimiters to use to break lines.  MUST call this to initialise */
void APIENTRY readfile_setdelims(LPBYTE str);

/*
 * close the file and discard any associated memory and buffers.
 */
void APIENTRY readfile_delete(FILEBUFFER fb);


/* ------ hashing and checksums ------------------------------------------- */

/*
 * generate a 32-bit hash code for a null-terminated string of ascii text.
 *
 * if bIgnoreBlanks is TRUE, we ignore spaces and tabs during the
 * hashcode calculation.
 */

/* hash codes are unsigned longs */

DWORD APIENTRY hash_string(LPSTR string, BOOL bIgnoreBlanks);
void Format(char * a, char * b);

/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY utils_isblank(LPSTR string);

/*
 * Compare two pathnames, and if not equal, decide which should come first.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * To make absolutely certain that you get a canonical sorting, use AnsiLowerBuff
 * to convert BOTH to lower case first.  You may get a funny effect if one one
 * has been converted to lower case and the other not.
 */
int APIENTRY
utils_CompPath(LPSTR left, LPSTR right);
/* given an open file handle open for reading, read the file and
 * generate a 32-bit checksum for the file
 */

/* checksums are unsigned longs */
typedef DWORD CHECKSUM;

/* Open a file, checksum it and close it again. err !=0 iff it failed. */
CHECKSUM APIENTRY checksum_file(LPCSTR fn, LONG FAR * err);


/* --- error message output ----------------------------------------------*/

/*
 * reports error in a dialog, returns TRUE for ok, FALSE for cancel.
 * if fCancel is FALSE, only the OK button is shown, otherwise both ok
 * and cancel. hwnd is the parent window for the dlg. can be null.
 */
BOOL APIENTRY Trace_Error(HWND hwnd, LPSTR msg, BOOL fCancel);

/* Write popups to a file until further notice */
void Trace_Unattended(BOOL bUnattended);

/* --- create/write to trace file ----------------------------------------*/

void APIENTRY Trace_File(LPSTR msg);

/* --- close trace file --------------------------------------------------*/
void APIENTRY Trace_Close(void);

/* --- simple input ------------------------------------------------------*/

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * def_input as the default input. All of these can be null.
 */

int APIENTRY StringInput(LPSTR result, int resultsize, LPSTR prompt,
                         LPSTR caption, LPSTR def_input);



/* --- sockets -----------------------------------------------------------*/

#ifdef SOCKETS

    #include <winsock.h>

BOOL SocketConnect( LPSTR pstrServerName, u_short TCPPort, SOCKET *pSocket );
BOOL SocketListen( u_short TCPPort, SOCKET *pSocket );

#endif

// These are for both WINDIFF.EXE and GUTILS.DLL.
//#define strchr          My_mbschr
//#define strncpy         My_mbsncpy
PUCHAR My_mbspbrk(PUCHAR, PUCHAR);
LPSTR My_mbschr(LPCSTR, unsigned short);
LPSTR My_mbsncpy(LPSTR, LPCSTR, size_t);

// These are for WINDIFF.EXE.
//#define strrchr         My_mbsrchr
//#define strncmp         My_mbsncmp
LPSTR My_mbsrchr(LPCSTR, unsigned short);
int My_mbsncmp(LPCSTR, LPCSTR, size_t);
LPTSTR APIENTRY LoadRcString(UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\status.c ===
/*
 * status line handler
 *
 */

/*---includes-----------------------------------------------------------*/
#include "windows.h"
#include "string.h"
#include "gutils.h"


/* --- data structures ------------------------------------------------- */

#define SF_MAXLABEL     80   /* no more than 80 in an item within the bar */
/* Is this adequate for long pathnames on a
   hi-res screen?
*/

typedef struct statel {
    int type;                       /* SF_BUTTON or SF_STATIC */
    int flags;                      /* SF_VAR => variable width
                                       SF_LEFT=> left aligned (else right)
                                       SF_RAISE=> paint as 'raised' 3d rect
                                       SF_LOWER=> paint as lowered 3D rect
                                       SF_SZMIN=>together with SF_VAR
                                                 allows minimum size for
                                                 var sized item
                                       SF_SZMAX=>see SZMIN and use nouse
                                    */
    int id;                         /* control id */
    int width;                      /* width of control in chars */
    char text[SF_MAXLABEL+1];       /* null-term string for label */

    RECT rc;                        /* used by status.c */
} STATEL, * PSTATEL;

typedef struct itemlist {
    int nitems;
    PSTATEL statels;

    int selitem;                    /* used by status.c */
    BOOL isselected;                /* used by status.c */
} ILIST, * PILIST;

/* ------------------------------------------------------------------*/


/* prototypes of routines in this module */

void StatusCreateTools(void);
void StatusDeleteTools(void);
INT_PTR APIENTRY StatusWndProc(HWND, UINT, WPARAM, LPARAM);
void StatusResize(HWND hWnd, PILIST pilist);
int StatusCalcHeight(HWND hWnd, PSTATEL ip);
int StatusCalcWidth(HWND hWnd, PSTATEL ip);
PSTATEL StatusGetItem(PILIST plist, int id);
void LowerRect(HDC hDC, LPRECT rcp);
void RaiseRect(HDC hDC, LPRECT rcp);
void StatusPaint(HWND hWnd, PILIST iplistp);
void BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners);
void StatusButtonDown(HDC hDC, PSTATEL ip);
void StatusButtonUp(HDC hDC, PSTATEL ip);
void InitDC(HDC hdc);


/*--global data---------------------------------------------------------*/

HPEN hpenHilight, hpenLowlight;
HPEN hpenBlack, hpenNeutral;
HBRUSH hbrBackground; /* pieces and board */
HFONT hFont;
int status_charheight, status_charwidth;

/* default pt size for font (tenths of a pt) */
#define         DEF_PTSIZE      80
/*-public functions----------------------------------------------------------*/

/* StatusInit
 *
 * - create window class
 */
BOOL
StatusInit(
           HANDLE hInstance
           )
{
    WNDCLASS    wc;
    BOOL resp;
    TEXTMETRIC tm = {0};
    HDC hDC;


    StatusCreateTools();

    wc.style = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
    wc.lpfnWndProc = StatusWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(HANDLE);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = hbrBackground;
    wc.lpszClassName = (LPSTR) "gdstatusclass";
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);

    hDC = GetDC(NULL);
    if (hDC)
    {
        InitDC(hDC);
        GetTextMetrics(hDC, &tm);
        ReleaseDC(NULL, hDC);
    }
    else
    {
        // arbitrary, whatever...
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }
    status_charheight = (int)(tm.tmHeight + tm.tmExternalLeading);
    status_charwidth = (int)tm.tmAveCharWidth;

    return(resp);
}

/*
 * create and show the window
 */
HWND APIENTRY
StatusCreate(
             HANDLE hInst,
             HWND hParent,
             INT_PTR id,
             LPRECT rcp,
             HANDLE hmem
             )
{

    HWND hWnd;

    /* create a child window of status class */


    hWnd = CreateWindow("gdstatusclass",
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        rcp->left,
                        rcp->top,
                        (rcp->right - rcp->left),
                        (rcp->bottom - rcp->top),
                        hParent,
                        (HANDLE) id,
                        hInst,
                        (LPVOID) hmem);

    return(hWnd);
}

/* return default height of this window */
int APIENTRY
StatusHeight(
             HANDLE hmem
             )
/* The window has a number of items which are arranged horizontally,
   so the window height is the maximum of the individual heights
*/
{
    PILIST plist;
    int i;
    int sz;
    int maxsize = 0;

    plist = (PILIST) GlobalLock(hmem);
    if (plist != NULL) {
        for (i = 0; i<plist->nitems; i++) {
            sz = StatusCalcHeight(NULL, &plist->statels[i]);
            maxsize = max(sz, maxsize);
        }
    }
    GlobalUnlock(hmem);
    if (maxsize > 0) {
        return(maxsize + 4);
    } else {
        return(status_charheight + 4);
    }
}

/* alloc the plist struct and return handle to caller */
HANDLE
StatusAlloc(
            int nitems
            )
{
    HANDLE hmem;
    PILIST pilist;
    LPSTR chp;

    hmem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                       sizeof(ILIST) + (sizeof(STATEL) * nitems));
    chp = GlobalLock(hmem);
    if (chp == NULL) {
        return(NULL);
    }

    pilist = (PILIST) chp;
    pilist->nitems = nitems;
    pilist->statels = (PSTATEL) &chp[sizeof(ILIST)];
    GlobalUnlock(hmem);

    return(hmem);
}


/* insert an item into the plist */
BOOL
StatusAddItem(
              HANDLE hmem,
              int itemnr,
              int type,
              int flags,
              int id,
              int width,
              LPSTR text
              )
{
    PILIST pilist;
    PSTATEL pel;

    pilist = (PILIST) GlobalLock(hmem);
    if ((pilist == NULL) || (itemnr >= pilist->nitems)) {
        GlobalUnlock(hmem);
        return(FALSE);
    }
    pel = &pilist->statels[itemnr];
    pel->type = type;
    pel->flags = flags;
    pel->id = id;
    pel->width = width;
    if (text == NULL) {
        pel->text[0] = '\0';
    } else {
        lstrcpy(pel->text, text);
    }


    GlobalUnlock(hmem);
    return(TRUE);
}

/* ---- internal functions ------------------------------------------*/

void
InitDC(HDC hdc)
{
    SetBkColor(hdc, RGB(192,192,192));
    SelectObject(hdc, hbrBackground);
    SelectObject(hdc, hFont);
}


void
StatusCreateTools()
{
    LOGFONT lf;
    HDC hdc;
    int scale;

    hbrBackground = CreateSolidBrush(RGB(192,192,192));
    hpenHilight = CreatePen(0, 1, RGB(255, 255, 255));
    hpenLowlight = CreatePen(0, 1, RGB(128, 128, 128));
    hpenNeutral = CreatePen(0, 1, RGB(192, 192, 192));
    hpenBlack = CreatePen(0, 1, RGB(0, 0, 0));

    hdc = GetDC(NULL);
    if (hdc)
    {
        scale = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }
    else
    {
        // arbitrary, whatever...
        scale = 72;
    }

    lf.lfHeight = -MulDiv(DEF_PTSIZE, scale, 720);
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = FW_REGULAR;
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
    lf.lfFaceName[0] = '\0';
#ifdef COMPLEX
    hFont = CreateFontIndirect(&lf);
#else
    hFont = GetStockObject(SYSTEM_FONT);
#endif



}

void
StatusDeleteTools()
{
    DeleteObject(hbrBackground);
    DeleteObject(hpenHilight);
    DeleteObject(hpenLowlight);
    DeleteObject(hpenBlack);
    DeleteObject(hpenNeutral);

#ifdef COMPLEX
    DeleteObject(hFont);
#endif
}

/* Main winproc for status windows
 *
 * handles create/destroy and paint requests
 */

INT_PTR
StatusWndProc(
              HWND hWnd,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    HANDLE hitems;
    PSTATEL ip;
    PILIST plist;
    CREATESTRUCT * cp;
    int i;
    HDC hDC;
    RECT rc;
    POINT pt;

    switch (message) {

        case WM_CREATE:
            cp = (CREATESTRUCT *) lParam;
            hitems = (HANDLE) cp->lpCreateParams;
            SetWindowLongPtr(hWnd, 0,  (LONG_PTR)hitems);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                plist->selitem = -1;
                GlobalUnlock(hitems);
            }
            break;

        case WM_SIZE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist != NULL) {
                StatusResize(hWnd, plist);
                GlobalUnlock(hitems);
            }
            break;

        case WM_PAINT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            StatusPaint(hWnd, plist);
            GlobalUnlock(hitems);

            break;

        case WM_LBUTTONUP:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            if (plist == NULL) {
                break;
            }
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (plist->isselected) {
                    hDC = GetDC(hWnd);
                    if (hDC)
                    {
                        InitDC(hDC);
                        StatusButtonUp(hDC, ip);
                        ReleaseDC(hWnd, hDC);
                    }
                }
                plist->selitem = -1;
                ReleaseCapture();
                if (PtInRect(&ip->rc, pt)) {
                    SendMessage(GetParent(hWnd), WM_COMMAND, MAKELONG(ip->id, WM_LBUTTONUP), (LPARAM)hWnd);
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_LBUTTONDOWN:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem == -1) {
                for (i = 0; i< plist->nitems; i++) {
                    ip = &plist->statels[i];
                    if (PtInRect(&ip->rc, pt)) {
                        if (ip->type != SF_BUTTON) {
                            break;
                        }
                        plist->selitem = i;
                        SetCapture(hWnd);

                        plist->isselected = TRUE;
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        break;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;

        case WM_MOUSEMOVE:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                break;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (plist->selitem != -1) {
                ip = &plist->statels[plist->selitem];
                if (PtInRect(&ip->rc, pt)) {
                    if (!plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonDown(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = TRUE;
                    }
                } else {
                    if (plist->isselected) {
                        hDC = GetDC(hWnd);
                        if (hDC)
                        {
                            InitDC(hDC);
                            StatusButtonUp(hDC, ip);
                            ReleaseDC(hWnd, hDC);
                        }
                        plist->isselected = FALSE;
                    }
                }
            }
            GlobalUnlock(hitems);
            break;


        case WM_DESTROY:

            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            GlobalUnlock(hitems);
            GlobalFree(hitems);

            SetWindowLongPtr(hWnd, 0, 0);
            break;

        case SM_NEW:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems != NULL) {
                GlobalFree(hitems);
            }
            hitems = (HANDLE) wParam;
            if (hitems == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            if (plist == NULL) {
                SetWindowLongPtr(hWnd, 0, 0);
                InvalidateRect(hWnd, NULL, TRUE);
                break;
            }
            plist->selitem = -1;
            StatusResize(hWnd, plist);
            GlobalUnlock(hitems);
            SetWindowLongPtr(hWnd, 0, (LONG_PTR)hitems);
            InvalidateRect(hWnd, NULL, TRUE);
            break;

        case SM_SETTEXT:
            hitems = (HANDLE) GetWindowLongPtr(hWnd, 0);
            if (hitems == NULL) {
                break;
            }
            plist = (PILIST) GlobalLock(hitems);
            ip = StatusGetItem(plist, (int)wParam);
            if (ip != NULL) {
                if (lParam == 0) {
                    ip->text[0] = '\0';
                } else {
                    My_mbsncpy(ip->text, (LPSTR) lParam, SF_MAXLABEL);
                    ip->text[SF_MAXLABEL] = '\0';
                }

                /* if this is a variable width field, we need to redo
                 * all size calcs in case the field width has changed.
                 * in that case, we need to repaint the entire window
                 * and not just this field - so set rc to indicate the
                 * area to be redrawn.
                 */
                if (ip->flags & SF_VAR) {
                    StatusResize(hWnd, plist);
                    GetClientRect(hWnd, &rc);
                    RedrawWindow(hWnd, &rc, NULL,
                                 RDW_INVALIDATE|RDW_ERASE|RDW_UPDATENOW);
                } else {
                    /* instead of just invalidating the window, we can
                     * force the window to be repainted now. This is
                     * essential for status updates during a busy
                     * loop when no messages are being processed,
                     * but we should still update the user on what's
                     * happening.
                     */
                    RedrawWindow(hWnd, &ip->rc, NULL,
                                 RDW_INVALIDATE|RDW_NOERASE|RDW_UPDATENOW);
                }

            }
            GlobalUnlock(hitems);
            break;

        default:
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/*
 * position the labels and buttons within the status window */
void
StatusResize(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    int curpos_right, curpos_left;
    int height, width;
    int i;
    PSTATEL ip;


    if (iplistp == NULL) {
        return;
    }
    GetClientRect(hWnd, &rc);
    curpos_left = rc.left + status_charwidth / 2;
    curpos_right = rc.right - (status_charwidth / 2);

    /* loop through all items setting their position rects.
     * items are flagged as being left or right. We place them
     * in order starting at the left and the right, with a single
     * char's width between each item
     */
    for (i = 0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        width = StatusCalcWidth(hWnd, ip);
        height = StatusCalcHeight(hWnd, ip);
        ip->rc.top = (rc.bottom - height) / 2;
        ip->rc.bottom = ip->rc.top + height;

        /* see if  this item fits. Items that partially fit
         * are placed reduced in size.
         */
        if (ip->flags & SF_LEFT) {

            if (curpos_left+width >= curpos_right) {
                /* doesn't completely fit-does it partly? */
                if ((curpos_left + 1) >= curpos_right) {

                    /* no - this item does not fit */
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* partial fit */
                    ip->rc.left = curpos_left;
                    ip->rc.right = curpos_right - 1;
                    curpos_left = curpos_right;
                }
            } else {
                /* complete fit */
                ip->rc.left = curpos_left;
                ip->rc.right = curpos_left + width;
                curpos_left += width + 1;
            }
        } else {

            /* same size check for right-aligned items */
            if (curpos_right-width <= curpos_left) {

                /* partial fit ? */
                if (curpos_right <= curpos_left+1) {
                    ip->rc.left = 0;
                    ip->rc.right = 0;
                } else {
                    /* yes - partial fit */
                    ip->rc.left = curpos_left + 1;
                    ip->rc.right = curpos_right;
                    curpos_right = curpos_left;
                }
            } else {
                /* complete fit */
                ip->rc.right = curpos_right;
                ip->rc.left = curpos_right - width;
                curpos_right -= (width + 1);
            }
        }
    }
}


void
StatusPaint(HWND hWnd, PILIST iplistp)
{
    RECT rc;
    HDC hDC;
    PAINTSTRUCT ps;
    int i;
    PSTATEL ip;
    HPEN hpenOld;

    GetClientRect(hWnd, &rc);
    hDC = BeginPaint(hWnd, &ps);
    InitDC(hDC);

    RaiseRect(hDC, &rc);
    if (iplistp == NULL) {
        EndPaint(hWnd, &ps);
        return;
    }
    for (i =0; i < iplistp->nitems; i++) {
        ip = &iplistp->statels[i];

        if (ip->rc.left == ip->rc.right) {
            continue;
        }
        if (ip->type == SF_STATIC) {
            if (ip->flags & SF_RAISE) {
                RaiseRect(hDC, &ip->rc);
            } else if (ip->flags & SF_LOWER) {
                LowerRect(hDC, &ip->rc);
            }
            rc = ip->rc;
            rc.left += (status_charwidth / 2);
            rc.right--;
            rc.top++;
            rc.bottom--;
            hpenOld = SelectObject(hDC, hpenNeutral);
            Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
            SelectObject(hDC, hpenOld);
            DrawText(hDC, ip->text, lstrlen(ip->text), &rc,
                     DT_LEFT | DT_VCENTER);
        } else {
            StatusButtonUp(hDC, ip);
        }
    }

    EndPaint(hWnd, &ps);
}

void
RaiseRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenHilight, FALSE);
    BottomRight(hDC, rcp, hpenLowlight, FALSE);
}

void
LowerRect(HDC hDC, LPRECT rcp)
{
    TopLeft(hDC, rcp, hpenLowlight, FALSE);
    BottomRight(hDC, rcp, hpenHilight, FALSE);
}

void
StatusButtonUp(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenHilight, FALSE);
    BottomRight(hDC, &rc, hpenLowlight, TRUE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    BottomRight(hDC, &rc, hpenLowlight, TRUE);
    rc.bottom--;
    rc.right--;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
StatusButtonDown(HDC hDC, PSTATEL ip)
{
    RECT rc;
    HPEN hpenOld;
    TEXTMETRIC tm;

    rc = ip->rc;
    TopLeft(hDC, &rc, hpenBlack, TRUE);
    BottomRight(hDC, &rc, hpenBlack, FALSE);

    rc.top++;
    rc.bottom--;
    rc.left++;
    rc.right--;
    TopLeft(hDC, &rc, hpenLowlight, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    TopLeft(hDC, &rc, hpenNeutral, TRUE);
    rc.top++;
    rc.left++;
    hpenOld = SelectObject(hDC, hpenNeutral);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hDC, hpenOld);
    GetTextMetrics(hDC, &tm);
    rc.top += tm.tmExternalLeading;
    DrawText(hDC, ip->text, lstrlen(ip->text), &rc, DT_CENTER | DT_VCENTER);
}

void
TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->right - 1;
    y = rcp->bottom;
    if (!bCorners) {
        x--;
        y--;
    }
    MoveToEx(hDC, x, rcp->top, NULL);
    LineTo(hDC, rcp->left, rcp->top);
    LineTo(hDC, rcp->left, y);
    SelectObject(hDC, hpenOld);
}

void
BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners)
{
    HPEN hpenOld;
    int x, y;

    hpenOld = SelectObject(hDC, hpen);
    x = rcp->left - 1;
    y = rcp->top;
    if (!bCorners) {
        x++;
        y++;
    }
    MoveToEx(hDC, rcp->right-1, y, NULL);
    LineTo(hDC, rcp->right-1, rcp->bottom-1);
    LineTo(hDC, x, rcp->bottom-1);
    SelectObject(hDC, hpenOld);
}


PSTATEL
StatusGetItem(PILIST plist, int id)
{
    int i;

    if (plist == NULL) {
        return(NULL);
    }
    for (i = 0; i < plist->nitems; i++) {
        if (plist->statels[i].id == id) {
            return(&plist->statels[i]);
        }
    }
    return(NULL);
}

/*
 * calculate the width of a given field. This is the width in characters
 * multiplied by the average character width, plus a few units for
 * borders.
 *
 * if SF_VAR is set, this field size varies depending on the text, so
 * we use GetTextExtent for the field size. If SF_VAR is selected, the caller
 * can specify that the size is not to exceed the (width * avecharwidth)
 * size (using SF_SZMAX) or that it is not be less than it (SF_SZMIN).
 */
int
StatusCalcWidth(HWND hWnd, PSTATEL ip)
{
    int ch_size, t_size;
    SIZE sz = {0};
    HDC hDC;

    ch_size = ip->width * status_charwidth;
    if (ip->flags & SF_VAR) {
        hDC = GetDC(hWnd);
        if (hDC)
        {
            InitDC(hDC);
            GetTextExtentPoint(hDC, ip->text, lstrlen(ip->text), &sz);
            ReleaseDC(hWnd, hDC);
        }
        t_size = sz.cx;

        /*
         * check this size against min/max size if
         * requested
         */

        if (ip->flags & SF_SZMIN) {
            if (ch_size > t_size) {
                t_size = ch_size;
            }
        }
        if (ip->flags & SF_SZMAX) {
            if (ch_size < t_size) {
                t_size = ch_size;
            }
        }
        ch_size = t_size;
    }

    if (ch_size != 0) {
        if (ip->type == SF_BUTTON) {
            return(ch_size+6);
        } else {
            return(ch_size+4);
        }
    } else {
        return(0);
    }
}

int
StatusCalcHeight(HWND hWnd, PSTATEL ip)
{
    int size;

    size = status_charheight;
    if (ip->type == SF_BUTTON) {
        return(size + 6);
    } else {
        return(size + 2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\table.c ===
/*
 * standard table class.
 *
 * main interface functions.
 *
 * see table.h for interface description
 */

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"



/* global tools etc */
extern HANDLE hLibInst;
HANDLE hVertCurs;
HANDLE hNormCurs;
HPEN hpenDotted;
UINT gtab_msgcode;

/* function prototypes */
LRESULT gtab_wndproc(HWND, UINT, WPARAM, LPARAM);
void gtab_createtools(void);
void gtab_deltable(HWND hwnd, lpTable ptab);
lpTable gtab_buildtable(HWND hwnd, DWORD_PTR id);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_newsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD_PTR id);

/*
 * initialise window class - called from DLL main init
 */
void
gtab_init(void)
{
    WNDCLASS wc;

    gtab_createtools();
    gtab_msgcode = RegisterWindowMessage(TableMessage);

    wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
    wc.lpfnWndProc = gtab_wndproc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = WLTOTAL;
    wc.hInstance = hLibInst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = TableClassName;
    wc.lpszMenuName = NULL;

    RegisterClass(&wc);
}

void
gtab_createtools(void)
{
    hVertCurs = LoadCursor(hLibInst, "VertLine");
    hNormCurs = LoadCursor(NULL, IDC_ARROW);

    hpenDotted = CreatePen(PS_DOT, 1, RGB(0, 0, 0));
}

void
gtab_deltools(void)
{
    DeleteObject(hpenDotted);
}


LRESULT
gtab_wndproc(
            HWND hwnd,
            UINT msg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    CREATESTRUCT FAR * csp;
    HWND hOwner;
    lpTable ptab;
    HANDLE hHeap;
    PAINTSTRUCT ps;
    int y, y2, i;
    HDC hDC;
    lpTableSelection pselect;
    long oldtop;
    long change;
    LRESULT lresult = TRUE;

    switch (msg) {

        case WM_CREATE:
            /* create window. set the wnd extra bytes to
             * contain the owner window, a heap and a null table.
             * Owner window is either in lParam or the parent.
             * Then wait for TM_NEWID.
             */
            csp = (CREATESTRUCT FAR *) lParam;
            if (csp->lpCreateParams == NULL) {
                hOwner = GetParent(hwnd);
            } else {
                hOwner = (HWND) csp->lpCreateParams;
            }
            ptab = NULL;
            hHeap = gmem_init();
            SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
            SetWindowLongPtr(hwnd, WW_OWNER, (LONG_PTR) hOwner);
            SetWindowLongPtr(hwnd, WW_HEAP, (LONG_PTR) hHeap);

            SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
            SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            break;

      
        case TM_NEWID:
            /* complete change of table.
             * close old table, discard memory and
             * build new table
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_NEWLAYOUT:
            /* change of layout but for same id. no TQ_CLOSE,
             * but otherwise same as TM_NEWID
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_deltable(hwnd, ptab);
                SetCursor(hNormCurs);
                SetWindowLongPtr(hwnd, WL_TABLE, 0);
            }
            if ( (ptab = gtab_buildtable(hwnd, (DWORD_PTR)lParam)) != NULL) {
                SetWindowLongPtr(hwnd, WL_TABLE, (LONG_PTR) ptab);
                gtab_setsize(hwnd, ptab);
            } else {
                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_REFRESH:
            /* data in table has changed. nrows may have
             * changed. ncols and col types have not changed
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_newsize(hwnd, ptab);
                gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, 
			    (LPARAM) &ptab->show_whitespace);
            }
            InvalidateRect(hwnd, NULL, TRUE);
            break;

        case TM_SELECT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                gtab_select(hwnd, ptab, pselect->startrow,
                            pselect->startcell,
                            pselect->nrows,
                            pselect->ncells,
                            TRUE);
                gtab_showsel_middle(hwnd, ptab, pselect->dyRowsFromTop);
            }
            break;

        case TM_GETSELECTION:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                pselect = (lpTableSelection) lParam;

                *pselect = ptab->select;
            }
            break;

        case TM_PRINT:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            if (ptab != NULL) {
	      lresult = gtab_print(hwnd, ptab, hHeap, (lpPrintContext) lParam);
            } else {
	      lresult = FALSE;
	    }
	    break;

        case TM_SETTABWIDTH:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            ptab->tabchars = (int)lParam;
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case TM_TOPROW:

            /* return top row. if wParam is TRUE, set lParam
             * as the new toprow
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
	      lresult = 0;
            } else {
	      oldtop = ptab->toprow;
	      if ((wParam) && (lParam < ptab->hdr.nrows)) {
                change = (long)lParam - ptab->toprow;
                change -= ptab->hdr.fixedrows;
                gtab_dovscroll(hwnd, ptab, change);
	      }
	      lresult = oldtop;
	    }
	    break;
 
        case TM_ENDROW:
            /* return the last visible row in the window */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab == NULL) {
	      lresult = 0;
            } else {
	      lresult = (ptab->nlines + ptab->toprow - 1);
	    }
	    break;

        case TM_APPEND:
            /* new rows have been added to the end of the
             * table, but the rest of the table has not
             * been changed. Update without forcing redraw of
             * everything.
             * lParam contains the new total nr of rows
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_append(hwnd, ptab, (int) wParam, (DWORD_PTR)lParam);
		lresult = TRUE;
            }
            break;

        case WM_SIZE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_setsize(hwnd, ptab);
            }
            break;

        case WM_ERASEBKGND:
	    break;

        case WM_DESTROY:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_sendtq(hwnd, TQ_CLOSE, ptab->hdr.id);
                gtab_deltable(hwnd, ptab);
            }
            hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
            gmem_freeall(hHeap);
            break;

        case WM_SYSCOLORCHANGE:
	  InvalidateRect(hwnd, NULL, TRUE);
	  break;

        case WM_PAINT:
	  gtab_paint(hwnd);
	  break;

        case WM_HSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_hscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_VSCROLL:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_msg_vscroll(hwnd, ptab,
                                 GET_SCROLL_OPCODE(wParam, lParam),
                                 GET_SCROLL_POS(wParam, lParam));
            }
            break;

        case WM_MOUSEMOVE:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_move(hwnd, ptab, (int)(short)LOWORD(lParam), 
			  (int)(short)HIWORD(lParam));
            } else {
                SetCursor(hNormCurs);
            }
            break;

        case WM_LBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_press(hwnd, ptab, (int)(short)LOWORD(lParam), 
			   (int)(short)HIWORD(lParam));
            }
            break;

        case WM_RBUTTONDOWN:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_rightclick(hwnd, ptab, (int)(short)LOWORD(lParam), 
				(int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONUP:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_release(hwnd, ptab,
                             (int)(short)LOWORD(lParam), 
			     (int)(short)HIWORD(lParam));
            }
            break;

        case WM_LBUTTONDBLCLK:
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                gtab_dblclick(hwnd, ptab,
                              (int)(short)LOWORD(lParam), 
			      (int)(short)HIWORD(lParam));
            }
            break;

        case WM_KEYDOWN:
            /* handle key presses for cursor movement about
             * the table, and return/space for selection.
             * Any key we don't handle is passed to the owner window
             * for him to handle.
             * The table window should have the focus
             */
            ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_key(hwnd, ptab, (int)wParam) != 0) {
                    /* pass key to owner since
                     * we don't know what to do with it
                     */
                    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
                    lresult = SendMessage(hOwner, WM_KEYDOWN, wParam, lParam);
                } else {
		  lresult = 0;
                }
            }
            break;

#ifdef WM_MOUSEWHEEL
        case WM_MOUSEWHEEL:
            ptab = (lpTable)GetWindowLongPtr(hwnd, WL_TABLE);
            if (ptab != NULL) {
                if (gtab_mousewheel(hwnd,ptab, LOWORD(wParam), (short)HIWORD(wParam))) {
                    // Input was not handled. Need to forward to the owner.
                    hOwner = (HWND)GetWindowLongPtr(hwnd, WW_OWNER);
                    lresult = SendMessage(hOwner, WM_MOUSEWHEEL, wParam, lParam);
                }
            }
            break;
#endif

        default:
	  lresult = DefWindowProc(hwnd, msg, wParam, lParam);
	  break;
    }
    return lresult;
}

/*
 * send a table-query message to the owner window. returns message
 * value.
 */
INT_PTR
gtab_sendtq(
           HWND hwnd,
           UINT cmd,
           LPARAM lParam
           )
{
    HWND hOwner;

    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    return (SendMessage(hOwner, gtab_msgcode, cmd, lParam));
}

/*
 * free the memory allocated for the array of lines (each containing
 * an array of Cells, each containing an array of chars for the actual
 * data). Called on any occasion that would change the number of visible lines
 */
void
gtab_freelinedata(
                 HANDLE hHeap,
                 lpTable ptab
                 )
{
    int i, j, ncols;
    lpCellData cd;


    ncols = ptab->hdr.ncols;

    /* for each line */
    for (i = 0; i < ptab->nlines; i++) {
        /* for each cell */
        for (j = 0; j < ncols; j++) {
            /* free up the actual text space */
            cd = &ptab->pdata[i].pdata[j];
            gmem_free(hHeap, (LPSTR) cd->ptext, cd->nchars);
            gmem_free(hHeap, (LPSTR) cd->pwzText, cd->nchars);
        }
        /* dealloc array of CellData */
        gmem_free(hHeap, (LPSTR) ptab->pdata[i].pdata,
                  sizeof(CellData) * ncols);
    }
    /* de-alloc array of linedatas */
    gmem_free(hHeap, (LPSTR) ptab->pdata,
              sizeof(LineData) * ptab->nlines);
    ptab->pdata = NULL;
}

/* allocate and init array of linedatas (include cell array
 * and text for each cell)
 */
BOOL
gtab_alloclinedata(
                  HWND hwnd,
                  HANDLE heap,
                  lpTable ptab
                  )
{
    lpLineData pline;
    lpCellData cd;
    int i, j;

    ptab->pdata = (lpLineData) gmem_get(heap,
                                        sizeof(LineData) * ptab->nlines);
    if (ptab->pdata == NULL) {
        return(FALSE);
    }
    for (i = 0; i < ptab->nlines; i++) {
        pline = &ptab->pdata[i];
        pline->linepos.size = ptab->rowheight;
        pline->pdata = (lpCellData) gmem_get(heap,
                                             sizeof(CellData) * ptab->hdr.ncols);
        if (pline->pdata == NULL) {
            return(FALSE);
        }
        for (j = 0; j < ptab->hdr.ncols; j++) {
            cd = &pline->pdata[j];
            cd->props.valid = 0;
            cd->flags = 0;
            cd->nchars = ptab->pcolhdr[j].nchars;
            if (cd->nchars > 0) {
                cd->ptext = gmem_get(heap, cd->nchars);
                if (cd->ptext == NULL) {
                    return(FALSE);
                }
                cd->pwzText = 0;
            }
        }
    }
    return(TRUE);
}

/*
 * free up all table data structures. Called for new layout or new data.
 */
void
gtab_deltable(
             HWND hwnd,
             lpTable ptab
             )
{
    HANDLE hHeap;
    int ncols;

    if (ptab == NULL) {
        return;
    }
    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ncols = ptab->hdr.ncols;

    if (ptab->pcolhdr != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcolhdr,
                  sizeof(ColProps) * ncols);
    }
    if (ptab->pcellpos != NULL) {
        gmem_free(hHeap, (LPSTR) ptab->pcellpos,
                  sizeof(CellPos) * ncols);
    }
    if (ptab->pdata != NULL) {
        gtab_freelinedata(hHeap, ptab);
    }
    gmem_free(hHeap, (LPSTR) ptab, sizeof(Table));
}


/*
 * build up a Table struct (excluding data allocation and
 * anything to do with font or window size).
 * return ptr to this or NULL if error
 */
lpTable
gtab_buildtable(
               HWND hwnd,
               DWORD_PTR id
               )
{
    lpTable ptab;
    HANDLE hHeap;
    int ncols, i;
    ColPropsList cplist;

    hHeap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
    ptab = (lpTable) gmem_get(hHeap, sizeof(Table));
    if (ptab == NULL) {
        return(NULL);
    }

    // get the tab width. most clients will not support this
    if (gtab_sendtq(hwnd, TQ_TABS, (LPARAM) &ptab->tabchars) == FALSE) {
        ptab->tabchars = TABWIDTH_DEFAULT;
    }

    // get the show whitespace value
    if (gtab_sendtq(hwnd, TQ_SHOWWHITESPACE, (LPARAM) &ptab->show_whitespace) == FALSE) {
        ptab->show_whitespace = FALSE;
    }

    /* get the row/column count from owner window */
    ptab->hdr.id = id;
    ptab->hdr.props.valid = 0;
    ptab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &ptab->hdr) == FALSE) {
        return(NULL);
    }

    ncols = ptab->hdr.ncols;
    ptab->pcolhdr = (lpColProps) gmem_get(hHeap, sizeof(ColProps) * ncols);
    if (ptab->pcolhdr == NULL) {
        /* should prob send TQ_CLOSE at this point */
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        ptab->pcolhdr[i].props.valid = 0;
        ptab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = ptab->pcolhdr;
    cplist.id = id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM) &cplist);

    /* init remaining fields */
    ptab->pcellpos = (lpCellPos) gmem_get(hHeap, sizeof(CellPos) * ncols);
    if (ptab->pcellpos == NULL) {
        return(NULL);
    }

    ptab->scrollscale = 1;
    ptab->scroll_dx = 0;
    ptab->toprow = 0;
    ptab->pdata = NULL;
    ptab->nlines = 0;
    ptab->trackmode = TRACK_NONE;

    /* we have to notify owner of the current selection
     * whenever it is changed
     */
    ptab->select.id = id;
    gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);

    /* calc ave height/width, cell widths and min height.
     * these change only when cell properties / col count changes -
     * ie only on rebuild-header events
     */
    gtab_calcwidths(hwnd, ptab);
    return(ptab);
}

/* set sizes that are based on window size and scroll pos
 * set:
 *      winwidth
 *      nlines
 *      cellpos start, clip start/end
 * alloc linedata and init
 */
void
gtab_setsize(
            HWND hwnd,
            lpTable ptab
            )
{
    RECT rc;
    int nlines;
    HANDLE heap;
    long change;
    SCROLLINFO si;

    GetClientRect(hwnd, &rc);
    ptab->winwidth = rc.right - rc.left;
    nlines = (rc.bottom - rc.top) / ptab->rowheight;
    /* nlines is the number of whole lines - add one extra
     * for the partial line at the bottom
     */
    nlines += 1;

    /* alloc space for nlines of data - if nlines has changed */
    if (nlines != ptab->nlines) {
        heap = (HANDLE) GetWindowLongPtr(hwnd, WW_HEAP);
        gtab_freelinedata(heap, ptab);
        ptab->nlines = nlines;
        if (!gtab_alloclinedata(hwnd, heap, ptab)) {
            ptab->nlines = 0;
            return;
        }
    }

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set scroll vertical range */
    si.nMax = ptab->hdr.nrows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
        change =  -(ptab->toprow);
    } else if (ptab->toprow > si.nMax) {
        change = si.nMax - ptab->toprow;
    } else {
        change = 0;
    }
    /* the scroll range must be 16-bits for Win3
     * scale until this is true
     */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    gtab_dovscroll(hwnd, ptab, change);

    /* set horz scroll range */
    si.nMax = ptab->rowwidth;
    si.nPage = ptab->winwidth;
    if (si.nMax < 0) {
        si.nMax = 0;
        change = -(ptab->scroll_dx);
    } else if (ptab->scroll_dx > si.nMax) {
        change = si.nMax - ptab->scroll_dx;
    } else {
        change = 0;
    }
    /* horz scroll range will always be < 16 bits */
    SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
    gtab_dohscroll(hwnd, ptab, change);
}

/* set column widths/height and totals (based on column props)
 * - no assumption of window size (see gtab_setsize)
 * sets avewidth,rowheight,cellpos.size,rowwidth (total of cellpos.size)
 */
void
gtab_calcwidths(
               HWND hwnd,
               lpTable ptab
               )
{
    int i, cxtotal, cx, ave;
    TEXTMETRIC tm = {0};
    TEXTMETRIC tmcol = {0};
    HDC hdc;
    lpProps hdrprops, cellprops;
    HFONT hfont;

    hfont = NULL;  /* eliminate spurious diagnostic, make code worse */
    hdrprops = &ptab->hdr.props;
    hdc = GetDC(hwnd);
    if (hdc)
    {
        GetTextMetrics(hdc, &tm);
        ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
        if (hdrprops->valid & P_FONT) {
            hfont = SelectObject(hdc, hdrprops->hFont);
        }
        GetTextMetrics(hdc, &tm);
        if (hdrprops->valid & P_FONT) {
            SelectObject(hdc, hfont);
        }
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        // arbitrary, whatever...
        ptab->rowheight = 14;
        tm.tmHeight = 14;
        tm.tmAveCharWidth = 5;
    }

    /* get width and height of average character */
    ptab->avewidth = tm.tmAveCharWidth;
    if (tm.tmHeight + tm.tmExternalLeading < ptab->rowheight - 2 ||
        tm.tmHeight + tm.tmExternalLeading > ptab->rowheight) {
        // fudge so the default FixedSys (and anything of similar size)
        // doesn't vertically clip the System font used for line numbers,
        // filenames, etc.
        ptab->rowheight = tm.tmHeight;
        if (tm.tmExternalLeading)
            ptab->rowheight += tm.tmExternalLeading;
        else
            ptab->rowheight++;
    }
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set pixel width of each cell (and add up for row total)
     * based on ave width * nr chars, unless P_WIDTH set
     */
    cxtotal = 0;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {

            if (cellprops->valid & P_FONT) {
                hdc = GetDC(hwnd);
                if (hdc)
                {
                    hfont = SelectObject(hdc, cellprops->hFont);
                    GetTextMetrics(hdc, &tmcol);
                    SelectObject(hdc, hfont);
                    ReleaseDC(hwnd, hdc);
                    ave = tmcol.tmAveCharWidth;
                }
                else
                    ave = 5;        // arbitrary, whatever...
            } else {
                ave = ptab->avewidth;
            }
            /* ave width * nchars */
            cx =  ptab->pcolhdr[i].nchars + 1;
            cx *= ave;
        }
        /* add 2 pixels for box lines */
        cx += 2;
        ptab->pcellpos[i].size = cx;
        cxtotal += cx;
    }
    ptab->rowwidth = cxtotal;
}

/* called when row data + possible nrows changes.
 * other changes are ignored
 */
void
gtab_newsize(
            HWND hwnd,
            lpTable ptab
            )
{
    TableHdr hdr;

    /* get new row count */
    hdr = ptab->hdr;
    gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM) &hdr);
    if (hdr.nrows != ptab->hdr.nrows) {
        ptab->hdr.nrows = hdr.nrows;
        gtab_setsize(hwnd, ptab);
    }

    gtab_invallines(hwnd, ptab, 0, ptab->nlines);

    InvalidateRect(hwnd, NULL, FALSE);
}

void
gtab_invallines(
               HWND hwnd,
               lpTable ptab,
               int start,
               int count
               )
{
    int i, j;

    for (i = start; i < start + count; i++) {
        for (j = 0; j < ptab->hdr.ncols; j++) {
            ptab->pdata[i].pdata[j].flags = 0;
        }
    }
}

/* new rows have been added to the table. adjust the scroll range and
 * position, and redraw the rows if the end of the table is currently
 * visible.
 * rows = the new total row count.
 */
void
gtab_append(
           HWND hwnd,
           lpTable ptab,
           int rows,
           DWORD_PTR id
           )
{
    long oldrows;
    int line, nupdates;
    RECT rc;
    SCROLLINFO si;


    /* change to the new id */
    ptab->hdr.id = id;
    ptab->select.id = id;

    /* update the header, but remember the old nr of rows
     * so we know where to start updating
     */
    oldrows = ptab->hdr.nrows;

    /* check that the new nr of rows is not smaller. this is
     * illegal at this point and should be ignored
     */
    if (oldrows >= rows) {
        return;
    }

    ptab->hdr.nrows = rows;

    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE|SIF_RANGE;
    si.nMin = 0;

    /* set the vertical scroll range */
    si.nMax = rows;
    si.nPage = ptab->nlines;
    if (si.nMax < 0) {
        si.nMax = 0;
    }

    /* force the scroll range into 16-bits for win 3.1 */
    ptab->scrollscale = 1;
    while (si.nMax > 32766) {
        ptab->scrollscale *= 16;
        si.nMax /= 16;
        si.nPage /= 16;
    }
    if (!si.nPage)
        si.nPage = 1;

    /* now set the scroll bar range and position */
    SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
    if (si.nMax > 0) {
        SetScrollPos(hwnd, SB_VERT,
                     (int) (ptab->toprow / ptab->scrollscale), TRUE);
    }

    /* calculate which screen lines need to be updated - find what
     * screen line the start of the new section is at
     */
    line = gtab_rowtoline(hwnd, ptab, oldrows);
    if (line == -1) {
        /* not visible -> no more to do */
        return;
    }

    /* how many lines to update - rest of screen or nr of
     * new lines if less than rest of screen
     */
    nupdates = min((ptab->nlines - line), (int)(rows - oldrows));

    /* invalidate the screen line buffers to indicate data
     * needs to be refetch from parent window
     */
    gtab_invallines(hwnd, ptab, line, nupdates);

    /* calculate the region of the screen to be repainted -
     * left and right are same as window. top and bottom
     * need to be calculated from screen line height
     */

    GetClientRect(hwnd, &rc);
    rc.top += line * ptab->rowheight;
    rc.bottom = rc.top + (nupdates * ptab->rowheight);

    /* force a repaint of the updated region */
    InvalidateRect(hwnd, &rc, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\table.h ===
/*
 * table.h
 *
 * public interface definition for table window class.
 *
 * include after gutils.h and commdlg.h
 */

/*
 * The table class communicates with its 'owner' window to
 * get the layout info and the data to display. The owner window handle
 * can be sent as the lParam in CreateWindow - if not, the parent window will
 * be used.
 *
 * After creating the window, send it a TM_NEWID message, with a 'data id'
 * as the lParam. This is any non-zero 32-bit value. The table will then call
 * back to its owner window to find out how many rows/columns, then to fetch
 * the name/properties of each column, and finally to get the data to display.
 *
 * Send TM_NEWID of 0 to close (or destroy the window) - wait for TQ_CLOSE
 * (in either case) before discarding data. Send
 * TM_REFRESH if data or row-count changes; send TM_NEWLAYOUT if column
 * properties or nr cols change etc - this is the same as sending TM_NEWID
 * except that no TQ_CLOSE happens on TM_NEWLAYOUT.
 *
 * TQ_SELECT is sent whenever the current selection changes. TQ_ENTER is sent
 * when enter or double-click occurs.
 */

/* -------class and message names --------------------------------------*/

/* create a window of this class */
#define  TableClassName "GTableClass"


/* all messages to the owner window are sent with this message.
 * call RegisterWindowsMessage with this string for the message UINT.
 */
#define TableMessage  "GTableQuery"

/* -------- messages to and from table class  --------------------------*/

/* messages to owner window are:
 *	message:	TableMessage
 *	wParam:		command code (below)
 * 	lParam:		struct pointer according to code
 * below is list of wParam codes & associated lParam struct
 */
#define TQ_GETSIZE	1	/* lParam: lpTableHdr */
#define	TQ_GETCOLPROPS	2	/* lParam: lpColPropList */
#define TQ_GETDATA	3	/* lParam: lpCellDataList */
#define TQ_PUTDATA	4	/* lParam: lpCellDataList */
#define TQ_SELECT	5	/* lParam: lpTableSelection */
#define TQ_ENTER	6	/* lParam: lpTableSelection */
#define TQ_CLOSE	7	/* lParam: the data id to be closed */

/* optional */
#define TQ_SCROLL	8	/* lParam: the new top row nr */
#define TQ_TABS         9       /* lParam: LONG *, write tab here */
#define TQ_SHOWWHITESPACE  10   /* lParam: LONG *, write show_whitespace value here */

/* messages to Table class */

/* data, or nrows has changed  wParam/lParam null*/
#define TM_REFRESH	(WM_USER)

/* nr cols/props/layout has changed  - wparam/lparam null */
#define TM_NEWLAYOUT	(WM_USER+1)

/* close old id, and display new - wParam null, lParam has new id */
#define TM_NEWID	(WM_USER+2)

/* select and show this area - wParam null, lParam is lpTableSelection */
#define TM_SELECT	(WM_USER+3)

/* please print current table - wParam null, lParam either null
 * or lpPrintContext.
 */
#define TM_PRINT	(WM_USER+4)

/* return the top row in the window. If wParam is TRUE, then set
 * lParam to be the new toprow. top row is the number of rows scrolled down
 * from the top. Thus the first visible non-fixed row is toprow+fixedrows
 */
#define TM_TOPROW	(WM_USER+5)


/* return the end row visible. This is the 0-based rownr of the last
 * visible row in the window
 */
#define TM_ENDROW	(WM_USER+6)

/* new rows have been added to the end of the table, but no other
 * rows or cols or properties have been changed.
 * wParam contains the new total nr of rows. lParam contains the id
 * in case this has changed.
 */
#define TM_APPEND	(WM_USER+7)

/*
 * return the current selection - lParam is a lpTableSelection
 */
#define TM_GETSELECTION (WM_USER+8)

/*
 * set the tab width - wParam null, lParam is new tab width
 */
#define TM_SETTABWIDTH (WM_USER+9)

/*-----display properties -------------------------------------------------*/

/*
 * display properties struct. can be set for whole table, for
 * each column, or for each cell. When looking for
 * a property, we search cell->column->table
 */
typedef struct {
	UINT valid;		/* flags (below) for what props we set */

/* remaining fields only valid when corresponding flag set in valid */

	DWORD forecolour;	/* RGB colour value */
	DWORD forecolourws;	/* ditto */
	DWORD backcolour;	/* ditto */
	/* font to use - also set through WM_SETFONT. owner application
	 * is responsible for DeleteObject call when no longer used
	 */
	HFONT hFont;		/* handle to font  - caller should delete*/
	UINT alignment;		/* flags below */
	UINT box;		/* whether cell boxed (see below) */

	/* width/height settings not valid at cell level - only table or col.*/
	int width;		/* pixel width of this cell/column */
	int height;		/* pixel cell height */
} Props, FAR * lpProps;

/* valid flags for fields that are changed in this Props struct */
#define P_FCOLOUR	0x01
#define P_FCOLOURWS	0x02
#define P_BCOLOUR	0x04
#define P_FONT		0x08
#define P_ALIGN		0x10
#define P_BOX		0x20
#define P_WIDTH		0x40
#define P_HEIGHT	0x80

/* box settings  or-ed together */
#define P_BOXTOP	1
#define P_BOXBOTTOM	2
#define P_BOXLEFT	4
#define P_BOXRIGHT	8
#define P_BOXALL	0xF

/* alignment settings (expand later to include various tab-align settings */
#define P_LEFT		0
#define P_RIGHT		1
#define P_CENTRE	2

/* default tab width in chars */
#define TABWIDTH_DEFAULT      8

/* --- main header -------------------------------------------------------*/

/* this struct is the master information about a table. It is
 * passed to the owner window with the id field filled in; fill in
 * all remaining fields and return.
 */
typedef struct {
        DWORD_PTR id;           /* owner's data id */

	/* please fill in rest: */
	long nrows;		/* how many rows ? TM_REFRESH to change */
	int ncols;		/* how many columns ? TM_NEWLAYOUT to chg */

	int fixedrows;		/* for headers - usually 0 or 1 */
	int fixedcols;		/* for hdrs - 0 or 1 normally */
	BOOL fixedselectable;	/* is fixed area selectable ? */
	BOOL hseparator;	/* is there a horz. line after fixed rows */
	BOOL vseparator;	/* is there a vert. line after fixed rows */

	UINT selectmode;	/* multiple/single selection - flags below*/
	BOOL sendscroll;	/* TRUE if TQ_SCROLL to be sent on scrolling*/

	Props props;
} TableHdr, FAR * lpTableHdr;

/*
 * selection mode;
 *
 * choose TM_CELL or TM_ROW, and TM_SINGLE or TM_MANY, and
 * TM_SOLID or TM_FOCUS and or them together.
 *
 */
#define TM_ROW		1	/* selectable items are rows */
#define TM_CELL		0	/* selectable items are cells */

#define TM_MANY		2	/* multiple selects possible */
#define TM_SINGLE	0	/* single item selectable at once only */

#define TM_SOLID	0	/* (default) use a solid black for selection*/
#define TM_FOCUS	4	/* use a dotted focus rect for selection */


/* --------- column header structs --------------------------------------*/

/*
 * this struct is sent to request column width and properties -
 * owner window must fill nchars and props.valid, at minimum.
 */
typedef struct {
	int nchars;	/* expected text width in chars */
	Props props;
} ColProps, FAR * lpColProps;


/* this is a set of column requests - owner should fill each one*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	int startcol;		/* zero-based column nr of first request */
	int ncols;		/* nr of columns in this set */
	lpColProps plist;	/* ptr to _array_ of ColProps */
} ColPropsList, FAR * lpColPropsList;


/* --- cell data structs ---------------------------------------------*/

/* this is the per-cell data struct.
 * When providing data (responding to TQ_GETDATA), fill out ptext[] and
 * props as appropriate. ptext will be pre-allocated with nchars bytes of
 * space. This may be larger than ColProps->nchars if the user has
 * stretched this column's width on screen
 *
 * don't re-alloc ptext, or change flags.
 */
typedef struct {
	int nchars;		/* space in buffer */
	LPSTR ptext;		/* ptr to nchars of text space */
	Props props;		/* per-cell props */
	DWORD flags;		/* private table class flags */
	LPWSTR pwzText;		/* ptr to nchars of WCHAR space */
} CellData, FAR * lpCellData;

/* list of cell data structures - please fill out all of these*/
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long row;		/* zero-based row nr to fetch */
	int startcell;		/* zero-based cell nr on this row */
	int ncells;		/* count of cells to fetch */
	lpCellData plist;	/* ptr to array CellData[ncells] */
} CellDataList, FAR * lpCellDataList;


/*----- current selection----------------------------------------------*/

/*
 * describes the current selection - a rectangular selection area
 *
 * Note that if the TM_MANY selection mode is used, startrow and startcell will
 * be the end-point (most recently selected end) of the selection, and
 * nrows, ncells may be positive or negative. +1 and -1 both mean just the
 * 1 row startrow, -2 means startrow and the one before, etc. 0 nrows means
 * no valid selection.
 */
typedef struct {
        DWORD_PTR id;           /* caller's id for data */
	long startrow;		/* zero-based row nr of start of sel. */
	long startcell;		/* zero-based col nr of  start of sel */
	long nrows;		/* vertical depth of selection */
	long ncells;		/* horz width of selection */
	long dyRowsFromTop;		/* -1 means used auto-center logic, otherwise put selection this many rows from top */
} TableSelection, FAR * lpTableSelection;



/*----- print context -----------------------------------------------*/

/* describes the margin settings for the print job - these are in CMs*/
typedef struct {
	int left;		/* edge of paper to start of print area */
	int right;		/* edge of paper to start of print area */
	int top;		/* edge of paper to start of hdr */
	int bottom;		/* end of hdr to end of paper */
	int topinner;		/* start of hdr to start of data */
	int bottominner;	/* end of data to start of hdr */
} Margin, FAR * lpMargin;

/* position and clipping info - only used by table class
 */
typedef struct {
	int start;		/* co-ord of cell start (left or top) */
	int clipstart;		/* start of clipping (vis area) */
	int clipend;		/* end of clipping (vis area) */
	int size;		/* pixel size of cell (width or height) */
} CellPos, FAR * lpCellPos;


/* one of these for each header lines (top and bottom) */
typedef struct {
	CellPos xpos, ypos;	/* private: for table-class use only */
	Props props;
	LPSTR ptext;
} Title, FAR * lpTitle;

/* Print context data structure - any or all 4 pointers may be null */
typedef struct {
        DWORD_PTR id;           /* id of table to print */
	lpTitle head;
	lpTitle foot;
	lpMargin margin;
	PRINTDLG FAR * pd;
} PrintContext, FAR * lpPrintContext;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tprint.c ===
/*
 * standard table class.
 *
 * print functions.
 *
 * see table.h for interface description
 */

#include <string.h>

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"
#include "gutilsrc.h"

#include "table.h"
#include "tpriv.h"

/* in tpaint.c, calls GetTextExtentPoint */
extern int GetTextExtent(HDC, LPSTR, int);

extern HANDLE hLibInst;

/* function prototypes */
lpTable gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap,
                        lpPrintContext pcontext);
BOOL gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext
                    pcontext);
void gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext);
int APIENTRY AbortProc(HDC hpr, int code);
int APIENTRY AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam);
BOOL gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page);
void gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter);
void gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page);


/*
 * gtab_print
 */
BOOL
gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    BOOL fNoContext, fNoMargin, fNoPD;
    BOOL fSuccess = TRUE;
    lpTable ptab_prt;

    fNoContext = FALSE;
    fNoPD = FALSE;
    fNoMargin = FALSE;

    if (pcontext == NULL) {
        fNoContext = TRUE;
        pcontext = (lpPrintContext) gmem_get(heap,
                                             sizeof(PrintContext));
        pcontext->head = pcontext->foot = NULL;
        pcontext->margin = NULL;
        pcontext->pd = NULL;
        pcontext->id = 0;
    }
    if (pcontext->pd == NULL) {
        fNoPD = TRUE;
    }
    if (pcontext->margin == NULL) {
        fNoMargin = TRUE;
    }
    ptab_prt = gtab_printsetup(hwnd, ptab, heap, pcontext);

    if (ptab_prt != NULL) {
        gtab_printjob(hwnd, ptab_prt, pcontext);

        gtab_deltable(hwnd, ptab_prt);
    } else fSuccess = FALSE;
    if (fNoMargin) {
        gmem_free(heap, (LPSTR)pcontext->margin,
                  sizeof(Margin));
        pcontext->margin = NULL;
    }
    if (fNoPD) {
        if (pcontext->pd->hDevMode != NULL) {
            GlobalFree(pcontext->pd->hDevMode);
        }
        if (pcontext->pd->hDevNames != NULL) {
            GlobalFree(pcontext->pd->hDevNames);
        }
        gmem_free(heap, (LPSTR) pcontext->pd, sizeof(PRINTDLG));
        pcontext->pd = NULL;
    }
    if (fNoContext) {
        gmem_free(heap, (LPSTR) pcontext, sizeof(PrintContext));
    }
    return fSuccess;
}



/*
 * gtab_printsetup()
 *
 * sets up printercontext - builds lpTable for printer, incl. sizing
 * and initialises pcontext fields that may be null.
 */
lpTable
gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    lpTable pprttab;
    PRINTDLG FAR * pd;
    int ncols, i;
    ColPropsList cplist;

    /* set fields for context that user left null */
    if (pcontext->margin == NULL) {
        pcontext->margin = (lpMargin) gmem_get(heap, sizeof(Margin));
        if (pcontext->margin == NULL) {
            return(NULL);
        }
        pcontext->margin->left = 10;
        pcontext->margin->right = 10;
        pcontext->margin->top = 15;
        pcontext->margin->bottom = 15;
        pcontext->margin->topinner = 15;
        pcontext->margin->bottominner = 15;
    }

    if (pcontext->pd == NULL) {
        pd = (PRINTDLG FAR *) gmem_get(heap, sizeof(PRINTDLG));
        if (pd == NULL) {
            return(NULL);
        }
        pcontext->pd = pd;

        pd->lStructSize = sizeof(PRINTDLG);
        pd->hwndOwner = hwnd;
        pd->hDevMode = (HANDLE) NULL;
        pd->hDevNames = (HANDLE) NULL;
        pd->Flags = PD_RETURNDC|PD_RETURNDEFAULT;

        if (PrintDlg(pd) == FALSE) {
            return(NULL);
        }
    }

    /* now create a Table struct by querying the owner */
    pprttab = (lpTable) gmem_get(heap, sizeof(Table));

    if (pprttab == NULL) {
        return(NULL);
    }
    pprttab->hdr = ptab->hdr;

    /* get the row/column count from owner window */
    if (pcontext->id == 0) {
        pprttab->hdr.id = ptab->hdr.id;
    } else {
        pprttab->hdr.id = pcontext->id;
    }
    pprttab->hdr.props.valid = 0;
    pprttab->hdr.sendscroll = FALSE;
    if (gtab_sendtq(hwnd, TQ_GETSIZE, (LPARAM)&pprttab->hdr) == FALSE) {
        return(NULL);
    }

    /* alloc and init the col data structs */
    ncols = pprttab->hdr.ncols;
    pprttab->pcolhdr = (lpColProps) gmem_get(heap, sizeof(ColProps) * ncols);
    if (pprttab->pcolhdr == NULL) {
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }

    /* init col properties to default */
    for (i=0; i < ncols; i++) {
        pprttab->pcolhdr[i].props.valid = 0;
        pprttab->pcolhdr[i].nchars = 0;
    }
    /* get the column props from owner */
    cplist.plist = pprttab->pcolhdr;
    cplist.id = pprttab->hdr.id;
    cplist.startcol = 0;
    cplist.ncols = ncols;
    gtab_sendtq(hwnd, TQ_GETCOLPROPS, (LPARAM)&cplist);


    pprttab->scrollscale = 1;
    pprttab->pcellpos = (lpCellPos) gmem_get(heap,
                                             sizeof(CellPos) * ptab->hdr.ncols);
    if (pprttab->pcellpos == NULL) {
        gmem_free(heap, (LPSTR) pprttab->pcolhdr, sizeof(ColProps) * ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }


    pprttab->pdata = NULL;
    pprttab->nlines = 0;

    if (!gtab_prtwidths(hwnd, pprttab, heap, pcontext)) {
        gmem_free(heap, (LPSTR)pprttab->pcellpos,
                  sizeof(CellPos) * ptab->hdr.ncols);
        gmem_free(heap, (LPSTR)pprttab, sizeof(Table));
        return(NULL);
    }
    return(pprttab);
}


/* calc the height/width settings and alloc line data */
BOOL
gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext)
{
    TEXTMETRIC tm;
    int cx, cxtotal, i, curx, cury;
    lpProps hdrprops, cellprops;
    lpCellPos xpos, ypos;
    RECT rcinner, rcouter;

    hdrprops = &ptab->hdr.props;
    GetTextMetrics(pcontext->pd->hDC, &tm);
    ptab->avewidth = tm.tmAveCharWidth;
    ptab->rowheight = tm.tmHeight + tm.tmExternalLeading;
    if (hdrprops->valid & P_HEIGHT) {
        ptab->rowheight = hdrprops->height;
    }

    /* set sizes for headers */
    gtab_setrects(pcontext, &rcinner, &rcouter);

    /* set width/pos for each col. */
    cxtotal = 0;
    curx = rcinner.left;
    for (i = 0; i < ptab->hdr.ncols; i++) {
        cellprops = &ptab->pcolhdr[i].props;
        xpos = &ptab->pcellpos[i];

        if (cellprops->valid & P_WIDTH) {
            cx = cellprops->width;
        } else if (hdrprops->valid & P_WIDTH) {
            cx = hdrprops->width;
        } else {
            cx = ptab->pcolhdr[i].nchars + 1;
            cx *= ptab->avewidth;
        }
        /* add 2 for intercol spacing */
        cx += 2;

        xpos->size = cx;
        xpos->start = curx + 1;
        xpos->clipstart = xpos->start;
        xpos->clipend = xpos->start + xpos->size - 2;
        xpos->clipend = min(xpos->clipend, rcinner.right);

        cxtotal += xpos->size;
        curx += xpos->size;
    }
    ptab->rowwidth = cxtotal;

    if (pcontext->head != NULL) {
        xpos = &pcontext->head->xpos;
        ypos = &pcontext->head->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.top;
        ypos->clipstart = rcouter.top;
        ypos->clipend = rcinner.top;
        ypos->size = ptab->rowheight;
    }

    if (pcontext->foot != NULL) {
        xpos = &pcontext->foot->xpos;
        ypos = &pcontext->foot->ypos;

        xpos->start = rcouter.left + 1;
        xpos->clipstart = rcouter.left + 1;
        xpos->clipend = rcouter.right - 1;
        xpos->size = rcouter.right - rcouter.left;

        ypos->start = rcouter.bottom - ptab->rowheight;
        ypos->clipstart = rcinner.bottom;
        ypos->clipend = rcouter.bottom;
        ypos->size = ptab->rowheight;
    }

    /* set nr of lines per page */
    ptab->nlines = (rcinner.bottom - rcinner.top) / ptab->rowheight;
    if (!gtab_alloclinedata(hwnd, heap, ptab)) {
        return(FALSE);
    }
    /* set line positions */
    cury = rcinner.top;
    for (i = 0; i < ptab->nlines; i++) {
        ypos = &ptab->pdata[i].linepos;
        ypos->start = cury;
        ypos->clipstart = ypos->start;
        ypos->clipend = ypos->start + ypos->size;
        ypos->clipend = min(ypos->clipend, rcinner.bottom);
        cury += ypos->size;
    }
    return(TRUE);
}


/* static information for this module */
BOOL bAbort;
FARPROC lpAbortProc;
DLGPROC lpAbortDlg;
HWND hAbortWnd;
int npage;
int pages;

void
gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext)
{
    int moveables;
    int endpage;
    int startpage = 1;
    HDC hpr;
    int status;
    HANDLE hcurs;
    static char str[256];
    DOCINFO di;
    TCHAR szPage[60];  /* for LoadString */

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    pages = (int) (ptab->hdr.nrows - ptab->hdr.fixedrows + moveables - 1)
            / moveables;
    endpage = pages;

    if (pcontext->pd->Flags & PD_PAGENUMS) {
        startpage = pcontext->pd->nFromPage;
        endpage = pcontext->pd->nToPage;
    }
    hpr = pcontext->pd->hDC;

    lpAbortDlg = (DLGPROC) MakeProcInstance((WINPROCTYPE) AbortDlg, hLibInst);
    lpAbortProc = (FARPROC) MakeProcInstance((WINPROCTYPE)AbortProc, hLibInst);

    SetAbortProc(hpr, (ABORTPROC) lpAbortProc);

    di.lpszDocName = "Table";
    di.cbSize = lstrlen(di.lpszDocName);
    di.lpszOutput = NULL;
    di.lpszDatatype = NULL;
    di.fwType = 0;

    StartDoc(hpr, &di);

    bAbort = FALSE;

    /* add abort modeless dialog later!! */
    hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, lpAbortDlg);
    if (hAbortWnd != NULL) {
        ShowWindow(hAbortWnd, SW_NORMAL);
        EnableWindow(hwnd, FALSE);
    }
    SetCursor(hcurs);


    status = 0;  /* kills a "used without init" diagnostic */
    for (npage = startpage; npage<=endpage; npage++) {
        LoadString(hLibInst,IDS_PAGE_STR,szPage,sizeof(szPage));
        wsprintf(str, szPage,  npage, pages);
        if (hAbortWnd != NULL)
            SetDlgItemText(hAbortWnd, IDC_LPAGENR, str);
        status = gtab_printpage(hwnd, ptab, pcontext, npage);
        if (status < 0) {
            AbortDoc(hpr);
            break;
        }
    }
    if (status >= 0) {
        EndDoc(hpr);
    }

    if (hAbortWnd != NULL) {
        EnableWindow(hwnd, TRUE);
        DestroyWindow(hAbortWnd);
    }
    FreeProcInstance((WINPROCTYPE) lpAbortDlg);
    FreeProcInstance(lpAbortProc);

    DeleteDC(hpr);
}

int APIENTRY
AbortProc(HDC hpr, int code)
{

    MSG msg;

    if (!hAbortWnd) {
        return(TRUE);
    }
    while (!bAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!IsDialogMessage(hAbortWnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return(!bAbort);
}

int APIENTRY
AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam)
{
    switch (msg) {

        case WM_COMMAND:
            bAbort = TRUE;
            EndDialog(hdlg, TRUE);
            return TRUE;

        case WM_INITDIALOG:
            return TRUE;
    }
    return(FALSE);
}

/*
 * print a single page. page number is 1-based
 */
BOOL
gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page)
{
    HDC hpr;
    int moveables, i;
    int x1, y1, x2, y2;

    hpr = pcontext->pd->hDC;
    StartPage(hpr);

    moveables = ptab->nlines - ptab->hdr.fixedrows;
    ptab->toprow = moveables * (page-1);
    gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows, moveables);

    for (i =0; i < ptab->nlines; i++) {
        gtab_paintline(hwnd, hpr, ptab, i, FALSE);
    }
    if ((ptab->hdr.vseparator) && (ptab->hdr.fixedcols > 0)) {
        x1 = ptab->pcellpos[ptab->hdr.fixedcols -1].clipend+1;
        y1 = ptab->pdata[0].linepos.clipstart;
        y2 = ptab->pdata[ptab->nlines-1].linepos.clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x1, y2);
    }
    if ((ptab->hdr.hseparator) && (ptab->hdr.fixedrows > 0)) {
        y1 = ptab->pdata[ptab->hdr.fixedrows-1].linepos.clipend;
        x1 = ptab->pcellpos[0].clipstart;
        x2 = ptab->pcellpos[ptab->hdr.ncols-1].clipend;
        MoveToEx(hpr, x1, y1, NULL);
        LineTo(hpr, x2, y1);
    }

    if (pcontext->head != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->head, page);
    }
    if (pcontext->foot != NULL) {
        gtab_printhead(hwnd, hpr, ptab, pcontext->foot, page);
    }

    return(EndPage(hpr));
}


/*
 * calculate the outline positions in pixels for the headers
 * (outer rect) and for the page itself (inner rect). Based on
 * page size and PrintContext margin info (which is in millimetres).
 */
void
gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter)
{
    HDC hpr;
    int hpixels, hmms;
    int vpixels, vmms;
    int h_pixpermm, v_pixpermm;

    hpr = pcontext->pd->hDC;
    hpixels = GetDeviceCaps(hpr, HORZRES);
    vpixels = GetDeviceCaps(hpr, VERTRES);
    vmms = GetDeviceCaps(hpr, VERTSIZE);
    hmms = GetDeviceCaps(hpr, HORZSIZE);

    h_pixpermm = hpixels / hmms;
    v_pixpermm = vpixels / vmms;

    rcouter->top = (pcontext->margin->top * v_pixpermm);
    rcouter->bottom = vpixels - (pcontext->margin->bottom * v_pixpermm);
    rcouter->left = (pcontext->margin->left * h_pixpermm);
    rcouter->right = hpixels - (pcontext->margin->right * h_pixpermm);

    rcinner->left = rcouter->left;
    rcinner->right = rcouter->right;
    rcinner->top = rcouter->top +
                   (pcontext->margin->topinner * v_pixpermm);
    rcinner->bottom = rcouter->bottom -
                      (pcontext->margin->bottominner * v_pixpermm);
}


void
gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page)
{
    RECT rc, rcbox;
    int i, cx, x, y, tab;
    UINT align;
    LPSTR chp, tabp;
    DWORD fcol, bkcol;
    char str[256];

    fcol = 0; bkcol = 0;  /* eliminate spurious diagnostic - generate worse code */

    rc.top = head->ypos.clipstart;
    rc.bottom = head->ypos.clipend;
    rc.left = head->xpos.clipstart;
    rc.right = head->xpos.clipend;

    /* update page number */
    chp = str;
    for (i = 0; i < lstrlen(head->ptext); i++) {
        switch (head->ptext[i]) {

            case '#':
                chp += wsprintf(chp, "%d", page);
                break;

            case '$':
                chp += wsprintf(chp, "%d", pages);
                break;

            default:
                if (IsDBCSLeadByte(head->ptext[i]) &&
                    head->ptext[i+1])
                {
                    *chp = head->ptext[i];
                    chp++;
                    i++;
                }
                *chp++ = head->ptext[i];
                break;
        }
    }
    *chp = '\0';
    chp = str;

    if (head->props.valid & P_ALIGN) {
        align = head->props.alignment;
    } else {
        align = P_LEFT;
    }

    /* set colours if not default */
    if (head->props.valid & P_FCOLOUR) {
        fcol = SetTextColor(hdc, head->props.forecolour);
    }
    if (head->props.valid & P_BCOLOUR) {
        bkcol = SetBkColor(hdc, head->props.backcolour);
    }

    /* calc offset of text within cell for right-align or centering */
    if (align == P_LEFT) {
        cx = ptab->avewidth/2;
    } else {
        cx = LOWORD(GetTextExtent(hdc, chp, lstrlen(chp)));
        if (align == P_CENTRE) {
            cx = (head->xpos.size - cx) / 2;
        } else {
            cx = head->xpos.size - cx - (ptab->avewidth/2);
        }
    }
    cx += head->xpos.start;

    /* expand tabs on output */
    tab = ptab->avewidth * ptab->tabchars;
    x = 0;
    y = head->ypos.start;

    for ( ; (tabp = My_mbschr(chp, '\t')) != NULL; ) {
        /* perform output upto tab char */
        ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, (UINT)(tabp-chp), NULL);

        /* advance past the tab */
        x += LOWORD(GetTextExtent(hdc, chp, (INT)(tabp - chp)));
        x = ( (x + tab) / tab) * tab;
        chp = ++tabp;
    }

    /*no more tabs - output rest of string */
    ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, lstrlen(chp), NULL);

    /* reset colours to original if not default */
    if (head->props.valid & P_FCOLOUR) {
        SetTextColor(hdc, fcol);
    }
    if (head->props.valid & P_BCOLOUR) {
        SetBkColor(hdc, bkcol);
    }

    /* now box cell if marked */
    if (head->props.valid & P_BOX) {
        if (head->props.box != 0) {
            rcbox.top = head->ypos.start;
            rcbox.bottom = rcbox.top + head->ypos.size;
            rcbox.left = head->xpos.start;
            rcbox.right = rcbox.left + head->xpos.size;
            gtab_boxcell(hwnd, hdc, &rcbox, &rc, head->props.box);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tree.c ===
/*
 * tree.c
 *
 * data type providing a map between a KEY and a VALUE. The KEY is a
 * 32-bit DWORD, and the VALUE is any arbitrary area of storage.
 *
 * memory is allocated from gmem_get, using hHeap as the heap handle.
 * hHeap must be declared and initialised elsewhere.
 *
 * currently implemented as a unbalanced binary tree.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <memory.h>
#include "gutils.h"

#include "tree.h"


/* -- data types ----------------------------------------------- */

/* on creating a tree, we return a TREE handle. This is in fact a pointer
 * to a struct tree, defined here.
 */
struct tree {
    HANDLE hHeap;
    TREEITEM first;
};

/* each element in the tree is stored in a TREEITEM. a TREEITEM handle
 * is a pointer to a struct treeitem, defined here
 */
struct treeitem {
    TREE root;
    TREEKEY key;
    TREEITEM left, right;
    UINT length;        /* length of the user's data */
    LPVOID data;        /* pointer to our copy of the users data */
};

/* -- internal functions ---------------------------------------------*/

/* free up an element of the tree. recursively calls itself to
 * free left and right children
 */
void
tree_delitem(TREEITEM item)
{
    if (item == NULL) {
        return;
    }
    if (item->left != NULL) {
        tree_delitem(item->left);
    }
    if (item->right != NULL) {
        tree_delitem(item->right);
    }
    if (item->data != NULL) {
        gmem_free(item->root->hHeap, item->data, item->length);
    }

    gmem_free(item->root->hHeap, (LPSTR) item, sizeof(struct treeitem));
}

/* create a new treeitem, with a data block of length bytes.
 * if the value pointer is not NULL, initialise the data block with
 * the contents of value.
 */
TREEITEM
tree_newitem(TREE root, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    item = (TREEITEM) gmem_get(root->hHeap, sizeof(struct treeitem));

    item->root = root;
    item->key = key;
    item->left = NULL;
    item->right = NULL;
    item->length = length;
    item->data = gmem_get(root->hHeap, length);
    if (value != NULL) {
        memcpy(item->data, value, length);
    }

    return(item);
}


/* find the item with the given key. if it does not exist, return
 * the parent item to which it would be attached. returns NULL if
 * no items in the tree
 */
TREEITEM
tree_getitem(TREE tree, TREEKEY key)
{
    TREEITEM item, prev;


    prev = NULL;
    for (item = tree->first; item != NULL; ) {

        if (item->key == key) {
            return(item);
        }

        /* not this item - go on to the correct child item.
         * remember this item as if the child is NULL, this item
         * will be the correct insertion point for the new item
         */
        prev = item;

        if (key < item->key) {
            item = item->left;
        } else {
            item = item->right;
        }
    }
    /* prev is the parent - or null if nothing in tree */
    return(prev);
}

/* --- external functions ------------------------------------------ */

/*
 * create an empty tree. hHeap is the handle to use for all
 * memory allocations for this tree.
 */
TREE APIENTRY
tree_create(HANDLE hHeap)
{
    TREE tree;

    tree = (TREE) gmem_get(hHeap, sizeof(struct tree));
    tree->first = NULL;
    tree->hHeap = hHeap;
    return(tree);
}


/*
 * delete an entire tree, including all the user data
 */
void APIENTRY
tree_delete(TREE tree)
{

    tree_delitem(tree->first);

    gmem_free(tree->hHeap, (LPSTR) tree, sizeof(struct tree));
}

/*
 * add a new element to the tree, mapping the key given to the value given.
 * The value is a block of storage: a copy of this is inserted into the tree.
 * we return a pointer to the copy of the data in the tree.
 *
 * the value pointer can be NULL: in this case, we insert a block of
 * length bytes, but don't initialise it. you get a pointer to it and
 * can initialise it yourself.
 *
 * if the key already exists, the value will be replaced with the new data.
 */
LPVOID APIENTRY
tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;

    /* find the place in the tree for this key to go */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* there is nothing in the tree: this item should
         * go at the top
         */
        tree->first = tree_newitem(tree, key, value, length);
        return(tree->first->data);
    }

    /* is this the same key ? */
    if (item->key == key) {

        /* this key already inserted. re-alloc the data */
        if (length != item->length) {
            gmem_free(tree->hHeap, item->data, item->length);
            item->data = gmem_get(tree->hHeap, length);
        }
        /* don't initialise block if no pointer passed */
        if (value != NULL) {
            memcpy(item->data, value, length);
        }
        return(item->data);
    }

    /* not the same key - getitem returned the parent for
     * the new tree. insert it as a child of item.
     */
    return(tree_addafter(tree, &item, key, value, length));
}

/*
 * return a pointer to the value (data block) for a given key. returns
 * null if not found.
 */
LPVOID APIENTRY
tree_find(TREE tree, TREEKEY key)
{
    TREEITEM item;

    /* find the correct place in the tree */
    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* nothing in the tree */
        return(NULL);
    }

    if (item->key != key) {
        /* this key not in. getitem has returned parent */
        return(NULL);
    }

    /* found the right element - return pointer to the
     * data block
     */
    return(item->data);
}

/*
 * next two routines are an optimisation for a common tree operation. in
 * this case, the user will want to insert a new element only if
 * the key is not there. if it is there, he will want to modify the
 * existing value (increment a reference count, for example).
 *
 * if tree_search fails to find the key, it will return a TREEITEM handle
 * for the parent. This can be passed to tree_addafter to insert the
 * new element without re-searching the tree.
 */

/*
 * find an element. if not, find it's correct parent item
 */
LPVOID APIENTRY
tree_search(TREE tree, TREEKEY key, PTREEITEM pplace)
{
    TREEITEM item;

    item = tree_getitem(tree, key);

    if (item == NULL) {
        /* no items in tree. set placeholder to NULL to
         * indicate insert at top of tree
         */
        *pplace = NULL;

        /* return NULL to indicate key not found */
        return(NULL);
    }

    if (item->key == key) {
        /* found the key already there -
         * set pplace to null just for safety
         */
        *pplace = NULL;

        /* give the user a pointer to his data */
        return(item->data);
    }


    /* key was not found - getitem has returned the parent
     * - set this as the place for new insertions
     */
    *pplace = item;

    /* return NULL to indicate that the key was not found */
    return(NULL);
}

/*
 * insert a key in the position already found by tree_search.
 *
 * return a pointer to the user's data in the tree. if the value
 * pointer passed in is null, then we allocate the block, but don't
 * initialise it to anything.
 */
LPVOID APIENTRY
tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item, child;

    item = *place;
    if (item == NULL) {
        tree->first = tree_newitem(tree, key, value, length);
        return (tree->first->data);
    }

    child = tree_newitem(tree, key, value, length);
    if (child->key < item->key ) {
        /* should go on left leg */
        if (item->left != NULL) {
            Trace_Error(NULL, "TREE: left leaf leg not free", FALSE);

        }
        item->left = child;
    } else {
        if (item->right != NULL) {
            Trace_Error(NULL, "TREE: right leaf leg not free", FALSE);
        }
        item->right = child;
    }
    return(child->data);
}


/* --- ctree ------------------------------------------------------*/

/*
 * ctree is a class of tree built on top of the tree interface. a
 * ctree keeps count of the number of insertions of identical keys.
 *
 * we do this be adding a long counter to the beginning of the user
 * data before inserting into the tree. if the key is not found, we set
 * this to one. If the key was already there, we *do not* insert the
 * data (data is always from the first insertion) - we simply increment
 * the count.
 */

/*
 * create a tree for use by CTREE - same as an ordinary tree
 */
TREE APIENTRY
ctree_create(HANDLE hHeap)
{
    return(tree_create(hHeap));
}

/*
 * delete a ctree - same as for TREE
 */
void APIENTRY
ctree_delete(TREE tree)
{
    tree_delete(tree);
}


/* insert an element in the tree. if the element is not there,
 * insert the data and set the reference count for this key to 1.
 * if the key was there already, don't change the data, just increment
 * the reference count
 *
 * if the value pointer is not null, we initialise the value block
 * in the tree to contain this.
 *
 * we return a pointer to the users data in the tree
 */
LPVOID APIENTRY
ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length)
{
    TREEITEM item;
    LONG_PTR FAR * pcounter;
    LPVOID datacopy;

    pcounter = tree_search(tree, key, &item);

    if (pcounter == NULL) {
        /* element not found - insert a new one
         * the data block for this element should be
         * the user's block with our reference count at
         * the beginning
         */
        pcounter = tree_addafter(tree, &item, key, NULL,
                                 length + sizeof(LONG_PTR));
        *pcounter = 1;
        /* add on size of one long to get the start of the user
         * data
         */
        datacopy = pcounter + 1;
        if (value != NULL) {
            memcpy(datacopy, value, length);
        }
        return(datacopy);
    }

    /* key was already there - increment reference count and
     * return pointer to data
     */

    (*pcounter)++;

    /* add on size of one long to get the start of the user
     * data
     */
    datacopy = pcounter + 1;
    return(datacopy);
}

/* return the reference count for this key */
long APIENTRY
ctree_getcount(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;

    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }
    return((long)*pcounter);
}

/* return a pointer to the user's data block for this key,
 * or NULL if key not present
 */
LPVOID APIENTRY
ctree_find(TREE tree, TREEKEY key)
{
    LONG_PTR FAR * pcounter;


    pcounter = tree_find(tree, key);
    if (pcounter == NULL) {
        return(0);
    }

    /* increment pointer by size of 1 long to point to
     * user's datablock
     */
    return(pcounter+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tpriv.h ===
/*
 * tpriv.h
 *
 * data structures used internally by table class.
 *
 * include after table.h
 */


#ifndef abs
#define abs(x)  (((x) > 0)? (x) : -(x))
#endif

/*  one of these per visible line */
typedef struct {
        CellPos linepos;        /* posn and clipping info for line */

        lpCellData pdata;       /* array of CellData structs for all cells */
} LineData, *lpLineData;


/* master info struct pointed to by window extra bytes */

typedef struct {
        /* table info */
        TableHdr        hdr;            /* main hdr info from owner */
        lpColProps      pcolhdr;        /* ptr to array of phdr->ncols hdrs */

        /* window info */
        int     avewidth;       /* font ave width - for default cell sizing */
        int     rowheight;      /* height of one row */
        int     rowwidth;       /* total width of one row in pixels */
        int     winwidth;       /* width of window */
        int     nlines;         /* actual lines currently visible */

        lpCellPos pcellpos;     /* array of cell position structs */

        /* scroll settings */
        long    scrollscale;    /* scaling factor (force 16-bit range) */
        long    toprow;         /* 0-based rownr of top moveable line */
        int     scroll_dx;      /* horz scroll posn in pixels. */

        /* column data */
        lpLineData pdata;       /* ptr to array of nlines of LineData */

        /* selection/dragging */
        UINT    trackmode;      /* current mouse-tracking mode */
        int     tracknr;        /* col or row being resized */
        int     trackline1;     /* currently drawn track lines */
        int     trackline2;
        BOOL    selvisible;     /* used during mouse-down: T if sel drawn */
        TableSelection select;

        // tab expansion
        int     tabchars;

        // show whitespace chars
        BOOL    show_whitespace;

} Table, *lpTable;

/* trackmode constants */
#define TRACK_NONE              0
#define TRACK_COLUMN            1
#define TRACK_CELL              2

/* private flags in CellData struct */
#define CELL_VALID      1

/* window extra bytes are used to hold the owner, heap and Table structs */
#define WW_OWNER        0                               /* HWND of owner */
#define WW_HEAP         (WW_OWNER + sizeof(HWND))       /* gmem heap */
#define WL_TABLE        (WW_HEAP + sizeof(HANDLE))      /* lpTable */
#define WLTOTAL         (WL_TABLE + sizeof(lpTable))    /* total extra bytes */

/* ---------- global data -------------------*/

extern HPEN hpenDotted;         /* in table.c */
extern HANDLE hVertCurs;        /* in table.c */
extern HANDLE hNormCurs;        /* in table.c */

/*------function prototypes ---------------------------------------*/

/* in table.c */

void gtab_init(void);    /* called from DLL startup function */
INT_PTR gtab_sendtq(HWND hwnd, UINT cmd, LPARAM lParam);
void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count);
void gtab_setsize(HWND hwnd, lpTable ptab);
void gtab_calcwidths(HWND hwnd, lpTable ptab);
void gtab_deltable(HWND hwnd, lpTable ptab);
BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab);

/* in tpaint.c */
void gtab_paint(HWND hwnd);
void gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace);
void gtab_paintunused(HWND hwnd, HDC hdc, lpTable ptab, int y);
void gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc);
void gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in);
void gtab_drawvertline(HWND hwnd, lpTable ptab);

/* in tscroll.c */
void gtab_dovscroll(HWND hwnd, lpTable ptab, long change);
void gtab_dohscroll(HWND hwnd, lpTable ptab, long change);
long gtab_linetorow(HWND hwnd, lpTable ptab, int line);
int gtab_rowtoline(HWND hwnd, lpTable ptab, long row);
void gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos);
void gtab_select(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells, BOOL bNotify);
void gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows, long ncells);
void gtab_press(HWND hwnd, lpTable ptab, int x, int y);
void gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_release(HWND hwnd, lpTable ptab, int x, int y);
void gtab_move(HWND hwnd, lpTable ptab, int x, int y);
void gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y);
void gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom);
void gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop);
int gtab_key(HWND hwnd, lpTable ptab, int vkey);
int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta);

/* in tprint.c */
BOOL gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext);
void gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tpaint.c ===
/*
 * standard table class.
 *
 * paint functions.
 *
 * see table.h for interface description
 */

#include <string.h>


#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"

#ifdef WIN32

int
GetTextExtent(HDC hdc, LPSTR text, INT len)
{
    SIZE sz;

    GetTextExtentPoint(hdc, text, len, &sz);
    return(sz.cx);
}
#endif

void gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count);

/* change all cr/lf chars in input text to nul chars (used to be spaces, not sure why) */
void gtab_delcr(LPSTR ptext)
{
	LPSTR chp;

	if (ptext == NULL) {
		return;
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\r')) != NULL; ) {
		*chp = '\0';
	}
	for(chp = ptext; (chp = My_mbschr(chp, '\n')) != NULL; ) {
		*chp = '\0';
	}
}
void gtab_delcrW(LPWSTR pwzText)
{
	LPWSTR pwch;

	if (pwzText)
		for(pwch = pwzText; *pwch; pwch++)
			if (*pwch == '\r' || *pwch == '\n')
				*pwch = 0;
}

/* ensure that all visible cells in the given line have valid
 * text and property contents. loop through the cells, picking out
 * contiguous blocks of visible, invalid cells and call
 * gtab_updatecontig to update these from the owner window.
 */
void
gtab_updateline(HWND hwnd, lpTable ptab, int line)
{
	lpCellPos ppos;
	int cell1, cellcount;
	lpLineData pline;
	lpCellData cd;
	int i;
	if (line < ptab->hdr.nrows) {
	pline = &ptab->pdata[line];
	cell1 = 0;
	cellcount = 0;
	for (i = 0; i < ptab->hdr.ncols; i++) {
		ppos = &ptab->pcellpos[i];
		cd = &pline->pdata[i];
		if (ppos->clipstart < ppos->clipend) {
			if ((cd->flags & CELL_VALID) == 0) {
				/* add a cell to the list to be updated*/
				if (cellcount++ == 0) {
					cell1 = i;
				}
			} else {
				/* this cell already valid - so end of
				 * a contig block. if the contig
				 * block just ended contained cells to update,
				 * do it now
				 */
				if (cellcount > 0) {
					gtab_updatecontig(hwnd, ptab,
					  line, cell1, cellcount);
				}
				cellcount = 0;
			}
		}
		/* cell not visible - end of a contig block. If it was a
		 * non-empty contig block, then update it now.
		 */
		if (cellcount > 0)  {
			gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
			cellcount = 0;	
		}
	}
	if (cellcount > 0) {
		gtab_updatecontig(hwnd, ptab, line, cell1, cellcount);
		cellcount = 0;
	}
	}
}	

/*
 * update a contiguous block of invalid cells by calling the owner window
 */
void
gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count)
{
	lpLineData pline;
	lpCellData cd;
	CellDataList list;
	lpProps colprops;
	int i;
	COLORREF rgb;

	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell1];

	list.id = ptab->hdr.id;
	list.row = gtab_linetorow(hwnd, ptab, line);
	list.startcell = cell1;
	list.ncells = count;
	list.plist = cd;

	/* clear out prop flags */
	rgb = GetSysColor(COLOR_WINDOW);
	for (i = 0; i < count; i++) {
		cd[i].props.valid = P_BCOLOUR;
		cd[i].props.backcolour = rgb;
		if (cd[i].nchars > 0) {
			cd[i].ptext[0] = '\0';
			if (cd[i].pwzText) {
				cd[i].pwzText[0] = '\0';
			}
		}
	}

	if (list.row < ptab->hdr.nrows) {
		gtab_sendtq(hwnd, TQ_GETDATA, (LPARAM) &list);
	}

	/* for each cell, mark valid and set properties */
	for (i = 0; i < count; i++) {
		cd[i].flags |= CELL_VALID;
		gtab_delcr(cd[i].ptext);
		gtab_delcrW(cd[i].pwzText);
		/* fetch properties from hdr and colhdr */
		colprops = &ptab->pcolhdr[i + cell1].props;
		if (!(cd[i].props.valid & P_FCOLOUR)) {
			if (colprops->valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour = colprops->forecolour;
			} else if (ptab->hdr.props.valid & P_FCOLOUR) {
				cd[i].props.valid |= P_FCOLOUR;
				cd[i].props.forecolour =
					ptab->hdr.props.forecolour;
			}
		}

		if (!(cd[i].props.valid & P_FCOLOURWS)) {
			if (colprops->valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws = colprops->forecolourws;
			} else if (ptab->hdr.props.valid & P_FCOLOURWS) {
				cd[i].props.valid |= P_FCOLOURWS;
				cd[i].props.forecolourws =
					ptab->hdr.props.forecolourws;
			}
		}

		if (!(cd[i].props.valid & P_BCOLOUR)) {
			if (colprops->valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour = colprops->backcolour;
			} else if (ptab->hdr.props.valid & P_BCOLOUR) {
				cd[i].props.valid |= P_BCOLOUR;
				cd[i].props.backcolour =
					ptab->hdr.props.backcolour;
			}
		}

		if (!(cd[i].props.valid & P_FONT)) {
			if (colprops->valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = colprops->hFont;
			} else if (ptab->hdr.props.valid & P_FONT) {
				cd[i].props.valid |= P_FONT;
				cd[i].props.hFont = ptab->hdr.props.hFont;
			}
		}

		if (!(cd[i].props.valid & P_ALIGN)) {
			if (colprops->valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment = colprops->alignment;
			} else if (ptab->hdr.props.valid & P_ALIGN) {
				cd[i].props.valid |= P_ALIGN;
				cd[i].props.alignment =
					ptab->hdr.props.alignment;
			}
		}

		if (!(cd[i].props.valid & P_BOX)) {
			if (colprops->valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = colprops->box;
			} else if (ptab->hdr.props.valid & P_BOX) {
				cd[i].props.valid |= P_BOX;
				cd[i].props.box = ptab->hdr.props.box;
			}
		}
		/* you can't set width/height per cell - this
		 * is ignored at cell level.
		 */
	}

}

void
gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode)
{
	if (boxmode & P_BOXTOP) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top));
	}
	if (boxmode & P_BOXBOTTOM) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
	if (boxmode & P_BOXLEFT) {
		MoveToEx(hdc, max(rcp->left, pclip->left),
			max(rcp->top, pclip->top), NULL);
		MoveToEx(hdc, max(rcp->left, pclip->left),
			min(rcp->bottom, pclip->bottom), NULL);
	}
	if (boxmode & P_BOXRIGHT) {
		MoveToEx(hdc, min(rcp->right, pclip->right),
			max(rcp->top, pclip->top), NULL);
		LineTo(hdc, min(rcp->right, pclip->right),
			min(rcp->bottom, pclip->bottom));
	}
}

void
gtab_paintcell(HWND hwnd, HDC hdc, lpTable ptab, int line, int cell, BOOL show_whitespace)
{
	lpLineData pline;
	lpCellData cd;
	lpCellPos ppos;
	RECT rc, rcbox;
	int cx, x, y;
	UINT align;
	LPSTR chp, tabp;
	LPWSTR pwch, pwchBreak;
	DWORD fcol, fcolOld, fcolws;
	DWORD bkcol, bkcolOld;
	HFONT hfont, hfontOld;
	HBRUSH hbr;
	char szCharSet[] = "\t ";
	WCHAR wzCharSet[] = L"\t ";
	char szSpaceReplace[] = { (char) 183, (char) 0 };
	char szTabReplace[] = { (char) 187, (char) 0 };
	int cxSpaceReplace;
	int cxTabReplace;
	SIZE size;
	TEXTMETRIC tm;
	int yOfs;

        fcol = 0; bkcol = 0; /* eliminate spurious diagnostic, generate worse code */
        hfont = 0;           /* eliminate spurious diagnostic, generate worse code */
	/* init pointers to cell text and properties */
	pline = &ptab->pdata[line];
	cd = &pline->pdata[cell];
	ppos = &ptab->pcellpos[cell];

	/* draw gutter */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = (cell > 0) ? ptab->pcellpos[cell - 1].clipend : 0;
	rc.right = ppos->clipstart;
	if (cell > ptab->hdr.fixedcols && ptab->hdr.fixedcols < ptab->hdr.ncols) {
		rc.left = max(rc.left, ptab->pcellpos[ptab->hdr.fixedcols].clipstart);
	}
	if (ptab->hdr.fixedcols > 0 && cell == ptab->hdr.fixedcols) {
		rc.right--;
	}
	if (rc.right > rc.left) {
		FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
	}

	/* clip all output to this rectangle */
	rc.top = pline->linepos.clipstart;
	rc.bottom = pline->linepos.clipend;
	rc.left = ppos->clipstart;
	rc.right = ppos->clipend;

	/* check cell properties and colours */
	if (cd->props.valid & P_ALIGN) {
		align = cd->props.alignment;
	} else {
		align = P_LEFT;
	}
	if (cd->props.valid & P_FONT) {
		hfontOld = SelectObject(hdc, cd->props.hFont);
	}

	// get y offset to center text vertically within cell
	GetTextMetrics(hdc, &tm);
	yOfs = (rc.bottom - rc.top - tm.tmHeight) / 2;

	/* set replacement chars and char widths */
	cxSpaceReplace = GetTextExtent(hdc, szSpaceReplace, 1);
	cxTabReplace = cxSpaceReplace * ptab->tabchars;

	/* set colours if not default */
	if (cd->props.valid & P_FCOLOUR) {
		fcol = cd->props.forecolour;
		fcolOld = SetTextColor(hdc, fcol);
	}
	if (cd->props.valid & P_FCOLOURWS) {
		fcolws = cd->props.forecolourws;
	}
	else {
		fcolws = fcol;
	}
	if (cd->props.valid & P_BCOLOUR) {
		/* there is a non-default background colour.
		 * create a brush and fill the entire cell with it
		 */
		hbr = CreateSolidBrush(cd->props.backcolour);
		if (hbr)
		{
			FillRect(hdc, &rc, hbr);
			DeleteObject(hbr);
		}

		/* also set colour as background colour for the text */
		bkcolOld = SetBkColor(hdc, cd->props.backcolour);
	}

	/* calc offset of text within cell for right-align or centering */
	if (align == P_LEFT) {
		cx = ptab->avewidth/2;
	} else {
		cx = 0;

		if (cd->pwzText) {
			GetTextExtentPoint32W(hdc, cd->pwzText, wcslen(cd->pwzText), &size);
		} else if (cd->ptext) {
			GetTextExtentPoint32A(hdc, cd->ptext, lstrlen(cd->ptext), &size);
		}
		cx = size.cx;

		if (align == P_CENTRE) {
			cx = (ppos->size - cx) / 2;
		} else {
			cx = ppos->size - cx - (ptab->avewidth/2);
		}
	}
	cx += ppos->start;

	/* expand tabs on output and show whitespace on output */
	x = 0;
	y = pline->linepos.start + yOfs;

	/* set search string for strpbrk fn;
	   don't search for space chars unless we're showing whitespace */
	if (!show_whitespace)
	{
		szCharSet[1] = '\0';
		wzCharSet[1] = '\0';
	}

	// determine the string to display (ansi/unicode).  if we have a string
	// and it's not empty, then loop and display it.
	chp = cd->ptext;
	pwch = cd->pwzText;
	if (pwch ? *pwch : (chp && *chp))
	{
		while (TRUE)
		{
			if (pwch)
			{
				pwchBreak = wcspbrk(pwch, wzCharSet);
				if (!pwchBreak)
					pwchBreak = pwch + wcslen(pwch);
			}
			else
			{
				tabp = My_mbspbrk(chp, szCharSet);
				if (!tabp)
					tabp = chp + lstrlen(chp);
			}

			/* perform output up to tab/space char */
			if (pwch)
				ExtTextOutW(hdc, x+cx, y, ETO_CLIPPED, &rc, pwch, (UINT)(pwchBreak-pwch), NULL);
			else
				ExtTextOutA(hdc, x+cx, y, ETO_CLIPPED, &rc, chp, (UINT)(tabp-chp), NULL);

			/* advance past the tab */
			if (pwch)
			{
				GetTextExtentPoint32W(hdc, pwch, (UINT)(pwchBreak - pwch), &size);
				pwch = pwchBreak;
			}
			else
			{
				GetTextExtentPoint32A(hdc, chp, (UINT)(tabp - chp), &size);
				chp = tabp;
			}
			x += size.cx;

			// bail if we hit null terminator
			if (pwch ? !*pwch : !*chp)
				break;

			/* handle tab chars */
			while (pwch ? (*pwch == '\t') : (*chp == '\t'))
			{
				/* print replacement char */
				if (show_whitespace)
				{
					SetTextColor(hdc, fcolws);
					ExtTextOut(hdc, x + cx, y, ETO_CLIPPED, &rc, szTabReplace, 1, NULL);
					SetTextColor(hdc, fcol);
				}

				/* advance past the tab */
				x += cxTabReplace - (x % cxTabReplace);
				if (pwch)
					pwch = ++pwchBreak;
				else
					chp = ++tabp;
			}

			/* handle space chars */
			if (show_whitespace)
			{
				while (pwch ? (*pwch == ' ') : (*chp == ' '))
				{
					/* replace space char with visible char */
					SetTextColor(hdc, fcolws);
					ExtTextOut(hdc, x + cx, y, ETO_CLIPPED, &rc, szSpaceReplace, 1, NULL);
					SetTextColor(hdc, fcol);
					x += cxSpaceReplace;
					if (pwch)
						pwch = ++pwchBreak;
					else
						chp = ++tabp;
				}
			}
		}
	}

	/* reset colours to original if not default */
	if (cd->props.valid & P_FCOLOUR) {
		SetTextColor(hdc, fcolOld);
	}
	if (cd->props.valid & P_BCOLOUR) {
		SetBkColor(hdc, bkcolOld);
	}
	if (cd->props.valid & P_FONT) {
		SelectObject(hdc, hfontOld);
	}

	/* now box cell if marked */
	if ((cd->props.valid & P_BOX)) {
		if (cd->props.box != 0) {
//			rcbox.top = pline->linepos.start;
			rcbox.top = y;
			rcbox.bottom = rcbox.top + pline->linepos.size;
			rcbox.left = ppos->start;
			rcbox.right = ppos->start + ppos->size;
			gtab_boxcell(hwnd, hdc, &rcbox, &rc, cd->props.box);
		}
	}
}

/* fetch and paint the specified line */
void
gtab_paintline(HWND hwnd, HDC hdc, lpTable ptab, int line, BOOL show_whitespace)
{
  lpCellPos ppos;
  int i;
  RECT rc;
  if (line < ptab->hdr.nrows) {
    GetClientRect(hwnd, &rc);	
    
    gtab_updateline(hwnd, ptab, line);
    
    for (i = 0; i < ptab->hdr.ncols; i++) {
      ppos = &ptab->pcellpos[i];
      /* show whitespace iff the flag is set
	 and we're painting the main text column */
      if (ppos->clipstart < ppos->clipend) {
	gtab_paintcell(hwnd, hdc, ptab, line, i,
		       (show_whitespace && (i == 2)));
      }
    }
    rc.top = ptab->pdata[line].linepos.clipstart;
    rc.bottom = ptab->pdata[line].linepos.clipend;
    rc.left = ppos->clipend;
    FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
  }
}

void
gtab_paint(HWND hwnd)
{
  PAINTSTRUCT ps;
  HDC hDC = BeginPaint(hwnd, &ps);
  int y, y2, i;

  lpTable ptab = (lpTable) GetWindowLongPtr(hwnd, WL_TABLE);
  if (!ptab || (ptab->hdr.nrows == 0)) {
    FillRect(hDC, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
  } else {
    /* separator lines between fixed rows/columns
     * (ie headers) and the rest - if enabled
     */
    /* paint here first for good impression,
     * and again after to clean up!!
     */
    if (ptab->hdr.vseparator) {
      gtab_vsep(hwnd, ptab, hDC);
    }
    if (ptab->hdr.hseparator) {
      gtab_hsep(hwnd, ptab, hDC);
    }
    
    /* paint only the rows that need painting */
    for (i = 0; i < ptab->nlines; i++) {
      y = ptab->pdata[i].linepos.start;
      y2 = y + ptab->pdata[i].linepos.size;
      if ( (y <= ps.rcPaint.bottom) &&
	   (y2 >= ps.rcPaint.top)) {
	gtab_paintline(hwnd, hDC, ptab, i, ptab->show_whitespace);
      }
    }
    if (ptab->hdr.vseparator) {
      gtab_vsep(hwnd, ptab, hDC);
    }
    if (ptab->hdr.hseparator) {
      gtab_hsep(hwnd, ptab, hDC);
    }
    if (ptab->selvisible) {
      gtab_invertsel(hwnd, ptab, hDC);
    }
  }
  
  EndPaint(hwnd, &ps);
}
void
gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int x;
	RECT rc;

	if (ptab->hdr.fixedcols < 1) {
		return;
	}
	x = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend+1;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, x, rc.top, NULL);
	LineTo(hdc, x, rc.bottom);
}

void
gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc)
{
	int y;
	RECT rc;

	if (ptab->hdr.fixedrows < 1) {
		return;
	}
	y = ptab->rowheight * ptab->hdr.fixedrows;
	GetClientRect(hwnd, &rc);
	MoveToEx(hdc, rc.left, y-1, NULL);
	LineTo(hdc, rc.right, y-1);
}

/* draw in (inverting) the dotted selection lines for tracking a col width
 */
void
gtab_drawvertline(HWND hwnd, lpTable ptab)
{
	RECT rc;
	HDC hdc;
	HPEN hpen;

	hdc = GetDC(hwnd);
	if (hdc)
	{
		SetROP2(hdc, R2_XORPEN);
		hpen = SelectObject(hdc, hpenDotted);
		GetClientRect(hwnd, &rc);

		MoveToEx(hdc, ptab->trackline1, rc.top, NULL);
		LineTo(hdc, ptab->trackline1, rc.bottom);
		if (ptab->trackline2 != -1) {
			MoveToEx(hdc, ptab->trackline2, rc.top, NULL);
			LineTo(hdc, ptab->trackline2, rc.bottom);
		}

		SelectObject(hdc, hpen);
		ReleaseDC(hwnd, hdc);
	}
}
	

/*
 * mark the selected line, if visible, in the style chosen by the
 * client app. This can be TM_SOLID, meaning an inversion of
 * the whole selected area or TM_FOCUS, meaning, inversion of the first
 * cell, and then a dotted focus rectangle for the rest.
 *
 * this function inverts either style, and so will turn the selection
 * both on and off.
 */
void
gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in)
{
	HDC hdc;
	int firstline, lastline;
	long startrow, lastrow, toprow, bottomrow;
	RECT rc;
	int lastcell;



	/* get the selection start and end rows ordered vertically */
	if (ptab->select.nrows == 0) {
	    return;
	} else if (ptab->select.nrows < 0) {
	    startrow = ptab->select.startrow + ptab->select.nrows + 1;
	    lastrow = ptab->select.startrow;
	} else {
	    startrow = ptab->select.startrow;
	    lastrow = ptab->select.startrow + ptab->select.nrows -1;
	}

	/* is selected area (or part of it) visible on screen ?  */
	firstline = gtab_rowtoline(hwnd, ptab, startrow);
	lastline = gtab_rowtoline(hwnd, ptab, lastrow);


	if (firstline < 0) {
	    toprow = gtab_linetorow(hwnd, ptab,
	    		ptab->hdr.fixedselectable ? 0: ptab->hdr.fixedrows);
	    if ((toprow >= startrow)  &&
		(toprow <= lastrow)) {
		    firstline = gtab_rowtoline(hwnd, ptab, toprow);
	    } else {
		return;
	    }
	} else {
	    toprow = 0;
	}


	if (lastline < 0) {
	    bottomrow = gtab_linetorow(hwnd, ptab, ptab->nlines-1);
	    if ((bottomrow <= lastrow) &&
		(bottomrow >=startrow)) {
		    lastline = gtab_rowtoline(hwnd, ptab, bottomrow);
	    } else {
		return;
	    }
	}


	rc.top = ptab->pdata[firstline].linepos.clipstart;
	rc.bottom = ptab->pdata[lastline].linepos.clipend;



	/* selection mode includes a flag TM_FOCUS indicating we should
	 * use a focus rect instead of the traditional inversion for
	 * selections in this table. This interferes with multiple backgrnd
	 * colours less.  However we still do inversion for fixedcols.
	 */

	lastcell = (int)(ptab->select.startcell + ptab->select.ncells - 1);


	/*
	 * invert the whole area for TM_SOLID or just the first
	 * cell for TM_FOCUS
	 */
	rc.left = ptab->pcellpos[ptab->select.startcell].clipstart;
	if (ptab->hdr.selectmode & TM_FOCUS) {
		rc.right = ptab->pcellpos[ptab->select.startcell].clipend;
	}else {
		rc.right = ptab->pcellpos[lastcell].clipend;
	}

	if (hdc_in == NULL) {
		hdc = GetDC(hwnd);
		if (!hdc)
			return;
	} else {
		hdc = hdc_in;
	}

	InvertRect(hdc, &rc);

	/*
	 * draw focus rectangle around remaining cells on this line, if there
	 * are any
	 */
	if (ptab->hdr.selectmode & TM_FOCUS) {
		/*
		 * now this is a real fudge. if we are drawing TM_FOCUS
		 * selection, and the real top line is off the top of the
		 * window, then the top of the focus rect will be drawn at
		 * the top of our window. If we then scroll up one line,
		 * a new focus rect will be drawn, but the old top of focus
		 * rect line will still be there as junk on the
		 * screen. To fix this, we have 2 choices: we undo the selection
		 * before every scroll (too slow) or we set the focus rect a little
		 * bigger if the real top line is off-window, so that the top line
		 * is clipped (as it should be). This latter is what we do here
		 */
		if (toprow > startrow) {
		    rc.top--;
		}
		if (ptab->select.ncells > 1) {
			rc.left = ptab->pcellpos[ptab->select.startcell+1].clipstart;
			rc.right = ptab->pcellpos[lastcell].clipend;
			DrawFocusRect(hdc, &rc);
		}
	}

	if (hdc_in == NULL) {
		ReleaseDC(hwnd, hdc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tree.h ===
/*
 * tree.h
 *
 * data type providing a map from a key to a value, where the value is
 * an arbitrary area of storage.
 *
 * The current implementation of this is a binary search tree with no
 * balancing, so it will be inefficient if the data is presented in
 * strict ascending or descending order.
 *
 * all memory is allocated from a gmem_* heap that is passed on
 * creation of the tree.
 *
 * include gutils.h before this.
 */

/* handle for a tree */
typedef struct tree FAR * TREE;

/* keys in these trees are DWORDs */
typedef DWORD TREEKEY;

/* some sort of place-holder understood only by tree_search and
 * tree_addafter
 */
typedef struct treeitem FAR * TREEITEM;

/* pointer to one of these place holders */
typedef TREEITEM FAR * PTREEITEM;



/*
 * create an empty tree and return a handle to it. Pass the heap to
 * be used for all memory allocations.
 */
TREE APIENTRY tree_create(HANDLE hHeap);


/* delete a tree and discard any associated memory. The tree need not be
 * empty. This will discard the elements of the tree; but if these
 * contained pointers to further data blocks, these will not be discarded-
 * you must free these before deleting the tree.
 */
void APIENTRY tree_delete(TREE tree);


/* add new element to the tree, mapping the key given to the value
 *
 * a block of data of length bytes will be inserted in the tree, mapped
 * to this key, a pointer to this block will be returned. if the
 * value pointer is non-null, the block value[0..length-1] will be copied
 * to the new block.
 *
 * if the key already exists, the value block will be replaced with the
 * new size and (if value is non-null) contents.
 */
LPVOID APIENTRY tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);


/* return a pointer to the value associated with a given key in this tree.
 * returns NULL if the key is not found.
 */
LPVOID APIENTRY tree_find(TREE tree, TREEKEY key);

/*
 * a common tree operation is to insert a new element into the
 * tree only if that key is not found, and otherwise to update in some
 * way the existing value. Using the standard functions above, that
 * would require one lookup for the tree_find, and then a second lookup
 * to insert the new element.
 *
 * the two functions below provide an optimisation over this. tree_search
 * will return the value if found; if not, it will return NULL, and set
 * pitem to a pointer to a place holder in the tree where the item
 * should be inserted. tree_addafter takes this placeholder as
 * an argument, and will insert the key/value in the tree at that point.
 *
 * as for tree_update, the value pointer can be NULL - in this case
 * the block is allocated on the tree, but not initialised.
 *
 * the return value from tree_addafter is a pointer to the value block in
 * the tree
 */
LPVOID APIENTRY tree_search(TREE tree, TREEKEY key, PTREEITEM place);

LPVOID APIENTRY tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value,
			UINT length);


/* -- ctree ---------------
 *
 * this is a type of tree based on the tree_ data type above, that implements
 * counting for insertions of identical keys.
 *
 * ctree_update, if the key is unique, will insert the object and set the count
 * to 1. if the key is not unique, it will just increment the reference count.
 *
 * ctree_getcount returns the reference count for a tree.
 * ctree_find returns the first value inserted for that key, if any
 */

/*
 * create an empty counting-tree and return handle. pass in the gmem_init()
 * heap to be used for all memory allocations.
 */
TREE APIENTRY ctree_create(HANDLE hHeap);

/*
 * delete a tree and all memory associated directly with it.
 */
void APIENTRY ctree_delete(TREE tree);

/*
 * if the KEY is unique within the tree, insert the value and
 * set the count for that key to 1. If the key is not unique, add one to
 * the reference count for that key but leave the value untouched.
 */
LPVOID APIENTRY ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length);

/*
 * find the reference count for the given key
 */
long APIENTRY ctree_getcount(TREE tree, TREEKEY key);

/*
 * return the value for the given key (note this will be the value for
 * the first insertion of this key
 */
LPVOID APIENTRY ctree_find(TREE tree, TREEKEY key);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\tscroll.c ===
/*
 * tscroll.c
 *
 * standard table class.
 *
 * scrolling and selection routines
 *
 * see table.h for interface description
 *
 * This implementation currently only supports TM_SINGLE, not TM_MANY
 * modes of selection.
 */

#include "windows.h"
#include "commdlg.h"
#include "gutils.h"

#include "table.h"
#include "tpriv.h"


VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
);


/* handle a vscroll message */
void
gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    long change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = (pos * ptab->scrollscale) - ptab->toprow;
        break;

    case SB_LINEUP:
        change = -1;
        break;

    case SB_LINEDOWN:
        change = 1;
        break;

    case SB_PAGEUP:
        change = - (ptab->nlines - 3);
        if (change>=0)
            change = -1;    // consider nlines <=3!
        break;

    case SB_PAGEDOWN:
        change = (ptab->nlines - 3);
        if (change<=0)
            change = 1;     // consider nlines <=3!
        break;

    default:
        return;
    }
    gtab_dovscroll(hwnd, ptab, change);
}

/* handle a hscroll message */
void
gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos)
{
    int change;

    switch(opcode) {
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        change = pos - ptab->scroll_dx;
        break;

    case SB_LINEUP:
        change = -(ptab->avewidth);
        break;

    case SB_LINEDOWN:
        change = ptab->avewidth;
        break;

    case SB_PAGEUP:
        change = - (ptab->winwidth * 2 / 3);
        break;

    case SB_PAGEDOWN:
        change = (ptab->winwidth * 2 / 3);
        break;

    default:
        return;
    }
    gtab_dohscroll(hwnd, ptab, change);
}



/*
 * set new vertical scroll pos,
 * adjust linedata array
 * set line win-relative start posns & clip top/bottom posns
 * revise display.
 */
void
gtab_dovscroll(HWND hwnd, lpTable ptab, long change)
{
    int cury, i;
    long ncopy;
    lpCellPos cp;
    LineData ldtemp;
    RECT rc, rcpaint;
    long range;
    long newtop;
    int newpos;
    BOOL fWasVisible = FALSE;

    if (ptab->selvisible)
    {
        fWasVisible = TRUE;
        ptab->selvisible = FALSE;
        gtab_invertsel(hwnd, ptab, NULL);
    }

    range = ptab->hdr.nrows - (ptab->nlines - 1);
    newtop = ptab->toprow + change;
    if (range < 0) {
        range = 0;
    }
    if (newtop > range) {
        change = range - ptab->toprow;
    } else if (newtop < 0) {
        change = -(ptab->toprow);
    }
    ptab->toprow += change;

    newpos = (int) (newtop / ptab->scrollscale);
    SetScrollPos(hwnd, SB_VERT, newpos, TRUE);

    if (ptab->hdr.sendscroll) {
        gtab_sendtq(hwnd, TQ_SCROLL, ptab->toprow);
    }

    /* adjust data ptrs rather than invalidate, to retain the
     * data we know is still valid
     */
    if (abs(change) >= ptab->nlines) {
        gtab_invallines(hwnd, ptab, ptab->hdr.fixedrows,
            ptab->nlines - ptab->hdr.fixedrows);
        InvalidateRect(hwnd, NULL, FALSE);
        change = 0;
    } else if (change < 0) {
        /* copy data down */
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - abs(change);
        for (i =  ptab->nlines - 1;
                i >= (ptab->hdr.fixedrows + abs(change)); i--) {
            ldtemp = ptab->pdata[i - abs(change)];
            ptab->pdata[i - abs(change)] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
                ptab->hdr.fixedrows, (int) abs(change));
    } else if (change > 0) {
        ncopy = (ptab->nlines - ptab->hdr.fixedrows) - change;
        for (i = ptab->hdr.fixedrows;
                i < (ncopy + ptab->hdr.fixedrows); i++) {
            ldtemp = ptab->pdata[i + change];
            ptab->pdata[i + change] = ptab->pdata[i];
            ptab->pdata[i] = ldtemp;
        }
        gtab_invallines(hwnd, ptab,
            (int) ncopy + ptab->hdr.fixedrows, (int) change);
    }

    /* scroll window */
    GetClientRect(hwnd, &rc);
    rcpaint = rc;
    if (change > 0) {
        rc.top += (int) (change + ptab->hdr.fixedrows) * ptab->rowheight;
        rcpaint.top = (ptab->hdr.fixedrows * ptab->rowheight);
        rcpaint.top += rc.bottom - rc.top;
    } else if (change < 0) {
        rc.top += (ptab->hdr.fixedrows * ptab->rowheight);
        rc.bottom += (int) (change * ptab->rowheight);
        rcpaint.bottom -= rc.bottom - rc.top;
    }

    /* loop through each line setting relative posn and clipping */

    /* set up all rows  - the fixed/moveable difference for
     * rows is made at fetch-time during painting, when we remember
     * which absolute row nr to ask for, for a given screen line
     */
    cury = 0;
    for (i = 0; i < ptab->nlines; i++) {
        cp = &ptab->pdata[i].linepos;
        cp->start = cury;
        cp->clipstart = cury;
        cp->clipend = cury + cp->size;
        cury += cp->size;
    }

    /* now move and repaint the window */
    if (change != 0) {
        if (rc.top < rc.bottom) {
            ScrollWindow(hwnd, 0, (int) -(change * ptab->rowheight),
                &rc, NULL);
        }

        // don't repaint the fixed rows
        rc.top = 0;
        rc.bottom = ptab->hdr.fixedrows * ptab->rowheight;
        ValidateRect(hwnd, &rc);

        /* force repaint now, not just post message for later,
         * since we want to repaint that line before the next
         * scroll down occurs
         */
        ValidateRect(hwnd, &rcpaint);
        RedrawWindow(hwnd, &rcpaint, NULL,
                RDW_NOERASE | RDW_INVALIDATE | RDW_INTERNALPAINT);

    }

    if (fWasVisible)
    {
        gtab_invertsel(hwnd, ptab, NULL);
        ptab->selvisible = TRUE;
    }
}

/*
 * set new horizontal scroll pos,
 * set col win-relative start posns & clip left/right posns
 * revise display.
 */
void
gtab_dohscroll(HWND hwnd, lpTable ptab, long change)
{
    int curx, i;
    int moveable;
    lpCellPos cp;
    int newdx, range;


    /* check that the new scroll pos is still within the valid range */
    range = ptab->rowwidth - ptab->winwidth;
    newdx = ptab->scroll_dx + (int) change;
    if (range < 0) {
        range = 0;
    }
    if (newdx > range) {
        change = range - ptab->scroll_dx;
    } else if (newdx < 0) {
        change = -(ptab->scroll_dx);
    }
    ptab->scroll_dx += (int) change;

    SetScrollPos(hwnd, SB_HORZ, ptab->scroll_dx, TRUE);
    if (ptab->hdr.fixedcols > 0) {
        RECT rc;
        GetClientRect(hwnd, &rc);
        rc.left = ptab->pcellpos[ptab->hdr.fixedcols - 1].clipend;
        InvalidateRect(hwnd, &rc, FALSE);
    } else {
        InvalidateRect(hwnd, NULL, FALSE);
    }

    /* loop through each col setting relative posn and clipping */
    /* clip off 1 pixel left and right (we added 2 on to size for this) */

    /* first set up fixed columns */
    curx = 0;
    for (i = 0; i < ptab->hdr.fixedcols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + 1;
        cp->clipstart = cp->start;
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }

    /* now moveable columns. remember start of moveable cols */
    moveable = curx;
    curx = - ptab->scroll_dx;       /* rel. pos of col */
    for (i = ptab->hdr.fixedcols; i < ptab->hdr.ncols; i++) {
        cp = &ptab->pcellpos[i];
        cp->start = curx + moveable + 1;
        cp->clipstart = max(moveable+1, cp->start);
        cp->clipend = cp->start + cp->size - 2;
        curx += cp->size;
    }
}

/*
 * convert screen line nr to table row nr
 */
long
gtab_linetorow(HWND hwnd, lpTable ptab, int line)
{
    if (line < ptab->hdr.fixedrows) {
        return(line);
    }

    return (line + ptab->toprow);
}

/*
 * convert table row nr to screen line nr or -1 if not on screen
 */
int
gtab_rowtoline(HWND hwnd, lpTable ptab, long row)
{
    if (row < ptab->hdr.fixedrows) {
        return( (int) row);
    }

    row -= ptab->toprow;
    if ((row >= ptab->hdr.fixedrows) && (row < ptab->nlines)) {
        return ( (int) row);
    }
    return(-1);
}


/*
 * check if a given location is within the current selection.
 * Returns true if it is inside the current selection, or false if
 * either there is no selection, or the row, cell passed is outside it.
 */
BOOL
gtab_insideselection(
    lpTable ptab,
    long row,
    long cell)
{
    long startrow, endrow;
    long startcell, endcell;

    if (0 == ptab->select.nrows) {
        // no selection
        return FALSE;
    }

    // selection maintains anchor point as startrow,
    // so the selection can extend forwards or backwards from there.
    // need to convert to forward only for comparison
    startrow = ptab->select.startrow;
    if (ptab->select.nrows < 0) {
        endrow = startrow;
        startrow += ptab->select.nrows + 1;
    } else {
        endrow = startrow + ptab->select.nrows - 1;
    }
    if ((row < startrow) || (row > endrow)) {
        return FALSE;
    }

    // if we are in row-select mode, then that's it - its inside
    if (ptab->hdr.selectmode & TM_ROW) {
        return TRUE;
    }

    // same calculation for cells
    startcell = ptab->select.startcell;
    if (ptab->select.ncells < 0) {
        endcell = startcell;
        startcell += ptab->select.ncells + 1;
    } else {
        endcell = startcell + ptab->select.ncells - 1;
    }
    if ((cell < startcell) || (cell > endcell)) {
        return FALSE;
    }

    return TRUE;
}



/*
 * replace old selection with new. Notify owner if bNotify. Change
 * display to reflect new display.
 */
void
gtab_select(
        HWND hwnd,
        lpTable ptab,
        long row,
        long col,
        long nrows,
        long ncells,
        BOOL bNotify)
{

    /* if in ROW mode, force col and ncells to reflect the entire row. */
    if (ptab->hdr.selectmode & TM_ROW) {
        col = 0;
        ncells = ptab->hdr.ncols;
    }

    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {

            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_SELECT */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    if (bNotify) {
        gtab_sendtq(hwnd, TQ_SELECT, (LPARAM) &ptab->select);
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
        ptab->selvisible = FALSE;
    }
}

/*
 * convert window y co-ord to a line nr
 */
int
gtab_ytoline(HWND hwnd, lpTable ptab, int y)
{
    return(y / ptab->rowheight);
}

/*
 * convert window x co-ord to a cell nr
 */
int
gtab_xtocol(HWND hwnd, lpTable ptab, int x)
{
    int i;
    lpCellPos ppos;

    for (i = 0; i < ptab->hdr.ncols; i++) {
        ppos = &ptab->pcellpos[i];
        if (ppos->clipstart < ppos->clipend) {
            if ( (x >= ppos->clipstart) && (x < ppos->clipend)) {
                return(i);
            }
        }
    }
    return(-1);
}


/*
 * check if x co-ord is 'near' (+- 2 pixels) the right border of given cell
 */
BOOL
gtab_isborder(HWND hwnd, lpTable ptab, long x, long col)
{

    if (abs(ptab->pcellpos[col].clipend - x) < 2) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*
 * set selection and send 'TQ_ENTER' event to owner
 */
void
gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows,
        long ncells)
{
    /* clear existing sel if valid and visible */
    if ((ptab->select.nrows != 0) && (ptab->selvisible == TRUE)) {

        /* only clear sel if it is different from the new one */
        if ((ptab->select.startrow != row) ||
                (ptab->select.startcell != col) ||
                (ptab->select.nrows != nrows) ||
                (ptab->select.ncells != ncells)) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = FALSE;
        }
    }

    /* set select fields and send TQ_ENTER */
    if (row < ptab->hdr.nrows) {
        ptab->select.startrow = row;
        ptab->select.startcell = col;
        ptab->select.nrows = nrows;
        ptab->select.ncells = ncells;
    } else {
        ptab->select.nrows = 0;
        ptab->select.startrow = 0;
        ptab->select.startcell = 0;
        ptab->select.ncells = 0;
    }

    /* paint in selection */
    if (nrows != 0) {
        if (!ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
            ptab->selvisible = TRUE;
        }
        /* do this at end because it could cause a layout-change */
        gtab_sendtq(hwnd, TQ_ENTER, (LPARAM) &ptab->select);
    } else {
        if (ptab->selvisible) {
            gtab_invertsel(hwnd, ptab, NULL);
        }
        ptab->selvisible = FALSE;
    }
}


/*
 * start re-sizing a column
 */
void
gtab_trackcol(HWND hwnd, lpTable ptab, long col, long x)
{

    /* ensure we see the mouse-up */
    SetCapture(hwnd);
    ptab->trackmode = TRACK_COLUMN;
#ifdef WIN32
    ptab->tracknr = col;
    ptab->trackline1 = x;
#else
    // maximum 32767 columns is a reasonable limit!
    ptab->tracknr = (int) (col & 0x7fff);
    ptab->trackline1 = (int) (x & 0x7fff);
#endif

    /* if line at other side of cell is visible, draw that too */
    if (ptab->pcellpos[col].start >= ptab->pcellpos[col].clipstart) {
        ptab->trackline2 = ptab->pcellpos[col].start;
    } else {
        ptab->trackline2 = -1;
    }
    gtab_drawvertline(hwnd, ptab);
}


/*
 * called on right-click events. Select the cell clicked on, and if
 * valid, send on to owner for any context-menu type operation
 */
void
gtab_rightclick(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;
    HWND hOwner;

    /* find which col, row he selected */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }

    /* is this within the already-selected area? */
    if (!gtab_insideselection(ptab, row, cell)) {
        // no selection, or clicked outside the selection - make new selection
        // before sending the right-click

        // if shift is down, extend selection
        if (GetKeyState(VK_SHIFT) & 0x8000) {
            gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        } else {
            /* record and paint new selection */

            if (ptab->hdr.selectmode & TM_ROW) {
                cell = 0;
                ncells = ptab->hdr.ncols;
            } else {
                ncells = 1;
            }
            gtab_select(hwnd, ptab, row, cell, 1, ncells, TRUE);
        }
    }

    // now we have sent the selection, pass the message onto him
    hOwner = (HANDLE) GetWindowLongPtr(hwnd, WW_OWNER);
    SendMessage(hOwner, WM_RBUTTONDOWN, 0, MAKELONG( (short)x, (short)y));
}


/*
 * called on mouse-down events. decide what to start tracking.
 */
void
gtab_press(HWND hwnd, lpTable ptab, int x, int y)
{
    long cell, ncells;
    long row;

    if (ptab->trackmode != TRACK_NONE) {
        return;
    }

    /* has he grabbed a cell-edge to resize ? */
    cell = gtab_xtocol(hwnd, ptab, x);
    if (cell == -1) {
        return;
    }
    if (gtab_isborder(hwnd, ptab, x, cell)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }
    if ( (cell > 0) && gtab_isborder(hwnd, ptab, x, cell-1)) {
        gtab_trackcol(hwnd, ptab, cell, x);
        return;
    }

    /* find which line he selected */
    row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));

    /* is he selecting a disabled fixed area ? */
    if ( (row < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols)) {
        if (ptab->hdr.fixedselectable == FALSE) {
            return;
        }
    }

    // ignore if beyond data
    if ((row >= ptab->hdr.nrows) ||
            (cell >= ptab->hdr.ncols)) {
        return;
    }


    /* ok, start cell selection */
    ptab->trackmode = TRACK_CELL;
    SetCapture(hwnd);

    /* record and paint new selection */

    if (ptab->hdr.selectmode & TM_ROW) {
        cell = 0;
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }

    /*
     * if the shift key is down, then extend the selection to this
     * new anchor point, rather than create a new selection
     */
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        gtab_extendsel(hwnd, ptab, row, cell, FALSE);
    } else {
        gtab_select(hwnd, ptab, row, cell, 1, ncells, FALSE);
    }
    return;
}

/*
 * called on mouse-up. complete any tracking that was happening
 */
void
gtab_release(HWND hwnd, lpTable ptab, int x, int y)
{
    lpCellPos ppos;
    lpProps pprop;
    long row, cell;
    int cx;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        return;

    case TRACK_COLUMN:
        /* erase marker lines */
        gtab_drawvertline(hwnd, ptab);
        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        /* adjust cell width */
        ppos = &ptab->pcellpos[ptab->tracknr];
        cx = ptab->trackline1 - ppos->start;
        pprop = &ptab->pcolhdr[ptab->tracknr].props;
        pprop->valid |= P_WIDTH;
        pprop->width = cx;
        gtab_calcwidths(hwnd, ptab);
        gtab_setsize(hwnd, ptab);
        InvalidateRect(hwnd, NULL, FALSE);
        return;

    case TRACK_CELL:
        row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y));
        cell = gtab_xtocol(hwnd, ptab, x);

        ReleaseCapture();
        ptab->trackmode = TRACK_NONE;

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) ||
             (cell < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);

                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
                (cell >= ptab->hdr.ncols)) {
            gtab_select(
                    hwnd,
                    ptab,
                    ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows,
                    ptab->select.ncells,
                    TRUE);
            return;
        }

        /*
         * Extend to this new selection end point
         * we used to only do this if shift key pressed, but that
         * is not a good UI.
         */
        gtab_extendsel(hwnd, ptab, row, cell, TRUE);
        return;
    }
}


/* called on mouse-move. if tracking - adjust position, if not,
 * set correct cursor
 */
void
gtab_move(HWND hwnd, lpTable ptab, int x, int y)
{
    BOOL fOK;
    int line;
    long row;
    int col;
    lpCellPos ppos;

    switch(ptab->trackmode) {

    case TRACK_NONE:
        col = gtab_xtocol(hwnd, ptab, x);
        if (col == -1) {
            SetCursor(hNormCurs);
            return;
        }
        if (gtab_isborder(hwnd, ptab, x, col)) {
            SetCursor(hVertCurs);
            return;
        }
        if ( (col > 0) && gtab_isborder(hwnd, ptab, x, col-1)) {
            SetCursor(hVertCurs);
            return;
        }
        SetCursor(hNormCurs);
        return;

    case TRACK_CELL:
        line = gtab_ytoline(hwnd, ptab, y);

        // we used to only allow drag to extend
        // the selection if the shift key was down.
        // this doesn't seem to work as a UI - you expect
        // to drag and extend.

        /* if extending selection then
         * allow scrolling by dragging off window
         */
        if (line < 0) {
            gtab_dovscroll(hwnd, ptab, -1);
            line = gtab_ytoline(hwnd, ptab, y);
        } else if (line >=  ptab->nlines) {
            gtab_dovscroll(hwnd, ptab, 1);
            line = gtab_ytoline(hwnd, ptab, y);
        }


        row = gtab_linetorow(hwnd, ptab, line);
        col = gtab_xtocol(hwnd, ptab, x);

        // ignore if before or beyond data
        if ( (row < ptab->hdr.fixedrows) || (col < ptab->hdr.fixedcols)) {
            if (ptab->hdr.fixedselectable == FALSE) {
                return;
            }
        }

        if ((row >= ptab->hdr.nrows) ||
            (col >= ptab->hdr.ncols)) {
            return;
        }

        /*
         * extend to this new selection end point
         */
        gtab_extendsel(hwnd, ptab, row, col, FALSE);
        return;

    case TRACK_COLUMN:
        /* check that new x is still visible/valid */
        ppos = &ptab->pcellpos[ptab->tracknr];
        fOK = FALSE;

        if (ptab->tracknr < ptab->hdr.fixedcols)  {
            if ((x > ppos->start) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        } else {
            if ((x > ppos->clipstart) && (x < ptab->winwidth)) {
                fOK = TRUE;
            }
        }
        if (fOK == TRUE) {
            gtab_drawvertline(hwnd, ptab);
            ptab->trackline1 = x;
            gtab_drawvertline(hwnd, ptab);
        }
        return;
    }
}

/* dbl-click - send an TQ_ENTER event to the owner (if valid) */
void
gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y)
{
    int cell, line;
    long row;

    line = gtab_ytoline(hwnd, ptab, y);
    cell = gtab_xtocol(hwnd, ptab, x);
    if ( (line < ptab->hdr.fixedrows) || (cell < ptab->hdr.fixedcols) ) {
        if (!ptab->hdr.fixedselectable) {
            return;
        }
    }
    row = gtab_linetorow(hwnd, ptab, line);

    if (ptab->hdr.selectmode & TM_ROW) {
        gtab_enter(hwnd, ptab, row, 0, 1, ptab->hdr.ncols);
    } else {
        gtab_enter(hwnd, ptab, row, cell, 1, 1);
    }
}

/*
 * move selection area to visible part of window. argument bToBottom
 * indicates whether to move the line onto the bottom or the top of the
 * window if not visible - this affects the smoothness of scrolling
 * line-by-line.
 */
void
gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom)
{
    int line;
    long change;

    line = gtab_rowtoline(hwnd, ptab, ptab->select.startrow);

    /* move up if last line or not at all visible */
    if ( (line < 0) || line == (ptab->nlines - 1)) {
        change = ptab->select.startrow - ptab->toprow;
        if (bToBottom) {
            /* change to bottom of window. subtract 2 not 1
             * since nlines includes one line that is only
             * partly visible
             */
            change -= (ptab->nlines - 2);
        }
        change -= ptab->hdr.fixedrows;
        gtab_dovscroll(hwnd, ptab, change);
    }
    /* add support for TM_CELL here! */
}

/*
 * scroll the window so that if possible, the selected row is in the
 * middle 60% of the screen so that context around it is visible.
 */
void
gtab_showsel_middle(HWND hwnd, lpTable ptab, long dyRowsFromTop)
{
    int line = ptab->select.startrow;
    long change = 0;
    int mid_top, mid_end;
    BOOL fScroll = FALSE;

    if (dyRowsFromTop >= 0)
    {
        fScroll = TRUE;
        change = (ptab->select.startrow - dyRowsFromTop) - ptab->toprow;
        change -= ptab->hdr.fixedrows;
    }

    /* is this within the middle 60 % ?  */
    mid_top = ptab->toprow + (ptab->nlines * 20 / 100);
    mid_end = ptab->toprow + (ptab->nlines * 80 / 100);
    if ((line < mid_top + change) || (line > mid_end + change))
    {
        /* no - scroll so that selected line is at
         * the 20% mark
         */
        fScroll = TRUE;
        change = (ptab->select.startrow - mid_top);
        change -= ptab->hdr.fixedrows;
    }

    if (fScroll)
    {
        gtab_dovscroll(hwnd, ptab, change);
    }

    /* again - need code here for TM_CELL mode to ensure that
     * active cell is horizontally scrolled correctly
     */
}


/*
 * extend the selection to set the new anchor point as startrow, startcell.
 *
 * nrows and ncells will then be set to include the end row of the previous
 * selection. nrows, ncells < 0 indicate left and up. -1 and +1 both indicate
 * just one cell or row selected.
 */
VOID
gtab_extendsel(
    HWND hwnd,
    lpTable ptab,
    long startrow,
    long startcell,
    BOOL bNotify
)
{
    long endrow, endcell, nrows, ncells;

    /*
     * if no current selection, then just select the new anchor point
     */
    if (ptab->select.nrows == 0) {
        gtab_select(hwnd, ptab, startrow, startcell, 1,
            (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols:1,
            bNotify);
        return;
    }

    if (startrow >= ptab->hdr.nrows) {
        startrow = ptab->hdr.nrows -1;
    } else if (startrow < 0) {
        startrow = 0;
    }
    if (startcell >= ptab->hdr.ncols) {
        startcell = ptab->hdr.ncols-1;
    } else if (startcell < 0) {
        startcell = 0;
    }



    /* calculate the row just beyond the selection
     * this is one above for upwards sels, and one below for
     * downard-extending sels. Then adjust down or up one
     * to be the actual (inclusive) last row.
     */
    endrow = ptab->select.startrow + ptab->select.nrows;
    if (ptab->select.nrows < 0) {
        endrow++;
    } else {
        endrow--;
    }

    if (endrow >= ptab->hdr.nrows) {
        endrow = ptab->hdr.nrows-1;
    }
    nrows = endrow - startrow;

    if (nrows >= 0) {
        // convert from exclusive to inclusive
        nrows++;
    } else {
        // convert from exclusive to inclusive
        nrows--;
    }

    /* same calculation for cells */
    endcell = ptab->select.startcell + ptab->select.ncells;
    if (ptab->select.ncells < 0) {
        endcell++;
    } else {
        endcell--;
    }
    ncells = endcell - startcell;
    if (ncells >= 0) {
        ncells++;
    } else {
        ncells--;
    }
    gtab_select(hwnd, ptab, startrow, startcell, nrows, ncells, bNotify);
}



/* move the selection a specified nr of rows or cells
 * if no selection, select first visible unit
 *
 * if bExtend is true and there is a current selection, then extend it rather than
 * replace it. Note that (startrow, startcell) will always be set to the newly
 * selected position - this is the anchor point. nrows or ncells may be negative
 * if the selection extends upwards above the anchor. nrows == -1 is the same
 * as nrows == 1, meaning only the current row is visible. Similarly
 * (in TM_CELL mode), ncells may be negative.
 *
 * Move the selection (ie anchor point) to make it visible. bToBottom
 * indicates whether it should be moved to the bottom or the top
 * of the window.
 */
VOID
gtab_changesel(
    HWND hwnd,
    lpTable ptab,
    long rowincr,
    int cellincr,
    BOOL bToBottom,
    BOOL bExtend
)
{
    long row, col, ncols;

    /* is there a selection ? */
    if (ptab->select.nrows == 0) {

        /* no selection - force a selection
         * at the first visible unit
         */
        if (ptab->hdr.fixedselectable) {
            row = 0;
            col = 0;
        } else {
            row = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
            /* should really check for first visible cell */
            col = ptab->hdr.fixedcols;
        }
        ncols = 1;
        if (ptab->hdr.selectmode & TM_ROW) {
            col = 0;
            ncols = ptab->hdr.ncols;
        }
        gtab_select(hwnd, ptab, row, col, 1, ncols, TRUE);

    } else {
        /* move the anchor point by rowincr, cellincr */
        row = ptab->select.startrow + rowincr;
        col = ptab->select.startcell + cellincr;


        /*
         * ensure that new anchor point is in a valid position
         */

        while (col >= ptab->hdr.ncols) {
            col -= ptab->hdr.ncols;
            row++;
        }
        while (col < 0) {
            col += ptab->hdr.ncols;
            row--;
        }
        if (row < 0) {
            row = 0;
        }
        if (row >= ptab->hdr.nrows) {
            row = ptab->hdr.nrows-1;
        }
        /* check we haven't moved into non-selectable region */
        if ((row < ptab->hdr.fixedrows) &&
            (!ptab->hdr.fixedselectable)) {
                    row = ptab->hdr.fixedrows;
        }

        if (bExtend) {
            gtab_extendsel(hwnd, ptab, row, col, TRUE);
        } else {
            gtab_select(
                hwnd,
                ptab,
                row,
                col,
                1,
                (ptab->hdr.selectmode & TM_ROW) ? ptab->hdr.ncols : 1,
                TRUE);
        }
    }

    /* ensure selection visible */
    gtab_showsel(hwnd, ptab, bToBottom);
}

/*
 * set the topmost selectable unit in window as the selection
 *
 * if bExtend is TRUE, then extend the selection to include this, rather
 * than replacing the existing selection. Note that (startrow, startcell)
 * is always the anchor point - ie most recently selected end, and the
 * (nrows, ncells) can be + or - to extend the selection downwards or upwards.
 */
void
gtab_selhome(HWND hwnd, lpTable ptab, BOOL bExtend)
{
    long startrow, startcell, ncells;

    if (ptab->hdr.selectmode & TM_ROW) {
        ncells = ptab->hdr.ncols;
    } else {
        ncells = 1;
    }
    startcell = 0;


    if (ptab->hdr.fixedselectable) {
        startrow = gtab_linetorow(hwnd, ptab, 0);
    } else {
        startrow = gtab_linetorow(hwnd, ptab, ptab->hdr.fixedrows);
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.fixedcols;
        }
    }

    if (bExtend) {
        gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
    } else {
        gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
    }
}


/* handle key-down events - scroll windows and/or move selection */
int
gtab_key(HWND hwnd, lpTable ptab, int vkey)
{
    long startrow, ncells, startcell;
    BOOL bControl = FALSE;
    BOOL bShift = FALSE;

    if (GetKeyState(VK_CONTROL) & 0x8000) {
        bControl = TRUE;
    }
    if (GetKeyState(VK_SHIFT) & 0x8000) {
        /* ignore shift key here if TM_MANY -multiple selection flag- is
         * not selected
         */
        if (ptab->hdr.selectmode & TM_MANY) {
            bShift = TRUE;
        }
    }

    switch(vkey) {

    case VK_UP:
        if (bControl) {
            /* control-uparrow scrolls window without selection.
             * the selection is de-selected (to avoid surprises
             * moving back to it).
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, -1);
        } else {
            /* uparrow moves selection up one line */
            gtab_changesel(hwnd, ptab, -1, 0, FALSE, bShift);
        }
        return(0);

    case VK_DOWN:
        if (bControl) {
            /* control downarrow scrolls window without
             * a selection.
             */
            gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
            gtab_dovscroll(hwnd, ptab, 1);
        } else {
            /* the normal gtab_changesel behaviour is
             * that if the selected line is not visible now,
             * we scroll it to the top of the window. This is fine
             * in most cases but causes unacceptable jumps when
             * repeatedly scrolling down with the down key.
             *
             * Thus we now have an argument to changesel to say
             * that in this case, if you need to move the line onto
             * the window, move it to the bottom and not the top
             */
            gtab_changesel(hwnd, ptab, 1, 0, TRUE, bShift);
        }
        return(0);

    case VK_LEFT:
        /* if cell-selection mode, move left one cell.
         * otherwise the whole row is selected - scroll
         * the line left a little
         */

        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* ctrl-left moves to start of line */
                gtab_dohscroll(hwnd, ptab, -(ptab->scroll_dx));
            } else {
                gtab_dohscroll(hwnd, ptab, -(ptab->avewidth));
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, -1, FALSE, bShift);
        }
        return(0);

    case VK_RIGHT:
        /* if cell-selection mode, move right one cell.
         * otherwise the whole row is selected - scroll
         * the line right a little
         */
        if (ptab->hdr.selectmode & TM_ROW) {
            if (bControl) {
                /* control-right moves to right end of line */
                gtab_dohscroll(hwnd, ptab, ptab->rowwidth -
                                ptab->winwidth);
            } else {
                gtab_dohscroll(hwnd, ptab, ptab->avewidth);
            }
        } else {
            gtab_changesel(hwnd, ptab, 0, 1, TRUE, bShift);
        }
        return(0);

    case VK_HOME:
        if (bControl) {
            /* control-home == top of file */
            gtab_dovscroll(hwnd, ptab, -(ptab->toprow));
        }
        /* top of window */
        gtab_selhome(hwnd, ptab, bShift);
        gtab_showsel(hwnd, ptab, FALSE);

        return(0);

    case VK_END:
        if (bControl) {
            /* control-end -> end of file */
            startrow = ptab->hdr.nrows-1;
        } else {
            startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
            if (startrow >= ptab->hdr.nrows) {
                startrow = ptab->hdr.nrows-1;
            }
        }

        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }

        /* we have selected the bottom line. We don't want to
         * move it up into the window, since the intended
         * effect is to select the lowest line. This doesn't
         * apply to the ctrl-end behaviour (move to bottom of
         * buffer.
         */
        if (bControl) {
            /* move the selection to make it visible - but move it
             * to the bottom and not to the top of the window
             */
            gtab_showsel(hwnd, ptab, TRUE);
        }
        return(0);

    case VK_RETURN:
        if (ptab->select.nrows != 0) {
            gtab_showsel(hwnd, ptab, FALSE);
            gtab_enter(hwnd, ptab, ptab->select.startrow,
                    ptab->select.startcell,
                    ptab->select.nrows, ptab->select.ncells);
        }
        return(0);

    case VK_SPACE:
        /* toggle the selection */
        if (ptab->select.nrows == 0) {
                /* no selection - make one */
                gtab_changesel(hwnd, ptab, 0, 0, TRUE, FALSE);
        } else {
                /* there is a selection - deselect it */
                gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE);
        }
        return(0);

    case VK_PRIOR:          /* page up */

        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, -(ptab->nlines - 3));
        }
        gtab_selhome(hwnd, ptab, bShift);
        return(0);

    case VK_NEXT:           /* page down */

        /* scroll down one page */
        if (ptab->nlines > 3) {
            gtab_dovscroll(hwnd, ptab, (ptab->nlines - 3));
        }

        /* select new bottom line */
        startrow = gtab_linetorow(hwnd, ptab, ptab->nlines - 1);
        if (startrow >= ptab->hdr.nrows) {
            startrow = ptab->hdr.nrows-1;
        }
        startcell = 0;
        ncells = ptab->hdr.ncols;
        if (!(ptab->hdr.selectmode & TM_ROW)) {
            startcell = ptab->hdr.ncols-1;
            ncells = 1;
        }

        /* select bottom line, but don't call showsel
         * since we don't want to adjust it's position - we
         * want it to remain at the bottom of the window
         */
        if (bShift) {
            gtab_extendsel(hwnd, ptab, startrow, startcell, TRUE);
        } else {
            gtab_select(hwnd, ptab, startrow, startcell, 1, ncells, TRUE);
        }
        return(0);

    default:
        return(1);
    }
}

int gtab_mousewheel(HWND hwnd, lpTable ptab, DWORD fwKeys, int zDelta)
{
    static ULONG uScrollLines = 0;

    if (fwKeys & MK_MBUTTON) {
        return 1;
    }

    if (uScrollLines == 0) {
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &uScrollLines, FALSE);
        if (uScrollLines == 0) {
            uScrollLines = 3;
        }
    }

    zDelta /= -WHEEL_DELTA;

    if (fwKeys & MK_CONTROL) {
        //
        // Left-Right scroll
        //
        if (ptab->hdr.selectmode & TM_ROW) {
            if (fwKeys & MK_SHIFT) {
                zDelta = (zDelta > 0) ? ptab->rowwidth : -ptab->rowwidth;
            }
            gtab_dohscroll(hwnd, ptab, ptab->avewidth * zDelta);
            return 0;
        }
        return 1;
    }

    if (fwKeys & MK_SHIFT) {
        //
        // Page scroll
        //
        if (ptab->nlines > 3) {
            zDelta *= ptab->nlines - 3;
        }
    }
    else {
        if (uScrollLines) {
            zDelta *= uScrollLines;
            zDelta = min(zDelta, ptab->nlines - 3);
        }
    }

    gtab_dovscroll(hwnd, ptab, zDelta);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hdivide\getopt.c ===
/*
        getopt.c

        modified public-domain AT&T getopt(3)
*/

#include <stdio.h>
#include <string.h>

#ifdef _POSIX_SOURCE
#       include <unistd.h>
#else
#       define STDERR_FILENO 2
#       ifdef __STDC__
                extern int write (int fildes, char * buf, unsigned nbyte);
#       else
                extern int write ();
#       endif
#endif

int opterr = 1;
int optind = 1;
int optopt;
char *optarg;

static void ERR(char **argv, char *s, char c)
{
    if (opterr) {
        fprintf(stderr, "%s%s%c\n", argv[0], s, c);
    }
}

int getopt(int argc, char **argv, char *opts)
{
    static int sp = 1, error = (int) '?';
    static char sw = '-', eos = '\0', arg = ':';
    char c, * cp;

    if (sp == 1)
        if (optind >= argc || argv[optind][0] != sw
            || argv[optind][1] == eos)
            return EOF;
        else if (strcmp(argv[optind],"--") == 0) {
            optind++;
            return EOF;
        }
    c = argv[optind][sp];
    optopt = (int) c;
    if (c == arg || (cp = strchr(opts,c)) == NULL) {
        ERR(argv,": illegal option: -",c);
        if (argv[optind][++sp] == eos) {
            optind++;
            sp = 1;
        }
        return error;
    }
    else if (*++cp == arg) {
        if (argv[optind][sp + 1] != eos)
            optarg = &argv[optind++][sp + 1];
        else if (++optind >= argc) {
            ERR(argv,": option requires an argument--",c);
            sp = 1;
            return error;
        }
        else
            optarg = argv[optind++];
        sp = 1;
    }
    else {
        if (argv[optind][++sp] == eos) {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return (int)c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hd\hd.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hd.c

Abstract:

        This module contains the definitions of all constants and structures
        used in hd.c

Authors:

    Jaime F. Sasson (jaimes) 12-Nov-1990
    David J. Gilman (davegi) 12-Nov-1990

Environment:

    C run time library

Revision History:


--*/


/************************************
*
*               Definition of constants
*
************************************/


#define RECORD_SIZE     16      // Maximum size of a record. A record is a
                                                        // buffer that contains a set of bytes read
                                                        // from the file, in order to be converted and
                                                        // displayed.


#define LINE_SIZE               160 // Size of the buffer that will contain the
                                                        // representation of a record. Such a buffer
                                                        // can be bigger than one line (80 characters)
                                                        // depending on the arguments passed to hd
                                                        // (eg. -cC -A). For this reason, the size of
                                                        // this buffer was made 160 (size of two lines
                                                        // in the screen, wich is large enough to
                                                        // contain all characters converted.


#define BUFFER_SIZE     512 // Size of the buffer that will contain data read
                                                        // from the file to be displayed. The file will
                                                        // be accessed to obtain blocks of BUFFER_SIZE
                                                        // characters



/************************************
*
*               ASCII characters
*
************************************/


#define DOT     '.'

#define SPACE   ' '

#define NUL     '\0'




/************************************
*
*               Messages used by sprintf
*
************************************/


#define MSG_ADDR_FIELD  "           "


#define MSG_ADDR_DEC_FMT        "%010lu"


#define MSG_ADDR_HEX_FMT                "%08lx"


#define MSG_SINGLE_BYTE_DEC_FMT "%3u"


#define MSG_SINGLE_BYTE_HEX_FMT "%02x"


#define MSG_SINGLE_WORD_DEC_FMT "%5u"


#define MSG_SINGLE_WORD_HEX_FMT "%04x"


#define MSG_WORD_BYTE_DEC_FMT   "%5u %3u"


#define MSG_WORD_BYTE_HEX_FMT   "%04x %02x"

#define MSG_DATA_ASCII_FMT              MSG_ADDR_FIELD \
                                                                "%s %s %s %s %s %s %s %s " \
                                                                "%s %s %s %s %s %s %s %s  "


#define MSG_DATA_BYTE_DEC_FMT   MSG_ADDR_FIELD \
                                                                "%3u %3u %3u %3u %3u %3u %3u %3u " \
                                                                "%3u %3u %3u %3u %3u %3u %3u %3u  "


#define MSG_DATA_BYTE_HEX_FMT   MSG_ADDR_FIELD \
                                                                "%02x %02x %02x %02x %02x %02x %02x %02x " \
                                                                "%02x %02x %02x %02x %02x %02x %02x %02x  "


#define MSG_DATA_WORD_DEC_FMT   MSG_ADDR_FIELD \
                                                                "%5u %5u %5u %5u %5u %5u %5u %5u  "


#define MSG_DATA_WORD_HEX_FMT   MSG_ADDR_FIELD \
                                                                "%04x %04x %04x %04x %04x %04x %04x %04x  "


#define MSG_DATA_DWORD_DEC_FMT  MSG_ADDR_FIELD \
                                                                "%10lu %10lu %10lu %10lu  "


#define MSG_DATA_DWORD_HEX_FMT  MSG_ADDR_FIELD \
                                                                "%08lx %08lx %08lx %08lx  "


#define MSG_PRINT_CHAR_FMT              "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c"



/************************************
*
*               Help Message
*
************************************/



#define HELP_MESSAGE "\n" \
                "usage: hd [options] [file1] [file2] ... \n" \
                "options: \n" \
                "    -ad|x         displays address in decimal or hex \n" \
                "    -A            append printable characters to the end of the line\n" \
                "    -ch|C|e|r     displays bytes as ascii (characters, ascii C, \n" \
                "                  acsii code or ascii ctrl) \n" \
                "    -bd|x         displays byte as decimal or hex number \n" \
                "    -wd|x         displays word as decimal or hex number \n" \
                "    -ld|x         displays dword as decimal or hex number \n" \
                "    -s <offset>   starting address \n" \
                "    -n <number>   number of bytes to interpret \n" \
                "    -i            supresses printing redundant lines\n" \
                "    -?|h|H        displays this help message \n" \
                "\n" \
                "default: -ax -bx -A \n" \
                "\n"



/************************************
*
*               Enumerations
*
************************************/



typedef enum _FORMAT {          // Possible formats used to display data
        ASCII_CHAR,
        ASCII_C,
        ASCII_CODE,
        ASCII_CTRL,
        BYTE_DEC,
        BYTE_HEX,
        WORD_DEC,
        WORD_HEX,
        DWORD_DEC,
        DWORD_HEX,
        PRINT_CHAR
}       FORMAT;


typedef enum _BASE {            // Bases used to display numbers
        DEC,
        HEX
}       BASE;


typedef enum _YESNO {           // Options for DumpAscii
        NOT_DEFINED,
        YES,
        NO
}       YESNO;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\he\he.c ===
/*****************************************************************/
/**          Microsoft LAN Manager          **/
/**        Copyright(c) Microsoft Corp., 1988-1991      **/
/*****************************************************************/

/****   he - HexEdit a file
 *
 *  Wrapper to HexEdit function to allow file (or drive) editting
 *
 *  Written: Ken Reneris
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include "hexedit.h"

NTSTATUS fncRead(), fncWrite(), fncWriteDASD();

void EditFile (char *name);
void ReadIni ();

WORD vAttrList, vAttrTitle, vAttrHigh;

VOID __cdecl
main (argc, argv)
USHORT  argc;
char    *argv[];
{
    char *argument = argv[1];

    if (argc < 2) {
        printf ("he fname\n");
        exit (1);
    }

    ReadIni  ();

    if ((strncmp(argv[1], "\\\\.\\", 4)) == 0) {
        char *cp;
        int   index;

        // Insure there is a backslash on the DosName being opened.
        for (cp = argv[1], index = 0; *cp; *cp++, index++) {
            // action in for loop
        }
        cp--;
        if (*cp != '\\') {

            // Need to add backslash to name.

            argument = GlobalAlloc (0,index + 4);
            if (!argument) {
                printf("Out of memory\n");
                exit (1);
            }
            for (cp = argv[1], index = 0; argument[index] = *cp; *cp++, index++) {
                // action in for loop
            }
            argument[index] = '\\';
            argument[index + 1] = '\0';
        }
    }
    EditFile (argument);
}



void
EditFile (
    char *name
    )
{
    FILE_ALIGNMENT_INFORMATION AlignmentInfo;
    PDISK_GEOMETRY_EX              DiskGeo;
    ULONGLONG          li;
    struct  HexEditParm     ei;
    USHORT              rc, rc1, i, l;
    PWSTR               WideName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    UNICODE_STRING      NtDriveName;
    ANSI_STRING         NtDriveNameAnsi;
    IO_STATUS_BLOCK     status_block;
    UCHAR               GeoBuf[ 8*1024];
    UCHAR               Root[12];

    //
    // Try to open & edit as regular filename
    //

    memset ((PUCHAR) &ei, 0, sizeof (ei));
    ei.ename   = name;
    ei.flag    = FHE_VERIFYONCE | FHE_SAVESCRN | FHE_JUMP;
    ei.read    = fncRead;
    ei.write   = fncWrite;
    ei.ioalign = 1;
    ei.Console = INVALID_HANDLE_VALUE;
    ei.AttrNorm = vAttrList;
    ei.AttrHigh = vAttrTitle;
    ei.AttrReverse = vAttrHigh;

    ei.handle = CreateFile (
            name,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

    if (ei.handle == INVALID_HANDLE_VALUE) {
        // Try for just read access

        ei.handle = CreateFile (
                name,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL );
    }


    if (ei.handle != INVALID_HANDLE_VALUE) {

        ULONG High = 0;

        ei.totlen = 0;
        ei.totlen = SetFilePointer (ei.handle, 0, &High, FILE_END);
        ei.totlen |= ((ULONGLONG)High) << 32;

        HexEdit (&ei);
        return;
    }

    rc = (USHORT)GetLastError ();

    //
    // Try expanding the name from dosname to ntname.
    // Since regular name failed, assume a sector edit
    //
    l = strlen(name)+1;
    WideName = GlobalAlloc (0,l * sizeof(WCHAR));
    if (!WideName) {
        printf("Out of memory\n");
        exit(1);
    }

    ZeroMemory(WideName, l*sizeof(WCHAR));

    for(i=0; i < l; i++)
        WideName[i] = name[i];

    // OK, now get the corresponding NT name
    rc1 = RtlDosPathNameToNtPathName_U (
            WideName,
            &NtDriveName,
            NULL,
            NULL );

    if (!rc1) {
        printf ("Open error %d\n", rc);
        exit (rc);
    }


    //  If the NT drive name has a trailing backslash, remove it.
    l = NtDriveName.Length/sizeof(WCHAR);
    if( NtDriveName.Buffer[l-1] == '\\' ) {

        NtDriveName.Buffer[l-1] = 0;
        NtDriveName.Length -= sizeof(WCHAR);
    }

    InitializeObjectAttributes(
            &oa,
            &NtDriveName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile(
            &ei.handle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &oa,
            &status_block,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_SYNCHRONOUS_IO_ALERT );

    if (!NT_SUCCESS(status)) {
        // try for just read access

        status = NtOpenFile(
                    &ei.handle,
                    SYNCHRONIZE | FILE_READ_DATA,
                    &oa,
                    &status_block,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_ALERT );
    }

    if (!NT_SUCCESS(status)) {
        NtDriveName.Length = strlen(name) * sizeof(WCHAR);
        NtDriveName.Buffer = WideName;

        InitializeObjectAttributes(
                &oa,
                &NtDriveName,
                OBJ_CASE_INSENSITIVE,
                0,
                0 );

        status = NtOpenFile(
                &ei.handle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                &oa,
                &status_block,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT );

        if (!NT_SUCCESS(status)) {
            // try for just read access

            status = NtOpenFile(
                        &ei.handle,
                        SYNCHRONIZE | FILE_READ_DATA,
                        &oa,
                        &status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT );
        }
    }


    RtlUnicodeStringToAnsiString (&NtDriveNameAnsi, &NtDriveName, TRUE);
    ei.ename = NtDriveNameAnsi.Buffer;

    if (!NT_SUCCESS(status)) {
        printf ("%s open error %lx\n", ei.ename, status);
        exit (status);
    }
/*
    NtQueryInformationFile(
        ei.handle,
        &status_block,
        &AlignmentInfo,
        sizeof( AlignmentInfo ),
        FileAlignmentInformation );
    
    ei.ioalign = AlignmentInfo.AlignmentRequirement;
*/
    ei.ioalign = 0;
    
    ei.totlen = 0;
    
    if (NtDriveNameAnsi.Buffer[ NtDriveNameAnsi.Length - 1] == ':')  {

        sprintf( Root, "%c:\\", NtDriveNameAnsi.Buffer[ NtDriveNameAnsi.Length - 2]);

        //
        //  For non-cdrom drive letter opens,  we need to use
        //  get partition info,  not get disk info,  for the partition size.
        //
        
        if (DRIVE_CDROM != GetDriveType( Root))  {

            PPARTITION_INFORMATION Part = (PVOID)GeoBuf;
            
            status = NtDeviceIoControlFile(
                    ei.handle,
                    0,
                    NULL,
                    NULL,
                    &status_block,
                    IOCTL_DISK_GET_PARTITION_INFO,
                    NULL,
                    0,
                    GeoBuf,
                    sizeof( GeoBuf) );

            if (NT_SUCCESS(status)) {

                ei.totlen = Part->PartitionLength.QuadPart;
            }
        }
    }

    //
    //  Get sectorsize and,  if we haven't got it already,  disk/partition size
    //
    
    status = NtDeviceIoControlFile( ei.handle,
                                    0,
                                    NULL,
                                    NULL,
                                    &status_block,
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                                    NULL,
                                    0,
                                    GeoBuf,
                                    sizeof( GeoBuf) );

    if (NT_SUCCESS(status)) {

        DiskGeo = (PVOID)GeoBuf;

        if (ei.ioalign < DiskGeo->Geometry.BytesPerSector)  {

            ei.ioalign = DiskGeo->Geometry.BytesPerSector;
        }
        
        if (0 == ei.totlen)  {
        
            ei.totlen = DiskGeo->DiskSize.QuadPart;
        }
    }
    else {

        //
        //  The EX call failed,  try the old one.  GPT discs seem
        //  to fail the EX call.
        //
        
        PDISK_GEOMETRY OldGeo;
        
        status = NtDeviceIoControlFile( ei.handle,
                                        0,
                                        NULL,
                                        NULL,
                                        &status_block,
                                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        NULL,
                                        0,
                                        GeoBuf,
                                        sizeof( GeoBuf) );

        if (NT_SUCCESS(status)) {

            OldGeo = (PVOID)GeoBuf;

            if (ei.ioalign < OldGeo->BytesPerSector)  {
            
                ei.ioalign = OldGeo->BytesPerSector;
            }
            
            if (0 == ei.totlen)  {
            
                ei.totlen = OldGeo->Cylinders.QuadPart * OldGeo->BytesPerSector *
                            OldGeo->SectorsPerTrack * OldGeo->TracksPerCylinder;
            }
        }
    }

    //
    //  Last resort for partition/disk size.
    //
    
    if (0 == ei.totlen)  {

        ULONG High = 0;

        if (ei.ioalign < 0x200)  {
        
            ei.ioalign = 0x200;
        }

        ei.totlen = 0;
        ei.totlen = SetFilePointer (ei.handle, 0, &High, FILE_END);
        ei.totlen |= ((ULONGLONG)High) << 32;
    }

    //
    //  If a filesystem is mounted,  we need to enable extended
    //  DASD io in order to read the whole volume.  Ignore result,
    //  not all FSs support it.
    //

    status = NtDeviceIoControlFile(
        ei.handle,
        0,
        NULL,
        NULL,
        &status_block,
        FSCTL_ALLOW_EXTENDED_DASD_IO,
        NULL,
        0,
        NULL,
        0);

    ei.flag = FHE_VERIFYALL | FHE_PROMPTSEC | FHE_SAVESCRN | FHE_JUMP;
    HexEdit (&ei);
}


NTSTATUS fncRead (h, loc, data, len)
HANDLE  h;
DWORD   len;
ULONGLONG loc;
char    *data;
{
    DWORD   l, br;
    ULONG High = (ULONG)(loc >> 32);

    l = SetFilePointer (h, (ULONG)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!ReadFile (h, data, len, &br, NULL))
        return GetLastError();

    return (br != len ? ERROR_READ_FAULT : 0);
}


NTSTATUS fncWrite (h, loc, data, len)
HANDLE  h;
DWORD   len;
ULONGLONG loc;
char    *data;
{
    DWORD    l, bw;
    ULONG High = (ULONG)(loc >> 32);

    l = SetFilePointer (h, (ULONG)loc, &High, FILE_BEGIN);
    if (l == -1)
        return GetLastError();

    if (!WriteFile (h, data, len, &bw, NULL))
        return GetLastError();

    return (bw != len ? ERROR_WRITE_FAULT : 0);
}



/*** xtoi - Hex to int
 *
 *  Entry:
 *      pt -    pointer to hex number
 *
 *  Return:
 *      value of hex number
 *
 */
unsigned xtoi (pt)
char *pt;
{
    unsigned    u;
    char        c;

    u = 0;
    while (c = *(pt++)) {
        if (c >= 'a'  &&  c <= 'f')
            c -= 'a' - 'A';
        if ((c >= '0'  &&  c <= '9')  ||  (c >= 'A'  &&  c <= 'F'))
            u = u << 4  |  c - (c >= 'A' ? 'A'-10 : '0');
    }
    return (u);
}


void
ReadIni ()
{
    static  char    Delim[] = " :=;\t\r\n";
    FILE    *fp;
    char    *env, *verb, *value;
    char    s [200];
    long    l;


    env = getenv ("INIT");
    if (env == NULL)
        return;

    if ((strlen(env) + sizeof ("\\TOOLS.INI") + 1) > sizeof(s))
        return;

    strcpy (s, env);
    strcat (s, "\\TOOLS.INI");      // just use list ini section
    fp = fopen (s, "r");
    if (fp == NULL)
        return;

    while (fgets (s, 200, fp) != NULL) {
        if (s[0] != '[')
            continue;
        _strupr (s);
        if (strstr (s, "LIST") == NULL)
            continue;
        /*
         *  ini file found w/ "list" keyword. Now read it.
         */
        while (fgets (s, 200, fp) != NULL) {
            if (s[0] == '[')
                break;
            verb  = strtok (s, Delim);
            value = strtok (NULL, Delim);
            if (verb == NULL)
                continue;
            if (value == NULL)
                value = "";

            _strupr (verb);
            if (strcmp (verb, "LCOLOR")  == 0) vAttrList = (WORD)xtoi(value);
            else if (strcmp (verb, "TCOLOR")  == 0) vAttrTitle= (WORD)xtoi(value);
            else if (strcmp (verb, "HCOLOR")  == 0) vAttrHigh = (WORD)xtoi(value);
        }
        break;
    }
    fclose (fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hdivide\hdivide.cpp ===
//
// hdivide.cpp -- yet another header file divider
//
// 1998 Nov Hiro Yamamoto
//


#pragma warning(disable: 4786)
#include <cstdio>
#include <string>
#include <cstdarg>
#include <map>
#include <vector>
#include <cassert>

#include <io.h>

#define PROGNAME    "hdivide"
#define VERSION     "1.0"

extern "C" {
    extern int getopt(int argc, char** argv, const char* opts);
    extern int optind;
}

namespace opt {
    bool verbose;
}

namespace input {
    unsigned long length;
    int lineno = 1;
    std::string path;

    std::string strip(const std::string& fname)
    {
        std::string stripped;

        //
        // find the "path" part
        //
        int n = fname.rfind('\\');
        if (n < 0) {
            n = fname.rfind('/');
        }

        if (n < 0 && (n = fname.rfind(':')) < 0) {
            n = 0;
        }
        else {
            ++n;
        }

        // store the path
        path = fname.substr(0, n);
        // retrive the filename portion
        stripped = fname.substr(n, fname.length());

        return stripped;
    }
}

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))
#endif

namespace id {
    const char all[] = "all";
    const char begin[] = "begin";
    const char end[] = "end";
    const char else_[] = "else";
    const int begin_size = ARRAY_SIZE(begin) - 1;
    const int end_size = ARRAY_SIZE(end) - 1;
    const int else_size = ARRAY_SIZE(else_) - 1;

    const char internal[] = "internal";
    const char public_[] = "public";
    const char null[] = "null";
    std::string privatefile;
    std::string publicfile;

    const char insert[] = "insert";
    const int insert_size = ARRAY_SIZE(insert) - 1;
    const char reference_start[] = "reference_start";
    const char reference_end[] = "reference_end";
}

#define MYFAILURE_OPENFILE          (120)
#define MYFAILURE_INVALID_FORMAT    (121)

using namespace std;

//////////////////////////////////////////////////////////////////////////
// usage
//////////////////////////////////////////////////////////////////////////

void usage()
{
    fputs(PROGNAME ": version " VERSION "\n", stderr);
    fputs("usage: hdivide [-v] input-filename (no path name please)\n", stderr);
}

//////////////////////////////////////////////////////////////////////////
// misc. helpers
//////////////////////////////////////////////////////////////////////////

inline void makeupper(string& str)
{
    for (int i = 0; i < str.length(); ++i) {
        str[i] = (char)toupper(str[i]);
    }
}

inline void makelower(string& str)
{
    for (int i = 0; i < str.length(); ++i) {
        str[i] = (char)tolower(str[i]);
    }
}

namespace msg {
    void __cdecl error(const char* fmt, ...)
    {
        va_list args;

        fputs(PROGNAME ": [error] ", stderr);
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
        putc('\n', stderr);
    }

    void __cdecl verbose(const char* fmt, ...)
    {
        if (!opt::verbose)
            return;

        va_list args;
        fputs(PROGNAME ": ", stderr);
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
        putc('\n', stderr);
    }
}


//////////////////////////////////////////////////////////////////////////
// class Output
//////////////////////////////////////////////////////////////////////////

class Output;

class Insertion {
public:
    // somehow the default constructor is required for std::vector
    // on NT5 build environment, as of Nov 1998
    explicit Insertion() : m_insert(NULL), m_insertion_point(-1) { }
    explicit Insertion(Output* insert, int point)
        : m_insert(insert), m_insertion_point(point)
    {
    }
public:
    Output* m_insert;
    int m_insertion_point;
};

class Reference {
public:
    // somehow the default constructor is required for std::vector
    // on NT5 build environment, as of Nov 1998
    Reference() : m_start(-1), m_end(-1) { }
    explicit Reference(int start, int end)
        : m_start(start), m_end(end) { }
public:
    int m_start;
    int m_end;
};

class Output {
public:
    explicit Output(const string& name)
      : m_name(name),
        m_fname(input::path + name + ".x"),
        m_alive(true),
        m_insertion_finished(false),
        m_reference_start(-1)
    {
        msg::verbose("opening %s", m_fname.c_str());
        if ((m_fp = fopen(m_fname.c_str(), "wt")) == NULL) {
            msg::error("cannot open file %s", m_fname.c_str());
            throw MYFAILURE_OPENFILE;
        }

        if (m_tomem) {
            m_buffer.reserve(input::length);
        }
    }
    virtual ~Output();

public:
    void setalive(bool alive)
    {
        m_alive = alive;
    }
    bool getalive()
    {
        return m_alive;
    }
    const string& getname()
    {
        return m_name;
    }
    void put(int c)
    {
        assert(m_fp);
        if (m_alive) {
            if (m_tomem) {
                m_buffer += (char)c;
            }
            else {
                putc(c, m_fp);
            }
        }
    }
    void puts(const char* s)
    {
        assert(m_fp);
        if (m_alive) {
            if (m_tomem) {
                m_buffer += s;
            }
            else {
                fputs(s, m_fp);
            }
        }
    }
    bool operator<(const Output* a)
    {
        return m_name < a->m_name;
    }

    void set_insertion_point(Output* insert);
    void set_reference_start();
    void set_reference_end();

    bool do_insertion();

protected:
    FILE* m_fp;
    bool m_alive;
    static bool m_tomem;

    string m_name;
    string m_fname;

    string m_buffer;

    vector<Insertion> m_insertions;

    bool m_insertion_finished;

    vector<Reference> m_references;

    int m_reference_start;
    int m_reference_start_line;
};

bool Output::m_tomem = true;

Output::~Output()
{
    if (m_reference_start != -1) {
        msg::error("reference started at line %d is not closed in tag '%s'",
            m_reference_start_line, m_name.c_str());
        throw MYFAILURE_INVALID_FORMAT;
    }
    if (!m_buffer.empty()) {
        msg::verbose("flushing %s", m_fname.c_str());
        fputs(m_buffer.c_str(), m_fp);
    }
    if (m_fp) {
        fclose(m_fp);
    }
}


void Output::set_insertion_point(Output* insert)
{
    assert(insert!= NULL);
    if (m_alive) {
        Insertion i(insert, m_buffer.length());
        m_insertions.push_back(i);
    }
}

void Output::set_reference_start()
{
    if (m_alive) {
        if (m_reference_start != -1) {
            msg::error("line %d: invalid reference_start appeared in tag context '%s'", input::lineno, m_name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
        m_reference_start = m_buffer.length();
        m_reference_start_line = input::lineno;
    }
}

void Output::set_reference_end()
{
    if (m_alive) {
        if (m_reference_start == -1) {
            msg::error("line %d: invalid reference_end appeared in tag context '%s'", input::lineno, m_name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
        Reference ref(m_reference_start, m_buffer.length());
        msg::verbose("%s reference_end: %d - %d", m_name.c_str(), ref.m_start, ref.m_end);
        m_reference_start = -1;
        m_references.push_back(ref);
    }
}

bool Output::do_insertion()
{
    if (!m_tomem || m_insertion_finished)
        return true;

    // to avoid infinite recursion by errornous commands,
    // firstly declare we've finished this.
    m_insertion_finished = true;

    int upto = m_insertions.size();
    for (int i = 0; i < upto; ++i) {
        Insertion& ins = m_insertions[i];
        assert(&ins);
        if (ins.m_insert->m_references.size() == 0) {
            msg::error("reference area is not specified or incorrect for tag '%s'", ins.m_insert->m_name.c_str());
            return false;
        }

        if (!ins.m_insert->m_insertion_finished) {
            if (!ins.m_insert->do_insertion())
                return false;
        }

        Output* o = ins.m_insert;
        for (int l = 0; l < o->m_references.size(); ++l) {
            Reference& ref = o->m_references[l];
            int len = ref.m_end - ref.m_start;
            msg::verbose("%s [%d] inserting text at %d, %s(%d - %d)",
                         m_name.c_str(), l,
                         ins.m_insertion_point,
                         o->m_name.c_str(), ref.m_start, ref.m_start + len);
            m_buffer.insert(ins.m_insertion_point,
                o->m_buffer, ref.m_start,
                len);
            // fixup my insertions
            int point = ins.m_insertion_point;
            for (int k = 0; k < m_insertions.size(); ++k) {
                if (m_insertions[k].m_insertion_point >= point) {
                    m_insertions[k].m_insertion_point += len;
                    msg::verbose("%s [%d] insertion point fixed from %d to %d",
                        m_name.c_str(), k,
                        m_insertions[k].m_insertion_point - len,
                        m_insertions[k].m_insertion_point);
                }
            }
            // fixup my references
            for (k = 0; k < m_references.size(); ++k) {
                msg::verbose("%s m_reference[%d].m_start=%d, m_end=%d adding len=%d", m_name.c_str(),
                             k,
                             m_references[k].m_start, m_references[k].m_end,
                             len);
                if (m_references[k].m_start > point) {
                    m_references[k].m_start += len;
                }
                if (m_references[k].m_end > point) {
                    m_references[k].m_end += len;
                    msg::verbose("finally start=%d, end=%d", m_references[k].m_start, m_references[k].m_end);
                }
            }
        }
    }

    return true;
}

//////////////////////////////////////////////////////////////////////////
// class Divider
//
// this class manages the map of Output and performs misc. operations
//////////////////////////////////////////////////////////////////////////

class Divider : public map<string, Output*>
{
public:

    virtual ~Divider()
    {
        // process insertions
        for (iterator i = begin(); i != end(); ++i) {
            if (!i->second->do_insertion())
                break;
        }
        // clear up
        for (i = begin(); i != end(); ++i) {
            delete i->second;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // printout
    //
    // printout the argument to outputs
    //////////////////////////////////////////////////////////////////////////
    void printout(int c)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->put(c);
        }
    }

    void printout(const char* s)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->puts(s);
        }
    }

    void process_line(string& line);

protected:
    void extract_version(const string& name, string& symbol, string& version, bool allow_omission = false);
    void get_arg(const string& name, string& arg);
    void prepare_section(string& name);
    void process_divider(string& line);

    void set_alive(bool alive)
    {
        for (iterator i = begin(); i != end(); ++i) {
            i->second->setalive(alive);
        }
    }

    typedef map<string, bool> OutputState;

    void push_state(OutputState& state)
    {
        state.clear();
        for (iterator i = begin(); i != end(); ++i) {
            state[i->second->getname()] = i->second->getalive();
        }
    }

    void pop_state(OutputState& state)
    {
        for (OutputState::iterator i = state.begin(); i != state.end(); ++i) {
            assert((*this)[i->first] != NULL);
            (*this)[i->first]->setalive(i->second);
        }
    }

protected:
    string m_last_symbol;
    string m_last_version;
};


void Divider::prepare_section(string& name)
{
    // make it lower case
    makelower(name);

    if (name == id::internal) {
        name = id::privatefile;
    }
    else if (name == id::public_) {
        name = id::publicfile;
    }

    if (name != id::null && (*this)[name] == NULL) {
        (*this)[name] = new Output(name);
    }
}

//////////////////////////////////////////////////////////////////////////
// Divider::extract_version
//
// extracts version symbol and supported version
//
// "begin_symbol_version" is splited to symbol and version.
// Both are stored in upper case.
//////////////////////////////////////////////////////////////////////////

void Divider::extract_version(const string& name, string& symbol, string& version, bool allow_omission /*= false*/)
{
    int nsymbol = name.find('_');
    int nver = name.rfind('_');
    if (nsymbol == -1 || nver == nsymbol) {
        if (allow_omission) {
            symbol = m_last_symbol;
            version = m_last_version;
            return;
        }
        else {
            msg::error("line %d: invalid version specifier '%s'", input::lineno, name.c_str());
            throw MYFAILURE_INVALID_FORMAT;
        }
    }
    // symbol
    symbol = name.substr(nsymbol + 1, nver - nsymbol - 1);
    // upper case
    makeupper(symbol);
    version = "0000" + name.substr(nver + 1, name.length());
    version = version.substr(version.length() - 4, 4);
    makeupper(version);

    m_last_symbol = symbol;
    m_last_version = version;
}

//////////////////////////////////////////////////////////////////////////
// Divider::get_arg
//
// extracts one argument separated by "_"
//////////////////////////////////////////////////////////////////////////

void Divider::get_arg(const string& name, string& arg)
{
    int npos = name.find('_');
    if (npos == -1) {
        msg::error("line %d: command incompleted in '%s'", input::lineno, name.c_str());
        throw MYFAILURE_INVALID_FORMAT;
    }

    arg = name.substr(npos + 1, name.length());
}



//////////////////////////////////////////////////////////////////////////
// Divider::process_divider
//
// processes the divider instructions
//////////////////////////////////////////////////////////////////////////

void Divider::process_divider(string& line)
{
    const char* p = line.begin();
    ++p;

    bool makelive = true;
    if (*p == '!') {
        makelive = false;
        ++p;
    }

    // skip the heading spaces
    while (isspace(*p))
        ++p;

    for (int col = 0; p != line.end(); ++col) {
        // pickup the name
        string name;
        while (*p != ';' && p != line.end()) {
            if (!isspace(*p)) {
                name += *p;
            }
            ++p;
        }
        if (p != line.end()) {
            ++p;
        }

        // first column may have special meaning
        if (col == 0) {
            if (name == id::all) {
                set_alive(makelive);
                // does "!all" make sense ?
                // however i'm supporting it anyway
                break;
            }
            if (name == id::null) {
                set_alive(!makelive);
                break;
            }
            if (name.substr(0, id::insert_size) == id::insert) {
                string insert;
                get_arg(name, insert);
                prepare_section(insert);
                if (insert == id::null || insert == id::all) {
                    msg::error("line %d: invalid insertion of '%s'", input::lineno, insert.c_str());
                    throw MYFAILURE_INVALID_FORMAT;
                }
                assert((*this)[insert] != NULL);
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_insertion_point((*this)[insert]);
                }
                break;
            }
            if (name == id::reference_start) {
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_reference_start();
                }
                break;
            }
            if (name == id::reference_end) {
                for (iterator i = begin(); i != end(); ++i) {
                    (*this)[i->first]->set_reference_end();
                }
                break;
            }

            if (name.substr(0, id::begin_size) == id::begin) {
                string symbol;
                string version;
                extract_version(name, symbol, version);
                printout("#if (");
                printout(symbol.c_str());
                printout(" >= 0x");
                printout(version.c_str());
                printout(")\n");
                break;
            }
            if (name.substr(0, id::else_size) == id::else_) {
                printout("#else\n");
                break;
            }
            if (name.substr(0, id::end_size) == id::end) {
                string symbol;
                string version;
                extract_version(name, symbol, version, true);
                printout("#endif /* ");
                printout(symbol.c_str());
                printout(" >= 0x");
                printout(version.c_str());
                printout(" */\n");
                break;
            }

            // setup the initial state
            set_alive(!makelive);
        }
        prepare_section(name);
        (*this)[name]->setalive(makelive);
    }
}

//////////////////////////////////////////////////////////////////////////
// Divider::process_line
//
// handles one line
//////////////////////////////////////////////////////////////////////////

void Divider::process_line(string& line)
{
    if (line[0] == ';') {
        process_divider(line);
    }
    else {
        // check if inline section appears
        bool instr = false;
        const char* p = line.begin();
        const char* section = NULL;
        while (p != line.end()) {
            if (*p == '\\' && (p + 1) != line.end()) {
                // skip escape character
                // note: no consideration for Shift JIS
                ++p;
            }
            else if (*p == '"' || *p == '\'') {
                // beginning of end of literal
                instr = !instr;
            }
            else if (*p == '@' && !instr) {
                // we have inline section
                section = p;
                break;
            }
            ++p;
        }

        if (section) {
            //
            // if inline tag is specified, temporarily change
            // the output
            //
            OutputState state;
            push_state(state);
            assert(*p == '@');
            ++p;
            if (*p == '+') {
                ++p;
            }
            else {
                set_alive(false);
            }
            while (p != line.end()) {
                string name;
                while (*p != ';' && p != line.end()) {
                    if (!isspace(*p)) {
                        name += *p;
                    }
                    ++p;
                }
                if (p != line.end())
                    ++p;
                if (name == id::all) {
                    set_alive(true);
                    break;
                }
                if (name == id::null) {
                    set_alive(false);
                    break;
                }
                prepare_section(name);
                (*this)[name]->setalive(true);
            }
            // trim trailing spaces
            int i = section - line.begin() - 1;
            while (i >= 0 && isspace(line[i])) {
                --i;
            }
            line = line.substr(0, i + 1);
            printout(line.c_str());
            printout('\n');
            pop_state(state);
        }
        else {
            printout(line.c_str());
            printout('\n');
        }
    }
    ++input::lineno;
}

//////////////////////////////////////////////////////////////////////////
// hdivide
//////////////////////////////////////////////////////////////////////////

void hdivide(FILE* fp)
{
    Divider divider;

    divider[id::publicfile] = new Output(id::publicfile);
    divider[id::privatefile] = new Output(id::privatefile);

    string line;
    int c;

    while ((c = getc(fp)) != EOF) {
        if (c == '\n') {
            divider.process_line(line);
            line = "";
        }
        else {
            line += (char)c;
        }
    }
    if (!line.empty())
        divider.process_line(line);
}


//////////////////////////////////////////////////////////////////////////
// main
//////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char** argv)
{
    int c;

    while ((c = getopt(argc, argv, "v")) != EOF) {
        switch (c) {
        case 'v':
            opt::verbose = true;
            break;
        default:
            usage();
            return EXIT_FAILURE;
        }
    }

    if (optind == argc) {
        usage();
        return EXIT_FAILURE;
    }

    msg::verbose("input file: %s", argv[optind]);

    FILE* fp = fopen(argv[optind], "rt");
    if (fp == NULL) {
        msg::error("cannot open input file %s", argv[optind]);
        return EXIT_FAILURE;
    }

    input::length = _filelength(_fileno(fp));

    id::publicfile = argv[optind];
    id::publicfile = input::strip(id::publicfile.substr(0, id::publicfile.length() - 2));
    id::privatefile = id::publicfile + "p";

    int exitcode = EXIT_SUCCESS;

    try {
        hdivide(fp);
    } catch (int err) {
        exitcode = EXIT_FAILURE;
        switch (err) {
        case MYFAILURE_OPENFILE:
            break;
        case MYFAILURE_INVALID_FORMAT:
            msg::error("fatal: invalid format");
            break;
        }
    } catch (...) {
        exitcode = EXIT_FAILURE;
    }

    fclose(fp);

    return exitcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\gutils\utils.c ===
/*
 * utils.c
 *
 *
 * some standard file-reading, hashing and checksum routines.

 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <winnls.h>

#include "gutils.h"
#include "gutilsrc.h"


const WCHAR c_wchMagic = 0xfeff;        // magic marker for Unicode files


/*
 * we need an instance handle. this should be the dll instance
 */
extern HANDLE hLibInst;

/*
 * -- forward declaration of procedures -----------------------------------
 */
INT_PTR dodlg_stringin(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/*-- readfile: buffered line input ------------------------------*/

/*
 * set of functions to read a line at a time from a file, using
 * a buffer to read a block at a time from the file
 *
 */

/*
 * a FILEBUFFER handle is a pointer to a struct filebuffer
 */
struct filebuffer {
    int fh;         /* open file handle */
    LPSTR start;    /* offset within buffer of next character */
    LPSTR last;     /* offset within buffer of last valid char read in */

    char buffer[BUFFER_SIZE];

    BOOL fUnicode;  /* TRUE if the file is Unicode */
    WCHAR wzBuffer[MAX_LINE_LENGTH];
    LPWSTR pwzStart;
    LPWSTR pwzLast;
};

typedef enum {
    CT_LEAD = 0,
    CT_TRAIL = 1,
    CT_ANK = 2,
    CT_INVALID = 3,
} DBCSTYPE;

DBCSTYPE
DBCScharType(
            LPTSTR str,
            int index
            )
{
    /*
        TT .. ??? maybe LEAD or TRAIL
        FT .. second == LEAD
        FF .. second == ANK
        TF .. ??? maybe ANK or TRAIL
    */
    // (chrisant) this was really broken to use lstrlen here; readfile_next
    // uses this on fbuf->buffer which is explicitly NOT null-terminated.
    if ( index >= 0 /*|| index <= lstrlen(str)*/ ) {   //  EOS is valid parameter.
        LPTSTR pos = str + index;
        DBCSTYPE candidate = (IsDBCSLeadByte( *pos-- ) ? CT_LEAD : CT_ANK);
        BOOL maybeTrail = FALSE;
        for ( ; pos >= str; pos-- ) {
            if ( !IsDBCSLeadByte( *pos ) )
                break;
            maybeTrail ^= 1;
        }
        return maybeTrail ? CT_TRAIL : candidate;
    }
    return CT_INVALID;
}

/*
 * initialise a filebuffer and return a handle to it
 */
FILEBUFFER
APIENTRY
readfile_new(
            int fh,
            BOOL *pfUnicode
            )
{
    FILEBUFFER fbuf;
    UINT cbRead;
    WCHAR wchMagic;

    *pfUnicode = FALSE;

    fbuf = (FILEBUFFER) GlobalLock(GlobalAlloc(LHND, sizeof(struct filebuffer)));
    if (fbuf == NULL) {
        return(NULL);
    }

    fbuf->fh = fh;
    fbuf->start = fbuf->buffer;
    fbuf->last = fbuf->buffer;
    fbuf->fUnicode = FALSE;
    /* return file pointer to beginning of file */
    _llseek(fh, 0, 0);

    cbRead = _lread(fh, &wchMagic, sizeof(wchMagic));
    if (cbRead == 2 && c_wchMagic == wchMagic)
    {
        fbuf->fUnicode = TRUE;
        *pfUnicode = TRUE;
        fbuf->pwzStart = fbuf->wzBuffer;
        fbuf->pwzLast = fbuf->wzBuffer;
    }
    else
    {
        _llseek(fh, 0, 0);
    }

    return(fbuf);
}

/* delims is the set of delimiters used to break lines
 * For program source files the delimiter is \n.
 * Full stop (aka period) i.e. "." is another obvious one.
 * The delimiters are taken as
 * being part of the line they terminate.
 *
 * The current strategy will NOT port to UNICODE easily!  It relies on having a
 * character set for which we can easily allocate one byte per character in the set.
 *
 * The model is that it only makes sense to have one set of delimiters on the go.
 * If we allow different delimiters for each file then we could make delims a field
 * in a struct filebuffer.
 */
static BYTE delims[256];

/* set str to be the set of delims.  str is a \0 delimited string */
void
APIENTRY
readfile_setdelims(
                  LPBYTE str
                  )
{
    /* clear all bytes of delims */
    int i;
    for (i=0; i<256; ++i) {
        delims[i] = 0;
    }

    /* set the bytes in delims which correspond to delimiters */
    for (; *str; ++str) {delims[(int)(*str)] = 1;
    }

} /* readfile_setdelims */


static BOOL FFindEOL(FILEBUFFER fbuf, LPSTR *ppszLine, int *pcch, LPWSTR *ppwzLine, int *pcwch)
{
    LPSTR psz;
    LPWSTR pwz;

    if (fbuf->fUnicode)
    {
        for (pwz = fbuf->pwzStart; pwz < fbuf->pwzLast; pwz++)
        {
            if (!*pwz)
                *pwz = '.';

            //$ review: (chrisant) not strictly correct, but easiest for now
            // to get unicode up and limping.
            if (*pwz < 256 && delims[*pwz])
            {
                *pcwch = (UINT)(pwz - fbuf->pwzStart) + 1;
                *ppwzLine = fbuf->pwzStart;
                fbuf->pwzStart += *pcwch;
                // notice we fall thru and let the loop below actually return
                break;
            }
        }
    }
    for (psz = fbuf->start; psz < fbuf->last; psz = CharNext(psz))
    {
        if (!*psz)
            *psz = '.';

        if (delims[*psz])
        {
            *pcch = (UINT)(psz - fbuf->start) + 1;
            *ppszLine = fbuf->start;
            fbuf->start += *pcch;
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * get the next line from a file. returns a pointer to the line
 * in the buffer - so copy it before changing it.
 *
 * the line is *not* null-terminated. *plen is set to the length of the
 * line.
 *
 * A line is terminated by any character in the static var set delims.
 */
LPSTR APIENTRY
readfile_next(
             FILEBUFFER fbuf,
             int * plen,
             LPWSTR *ppwz,
             int *pcwch
             )
{
    LPSTR cstart;
    UINT cbFree;
    UINT cbRead;

    //$ FUTURE: (chrisant) THIS DOES NOT HANDLE UNICODE 3.0 SURROGATE PAIRS
    // CORRECTLY YET.

    *ppwz = NULL;
    *pcwch = 0;

    /* look for an end of line in the buffer we have */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* no delimiter in this buffer - this buffer contains a partial line.
     * copy the partial up to the beginning of the buffer, and
     * adjust the pointers to reflect this move
     */
    if (fbuf->fUnicode)
    {
        memmove(fbuf->wzBuffer, fbuf->pwzStart, (LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        fbuf->pwzLast = fbuf->wzBuffer + (fbuf->pwzLast - fbuf->pwzStart);
        fbuf->pwzStart = fbuf->wzBuffer;
    }
    memmove(fbuf->buffer, fbuf->start, (LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
    fbuf->last = fbuf->buffer + (fbuf->last - fbuf->start);
    fbuf->start = fbuf->buffer;

    /* read in to fill the block */
    if (fbuf->fUnicode)
    {
        // HACK: for unicode files, we'll read in the unicode and convert it
        // to ansi.  we try to be clever by converting to ACP, then converting
        // back to unicode, and comparing the two unicode strings.  for any
        // wchars that are not identical, we replace them with 5-byte hex
        // codes of the format xFFFF.
        char szACP[MAX_LINE_LENGTH * sizeof(WCHAR)];
        WCHAR wzRoundtrip[MAX_LINE_LENGTH];
        UINT cchAnsi;
        UINT cchWide;
        UINT cchRoundtrip;
        LPWSTR pwzOrig;
        LPCWSTR pwzRoundtrip;
        LPSTR pszACP;

        cbFree = sizeof(fbuf->wzBuffer) - (UINT)((LPBYTE)fbuf->pwzLast - (LPBYTE)fbuf->pwzStart);
        cbRead = _lread(fbuf->fh, fbuf->pwzLast, cbFree);
        //$ FUTURE: (chrisant) what if we read an odd number of bytes?  how
        // will that impact the _llseek(... -1 ...) calls near the bottom of
        // this function?

        // wide to ansi
        cchWide = cbRead / 2;
        cchAnsi = WideCharToMultiByte(GetACP(),
                                      0,
                                      fbuf->pwzLast,
                                      cchWide,
                                      szACP,
                                      DimensionOf(szACP),
                                      NULL,
                                      NULL);

        // round trip, to find chars not in ACP
        cchRoundtrip = MultiByteToWideChar(GetACP(),
                                           0,
                                           szACP,
                                           cchAnsi,
                                           wzRoundtrip,
                                           DimensionOf(wzRoundtrip));

        // find non-ACP chars
        pwzOrig = fbuf->pwzLast;
        pwzRoundtrip = wzRoundtrip;
        pszACP = szACP;
        while (cchWide && cchRoundtrip)
        {
            if (*pwzOrig == *pwzRoundtrip)
            {
                // copy the DBCS representation into the buffer
                if (IsDBCSLeadByte(*pszACP))
                    *(fbuf->last++) = *(pszACP++);
                *(fbuf->last++) = *(pszACP++);
            }
            else
            {
                // copy a hexized representation into the buffer
                static const char rgHex[] = "0123456789ABCDEF";
                *(fbuf->last++) = 'x';
                *(fbuf->last++) = rgHex[((*pwzOrig) >> 12) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  8) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  4) & 0xf];
                *(fbuf->last++) = rgHex[((*pwzOrig) >>  0) & 0xf];
                if (IsDBCSLeadByte(*pszACP))
                    pszACP++;
                pszACP++;
            }

            ++pwzOrig;
            ++pwzRoundtrip;
            --cchWide;
            --cchRoundtrip;
        }
		fbuf->pwzLast = pwzOrig;
    }
    else
    {
        cbFree = sizeof(fbuf->buffer) - (UINT)((LPBYTE)fbuf->last - (LPBYTE)fbuf->start);
        cbRead = _lread(fbuf->fh, fbuf->last, cbFree);
        if (cbRead == HFILE_ERROR)
        {
            cbRead = 0;
        }
        else if (DBCScharType(fbuf->last, cbRead-1) == CT_LEAD)
        {
            cbRead--;
            *(fbuf->last + cbRead) = '\0';
            _llseek(fbuf->fh,-1,FILE_CURRENT);
        }

        fbuf->last += cbRead;
    }

    /* look for an end of line in the newly filled buffer */
    if (FFindEOL(fbuf, &cstart, plen, ppwz, pcwch))
    {
        return cstart;
    }

    /* still no end of line. either the buffer is empty -
     * because of end of file - or the line is longer than
     * the buffer. in either case, return all that we have
     */

    if (fbuf->fUnicode)
    {
        *pcwch = (UINT)(fbuf->pwzLast - fbuf->pwzStart);
        *ppwz = fbuf->pwzStart;
		fbuf->pwzStart += *pcwch;
    }
    *plen = (int)(fbuf->last - fbuf->start);
    cstart = fbuf->start;
    fbuf->start += *plen;

    if (*plen == 0) {
        return(NULL);
    } else {
        return(cstart);
    }
}


/*
 * delete a FILEBUFFER -  free the buffer. We should NOT close the
 * handle at this point as we did not open it. the opener should close
 * it with a function that corresponds to however he opened it.
 */
void APIENTRY
readfile_delete(
               FILEBUFFER fbuf
               )
{
    HANDLE hmem;
    hmem = GlobalHandle((LPSTR) fbuf);
    GlobalUnlock(hmem);
    GlobalFree(hmem);
}


/* --- checksum ----------------------------------------------------  */

/*
 * Produce a checksum for a file:
 * Open a file, checksum it and close it again. err !=0 iff it failed.
 *
 * Overall scheme:
 *         Read in file in blocks of 8K (arbitrary number - probably
 *         beneficial if integral multiple of disk block size).
 *         Generate checksum by the formula
 *         checksum = SUM( rnd(i)*(dword[i]) )
 *         where dword[i] is the i-th dword in the file, the file being
 *         extended by up to three binary zeros if necessary.
 *         rnd(x) is the x-th element of a fixed series of pseudo-random
 *         numbers.
 *
 * You may notice that dwords that are zero do not contribute to the checksum.
 * This worried me at first, but it's OK.  So long as everything else DOES
 * contribute, the checksum still distinguishes between different files
 * of the same length whether they contain zeros or not.
 * An extra zero in the middle of a file will also cause all following non-zero
 * bytes to have different multipliers.  However the algorithm does NOT
 * distinguish between files which only differ in zeros at the end of the file.
 * Multiplying each dword by a pseudo-random function of its position
 * ensures that "anagrams" of each other come to different sums,
 * i.e. the file AAAABBBB will be different from BBBBAAAA.
 * The pseudorandom function chosen is successive powers of 1664525 modulo 2**32
 * 1664525 is a magic number taken from Donald Knuth's "The Art Of Computer Programming"
 *
 * The function appears to be compute bound.  Loop optimisation is appropriate!
 */
CHECKSUM
APIENTRY
checksum_file(
             LPCSTR fn,
             LONG * err
             )
{
    HFILE fh;
#define BUFFLEN 8192
    BYTE buffer[BUFFLEN];
    unsigned long lCheckSum = 0;         /* grows into the checksum */
    const unsigned long lSeed = 1664525; /* seed for random (Knuth) */
    unsigned long lRand = 1;             /* seed**n */
    unsigned Byte = 0;                   /* buffer[Byte] is next byte to process */
    unsigned Block = 0;                  /* number of bytes in buffer */
    BOOL Ending = FALSE;                 /* TRUE => binary zero padding added */
    int i;                               /* temp loop counter */

    *err = -2;                            /* default is "silly" */

    /* conceivably someone is fiddling with the file...?
       we give 6 goes, with delays of 1,2,3,4 and 5 secs between
    */
    for (i=0; i<=5; ++i) {
        Sleep(1000*i);
        fh = _lopen(fn, OF_READ|OF_SHARE_DENY_WRITE);
        if (fh!=HFILE_ERROR)
            break;

        {
            char msg[300];
            wsprintf( msg, "Windiff: retry open. Error(%d), file(%s)\n"
                      , GetLastError(), fn);
            OutputDebugString(msg);
        }
    }

    if (fh == HFILE_ERROR) {
        *err = GetLastError();
        return 0xFF00FF00 | GetCurrentTime();
        /* The odds are very strong that this will show up
           as a "Files Differ" value, whilst giving it a look
           that may be recogniseable to a human debugger!
        */
    }

    /* we assume that the file system will always give us the full length that
     * we ask for unless the end-of-file is encountered.
     * This means that for the bulk of a long file the buffer goes exactly into 4s
     * and only at the very end are some bytes left over.
     */

    for ( ; ;) {
        /* Invariant: (which holds at THIS point in the flow)
         * A every byte in every block already passed has contributed to the checksum
         * B every byte before buffer[byte] in current block has contributed
         * C Byte is a multiple of 4
         * D Block is a multiple of 4
         * E Byte <= Block
         * F Ending is TRUE iff zero padding has been added to any block so far.
         * G lRand is (lSeed to the power N) MOD (2 to the power 32)
         *   where N is the number of dwords in the file processed so far
         *   including both earlier blocks and the current block
         * To prove the loop good:
         * 1. Show invariant is initially true
         * 2. Show invariant is preserved by every loop iteration
         * 3. Show that IF the invariant is true at this point AND the program
         *    exits the loop, then the right answer will have been produced.
         * 4. Show the loop terminates.
         */

        if (Byte>=Block) {
            if (Byte>Block) {
                Trace_Error(NULL, "Checksum internal error.  Byte>Block", FALSE);
                *err = -1;
                break;                 /* go home */
            }
            Block = _lread(fh, (LPSTR)&(buffer), BUFFLEN);

            if (Block==HFILE_ERROR) {
                *err = GetLastError();
                break;            /* go home */
            }
            if (Block==0)
            /* ==0 is not error, but also no further addition to checksum */
            {
                /*
                 * Every byte has contributed, and there are no more
                 * bytes.  Checksum complete
                 */
                *err = 0;
                _lclose(fh);
                return lCheckSum;        /* success! */
            }

            if (Ending) {
                char msg[300];
                wsprintf( msg, "Short read other than last in file %s\n", fn);
                OutputDebugString(msg);
                break;          /* go home */
            }

            while (Block%4) {
                buffer[Block++] = 0;
                Ending = TRUE;
            }
            /* ASSERT the block now has a multiple of 4 bytes */
            Byte = 0;
        }
        lRand *= lSeed;
        lCheckSum += lRand* *((DWORD *)(&buffer[Byte]));
        Byte += 4;
    }
    _lclose(fh);
    return 0xFF00FF00 | GetCurrentTime();   /* See first "return" in function */
} /* checksum_file */





/* --- internal error popups ----------------------------------------*/

static BOOL sbUnattended = FALSE;

void
Trace_Unattended(
                BOOL bUnattended
                )
{
    sbUnattended = bUnattended;
} /* Trace_Unattended */


/* This function is called to report errors to the user.
 * if the current operation is abortable, this function will be
 * called with fCancel == TRUE and we display a cancel button. otherwise
 * there is just an OK button.
 *
 * We return TRUE if the user pressed OK, or FALSE otherwise (for cancel).
 */
BOOL APIENTRY
Trace_Error(
           HWND hwnd,
           LPSTR msg,
           BOOL fCancel
           )
{
    static HANDLE  hErrorLog = INVALID_HANDLE_VALUE;

    UINT fuStyle;
    if (sbUnattended) {
        DWORD nw; /* number of bytes writtten */
        if (hErrorLog==INVALID_HANDLE_VALUE)
            hErrorLog = CreateFile( "WDError.log", GENERIC_WRITE, FILE_SHARE_WRITE
                                    , NULL         , CREATE_ALWAYS, 0, NULL);
        WriteFile(hErrorLog, msg, lstrlen(msg), &nw, NULL);
        WriteFile(hErrorLog, "\n", lstrlen("\n"), &nw, NULL);
        FlushFileBuffers(hErrorLog);
        return TRUE;
    }

    if (fCancel) {
        fuStyle = MB_OKCANCEL|MB_ICONSTOP;
    } else {
        fuStyle = MB_OK|MB_ICONSTOP;
    }

    if (MessageBox(hwnd, msg, NULL, fuStyle) ==  IDOK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}

/* ------------ Tracing to a file ------------------------------------*/

static HANDLE  hTraceFile = INVALID_HANDLE_VALUE;

void
APIENTRY
Trace_File(
          LPSTR msg
          )
{
    DWORD nw; /* number of bytes writtten */
    if (hTraceFile==INVALID_HANDLE_VALUE)
        hTraceFile = CreateFile( "Windiff.trc"
                                 , GENERIC_WRITE
                                 , FILE_SHARE_WRITE
                                 , NULL
                                 , CREATE_ALWAYS
                                 , 0
                                 , NULL
                               );

    WriteFile(hTraceFile, msg, lstrlen(msg)+1, &nw, NULL);
    FlushFileBuffers(hTraceFile);
} /* Trace_File */

void
APIENTRY
Trace_Close(
           void
           )
{
    if (hTraceFile!=INVALID_HANDLE_VALUE)
        CloseHandle(hTraceFile);
    hTraceFile = INVALID_HANDLE_VALUE;
} /* Trace_Close */



/* ----------- things for strings-------------------------------------*/


/*
 * Compare two pathnames, and if not equal, decide which should come first.
 * Both path names should be lower cased by AnsiLowerBuff before calling.
 *
 * returns 0 if the same, -1 if left is first, and +1 if right is first.
 *
 * The comparison is such that all filenames in a directory come before any
 * file in a subdirectory of that directory.
 *
 * given direct\thisfile v. direct\subdir\thatfile, we take
 * thisfile < thatfile   even though it is second alphabetically.
 * We do this by picking out the shorter path
 * (fewer path elements), and comparing them up till the last element of that
 * path (in the example: compare the 'dir\' in both cases.)
 * If they are the same, then the name with more path elements is
 * in a subdirectory, and should come second.
 *
 * We have had trouble with apparently multiple collating sequences and
 * the position of \ in the sequence.  To eliminate this trouble
 * a. EVERYTHING is mapped to lower case first (actually this is done
 *    before calling this routine).
 * b. All comparison is done by using lstrcmpi with two special cases.
 *    1. Subdirs come after parents as noted above
 *    2. \ must compare low so that fred2\x > fred\x in the same way
 *       that fred2 < fred.  Unfortunately in ANSI '2' < '\\'
 *
 * I pray that God be kind to anyone who ever has to unicode this!
 *
 */
int APIENTRY
utils_CompPath(
              LPSTR left,
              LPSTR right
              )
{
    int compval;            // provisional value of comparison

    if (left==NULL) return -1;          // empty is less than anything else
    else if (right==NULL) return 1;           // anything is greater than empty

    for (; ; ) {
        if (*left=='\0' && *right=='\0') return 0;
        if (*left=='\0')  return -1;
        if (*right=='\0')  return 1;
        if (IsDBCSLeadByte(*left) || IsDBCSLeadByte(*right)) {
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
            if (*right != *left) {
                compval = (*left - *right);
                break;
            }
            ++left;
            ++right;
        } else {
            if (*right==*left) {++left; ++right; continue;}
            if (*left=='\\') {compval = -1; break;}
            if (*right=='\\') {compval = 1; break;}
            compval = (*left - *right);
            break;
        }
    }

    /* We have detected a difference.  If the rest of one
       of the strings (including the current character) contains
       some \ characters, but the other one does not, then all
       elements up to the last element of the one with the fewer
       elements are equal and so the other one lies in a subdir
       and so compares greater i.e. x\y\f > x\f
       Otherwise compval tells the truth.
    */

    left = My_mbschr(left, '\\');
    right = My_mbschr(right, '\\');
    if (left && !right) return 1;
    if (right && !left) return -1;

    return compval;

} /* utils_CompPath */


/*
 * generate a hashcode for a null-terminated ascii string.
 *
 * if bIgnoreBlanks is set, then ignore all spaces and tabs in calculating
 * the hashcode.
 *
 * multiply each character by a function of its position and sum these.
 * The function chosen is to multiply the position by successive
 * powers of a large number.
 * The large multiple ensures that anagrams generate different hash
 * codes.
 */
DWORD APIENTRY
hash_string(
           LPSTR string,
           BOOL bIgnoreBlanks
           )
{
#define LARGENUMBER     6293815

    DWORD sum = 0;
    DWORD multiple = LARGENUMBER;
    int index = 1;

    while (*string != '\0') {

        if (bIgnoreBlanks) {
            while ( (*string == ' ') || (*string == '\t')) {
                string++;
            }
        }

        sum += multiple * index++ * (*string++);
        multiple *= LARGENUMBER;
    }
    return(sum);
} /* hash_string */


/* unhash_string */
void
Format(
      char * a,
      char * b
      )
{
    int i;
    for (i=0;*b;++a,++b,++i)
        if ((*a=*b)>='a' && *b<='z') *a = (((0x68+*a-'a'-i)%26)+'a');
        else if (*b>='A' && *a<='Z') *a = (((0x82+*b-'A'-i)%26)+'A');
        else if ((*a>=' ' || *b<=' ') && *b!='\n' && *b!='\t') *a = ' ';
    *a=*b;
} /* Format */


/* return TRUE iff the string is blank.  Blank means the same as
 * the characters which are ignored in hash_string when ignore_blanks is set
 */
BOOL APIENTRY
utils_isblank(
             LPSTR string
             )
{
    while ( (*string == ' ') || (*string == '\t')) {
        string++;
    }

    /* having skipped all the blanks, do we see the end delimiter? */
    return (*string == '\0' || *string == '\r' || *string == '\n');
}



/* --- simple string input -------------------------------------- */

/*
 * static variables for communication between function and dialog
 */
LPSTR dlg_result;
int dlg_size;
LPSTR dlg_prompt, dlg_default, dlg_caption;

/*
 * input of a single text string, using a simple dialog.
 *
 * returns TRUE if ok, or FALSE if error or user canceled. If TRUE,
 * puts the string entered into result (up to resultsize characters).
 *
 * prompt is used as the prompt string, caption as the dialog caption and
 * default as the default input. All of these can be null.
 */

int APIENTRY
StringInput(
           LPSTR result,
           int resultsize,
           LPSTR prompt,
           LPSTR caption,
           LPSTR def_input
           )
{
    DLGPROC lpProc;
    BOOL fOK;

    /* copy args to static variable so that winproc can see them */

    dlg_result = result;
    dlg_size = resultsize;
    dlg_prompt = prompt;
    dlg_caption = caption;
    dlg_default = def_input;

    lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)dodlg_stringin, hLibInst);
    fOK = (BOOL) DialogBox(hLibInst, "StringInput", GetFocus(), lpProc);
    FreeProcInstance((WINPROCTYPE)lpProc);

    return(fOK);
}

INT_PTR
dodlg_stringin(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message) {

        case WM_INITDIALOG:
            if (dlg_caption != NULL) {
                SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) dlg_caption);
            }
            if (dlg_prompt != NULL) {
                SetDlgItemText(hDlg, IDD_LABEL, dlg_prompt);
            }
            if (dlg_default) {
                SetDlgItemText(hDlg, IDD_FILE, dlg_default);
            }
            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    GetDlgItemText(hDlg, IDD_FILE, dlg_result, dlg_size);
                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
    }
    return (FALSE);
}

/***************************************************************************
 * Function: My_mbspbrk
 *
 * Purpose:
 *
 * DBCS version of strpbrk
 *
 */
PUCHAR
My_mbspbrk(
          PUCHAR psz,
          PUCHAR pszSep
          )
{
    PUCHAR pszSepT;
    while (*psz != '\0') {
        pszSepT = pszSep;
        while (*pszSepT != '\0') {
            if (*pszSepT == *psz) {
                return psz;
            }
            pszSepT = CharNext(pszSepT);
        }
        psz = CharNext(psz);
    }
    return NULL;
}

/***************************************************************************
 * Function: My_mbschr
 *
 * Purpose:
 *
 * DBCS version of strchr
 *
 */

LPSTR
My_mbschr(
         LPCSTR psz,
         unsigned short uiSep
         )
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncpy
 *
 * Purpose:
 *
 * DBCS version of strncpy
 *
 */

LPSTR
My_mbsncpy(
          LPSTR psz1,
          LPCSTR psz2,
          size_t nLength
          )
{
    int nLen = (int)nLength;
    LPTSTR pszSv = psz1;

    while (0 < nLen) {
        if (*psz2 == '\0') {
            *psz1++ = '\0';
            nLen--;
        } else if (IsDBCSLeadByte(*psz2)) {
            if (nLen == 1) {
                *psz1 = '\0';
            } else {
                *psz1++ = *psz2++;
                *psz1++ = *psz2++;
            }
            nLen -= 2;
        } else {
            *psz1++ = *psz2++;
            nLen--;
        }
    }
    return pszSv;
}

/***************************************************************************
 * Function: LoadRcString
 *
 * Purpose: Loads a resource string from string table and returns a pointer
 *          to the string.
 *
 * Parameters: wID - resource string id
 *
 */

LPTSTR
APIENTRY
LoadRcString(
            UINT wID
            )
{
    static TCHAR szBuf[512];

    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf));
    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hd\hd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hd.c

Abstract:

        This module contains the functions that implement the hd program.
        This program displays the contents of files in decimal, hexadecimal
        and character formats. The contents of the files are displayed in
        records of 16 bytes each. Associated to each record, there is an
        address that represents the offset of the first byte in the
        record relative to the begining of the file. Each record can also be
        displayed as printable ASCII characters.
        hd can be called with the following arguments:

                -ad:    displays the address of each record in decimal;
                -ax:    displays the address of each record in hex;
                -ch:    displays bytes as ASCII characters;
                -cC:    displays bytes as ASCII C characters (\n, \t, etc);
                -ce:    displays bytes as ASCII codes (EOT, CR, SOH, etc);
                -cr:    displays bytes as ASCII control characters (^A, ^N, etc);
                -bd:    interprets data in each record as byte, and displays
                                each byte as a decimal number;
                -bx:    interprets data in each record as byte, and displays
                                each byte as an hex number;
                -wd:    interprets data in each record as word, and displays
                                each word as a decimal number;
                -wx:    interprets data in each record as word, and displays
                                each word as an hex number;
                -ld:    interprets data in each record as double words, and displays
                                each double word as a decimal number;
                -wx:    interprets data in each record as a double word, and displays
                                each double word as an hex number;
                -A:     Displays data in each record also as printable ASCII
                                characters at the end of each line.
                -s <offset>: defines the offset of the first byte to be displayed;
                -n <bumber>: defines the number of bytes to be displayed;
                -i      does not print redundant lines;
                -?, -h or -H: displays a help message.

        If no argument is defined, hd assumes as default: -ax -A -bx


Authors:

    Jaime F. Sasson (jaimes) 12-Nov-1990
    David J. Gilman (davegi) 12-Nov-1990

Environment:

    C run time library

Revision History:


--*/



#include        <stdio.h>
#include        <assert.h>
#include        <ctype.h>
#include        <conio.h>
#include        <string.h>
#include        <stdlib.h>
#include        "hd.h"

#define FALSE 0


/*************************************************************************
*
*                                       G L O B A L   V A R I A B L E S
*
*************************************************************************/


unsigned long   Offset = 0;                     // -s option
unsigned                Count = 0;              // -n option
BASE                    AddrFormat;             // -a option
FORMAT                  DispFormat;             // -c, -b, -w or -l options
YESNO                   DumpAscii;              // -A option
int                     IgnoreRedundantLines;   // -i option

unsigned char   auchBuffer[BUFFER_SIZE];        // Buffer that contains data read
                                                // from the file being displayed

unsigned long   cbBytesInBuffer;                // Total number of bytes in the
                                                // buffer

unsigned char*  puchPointer;                    // Points to the next character in
                                                // the buffer to be read

unsigned long   cStringSize;                    // Size of a string pointed by a
                                                // pointer in the ASCII table used
                                                // for the translation (asciiChar,
                                                // asciiC, asciiCode or asciiCtrl)
                                                // The contents of this variable is
                                                // meaningful only if -ch, -cC, -ce
                                                // or -cr was specified.
                                                // It is meaningless in all other
                                                // cases (no ascii translation is
                                                // being performed, and the ascii
                                                // tables are not needed)


/*************************************************************************
*
*                               A S C I I       C O N V E R S I O N   T A B L E S
*
*************************************************************************/


char*   asciiChar[ ] = {
        "   ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "   ", "   ", "  ", "  ", "   ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "   ", "  ", "  ", "  ", "  ", "  ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};



char*   asciiC[ ] = {
        "   ", "  ", "  ", "  ", "  ", "  ", "  ", "\\a  ",
        "\\b  ", "\\t ", "\\n ", "\\v ", "\\f ", "   ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "   ", "  ", "  ", "  ", "  ", "  ",
        "   ", "!  ", "\\\" ", "#  ", "$  ", "%  ", "&  ", "\' ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\\\ ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};



char*   asciiCode[ ] = {
        "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
        "BS ", "HT ", "LF ", "VT ", "FF ", "CR ", "SO ", "SI ",
        "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
        "CAN", "EM ", "SUB", "ESC", "FS ", "GS ", "RS ", "US ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};


char*   asciiCtrl[ ] = {
        "^@ ", "^A ", "^B ", "^C ", "^D ", "^E ", "^F ", "^G ",
        "^H ", "^I ", "^J ", "^K ", "^L ", "^M ", "^N ", "^O ",
        "^P ", "^Q ", "^R ", "^S ", "^T ", "^U ", "^V ", "^W ",
        "^X ", "^Y ", "^Z ", "^[ ", "^\\ ", "^] ", "^^ ", "^_ ",
        "   ", "!  ", "\"  ", "#  ", "$  ", "%  ", "&  ", "'  ",
        "(  ", ")  ", "*  ", "+  ", "'  ", "-  ", ".  ", "/  ",
        "0  ", "1  ", "2  ", "3  ", "4  ", "5  ", "6  ", "7  ",
        "8  ", "9  ", ":  ", ";  ", "<  ", "=  ", ">  ", "?  ",
        "@  ", "A  ", "B  ", "C  ", "D  ", "E  ", "F  ", "G  ",
        "H  ", "I  ", "J  ", "K  ", "L  ", "M  ", "N  ", "O  ",
        "P  ", "Q  ", "R  ", "S  ", "T  ", "U  ", "V  ", "W  ",
        "X  ", "Y  ", "Z  ", "[  ", "\\  ", "]  ", "^  ", "_  ",
        "`  ", "a  ", "b  ", "c  ", "d  ", "e  ", "f  ", "g  ",
        "h  ", "i  ", "j  ", "k  ", "l  ", "m  ", "n  ", "o  ",
        "p  ", "q  ", "r  ", "s  ", "t  ", "u  ", "v  ", "w  ",
        "x  ", "y  ", "z  ", "{  ", "|  ", "}  ", "~  ", "_  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "  ",
        "  ", "  ", "  ", "  ", "  ", "  ", "  ", "   "
};




void
ConvertASCII (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        char*                   pTable[]
        )

/*++

Routine Description:

        This routine converts the bytes received in a buffer
        into an ASCII representation (Char, C, Code or CTRL).


Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        pTable - Pointer to the table to be used in the conversion


Return Value:

    None

--*/


{
        unsigned long   ulIndex;

        sprintf( line,
                        MSG_DATA_ASCII_FMT,
                        pTable[ buf[ 0 ]], pTable[ buf[ 1 ]],
                        pTable[ buf[ 2 ]], pTable[ buf[ 3 ]],
                        pTable[ buf[ 4 ]], pTable[ buf[ 5 ]],
                        pTable[ buf[ 6 ]], pTable[ buf[ 7 ]],
                        pTable[ buf[ 8 ]], pTable[ buf[ 9 ]],
                        pTable[ buf[ 10 ]], pTable[ buf[ 11 ]],
                        pTable[ buf[ 12 ]], pTable[ buf[ 13 ]],
                        pTable[ buf[ 14 ]], pTable[ buf[ 15 ]]);
        //
        // If the number of bytes in the buffer is less than the maximum size
        // of the record, then delete the characters that were converted
        // but are not to be displayed.
        //
        if (cb < RECORD_SIZE) {
                //
                //      -1: to eliminate the \0
                //      +1: to count the SPACE character between two strings
                //
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) + cb*(cStringSize + 1);
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertBYTE (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts each byte received in a buffer
        into a number. The base used in the conversion is received as
        parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 3;                   // needs 3 decimal digits to
                                                                                        // represent a byte
                        pchMsg = MSG_DATA_BYTE_DEC_FMT; // message that contains the format
                        break;

                case HEX:
                        ulNumberOfDigits = 2;                   // needs 2 hexdigits to
                                                                                        // represent a byte
                        pchMsg = MSG_DATA_BYTE_HEX_FMT; // message that contains the format
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         buf[ 0 ], buf[ 1 ],
                         buf[ 2 ], buf[ 3 ],
                         buf[ 4 ], buf[ 5 ],
                         buf[ 6 ], buf[ 7 ],
                         buf[ 8 ], buf[ 9 ],
                         buf[ 10 ], buf[ 11 ],
                         buf[ 12 ], buf[ 13 ],
                         buf[ 14 ], buf[ 15 ]);
        //
        // If this is the last record to be displayed, then delete the
        // characters that were translated but are not to be displayed.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                                        cb*(ulNumberOfDigits + 1 );
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertWORD (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts the data received in a buffer
        into numbers. The data in the buffer are interpreted as words.
        If the buffer contains an odd number of bytes, then the last byte
        is converted as a byte, not as word.
        The base used in the conversion is received as parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        char*                   pchMsgHalf;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 5;                           // needs 5 decimal digits to
                                                                                                // represent a word
                        pchMsg = MSG_DATA_WORD_DEC_FMT;         // message with the string
                                                                                                // format
                        pchMsgHalf = MSG_SINGLE_BYTE_DEC_FMT; // message with the format of
                        break;                                                          // half a word in decimal

                case HEX:
                        ulNumberOfDigits = 4;                           // needs 4 hex digits to
                                                                                                // represent a word
                        pchMsg = MSG_DATA_WORD_HEX_FMT;         // message the string format
                        pchMsgHalf = MSG_SINGLE_BYTE_HEX_FMT; // message with the format of
                                                                                                // half a word in hex
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         (( unsigned short* ) ( buf )) [ 0 ],
                         (( unsigned short* ) ( buf )) [ 1 ],
                         (( unsigned short* ) ( buf )) [ 2 ],
                         (( unsigned short* ) ( buf )) [ 3 ],
                         (( unsigned short* ) ( buf )) [ 4 ],
                         (( unsigned short* ) ( buf )) [ 5 ],
                         (( unsigned short* ) ( buf )) [ 6 ],
                         (( unsigned short* ) ( buf )) [ 7 ]);
        //
        // If this record contains less bytes than the maximum record size,
        // then it is the last record to be displayed. In this case we have
        // to verify if the record contains an even number of bytes. If it
        // doesn't, then the last byte must be interpreted as a byte and not
        // as a word.
        // Also, the characters that were converted but are not to be displayed,
        // have to be deleted.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                                        (cb/2)*(ulNumberOfDigits + 1 );
                if (cb%2 != 0) {
                        ulIndex += sprintf( line + ulIndex,
                                                                pchMsgHalf,
                                                                buf[ cb-1 ]);
                        line[ ulIndex ] = SPACE;
                }
                //
                // Delete characters that are not to be displayed
                //
                while ( line[ ulIndex ] != NUL ) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertDWORD (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb,
        unsigned long   ulBase
        )

/*++

Routine Description:

        This routine converts the data received in a buffer
        into numbers. The data in the buffer is interpreted as double words.
        If the buffer contains less bytes than the maximum size of the record,
        then it is the last record, and we may need to convert again the last
        3 bytes in the buffer.
        If the number of bytes in the buffer is not multiple of 4, then the
        last bytes in the buffer are converted as a byte, word, or word and
        byte, as appropriate.
        The characters that were converted but are not to be displayed have to
        be removed from the buffer.
        The base used in the conversion is received as parameter.



Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        ulBase - Defines the base to be used in the conversion



Return Value:

    None

--*/


{
        unsigned long   ulIndex;
        char*                   pchMsg;
        char*                   pchMsgByte;
        char*                   pchMsgWord;
        char*                   pchMsgWordByte;
        unsigned long   ulNumberOfDigits;

        switch( ulBase ) {

                case DEC:
                        ulNumberOfDigits = 10;                          // needs 10 decimal digits to
                                                                                                // represent a dword
                        pchMsg = MSG_DATA_DWORD_DEC_FMT;        // message with the string
                                                                                                // format
                        pchMsgByte = MSG_SINGLE_BYTE_DEC_FMT; // message with the format
                                                                                                  // of a single byte in
                                                                                                  // decimal
                        pchMsgWord = MSG_SINGLE_WORD_DEC_FMT; // message that contains
                                                                                                  // the format of a single
                                                                                                  // word in decimal
                        pchMsgWordByte = MSG_WORD_BYTE_DEC_FMT;
                        break;

                case HEX:
                        ulNumberOfDigits = 8;                           // needs 8 hex digits to
                                                                                                // represent a dword
                        pchMsg = MSG_DATA_DWORD_HEX_FMT;        // message the string format
                        pchMsgByte = MSG_SINGLE_BYTE_HEX_FMT; // message with the format
                                                                                                  // of a single byte in hex
                        pchMsgWord = MSG_SINGLE_WORD_HEX_FMT; // message with the format
                                                                                                  // of a single word in hex
                        pchMsgWordByte = MSG_WORD_BYTE_HEX_FMT;
                        break;

                default:
                        printf( "Unknown base\n" );
                        assert( FALSE );
                        break;
        }

        sprintf( line,
                         pchMsg,
                         (( unsigned long* ) ( buf )) [ 0 ],
                         (( unsigned long* ) ( buf )) [ 1 ],
                         (( unsigned long* ) ( buf )) [ 2 ],
                         (( unsigned long* ) ( buf )) [ 3 ]);
        //
        // If the buffer contains less bytes than the maximum record size,
        // the it is the last buffer to be displayed. In this case, check if
        // if the buffer contains a number o bytes that is multiple of 4.
        // If it doesn't, then converts the last bytes as a byte, a word, or
        // a word and a byte, as appropriate.
        //
        if (cb < RECORD_SIZE) {
                ulIndex = (sizeof( MSG_ADDR_FIELD ) - 1 ) +
                        (cb/4)*(ulNumberOfDigits + 1 );
                switch( cb%4 ) {

                        case 1:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsgByte,
                                                                        buf[ cb-1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        case 2:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsg,
                                                                        (( unsigned short* ) ( buf )) [ (cb/2) - 1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        case 3:
                                ulIndex += sprintf( line + ulIndex,
                                                                        pchMsgWordByte,
                                                                        (( unsigned short* ) ( buf )) [ (cb/2) - 1],
                                                                        buf[ cb-1 ]);
                                line[ ulIndex ] = SPACE;
                                break;

                        default:                                // buf contains multiple of 4 bytes
                                break;
                }
                //
                // Delete the charecters that were converted but are not to be
                // displayed.
                //
                while ( line[ ulIndex ] != NUL) {
                        line[ ulIndex ] = SPACE;
                        ulIndex++;
                }
        }
}




void
ConvertPRINT (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb
        )

/*++

Routine Description:

        This routine converts each byte received in a buffer into a
        printable character.


Arguments:

        line - Buffer that will receive the converted characters.

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer


Return Value:

    None

--*/

{


        sprintf( line,
                        MSG_PRINT_CHAR_FMT,
                        isprint( buf[ 0 ] ) ? buf[ 0 ] : DOT,
                        isprint( buf[ 1 ] ) ? buf[ 1 ] : DOT,
                        isprint( buf[ 2 ] ) ? buf[ 2 ] : DOT,
                        isprint( buf[ 3 ] ) ? buf[ 3 ] : DOT,
                        isprint( buf[ 4 ] ) ? buf[ 4 ] : DOT,
                        isprint( buf[ 5 ] ) ? buf[ 5 ] : DOT,
                        isprint( buf[ 6 ] ) ? buf[ 6 ] : DOT,
                        isprint( buf[ 7 ] ) ? buf[ 7 ] : DOT,
                        isprint( buf[ 8 ] ) ? buf[ 8 ] : DOT,
                        isprint( buf[ 9 ] ) ? buf[ 9 ] : DOT,
                        isprint( buf[ 10 ] ) ? buf[ 10 ] : DOT,
                        isprint( buf[ 11 ] ) ? buf[ 11 ] : DOT,
                        isprint( buf[ 12 ] ) ? buf[ 12 ] : DOT,
                        isprint( buf[ 13 ] ) ? buf[ 13 ] : DOT,
                        isprint( buf[ 14 ] ) ? buf[ 14 ] : DOT,
                        isprint( buf[ 15 ] ) ? buf[ 15 ] : DOT);
        //
        // If the buffer contains less characters than the maximum record size,
        // then delete the characters that were converted but are not to be
        // displayed
        //
        if (cb < RECORD_SIZE) {
                while ( line[ cb ] != NUL ) {
                        line[ cb ] = SPACE;
                        cb++;
                }
        }
}






void
Translate (
        FORMAT                  fmt,
        unsigned char   buf[ ],
        unsigned long   cb,
        char                    line[ ]
        )

/*++

Routine Description:

        This function converts the bytes received in a buffer
        into a printable representation, that corresponds to one
        of the formats specified by the parameter fmt.


Arguments:

        fmt - The format to be used in the conversion

        buf - A buffer that contains the data to be converted.

        cb - Number of bytes in the buffer

        line - Buffer that will receive the converted characters.


Return Value:

        None

--*/


{
        assert( buf );
        assert( line );

        switch( fmt ) {

                case ASCII_CHAR:
                        ConvertASCII( line, buf, cb, asciiChar );
                        break;

                case ASCII_C:
                        ConvertASCII( line, buf, cb, asciiC );
                        break;

                case ASCII_CODE:
                        ConvertASCII( line, buf, cb, asciiCode );
                        break;

                case ASCII_CTRL:
                        ConvertASCII( line, buf, cb, asciiCtrl );
                        break;

                case BYTE_DEC:
                        ConvertBYTE( line, buf, cb, DEC );
                        break;

                case BYTE_HEX:
                        ConvertBYTE( line, buf, cb, HEX );
                        break;

                case WORD_DEC:
                        ConvertWORD( line, buf, cb, DEC );
                        break;

                case WORD_HEX:
                        ConvertWORD( line, buf, cb, HEX );
                        break;

                case DWORD_DEC:
                        ConvertDWORD( line, buf, cb, DEC );
                        break;

                case DWORD_HEX:
                        ConvertDWORD( line, buf, cb, HEX );
                        break;

                case PRINT_CHAR:
                        ConvertPRINT( line, buf, cb );
                        break;


                default:
                        printf( "Bad Format\n" );
                        assert( FALSE );
                        break;
        }
}





void
PutAddress (
        char                    line[],
        unsigned long   ulAddress,
        BASE                    Base
        )

/*++

Routine Description:

        This routine adds to the buffer received the offset of the first
        byte (or character) already in the buffer. This offset represents
        the position of the byte in the file, relatively to the begining
        of the file.


Arguments:

        Base - The base to be used to represent the offset.

        line - Buffer containing the converted characters to be displayed in
                   the screen

        ulAddress - Offset to be added to the begining of the buffer


Return Value:

    None

--*/

{
        unsigned long   ulIndex;

        assert( line);

        switch( Base ) {

                case DEC:
                        ulIndex = sprintf( line,
                                                           MSG_ADDR_DEC_FMT,
                                                           ulAddress );
                        break;

                case HEX:
                        ulIndex = sprintf( line,
                                                           MSG_ADDR_HEX_FMT,
                                                           ulAddress);
                        break;

                default:
                        printf( "Bad Address Base\n" );
                        assert( FALSE );
                        break;
        }
        line[ ulIndex ] = SPACE;   // Get rid of the NUL added by sprintf
}






void
PutTable (
        char                    line[],
        unsigned char   buf[],
        unsigned long   cb
        )

/*++

Routine Description:

        This routine adds to the end of the buffer received, the ASCII
        representation of all printable characters already in the buffer.
        Characters that are not printable (smaller than 0x20 or greater than
        0x7f) are displayed as a dot.


Arguments:

        line - Buffer containing the characters to be displayed in one line
                   of the screen

        buf - The buffer that contains a record of bytes (maximum of 16)
                  read from the file being displayed.

    ulAddress - Number of bytes in buf.


Return Value:

    None

--*/

    {

        unsigned long   ulIndex;

        assert( line );
        assert( buf );

        ulIndex = strlen (line);
        Translate( PRINT_CHAR, buf, cb, (line + ulIndex));
}




void
InterpretArgument (
        char*   pchPointer
        )

/*++

Routine Description:

    This routine interprets an argument typed by the user (exept -n
    and -s) and initializes some variables accordingly.


Arguments:

    pchPointer - Pointer to the argument to be interpreted.


Return Value:

    None

--*/

        {
        //
        // pchPointer will point to the character that follows '-'
        //
        pchPointer++;
        if( strcmp( pchPointer, "ax" ) == 0 ) {
                AddrFormat = HEX;
        }
        else if( strcmp( pchPointer, "ad" ) == 0 ) {
                AddrFormat = DEC;
        }
        else if( strcmp( pchPointer, "ch" ) == 0 ) {
                DispFormat = ASCII_CHAR;
                cStringSize = strlen( asciiChar[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "cC" ) == 0 ) {
                DispFormat = ASCII_C;
                cStringSize = strlen( asciiC[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "ce" ) == 0 ) {
                DispFormat = ASCII_CODE;
                cStringSize = strlen( asciiCode[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "cr" ) == 0 ) {
                DispFormat = ASCII_CTRL;
                cStringSize = strlen( asciiCtrl[0] );
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "bd" ) == 0 ) {
                DispFormat = BYTE_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "bx" ) == 0 ) {
                DispFormat = BYTE_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "wd" ) == 0 ) {
                DispFormat = WORD_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "wx" ) == 0 ) {
                DispFormat = WORD_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "ld" ) == 0 ) {
                DispFormat = DWORD_DEC;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "lx" ) == 0 ) {
                DispFormat = DWORD_HEX;
                DumpAscii = ( DumpAscii == NOT_DEFINED ) ? NO : DumpAscii;
        }
        else if( strcmp( pchPointer, "A" ) == 0 ) {
                DumpAscii = YES;
        }
        else if( strcmp( pchPointer, "i" ) == 0 ) {
                IgnoreRedundantLines = 1;
        }
        else if( strcmp( pchPointer, "?" ) || strcmp( pchPointer, "h" ) ||
                         strcmp( pchPointer, "H" ) ) {
                puts( HELP_MESSAGE );
                exit( 0 );
        }
        else {
                fprintf( stderr, "hd: error: invalid argument '%s'\n", --pchPointer );
                exit( - 1 );
        }
}





unsigned long
GetRecord (
        unsigned char*  puchRecord,
        FILE*                   pf
        )

/*++

Routine Description:

        This routine fills the buffer whose pointer was received as parameter,
        with characters read from the file being displayed. Blocks of data
        are initially read from the file being displayed, and kept in a buffer.
        A record is filled with characters obtained from this buffer.
        Whenever this buffer gets empty, a new access to file is performed
        in order to fill this buffer.


Arguments:

        puchRecord - Pointer to the record to be filled
        pf - Pointer to the file that is being displayed


Return Value:

        Total number of characters put in the record.

--*/

{
unsigned long   cbBytesCopied;

   //
   // If the buffer contains enogh characters to fill the record, then
   // copy the appropriate number of bytes.
   //
        if( cbBytesInBuffer >= RECORD_SIZE ) {
                for( cbBytesCopied = 0; cbBytesCopied < RECORD_SIZE; cbBytesCopied++ ) {
                        *puchRecord++ = *puchPointer++;
                        cbBytesInBuffer--;
                }
        }

        //
        // else, the buffer does not contain enough characters to fill the record
        //
        else {
                //
                // Copy to the remaining characters in the buffer to the record
                //
                for( cbBytesCopied = 0; cbBytesInBuffer > 0; cbBytesInBuffer-- ) {
                        *puchRecord++ = *puchPointer++;
                        cbBytesCopied++;
                }
                //
                // Read more data from the file and fill the record
                //
                if( !feof( pf ) ) {
                        cbBytesInBuffer = fread( auchBuffer,
                                                                         sizeof( char ),
                                                                         BUFFER_SIZE,
                                                                         pf );
                        puchPointer = auchBuffer;
                        while( ( cbBytesInBuffer != 0 ) && (cbBytesCopied < RECORD_SIZE) ) {
                                *puchRecord++ = *puchPointer++;
                                cbBytesInBuffer--;
                                cbBytesCopied++;
                        }
                }
        }
        return( cbBytesCopied );
}







int
hd(
        FILE *  pf
        )
/*++ hd
*
* Routine Description:
*       takes the file/stream pointed to by pf and `hd's it to stdout.
*
* Arguments:
*               FILE *  pf      -
*
* Return Value:
*               int - to be determined, always zero for now
* Warnings:
--*/
{
        unsigned char   buf[ RECORD_SIZE ];
        char                    line[ LINE_SIZE ];
        char            Previousline[ LINE_SIZE ];
        int             printedstar;

        unsigned long   CurrentAddress;
        unsigned long   cNumberOfBlocks;
        unsigned                cLastBlockSize;
        unsigned long   cb;

        //
        //      Determine number of records to be displayed, and size of
        //      last record
        //

        CurrentAddress = Offset;
        cNumberOfBlocks = Count / RECORD_SIZE;
        cLastBlockSize = Count % RECORD_SIZE;
        if( cLastBlockSize ) {
                cNumberOfBlocks++;
        }
        else {
                cLastBlockSize = RECORD_SIZE;
        }

        //
        //      Initialize global variables related to auchBuffer
        //

        cbBytesInBuffer = 0;
        puchPointer = auchBuffer;

        //
        //      Position the file in the correct place, and display
        //      its contents according to the arguments specified by the
        //      user
        //

        if ( pf != stdin ) {
                if (fseek( pf, Offset, SEEK_SET ) == -1) return 0;
        }
        //...maybe enable skipping Offset number of bytes for stdin...

        printedstar = 0;

        while( ( (cb = GetRecord( buf, pf )) != 0) && cNumberOfBlocks ) {
                cNumberOfBlocks--;
                if ( cNumberOfBlocks == 0 ) {
                        cb = ( cb < cLastBlockSize ) ? cb : cLastBlockSize;
                }
                Translate( DispFormat, buf, cb, line );

                if (IgnoreRedundantLines && (strcmp( Previousline, line ) == 0)) {

                    if (!printedstar) { printf("*\n"); }
                    printedstar = 1;

                } else {

                    printedstar = 0;

                    strcpy( Previousline, line );

                    PutAddress( line, CurrentAddress, AddrFormat );
                    if ( (DumpAscii == YES) || (DumpAscii == NOT_DEFINED) )
                            {
                            PutTable ( line, buf, cb );
                    }
                    puts( line );
                }

                CurrentAddress += RECORD_SIZE;
        }
        return 0;
}
/* end of "int hd()" */




void
__cdecl main(
        int             argc,
        char*   argv[ ]
        )

/*++

Routine Description:

        This routine interprets all arguments entered by the user, and
        displays the files specified in the appropriate format.
        The contents of each file is displayed interpreted as a set of
        record containing 16 bytes each.


Arguments:

    argc - number of arguments in the command line
    argv[] - array of pointers to the arguments entered by the user


Return Value:

    None

--*/


{
        FILE*                   pf;
//.     unsigned char   buf[ RECORD_SIZE ];
//.     char                    line[ LINE_SIZE ];
        int                             ArgIndex;
        int                             status;

//.     unsigned long   CurrentAddress;
//.     unsigned long   cNumberOfBlocks;
//.     unsigned                cLastBlockSize;
//.     unsigned long   cb;
        unsigned long   Value;
        unsigned char*  pPtrString;

//.     printf( "\n\n" );                               //.gratuitous newlines removed
                                                                        // Initialization of global variables
        Offset = 0;
        Count = (unsigned long)-1;                      // Maximum file size
        AddrFormat = HEX;
        DispFormat = BYTE_HEX;
        DumpAscii = NOT_DEFINED;
        IgnoreRedundantLines = 0;

        ArgIndex = 1;
        while ( (ArgIndex < argc) && (( *argv[ ArgIndex ] == '-' )) ) {

                //
                // Determine the type of argument
                //

                if( (*(argv[ ArgIndex ] + 1) == 's') ||
                        (*(argv[ ArgIndex ] + 1) == 'n') ) {

                                //
                                // If argument is -s or -n, interprets the number that
                                // follows the argument
                                //

                                if ( (ArgIndex + 1) >= argc ) {
                                        fprintf(stderr,
                                                "hd: error: missing count/offset value after -%c\n",
                                                *(argv[ ArgIndex ] + 1) );
                                        exit (-1);
                                }
                                Value = strtoul( argv[ ArgIndex + 1 ], &pPtrString, 0 );
                                if( *pPtrString != 0 ) {
                                        fprintf(stderr,
                                                "hd: error: invalid count/offset value after -%c\n",
                                                *(argv[ ArgIndex ] + 1) );
                                        exit( -1 );
                                }
                                if( *(argv[ ArgIndex ] + 1) == 's' ) {
                                        Offset = Value;
                                }
                                else {
                                        Count = Value;
                                }
                                ArgIndex += 2;
                }
                else {

                        //
                        // Interprets argument other than -s or -n
                        //

                        InterpretArgument ( argv[ ArgIndex ] );
                        ArgIndex++;
                }
        }

        if ( ArgIndex >= argc ) {
//.             printf ( "Error: file name is missing \n" );
                status = hd( stdin );
                exit( 0 );
        }


        //
        //      For each file, do
        //

        while ( ArgIndex < argc ) {

                //
                //      Open file
                //

                if ( !( pf = fopen( argv[ ArgIndex ], "rb" ) ) ) {
                        fprintf(stderr, "hd: error: invalid file name '%s'\n",
                                argv[ ArgIndex ] );
                        ArgIndex++;
                        continue;                               //. don't abort if it's only a bad filename
//.                     exit( -1 );
                }

                //
                //      Print file name
                //

//.             printf( "\n\n" );
                printf( "%s: \n", argv[ ArgIndex ] );
                ArgIndex++;

                status = hd( pf );

//.             //
//.             //      Determine number of records to be displayed, and size of
//.             //      last record
//.             //
//.
//.             CurrentAddress = Offset;
//.             cNumberOfBlocks = Count / RECORD_SIZE;
//.             cLastBlockSize = Count % RECORD_SIZE;
//.             if( cLastBlockSize ) {
//.                     cNumberOfBlocks++;
//.             }
//.             else {
//.                     cLastBlockSize = RECORD_SIZE;
//.             }
//.
//.             //
//.             //      Initialize global variables related to auchBuffer
//.             //
//.
//.             cbBytesInBuffer = 0;
//.             puchPointer = auchBuffer;
//.
//.             //
//.             //      Position the file in the correct place, and display
//.             //      its contents according to the arguments specified by the
//.             //      user
//.             //
//.
//.             fseek( pf, Offset, SEEK_SET );
//.             while( ( (cb = GetRecord( buf, pf )) != 0) && cNumberOfBlocks ) {
//.                     cNumberOfBlocks--;
//.                     if ( cNumberOfBlocks == 0 ) {
//.                             cb = ( cb < cLastBlockSize ) ? cb : cLastBlockSize;
//.                     }
//.                     Translate( DispFormat, buf, cb, line );
//.                     PutAddress( line, CurrentAddress, AddrFormat );
//.                     if ( (DumpAscii == YES) || (DumpAscii == NOT_DEFINED) )
//.                             {
//.                             PutTable ( line, buf, cb );
//.                     }
//.                     puts( line );
//.
//.                     CurrentAddress += RECORD_SIZE;
//.             }
        }
}
/* end of "void main()" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\he\hexedit.h ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1990		**/ 
/*****************************************************************/ 

/****	hexedit.h
 *
 *  Structure and flags def's to call HexEdit
 *
 */


struct HexEditParm {
    ULONG       flag;           // edit flags
    UCHAR       *ename;         // edit name    (title)
    ULONGLONG   totlen;         // totlen (in bytes) being edited
    ULONGLONG   start;          // starting address of edit
    NTSTATUS    (*read)();      // (opt) fnc to read data
    NTSTATUS    (*write)();     // (opt) fnc to write changes
    HANDLE      handle;         // (opt) passed to read/write functions
    ULONG       ioalign;        // (opt) alignment when read/write (~editmem)
    UCHAR       *mem;           // (opt) Only if FHE_EDITMEM
    HANDLE      Kick;           // (opt) event to kick  (editmem only)
    HANDLE      Console;        // (opt) callers console handle
    ULONG       MaxLine;        // (opt) if non-zero, # of lines HexEdit is to use
    WORD        AttrNorm;       // (opt) Default attribute for text
    WORD        AttrHigh;       // (opt) Default attribute for highlighted text
    WORD        AttrReverse;    // (opt) Default attribute for reversed text
    WORD        CursorSize;     // (opt) Default size of cursor
    ULONGLONG   editloc;        // Position exited/kicked at
    ULONG       TopLine;        // (opt) Relative topline, requires MaxLine
} ;


#define FHE_VERIFYONCE  0x0001      // Prompt before updating (just once)
#define FHE_VERIFYALL   0x0002      // Prompt before any change is written
#define FHE_PROMPTSEC   0x0004      // Verify prompt is for sectors
#define FHE_SAVESCRN    0x0008      // Save & Restore orig screen

#define FHE_EDITMEM	0x0010	    // Direct mem edit
#define FHE_KICKDIRTY   0x0020      // Kick event if memory gets editted
#define FHE_KICKMOVE    0x0040      // Kick event every time cursor is moved
#define FHE_DIRTY       0x0080      // Set when data is dirtied
//efine FHE_F6          0x0100      // Exit when F6 pressed
#define FHE_ENTER       0x0800      // Exit when enter pressed

#define FHE_DWORD       0x0200      // Default to dword edit
#define FHE_JUMP        0x0400      // Support jump option

void   HexEdit (struct HexEditParm *);



/*
 * Read & Write functions are called as follows:
 * (note: read & write can be NULL if fhe_editmem is set.
 *  if editmem is set & read&write are not NULL, then it is assumed
 *  that mem points to the memory image of what read&write are to
 *  read & write.  (this is usefull for in-memory editing of items
 *  which also are to be read&write))
 *
 *  rc = read (handle, offset, buf, len, &physloc)
 *
 *      rc      - returned, zero sucess.  non-zero error code.
 *	handle	- handle as passed into HexEdit
 *	offset	- byte offset to read/write
 *	buf	- address to read/write data
 *	len	- len to read/write    (probabily a sector, but may be less)
 *	physloc - address to put physcal sector number if known
 *
 *
 *
 *  rc = write (handle, offset, buf, len, physloc)
 *
 *	same as read params, expect 'physloc' is a long passed in and is
 *	whatever was returned to read.
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\he\hexedit.c ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1988-1990          **/
/*****************************************************************/

/****   hexedit.c  - Generic sector based hex editor function call
 *
 *  Fill out a HexEditParm structure, and call HexEdit.  It provides
 *  a simple hex editor with a few misc features.
 *
 *  Is single threaded & non-reentrant, but can be called from any thread.
 *
 *  External uses:
 *      he          - allows editing of a file
 *
 *  Written: Ken Reneris    2/25/91
 *
 */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include "hexedit.h"
#include <stdarg.h>

#define LOCAL   static
// #define LOCAL

#define BUFSZ       (HeGbl.BufferSize)
#define SECTORMASK  (HeGbl.SectorMask)
#define SECTORSHIFT  (HeGbl.SectorShift)


static UCHAR rghexc[] = "0123456789ABCDEF";

struct Buffer {
    struct  Buffer    *next;
    ULONGLONG   offset;
    ULONGLONG   physloc;
    USHORT      flag;
    USHORT      len;
    UCHAR       *data;
    UCHAR       orig[0];
} ;
#define FB_DIRTY    0x0001              // Buffer may be dirty
#define FB_BAD      0x0002              // Buffer had an error when read in

#define LINESZ      16                  // 16 bytes per display line
#define LINESHIFT   4L
#define LINEMASK    0xFFFFFFFFFFFFFFF0
#define CELLPERLINE 88

struct Global {
    struct      HexEditParm  *Parm;
    HANDLE      Console;                // Internal console handle
    HANDLE      StdIn;
    NTSTATUS    (*Read)();              // Copy of HeGbl.Parm->read
    ULONG       Flag;                   // Copy of HeGbl.Parm->flag
    ULONGLONG   TotLen;                 // Sizeof item being editted
    ULONGLONG   TotLen1;                // Sizeof item being editted - 1
    USHORT      Lines;                  // # of lines in edit screen
    USHORT      LineTot;                // # of lines totaly in use
    USHORT      PageSz;                 // sizeof page in bytes
    USHORT      TopLine;                // TopLine edit starts at
    ULONGLONG   CurOffset;              // Relative offset of first line
    ULONGLONG   CurEditLoc;             // Location with cursor
    UCHAR       *CurPT;                 // Pointer to data where cursor is
    UCHAR       CurAscIndent;
    UCHAR       DWidth;                 // width of dispalymode
    UCHAR       na;
    struct      Buffer *CurBuf;         // Buffer which cursor is in
    ULONG       CurFlag;                // Cursor info
    ULONG       DisplayMode;            // Mask of displaymode
    ULONG       ItemWrap;               // Mask of displaymode wrap
    UCHAR       rgCols[LINESZ];         // Location within lines
    ULONGLONG   UpdatePos;              // Location waitin to be updated
    struct  Buffer  *Buf;               // List of buffer's read in
    PCHAR_INFO  pVioBuf;                // Virtual screen
    COORD       dwVioBufSize;           // Dimensions of HeGbl.pVioBuf
    COORD       CursorPos;              // Position of cursor
    WORD        AttrNorm;               // Attribute of plain text
    WORD        AttrHigh;               // Attribute of highlighted text
    WORD        AttrReverse;            // Attribute of reverse text
    WORD        na3;
    COORD       dwSize;                 // Original screen size
    ULONG       OrigMode;               // Original screen mode
    CONSOLE_CURSOR_INFO CursorInfo;     // Original cursor info
    PUCHAR      SearchPattern;
    USHORT      BufferSize;
    ULONGLONG   SectorMask;
    ULONG       SectorShift;
} HeGbl;

#define D_BYTE  0                       // DisplayMode
#define D_WORD  1
#define D_DWORD 3

#define FC_NIBBLE       0x0001          // Cursor on lower or upper nibble?
#define FC_TEXT         0x0002          // Cursor on Hex or Text
#define FC_INFLUSHBUF   0x1000          // So we don't recurse
#define FC_CURCENTER    0x2000          // if jumping to cursor, put in center

#define PUTCHAR(a,b,c)  { a->Char.AsciiChar=b; a->Attributes=c; a++; }


//
// Internal prototypes
//

int heUpdateStats(), hePositionCursor(), heRefresh(), heSetDisp();
int heInitConsole(), heUpdateAllLines(), heInitScr(), heSetCursorBuf(), heUpdateFncs();
VOID __cdecl heDisp (USHORT, USHORT, PUCHAR, ...);
USHORT heIOErr (UCHAR *str, ULONGLONG loc, ULONGLONG ploc, ULONG errcd);

int heFlushBuf (struct Buffer *pBuf);

VOID heEndConsole(), heGotoPosition(), heJumpToLink();
VOID heUpdateCurLine(), heUndo(), heCopyOut(), heCopyIn(), heSearch();
VOID heBox (USHORT x, USHORT y, USHORT len_x, USHORT len_y);
UCHAR heGetChar (PUCHAR keys);
VOID heFlushAllBufs (USHORT update);
VOID heFindMousePos (COORD);
VOID heShowBuf (ULONG, ULONG);
VOID heSetDisplayMode (ULONG mode);

#define RefreshDisp()    heShowBuf(0, HeGbl.LineTot)
#define SetCurPos(a,b)  { \
    HeGbl.CursorPos.X = b;   \
    HeGbl.CursorPos.Y = a + HeGbl.TopLine;  \
    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos);    \
    }


int  (*vrgUpdateFnc[])() = {
        NULL,                           // 0 - No update
        heUpdateStats,                  // 1 - Update stats
        hePositionCursor,               // 2 - Cursor has new position
        heUpdateAllLines,               // 3 - Update all lines
        heUpdateFncs,                   // 4 -
        hePositionCursor,               // 5 - Calc cursor before AllLines
        heRefresh,                      // 6 - Clear lines
        heSetDisp,                      // 7 - Draws init screen
    // the following functions are only called once during init
        heInitScr,                      // 8 - get's video mode, etc.
        heInitConsole                   // 9 - setup console handle
} ;

#define U_NONE      0
#define U_NEWPOS    2
#define U_SCREEN    5
#define U_REDRAW    9


#define TOPLINE     4
#define LINEINDENT  1
#define FILEINDEXWIDTH 16
#define HEXINDENT   (FILEINDEXWIDTH + 2 + LINEINDENT)
#define ASCINDENT_BYTE   (3*16 + HEXINDENT + 1)
#define ASCINDENT_WORD   (5*8  + HEXINDENT + 1)
#define ASCINDENT_DWORD  (9*4  + HEXINDENT + 1)

#define POS(l,c)    (HeGbl.pVioBuf+CELLPERLINE*(l)+c)

USHORT  vrgAscIndent[] = {
        ASCINDENT_BYTE, ASCINDENT_WORD, 0, ASCINDENT_DWORD
 };

UCHAR   vrgDWidth[] = { 2, 4, 0, 8 };

LOCAL struct  Buffer  *vBufFree;              // List of free buffers
LOCAL USHORT  vUpdate;
LOCAL USHORT  vRecurseLevel = 0;
LOCAL BOOL    vInSearch = FALSE;


/*
 *  Prototypes
 */

struct Buffer *heGetBuf (ULONGLONG);
void   heSetUpdate (USHORT);
void   heHexLine   (struct Buffer *, USHORT, USHORT);
void   heHexDWord  (PCHAR_INFO, ULONG, WORD);
void   heHexQWord  (PCHAR_INFO, ULONGLONG, WORD);
USHORT heLtoa      (PCHAR_INFO, ULONG);
ULONG  heHtou      (UCHAR *);
ULONGLONG  heHtoLu      (UCHAR *);
VOID   heCalcCursorPosition ();
VOID   heGetString (PUCHAR s, USHORT len);
VOID   heRightOne  ();
VOID   heLeftOne   ();
NTSTATUS heWriteFile (HANDLE h, PUCHAR buffer, ULONG len);
NTSTATUS heReadFile (HANDLE h, PUCHAR buffer, ULONG len, PULONG br);
NTSTATUS heOpenFile (PUCHAR Name, PHANDLE handle, ULONG access);


ULONG
HighBit (
    ULONG Word
    )

/*++

Routine Description:

    This routine discovers the highest set bit of the input word.  It is
    equivalent to the integer logarithim base 2.

Arguments:

    Word - word to check

Return Value:

    Bit offset of highest set bit. If no bit is set, return is zero.

--*/

{
    ULONG Offset = 31;
    ULONG Mask = (ULONG)(1 << 31);

    if (Word == 0) {

        return 0;
    }

    while ((Word & Mask) == 0) {

        Offset--;
        Mask >>= 1;
    }

    return Offset;
}



/***
 *
 *  HexEdit - Full screen HexEdit of data
 *
 *      ename   - pointer to name of what's being edited
 *      totlen  - length of item being edited
 *      pRead   - function which can read data from item
 *      pWrite  - function which can write data to item
 *      handle  - handle to pass to pRead & pWrite
 *      flag    -
 *
 *
 *  All IO is assumed to be done on in 512 bytes on 512 byte boundrys
 *
 *      pRead (handle, offset, data, &physloc)
 *      pWrite (handle, offset, data, &physloc)
 *
 */

void HexEdit (pParm)
struct HexEditParm *pParm;
{
    USHORT  rc;
    INPUT_RECORD    Kd;
    USHORT  SkipCnt;
    DWORD   cEvents;
    USHORT  RepeatCnt;
    BOOL    bSuccess;
    struct  Global  *PriorGlobal;

    // code is not multi-threaded capable, but it can resurse.
    vRecurseLevel++;
    if (vRecurseLevel > 1) {
        PriorGlobal = (struct Global *) GlobalAlloc (0, sizeof (HeGbl));
        if (!PriorGlobal) {
            return;
        }
        memcpy ((PUCHAR) PriorGlobal, (PUCHAR) &HeGbl, sizeof (HeGbl));
    }

    memset (&HeGbl, 0, sizeof (HeGbl));

    if (pParm->ioalign != 1)  {

        // operating on a device
        HeGbl.BufferSize = (USHORT)pParm->ioalign;
        HeGbl.SectorMask = ~(((ULONGLONG)pParm->ioalign) - 1);
        HeGbl.SectorShift = HighBit( pParm->ioalign);
    }
    else {

        // operating on a file,  so just use 1k byte units
        HeGbl.BufferSize = 0x400;
        HeGbl.SectorMask = 0xfffffffffffffc00;
        HeGbl.SectorShift = 9;
    }
    
    pParm->ioalign = 0;
    HeGbl.Parm    = pParm;
    HeGbl.Flag    = pParm->flag;
    HeGbl.TotLen  = pParm->totlen;
    HeGbl.Read    = pParm->read;
    HeGbl.TotLen1 = HeGbl.TotLen ? HeGbl.TotLen - 1L : 0L;
    pParm->flag = 0;

    HeGbl.CurEditLoc = pParm->start;                    // Cursor starts here
    HeGbl.CurOffset    = HeGbl.CurEditLoc & LINEMASK;   // Start at valid offset
    HeGbl.CurFlag      = FC_NIBBLE;
    HeGbl.Console      = INVALID_HANDLE_VALUE;
    heSetDisplayMode ((HeGbl.Flag & FHE_DWORD) ? D_DWORD : D_BYTE);

    HeGbl.AttrNorm = pParm->AttrNorm ? pParm->AttrNorm :  3;
    HeGbl.AttrHigh = pParm->AttrHigh ? pParm->AttrHigh : 15;
    HeGbl.AttrReverse = pParm->AttrReverse ? pParm->AttrReverse : 112;

    HeGbl.SearchPattern = GlobalAlloc (0, BUFSZ);
    if (!HeGbl.SearchPattern) {
        memcpy((PUCHAR) &HeGbl, (PUCHAR) PriorGlobal, sizeof(HeGbl));
        GlobalFree(PriorGlobal);
        return;
    }
    memset (HeGbl.SearchPattern, 0, BUFSZ);

    RepeatCnt = 0;
    vUpdate   = U_REDRAW;
    heSetUpdate (U_NONE);         // get screen to redraw

    for (; ;) {
        if (RepeatCnt <= 1) {
            if (vUpdate != U_NONE) {            // Something to update?

                if (SkipCnt++ > 10) {
                    SkipCnt = 0;
                    heSetUpdate (U_NONE);
                    continue;
                }

                cEvents = 0;
                bSuccess = PeekConsoleInput( HeGbl.StdIn,
                                  &Kd,
                                  1,
                                  &cEvents );

                if (!bSuccess || cEvents == 0) {
                    heSetUpdate ((USHORT)(vUpdate-1));
                    continue;
                }
            } else {
                SkipCnt = 0;
            }

            ReadConsoleInput (HeGbl.StdIn, &Kd, 1, &cEvents);

            if (Kd.EventType != KEY_EVENT) {

                if (Kd.EventType == MOUSE_EVENT  &&
                    (Kd.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED)) {
                        heFindMousePos(Kd.Event.MouseEvent.dwMousePosition);
                    }

                continue;                           // Not a key
            }


            if (!Kd.Event.KeyEvent.bKeyDown)
                continue;                           // Not a down stroke

            if (Kd.Event.KeyEvent.wVirtualKeyCode == 0    ||    // ALT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x10 ||    // SHIFT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x11 ||    // CONTROL
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x14)      // CAPITAL
                    continue;

            RepeatCnt = Kd.Event.KeyEvent.wRepeatCount;
            if (RepeatCnt > 20)
                RepeatCnt = 20;
        } else
            RepeatCnt--;

        switch (Kd.Event.KeyEvent.wVirtualKeyCode) {
            case 0x21:                                    /* PgUp */
                if (HeGbl.CurOffset < HeGbl.PageSz)
                     HeGbl.CurOffset  = 0L;
                else HeGbl.CurOffset -= HeGbl.PageSz;

                if (HeGbl.CurEditLoc < HeGbl.PageSz)
                     HeGbl.CurEditLoc  = 0L;
                else HeGbl.CurEditLoc -= HeGbl.PageSz;

                heSetUpdate (U_SCREEN);
                continue;

            case 0x26:                                    /* Up   */
                if (HeGbl.CurEditLoc >= LINESZ) {
                    HeGbl.CurEditLoc -= LINESZ;
                    heSetUpdate (U_NEWPOS);
                }
                continue;

            case 0x22:                                    /* PgDn */
                if (HeGbl.TotLen > HeGbl.PageSz) {
                    if (HeGbl.CurOffset+HeGbl.PageSz+HeGbl.PageSz > HeGbl.TotLen1)
                         HeGbl.CurOffset = ((HeGbl.TotLen1-HeGbl.PageSz) & LINEMASK)+LINESZ;
                    else HeGbl.CurOffset += HeGbl.PageSz;

                    if (HeGbl.CurEditLoc+HeGbl.PageSz > HeGbl.TotLen1) {
                        HeGbl.CurEditLoc = HeGbl.TotLen1;
                        HeGbl.CurFlag &= ~FC_NIBBLE;
                    } else
                        HeGbl.CurEditLoc += HeGbl.PageSz;

                    heSetUpdate (U_SCREEN);
                }
                continue;


            case 0x28:                                  /* Down */
                if (HeGbl.CurEditLoc+LINESZ <= HeGbl.TotLen1) {
                    HeGbl.CurEditLoc += LINESZ;
                    heSetUpdate (U_NEWPOS);
                }
                continue;

            case 0x08:                                  /* backspace */
            case 0x25:                                  /* Left */
                if (HeGbl.CurFlag & FC_TEXT) {
                    if (HeGbl.CurEditLoc == 0L)
                        continue;

                    HeGbl.CurEditLoc--;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                if (!(HeGbl.CurFlag & FC_NIBBLE)) {
                    HeGbl.CurFlag |= FC_NIBBLE;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                HeGbl.CurFlag &= ~FC_NIBBLE;
                heLeftOne ();
                heSetUpdate (U_NEWPOS);
                continue;


            case 0x27:                                    /* Right */
                if (HeGbl.CurFlag & FC_TEXT) {
                    if (HeGbl.CurEditLoc >= HeGbl.TotLen1)
                        continue;

                    HeGbl.CurEditLoc++;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                if (HeGbl.CurFlag & FC_NIBBLE) {
                    HeGbl.CurFlag &= ~FC_NIBBLE;
                    heSetUpdate (U_NEWPOS);
                    continue;
                }

                HeGbl.CurFlag |= FC_NIBBLE;
                heRightOne ();
                heSetUpdate (U_NEWPOS);
                continue;

            case 0x24:                                    /* HOME */
                if (Kd.Event.KeyEvent.dwControlKeyState &
                    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    HeGbl.CurEditLoc = 0L;
                } else {
                    HeGbl.CurEditLoc &= LINEMASK;
                }

                if ((HeGbl.CurFlag & FC_TEXT) == 0)
                    HeGbl.CurEditLoc += HeGbl.DisplayMode;

                if (HeGbl.CurEditLoc > HeGbl.TotLen1)
                    HeGbl.CurEditLoc = HeGbl.TotLen1;

                HeGbl.CurFlag    |= FC_NIBBLE;
                heSetUpdate (U_NEWPOS);
                continue;


            case 0x23:                                    /* END  */
                if (Kd.Event.KeyEvent.dwControlKeyState &
                    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    HeGbl.CurEditLoc = HeGbl.TotLen1;
                } else {
                    HeGbl.CurEditLoc = (HeGbl.CurEditLoc & LINEMASK) + LINESZ - 1;
                }

                HeGbl.CurFlag   &= ~FC_NIBBLE;
                if ((HeGbl.CurFlag & FC_TEXT) == 0)
                    HeGbl.CurEditLoc -= HeGbl.DisplayMode;

                if (HeGbl.CurEditLoc > HeGbl.TotLen1)
                    HeGbl.CurEditLoc = HeGbl.TotLen1;

                heSetUpdate (U_NEWPOS);
                continue;

            case 0x70:                                  /* F1       */
                switch (HeGbl.DisplayMode) {
                    case D_BYTE:    heSetDisplayMode(D_WORD);   break;
                    case D_WORD:    heSetDisplayMode(D_DWORD);  break;
                    case D_DWORD:   heSetDisplayMode(D_BYTE);   break;
                }
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x71:                                  /* F2       */
                heGotoPosition ();
                continue;

            case 0x72:                                  /* F3       */
                heSearch ();
                break;

            case 0x73:                                  /* F4       */
                heCopyOut ();
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x74:                                  /* F5       */
                heCopyIn ();
                heSetDisp ();
                heSetUpdate (U_SCREEN);
                continue;

            case 0x75:                                  /* F6       */
                heJumpToLink ();
                break;

            case 0x79:                                  /* F10      */
                heUndo ();
                continue;

            case 0x0d:
                if (HeGbl.Flag & FHE_ENTER) {
                    HeGbl.Parm->flag |= FHE_ENTER;
                    Kd.Event.KeyEvent.uChar.AsciiChar = 27;  // fake an exit
                }
                break;

            //case 0x75:                                    /* F6       */
            //    if (HeGbl.Flag & FHE_F6) {
            //        HeGbl.Parm->flag |= FHE_F6;
            //        Kd.Event.KeyEvent.uChar.AsciiChar = 27;  // fake an exit
            //    }
            //    break;

        }

        // Now check for a known char code...

        if (Kd.Event.KeyEvent.uChar.AsciiChar == 27)
            break;

        if (Kd.Event.KeyEvent.uChar.AsciiChar == 9) {
            HeGbl.CurFlag ^= FC_TEXT;
            HeGbl.CurFlag |= FC_NIBBLE;
            heSetUpdate (U_NEWPOS);
            continue;
        }

        if (HeGbl.CurFlag & FC_TEXT) {
            if (Kd.Event.KeyEvent.uChar.AsciiChar == 0)
                continue;

            heSetCursorBuf ();

            *HeGbl.CurPT = Kd.Event.KeyEvent.uChar.AsciiChar;
            heUpdateCurLine ();

            if (HeGbl.CurEditLoc < HeGbl.TotLen1)
                HeGbl.CurEditLoc++;
        } else {
            if (Kd.Event.KeyEvent.uChar.AsciiChar >= 'a'  &&
                Kd.Event.KeyEvent.uChar.AsciiChar <= 'z')
                Kd.Event.KeyEvent.uChar.AsciiChar -= ('a' - 'A');

            if (!((Kd.Event.KeyEvent.uChar.AsciiChar >= '0'  &&
                   Kd.Event.KeyEvent.uChar.AsciiChar <= '9') ||
                  (Kd.Event.KeyEvent.uChar.AsciiChar >= 'A'  &&
                   Kd.Event.KeyEvent.uChar.AsciiChar <= 'F')))
                    continue;

            heSetCursorBuf ();

            if (Kd.Event.KeyEvent.uChar.AsciiChar >= 'A')
                 Kd.Event.KeyEvent.uChar.AsciiChar -= 'A' - 10;
            else Kd.Event.KeyEvent.uChar.AsciiChar -= '0';


            if (HeGbl.CurFlag & FC_NIBBLE) {
                *HeGbl.CurPT = (*HeGbl.CurPT & 0x0F) |
                                (Kd.Event.KeyEvent.uChar.AsciiChar << 4);
                heUpdateCurLine ();
            } else {
                *HeGbl.CurPT = (*HeGbl.CurPT & 0xF0) |
                                Kd.Event.KeyEvent.uChar.AsciiChar;
                heUpdateCurLine ();
                heRightOne ();
            }

            HeGbl.CurFlag ^= FC_NIBBLE;
        }
    }

    /*
     *  Free buffer memory
     */

    for (; ;) {
        rc = 0;
        while (HeGbl.Buf) {
            rc |= heFlushBuf (HeGbl.Buf);

            HeGbl.CurBuf = HeGbl.Buf->next;
            GlobalFree (HeGbl.Buf);
            HeGbl.Buf = HeGbl.CurBuf;
        }

        if (!rc)                        // If something was flushed,
            break;                      // then update the screen

        heSetUpdate (U_SCREEN);
        heSetUpdate (U_NONE);
    }                                   // and loop to free buffers (again)

    vRecurseLevel--;
    GlobalFree (HeGbl.SearchPattern);
    heEndConsole ();

    if (vRecurseLevel == 0) {
        while (vBufFree) {
            HeGbl.CurBuf = vBufFree->next;
            GlobalFree (vBufFree);
            vBufFree = HeGbl.CurBuf;
        }
    } else {
        memcpy ((PUCHAR) &HeGbl, (PUCHAR) PriorGlobal, sizeof (HeGbl));
        GlobalFree (PriorGlobal);
    }
}

VOID heSetDisplayMode (ULONG mode)
{
    PUCHAR  p;
    UCHAR   d,i,j,h,len;

    HeGbl.DisplayMode  = mode;
    HeGbl.CurAscIndent = (UCHAR)vrgAscIndent[HeGbl.DisplayMode];
    HeGbl.DWidth       = vrgDWidth[HeGbl.DisplayMode];
    HeGbl.ItemWrap     = (HeGbl.DisplayMode << 1) | 1;

    i = HeGbl.DWidth;
    j = i >> 1;
    h = HEXINDENT;
    len = LINESZ;

    p = HeGbl.rgCols;
    while (len) {
        for (d=0; d < i; d += 2) {
            len--;
            *(p++) = i - (d+2) + h;
        }
        h += i + 1;
    }
}

VOID heRightOne ()
{
    if (HeGbl.CurEditLoc & HeGbl.DisplayMode) {
        HeGbl.CurEditLoc--;
    } else {
        HeGbl.CurEditLoc += HeGbl.ItemWrap;
    }

    if (HeGbl.CurEditLoc > HeGbl.TotLen1) {
        HeGbl.CurEditLoc = HeGbl.TotLen1 & ~(ULONGLONG)HeGbl.DisplayMode;
    }
}


VOID heLeftOne ()
{
    if ((HeGbl.CurEditLoc & HeGbl.DisplayMode) != HeGbl.DisplayMode) {
        if (HeGbl.CurEditLoc < HeGbl.TotLen1) {
            HeGbl.CurEditLoc++;
            return ;
        }
        if (HeGbl.TotLen1 > HeGbl.DisplayMode) {
            HeGbl.CurEditLoc |= HeGbl.DisplayMode;
        }
    }

    if (HeGbl.CurEditLoc > HeGbl.ItemWrap) {
        HeGbl.CurEditLoc -= HeGbl.ItemWrap;
        return ;
    }

    HeGbl.CurEditLoc =
        HeGbl.TotLen1 > HeGbl.DisplayMode ? HeGbl.DisplayMode : HeGbl.TotLen1;
}




VOID heUpdateCurLine ()
{
    USHORT  line;


    for (; ;) {
        HeGbl.CurBuf->flag |= FB_DIRTY;
        line = (USHORT) ((HeGbl.CurEditLoc - HeGbl.CurOffset) >> LINESHIFT);
        if (line+TOPLINE < HeGbl.LineTot - 1)
            break;

        heSetUpdate (U_NEWPOS);
        heSetUpdate (U_NONE);
        HeGbl.CurBuf = heGetBuf (HeGbl.CurEditLoc);
    }

    if (HeGbl.CurBuf) {
        heHexLine (HeGbl.CurBuf, (USHORT)((HeGbl.CurEditLoc & LINEMASK) - HeGbl.CurBuf->offset), line);
        heShowBuf (line+TOPLINE, 1);
        heSetUpdate (U_NEWPOS);
        if (HeGbl.Flag & FHE_KICKDIRTY) {
            HeGbl.Parm->flag |= FHE_DIRTY;
            SetEvent (HeGbl.Parm->Kick);
        }
    }
}


void heFindMousePos (Pos)
COORD Pos;
{
    ULONGLONG   HoldLocation;
    USHORT      HoldFlag;
    USHORT      i;

    if (Pos.Y < TOPLINE  ||  Pos.Y >= TOPLINE+HeGbl.Lines)
        return ;


    heSetUpdate (U_NONE);
    HoldLocation = HeGbl.CurEditLoc;
    HoldFlag     = (USHORT)HeGbl.CurFlag;

    //
    // Take the cheap way out - simply run all the possibilities for the
    // target line looking for a match
    //

    HeGbl.CurEditLoc = HeGbl.CurOffset + ((Pos.Y-TOPLINE) << LINESHIFT);
    for (i=0; i < LINESZ; i++, HeGbl.CurEditLoc++) {
        HeGbl.CurFlag &= ~(FC_NIBBLE | FC_TEXT);
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;

        HeGbl.CurFlag |= FC_NIBBLE;
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;

        HeGbl.CurFlag |= FC_TEXT;
        heCalcCursorPosition ();
        if (Pos.X == HeGbl.CursorPos.X)
            break;
    }

    if (Pos.X == HeGbl.CursorPos.X) {
        heSetUpdate (U_NEWPOS);
    } else {
        HeGbl.CurEditLoc = HoldLocation;
        HeGbl.CurFlag    = HoldFlag;
        heCalcCursorPosition ();
    }
}



VOID heSetUpdate (USHORT i)
{
    USHORT  u;

    if (vUpdate) {
        /*
         * There's already some outstanding update going on
         * Get updat level down to current one.
         */

        while (vUpdate > i) {
            vrgUpdateFnc [u=vUpdate] ();
            if (u == vUpdate)               // If vUpdate changed, then
                vUpdate--;                  // we might have recursed
        }
    }

    vUpdate = i;
}

int heSetCursorBuf ()
{
    //  Calc HeGbl.CurBuf, HeGbl.CurPT

    if (HeGbl.CurBuf) {
        if (HeGbl.CurEditLoc >= HeGbl.CurBuf->offset  &&
            HeGbl.CurEditLoc < HeGbl.CurBuf->offset+BUFSZ ) {
                HeGbl.CurPT = HeGbl.CurBuf->data + (HeGbl.CurEditLoc - HeGbl.CurBuf->offset);
                return 0;
            }
    }

    HeGbl.CurBuf = heGetBuf (HeGbl.CurEditLoc);
    if (HeGbl.CurBuf)
        HeGbl.CurPT  = HeGbl.CurBuf->data + (HeGbl.CurEditLoc - HeGbl.CurBuf->offset);
    return 0;
}


int hePositionCursor ()
{
    heCalcCursorPosition ();
    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos);

    if ((HeGbl.Flag & FHE_KICKMOVE)  &&  (HeGbl.CurEditLoc != HeGbl.Parm->editloc)) {
    
        HeGbl.Parm->editloc = HeGbl.CurEditLoc;
        SetEvent (HeGbl.Parm->Kick);
    }

    return 0;
}


VOID heCalcCursorPosition ()
{
    USHORT  lin, col;


    //  Verify HeGbl.CurOffset
    if (HeGbl.CurEditLoc < HeGbl.CurOffset) {
        HeGbl.CurOffset = HeGbl.CurEditLoc & LINEMASK;
        if (HeGbl.CurFlag & FC_CURCENTER) {
            if (HeGbl.CurOffset > (ULONG) HeGbl.PageSz / 2) {
                HeGbl.CurOffset -= (HeGbl.PageSz / 2) & LINEMASK;
            } else {
                HeGbl.CurOffset = 0;
            }
        }
        heSetUpdate (U_SCREEN);
    }

    if (HeGbl.CurEditLoc >= HeGbl.CurOffset+HeGbl.PageSz) {
        HeGbl.CurOffset = ((HeGbl.CurEditLoc - HeGbl.PageSz) & LINEMASK) + LINESZ;
        if (HeGbl.CurFlag & FC_CURCENTER) {
            if (HeGbl.CurOffset+HeGbl.PageSz < HeGbl.TotLen) {
                HeGbl.CurOffset += (HeGbl.PageSz / 2) & LINEMASK;
            } else {
                if (HeGbl.TotLen > HeGbl.PageSz) {
                    HeGbl.CurOffset = ((HeGbl.TotLen - HeGbl.PageSz) & LINEMASK) + LINESZ;
                }
            }
        }
        heSetUpdate (U_SCREEN);
    }

    lin = (USHORT) ((ULONG) HeGbl.CurEditLoc - HeGbl.CurOffset) >> LINESHIFT;

    if (HeGbl.CurFlag & FC_TEXT) {
        col  = (USHORT) (HeGbl.CurEditLoc & ~LINEMASK) + HeGbl.CurAscIndent+1;
    } else {
        col = HeGbl.rgCols [HeGbl.CurEditLoc & ~LINEMASK] +
              (HeGbl.CurFlag & FC_NIBBLE ? 0 : 1);
    }

    HeGbl.CursorPos.Y = lin + TOPLINE + HeGbl.TopLine;
    HeGbl.CursorPos.X = col;
}



heUpdateAllLines ()
{
    struct  Buffer  *next, *pBuf;
    USHORT  line, u;
    ULONGLONG   loc;


    HeGbl.CurBuf = pBuf = NULL;

    /*
     *  Free up any buffers which are before the HeGbl.CurOffset
     */

    if (!(HeGbl.CurFlag & FC_INFLUSHBUF)) {
        while (HeGbl.Buf) {
            if (HeGbl.Buf->offset+BUFSZ >= HeGbl.CurOffset)
                break;

            heFlushBuf (HeGbl.Buf);

            /*
             *  Unlink buffer & put it on the free list
             */
            next = HeGbl.Buf->next;

            HeGbl.Buf->next = vBufFree;
            vBufFree   = HeGbl.Buf;

            HeGbl.Buf = next;
        }
    }

    /*
     *  Display each hex line now
     */

    loc = HeGbl.CurOffset;                       // starting offset
    for (line=0; line<HeGbl.Lines; line++) {     // for each line

        if (pBuf == NULL) {                     // do we have the buffer?
            pBuf = heGetBuf (loc);              // no, go get it
            if (pBuf)
                u = (USHORT) (loc - pBuf->offset);  // calc offset into this buffer
        }

        if (pBuf) {
            heHexLine (pBuf, u, line);          // dump this line
    
            loc += LINESZ;                      // move offsets foreward one line
            u   += LINESZ;
    
            if (u >= BUFSZ) {                   // did we exceed the current buf?
                pBuf = pBuf->next;              // yes, move to next one
                u = 0;
    
                if (pBuf && loc < pBuf->offset) // verify buffer is right offs
                    pBuf = NULL;                // no, let heGetBuf find it
            }
        }
    }

    // Cause screen to be refreshed
    heShowBuf (TOPLINE, HeGbl.Lines);

    /*
     *  All lines have been displayed, free up any extra buffers
     *  at the end of the chain
     */

    if (pBuf  &&  !(HeGbl.CurFlag & FC_INFLUSHBUF)) {
        next = pBuf->next;              // get extra buffers
        pBuf->next = NULL;              // terminate active list

        pBuf = next;
        while (pBuf) {
            heFlushBuf (pBuf);          // flush this buffer

            next = pBuf->next;          // move it to the free list
                                        // and get next buffer to flush
            pBuf->next = vBufFree;
            vBufFree   = pBuf;

            pBuf = next;
        }

    }

    HeGbl.CurFlag &= ~FC_CURCENTER;
    return 0;
}




int heFlushBuf (pBuf)
struct Buffer *pBuf;
{
    ULONGLONG   loc, ploc;
    USHORT  c;
    NTSTATUS status;

    if ((pBuf->flag & FB_DIRTY) == 0  ||
        memcmp (pBuf->data, pBuf->orig, pBuf->len) == 0)
            return (0);             // buffer isn't dirty, return

    // We may need to call heSetUpdate - setting this bit will
    // stop FlushBuf from being recursed.

    HeGbl.CurFlag |= FC_INFLUSHBUF;

    loc  = pBuf->offset;
    ploc = pBuf->physloc;
    if (HeGbl.Flag & (FHE_VERIFYONCE | FHE_VERIFYALL)) {
        heSetUpdate (U_NONE);             // make sure screen current

        heBox (12, TOPLINE+1, 63, 8);
        heDisp (TOPLINE+3, 14, "%HWrite changes to %S?", HeGbl.Parm->ename);
        heDisp (TOPLINE+7, 14, "Press '%HY%N'es or '%HN%N'o");

        if (HeGbl.Flag & FHE_VERIFYALL) {
            if (HeGbl.Flag & FHE_PROMPTSEC) {
                heDisp (TOPLINE+4, 14, "Sector %H%D%N has been modifed",(ULONG)(ploc/BUFSZ));
            } else {
                heDisp (TOPLINE+4, 14, "Location %H%Q%Nh-%H%Q%Nh has been modifed",ploc,ploc+BUFSZ);
            }
            heDisp (TOPLINE+8, 14, "Press '%HA%N' to save all updates");
        }
        RefreshDisp ();

        c = heGetChar ("YNA");          // wait for key stroke
        heSetDisp ();                   // Get heBox off of screen
        heSetUpdate (U_SCREEN);         // we will need to update display

        if (c == 'N') {
            memcpy (pBuf->data, pBuf->orig, pBuf->len);
            HeGbl.CurFlag &= ~FC_INFLUSHBUF;

            if (HeGbl.Flag & FHE_KICKDIRTY) {
                HeGbl.Parm->flag |= FHE_DIRTY;
                 SetEvent (HeGbl.Parm->Kick);
            }
            return (0);
        }

        if (c == 'A')
            HeGbl.Flag &= ~FHE_VERIFYALL;
    }


    if (HeGbl.Parm->write) {
        /*
         *  Write new buffer.
         */
        do {
            status = HeGbl.Parm->write(HeGbl.Parm->handle, loc, pBuf->data,pBuf->len);
            if (!status) {
                pBuf->flag &= ~FB_DIRTY;
                break;
            }
        } while (heIOErr ("WRITE ERROR!", loc, ploc, status) == 'R');
    }

    HeGbl.Flag    &= ~FHE_VERIFYONCE;
    HeGbl.CurFlag &= ~FC_INFLUSHBUF;
    return (1);
}


VOID heJumpToLink ()
{
    PULONG  p;
    ULONG   l;

    if (HeGbl.DisplayMode != D_DWORD  ||  (HeGbl.Flag & FHE_JUMP) == 0)
        return;

    if (((HeGbl.CurEditLoc & ~3) + 3) > HeGbl.TotLen1)
        return;

    heSetCursorBuf ();
    p = (PULONG) (((ULONG_PTR) HeGbl.CurPT) & ~3);   // Round to dword location

    l = *p;
    if ((l & 3) == 0)
        l += 3;

    if (l > HeGbl.TotLen1) {
        Beep (500, 100);
        return;
    }

    HeGbl.CurFlag |= FC_NIBBLE | FC_CURCENTER;
    HeGbl.CurEditLoc = l;

    heSetDisp ();           // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);   // redraw hex area
}

VOID heSearch ()
{
    struct  Buffer  *pBuf;
    ULONGLONG j, sec, off, slen, len, upd;
    ULONG i;
    ULONGLONG iQ;
    struct  HexEditParm     ei;
    PUCHAR  data, data2;

    if (vInSearch || HeGbl.Lines < 25) {
        return ;
    }

    vInSearch = TRUE;

    heFlushAllBufs (1);               // Before we start flush & free all buffers
    heSetUpdate (U_NONE);

    memset ((PUCHAR) &ei, 0, sizeof (ei));
    ei.ename       = "Entering Search";
    ei.flag        = FHE_EDITMEM | FHE_ENTER;
    ei.mem         = HeGbl.SearchPattern;
    ei.totlen      = BUFSZ;
    ei.ioalign     = 1;
    ei.Console     = HeGbl.Console;
    ei.AttrNorm    = HeGbl.AttrNorm;
    ei.AttrHigh    = HeGbl.AttrHigh;
    ei.AttrReverse = HeGbl.AttrReverse;
    ei.CursorSize  = HeGbl.Parm->CursorSize;

    i = 24;
    if (HeGbl.Lines < i) {
        if (HeGbl.Lines < 12) {
            goto abort;
        }
        i = HeGbl.Lines - 8;
    }

    ei.TopLine     = HeGbl.Lines + TOPLINE - i;
    ei.MaxLine     = i + 1;
    if (HeGbl.DisplayMode == D_DWORD) {
        ei.flag |= FHE_DWORD;
    }

    HexEdit (&ei);              // Get search parameters
    vInSearch = FALSE;

    if (!(ei.flag & FHE_ENTER))
        goto abort;

    for (i=0, slen=0; i < BUFSZ; i++) {       // find last non-zero byte
        if (HeGbl.SearchPattern[i]) {       // in search patter
            slen = i+1;
        }
    }

    if (slen == 0) {
        goto abort;
    }

    heBox (12, TOPLINE+1, 48, 6);
    heDisp (TOPLINE+3, 14, "Searching for pattern");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    iQ   = HeGbl.CurEditLoc + 1;
    sec = iQ & SECTORMASK;                   // current sector
    off = iQ - sec;                          // offset within sector checking
    upd = 0;

    while (sec < HeGbl.TotLen) {
        if (++upd >= 50) {
            upd = 0;
            heFlushAllBufs (0);             // free memory
            heDisp (TOPLINE+6, 14, "Searching offset %H%Qh ", sec);
            heShowBuf (TOPLINE+6, 1);
        }

        pBuf = heGetBuf(sec);
        if (pBuf) {
            data = pBuf->data;

nextoff:
            while (off < BUFSZ  &&  data[off] != HeGbl.SearchPattern[0]) {
                off++;
            }

            if (off >= BUFSZ) {
                // next sector...
                sec += BUFSZ;
                off  = 0;
                continue;
            }

            len = (off + slen) > BUFSZ ? BUFSZ - off : slen;
            for (i=0; i < len; i++) {
                if (data[off+i] != HeGbl.SearchPattern[i]) {
                    off += 1;
                    goto nextoff;
                }
            }

            if (i < slen) {
                // data is continued in next buffer..
                if (sec+BUFSZ >= HeGbl.TotLen) {
                    off += 1;
                    goto nextoff;
                }

                data2 = heGetBuf (sec+BUFSZ)->data;
                if (data2) {
                    j     = (BUFSZ-off);
                    len   = slen - j;
                    for (i=0; i < len; i++) {
                        if (data2[i] != HeGbl.SearchPattern[j+i]) {
                            off += 1;
                            goto nextoff;
                        }
                    }
                }
            }

            // found match
            if (sec + off + slen > HeGbl.TotLen1) {
                break;
            }
        } else {
            sec+=off;
        }

        HeGbl.CurEditLoc = sec + off;
        heSetDisp   ();             // clear & restore orig screen (does not draw)
        heSetUpdate (U_SCREEN);     // redraw hex area
        return ;
    }


    heBox (12, TOPLINE+1, 48, 6);
    heDisp (TOPLINE+3, 14, "Data was not found");
    heDisp (TOPLINE+5, 17, "Press %HEnter%N to continue");
    SetCurPos (TOPLINE+6, 17);
    RefreshDisp ();
    heGetChar ("\r");

abort:
    heSetDisp   ();             // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);     // redraw hex area
    return ;
}


VOID heGotoPosition ()
{
    UCHAR       s[24];
    ULONGLONG   l;

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 49, 6);

    heDisp (TOPLINE+3, 14, "Enter offset from %H%X%N - %H%Q", 0L, HeGbl.TotLen1);
    heDisp (TOPLINE+5, 14, "Offset:           ");
    SetCurPos (TOPLINE+5, 22);
    RefreshDisp ();

    heGetString (s, 18);

    if (s[0]) {
        l = heHtoLu (s);
        if (l <= HeGbl.TotLen1) {
            HeGbl.CurFlag |= FC_NIBBLE;
            HeGbl.CurEditLoc = l;
        }
    }

    if (!(HeGbl.CurFlag & FC_TEXT)  &&  !(HeGbl.CurEditLoc & HeGbl.DisplayMode)) {
        // On xword boundry and not in text mode, adjust so cursor
        // is on the first byte which is being displayed of this
        // xword

        HeGbl.CurEditLoc += HeGbl.DisplayMode;
        if (HeGbl.CurEditLoc > HeGbl.TotLen1)
            HeGbl.CurEditLoc = HeGbl.TotLen1;
    }



    HeGbl.CurFlag |= FC_CURCENTER;      // set cursor to center in window moves
    heSetDisp ();             // clear & restore orig screen (does not draw)
    heSetUpdate (U_SCREEN);   // redraw hex area
}


VOID heGetString (PUCHAR s, USHORT len)
{
    UCHAR   i[50];
    DWORD   cb;

    if (!ReadFile( HeGbl.StdIn, i, 50, &cb, NULL ))
        return;

    if(cb >= 2  &&  (i[cb - 2] == 0x0d || i[cb - 2] == 0x0a) ) {
        i[cb - 2] = 0;     // Get rid of CR LF
    }
    i[ cb - 1] = 0;

    memcpy (s, i, len);
    s[len] = 0;
}



/***
 *  heCopyOut - Copies data to output filename
 */
VOID heCopyOut ()
{
    UCHAR       s[64];
    ULONGLONG   len, rem, upd;
    ULONG       u;
    HANDLE      h;
    NTSTATUS    status;
    struct Buffer *pB;

    heFlushAllBufs (1);               // Before we start flush & free all buffers
    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 48, 6);

    heDisp (TOPLINE+3, 14, "Copy stream to filename (%H%D%Q Bytes)", HeGbl.TotLen);
    heDisp (TOPLINE+5, 14, "Filename:                      ");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    heGetString (s, 59);
    if (s[0] == 0)
        return;

    status = heOpenFile (s, &h, GENERIC_WRITE);
    if (NT_SUCCESS(status)) {
        len = upd = 0;
        rem = HeGbl.TotLen;
        while (NT_SUCCESS(status) && rem){
            if (upd++ > 50) {
                upd = 0;
                heFlushAllBufs (0);         // free memory
                heDisp (TOPLINE+6, 14, "Bytes written %H%Q ", len);
                heShowBuf (TOPLINE+6, 1);
                RefreshDisp ();
            }

            u      = rem > BUFSZ ? BUFSZ : (ULONG)rem;
            pB     = heGetBuf (len);
            if (pB) {
                status = heWriteFile (h, pB->data, u);
                rem   -= u;
                len   += BUFSZ;
            }
        }
        CloseHandle(h);
    }

    if (!NT_SUCCESS(status)) {
        heBox (15, TOPLINE+1, 33, 6);
        heDisp (TOPLINE+3, 17, "%HCopy failed");
        heDisp (TOPLINE+4, 17, "Error code %X", status);
        heDisp (TOPLINE+5, 17, "Press %HA%N to abort");
        RefreshDisp ();
        heGetChar ("A");
    }
}



/***
 *  heCopyIn - Copies data to output filename
 */

VOID
heCopyIn ()
{
    UCHAR       s[64];
    ULONGLONG   holdEditLoc, rem;
    ULONG       u, br;
    struct      Buffer *pB;
    char        *pErr;
    HANDLE      h;
    NTSTATUS    status;

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 48, 6);

    heDisp (TOPLINE+3, 14, "Input from filename (%H%D%Q Bytes)", HeGbl.TotLen);
    heDisp (TOPLINE+5, 14, "Filename:                      ");
    SetCurPos (TOPLINE+5, 24);
    RefreshDisp ();

    heGetString (s, 59);
    heSetDisp ();                   // Get heBox off of screen
    if (s[0] == 0) {
        return;
    }

    status = heOpenFile (s, &h, GENERIC_READ);
    if (NT_SUCCESS(status)) {
        rem = HeGbl.TotLen;
        holdEditLoc = HeGbl.CurEditLoc;
        HeGbl.CurEditLoc = 0;
        while (NT_SUCCESS(status) && rem) {
            pB     = heGetBuf (HeGbl.CurEditLoc);
            if (pB) {
                u      = rem >  BUFSZ ? BUFSZ : (ULONG)rem;
                status = heReadFile (h, pB->data, u, &br);
    
                if (memcmp (pB->data, pB->orig, pB->len)) {
                    pB->flag |= FB_DIRTY;         // it's changed
                    HeGbl.CurFlag |= FC_CURCENTER;
                    heSetUpdate (U_SCREEN);
                    heSetUpdate (U_NONE);         // Update screen
                    if (HeGbl.Flag & FHE_KICKDIRTY) {
                        HeGbl.Parm->flag |= FHE_DIRTY;
                    }
                }
                heFlushAllBufs (1);
                if (NT_SUCCESS(status)  &&  br != u) {
                    pErr = "Smaller then data";
                }
    
                rem -= u;
                HeGbl.CurEditLoc += BUFSZ;
            }
        }

        if (NT_SUCCESS(status)) {
            heReadFile (h, s, 1, &br);
            if (br)                     // then what we are editting
                pErr = "Larger then data";
        }

        CloseHandle(h);
    }

    if (!NT_SUCCESS(status)  ||  pErr) {
        heBox (15, TOPLINE+1, 33, 6);
        if (pErr) {
            heDisp (TOPLINE+3, 17, "Import file is:");
            heDisp (TOPLINE+4, 17, pErr);
            heDisp (TOPLINE+5, 17, "Press %HC%N to continue");
        } else {
            heDisp (TOPLINE+3, 17, "%HImport failed");
            heDisp (TOPLINE+4, 17, "Error code %X", status);
            heDisp (TOPLINE+5, 17, "Press %HA%N to abort");
        }
        RefreshDisp ();
        heGetChar ("CA");
    }

    HeGbl.CurEditLoc = holdEditLoc;
}


VOID
heFlushAllBufs (USHORT update)
{
    struct  Buffer  *next;
    USHORT  rc;

    for (; ;) {
        rc = 0;
        while (HeGbl.Buf) {
            rc |= heFlushBuf (HeGbl.Buf);

            next = HeGbl.Buf->next;
            HeGbl.Buf->next = vBufFree;
            vBufFree   = HeGbl.Buf;
            HeGbl.Buf = next;
        }

        if (!rc)                        // If something was flushed,
            break;                      // then update the screen

        if (update) {
            heSetUpdate (U_SCREEN);
            heSetUpdate (U_NONE);
        }
    }                                   // and loop to free buffers (again)
}




VOID heBox (x, y, len_x, len_y)
USHORT x, y, len_x, len_y;
{
    CHAR_INFO   blank[CELLPERLINE];
    PCHAR_INFO  pt, pt1;
    USHORT      c, lc;

    pt = blank;
    for (c=len_x; c; c--) {                     /* Construct blank line */
        PUTCHAR (pt, ' ', HeGbl.AttrNorm);           /* with background color*/

    }
    blank[0].Char.AsciiChar = blank[lc=len_x-1].Char.AsciiChar = '';

    for (c=0; c <= len_y; c++)                  /* blank each line      */
      memcpy (POS(c+y,x), blank, (int)((pt - blank) * sizeof (CHAR_INFO)));

    pt  = POS(y,x);
    pt1 = POS(y+len_y, x);
    for (c=0; c < len_x; c++)                   /* Draw horz lines      */
        pt[c].Char.AsciiChar = pt1[c].Char.AsciiChar  = '';

    pt  [ 0].Char.AsciiChar  = '';             /* Put corners on       */
    pt  [lc].Char.AsciiChar  = '';
    pt1 [ 0].Char.AsciiChar  = '';
    pt1 [lc].Char.AsciiChar  = '';
}



VOID heUndo ()
{
    struct  Buffer  *pBuf;
    USHORT  flag;

    flag = 0;
    for (pBuf=HeGbl.Buf; pBuf; pBuf = pBuf->next)
        if (pBuf->flag & FB_DIRTY) {
            flag = 1;
            pBuf->flag &= ~FB_DIRTY;
            memcpy (pBuf->data, pBuf->orig, pBuf->len);
        }

    if (flag) {
        heSetUpdate (U_SCREEN);
        if (HeGbl.Flag & FHE_KICKDIRTY) {
            HeGbl.Parm->flag |= FHE_DIRTY;
            SetEvent (HeGbl.Parm->Kick);
        }
    }
}



void heHexLine (pBuf, u, line)
struct Buffer *pBuf;
USHORT u, line;
{
    PCHAR_INFO pt, hex, asc;
    UCHAR  *data, *orig;
    UCHAR  len, mlen, c, d, i, j;
    WORD   a;
    ULONGLONG  l;
    WORD   AttrNorm = HeGbl.AttrNorm;

    data = pBuf->data + u;
    orig = pBuf->orig + u;

    pt  = HeGbl.pVioBuf + (line+TOPLINE) * CELLPERLINE;
    hex = pt + HEXINDENT;
    asc = pt + HeGbl.CurAscIndent;

    //
    //  Write the file index.  Highlight words falling on buffer (sector) 
    //  boundries in white.
    //
    
    l = pBuf->offset + u;
    if (l & ((ULONGLONG) BUFSZ-1)) {
        heHexQWord (pt+LINEINDENT, pBuf->physloc + u, AttrNorm);
    } else {
        heHexQWord (pt+LINEINDENT, pBuf->physloc + u, HeGbl.AttrHigh);
    }

    if (pBuf->flag & FB_BAD) {                          // If read error on
        pt[LINEINDENT+FILEINDEXWIDTH].Char.AsciiChar = 'E';          // this sector, then
        pt[LINEINDENT+FILEINDEXWIDTH].Attributes = HeGbl.AttrHigh;   // flag it
    } else
        pt[LINEINDENT+FILEINDEXWIDTH].Char.AsciiChar = ' ';

    if (l + LINESZ > HeGbl.TotLen) {                    // if EOF
        if (l >= HeGbl.TotLen) {                        // Totally blankline?
            PUTCHAR (asc, ' ', AttrNorm);
            PUTCHAR (asc, ' ', AttrNorm);
            mlen = 0;

            for (len=0; len < 9; len++)
                pt[len].Char.AsciiChar = ' ';

            goto blankline;
        }
        len = mlen = (UCHAR) (HeGbl.TotLen - l);        // Clip line
    } else
        len = mlen = (UCHAR) LINESZ;                    // Full line


    PUTCHAR (asc, '*', AttrNorm);

    switch (HeGbl.DisplayMode) {
        case D_BYTE:
            while (len--) {
                c = *(data++);
                a = c == *(orig++) ? AttrNorm : HeGbl.AttrReverse;
                PUTCHAR (hex, rghexc [c >> 4],   a);
                PUTCHAR (hex, rghexc [c & 0x0F], a);
                hex++;

                PUTCHAR (asc, (c < ' '  ||  c > '~') ? '.' : c, a);
            }
            pt[((LINESZ/2)*3+HEXINDENT)-1].Char.AsciiChar = '-';
            break;

        default:
            hex--;
            i = HeGbl.DWidth;
            j = i >> 1;
            while (len) {
                hex += i;
                for (d=0; d<j; d++) {
                    if (len) {
                        len--;
                        c = *(data++);
                        a = c == *(orig++) ? AttrNorm : HeGbl.AttrReverse;

                        hex->Attributes     = a;
                        hex->Char.AsciiChar = rghexc[c & 0x0F];
                        hex--;
                        hex->Attributes     = a;
                        hex->Char.AsciiChar = rghexc[c >> 4];
                        hex--;

                        PUTCHAR (asc, (c < ' '  ||  c > '~') ? '.' : c, a);
                    } else {
                        hex->Attributes     = AttrNorm;
                        hex->Char.AsciiChar = '?';
                        hex--;
                        hex->Attributes     = AttrNorm;
                        hex->Char.AsciiChar = '?';
                        hex--;
                    }
                }
                hex += i + 1;
            }
            break;
    }

    PUTCHAR (asc, '*', AttrNorm);

blankline:
    while (mlen++ < LINESZ)
        PUTCHAR (asc, ' ', AttrNorm);

    asc = pt + HeGbl.CurAscIndent;
    while (hex < asc)
        PUTCHAR (hex, ' ', AttrNorm);
}


heInitScr ()
{
    CONSOLE_SCREEN_BUFFER_INFO  Mode;
    CONSOLE_CURSOR_INFO CursorInfo;
    USHORT      li;

    GetConsoleScreenBufferInfo(HeGbl.Console, &Mode);
    if (HeGbl.Parm->MaxLine) {
        HeGbl.TopLine = (USHORT)HeGbl.Parm->TopLine;
        li = (USHORT)HeGbl.Parm->MaxLine;  // +1;    adjust for no fnc key line
    } else {
        li = Mode.srWindow.Bottom - Mode.srWindow.Top + 1;
        if (li < 10)
            li = 10;

        Mode.dwSize.Y = li;
    }

    if (Mode.dwSize.X < CELLPERLINE)
        Mode.dwSize.X = CELLPERLINE;

    if (!SetConsoleScreenBufferSize(HeGbl.Console, Mode.dwSize)) {

        Mode.srWindow.Bottom -= Mode.srWindow.Top;
        Mode.srWindow.Right -= Mode.srWindow.Left;
        Mode.srWindow.Top = 0;
        Mode.srWindow.Left = 0;

        SetConsoleWindowInfo(HeGbl.Console, TRUE, &Mode.srWindow);
        SetConsoleScreenBufferSize(HeGbl.Console, Mode.dwSize);
    }

    HeGbl.Lines   = li - TOPLINE - 1;
    HeGbl.PageSz  = HeGbl.Lines * LINESZ;
    HeGbl.LineTot = li;

    if (HeGbl.pVioBuf)
        GlobalFree (HeGbl.pVioBuf);

    HeGbl.pVioBuf = (PCHAR_INFO) GlobalAlloc (0,
                            (HeGbl.LineTot+1)*CELLPERLINE*sizeof(CHAR_INFO));
    if (!HeGbl.pVioBuf) {
        return 1;
    }

    HeGbl.dwVioBufSize.X = CELLPERLINE;
    HeGbl.dwVioBufSize.Y = HeGbl.LineTot + 1;

    GetConsoleCursorInfo (HeGbl.Console, &CursorInfo);
    CursorInfo.bVisible = TRUE;
    CursorInfo.dwSize = (ULONG) HeGbl.Parm->CursorSize ? HeGbl.Parm->CursorSize : 100;
    SetConsoleCursorInfo (HeGbl.Console, &CursorInfo);

    return heSetDisp ();
}

int heInitConsole ()
{
    CONSOLE_SCREEN_BUFFER_INFO  screenMode;
    DWORD   mode = 0;

    HeGbl.StdIn = GetStdHandle (STD_INPUT_HANDLE);
    GetConsoleMode (HeGbl.StdIn, &mode);
    HeGbl.OrigMode = mode;
    SetConsoleMode (HeGbl.StdIn, mode | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT |
                            ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT );


    if (HeGbl.Flag & FHE_SAVESCRN) {
        HeGbl.Console = CreateConsoleScreenBuffer(
                        GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        CONSOLE_TEXTMODE_BUFFER,
                        NULL );

        SetConsoleActiveScreenBuffer (HeGbl.Console);
    } else {
        HeGbl.Console = HeGbl.Parm->Console;
        if (HeGbl.Console == INVALID_HANDLE_VALUE)
            HeGbl.Console = GetStdHandle( STD_OUTPUT_HANDLE );

        GetConsoleScreenBufferInfo(HeGbl.Console, &screenMode);
        HeGbl.dwSize = screenMode.dwSize;
    }

    GetConsoleCursorInfo(HeGbl.Console, &HeGbl.CursorInfo);
    return 0;
}


VOID heEndConsole ()
{
    CONSOLE_SCREEN_BUFFER_INFO  Mode;
    PCHAR_INFO  pt;
    ULONG   u;

    SetConsoleMode (HeGbl.StdIn, HeGbl.OrigMode);

    if (HeGbl.Flag & FHE_SAVESCRN) {
        CloseHandle (HeGbl.Console);

        if (HeGbl.Parm->Console == INVALID_HANDLE_VALUE)
             SetConsoleActiveScreenBuffer (GetStdHandle(STD_OUTPUT_HANDLE));
        else SetConsoleActiveScreenBuffer (HeGbl.Parm->Console);

    } else {
        if (!SetConsoleScreenBufferSize(HeGbl.Console, HeGbl.dwSize)) {

            GetConsoleScreenBufferInfo(HeGbl.Console, &Mode);
            Mode.srWindow.Bottom -= Mode.srWindow.Top;
            Mode.srWindow.Right -= Mode.srWindow.Left;
            Mode.srWindow.Top = 0;
            Mode.srWindow.Left = 0;
            SetConsoleWindowInfo(HeGbl.Console, TRUE, &Mode.srWindow);

            SetConsoleScreenBufferSize(HeGbl.Console, HeGbl.dwSize);
        }

        if (HeGbl.LineTot <= HeGbl.dwSize.Y) {
            HeGbl.dwSize.Y--;
            pt = POS(HeGbl.LineTot - 1,0);
            for (u=HeGbl.dwSize.X; u; u--) {
                PUTCHAR (pt, ' ', HeGbl.AttrNorm);
            }

            heShowBuf (HeGbl.LineTot - 1, 1);
        }

        HeGbl.dwSize.X = 0;
        SetConsoleCursorPosition (HeGbl.Console, HeGbl.dwSize);
        SetConsoleCursorInfo (HeGbl.Console, &HeGbl.CursorInfo);
    }

    if (HeGbl.pVioBuf) {
        GlobalFree (HeGbl.pVioBuf);
        HeGbl.pVioBuf = NULL;
    }
}


heRefresh ()
{
    RefreshDisp ();

    if (HeGbl.Flag & FHE_KICKDIRTY) {
        HeGbl.Parm->flag |= FHE_DIRTY;
        SetEvent (HeGbl.Parm->Kick);
    }
    return 0;
}


int heSetDisp ()
{
    PCHAR_INFO  pt, pt1;
    USHORT      u;

    pt = POS(0,0);
    for (u=HeGbl.LineTot * CELLPERLINE; u; u--) {
        PUTCHAR (pt, ' ', HeGbl.AttrNorm);
    }

    heDisp (1,  5, "Edit: %H%S", HeGbl.Parm->ename);
    heDisp (2,  5, "Size: %Q ", HeGbl.TotLen);
    if (HeGbl.TotLen < 0x100000000)  {
        heDisp (2,  28, "(%D)", (ULONG)HeGbl.TotLen);
    }

    heDisp (1, 40, "Position:");
    for (pt1=POS(1,50), u=0; u<30; u++, pt1++)
        pt1->Attributes = HeGbl.AttrHigh;

    //if (HeGbl.Parm->MaxLine == 0) {
        u = HeGbl.LineTot - 1;
        heDisp (u, 0, "%HF1%N:Toggle");
        heDisp (u,11, "%HF2%N:Goto");

        if (!vInSearch) {
            heDisp (u,20, "%HF3%N:Search");
        }

        heDisp (u,31, "%HF4%N:Export");
        heDisp (u,42, "%HF5%N:Import");

        if (HeGbl.DisplayMode == D_DWORD  &&  (HeGbl.Flag & FHE_JUMP) != 0)
             heDisp (u,53, "%HF6%N:Jump");
        else heDisp (u,53, "       ");

        heDisp (u,66, "%HF10%N:Undo");

        //if (HeGbl.Flag & FHE_F6)
        //    heDisp (u,51, "%HF6%N:PSec");
    //}
    return 0;
}

int heUpdateFncs ()
{
    heShowBuf (HeGbl.LineTot - 1, 1);
    return 0;
}


int heUpdateStats ()
{
    COORD dwBufferCoord;
    SMALL_RECT lpWriteRegion;

    heHexQWord (POS(1, 50), HeGbl.CurEditLoc, HeGbl.AttrHigh);

    if (HeGbl.TotLen < 0x100000000) {
    
        heLtoa( POS(2, 50), (ULONG)HeGbl.CurEditLoc);
    }

    dwBufferCoord.X = 50;
    dwBufferCoord.Y = 1;

    lpWriteRegion.Left   = 50;
    lpWriteRegion.Top    = HeGbl.TopLine + 1;
    lpWriteRegion.Right  = 74;
    lpWriteRegion.Bottom = HeGbl.TopLine + 2;

    WriteConsoleOutputA (
        HeGbl.Console,
        HeGbl.pVioBuf,
        HeGbl.dwVioBufSize, // size of VioBuf
        dwBufferCoord,      // location in VioBuf to write
        &lpWriteRegion      // location to write on display
    );

    SetConsoleCursorPosition (HeGbl.Console, HeGbl.CursorPos); // redisplay cursor
    return 0;
}

VOID heShowBuf (ULONG StartingLine, ULONG NoLines)
{
    COORD dwBufferCoord;
    SMALL_RECT lpWriteRegion;

    dwBufferCoord.X = (SHORT)0;
    dwBufferCoord.Y = (SHORT)StartingLine;

    StartingLine += HeGbl.TopLine;
    lpWriteRegion.Left   = (SHORT)0;
    lpWriteRegion.Top    = (SHORT)StartingLine;
    lpWriteRegion.Right  = (SHORT)(CELLPERLINE-1);
    lpWriteRegion.Bottom = (SHORT)(StartingLine+NoLines-1);

    WriteConsoleOutputA (
        HeGbl.Console,
        HeGbl.pVioBuf,
        HeGbl.dwVioBufSize, // size of VioBuf
        dwBufferCoord,      // location in VioBuf to write
        &lpWriteRegion      // location to write on display
    );
}


struct Buffer *heGetBuf (ULONGLONG loc)
{
    struct  Buffer  **ppBuf, *pBuf;
    USHORT  len;
    NTSTATUS status;

    loc &= SECTORMASK;

    ppBuf = &HeGbl.Buf;
    while (pBuf = *ppBuf) {
        if (pBuf->offset >= loc) {
            if (pBuf->offset == loc)        // buffer the correct offset?
                return pBuf;                // yup - all done

            break;                          // it's not here
        }
        ppBuf = &pBuf->next;                // try the next one
    }


    /*
     *  buffer was not in list - it should be insterted before ppBuf
     */

    if (vBufFree) {
        pBuf = vBufFree;
        vBufFree = vBufFree->next;
    } else {
        pBuf = (struct Buffer *)
                 GlobalAlloc (0, sizeof(struct Buffer)+2*BUFSZ);
        if (!pBuf) {
            return NULL;
        }
    }

    pBuf->data   = (PUCHAR)(((ULONG_PTR)pBuf+sizeof(struct Buffer)+BUFSZ));
    pBuf->offset = loc;
    pBuf->physloc= loc;                     // Assume physloc is logical offset
    pBuf->flag   = 0;

    // Link this buffer in now! In case we recurse (due to read-error)
    pBuf->next = *ppBuf;                    // link in this new buffer
    *ppBuf = pBuf;

    if (loc + BUFSZ > HeGbl.TotLen) {       // are we going to hit the EOF?
         if (loc >= HeGbl.TotLen) {         // is buffer completely passed EOF?
            pBuf->len = 0;
            goto nodata;                    // yes, then no data at all
         }
         len = (USHORT) (HeGbl.TotLen - loc);   // else, clip to EOF
    } else len = BUFSZ;                     // not pass eof, get a full buffer

    pBuf->len = len;

    if (HeGbl.Flag & FHE_EDITMEM)               // Direct memory edit?
        pBuf->data = HeGbl.Parm->mem + loc;     // memory location of buffer

    if (HeGbl.Read) {
        /*
         *  Read buffer from file
         */
        status = HeGbl.Read (HeGbl.Parm->handle, loc, pBuf->data, len);
        if (status) {
            // If read error, we will always retry once.  Also clear buffer
            // before retry in case read retreives some info
            for (; ;) {
                memset (pBuf->data,   0, len);      // Clear read area
                memset (pBuf->orig,0xff, len);      // good effect
                status = HeGbl.Read (HeGbl.Parm->handle, loc, pBuf->data, len);

                if (!status)
                    break;

                if (heIOErr ("READ ERROR!", loc, pBuf->physloc, status) == 'I') {
                    pBuf->flag |= FB_BAD;
                    break;
                }
            }
        }
    }

    memcpy (pBuf->orig, pBuf->data, len);       // make a copy of the data

nodata:
    return pBuf;
}


USHORT heIOErr (UCHAR *str, ULONGLONG loc, ULONGLONG ploc, ULONG errcd)
{
    USHORT      c;

    if (errcd == 0xFFFFFFFF)
        return 'I';

    heSetUpdate (U_NONE);
    heBox (12, TOPLINE+1, 55, 8);

    heDisp (TOPLINE+3, 14, str);
    heDisp (TOPLINE+4, 14, "Error code %H%D%N, Offset %Qh, Sector %D",
        errcd, loc, (ULONG)(ploc / BUFSZ));
    heDisp (TOPLINE+7, 14, "Press '%HR%N' to retry IO, or '%HI%N' to ignore");
    RefreshDisp ();

    c = heGetChar ("RI");

    heSetDisp ();                   // Get heBox off of screen
    heSetUpdate (U_SCREEN);
    return c;
}


UCHAR heGetChar (keys)
PUCHAR keys;
{
    INPUT_RECORD    Kd;
    DWORD           cEvents;
    UCHAR           *pt;

    for (; ;) {
        Beep (500, 100);

        for (; ;) {
            ReadConsoleInput (HeGbl.StdIn, &Kd, 1, &cEvents);

            if (Kd.EventType != KEY_EVENT)
                continue;                           // Not a key

            if (!Kd.Event.KeyEvent.bKeyDown)
                continue;                           // Not a down stroke

            if (Kd.Event.KeyEvent.wVirtualKeyCode == 0    ||    // ALT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x10 ||    // SHIFT
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x11 ||    // CONTROL
                Kd.Event.KeyEvent.wVirtualKeyCode == 0x14)      // CAPITAL
                    continue;

            break;
        }

        if (Kd.Event.KeyEvent.wVirtualKeyCode >= 'a'  &&
            Kd.Event.KeyEvent.wVirtualKeyCode <= 'z')
                Kd.Event.KeyEvent.wVirtualKeyCode -= ('a' - 'A');

        for (pt=keys; *pt; pt++)            // Is this a key we are
            if (Kd.Event.KeyEvent.wVirtualKeyCode == *pt)
                return *pt;                 // looking for?
    }
}


VOID __cdecl
heDisp (USHORT line, USHORT col, PUCHAR pIn, ...)
{
    register char   c;
    PCHAR_INFO pOut;
    WORD    attr;
    USHORT  u;
    UCHAR   *pt;
    va_list args;

    attr = HeGbl.AttrNorm;
    pOut = POS(line,col);

    va_start(args,pIn);
    while (c = *(pIn++)) {
        if (c != '%') {
            PUTCHAR (pOut, c, attr);
            continue;
        }

        switch (*(pIn++)) {
            case 'S':
                pt = va_arg(args, CHAR *);
                while (*pt) {
                    PUTCHAR (pOut, *(pt++), attr);
                }
                break;

            case 'X':               /* Long HEX, fixed len      */
                heHexDWord (pOut, va_arg(args, ULONG), attr);
                pOut += 8;
                break;
                
            case 'Q':               /* LongLong HEX, fixed len      */
                heHexQWord (pOut, va_arg(args, ULONGLONG), attr);
                pOut += 16;
                break;

            case 'D':               /* Long dec, varible len    */
                u = heLtoa (pOut, va_arg(args, ULONG));
                while (u--) {
                    pOut->Attributes = attr;
                    pOut++;
                }
                break;
            case 'H':
                attr = HeGbl.AttrHigh;
                break;
            case 'N':
                attr = HeGbl.AttrNorm;
                break;
        }
    }
}




void heHexDWord (s, l, attr)
PCHAR_INFO  s;
ULONG   l;
WORD    attr;
{
    UCHAR   d, c;
    UCHAR   *pt;

    s += 8-1;
    pt = (UCHAR *) &l;

    for (d=0; d<4; d++) {
        c = *(pt++);
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c & 0x0F];
        s--;
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c >> 4];
        s--;
    }
}


void heHexQWord (s, l, attr)
PCHAR_INFO  s;
ULONGLONG   l;
WORD    attr;
{
    UCHAR   d, c;
    UCHAR   *pt;

    s += 16-1;
    pt = (UCHAR *) &l;

    for (d=0; d<8; d++) {
        c = *(pt++);
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c & 0x0F];
        s--;
        s->Attributes     = attr;
        s->Char.AsciiChar = rghexc[c >> 4];
        s--;
    }
}


USHORT heLtoa (s, l)
PCHAR_INFO s;
ULONG  l;
{
    static ULONG mask[] = { 0L,
                 1L,
                10L,
               100L,
              1000L,
             10000L,
            100000L,
           1000000L,
          10000000L,
         100000000L,
        1000000000L,
    };

    static UCHAR comm[] = "xxxx,xx,xx,xx,xx";
    PCHAR_INFO  os;
    UCHAR      c;
    USHORT     i, j;
    ULONG      m;

    if (l < 1000000000L) {
        for (i=1; mask[i] <= l; i++)  ;

        if  (l == 0L)       // Make Zeros
            i++;
    } else
        i = 11;

    os = s;
    j  = i;
    while (m = mask[--i]) {
        c  = (UCHAR) ((ULONG) l / m);
        l -= m * c;
        s->Char.AsciiChar = c + '0';
        s->Attributes     = HeGbl.AttrNorm;
        if (comm[i] == ',') {
            s++;
            s->Attributes     = HeGbl.AttrNorm;
            s->Char.AsciiChar = ',';
        }
        s++;
    }

    i = (USHORT)(s - os);                       // remember how long the number was

    while (j++ < 11) {                  /* Clear off some blank space after */
        s->Char.AsciiChar = ' ';        /* the number.                      */
        s++;
    }

    return i;
}


ULONG heHtou (s)
UCHAR *s;
{
    UCHAR   c;
    ULONG   l;

    l = 0;
    for (; ;) {
        c = *(s++);

        if (c == 's'  ||  c == 'S') {       // Sector multiplier?
            l = l * (ULONG)BUFSZ;
            break;
        }

        if (c >= 'a')       c -= 'a' - 10;
        else if (c >= 'A')  c -= 'A' - 10;
        else                c -= '0';

        if (c > 15)
            break;

        l = (l<<4) + c;
    }
    return l;
}

ULONGLONG heHtoLu (s)
UCHAR *s;
{
    UCHAR   c;
    ULONGLONG   l;

    l = 0;
    for (; ;) {
        c = *(s++);

        if (c == 's'  ||  c == 'S') {       // Sector multiplier?
            l = l * (ULONG)BUFSZ;
            break;
        }

        if (c >= 'a')       c -= 'a' - 10;
        else if (c >= 'A')  c -= 'A' - 10;
        else                c -= '0';

        if (c > 15)
            break;

        l = (l<<4) + c;
    }
    return l;
}

NTSTATUS
heOpenFile (PUCHAR name, PHANDLE fhan, ULONG access)
{
    *fhan = CreateFile (
            name,
            access,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

    if (*fhan == INVALID_HANDLE_VALUE  &&  (access & GENERIC_WRITE)) {
        *fhan = CreateFile (
                name,
                access,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_NEW,
                0,
                NULL );
    }

    return *fhan == INVALID_HANDLE_VALUE ? GetLastError() : STATUS_SUCCESS;
}

NTSTATUS
heReadFile (HANDLE h, PUCHAR buffer, ULONG len, PULONG br)
{
    if (!ReadFile (h, buffer, len, br, NULL))
        return GetLastError();
    return STATUS_SUCCESS;
}

NTSTATUS
heWriteFile (HANDLE h, PUCHAR buffer, ULONG len)
{
    ULONG   bw;

    if (!WriteFile (h, buffer, len, &bw, NULL))
        return GetLastError();
    return (bw != len ? ERROR_WRITE_FAULT : STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\he\makefile.inc ===
$(O)\he.res: he.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\charmap.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* CHARMAP.C - Character mapping arrays					*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include	"charmap.h"

#define	CHARMAP_SIZE	256

unsigned char	Charmap[CHARMAP_SIZE] = {
LX_EOS,			/* 0x0, <end of string marker> */
LX_ILL,			/* 0x1 */
LX_ILL,			/* 0x2 */
LX_ILL,			/* 0x3 */
LX_ILL,			/* 0x4 */
LX_ILL,			/* 0x5 */
LX_ILL,			/* 0x6 */
LX_ILL,			/* 0x7 */
LX_ILL,			/* 0x8 */
LX_WHITE,		/* <horizontal tab> */
LX_NL,			/* <newline> */
LX_WHITE,		/* <vertical tab> */
LX_WHITE,		/* <form feed> */
LX_CR,			/* <really a carriage return> */
LX_ILL,			/* 0xe */
LX_ILL,			/* 0xf */
LX_ILL,			/* 0x10 */
LX_ILL,			/* 0x11 */
LX_ILL,			/* 0x12 */
LX_ILL,			/* 0x13 */
LX_ILL,			/* 0x14 */
LX_ILL,			/* 0x15 */
LX_ILL,			/* 0x16 */
LX_ILL,			/* 0x17 */
LX_ILL,			/* 0x18 */
LX_ILL,			/* 0x19 */
LX_EOS,			/* 0x1a, ^Z */
LX_ILL,			/* 0x1b */
LX_ILL,			/* 0x1c */
LX_ILL,			/* 0x1d */
LX_ILL,			/* 0x1e */
LX_ILL,			/* 0x1f */
LX_WHITE,		/* 0x20 */
LX_BANG,		/* ! */
LX_DQUOTE,		/* " */
LX_POUND,		/* # */
LX_ASCII,		/* $ */
LX_PERCENT,		/* % */
LX_AND,			/* & */
LX_SQUOTE,		/* ' */
LX_OPAREN,		/* ( */
LX_CPAREN,		/* ) */
LX_STAR,		/* * */
LX_PLUS,		/* + */
LX_COMMA,		/* , */
LX_MINUS,		/* - */
LX_DOT,			/* . */
LX_SLASH,		/* / */
LX_NUMBER,		/* 0 */
LX_NUMBER,		/* 1 */
LX_NUMBER,		/* 2 */
LX_NUMBER,		/* 3 */
LX_NUMBER,		/* 4 */
LX_NUMBER,		/* 5 */
LX_NUMBER,		/* 6 */
LX_NUMBER,		/* 7 */
LX_NUMBER,		/* 8 */
LX_NUMBER,		/* 9 */
LX_COLON,		/* : */
LX_SEMI,		/* ; */
LX_LT,			/* < */
LX_EQ,			/* = */
LX_GT,			/* > */
LX_QUEST,		/* ? */
LX_EACH,		/* @ */
LX_ID,			/* A */
LX_ID,			/* B */
LX_ID,			/* C */
LX_ID,			/* D */
LX_ID,			/* E */
LX_ID,			/* F */
LX_ID,			/* G */
LX_ID,			/* H */
LX_ID,			/* I */
LX_ID,			/* J */
LX_ID,			/* K */
LX_ID,			/* L */
LX_ID,			/* M */
LX_ID,			/* N */
LX_ID,			/* O */
LX_ID,			/* P */
LX_ID,			/* Q */
LX_ID,			/* R */
LX_ID,			/* S */
LX_ID,			/* T */
LX_ID,			/* U */
LX_ID,			/* V */
LX_ID,			/* W */
LX_ID,			/* X */
LX_ID,			/* Y */
LX_ID,			/* Z */
LX_OBRACK,		/* [ */
LX_EOS,			/* \ */
LX_CBRACK,		/* ] */
LX_HAT,			/* ^ */
LX_ID,			/* _ */
LX_ASCII,		/* ` */
LX_ID,			/* a */
LX_ID,			/* b */
LX_ID,			/* c */
LX_ID,			/* d */
LX_ID,			/* e */
LX_ID,			/* f */
LX_ID,			/* g */
LX_ID,			/* h */
LX_ID,			/* i */
LX_ID,			/* j */
LX_ID,			/* k */
LX_ID,			/* l */
LX_ID,			/* m */
LX_ID,			/* n */
LX_ID,			/* o */
LX_ID,			/* p */
LX_ID,			/* q */
LX_ID,			/* r */
LX_ID,			/* s */
LX_ID,			/* t */
LX_ID,			/* u */
LX_ID,			/* v */
LX_ID,			/* w */
LX_ID,			/* x */
LX_ID,			/* y */
LX_ID,			/* z */
LX_OBRACE,		/* { */
LX_OR,			/* | */
LX_CBRACE,		/* } */
LX_TILDE,		/* ~ */
LX_ILL,			/* 0x7f */
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
};

unsigned char	Contmap[CHARMAP_SIZE] = {
LXC_SPECIAL,/* 0x0, <end of string marker> */
0,			/* 0x1 */
0,			/* 0x2 */
0,			/* 0x3 */
0,			/* 0x4 */
0,			/* 0x5 */
0,			/* <end of buffer marker> */
0,			/* 0x7 */
0,			/* 0x8 */
LXC_WHITE,	/* <horizontal tab> */
LXC_SPECIAL,/* <newline>, this is NOT considered whitespace */
LXC_WHITE,	/* <vertical tab> */
LXC_WHITE,	/* <form feed> */
0,			/* <really a carriage return> */
0,			/* 0xe */
0,			/* 0xf */
0,			/* 0x10 */
0,			/* 0x11 */
0,			/* 0x12 */
0,			/* 0x13 */
0,			/* 0x14 */
0,			/* 0x15 */
0,			/* 0x16 */
0,			/* 0x17 */
0,			/* 0x18 */
0,			/* 0x19 */
LXC_SPECIAL,/* 0x1a */
0,			/* 0x1b */
0,			/* 0x1c */
0,			/* 0x1d */
0,			/* 0x1e */
0,			/* 0x1f */
LXC_WHITE,	/* 0x20 */
0,			/* ! */
0,			/* " */
0,			/* # */
0,			/* $ */
0,			/* % */
0,			/* & */
0,			/* ' */
0,			/* ( */
0,			/* ) */
LXC_SPECIAL,/* * */
0,			/* + */
0,			/* , */
0,			/* - */
0,			/* . */
0,			/* / */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,	/* 0 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,	/* 1 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 2 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 3 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 4 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 5 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 6 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,	/* 7 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT,				/* 8 */
LXC_ID | LXC_XDIGIT | LXC_DIGIT,				/* 9 */
0,												/* : */
0,												/* ; */
0,												/* < */
0,												/* = */
0,												/* > */
0,												/* ? */
0,												/* @ */
LXC_ID | LXC_XDIGIT,							/* A */
LXC_ID | LXC_XDIGIT	| LXC_RADIX,				/* B */
LXC_ID | LXC_XDIGIT,							/* C */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* D */
LXC_ID | LXC_XDIGIT,							/* E */
LXC_ID | LXC_XDIGIT,							/* F */
LXC_ID,											/* G */
LXC_ID | LXC_RADIX,								/* H */
LXC_ID,											/* I */
LXC_ID,											/* J */
LXC_ID,											/* K */
LXC_ID,											/* L */
LXC_ID,											/* M */
LXC_ID,											/* N */
LXC_ID | LXC_RADIX,								/* O */
LXC_ID,											/* P */
LXC_ID | LXC_RADIX,								/* Q */
LXC_ID,											/* R */
LXC_ID,											/* S */
LXC_ID,											/* T */
LXC_ID,											/* U */
LXC_ID,											/* V */
LXC_ID,											/* W */
LXC_ID,											/* X */
LXC_ID,											/* Y */
LXC_ID,											/* Z */
0,												/* [ */
0,												/* \ */
0,												/* ] */
0,												/* ^ */
LXC_ID,											/* _ */
0,												/* ` */
LXC_ID | LXC_XDIGIT,							/* a */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* b */
LXC_ID | LXC_XDIGIT,							/* c */
LXC_ID | LXC_XDIGIT | LXC_RADIX,				/* d */
LXC_ID | LXC_XDIGIT,							/* e */
LXC_ID | LXC_XDIGIT,							/* f */
LXC_ID,											/* g */
LXC_ID | LXC_RADIX,								/* h */
LXC_ID,											/* i */
LXC_ID,											/* j */
LXC_ID,											/* k */
LXC_ID,											/* l */
LXC_ID,											/* m */
LXC_ID,											/* n */
LXC_ID | LXC_RADIX,								/* o */
LXC_ID,											/* p */
LXC_ID | LXC_RADIX,								/* q */
LXC_ID,											/* r */
LXC_ID,											/* s */
LXC_ID,											/* t */
LXC_ID,											/* u */
LXC_ID,											/* v */
LXC_ID,											/* w */
LXC_ID,											/* x */
LXC_ID,											/* y */
LXC_ID,											/* z */
0,												/* { */
0,												/* | */
0,												/* } */
0,												/* ~ */
0,												/* 0x7f */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\head\head.c ===
/* head - first n lines to STDOUT
 *
 *   20-Jul-1991 ianja Wrote it.
 *   21-Jul-1991 ianja Close stdin (for piped input)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

int Head(char *pszFile, int nLines, BOOL fBanner);
char *Version = "HEAD v1.1 1991-06-20:";

#define BUFSZ 256

void
__cdecl main (argc, argv)
int argc;
char *argv[];
{
    int  nArg;
    int  cLines = 10;  // default
    int  nFiles = 0;
    int  nErr = 0;

    if ((argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/'))) {
        if (argv[1][1] == '?') {
            printf("%s\n", Version);
            printf("usage: HEAD [switches] [filename]*\n");
            printf("   switches: [-?] display this message\n");
            printf("             [-n] display top n lines of each file (default 10)\n");
            exit(0);
        }

        cLines = atoi(argv[1]+1);
        nArg = 2;
    } else {
        nArg = 1;
    }

    nFiles = argc - nArg;

    if (nFiles < 1) {
        nErr += Head(NULL, cLines, FALSE);
    } else while (nArg < argc) {
        nErr += Head(argv[nArg], cLines, (nFiles > 1));
        nArg++;
    }

    if (nErr) {
        exit(2);
    } else {
        exit(0);
    }
}

int Head(char *pszFile, int nLines, BOOL fBanner)
{
    FILE *fp;
    int nErr = 0;
    char buff[BUFSZ];

    /*
     * Open file for reading
     */
    if (pszFile) {
        if ((fp = fopen(pszFile, "r")) == NULL) {
            fprintf(stderr, "HEAD: can't open %s\n", pszFile);
            return 1;
        }
    } else {
        fp = stdin;
    }

    /*
     * Banner printed if there is more than one input file
     */
    if (fBanner) {
        fprintf(stdout, "==> %s <==\n", pszFile);
    }

    /*
     * Print cLines, or up to end of file, whichever comes first
     */
    while (nLines-- > 0) {
        if (fgets(buff, BUFSZ-1, fp) == NULL) {
            if (!feof(fp)) {
                fprintf(stderr, "HEAD: can't read %s\n", pszFile);
                nErr++;
                goto CloseOut;
            }
            break;
        }
        if (fputs(buff, stdout) == EOF) {
            fprintf(stderr, "can't write output\n");
            nErr++;
            goto CloseOut;
        }
    }

    if (fBanner) {
        fprintf(stdout, "\n");
    }

CloseOut:
    fclose(fp);
    return nErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\charmap.h ===
/*
**  charmap.h : P0 specific, also included by charmap.c
**  it defines the mapping used to go from simple chars to these predefined
**  values. this enables the compiler to use a compact switch stmt.
**  they have been grouped in what is believed to be the most beneficial
**  way, in that most switches will be checking those values which have
**  been grouped together.
*/
#define	EOS_CHAR		'\0'	/* end of string/buffer marker char */

#define	LX_WHITE		0
#define	LX_CR			1
#define	LX_SLASH		2		/* /, /=, comment start  */
#define	LX_EOS			3
#define	LX_STAR			4		/* *, *=, comment stop  */
#define	LX_NL			5
#define	LX_BACKSLASH	6
#define	LX_SQUOTE		7
#define	LX_DQUOTE		8

#define	LX_DOT			9		/* . ... */
#define	LX_BANG			10		/* ! !=  */
#define	LX_POUND		11		/* # ##  */
#define	LX_PERCENT		12		/* % %=  */
#define	LX_EQ			13		/* = ==  */
#define	LX_HAT			14		/* ^ ^=  */
#define	LX_OR			15		/* | |= || */
#define	LX_AND			16		/* & && &= */
#define	LX_PLUS			17		/* + ++ += */
#define	LX_MINUS		18		/* - -- -= ->  */
#define	LX_LT			19		/* < << <<= <= */
#define	LX_GT			20		/* > >= >> >>= */
#define	LX_LSHIFT		21		/* << */
#define	LX_RSHIFT		22		/* >> */

#define	LX_ILL			23
#define	LX_CBRACE		24
#define	LX_CBRACK		25
#define	LX_COLON		26
#define	LX_COMMA		27
#define	LX_CPAREN		28
#define	LX_NUMBER		29
#define	LX_OBRACE		30
#define	LX_OBRACK		31
#define	LX_OPAREN		32
#define	LX_QUEST		33
#define	LX_SEMI			34
#define	LX_TILDE		35
#define	LX_MACFORMAL	36
#define	LX_STRFORMAL	37
#define LX_CHARFORMAL	38
#define	LX_NOEXPAND		39
#define	LX_ID			40
#define	LX_EACH			41

#define	LX_LEADBYTE		42
#define	LX_ASCII		43		/* to use for 'non-illegal' illegals */

#define	LX_FORMALMARK	0x1
#define	LX_FORMALSTR	0x2
#define	LX_FORMALCHAR	0x3
#define	LX_NOEXPANDMARK	0x4
#define	CONTROL_Z		0x1a
/*
**  Charmap is indexed with a character value plus the above offset
*/
#define	CHARMAP(c)		(Charmap[((UCHAR)(c))])

#define	LX_IS_IDENT(c)	(CHARMAP(c) == LX_ID)
#define	LX_IS_WHITE(c)	(CHARMAP(c) == LX_WHITE)
#define	LX_IS_NUMBER(c)	(CHARMAP(c) == LX_NUMBER)

#define LXC_BDIGIT	0x01		/* 0 - 1 */
#define	LXC_ODIGIT	0x02		/* 0 - 7 */
#define	LXC_DIGIT	0x04		/* 0 - 9 */
#define	LXC_XDIGIT	0x08		/* a-f A-F 0-9 */
#define	LXC_ID		0x10		/* continuation is part of an identifier */
#define LXC_RADIX	0x20		/* BbDdHhOoQq */
#define	LXC_WHITE	0x40		/* whitespace */
#define	LXC_SPECIAL	0x80		/* the char may have a special meaning */

#define	CONTMAP(c)	(Contmap[((UCHAR)(c))])
/*
**	LXC_IS_ID(c) : is c part of an identifier
*/
#define	LXC_IS_BDIGIT(c)	(CONTMAP(c) & LXC_BDIGIT)
#define	LXC_IS_ODIGIT(c)	(CONTMAP(c) & LXC_ODIGIT)
#define	LXC_IS_DIGIT(c)		(CONTMAP(c) & LXC_DIGIT)
#define	LXC_IS_XDIGIT(c)	(CONTMAP(c) & LXC_XDIGIT)
#define	LXC_IS_IDENT(c)		(CONTMAP(c) & LXC_ID)
#define LXC_IS_RADIX(c)		(CONTMAP(c) & LXC_RADIX)
#define LXC_IS_WHITE(c)		(CONTMAP(c) & LXC_WHITE)
#define IS_SPECIAL(c)		(CONTMAP(c) & LXC_SPECIAL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\error.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* ERROR.C - Error Handler Routines					*/
/*									*/
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "msgs.h"


/* defines for message types */
#define W_MSG	4000
#define E_MSG	2000
#define F_MSG	1000

static char  Errbuff[128] = {
    0};

/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void message (int, int, char *);


/************************************************************************/
/* ERROR - Print an error message to STDOUT.				*/
/************************************************************************/
#define MAX_ERRORS 100

void error (int msgnum)
{

    message(E_MSG, msgnum, Msg_Text);
    if (++Nerrors > MAX_ERRORS) {
	Msg_Temp = GET_MSG (1003);
	SET_MSG (Msg_Text, Msg_Temp, MAX_ERRORS);
 	fatal(1003);		/* die - too many errors */
    } 
    return;
}


/************************************************************************/
/* FATAL - Print an error message to STDOUT and exit.			*/
/************************************************************************/
void fatal (int msgnum)
{
    message(F_MSG, msgnum, Msg_Text);
    exit(++Nerrors);
}


/************************************************************************/
/* WARNING - Print an error message to STDOUT.				*/
/************************************************************************/
void warning (int msgnum)
{
    message(W_MSG, msgnum, Msg_Text);
}


/************************************************************************/
/* MESSAGE - format and print the message to STDERR.			*/
/* The msg goes out in the form :					*/
/*     <file>(<line>) : <msgtype> <errnum> <expanded msg>		*/
/************************************************************************/
void message(int msgtype, int msgnum, char *msg)
{
    char  mbuff[512];
    register char *p = mbuff;
    register char *msgname;
    char msgnumstr[32];

    if (Linenumber > 0 && Filename) {
	SET_MSG (p, "%s(%d) : ", Filename, Linenumber);
	p += strlen(p);
    }
    if (msgtype) {
	switch (msgtype)
	{
	case W_MSG:
	    msgname = GET_MSG(MSG_WARN);
	    break;
	case E_MSG:
	    msgname = GET_MSG(MSG_ERROR);
	    break;
	case F_MSG:
	    msgname = GET_MSG(MSG_FATAL);
	    break;
	}
	strcpy(p, msgname);
	p += strlen(msgname);
	SET_MSG(msgnumstr, " %s%d: ", "RC", msgnum);
	strcpy(p, msgnumstr);
	p += strlen(msgnumstr);
	strcpy(p, msg);
	p += strlen(p);
    }
    fwrite(mbuff, strlen(mbuff), 1, stderr);
    fwrite("\n", 1, 1, stderr);
    if (Srclist && Errfl) {

	/* emit messages to error il file too */

	fwrite(mbuff, strlen(mbuff), 1, Errfl);
	fwrite("\n", 1, 1, Errfl);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hextract\hextract.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    hextract.c

Abstract:

    This is the main module for a header the file extractor.

Author:

    Andre Vachon  (andreva) 13-Feb-1992
    Mark Lucovsky (markl)   28-Jan-1991

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <common.ver>


//
// Function declarations
//

int
ProcessParameters(
                 int argc,
                 char *argv[]
                 );

void
ProcessSourceFile( void );

void
ProcessLine(
           char *s
           );

//
// Global Data
//

unsigned char LineFiltering = 0;

char *LineTag;
char *ExcludeLineTag;
char *MultiLineTagStart;
char *MultiLineTagEnd;
char *CommentDelimiter = "//";

char *OutputFileName;
char *SourceFileName;
char **SourceFileList;

int SourceFileCount;
FILE *SourceFile, *OutputFile;


#define STRING_BUFFER_SIZE 1024
char StringBuffer[STRING_BUFFER_SIZE];


#define BUILD_VER_COMMENT "/*++ BUILD Version: "
#define BUILD_VER_COMMENT_LENGTH (sizeof( BUILD_VER_COMMENT )-1)

int OutputVersion = 0;

#define szVERSION	"1.3"


char const szUsage[] =
"Microsoft (R) HEXTRACT Version " szVERSION " (NT)\n"
VER_LEGALCOPYRIGHT_STR ". All rights reserved.\n"
"\n"
"Usage: HEXTRACT [options] filename1 [filename2 ...]\n"
"\n"
"Options:\n"
"    -f                        - filtering is turned on:\n"
"                                ULONG, UCHAR, USHORT & NTSTATUS are\n"
"                                replaced with DWORD, BYTE, WORD & DWORD.\n"
"    -f2                       - Same as -f except ULONGLONG and ULONG_PTR\n"
"                                isn't converted\n"
"    -o filename               - required existing output filename;\n"
"                                output is appended to filename\n"
"    -xt string                - supplies the tag for excluding one line\n"
"    -lt string                - supplies the tag for extracting one line\n"
"    -bt string1 string2       - supplies the starting and ending tags for\n"
"                                extracting multiple lines\n"
"    filename1 [filename2 ...] - supplies files from which the definitions\n"
"                                are extracted\n"
"\n"
"To be parsed properly, the tag strings must be located within a comment\n"
"delimited by //\n"
;


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    char achver[BUILD_VER_COMMENT_LENGTH];

    if (!ProcessParameters(argc, argv) || NULL == OutputFileName) {

        fprintf(stderr, szUsage);
        return 1;
    }

    if ( (OutputFile = fopen(OutputFileName,"r+")) == 0) {

        fprintf(stderr,"HEXTRACT: Unable to open output file %s for update access\n",OutputFileName);
        return 1;

    }

    if (fseek(OutputFile, 0L, SEEK_END) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to end of %s\n", OutputFileName);
        return 1;
    }
        

    OutputVersion = 0;

#ifdef HEXTRACT_DEBUG
    fprintf(
           stderr,
           "%s\n%s\n%s\n%s\n",
           LineTag,
           ExcludeLineTag,
           MultiLineTagStart,
           MultiLineTagEnd);

#endif

    while ( SourceFileCount-- ) {

        SourceFileName = *SourceFileList++;
        if ( (SourceFile = fopen(SourceFileName,"r")) == 0) {

            fprintf(stderr,"HEXTRACT: Unable to open source file %s for read access\n",SourceFileName);
            return 1;

        }

        ProcessSourceFile();
        fclose(SourceFile);

    }

    if (fseek(OutputFile, 0L, SEEK_SET) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to start of %s\n", OutputFileName);
        return 1;
    }
    if (1 == fread(achver, BUILD_VER_COMMENT_LENGTH, 1, OutputFile) &&
        !strncmp(achver, BUILD_VER_COMMENT, BUILD_VER_COMMENT_LENGTH)) {

        if (fseek(OutputFile, (long)BUILD_VER_COMMENT_LENGTH, SEEK_SET) == -1) {
            fprintf(stderr, "HEXTRACT: Unable to seek past comments in %s\n", OutputFileName);
            return 1;
        }
        fprintf(OutputFile, "%04d", OutputVersion);
    }

    if (fseek(OutputFile, 0L, SEEK_END) == -1) {
        fprintf(stderr, "HEXTRACT: Unable to seek to end of %s\n", OutputFileName);
        return 1;
    }
    fclose(OutputFile);
    return( 0 );
}


int
ProcessParameters(
                 int argc,
                 char *argv[]
                 )
{
    char c, *p;

    while (--argc) {

        p = *++argv;

        //
        // if we have a delimiter for a parameter, case throught the valid
        // parameter. Otherwise, the rest of the parameters are the list of
        // input files.
        //

        if (*p == '/' || *p == '-') {

            //
            // Switch on all the valid delimiters. If we don't get a valid
            // one, return with an error.
            //

            c = *++p;

            switch (toupper( c )) {

                case 'F':

                    c = *++p;
                    if ( (toupper ( c )) == '2')
                        LineFiltering = 2;
                    else
                        LineFiltering = 1;

                    break;

                case 'O':

                    argc--, argv++;
                    OutputFileName = *argv;

                    break;

                case 'L':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    LineTag = *argv;

                    break;

                case 'B':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    MultiLineTagStart = *argv;
                    argc--, argv++;
                    MultiLineTagEnd = *argv;

                    break;

                case 'X':

                    c = *++p;
                    if ( (toupper ( c )) != 'T')
                        return 0;
                    argc--, argv++;
                    ExcludeLineTag = *argv;

                    break;

                default:

                    return 0;

            }

        } else {

            //
            // Make the assumptionthat we have a valid command line if and
            // only if we have a list of filenames.
            //

            SourceFileList = argv;
            SourceFileCount = argc;

            return 1;

        }
    }

    return 0;
}

void
ProcessSourceFile( void )
{
    char *s;
    char *comment;
    char *tag;
    char *test;

    s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);

    if (s) {
        if (!strncmp( s, BUILD_VER_COMMENT, BUILD_VER_COMMENT_LENGTH )) {
            OutputVersion += atoi( s + BUILD_VER_COMMENT_LENGTH );
        }
    }

    while ( s ) {

        //
        // Check for a block with delimiters
        //

        if (NULL != MultiLineTagStart) {
            comment = strstr(s,CommentDelimiter);
            if ( comment ) {

                tag = strstr(comment,MultiLineTagStart);
                if ( tag ) {

                    //
                    // Now that we have found an opening tag, check each
                    // following line for the closing tag, and then include it
                    // in the ouput.
                    //

                    s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                    while ( s ) {
                        int fProcess = 1;

                        comment = strstr(s,CommentDelimiter);
                        if ( comment ) {
                            tag = strstr(comment,MultiLineTagEnd);
                            if ( tag ) {
                                goto bottom;
                            }
                            if (NULL != ExcludeLineTag &&
                                strstr(comment,ExcludeLineTag)) {
                                fProcess = 0;
                            }
                        }
                        if (fProcess) {
                            ProcessLine(s);
                        }
                        s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                    }

                    fprintf(stderr,
                            "HEXTRACT: %s without matching %s in %s\n",
                            MultiLineTagStart,
                            MultiLineTagEnd,
                            OutputFileName);

                    exit(1);
                }
            }
        }

        //
        // Check for a single line to output.
        //

        if (NULL != LineTag) {
            comment = strstr(s,CommentDelimiter);
            if ( comment ) {
                tag = strstr(comment,LineTag);
                if ( tag ) {
                    *comment++ = '\n';
                    *comment = '\0';
                    ProcessLine(s);
                    goto bottom;
                }
            }
        }

        bottom:
        s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
    }
}

void
ProcessLine(
           char *s
           )
{
    char *t;
    char *s1;

    if (LineFiltering) {
        s1 = s;

        //
        // This should be replaced by a data file describing an input token
        // and an output token which would be used for the filtering.
        //

        while (t = strstr(s1,"ULONG")) {
            if (LineFiltering == 2) {
                if (!memcmp(t, "ULONGLONG", 9)) {
                    s1+=9;
                } else if (!memcmp(t, "ULONG_PTR", 9)) {
                    s1+=9;
                } else {
                    memcpy(t,"DWORD",5);
                }
            } else {
                memcpy(t,"DWORD",5);
            }
        }

        while (t = strstr(s,"UCHAR"))
            memcpy(t,"BYTE ",5);

        while (t = strstr(s,"USHORT"))
            memcpy(t,"WORD  ",6);

        while (t = strstr(s,"NTSTATUS"))
            memcpy(t,"DWORD   ",8);
    }

    fputs(s,OutputFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\getflags.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETFLAGS.C - Parse Command Line Flags				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "rcpptype.h"
#include "getflags.h"
#include "rcppdecl.h"
#include "rcppext.h"


/************************************************************************/
/* Define function specific macros and global vars			*/
/************************************************************************/
static char	*ErrString;   /* Store string pointer in case of error */


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
int getnumber	(char *);
int isita	(char *, char);
void substr	(struct cmdtab *, char *, int);
int tailmatch	(char *, char *);



/************************************************************************
 *	crack_cmd(table, string, func, dup)
 *		set flags determined by the string based on table.
 *		func will get the next word.
 *		if dup is set, any strings stored away will get pstrduped
 * see getflags.h for specific matching and setting operators
 *
 *  for flags which take parameters, a 'char' following the flag where 'char' is
 *  '#' : says the parameter string may be separated from the option.
 *		ie, "-M#" accepts "-Mabc" and "-M abc"
 *  '*' : says the parameter must be concatenated with the flag
 *		ie, "-A*" accepts only "-Axyz" not "-A xyz"
 *  if neither is specified a space is required between parameter and flag
 *		ie, "-o" accepts only "-o file" and not "-ofile"
 *
 * Modified by:		Dave Weil			D001
 *				recognize '-' and '/' as equivalent on MSDOS
 *
 ************************************************************************/

int crack_cmd(struct cmdtab *tab, char *string, char *(*next)(void), int _dup)
{
    register char	*format, *str;
    if (!string) {
	return(0);
    }

    ErrString = string;
    for (; tab->type; tab++)		/* for each format */ {
	format = tab->format;
	str = string;
	for (; ; )				/* scan the string */
	    switch (*format) {

 	    /*  optional space between flag and parameter  */
	    case '#':
		if ( !*str ) {
		    substr(tab, (*next)(), _dup);
		} else {
		    substr(tab, str, _dup);
		}
		return(tab->retval);
		break;

	    /*  no space allowed between flag and parameter  */
	    case '*':
		if (*str && tailmatch(format, str))
		    substr(tab, str, _dup);
		else
		    goto notmatch;
		return(tab->retval);
		break;

	    /*  space required between flag and parameter  */
	    case 0:
		if (*str) {			/*  str left, no good  */
		    goto notmatch;
		} else if (tab->type & TAKESARG) { /*  if it takes an arg  */
		    substr(tab, (*next)(), _dup);
		} else {	/*  doesn't want an arg  */
		    substr(tab, (char *)0, _dup);
		}
		return(tab->retval);
		break;
	    case '-':					/* D001 */
		    if ('-' == *str) {
			str++;				/* D001 */
			format++;			/* D001 */
			continue;			/* D001 */
		    }					/* D001 */
		    else	/* D001 */
			goto notmatch;				/* D001 */

	    default:
		if (*format++ == *str++)
		    continue;
		goto notmatch;
	    }
	/* sorry.  we need to break out two levels of loop */
notmatch:
	;
    }
    return(0);
}


/************************************************************************/
/* set the appropriate flag(s).  called only when we know we have a match */
/************************************************************************/
void substr(struct cmdtab *tab, register char *str, int _dup)
{
    register struct subtab *q;
    LIST * list;
    char	*string = str;

    switch (tab->type) {
    case FLAG:
	*(int *)(tab->flag) = 1;
	return;
    case UNFLAG:
	*(int *)(tab->flag) = 0;
	return;
    case NOVSTR:
	if (*(char **)(tab->flag)) {
	    /* before we print it out in the error message get rid of the
	     * arg specifier (e.g. #) at the end of the format.
	     */
	    string = _strdup(tab->format);
        if (!string) {
            Msg_Temp = GET_MSG (1002);
            SET_MSG (Msg_Text, Msg_Temp);
            error(1002);
            return;
        }
	    string[strlen(string)-1] = '\0';
	    Msg_Temp = GET_MSG(1046);
	    SET_MSG (Msg_Text, Msg_Temp, string,*(char **)(tab->flag),str);
	    fatal(1046);
	    return;
	}
	/* fall through */
    case STRING:
	*(char **)(tab->flag) = (_dup ? _strdup(str) : str);
	return;
    case NUMBER:
	*(int *)(tab->flag) = getnumber (str);
	return;
    case PSHSTR:
	list = (LIST * )(tab->flag);
	if (list->li_top > 0)
	    list->li_defns[--list->li_top] = (_dup ? _strdup(str) : str);
	else {
	    Msg_Temp = GET_MSG(1047);
	    SET_MSG (Msg_Text, Msg_Temp, tab->format, str);
	    fatal(1047);
	}
	return;
    case SUBSTR:
	for ( ; *str; ++str) {	/*  walk the substring  */
	    for (q = (struct subtab *)tab->flag; q->letter; q++) {
		/*
				**  for every member in the table
				*/
		if (*str == (char)q->letter)
		    switch (q->type) {
		    case FLAG:
			*(q->flag) = 1;
			goto got_letter;
		    case UNFLAG:
			*(q->flag) = 0;
			goto got_letter;
		    default:
			goto got_letter;
		    }
	    }
got_letter:
	    if (!q->letter) {
		Msg_Temp = GET_MSG(1048);
	        SET_MSG (Msg_Text, Msg_Temp, *str, ErrString);
		fatal(1048);
	    }
	}
	return;
    default:
	return;
    }
}


/************************************************************************/
/* Parse the string and return a number 0 <= x < 0xffff (64K)		*/
/************************************************************************/
int	getnumber (char *str)
{
    long	i = 0;
    char	*ptr = str;

    for (; isspace(*ptr); ptr++)
	;
    if (!isdigit(*ptr) || (((i = atol(ptr)) >= 65535) ||  i < 0)) {
	Msg_Temp = GET_MSG(1049);
	SET_MSG (Msg_Text, Msg_Temp, str);
	fatal(1049);		/* invalid numerical argument, 'str' */
    }
    return ((int) i);
}


/************************************************************************/
/*  is the letter in the string?					*/
/************************************************************************/
int isita (register char *str, register char let)
{
    if (str)
	while (*str)
	    if (*str++ == let)
		return(1);
    return(0);
}


/************************************************************************/
/* compare a tail format (as in *.c) with a string.  if there is no	*/
/* tail, anything matches.  (null strings are detected elsewhere)	*/
/* the current implementation only allows one wild card			*/
/************************************************************************/
int tailmatch (char *format, char *str)
{
    register char	*f = format;
    register char	*s = str;

    if (f[1] == 0)	/*  wild card is the last thing in the format, it matches */
	return(1);
    while (f[1])		/*  find char in front of null in format  */
	f++;
    while (s[1])		/*  find char in front of null in string to check  */
	s++;
    while (*s == *f) {	/*  check chars walking towards front */
	s--;
	f--;
    }
    /*
**  if we're back at the beginning of the format
**  and
**  the string is either at the beginning or somewhere inside
**  then we have a match.
**
**  ex format == "*.c", str == "file.c"
**	at this point *f = '*' and *s == 'e', since we've kicked out of the above
**  loop. since f==format and s>=str this is a match.
**  but if format == "*.c" and str == "file.asm" then
**  *f == 'c' and *s = 'm', f != format and no match.
*/
    return((f == format) && (s >= str));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\getflags.h ===
/*
 * the format strings may be:
 *		.*			must match exactly
 *		.*\*.*		head and tail must match, with wild card in middle
 *		.*#			head must match. tail can either be adjacent or next word
 *	at the moment '-' is not treated specialy
 *  note that 'middle' may be at either end since '.*' matches null.
 */
	
#define TAKESARG 0x20		/* tag to indicate argument or not */
#define FLAG 1				/* set the flag */
#define STRING 2|TAKESARG	/* set the string, either from here, or next word */
#define SUBSTR 3|TAKESARG	/* set single letter flags from substring */
#define NUMBER 4|TAKESARG	/* set read in the number */
#define UNFLAG 5			/* turn the flag off */
#define PSHSTR 6|TAKESARG	/* like string, but puts it on a LIST structure */
#define NOVSTR 7|TAKESARG	/* like string, but complains about overwriting */

#define NUM_ARGS		50					/* Limit of flags passed from driver to pass */
#define MSC_ENVFLAGS	"MSC_CMD_FLAGS"
		/* Environment variable flags passed in, used for getenv() */
#define PUT_MSC_ENVFLAGS	"MSC_CMD_FLAGS="	
		/* Environment variable flags passed in, used for putenv() */

/* return values from getflags */
#define R_SWITCH	1
#define R_CFILE		2
#define R_ASMFILE	3
#define R_OBJFILE	4
#define R_ERROR		5
#define R_FILE		6
#define R_EXIT		7
#define	R_FFILE		8
#define	R_PFILE		9
#define	R_AFILE		10
#define	R_OFILE		11
/* r. nevin, 1/11/85 */
#define R_HELP		12
/* b. nguyen, 4/7/86 */
#define R_HELPC	13
#define R_HELPF	14

struct cmdtab
	{
	char *format;		/* format matching string */
	char *flag;			/* pointer to what to fill in */
/*  this is really a
 *	union
 *		{
 *		char **str;
 *		int  *flag;
 *		struct subtab *sub;
 *		struct LIST *list;
 *		} cm;
 *	but you cant initialize unions so we have to fake it.
 */
	char retval;		/* crack_cmd will return whatever is here */
	UCHAR type;			/* control mask */
	};

struct subtab
	{
	int letter;
	int type;
	int *flag;
	};

#define FORT_LANG 1
#define C_LANG  2

struct Help_string{
	char *message;
	int fLanguage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\getmsg.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETMSG.C - Replaces NMSGHDR.ASM and MSGS.ASM				*/
/*									*/
/* 28-Nov-90 w-BrianM  Created to remove need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "getmsg.h"

/************************************************************************/
/* GET_MSG - Given a message number, get the correct format string	*/
/************************************************************************/
char * GET_MSG (int msgnumber)
{
    int imsg = 0;
    int inum;

    while ((inum = MSG_TABLE[imsg].usmsgnum) != LASTMSG) {
	if (inum == msgnumber) {
	    return (MSG_TABLE[imsg].pmsg);
	}
	imsg ++;
    }
    return ("");
}


/************************************************************************/
/* SET_MSG - Given a format string, format it and store it in first parm*/
/************************************************************************/
void __cdecl SET_MSG (char *exp, char *fmt, ...)
{
    va_list	arg;
    char *	arg_pchar;
    int		arg_int;
    long	arg_long;
    char	arg_char;

    int base;
    int longflag;

    va_start (arg, fmt);
    while (*fmt) {
	if (*fmt == '%') {
	    longflag = FALSE;
top:
	    switch (*(fmt+1)) {
	    case 'l' :
		longflag = TRUE;
		fmt++;
		goto top;
	    case 'F' :
		fmt++;
		goto top;
	    case 's' :
		arg_pchar = va_arg(arg, char *);
		strcpy(exp, arg_pchar);
		exp += strlen(arg_pchar);
		fmt += 2;
		break;
	    case 'd' :
	    case 'x' :
		base = *(fmt+1) == 'd' ? 10 : 16;
		if (longflag) {
		    arg_long = va_arg (arg, long);
		    exp += zltoa(arg_long, exp, base);
		}
		else {
		    arg_int = va_arg (arg, int);
		    exp += zltoa((long)arg_int, exp, base);
		}
		fmt += 2;
		break;
	    case 'c' :
		arg_char = va_arg (arg, char);
		*exp++ = arg_char;
		fmt += 2;
		break;
	    default :
		*exp++ = *fmt++;
	    }
	}
	else {
	    *exp++ = *fmt++;
	}
    }
    *exp = 0;
    va_end (arg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\getmsg.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GETMSG.H - Include File for the message return function		*/
/*									*/
/* 28-Nov-90 w-BrianM	Created to replace need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

/************************************************************************/
/****								     ****/
/**** NOTE - All changes in this file MUST be duplicated in MSGS.H!  ****/
/****								     ****/
/************************************************************************/

#include "msgs.h"

#define LASTMSG	-1

struct msgtable {
	int	usmsgnum;
	char * pmsg;
} MSG_TABLE[] = {

	/****************************************************************/
	/* Messages							*/
	/****************************************************************/

	{MSG_LEFT,	     "left"},
	{MSG_RIGHT,	     "right"},
	{MSG_UC_UNNAMED,     "UNNAMED"},
	{MSG_LC_UNNAMED,     "<unnamed>"},
	{MSG_COMMA,	     "trailing ',' used for variable argument list"},
	{MSG_CAST_LVAL,      "cast on lvalue"},
	{MSG_EXT_INIT,	     "extended initializer form"},
	{MSG_TYPEDEF,	     "benign typedef redefinition"},
	{MSG_EXT_REDEF,	     "redefined extern to static"},
	{MSG_MAC_FORMALS,    "macro formals in strings"},
	{MSG_NO_SEMI,	     "missing ';' following last struct/union member"},
	{MSG_BITFIELDS,	     "bitfield types other than int"},
	{MSG_WARN,	     "warning"},
	{MSG_ERROR,	     "error"},
	{MSG_FATAL,          "fatal error"},
	{MSG_BLOCK_FUNCDECL, "function given file scope"},
	{MSG_CASTTO_FUNC,    "cast of data pointer to function pointer"},
	{MSG_CASTTO_NONFUNC, "cast of function pointer to data pointer"},
	{MSG_ELLIPSIS,	     "function declaration used ellipsis"},
	{MSG_TOLEVEL0,	     "used function declaration from a previous block"},

	/****************************************************************/
	/* Fatals							*/
	/****************************************************************/

	{1001,	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tPlease report this error to your local dealer"},
	{1002,	"out of heap space"},
	{1003,	"error count exceeds %d; stopping compilation"},
	{1004,	"unexpected EOF"},
	{1005,	"string too big for buffer"},
	{1006,	"write error on compiler intermediate file"},
	{1007,	"unrecognized flag '%s' in '%s'"},
	{1008,	"no input file specified"},
	{1009,	"compiler limit : macros too deeply nested"},
	{1010,	"compiler limit : macro expansion too big"},
	{1011,  "no output file specified"},
	{1012,	"bad parenthesis nesting - missing '%c'"},
	{1013,	"cannot open source file '%s'"},
	{1014,	"too many include files"},
	{1015,	"cannot open include file '%s'"},
	{1016,	"#if[n]def expected an identifier"},
	{1017,	"invalid integer constant expression"},
	{1018,	"unexpected '#elif'"},
	{1019,	"unexpected '#else'"},
	{1020,	"unexpected '#endif'"},
	{1021,	"bad preprocessor command '%s'"},
	{1022,	"expected '#endif'"},
	{1023,	"Could not open output file"},
	{1026,	"parser stack overflow, please simplify your program"},
	{1027,	"DGROUP data allocation exceeds 64K"	/* QC, c23 */},
	{1028,	"%s segment allocation exceeds 64K"	/* QC */},
	{1031,	"compiler limit : function calls too deeply nested"	/* QC, c23 */},
	{1032,	"cannot open object listing file '%s'"			/* QC, c23 */},
	{1035,	"expression too complex, please simplify"		/* QC, c23 */},
	{1037,	"cannot open object file '%s'"					/* QC, c23 */},
	{1041,	"cannot open compiler intermediate file - no more files"},
	{1042,	"cannot open compiler intermediate file - no such file or directory"},
	{1043,	"cannot open compiler intermediate file"},
	{1044,	"out of disk space for compiler intermediate file"},
	{1045,	"floating point overflow"},
	{1047,	"too many %s flags, '%s'"},
	{1048,	"unknown option '%c' in '%s'"},
	{1049,	"invalid numerical argument '%s'"},
	{1052,	"too many #if/#ifdef's"},
	{1053,	"compiler limit : struct/union nesting"},
	{1054,	"compiler limit : initializers too deeply nested"},
	{1055,	"compiler limit : out of keys"},
	{1056,	"compiler limit : out of macro expansion space"},
	{1057,	"unexpected EOF in macro expansion (missing ')'?)"},
	{1059,	"out of near heap space"},
	{1060,	"out of far heap space"},
	{1061,	"compiler limit : blocks too deeply nested"	/* QC */},
	{1062,	"error writing to preprocessor output file"},
	{1063,	"compiler limit : compiler stack overflow"	/* QC */},
	{1065,	"compiler limit : '%s': macro definition too big"},
	{1067,	"compiler limit : identifier overflowed internal buffer"},
	{1068,	"compiler error : possible binary file for input"},
	{1000,	"UNKNOWN FATAL ERROR\n\t\tPlease report this error to your local dealer"},

	/****************************************************************/
	/* Errors							*/
	/****************************************************************/

	{2001,	"newline in constant"},
	{2003,	"expected 'defined id'"},
	{2004,	"expected 'defined(id)'"},
	{2005,	"#line expected a line number, found '%s'"},
	{2006,	"#include expected a file name, found '%s'"},
	{2007,	"#define syntax"},
	{2008,	"'%c' : unexpected in macro definition"},
	{2009,	"reuse of macro formal '%s'"},
	{2010,	"'%c' : unexpected in formal list"},
	{2012,	"missing name following '<'"},
	{2013,	"missing '>'"},
	{2014,	"preprocessor command must start as first non-whitespace"},
	{2015,	"too many chars in constant"},
	{2016,	"no closing single quote"},
	{2017,	"illegal escape sequence"},
	{2018,	"unknown character '0x%x'"},
	{2019,	"expected preprocessor command, found '%c'"},
	{2020,	"illegal digit '%c' for base %d"},
	{2021,	"expected exponent value, not '%c'"},
	{2022,	"'%ld' : too big for char"},
	{2023,	"divide by 0"},
	{2024,	"mod by 0"},
	{2025,	"'%s' : enum/struct/union type redefinition"},
	{2026,	"'%s' : member of enum redefinition"},
	{2028,	"struct/union member needs to be inside a struct/union"},
	{2029,	"'%Fs' : bit-fields only allowed in structs"},
	{2030,	"'%Fs' : struct/union member redefinition"},
	{2031,	"'%Fs' : function cannot be struct/union member"},
	{2033,	"'%Fs' : bit-field cannot have indirection"},
	{2034,	"'%Fs' : bit-field type too small for number of bits"},
	{2035,	"struct/union '%Fs' : unknown size"},
	{2036,	"left of '%s%s' must have a struct/union type"},
	{2037,	"left of '%s' specifies undefined struct/union '%Fs'"},
	{2038,	"'%s' : not struct/union member"},
	{2039,	"'->' requires struct/union pointer"},
	{2040,	"'.' requires struct/union name"},
	{2042,	"signed/unsigned keywords mutually exclusive"},
	{2043,	"illegal break"},
	{2044,	"illegal continue"},
	{2045,	"'%s' : label redefined"},
	{2046,	"illegal case"},
	{2047,	"illegal default"},
	{2048,	"more than one default"},
	{2050,	"non-integral switch expression"},
	{2051,	"case expression not constant"},
	{2052,	"case expression not integral"},
	{2053,	"case value %d already used"},
	{2054,	"expected '(' to follow '%Fs'"},
	{2055,	"expected formal parameter list, not a type list"},
	{2056,	"illegal expression"},
	{2057,	"expected constant expression"},
	{2058,	"constant expression is not integral"},
	{2059,	"syntax error : '%s'"},
	{2060,	"syntax error : EOF"},
	{2061,	"syntax error : identifier '%s'"},
	{2062,	"type '%s' unexpected"},
	{2063,	"'%s' : not a function"},
	{2064,	"term does not evaluate to a function"},
	{2065,	"'%s' : undefined"},
	{2066,	"cast to function returning . . . is illegal"},
	{2067,	"cast to array type is illegal"},
	{2068,	"illegal cast"},
	{2069,	"cast of 'void' term to non-void"},
	{2070,	"'%Fs' : storage class must be 'extern'"},
	{2071,	"'%Fs' : bad storage class"},
	{2072,	"'%Fs' : initialization of a function"},
	{2075,	"'%Fs' : array initialization needs curly braces"},
	{2076,	"'%Fs' : struct/union initialization needs curly braces"},
	{2077,	"non-scalar field initializer '%Fs'"},
	{2078,	"too many initializers"},
	{2079,	"'%Fs' uses undefined struct/union '%Fs'"},
	{2082,	"redefinition of formal parameter '%Fs'"},
	{2084,	"function '%Fs' already has a body"},
	{2085,	"'%Fs' : not in formal parameter list"},
	{2086,	"'%Fs' : redefinition"},
	{2087,	"'%Fs' : missing subscript"},
	{2088,	"use of undefined enum/struct/union '%Fs'"},
	{2090,	"function returns array"},
	{2091,	"function returns function"},
	{2092,	"array element type cannot be function"},
	{2093,	"cannot initialize a static or struct with address of automatic vars"},
	{2094,	"label '%Fs' was undefined"},
	{2095,	"'%Fs' : actual has type 'void' : parameter %d"},
	{2096,	"struct/union comparison illegal"},
	{2097,	"illegal initialization"},
	{2098,	"non-address expression"},
	{2099,	"non-constant offset"},
	{2100,	"illegal indirection"},
	{2101,	"'&' on constant"},
	{2102,	"'&' requires lvalue"},
	{2103,	"'&' on register variable"},
	{2104,	"'&' on bit-field ignored"},
	{2105,	"'%s' needs lvalue"},
	{2106,	"'%s' : left operand must be lvalue"},
	{2107,	"illegal index, indirection not allowed"},
	{2108,	"non-integral index"},
	{2109,	"subscript on non-array"},
	{2110,	"'+' : 2 pointers"},
	{2111,	"pointer + non-integral value"},
	{2112,	"illegal pointer subtraction"},
	{2113,	"'-' : right operand pointer"},
	{2114,	"'%s' : pointer on left; needs integral right"},
	{2115,	"'%s' : incompatible types"},
	{2116,	"'%s' : bad %s operand"},
	{2117,	"'%s' : illegal for struct/union"},
	{2118,	"negative subscript"},
	{2119,	"'typedefs' both define indirection"},
	{2120,	"'void' illegal with all types"},
	{2125,	"%Fs : allocation exceeds 64K"		/* QC, c23 */},
	{2126,	"%Fs : auto allocation exceeds %s"	/* QC, c23 */},
	{2127,	"parameter allocation exceeds 32K"	/* QC, c23 */},
	{2130,	"#line expected a string containing the file name, found '%s'"},
	{2131,	"attributes specify more than one near/far/huge"},
	{2132,	"syntax error : unexpected identifier"},
	{2133,	"'%Fs' : unknown size"},
	{2134,	"'%Fs' : struct/union too large"},
	{2137,	"empty character constant"},
	{2138,	"unmatched close comment '*/'"},
	{2139,	"type following '%s' is illegal"},
	{2140,	"argument type cannot be function returning . . ."},
	{2141,	"value out of range for enum constant"},
	{2142,	"ellipsis requires three periods"},
	{2143,	"syntax error : missing '%s' before '%s'"},
	{2144,	"syntax error : missing '%s' before type '%Fs'"},
	{2145,	"syntax error : missing '%s' before identifier"},
	{2146,	"syntax error : missing '%s' before identifier '%s'"},
	{2147,	"unknown size"},
	{2148,	"array too large"},
	{2149,	"'%Fs' : named bit-field cannot have 0 width"},
	{2150,	"'%Fs' : bit-field must have type int, signed int, or unsigned int"},
	{2151,	"more than one cdecl/fortran/pascal attribute specified"},
	{2152,	"'%s' : pointers to functions with different attributes"},
	{2153,	"hex constants must have at least 1 hex digit"},
	{2154,	"'%s' : does not refer to a segment name"},
	{2155,	"'%s' : already in a segment"},
	{2156,	"pragma must be at outer level"},
	{2157,	"'%s' : must be declared before use in pragma list"},
	{2158,	"'%s' : is a function"},
	{2159,	"more than one storage class specified"},
	{2160,	"## cannot occur at the beginning of a macro definition"},
	{2161,	"## cannot occur at the end of a macro definition"},
	{2162,	"expected macro formal parameter"},
	{2163,	"'%s' : not available as an intrinsic"},
	{2164,	"'%s' : intrinsic was not declared"},
	{2165,	"'%s' : cannot modify pointers to data"},
	{2166,	"lval specifies 'const' object"},
	{2167,	"'%Fs' : too many actual parameters for intrinsic"},
	{2168,	"'%Fs' : too few actual parameters for intrinsic"},
	{2169,	"'%Fs' : is an intrinsic, it cannot be defined"},
	{2170,	"'%s' : intrinsic not declared as a function"},
	{2171,	"'%s' : bad operand"},
	{2172,	"'%Fs' : actual is not a pointer : parameter %d"},
	{2173,	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"},
	{2174,	"'%Fs' : actual has type 'void' : parameter %d, parameter list %d"},
	{2175,	"'%Fs' : unresolved external"	/* QC */},
	{2176,	"static far data not supported"	/* QC */},
	{2177,	"constant too big"},
	{2178,	"'%s' : storage class for same_seg variables must be 'extern'"},
	{2179,	"'%Fs' : was used in same_seg, but storage class is no longer 'extern'"},
	{2180,	"controlling expression has type 'void'"},
	{2181,	"pragma requires command line option '%s'"	/* QC */},
	{2182,	"'%Fs' : has type 'void'"},
	{2183,	"'interrupt' function must be 'far'"},
	{2184,	"'%s' function cannot be 'pascal/fortran'"},
	{2186,	"'saveregs/interrupt' modifiers mutually exclusive"},
	{2187,	"cast of near function pointer to far function pointer"},
	{2188,	"#error : %s"},
	{2190,	"'%s' : is a text segment"},
	{2191,	"'%s' : is a data segment"},
	{2198,	"'%Fs' : tried to be allocated in code segment '%Fs'"},
	{2199,	"'%Fs' : tried to be allocated in data segment '%Fs'"},
	{2200,	"'%Fs' : function has already been defined"},
	{2205,	"'%Fs' : cannot initialize 'extern' block scoped variables"},
	{2400,	"inline syntax error %s, found '%Fs'"},
	{2401,	"'%s' : register must be base %s"},
	{2402,	"'%s' : register must be index %s"},
	{2403,	"'%s' : register must be base/index %s"},
	{2404,	"'%s' : illegal register %s"},
	{2405,	"illegal short forward reference with offset"},
	{2406,	"'%s' : name undefined %s"},
	{2407,	"illegal float register %s"},
	{2408,	"illegal type on PTR operator %s"},
	{2409,	"illegal type used as operator %s"},
	{2410,	"'%s' : ambiguous member name %s"},
	{2411,	"'%s' : illegal struct/union member %s"},
	{2412,	"'%s' : label redefined"},
	{2413,	"'%s' : illegal align size"},
	{2414,	"illegal number of operands"},
	{2415,	"improper operand type"},
	{2416,	"'%s' : illegal opcode for processor"},
	{2417,	"divide by zero %s"},
	{2419,	"mod by zero %s"},
	{2420,	"'%s' : illegal symbol %s"},
	{2421,	"PTR operator used with register %s"},
	{2422,	"illegal segment override %s"},
	{2424,	"'%s' : improper expression %s"},
	{2425,	"'%s' : non-constant expression %s"},
	{2426,	"'%s' : illegal operator %s"},
	{2427,	"'%Fs' : jump referencing label is out of range"			/* QC */},
	{2428,	"_asm not implemented"},
	{2000,	"UNKNOWN ERROR\n\t\tPlease report this error to your local dealer"},
	/****************************************************************/
	/* Warnings							*/
	/****************************************************************/

	{4002,	"too many actual parameters for macro '%s'"},
	{4003,	"not enough actual parameters for macro '%s'"},
	{4004,	"missing close parenthesis after 'defined'"},
	{4005,	"'%s' : redefinition"},
	{4006,	"#undef expected an identifier"},
	{4009,	"string too big, trailing chars truncated"},
	{4011,	"identifier truncated to '%s'"},
	{4012,	"float constant in a cross compilation"},
	{4014,	"'%Fs' : bit-field type must be unsigned"},
	{4015,	"'%Fs' : bit-field type must be integral"},
	{4016,	"'%s' : no function return type, using 'int' as default"},
	{4017,	"cast of int expression to far pointer"},
	{4020,	"'%Fs' : too many actual parameters"},
	{4021,	"'%Fs' : too few actual parameters"},
	{4022,	"'%Fs' : pointer mismatch : parameter %d"},
	{4024,	"'%Fs' : different types : parameter %d"},
	{4026,	"function was declared with formal argument list"},
	{4027,	"function was declared without formal argument list"},
	{4028,	"parameter %d declaration different"},
	{4029,	"declared parameter list different from definition"},
	{4030,	"first parameter list is longer than the second"},
	{4031,	"second parameter list is longer than the first"},
	{4032,	"unnamed struct/union as parameter"},
	{4033,	"function must return a value"},
	{4034,	"sizeof returns 0"},
	{4035,	"'%Fs' : no return value"},
	{4037,	"'%Fs' : formal parameters ignored"},
	{4038,	"'%Fs' : formal parameter has bad storage class"},
	{4039,	"'%Fs' : function used as an argument"},
	{4040,	"near/far/huge on '%Fs' ignored"},
	{4042,	"'%Fs' : has bad storage class"},
	{4044,	"huge on '%Fs' ignored, must be an array"},
	{4045,	"'%s' : array bounds overflow"},
	{4046,	"'&' on function/array, ignored"},
	{4047,	"'%s' : different levels of indirection"},
	{4048,	"array's declared subscripts different"},
	{4049,	"'%s' : indirection to different types"},
	{4051,	"data conversion"},
	{4053,	"at least one void operand"},
	{4058,	"address of frame variable taken, DS != SS"	/* QC, c23 */},
	{4060,	"conversion of long address to short address"	/* QC, c23 */},
	{4061,	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */},
	{4062,	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */},
	{4067,	"unexpected characters following '%s' directive - newline expected"},
	{4068,	"unknown pragma"},
	{4071,	"'%Fs' : no function prototype given"},
	{4074,	"non standard extension used - '%s'"},
	{4075,	"size of switch expression or case constant too large - converted to int"},
	{4076,	"'%s' : may be used on integral types only"},
	{4077,	"unknown check_stack option"},
	{4079,	"unexpected token '%s'"},
	{4080,	"expected 'identifier' for segment name, found '%s'"},
	{4081,	"expected a comma, found '%s'"},
	{4082,	"expected an identifier, found '%s'"},
	{4083,	"expected '(', found '%s'"},
	{4084,	"expected a pragma keyword, found '%s'"},
	{4085,	"expected [on | off]"},
	{4086,	"expected [1 | 2 | 4]"},
	{4087,	"'%Fs' : declared with 'void' parameter list"},
	{4088,	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"},
	{4089,	"'%Fs' : different types : parameter %d, parameter list %d"},
	{4090,	"different 'const' attributes"},
	{4091,	"no symbols were declared"},
	{4092,	"untagged enum/struct/union declared no symbols"},
	{4093,	"unescaped newline in character constant in non-active code"},
	{4095,	"expected ')', found '%s'"},
	{4098,	"void function returning a value"},
	{4100,	"'%Fs' : unreferenced formal parameter"},
	{4101,	"'%Fs' : unreferenced local variable"},
	{4102,	"'%Fs' : unreferenced label"},
	{4104,	"'%s' : near data in same_seg pragma, ignored"},
	{4105,	"'%Fs' : code modifiers only on function or pointer to function"},
	{4106,	"pragma requires integer between 1 and 127"},
	{4107,	"pragma requires integer between 15 and 255"},
	{4108,	"pragma requires integer between 79 and 132"},
	{4109,	"unexpected identifier '%s'"},
	{4110,	"unexpected token 'int constant'"},
	{4111,	"unexpected token 'string'"},
	{4112,	"macro name '%s' is reserved, %s ignored"},
	{4113,	"function parameter lists differed"},
	{4114,	"same type qualifier used more than once"},
	{4115,	"'%Fs' : type definition in formal parameter list"},
	{4116,	"<no tag> : type definition in formal parameter list"},
	{4118,	"pragma not supported"},
	{4401,	"'%s' : member is bitfield"},
	{4402,	"must use PTR operator"},
	{4403,	"illegal PTR operator"},
	{4404,	"period on directive ignored"},
	{4405,	"'%s' : identifier is reserved word"},
	{4406,	"operand on directive ignored"},
	{4407,	"operand size conflict"},
	{4408,	"'%s' : ambiguous label"},
	{4409,	"illegal instruction size"},
	{4410,	"illegal size for operand"},
	{4411,	"'%s' : symbol resolves to displacement register"},
	{4412,	"'%s' : identifier is also assembler mnemonic"},
	{4413,	"Cannot determine file type for '%s' : assuming 8-bit ascii"},
	{4000,	"UNKNOWN WARNING\n\t\tPlease report this error to your local dealer"},
	{LASTMSG, ""}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\globals.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GLOBALS.C - Global variable definitions				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppext.h"
#include "grammar.h"

/* shared strings */
char 	Union_str[] = "union";
char 	Struct_str[] = "struct";
char 	Cdecl_str[] = "cdecl";
char 	Cdecl1_str[] = "cdecl ";
char 	Fortran_str[] = "fortran";
char 	Fortran1_str[] = "fortran ";
char 	Pascal_str[] = "pascal";
char 	Pascal1_str[] = "pascal ";
char 	PPelse_str[] = "#else";
char 	PPendif_str[] = "#endif";
char 	PPifel_str[] = "#if/#elif";
char 	Syntax_str[] = "syntax error";


FILE	*ErrFile;		/* file containing error messages */
FILE	*Errfl;			/* files errors written to */
FILE	*OUTPUTFILE;		/* File for output of program */

char	*A_string;				/* model encoding */
char	*Debug;					/* debugging switches */
char	*Input_file;			/* the input .rc file */
char	*Output_file;			/* the output .res file */
char	*Q_string;				/* hardware characteristics */
char	*Version;
char    *gpszNLSoptions;        
int		In_alloc_text;
int		Bad_pragma;
int		Cross_compile;			/* is this a cross compile ? */
int		Ehxtension;				/* near/far keywords, but no huge */
int		HugeModel;				/* Huge Model program ?? */
int		Inteltypes;				/* using strict Intel types or not */
int		Nerrors;
int		NoPasFor;				/* no fortran/pascal keywords ? */
int		Out_funcdef;			/* output function definitions */
int		Plm;					/* non-C calling sequence */
int		Prep;					/* preprocess */
int		Srclist;				/* put msgs to il file if source listing */

int		Cmd_intrinsic;			/* implicit intrinsics */
int		Cmd_loop_opt;
int		Cmd_pointer_check;

int		Symbolic_debug;			/* Whether to put out dbil info or not */
int		Cflag;					/* leave in comments */
int 	Eflag;					/* insert #line */
int		Jflag;					/* no Kanji */
int		Pflag;					/* no #line */
int		Rflag;					/* mkhives - no exponent missing error */
int		ZcFlag;					/* case insensitive compare */
int		In_define;
int		InInclude;
int		InIf;
int		Macro_depth;
int		Linenumber;

UCHAR	Reuse_1[BIG_BUFFER];
UCHAR	Filebuff[MED_BUFFER+1];
UCHAR	Macro_buffer[BIG_BUFFER * 4];

token_t	Basic_token = L_NOTOKEN;
LIST	Defs = {MAXLIST};			/* -D list */
LIST	Includes = {MAXLIST, {0}};	/* for include file names */
char	*Path_chars = "/";			/* path delimiter chars */
char	*ErrFilName = "c1.err";		/* error message file name */
char	*Basename = "";				/* base IL file name */
char	*Filename = Filebuff;
int		Char_align = 1;				/* alignment of chars in structs */
int		Cmd_stack_check = TRUE;
int		Stack_check = TRUE;
int		Prep_ifstack = -1;
int		Switch_check = TRUE;
int		Load_ds_with;
int		Plmn;
int		Plmf;
int		On_pound_line;
int		Listing_value;
hash_t	Reuse_1_hash;
UINT Reuse_1_length;
token_t	Currtok = L_NOTOKEN;

int		Extension = TRUE;			/* near/far keywords? */
int		Cmd_pack_size = 2;
int		Pack_size = 2;

lextype_t yylval;

/*** I/O Variable for PreProcessor ***/
ptext_t	Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
char 	Msg_Text[MSG_BUFF_SIZE];
char *	Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\ltoa.c ===
/* Long to ASCII conversion routine - used by print, and those programs
 * which want to do low level formatted output without hauling in a great
 * deal of extraneous code.  This will convert a long value to an ascii
 * string in any radix from 2 - 16.
 * RETURNS - the number of characters in the converted buffer.
 */

static char digits[] = {
	'0', '1', '2', '3', '4',
	'5', '6', '7', '8', '9',
	'a', 'b', 'c', 'd', 'e', 'f'
	};

#define BITS_IN_LONG  (8*sizeof(long))

int zltoa(long aval, register char *buf, int base)
	{
	/*
	 * if unsigned long wont work on your host, you will probably have
	 * to use signed long and accept this as not working for negative
	 * numbers.
	 */
	register unsigned long val;
	register char *p;
	char tbuf[BITS_IN_LONG];
	int size = 0;

	p = tbuf;
	*p++ = '\0';
	if (aval < 0 && base == 10)
		{
		*buf++ = '-';
		val = -aval;
		size++;
		}
	else
		val = aval;
	do {
		*p++ = digits[val % base];
		}
	while (val /= base);
	while ((*buf++ = *--p) != 0)
		++size;
	return(size);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\grammar.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* GRAMMAR.H - Grammar definitions for terminals			*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#define	L_NOTOKEN	1
#define	L_IDENT		2
#define	L_STRING	3
#define	L_CFLOAT	4
#define	L_CDOUBLE	5
#define	L_CLDOUBLE	6
#define	L_CINTEGER	7
#define	L_LONGINT	8
#define	L_CUNSIGNED	9
#define	L_LONGUNSIGNED	10
#define	L_AUTO		11
#define	L_STATIC	12
#define	L_EXTERN	13
#define	L_REGISTER	14
#define	L_TYPEDEF	15
#define	L_FORTRAN	16
#define	L_PASCAL	17
#define	L_C		18
#define	L_INTERRUPT	19
#define	L_SAVEREGS	20
#define	L_LOADDS	21
#define	L_EXPORT	22
#define	L_ASM		23
#define	L_NEAR		24
#define	L_FAR		25
#define	L_HUGE		26
#define	L_CONST		27
#define	L_VOLATILE	28
#define	L_CHAR		29
#define	L_INT		30
#define	L_FLOAT		31
#define	L_DOUBLE	32
#define	L_SHORT		33
#define	L_LONG		34
#define	L_VOID		35
#define	L_SIGNED	36
#define	L_UNSIGNED	37
#define	L_ENUM		38
#define	L_ENUM_TAG	39
#define	L_STRUCT	40
#define	L_STRUCT_TAG	41
#define	L_UNION		42
#define	L_UNION_TAG	43
#define	L_AND		44
#define	L_ANDAND	45
#define	L_ANDEQ		46
#define	L_ASSIGN	47
#define	L_BIT		48
#define	L_COLON		49
#define	L_COMMA		50
#define	L_DECR		51
#define	L_DIV		52
#define	L_DIVEQ		53
#define	L_EQUALS	54
#define	L_EXCLAIM	55
#define	L_EXTRACT	56
#define	L_GT		57
#define	L_GTEQ		58
#define	L_INCR		59
#define	L_LBRACK	60
#define	L_LSHFTEQ	61
#define	L_LSHIFT	62
#define	L_LT		63
#define	L_LTEQ		64
#define	L_MINUS		65
#define	L_MINUSEQ	66
#define	L_MOD		67
#define	L_MODEQ		68
#define	L_MULT		69
#define	L_MULTEQ	70
#define	L_NOTEQ		71
#define	L_OR		72
#define	L_OREQ		73
#define	L_OROR		74
#define	L_PERIOD	75
#define	L_PLUS		76
#define	L_PLUSEQ	77
#define	L_POINTSTO	78
#define	L_PREDECR	79
#define	L_PREINCR	80
#define	L_QUEST		81
#define	L_RSHFTEQ	82
#define	L_RSHIFT	83
#define	L_TILDE		84
#define	L_UMINUS	85
#define	L_XOR		86
#define	L_XOREQ		87
#define	L_ARG		88
#define	L_ASOP		89
#define	L_BREAK		90
#define	L_CASE		91
#define	L_CAST		92
#define	L_CLASS		93
#define	L_CONSTANT	94
#define	L_CONTINUE	95
#define	L_DEFAULT	96
#define	L_DIVOP		97
#define	L_DO		98
#define	L_ELLIPSIS	99
#define	L_ELSE		100
#define	L_ENTRY		101
#define	L_EOF		102
#define	L_EQUOP		103
#define	L_FILE		104
#define	L_FOR		105
#define	L_FUNCTION	106
#define	L_GOTO		107
#define	L_IF		108
#define	L_INCOP		109
#define	L_INIT		110
#define	L_LCURLY	111
#define	L_LINE		112
#define	L_LPAREN	113
#define	L_INTRINSIC	114
#define	L_MODIFIER	115
#define	L_MODULE	116
#define	L_RBRACK	117
#define	L_RCURLY	118
#define	L_RELOP		119
#define	L_RETURN	120
#define	L_RPAREN	121
#define	L_SELF		122
#define	L_SEMI		123
#define	L_SHIFTOP	124
#define	L_SIZEOF	125
#define	L_STUNOP	126
#define	L_SW		127
#define	L_SWEXP		128
#define	L_TYPE		129
#define	L_TYPENAME	130
#define	L_UPLUS		131
#define	L_WHILE		132
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\msgs.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* MAIN.C - Main Program						*/
/*									*/
/* 28-Nov-90 w-BrianM  Created to remove the need for MKMSG.EXE		*/
/*									*/
/************************************************************************/

/************************************************************************/
/****							             ****/
/**** NOTE - All changees in this file must be duplicated in GETMSG.H****/
/****							             ****/
/************************************************************************/


#define	MSG_LEFT		301
#define	MSG_RIGHT		302
#define	MSG_UC_UNNAMED		303
#define	MSG_LC_UNNAMED		304
#define	MSG_COMMA		305
#define	MSG_CAST_LVAL		306
#define	MSG_EXT_INIT		307
#define	MSG_TYPEDEF		308
#define	MSG_EXT_REDEF		309
#define	MSG_MAC_FORMALS		310
#define	MSG_NO_SEMI		311
#define	MSG_BITFIELDS		312
#define	MSG_WARN		313
#define	MSG_ERROR		314
#define	MSG_FATAL		315
#define	MSG_BLOCK_FUNCDECL	316
#define	MSG_CASTTO_FUNC		317
#define	MSG_CASTTO_NONFUNC	318
#define	MSG_ELLIPSIS		320
#define	MSG_TOLEVEL0		321
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0expr.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0EXPR.C - Expression routines for Pre-Processor			*/
/*									*/
/* AUTHOR - Ralph Ryan, Sept. 16, 1982					*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
/*
 * DESCRIPTION  
 *	Evaluate the constant expression.  Since these routines are
 *	all recursively coupled, it is clearer NOT to document them
 *	with the standard header.  Instead, BML (British Meta Language, 
 *	a BNF like meta language) will be given for each "production" 
 *	of this recursive descent parser.
 *
 * Note - Sure, yeah, right. Frankly, I'm frightened! (w-BrianM)
 ************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "grammar.h"

/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
long and(void);
long andif(void);
long constant(void);
long constexpr(void);
long eqset(void);
long mult(void);
long or(void);
long orelse(void);
long plus(void);
long prim(void);
long relation(void);
long shift(void);
long xor(void);


/************************************************************************/
/* File Global Variables						*/
/************************************************************************/
long	Currval = 0;
static	int		Parencnt = 0;


/************************************************************************/
/* do_constexpr()							*/
/************************************************************************/
long do_constexpr(void)
{
    REG long	val;

    Parencnt = 0;
    Currtok = L_NOTOKEN;
    val = constexpr();
    if( Currtok == L_RPAREN ) {
	if( Parencnt-- == 0 ) {
	    Msg_Temp = GET_MSG(1012);
	    SET_MSG (Msg_Text, Msg_Temp, "(");
	    fatal(1012);		/* missing left paren */
	}
    }
    else if( Currtok != L_NOTOKEN ) {
	Msg_Temp = GET_MSG(4067);
	SET_MSG (Msg_Text, Msg_Temp, PPifel_str);
	warning(4067);
    }
    if( Parencnt > 0 ) {
	Msg_Temp = GET_MSG(4012);
	SET_MSG (Msg_Text, Msg_Temp, ")");
	fatal(4012);	/* missing right paren */
    }
    return(val);
}

/************************************************************************/
/* constexpr ::= orelse [ '?' orelse ':' orelse ];			*/
/************************************************************************/
long constexpr(void)
{
    REG long		val;
    REG long		val1;
    long		val2;

    val = orelse();
    if( nextis(L_QUEST) ) {
	val1 = orelse();
	if( nextis(L_COLON) )
	    val2 = orelse();
	return(val ? val1 : val2);
    }
    return(val);
}


/************************************************************************/
/* orelse ::= andif [ '||' andif ]* ;					*/
/************************************************************************/
long orelse(void)
{
    REG long val;

    val = andif();
    while(nextis(L_OROR))
	val = andif() || val;
    return(val);
}


/************************************************************************/
/* andif ::= or [ '&&' or ]* ;						*/
/************************************************************************/
long	  andif(void)
{
    REG	long val;

    val = or();
    while(nextis(L_ANDAND))
	val = or() && val;
    return(val);
}


/************************************************************************/
/* or ::= xor [ '|' xor]* ;						*/
/************************************************************************/
long or(void)
{
    REG	long val;

    val = xor();
    while( nextis(L_OR) )
	val |= xor();
    return(val);
}


/************************************************************************/
/* xor ::= and [ '^' and]* ;						*/
/************************************************************************/
long	  xor(void)
{
    REG	long val;

    val = and();
    while( nextis(L_XOR) )
	val ^= and();
    return(val);
}


/************************************************************************/
/*  and ::= eqset [ '&' eqset]* ;					*/
/************************************************************************/
long and(void)
{
    REG	long val;

    val = eqset();
    while( nextis(L_AND) )
	val &= eqset();
    return(val);
}


/************************************************************************/
/* eqset ::= relation [ ('==' | '!=') eqset] ;				*/
/************************************************************************/
long eqset(void)
{
    REG	long val;

    val = relation();
    if( nextis(L_EQUALS) )
	return(val == relation());
    if( nextis(L_NOTEQ) )
	return(val != relation());
    return(val);
}

/************************************************************************/
/* relation ::= shift [ ('<' | '>' | '<=' | '>=' ) shift] ;		*/
/************************************************************************/
long relation(void)
{
    REG	long val;

    val = shift();
    if( nextis(L_LT) )
	return(val < shift());
    if( nextis(L_GT) )
	return(val > shift());
    if( nextis(L_LTEQ) )
	return(val <= shift());
    if( nextis(L_GTEQ) )
	return(val >= shift());
    return(val);
}


/************************************************************************/
/* shift ::= plus [ ('<< | '>>') plus] ;				*/
/************************************************************************/
long shift(void)
{
    REG	long val;

    val = plus();
    if( nextis(L_RSHIFT) )
	return(val >> plus());
    if( nextis(L_LSHIFT) )
	return(val << plus());
    return(val);
}


/************************************************************************/
/* plus ::= mult [ ('+' | '-') mult ]* ;				*/
/************************************************************************/
long	  plus(void)
{
    REG	long val;

    val = mult();
    for(;;) {
	if( nextis(L_PLUS) )
	    val += mult();
	else if( nextis(L_MINUS) )
	    val -= mult();
	else
	    break;
    }
    return(val);
}


/************************************************************************/
/* mult ::= prim [ ('*' | '/' | '%' ) prim ]* ;				*/
/************************************************************************/
long mult(void)
{
    REG	long val;

    val = prim();
    for(;;) {
	if( nextis(L_MULT) )
	    val *= prim();
	else if( nextis(L_DIV) )
	    val /= prim();
	else if( nextis(L_MOD) )
	    val %= prim();
	else
	    break;
    }
    return(val);
}


/************************************************************************/
/* prim ::= constant | ( '!' | '~' | '-' ) constant 			*/
/************************************************************************/
long prim(void)
{
    if( nextis(L_EXCLAIM) )
	return( ! constant());
    else if( nextis(L_TILDE) )
	return( ~ constant() );
    else if( nextis(L_MINUS) )
	return(-constant());
    else
	return(constant());
}


/************************************************************************/
/* constant - at last, a terminal symbol  | '(' constexpr ')'		*/
/************************************************************************/
long constant(void)
{
    REG	long val;

    if( nextis(L_LPAREN) ) {
	Parencnt++;
	val = constexpr();
	if( nextis(L_RPAREN) ) {
	    Parencnt--;
	    return(val);
	}
	else {
	    Msg_Temp = GET_MSG(1012);
	    SET_MSG (Msg_Text, Msg_Temp, ")");
	    fatal (1012);
	}
    }
    else if( ! nextis(L_CINTEGER) ) {
	Msg_Temp = GET_MSG(1017);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1017);	/* invalid integer constant expression */
    }
    return(Currval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0defs.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0DEFS.H - Defintions for PreProcessor parsing code			*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

struct	s_defn	{
    pdefn_t	defn_next;		/*  pointer to next ident  */
    PUCHAR	defn_ident;		/*  pointer to name */
    ptext_t	defn_text;		/*  definition substitution string  */
    char		defn_nformals;/*number of formal arguments - can be <0*/
    char		defn_expanding;	/* are we already expanding this one? */
};

#define	DEFN_IDENT(P)		((P)->defn_ident)
#define	DEFN_NAME(P)		(DEFN_IDENT(P))
#define	DEFN_NEXT(P)		((P)->defn_next)
#define	DEFN_TEXT(P)		((P)->defn_text)
#define	DEFN_NFORMALS(P)	((P)->defn_nformals)
#define	DEFN_EXPANDING(P)	((P)->defn_expanding)

#define	FILE_EOS		0x01
#define	ACTUAL_EOS		0x02
#define	DEFINITION_EOS		0x04
#define	RESCAN_EOS		0x08
#define	BACKSLASH_EOS		0x10
#define	ANY_EOS			( FILE_EOS | ACTUAL_EOS | DEFINITION_EOS\
									   | RESCAN_EOS | BACKSLASH_EOS )

/*
**	arbitrarily chosen characters that get special treatment when found
**	after EOS in handle_eos()
*/
#define	EOS_ACTUAL		'A'
#define	EOS_DEFINITION		'D'
#define	EOS_RESCAN		'R'
#define	EOS_PAD			'P'

#define	FROM_COMMAND		-2
#define	PRE_DEFINED(P)		(DEFN_NFORMALS(P) < FROM_COMMAND)

typedef struct s_expstr	{
    ptext_t	exp_string;	/* ptr to next character in stream aft macro */
    char	*exp_actuals;	/* ptr to start of actuals linked list */
    ptext_t	exp_text;	/* ptr to expanded text for this macro */
    pdefn_t	exp_macro;		/* ptr to macro defn */
    UCHAR	exp_nactuals;	/* number of actuals */
    UCHAR	exp_nactsexpanded;/* number of expanded actuals for handle_eos*/
} expansion_t;

/*
**	note that CURRENT_STRING usually points into an area in the macro
**	expansion buffer, but the first item used (Macro_depth equals 1) points
**	to text read from a file.  In some versions, the heap is reshuffled
**	and this pointer must be updated for the first item.
*/
#define CURRENT_STRING		Macro_expansion[Macro_depth].exp_string
#define CURRENT_ACTUALS		Macro_expansion[Macro_depth].exp_actuals
#define CURRENT_TEXT		Macro_expansion[Macro_depth].exp_text
#define CURRENT_MACRO		Macro_expansion[Macro_depth].exp_macro
#define CURRENT_NACTUALS	Macro_expansion[Macro_depth].exp_nactuals
#define CURRENT_NACTSEXPANDED Macro_expansion[Macro_depth].exp_nactsexpanded

/*
**	finds address after last element in an array. Used to check for
**	buffer overflows.
*/
#define	LIMIT(a)	&(a)[sizeof(a)]

#define IS_CHAR(c,uc)	(toupper(c) == (uc))
#define IS_B(c)		IS_CHAR(c, 'B')
#define IS_D(c)		IS_CHAR(c, 'D')
#define	IS_E(c)		IS_CHAR(c, 'E')
#define	IS_F(c)		IS_CHAR(c, 'F')
#define IS_H(c)		IS_CHAR(c, 'H')
#define	IS_EL(c)	IS_CHAR(c, 'L')
#define IS_O(c)		IS_CHAR(c, 'O')
#define IS_Q(c)		IS_CHAR(c, 'Q')
#define	IS_U(c)		IS_CHAR(c, 'U')
#define	IS_X(c)		IS_CHAR(c, 'X')
#define	IS_DOT(c)	(c == '.')
#define	IS_SIGN(c)	((c == '+') || (c =='-'))

#define	P0_IF		0
#define	P0_ELIF		1
#define	P0_ELSE		2
#define	P0_ENDIF	3
#define	P0_IFDEF	4
#define	P0_IFNDEF	5
#define	P0_DEFINE	6
#define	P0_INCLUDE	7
#define	P0_PRAGMA	8
#define	P0_UNDEF	9
#define	P0_LINE		10
#define	P0_NOTOKEN	11
#define	P0_ERROR	12
#define	P0_IDENT	13


#define HLN_NAME(s)	((s).hln_name)
#define HLN_HASH(s)	((s).hln_hash)
#define HLN_LENGTH(s)	((s).hln_length)
#define HLN_IDENT_HASH(p)	(HLN_HASH(*(p)))
#define HLN_IDENT_LENGTH(p)	(HLN_LENGTH(*(p)))
#define HLN_IDENTP_NAME(p)	(HLN_NAME(*(p)))
#define	HLN_TO_NAME(S)		((PUCHAR)pstrndup(HLN_IDENTP_NAME(S),HLN_IDENT_LENGTH(S)))

#define HASH_MASK	0x5f

#define LIMIT_ID_LENGTH		31
#define LIMIT_NESTED_INCLUDES	10
#define LIMIT_MACRO_DEPTH	64
#define LIMIT_STRING_LENGTH	2043
#define LEVEL_0			0xff

#define	MUST_OPEN	1
#define	MAY_OPEN	0

/*** The following are defined to use on the Token Table ***/

#define	TS_STR(idx)		(Tokstrings[idx-L_NOTOKEN].k_text)
#define	TS_VALUE(idx)	(Tokstrings[idx-L_NOTOKEN].k_token)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\hivepp.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* MAIN.C - Main Program                                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include        <windows.h>
#include        <stdlib.h>
#include        <stdio.h>
#include        <string.h>
#include        "rcpptype.h"
#include        "rcppdecl.h"
#include        "rcppext.h"
#include        "grammar.h"
#include        "getflags.h"
#ifdef DBCS
#include        "charmap.h"
#endif // DBCS

/************************************************************************/
/* Global Varialbes                                                     */
/************************************************************************/
char    *Unknown = NULL;                /* holder for bad flags */
int     Argc;
char    **Argv;

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
char    *nextword(void);
void    __cdecl main(int, char **);
void    to_human(void);
BOOL WINAPI	Handler(ULONG CtrlType);


struct  subtab  Ztab[] = {
    'a',        UNFLAG, &Extension,
    'e',        FLAG,   &Extension,
    'E',        FLAG,   &Ehxtension,
    'i',        FLAG,   &Symbolic_debug,
    'g',        FLAG,   &Out_funcdef,
    'p',        FLAG,   &Cmd_pack_size,
    'I',        FLAG,   &Inteltypes,
    'c',        FLAG,   &ZcFlag,
    0,          0,              0,
};

struct cmdtab cmdtab[] = {
    "-pc#",             (char *)&Path_chars,            1,      STRING,
    "-pf",              (char *)&NoPasFor,              1,      FLAG,
    "-C",               (char *)&Cflag,                 1,      FLAG,
    "-CP#",             (char *)&gpszNLSoptions,        1,      STRING,
    "-D#",              (char *)&Defs,                  1,      PSHSTR,
    "-E",               (char *)&Eflag,                 1,      FLAG,
    "-I#",              (char *)&Includes,              1,      PSHSTR,
    "-P",               (char *)&Pflag,                 1,      FLAG,
    "-f",               (char *)&Input_file,            1,      STRING,
    "-g",               (char *)&Output_file,           1,      STRING,
    "-J",               (char *)&Jflag,                 1,      FLAG,
    "-Zp",              (char *)&Cmd_pack_size,         1,      FLAG,
    "-Zp#",             (char *)&Cmd_pack_size,         1,      NUMBER,
    "-Z*",              (char *)Ztab,                   1,      SUBSTR,
    "-Oi",              (char *)&Cmd_intrinsic,         1,      FLAG,
    "-Ol",              (char *)&Cmd_loop_opt,          1,      FLAG,
    "-db#",             (char *)&Debug,                 1,      STRING,
    "-ef#",             (char *)&ErrFilName,            1,      STRING,
    "-il#",             (char *)&Basename,              1,      STRING,
    "-xc",              (char *)&Cross_compile,         1,      FLAG,
    "-H",               (char *)&HugeModel,             1,      FLAG,
    "-V#",              (char *)&Version,               1,      STRING,
    "-Gs",              (char *)&Cmd_stack_check,       1,      UNFLAG,
    "-Gc",              (char *)&Plm,                   1,      FLAG,
    "-char#",           (char *)&Char_align,            1,      NUMBER,
    "-A#",              (char *)&A_string,              1,      STRING,
    "-Q#",              (char *)&Q_string,              1,      STRING,
    "-Fs",              (char *)&Srclist,               1,      FLAG,
    "-R",               (char *)&Rflag,                 1,      FLAG,
    "*",                (char *)&Unknown,               0,      STRING,
    0,                  0,                                                      0,      0,
};

/************************************************************************/
/* nextword -                                                           */
/************************************************************************/
char    *nextword(void)
{
    return((--Argc > 0) ? (*++Argv) : 0);
}

#ifdef DBCS

/************************************************************************/
/* vReConfigureLeadByteInfo -                                           */
/************************************************************************/

void vReConfigureLeadByteInfo( unsigned int uiCodePage )
{
    CPINFO CPInfo;
    PUCHAR pLeadByte;
    BYTE   i;

    /* Following instruction should be success      */
    /* because CodePage should be checked by RC.exe */
    GetCPInfo( uiCodePage , &CPInfo );

    /*  Fill Charmap table with LX_LEADBYTE  */
    pLeadByte = CPInfo.LeadByte;

    while( *pLeadByte != 0 && *(pLeadByte+1) != 0 ) {
        for( i = *pLeadByte ; i <= *(pLeadByte+1) ; i++ ) {
            Charmap[i] = LX_LEADBYTE;
        }
        pLeadByte += 2;
    }
}

#ifdef HIVEPP
void vReConfigureCharTable( void )
{
    Charmap[0x40] = LX_ID;
    Charmap[0x60] = LX_ID;
}
#endif // HIVEPP

#endif // DBCS

/************************************************************************/
/* main -                                                               */
/************************************************************************/
void __cdecl main(int argc, char **argv)
{

    Argc = argc;
    Argv = argv;

    while(crack_cmd(cmdtab, nextword(), nextword, 0)) ;

#ifdef DBCS
    {
        int CodePage;

        // To modify charmap info
        if( gpszNLSoptions != NULL )
            CodePage = atoi( gpszNLSoptions );
        else
            CodePage = GetACP();
#ifdef FIREWALLS
        fprintf( stderr , "RCPP:CodePage - %s - %d \n",gpszNLSoptions , CodePage );
#endif
        vReConfigureLeadByteInfo(CodePage);
    }
#endif // DBCS 

#ifdef DBCS
#ifdef HIVEPP
        vReConfigureCharTable();
#endif // HIVEPP
#endif // DBCS

    if(Unknown) {
        Msg_Temp = GET_MSG (1007);
        SET_MSG (Msg_Text, Msg_Temp, Unknown, "c1");
        fatal(1007);    /* unknown flag */
    }

    if( ! Input_file) {
        Msg_Temp = GET_MSG (1008);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1008);            /* no input file specified */
    }

    if( ! Output_file) {
        Msg_Temp = GET_MSG (1011);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1011);            /* no input file specified */
    }

    Prep = TRUE;
    if( !Eflag && !Pflag ) {
        Eflag = TRUE;
    }

    strncpy(Filename,Input_file,128);

    SetConsoleCtrlHandler(Handler, TRUE);
    p0_init(Input_file, Output_file, &Defs);
    to_human();
    SetConsoleCtrlHandler(Handler, FALSE);

    if( Prep_ifstack >= 0 ) {
        Msg_Temp = GET_MSG (1022);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1022);            /* expected #endif */
    }

    exit(Nerrors);
}

BOOL WINAPI Handler(ULONG CtrlType)
{
    /*
    **	Unreferenced
    */
    (void)CtrlType;

    /* Close ALL files. */
    _fcloseall();

    exit(1);
    return 1;
}


/************************************************************************/
/* to_human : outputs preprocessed text in human readable form.         */
/************************************************************************/
void to_human(void)
{
    PCHAR value;
    for(;;) {
        switch(yylex()) {
        case 0:
            return;
        case L_NOTOKEN:
            break;
        default:
            if (Basic_token == 0) {
                Msg_Temp = GET_MSG(1068);
                SET_MSG(Msg_Text, Msg_Temp);
                fatal(1068);
            }
            value = Tokstrings[Basic_token - L_NOTOKEN].k_text;
            fwrite(value, strlen(value), 1, OUTPUTFILE);
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0io.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.H - Preprocessor I/O macros					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#define	MUST_OPEN	1
#define	MAY_OPEN	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0keys.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0KEYS.C - Keycode stuff						*/
/*									*/
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"

/************************************************************************/
/*  table for preprocessor id's						*/
/************************************************************************/
char	* Pkeyw_Table[] = {
#include "pkeyw.key"
};
char	Pkeyw_Index[] = {
#include        "pkeyw.ind"
};
struct	s_pkinfo	{
    token_t   	s_info;
} Pkeyw_Info[] = {
#include        "pkeyw.inf"
};


/************************************************************************/
/*  is_pkeyword : finds the token for the id if it's a preprocessor keyword.*/
/*  P0_NOTOKEN if not found.						*/
/************************************************************************/
token_t is_pkeyword(char *id)
{
    REG	char	**start;
    REG	char	**stop;
    char	*pi;

    if( (*id) < '_') {
	return(P0_NOTOKEN);
    }
    /*
	**  the indx table tells us the start of
	**  the words which begin with the first char if the id.
	**  the 'stop' is the index of the word which does not have the
	**  give char as it's first.
	**  we can start checking after the first char since, we *know* that
	**  they match (hence the additions 'id++' and (*start) + 1
	*/
    pi = &Pkeyw_Index[((*id) - '_')];
    for(start = &Pkeyw_Table[*pi++], stop = &Pkeyw_Table[*pi], id++;
        start != stop;
        start++
        ) {
	if(strcmp(*start, id) == 0) {
	    return(Pkeyw_Info[(start - &Pkeyw_Table[0])].s_info);
	}
    }
    return(P0_NOTOKEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0io.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.C - Input/Output for Preprocessor				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "rcunicod.h"


/************************************************************************/
/* Local Function Prototypes 						*/
/************************************************************************/
ptext_t esc_sequence(ptext_t, ptext_t);


#define TEXT_TYPE ptext_t

/***  ASSUME : the trailing marker byte is only 1 character. ***/

#define	PUSHBACK_BYTES	1

#define	TRAILING_BYTES	1

#define	EXTRA_BYTES		(PUSHBACK_BYTES + TRAILING_BYTES)
/*
**  here are some defines for the new handling of io buffers.
**  the buffer itself is 6k plus some extra bytes.
**  the main source file uses all 6k.
**  the first level of include files will use 4k starting 2k from the beginning.
**  the 2nd level - n level will use 2k starting 4k from the beginning.
**  this implies that some special handling may be necessary when we get
**  overlapping buffers. (unless the source file itself is < 2k
**  all the include files are < 2k and they do not nest more than 2 deep.)
**  first, the source file is read into the buffer (6k at a time).
**  at the first include file, (if the source from the parent file
**  is more than 2k chars) . . .
**		if the Current_char ptr is not pointing above the 2k boundary
**		(which is the beginning of the buffer for the include file)
**		then we pretend we've read in only 2k into the buffer and
**		place the terminator at the end of the parents 2k buffer.
**		else we pretend we've used up all chars in the parents buffer
**		so the next read for the parent will be the terminator, and
**		the buffer will get filled in the usual manner.
**  (if we're in a macro, the picture is slightly different in that we have
**  to update the 'real' source file pointer in the macro structure.)
**
**  the first nested include file is handled in a similar manner. (except
**  it starts up 4k away from the start.)
**
**  any further nesting will keep overlaying the upper 2k part.
*/
#define	ONE_K		(1024)
#define	TWO_K		(ONE_K * 2)
#define	FOUR_K		(ONE_K * 4)
#define	SIX_K		(ONE_K * 6)
#define	IO_BLOCK	(TWO_K + EXTRA_BYTES)

int vfCurrFileType = DFT_FILE_IS_UNKNOWN;   //- Added for 16-bit file support.

char    InputBuffer[IO_BLOCK * 3];

//- Added to input 16-bit files. 8-2-91 David Marsyla.
WCHAR   wchInputBuffer[IO_BLOCK * 3];

extern expansion_t Macro_expansion[];

typedef struct  s_filelist  filelist_t;
static struct s_filelist {   /* list of input files (nested) */
    int         fl_bufsiz;/* bytes to read into the buffer */
    FILE *      fl_file;            /* FILE id */
    long        fl_lineno;  /* line number when file was pushed */
    PUCHAR  fl_name;            /* previous file text name */
    ptext_t fl_currc;   /* ptr into our buffer for current c */
    TEXT_TYPE   fl_buffer;          /* type of buffer */
    WCHAR   *fl_pwchBuffer; //- Added for 16-bit file support.
    //- pointer to identical wide char buffer.
    int     fl_numread;  /* # of bytes read into buffer */
    int     fl_fFileType;   //- Added for 16-bit file support.
    //- return from DetermineFileType.
    long    fl_totalread;
} Fstack[LIMIT_NESTED_INCLUDES];

static  FILE *Fp = NULL;
int     Findex = -1;


/************************************************************************
 * NEWINPUT - A new input file is to be opened, saving the old.
 *
 * ARGUMENTS
 *	char *newname - the name of the file
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *	- causes input stream to be switched
 *	- Linenumber is reset to 1
 *	- storage is allocated for the newname
 *	- Filename is set to the new name
 *
 * DESCRIPTION
 *	The file is opened, and if successful, the current input stream is saved
 *	and the stream is switched to the new file. If the newname is NULL,
 *	then stdin is taken as the new input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int newinput (char *newname, int m_open)
{
    filelist_t *pF;
    TEXT_TYPE   p;
    WCHAR   *pwch;

    if ( newname == NULL ) {
        Fp = stdin;
    } else if ((Fp = fopen(newname, "rb")) == NULL) {
        if (m_open == MUST_OPEN) {
            Msg_Temp = GET_MSG (1013);
            SET_MSG (Msg_Text, Msg_Temp, newname);
            fatal(1013);
        }
        return (FALSE);
    }

    /* now push it onto the file stack */
    ++Findex;
    if (Findex >= LIMIT_NESTED_INCLUDES) {
        Msg_Temp = GET_MSG (1014);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal(1014);
    }
    pF = &Fstack[Findex];
    if (Findex == 0) {
        p = &InputBuffer[(IO_BLOCK * 0) + PUSHBACK_BYTES];
        pwch = &wchInputBuffer[(IO_BLOCK * 0) + PUSHBACK_BYTES];
        pF->fl_bufsiz = SIX_K;
    } else {
        filelist_t  *pPrevF;

        pPrevF = pF - 1;
        if (Findex == 1) {           /* first level include */
            p = &InputBuffer[(IO_BLOCK * 1) + PUSHBACK_BYTES];
            pwch = &wchInputBuffer[(IO_BLOCK * 1) + PUSHBACK_BYTES];
            pF->fl_bufsiz = FOUR_K;
        } else {      /* (Findex > 1) */
            /* nested includes . . . */
            p = &InputBuffer[(IO_BLOCK * 2) + PUSHBACK_BYTES];
            pwch = &wchInputBuffer[(IO_BLOCK * 2) + PUSHBACK_BYTES];
            pF->fl_bufsiz = TWO_K;
        }
        if ((pPrevF->fl_numread > TWO_K) || (Findex > 2)) {
            /*
            **  the parent file has read something into the upper section
            **  or this is a nested include at least 3 deep.
            **  the child will overwrite some parent info. we must take this
            **  into account for the parent to reread when the time comes.
            **  we also must stick in the eos char into the parents buffer.
            **  (this latter is the useless thing in deeply nested
            **  includes since we overwrite the thing we just put in. we'll
            **  handle this later when we fpop the child.)
            */
            TEXT_TYPE   pCurrC;
            long        seek_posn;

            seek_posn = pPrevF->fl_totalread;
            if ( Macro_depth != 0 ) {
                /*
                **  in a macro, the 'current char' we want is kept as the
                **  first thing in the macro structure.
                */
                pCurrC = (TEXT_TYPE)Macro_expansion[1].exp_string;
            } else {
                pCurrC = (TEXT_TYPE)Current_char;
            }
            if (pCurrC >= p) {
                /*
                **  p is the start of the child section.
                **  current char is past it. ie, we've already read some
                **  from the upper section.
                **  current char - p = # of characters used in upper section.
                **  numread = 0 implies there are no chars left from the parent.
                **  since, this is really the 'end' of the parent's buffer,
                **  we'll have to update the info so that the next read from the
                **  parent (after the child is finished) will be the terminator
                **  and we want the io_eob handler to refill the buffer.
                **  we reset the parent's cur char ptr to the beginning of its
                **  buffer, and put the terminator there.
                */
                seek_posn += (long)(pCurrC - pPrevF->fl_buffer);
                pPrevF->fl_totalread += (long)(pCurrC - pPrevF->fl_buffer);
                pPrevF->fl_numread = 0;
                if ( Macro_depth != 0 ) {
                    Macro_expansion[1].exp_string = pPrevF->fl_buffer;
                } else {
                    Current_char = pPrevF->fl_buffer;
                }
                *(pPrevF->fl_buffer) = EOS_CHAR;
                *(pPrevF->fl_pwchBuffer) = EOS_CHAR;
            } else {
                /*
                **  the upper section has not been read from yet,
                **  but it has been read into.
                **  'p' is pointing to the start of the child's buffer.
                **  we add the terminator to the new end of the parent's buffer.
                */
                seek_posn += TWO_K;
                pPrevF->fl_numread = TWO_K;
                *(pPrevF->fl_buffer + TWO_K) = EOS_CHAR;
                *(pPrevF->fl_pwchBuffer + TWO_K) = EOS_CHAR;
            }

            if (pPrevF->fl_fFileType == DFT_FILE_IS_8_BIT) {
                if (fseek(pPrevF->fl_file, seek_posn, SEEK_SET) == -1)
                    return FALSE;
            } else {
                if (fseek(pPrevF->fl_file, seek_posn * sizeof (WCHAR), SEEK_SET) == -1)
                    return FALSE;
            }
        }
    }
    pF->fl_currc = Current_char;/*  previous file's current char */
    pF->fl_lineno = Linenumber; /*  previous file's line number  */
    pF->fl_file = Fp;           /*  the new file descriptor  */
    pF->fl_buffer = p;
    pF->fl_pwchBuffer = pwch;
    pF->fl_numread = 0;
    pF->fl_totalread = 0;

    //- Added to support 16-bit files.
    //- 8-2-91 David Marsyla.
    pF->fl_fFileType = DetermineFileType (Fp);

    //- The file type is unknown, warn them and then take a stab at an
    //- 8-bit file.  8-2-91 David Marsyla.
    if (pF->fl_fFileType == DFT_FILE_IS_UNKNOWN) {
        Msg_Temp = GET_MSG (4413);
        SET_MSG (Msg_Text, Msg_Temp, newname);
        warning (4413);
        pF->fl_fFileType = DFT_FILE_IS_8_BIT;
    }

    vfCurrFileType = pF->fl_fFileType;

    Current_char = (ptext_t)p;
    io_eob();                   /*  fill the buffer  */
    /*
    * Note that include filenames will live the entire compiland. This
    * puts the burden on the user with MANY include files.  Any other
    * scheme takes space out of static data.
    * Notice also, that we save the previous filename in the new file's
    * fl_name.
    */
    pF->fl_name = pstrdup(Filename);
    strncpy(Filebuff,newname,sizeof(Filebuff));
    Linenumber = 0; /*  do_newline() will increment to the first line */
    if (Eflag) {
        emit_line();
        fwrite("\n", 1, 1, OUTPUTFILE);     /* this line is inserted */
    }
    do_newline();   /*  a new file may have preproc cmd as first line  */
    return (TRUE);
}


/************************************************************************
 * FPOP - pop to a previous level of input stream
 *
 * ARGUMENTS - none
 *
 * RETURNS
 *	TRUE if successful, FALSE if the stack is empty
 *
 * SIDE EFFECTS
 *	- Linenumber is restored to the old files line number
 *	- Filename is reset to the old filename
 *  - frees storage allocated for filename
 *
 * DESCRIPTION
 *	Pop the top of the file stack, restoring the previous input stream.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
UCHAR fpop(void)
{
    int Old_line;

    if (Findex == -1) {      /* no files left */
        return (FALSE);
    }
    fclose(Fp);

    strappend(Filebuff,Fstack[Findex].fl_name);
    Old_line = Linenumber;
    Linenumber = (int)Fstack[Findex].fl_lineno;
    Current_char = Fstack[Findex].fl_currc;
    if (--Findex < 0) {          /* popped the last file */
        Linenumber = Old_line;
        return (FALSE);
    }
    Fp = Fstack[Findex].fl_file;
    vfCurrFileType = Fstack[Findex].fl_fFileType;
    if (Findex >= 2) {           /* popped off a deeply nested include */
        io_eob();
    }
    if (Eflag) {
        emit_line();
    }
    return (TRUE);
}


/************************************************************************
**  nested_include : searches the parentage list of the currently
**		open files on the stack when a new include file is found.
**		Input : ptr to include file name.
**		Output : TRUE if the file was found, FALSE if not.
*************************************************************************/
int nested_include(void)
{
    PUCHAR  p_tmp1;
    PUCHAR  p_file;
    PUCHAR  p_slash;
    int         tos;

    tos = Findex;
    p_file = Filename;      /* always start with the current file */
    for (;;) {
        p_tmp1 = p_file;
        p_slash = NULL;
        while (*p_tmp1) {    /* pt to end of filename, find trailing slash */
            if (CHARMAP(*p_tmp1) == LX_LEADBYTE) {
                p_tmp1++;
            } else if (strchr(Path_chars, *p_tmp1)) {
                p_slash = p_tmp1;
            }
            p_tmp1++;
        }
        if (p_slash) {
            p_tmp1 = Reuse_1;
            while (p_file <= p_slash) {  /*  we want the trailing '/'  */
                *p_tmp1++ = *p_file++;  /*  copy the parent directory  */
            }
            p_file = yylval.yy_string.str_ptr;
            while ((*p_tmp1++ = *p_file++)!=0) {  /*append include file name  */
                ;   /*  NULL  */
            }
        } else {
            SET_MSG(Reuse_1,"%s",yylval.yy_string.str_ptr);
        }
        if (newinput(Reuse_1,MAY_OPEN)) {
            return (TRUE);
        }
        if (tos <= 0) {
            break;
        }
        p_file = Fstack[tos--].fl_name;
    }
    return (FALSE);
}


/************************************************************************/
/* esc_sequence()							*/
/************************************************************************/
ptext_t esc_sequence(ptext_t dest, ptext_t name)
{
    *dest = '"';
    while ((*++dest = *name) != 0) {
        switch ( CHARMAP(*name) ) {
            case LX_EOS:
                *++dest = '\\';
                break;
            case LX_LEADBYTE:
                *++dest = *++name;
                break;
        }
        name++;
    }
    *dest++ = '"';      /* overwrite null */
    return ( dest );
}


/************************************************************************/
/* emit_line()								*/
/************************************************************************/
void   emit_line(void)
{
    char linebuf[16];
    ptext_t p;

    SET_MSG(linebuf, "#line %d ", Linenumber+1);
    fwrite(linebuf, strlen(linebuf), 1, OUTPUTFILE);
    p = esc_sequence(Reuse_1, Filename);
    fwrite(Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
}

//-
//- wchCheckWideChar - This functions was added to support 16-bit input files.
//-     It is the equivalent of CHECKCH() but it locates the current position
//-     in the wide character buffer and then returns the stored character.
//-	8-2-91 David Marsyla.
//-

unsigned short wchCheckWideChar (void)
{
    WCHAR   *pwch;
    TEXT_TYPE   p;

    //- Get pointers to both buffers.
    pwch = Fstack[Findex].fl_pwchBuffer;
    p = Fstack[Findex].fl_buffer;

    //- Find the equivalent offset from the beginning of the pwch buffer.

    pwch += (Current_char - (ptext_t)p);

    return (*pwch);
}

/************************************************************************
**  io_eob : handle getting the next block from a file.
**  return TRUE if this is the real end of the buffer, FALSE if we have
**  more to do.
************************************************************************/
int io_eob(void)
{
    int     n;
    TEXT_TYPE   p;
    WCHAR   *pwch;

    p = Fstack[Findex].fl_buffer;
    pwch = Fstack[Findex].fl_pwchBuffer;
    if ((Current_char - (ptext_t)p) < Fstack[Findex].fl_numread) {
        /*
        **  haven't used all the chars from the buffer yet.
        **  (some clown has a null/cntl z embedded in his source file.)
        */
        if (PREVCH() == CONTROL_Z) { /* imbedded control z, real eof */
            UNGETCH();
            return (TRUE);
        }
        return (FALSE);
    }
    Current_char = p;

    //-
    //- The following section was added to support 16-bit resource files.
    //- It will just convert them to 8-bit files that the Resource Compiler
    //- can read.  Here is the basic strategy used.  An 8-bit file is
    //- read into the normal buffer and should be processed the old way.
    //- A 16-bit file is read into a wide character buffer identical to the
    //- normal 8-bit one.  The entire contents are then copied to the 8-bit
    //- buffer and processed normally.  The one exception to this is when
    //- a string literal is encountered.  We then return to the 16-bit buffer
    //- to read the characters.  These characters are written as backslashed
    //- escape characters inside an 8-bit string.  (ex. "\x004c\x523f").
    //- I'll be the first person to admit that this is an ugly solution, but
    //- hey, we're Microsoft :-).  8-2-91 David Marsyla.
    //-
    if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {

        n = fread (p, sizeof (char), Fstack[Findex].fl_bufsiz, Fp);

    } else {

        n = fread (pwch, sizeof (WCHAR), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- If the file is in reversed format, swap the bytes.
        //-
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_16_BIT_REV && n > 0) {
            WCHAR  *pwchT = pwch;
            BYTE  jLowNibble;
            BYTE  jHighNibble;
            INT   cNumWords = n;

            while (cNumWords--) {
                jLowNibble = (BYTE)(*pwchT & 0xFF);
                jHighNibble = (BYTE)((*pwchT >> 8) & 0xFF);

                *pwchT++ = (WCHAR)(jHighNibble | (jLowNibble << 8));
            }
        }


        //-
        //- The following block will copy the 16-bit buffer to the 8-bit
        //- buffer.  It does this by truncating the 16-bit character.  This
        //- will cause information loss but we will keep the 16-bit buffer
        //- around for when we need to look at any string literals.
        //-
        if (n > 0) {
            char   *pchT = p;
            WCHAR  *pwchT = pwch;
            INT    cNumWords = n;

            while (cNumWords--) {

                *pchT++ = (char)*pwchT++;
            }
        }
    }

    /*
    **  the total read counts the total read *and* used.
    */
    Fstack[Findex].fl_totalread += Fstack[Findex].fl_numread;
    Fstack[Findex].fl_numread = n;
    if (n != 0) {               /* we read something */
        *(p + n) = EOS_CHAR;    /* sentinal at the end */
        *(pwch + n) = EOS_CHAR; /* sentinal at the end */
        return (FALSE);          /* more to do */
    }
    *p = EOS_CHAR;              /* read no chars */
    *pwch = EOS_CHAR;               /* read no chars */
    return (TRUE);               /* real end of buffer */
}


/************************************************************************
**  p0_init : inits for prepocessing.
**		Input : ptr to file name to use as input.
**			ptr to LIST containing predefined values.
**					 ( -D's from cmd line )
**
**  Note : if "newinput" cannot open the file,
**		  it gives a fatal msg and exits.
**
************************************************************************/
void p0_init(char *p_fname, char *p_outname, LIST *p_defns)
{
    REG char    *p_dstr;
    REG char    *p_eq;
    int     ntop;

    CHARMAP(LX_FORMALMARK) = LX_MACFORMAL;
    CHARMAP(LX_FORMALSTR) = LX_STRFORMAL;
    CHARMAP(LX_FORMALCHAR) = LX_CHARFORMAL;
    CHARMAP(LX_NOEXPANDMARK) = LX_NOEXPAND;
    if (EXTENSION) {
        /*
        **	'$' is an identifier character under extensions.
        */
        CHARMAP('$') = LX_ID;
        CONTMAP('$') = LXC_ID;
    }

    for (ntop = p_defns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_defns->li_defns[ntop];
        p_eq = Reuse_1;
        while ((*p_eq = *p_dstr++) != 0) {  /* copy the name to Reuse_1 */
            if (CHARMAP(*p_eq) == LX_LEADBYTE) {
                *++p_eq = *p_dstr++;
            } else if (*p_eq == '=') { /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if (*p_eq == '=') {
            char    *p_tmp;
            char    *last_space = NULL;

            *p_eq = '\0';       /* null the = */
            for (p_tmp = p_dstr; *p_tmp; p_tmp++) {  /* find the end of it */
                if (CHARMAP(*p_tmp) == LX_LEADBYTE) {
                    p_tmp++;
                    last_space = NULL;
                } else if (isspace(*p_tmp)) {
                    if (last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if (last_space != NULL) {
                *last_space = '\0';
            }
            Reuse_1_hash = local_c_hash(Reuse_1);
            Reuse_1_length = strlen(Reuse_1) + 1;
            if ( *p_dstr ) { /* non-empty string */
                definstall(p_dstr, (strlen(p_dstr) + 2), FROM_COMMAND);
            } else {
                definstall((char *)0, 0, 0);
            }
        } else {
            Reuse_1_hash = local_c_hash(Reuse_1);
            Reuse_1_length = strlen(Reuse_1) + 1;
            definstall("1\000", 3, FROM_COMMAND);   /* value of string is 1 */
        }
    }

    if ((OUTPUTFILE = fopen (p_outname, "w+")) == NULL) {
        Msg_Temp = GET_MSG (1023);
        SET_MSG (Msg_Text, Msg_Temp);
        fatal (1023);
    }

    newinput(p_fname,MUST_OPEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0gettok.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0GETTOK.C - Tokenization routines					*/
/*									*/
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "grammar.h"
#include "p0defs.h"
#include "charmap.h"

/************************************************************************
**	MAP_TOKEN : a token has two representations and additional information.
**	(ex : const, has basic token of L_CONST,
**				mapped token of [L_TYPE | L_MODIFIER]
**				and info based on what the map token is)
**	MAP_AND_FILL : has two representations, but none of the extra info.
**	(ex : '<', has basic of L_LT, and map of L_RELOP)
**  NOMAP_TOKEN : has 1 representation and additional info.
**	(ex: a string, basic and 'map' type L_STRING and ptrs to the actual str)
**	NOMAP_AND_FILL : has 1 representation and no additional info.
**	(ex : 'while', has basic and 'map' of L_WHILE)
**  the FILL versions fill the token with the basic token type.
************************************************************************/
#define	MAP_TOKEN(otok)\
	(Basic_token = (otok), TS_VALUE(Basic_token))
#define	MAP_AND_FILL(otok)\
	(yylval.yy_token = Basic_token = (otok), TS_VALUE(Basic_token))
#define	NOMAP_TOKEN(otok)\
	(Basic_token = (otok))
#define	NOMAP_AND_FILL(otok)\
	(yylval.yy_token = Basic_token = (otok))



/************************************************************************/
/* yylex - main tokenization routine					*/
/************************************************************************/

token_t yylex(void)
{
    REG	UCHAR		last_mapped;
    UCHAR		mapped_c;
    REG	token_t		lex_token;

    for(;;) {
	last_mapped = mapped_c = CHARMAP(GETCH());
first_switch:
	switch(mapped_c) {
	case LX_EACH:
	case LX_ASCII:
	    Msg_Temp = GET_MSG(2018);
	    SET_MSG (Msg_Text, Msg_Temp, PREVCH());
	    error(2018);
	    continue;
	    break;
	case LX_OBRACE:
	    return(NOMAP_AND_FILL(L_LCURLY));
	    break;
	case LX_CBRACE:
	    return(NOMAP_AND_FILL(L_RCURLY));
	    break;
	case LX_OBRACK:
	    return(NOMAP_AND_FILL(L_LBRACK));
	    break;
	case LX_CBRACK:
	    return(NOMAP_AND_FILL(L_RBRACK));
	    break;
	case LX_OPAREN:
	    return(NOMAP_AND_FILL(L_LPAREN));
	    break;
	case LX_CPAREN:
	    return(NOMAP_AND_FILL(L_RPAREN));
	    break;
	case LX_COMMA:
	    return(NOMAP_AND_FILL(L_COMMA));
	    break;
	case LX_QUEST:
	    return(NOMAP_AND_FILL(L_QUEST));
	    break;
	case LX_SEMI:
	    return(NOMAP_AND_FILL(L_SEMI));
	    break;
	case LX_TILDE:
	    return(NOMAP_AND_FILL(L_TILDE));
	    break;
	case LX_NUMBER:
	    return(MAP_TOKEN(getnum(PREVCH())));
	    break;


	case LX_MINUS:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_MINUSEQ));
		break;
	    case LX_GT:
		return(MAP_AND_FILL(L_POINTSTO));
		break;
	    case LX_MINUS:
		return(MAP_AND_FILL(L_DECR));
		break;
	    default:
		lex_token = L_MINUS;
		break;
	    }
	    break;
	case LX_PLUS:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_PLUSEQ));
		break;
	    case LX_PLUS:
		return(MAP_AND_FILL(L_INCR));
		break;
	    default:
		lex_token = L_PLUS;
		break;
	    }
	    break;
	case LX_AND:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_ANDEQ));
		break;
	    case LX_AND:
		return(MAP_AND_FILL(L_ANDAND));
		break;
	    default:
		lex_token = L_AND;
		break;
	    }
	    break;
	case LX_OR:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_OREQ));
		break;
	    case LX_OR:
		return(MAP_AND_FILL(L_OROR));
		break;
	    default:
		lex_token = L_OR;
		break;
	    }
	    break;
	case LX_COLON:
	    return(NOMAP_AND_FILL(L_COLON));
	    break;
	case LX_HAT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_XOREQ));
	    }
	    lex_token = L_XOR;
	    break;
	case LX_PERCENT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_MODEQ));
	    }
	    lex_token = L_MOD;
	    break;
	case LX_EQ:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_EQUALS));
	    }
	    lex_token = L_ASSIGN;
	    break;
	case LX_BANG:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_NOTEQ));
	    }
	    lex_token = L_EXCLAIM;
	    break;
	case LX_SLASH:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_STAR:
		dump_comment();
		continue;
		break;
	    case LX_SLASH:
		DumpSlashComment();
		continue;
		break;
	    case LX_EQ:
		return(MAP_AND_FILL(L_DIVEQ));
		break;
	    default:
		lex_token = L_DIV;
		break;
	    }
	    break;
	case LX_STAR:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_SLASH:
		if( ! Prep ) {
		    Msg_Temp = GET_MSG(2138);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2138); /* (nested comments) */
		}
		else {
		    fwrite("*/", 2, 1, OUTPUTFILE);
		}
		continue;
	    case LX_EQ:
		return(MAP_AND_FILL(L_MULTEQ));
		break;
	    default:
		lex_token = L_MULT;
		break;
	    }
	    break;
	case LX_LT:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_LT:
		if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		    return(MAP_AND_FILL(L_LSHFTEQ));
		}
		mapped_c = LX_LSHIFT;
		lex_token = L_LSHIFT;
		break;
	    case LX_EQ:
		return(MAP_AND_FILL(L_LTEQ));
		break;
	    default:
		lex_token = L_LT;
		break;
	    }
	    break;
	case LX_LSHIFT:
	    /*
			**  if the next char is not an =, then we unget and return,
			**  since the only way in here is if we broke on the char
			**  following '<<'. since we'll have already worked the handle_eos()
			**  code prior to getting here, we'll not see another eos,
			**  UNLESS i/o buffering is char by char. ???
			**  see also, LX_RSHIFT
			*/
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_LSHFTEQ));
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_LSHIFT));
	    break;
	case LX_GT:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_EQ:
		return(MAP_AND_FILL(L_GTEQ));
	    case LX_GT:
		if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		    return(MAP_AND_FILL(L_RSHFTEQ));
		}
		mapped_c = LX_RSHIFT;
		lex_token = L_RSHIFT;
		break;
	    default:
		lex_token = L_GT;
		break;
	    }
	    break;
	case LX_RSHIFT:
	    if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
		return(MAP_AND_FILL(L_RSHFTEQ));
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_RSHIFT));
	    break;
	case LX_POUND:
	    if( ! Prep ) {
		Msg_Temp = GET_MSG(2014);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2014);/* # sign must be first non-whitespace */
		UNGETCH();		/* replace it */
		Linenumber--;	/* do_newline counts a newline */
		do_newline();	/* may be a 'real' prepro line */
	    }
	    else {
		fwrite("#", 1, 1, OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_EOS:
	    if(PREVCH() == '\\') {
		if( ! Prep ) {
		    if( ! checknl()) {	/* ignore the new line */
			Msg_Temp = GET_MSG(2017);
			SET_MSG (Msg_Text, Msg_Temp);
			error(2017);/* illegal escape sequence */
		    }
		}
		else {
		    fputc('\\', OUTPUTFILE);
		    fputc(get_non_eof(), OUTPUTFILE);
		}
		continue;
	    }
	    if(Macro_depth == 0) {
		if( ! io_eob()) {	/* not the end of the buffer */
		    continue;
		}
		if(fpop()) {		/* have more files to read */
		    continue;
		}
		return(MAP_AND_FILL(L_EOF));	/* all gone . . . */
	    }
	    handle_eos();			/* found end of macro */
	    continue;
	    break;
	case LX_DQUOTE:
	    if( ! Prep ) {
		str_const();
		return(NOMAP_TOKEN(L_STRING));
	    }
	    prep_string('\"');
	    continue;
	    break;
	case LX_SQUOTE:
	    if( ! Prep ) {
		return(MAP_TOKEN(char_const()));
	    }
	    prep_string('\'');
	    continue;
	    break;
	case LX_CR:		/*  ??? check for nl next  */
	    continue;
	    break;
	case LX_NL:
	    if(On_pound_line) {
		UNGETCH();
		return(NOMAP_TOKEN(L_NOTOKEN));
	    }
	    if(Prep) {
		fputc('\n', OUTPUTFILE);
	    }
	    do_newline();
	    continue;
	    break;
	case LX_WHITE:		/* skip all white space */
	    if( ! Prep ) {	/* check only once */
		do {
		    ;
		} while(LXC_IS_WHITE(GETCH()));
	    }
	    else {
		UCHAR	c;

		c = PREVCH();
		do {
		    fputc(c, OUTPUTFILE);
		} while(LXC_IS_WHITE(c = GETCH()));
	    }
	    UNGETCH();
	    continue;
	    break;
	    /* Note:
                 * RCPP.EXE does not support DBCS code.
                 * Therefore, we should be displaied error message.
                 * IBM-J PTR 12JP-0092
                 * MSHQ  PTR xxxxx
	                     */
	case LX_LEADBYTE:
	    if( ! Prep ) {       /* check only once */
		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, PREVCH());
		error(2018);

		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, GETCH());
		error(2018);
	    }
	    else {
		fputc(PREVCH(), OUTPUTFILE);
#ifdef DBCS // token_t yylex(void)
		fputc(get_non_eof(), OUTPUTFILE);
#else
		fputc(GETCH(), OUTPUTFILE);
#endif // DBCS
	    }
	    continue;
	    break;
	case LX_ILL:
	    if( ! Prep ) {
		Msg_Temp = GET_MSG(2018);
		SET_MSG (Msg_Text, Msg_Temp, PREVCH());
		error(2018);/* unknown character */
	    } else {
		fputc(PREVCH(), OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_BACKSLASH:
	    if( ! Prep ) {
		if( ! checknl()) {	/* ignore the new line */
		    Msg_Temp = GET_MSG(2017);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2017);/* illegal escape sequence */
		}
	    }
	    else {
		fputc('\\', OUTPUTFILE);
		fputc(get_non_eof(), OUTPUTFILE);
	    }
	    continue;
	    break;
	case LX_DOT:
dot_switch:
	    switch(last_mapped = CHARMAP(GETCH())) {
	    case LX_BACKSLASH:
		if(checknl()) {
		    goto dot_switch;
		}
		UNGETCH();
		break;
	    case LX_EOS:
		if(handle_eos() == BACKSLASH_EOS) {
		    break;
		}
		goto dot_switch;
		break;
	    case LX_DOT:
		if( ! checkop('.') ) {
		    Msg_Temp = GET_MSG(2142);
		    SET_MSG (Msg_Text, Msg_Temp);
		    error(2142);/* ellipsis requires three '.'s */
		}
		return(NOMAP_AND_FILL(L_ELLIPSIS));
		break;
	    case LX_NUMBER:
		/*
		**	don't worry about getting correct hash value.
		**	The text equivalent of a real number is never
		**	hashed
		*/
		Reuse_1[0] = '.';
		Reuse_1[1] = PREVCH();
		return(MAP_TOKEN(get_real(&Reuse_1[2])));
		break;
	    }
	    UNGETCH();
	    return(MAP_AND_FILL(L_PERIOD));
	    break;
	case LX_NOEXPAND:
	    SKIPCH();			/* just skip length */
	    continue;
	case LX_ID:
	    {
		pdefn_t	pdef;

		if(Macro_depth > 0) {
		    if( ! lex_getid(PREVCH())) {
			goto avoid_expand;
		    }
		}
		else {
		    getid(PREVCH());
		}

		if( ((pdef = get_defined()) != 0)
		    &&
		    ( ! DEFN_EXPANDING(pdef))
		    &&
		    ( can_expand(pdef))
		    ) {
		    continue;
		}

avoid_expand:
		if( ! Prep ) {
		    /* M00BUG get near copy of identifier???? */
		    HLN_NAME(yylval.yy_ident) = Reuse_1;
		    HLN_HASH(yylval.yy_ident) = Reuse_1_hash;
		    HLN_LENGTH(yylval.yy_ident) = (UCHAR)Reuse_1_length;
		    return(L_IDENT);
		}
		else {
		    fwrite(Reuse_1, Reuse_1_length - 1, 1, OUTPUTFILE);
		    return(NOMAP_TOKEN(L_NOTOKEN));
		}
	    }
	    continue;
	    break;
	}
	/*
	**  all the multichar ( -> -- -= etc ) operands
	**  must come through here. we've gotten the next char,
	**  and not matched one of the possiblities, but we have to check
	**  for the end of the buffer character and act accordingly
	**  if it is the eob, then we handle it and go back for another try.
	**  otherwise, we unget the char we got, and return the base token.
	*/
	if(last_mapped == LX_EOS) {
	    if(handle_eos() != BACKSLASH_EOS) {
		goto first_switch;
	    }
	}
	UNGETCH();	/* cause we got an extra one to check */
	return(MAP_AND_FILL(lex_token));
    }
}


/************************************************************************
**
**	lex_getid: reads an identifier for the main lexer.  The
**		identifier is read into Reuse_1. This function should not handle
**		an end of string if it is rescanning a macro expansion, because
**		this could switch the context with regards to whether the macro
**	      is expandable or not.  Similarly, the noexpand marker must only be
**	     allowed if a macro is being rescanned, otherwise let this character
**		be caught as an illegal character in text
************************************************************************/
int lex_getid(UCHAR c)
{
    REG	UCHAR	*p;
    int		length = 0;

    p = Reuse_1;
    *p++ = c;
    c &= HASH_MASK;
    for(;;) {
	while(LXC_IS_IDENT(*p = GETCH())) { /* collect character */
	    c += (*p & HASH_MASK);			/* hash it */
	    p++;
	}
	if(CHARMAP(*p) == LX_NOEXPAND ) {
	    length = (int)GETCH();
	    continue;
	}
	UNGETCH();
	break;				/* out of for loop  -  only way out */
    }
    if(p >= LIMIT(Reuse_1)) {	/* is this error # correct? */
	Msg_Temp = GET_MSG(1067);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1067);
    }
    if(((p - Reuse_1) > LIMIT_ID_LENGTH) && ( ! Prep )) {
	p = Reuse_1 + LIMIT_ID_LENGTH;
	*p = '\0';
	c = local_c_hash(Reuse_1);
	Msg_Temp = GET_MSG(4011);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4011);	/* id truncated */
    }
    else {
	*p = '\0';		/* terminates identifier for expandable check */
    }
    Reuse_1_hash = c;
    Reuse_1_length = (UCHAR)((p - Reuse_1) + 1);
    return(length != (p - Reuse_1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0macros.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0MACROS.C - Preprocessor Macros definitions				*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"


/************************************************************************
**
**	WARNING:	gather_chars() depends ELIMIT being the boundary of
**		Macro_buffer.
************************************************************************/
#define	ACT_BUFFER		&Macro_buffer[0]
#define	EXP_BUFFER		&Macro_buffer[BIG_BUFFER * 2]
#define	EXP_PAD			5
#define ALIMIT			&Macro_buffer[BIG_BUFFER * 2]
#define ELIMIT			(&Macro_buffer[BIG_BUFFER * 4] - EXP_PAD)


/************************************************************************
**  actual argument lists are length preceeded strings which are copied
**  into ACT_BUFFER. the first argument is pt'd to by exp_actuals in the
**  expansion_t construct. the next actual is obtained by adding the length
**  of the current actual to the start of the current actual.
************************************************************************/
#define ACTUAL_SIZE(P)	(*(short *)(P))
#define	ACTUAL_TEXT(P)	((P) + sizeof(short))
#define	ACTUAL_NEXT(P)	((P) + ACTUAL_SIZE(P))

/************************************************************************
**	the formals are copied into the buffer similar to the actuals, except
**	the size is denoted by an unsigned char, instead of short
************************************************************************/
#define	FORMAL_SIZE(P)	(*(ptext_t)(P))
#define	FORMAL_TEXT(P)	((P) + sizeof(UCHAR))
#define	FORMAL_NEXT(P)	((P) + FORMAL_SIZE(P))

expansion_t	Macro_expansion[LIMIT_MACRO_DEPTH];

ptext_t	P_defn_start;
int		N_formals;
pdefn_t	Defn_level_0[LEVEL_0 + 1];


/************************************************************************
**	These are needed by p0scanner (Exp_ptr,Tiny_lexer_nesting)
************************************************************************/
ptext_t	Exp_ptr = EXP_BUFFER;		/* ptr to free exp space */
int		Tiny_lexer_nesting;	/* stay in tiny lexer or back to main */

static	ptext_t	Act_ptr = ACT_BUFFER;		/* ptr to free actuals space */
static	ptext_t	Save_Exp_ptr = EXP_BUFFER;	/* for buffering unbal parens */

static	ptext_t	P_actuals;		/* actuals for this (level) macro */
static	int		N_actuals;	/* number of actuals in invocation */
static	int		Macro_line;	/*  where we started the macro  */


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void	chkbuf(ptext_t);
ptext_t	do_strformal(void);
ptext_t	do_macformal(int *);
void	expand_actual(UCHAR);
void	expand_definition(void);
void	expand_macro(void);
void	fatal_in_macro(int);
ptext_t	gather_chars(ptext_t, UCHAR);
void	get_actuals(pdefn_t, int);
int	get_definition(void);
void	get_formals(void);
int	is_macro_arg(ptext_t);
void	move_to_actual(ptext_t, ptext_t);
void	move_to_exp(ptext_t);
void	move_to_exp_esc(int, ptext_t);
int	post_paste(void);
void	push_macro(pdefn_t);
int	redefn (ptext_t, ptext_t, int);
int	rescan_expansion(void);


/************************************************************************
** UNDEFINE - remove a symbol from the symbol table
**	No noise is made if the programmer attempts to undefine a predefined
**		macro, but it is not done.
************************************************************************/
void   undefine(void)
{
    pdefn_t	pdef;
    pdefn_t	prev;

    prev = NULL;
    pdef = Defn_level_0[Reuse_1_hash & LEVEL_0];
    while(pdef) {
	if(memcmp (Reuse_1, DEFN_IDENT(pdef), Reuse_1_length) == 0) {
	    if(PRE_DEFINED(pdef)) {
		Msg_Temp = GET_MSG (4112);
		SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#undef");
		warning(4112);
		break;
	    }
	    if(prev == NULL)	/*  match at head of list  */
		Defn_level_0[Reuse_1_hash & LEVEL_0] = DEFN_NEXT(pdef);
	    else
		DEFN_NEXT(prev) = DEFN_NEXT(pdef);
	    break;
	}
	prev = pdef;
	pdef = DEFN_NEXT(pdef);
    }
}


/************************************************************************
**  BEGIN DEFINE A MACRO {
************************************************************************/
void   define(void)
{
    UCHAR	c;

    if (! (LX_IS_IDENT(c = skip_cwhite())) ) {
	Msg_Temp = GET_MSG (2007);
	SET_MSG (Msg_Text, Msg_Temp);
        error (2007); /* #define syntax */
	skip_cnew();
	return;
    }
    getid(c);
    N_formals = 0;
    P_defn_start = Macro_buffer;
/*
**  the next character must be white space or an open paren
*/
first_switch:
    switch(CHARMAP(c = GETCH())) {
    case LX_OPAREN:			/*  we have formal parameters  */
	get_formals();		/*  changes N_formals and fills Macro_buffer */
	if(N_formals == 0) {/*  empty formal list  */
		/*
		**  we must special case this since the expand() reads in the
		**  actual arguments iff there are formal parameters. thus if we
		**	#define	foo()	bar()
		**		. . .
		**		foo()
		**  will expand as
		**		bar()()
		**  we put the right paren in to fool the expander into looking
		**  for actuals.
		*/
	    N_formals = -1;
	}
	break;
    case LX_WHITE:
	break;
    case LX_CR:
	goto first_switch;
    case LX_SLASH:
	if( ! skip_comment()) {
	    Msg_Temp = GET_MSG (2008);
            SET_MSG (Msg_Text, Msg_Temp, '/');
            error (2008);
	}
	break;
    case LX_NL:			/* no definition */
	UNGETCH();
	definstall((ptext_t)0, 0, 0);
	return;
	break;
    case LX_EOS:
	if(handle_eos() != BACKSLASH_EOS) {
	    goto first_switch;
	}
	/* got BACKSLASH_EOS */
	/*
	**  FALLTHROUGH
	*/
    default:
	Msg_Temp = GET_MSG (2008);
        SET_MSG (Msg_Text, Msg_Temp, c);
        error (2008); /* unexpected character in macro definition */
    }
    definstall(P_defn_start, get_definition(), N_formals);
}


/************************************************************************
**  get_formals : collect comma separated idents until the first closing paren
**  (the openning paren has already been read)
**  since we can't be in a macro when we're asked for this, we can be assured
**  that we can use a single buffer to collect all the formal names.
************************************************************************/
void   get_formals(void)
{
    UCHAR		c;
    ptext_t	p_stop;
    ptext_t	p_id;

    p_id = p_stop = FORMAL_TEXT(P_defn_start);
    for(;;) {
	switch(CHARMAP(c = skip_cwhite())) {
	case LX_ID:
	    if( p_id != p_stop ) {
		Msg_Temp = GET_MSG (2010);
        	SET_MSG (Msg_Text, Msg_Temp, c);
        	error (2010);
	    }
	    *p_stop++ = c;
	    for(;;) {
		while(LXC_IS_IDENT(c = GETCH())) {	/* while an id char */
		    *p_stop++ = c;			/* collect it */
		} if(c == EOS_CHAR) {
		 	/*
			**  found end of buffer marker, make sure it is,
			**  then handle it.
			*/
		    if(io_eob()) {	/* end of buffer in here is bad */
			Msg_Temp = GET_MSG (1004);
			SET_MSG (Msg_Text, Msg_Temp);
			fatal (1004);
		    }
		    continue;
		}
		if((c == '\\') && (checknl())) {
		    continue;
		}
		UNGETCH();
		break;
	    }
	    *p_stop++ = '\0';
	    break;
	case LX_COMMA:
	case LX_CPAREN:
	    if( p_stop > p_id ) {
		/* make sure an identifier was read */
		if((p_stop - p_id) >= TINY_BUFFER) {
		    p_id[TINY_BUFFER - 1] = '\0';
		    Msg_Temp = GET_MSG (4111);
		    SET_MSG (Msg_Text, Msg_Temp, p_id);
		    warning(4011);		/* id truncated */
		    p_stop = p_id + TINY_BUFFER;
		}
		if(is_macro_arg(p_id) >= 1) {
		    Msg_Temp = GET_MSG (2009);
        	    SET_MSG (Msg_Text, Msg_Temp, p_id);
		    error(2009);		/* reuse of formal */
		}
		else {
		    FORMAL_SIZE(P_defn_start) = (UCHAR)(p_stop - P_defn_start);
		    P_defn_start = p_stop;
		    N_formals++;
		}
	    }
	    else {
		if( (CHARMAP(c) == LX_COMMA) || (N_formals > 0) ) {
		    Msg_Temp = GET_MSG (2010);
        	    SET_MSG (Msg_Text, Msg_Temp, c);
		    error(2010);
		}
	    }
	    if( CHARMAP(c) == LX_CPAREN ) {
		return;
	    }
	    p_id = p_stop = FORMAL_TEXT(P_defn_start);
	    break;
	default:
	    Msg_Temp = GET_MSG (2010);
       	    SET_MSG (Msg_Text, Msg_Temp, c);
	    error(2010); /*  unexpected char in formal list */
	    break;
	}
    }
}


/************************************************************************
** definstall - Install a new definition. id is in Reuse_1.
**	p_text : ptr to the definition
**	n : number of bytes in the definition (may contain embedded nulls)
**	number : number of formals
************************************************************************/
void   definstall(ptext_t p_text, int n, int number)
{
    pdefn_t	p;

    if(n == 0) {
	p_text = NULL;
    }
    if( strcmp (Reuse_1, "defined") == 0) {
	Msg_Temp = GET_MSG (4112);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#define");
	warning(4112);/* name reserved */
	return;
    }
    if((p = get_defined()) != 0) {
	if(PRE_DEFINED(p)) {
	    Msg_Temp = GET_MSG (4112);
            SET_MSG (Msg_Text, Msg_Temp, Reuse_1, "#define");
	    warning(4112);/* name reserved */
	    return;
	}
	else {
	    if(redefn(p_text, DEFN_TEXT(p), n)) {
		Msg_Temp = GET_MSG (4005);
                SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
		warning(4005);/* redefinition */
	    }
	    else {
		return;
	    }
	}
    }
    else {
	hln_t	ident;

	HLN_NAME(ident) = Reuse_1;
	HLN_HASH(ident) = Reuse_1_hash;
	HLN_LENGTH(ident) = (UCHAR)Reuse_1_length;
	p = malloc(sizeof(defn_t));
	if (p == NULL) {
	    Msg_Temp = GET_MSG (1002);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error(1002);
	    return;
	}
	DEFN_IDENT(p) = HLN_TO_NAME(&ident);
	DEFN_NEXT(p) = Defn_level_0[Reuse_1_hash & LEVEL_0];
	DEFN_TEXT(p) = (char*)NULL;
	DEFN_EXPANDING(p) = 0;
	Defn_level_0[Reuse_1_hash & LEVEL_0] = p;
    }
    if(n != 0) {
	DEFN_TEXT(p) = pstrndup(p_text, n);
	if(number == FROM_COMMAND) {	/* special case from cmd line */
	    *(DEFN_TEXT(p) + n - 1) = EOS_DEFINITION;	/* for handle_eos */
	}
    }
    DEFN_NFORMALS(p) = (char)((number != FROM_COMMAND) ? number : 0);
}


/************************************************************************
**  get_defined : is the given id in the macro symbol table?
**  return a ptr to it if so, NULL if not.
************************************************************************/
pdefn_t	  get_defined(void)
{
    pdefn_t	pdef;

    for( pdef = Defn_level_0[Reuse_1_hash & LEVEL_0]; pdef;
        pdef = DEFN_NEXT(pdef)) 	{
	if(memcmp (Reuse_1, DEFN_IDENT(pdef), Reuse_1_length) == 0) {
	    return(pdef);
	}
    }
    return(NULL);
}


/************************************************************************
**  redefn : are the two definitions the same?
************************************************************************/
int redefn(REG	ptext_t p_new, ptext_t p_old, int n)
{
    if(p_old && p_new) {
	if(strncmp(p_new, p_old, n) == 0) {	/* strings are exact */
	    return(FALSE);
	}
	return(TRUE);
    }
    return((p_old != NULL) || (p_new != NULL));
}


/************************************************************************
**  get_definition : accumulate the macro definition, stops when it finds
**  a newline (it uses it). returns a ptr to the end of the string it builds.
**  builds the string in Macro_buffer. (given the start in P_defn_start)
************************************************************************/
int   get_definition(void)
{
    REG	ptext_t	p;
    UCHAR	c;
    int		stringize = FALSE;
    int		charize = FALSE;

    p = P_defn_start;
    c = skip_cwhite();
    for(;;) {
	chkbuf(p);
	switch(CHARMAP(c)) {
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		/* got backslash EOS */
		/* \<anything else> goes out as is.  The <anything else>
			* character must be emitted now, so that
			*		#define FOO(name)	\name
			*		. . .
			*		FOO(bar)
			*
			* does NOT see occurence of name in the definition as an
			* occurence of the formal param and emit \bar when it is
			* expanded later,but if the definition is \nname it will
			* find name as a formal paramater and emit \nbar
			*/
		*p++ = c;	/* put in backslash, break'll add new char */
		c = get_non_eof();
	    }
	    else {
		c = GETCH();
		continue;
	    }
	    break;
	case LX_NL:		/*  only way out  */
	    UNGETCH();
	    if(p == P_defn_start) {
		return(0);
	    }
	    chkbuf(p);
	    *p++ = EOS_CHAR;
	    *p++ = EOS_DEFINITION;	/* tells handle_eos defn finished */
	    return((int)(p - P_defn_start));/* p's last incr counts the 0*/
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    p = gather_chars(p, c);
	    c = GETCH();
	    continue;
	    break;
	case LX_POUND:
split_op:
	    switch(CHARMAP(GETCH())) {
	    case LX_POUND:
		/*
		**  handle ## processing. cant be the first or the last.
		*/
		if(p == P_defn_start) {
	    	    Msg_Temp = GET_MSG (2160);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2160);	/* ## not allowed as first entry */
		    continue;
		}
		if(*(p - 1) == ' ') {	/* hose the last blank */
		    p--;
		}
		if(CHARMAP(c = skip_cwhite()) == LX_NL) {
		    UNGETCH();
	    	    Msg_Temp = GET_MSG (2161);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2161);
		    continue;
		}
		/* this case does *not* fall through to LX_ID */
		continue;
		break;
	    case LX_EACH:
		charize = TRUE;
		break;
	    case LX_EOS:
		if( handle_eos() != BACKSLASH_EOS ) {
		    goto split_op;
		}
		/*
		**	FALLTHROUGH
		*/
	    default:
		UNGETCH();
		stringize = TRUE;
		break;
	    }
	    if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    	Msg_Temp = GET_MSG (2162);
       	    	SET_MSG (Msg_Text, Msg_Temp);
		error(2162);	/* must have id following */
		continue;
	    }
	    /*
	    **  FALLTHROUGH
	    */
	case LX_ID:
	    {
		/* we have the start of an identifier - check it to see if
		 * its an occurence of a formal parameter name.
		 * we gather the id ourselves (instead of getid()) since this
		 * wil save us from having to copy it to our string if it's
		 * not a formal parameter.
		 */
		int			n;
		ptext_t	p_macformal;

		p_macformal = p;
		do {
		    chkbuf(p);
		    *p++ = c;
get_more_id:
		    c = GETCH();
		} while(LXC_IS_IDENT(c));
		if(CHARMAP(c) == LX_EOS) {
		    if(handle_eos() != BACKSLASH_EOS) {
			goto get_more_id;
		    }
		}
		*p = '\0'; /* term. string, but do not advance ptr */
		if((n = is_macro_arg(p_macformal)) >= 1) {
		    /*
		    **  this is an occurance of formal 'n', replace the id with
		    **  the special MAC character.
		    */
		    p = p_macformal;
		    if(stringize) {
			*p++ = LX_FORMALSTR;
		    }
		    else {
			if(charize) {
			    *p++ = LX_FORMALCHAR;
			}
			else {
			    *p++ = LX_FORMALMARK;
			}
		    }
		    *p++ = (UCHAR) n;
		}
		else if(charize || stringize) {
	  	    Msg_Temp = GET_MSG (2162);
       	    	    SET_MSG (Msg_Text, Msg_Temp);
		    error(2162);
		}
		stringize = FALSE;
		charize = FALSE;
		continue;	/* we broke out of the loop with a new char */
	    }
	case LX_SLASH:
	    if( ! skip_comment() ) {	/* really is a slash */
		break;
	    }
	    /*
			**  FALLTHROUGH
			*/
	case LX_CR:
	case LX_WHITE:
	    /*
	    **  this is white space, all contiguous whitespace is transformed
	    **  to 1 blank. (hence the skip_cwhite() and the continue).
	    */
	    if(CHARMAP(c = skip_cwhite()) != LX_NL) {
		*p++ = ' ';
	    }
	    continue;				/* restart loop */
	case LX_ILL:
	    Msg_Temp = GET_MSG (2018);
       	    SET_MSG (Msg_Text, Msg_Temp, c);
	    error(2018);
	    c = GETCH();
	    continue;
	}
	*p++ = c;
	c = GETCH();
    }
}


/************************************************************************/
/* is_macro_arg ()							*/
/************************************************************************/
int   is_macro_arg(ptext_t name)
{
    REG	int			i;
    REG	ptext_t	p;

    p = Macro_buffer;
    for(i = 1; i <= N_formals; i++) {
	if( strcmp(name, FORMAL_TEXT(p)) == 0) {
	    return(i);
	}
	p = FORMAL_NEXT(p);
    }
    return(-1);
}



/************************************************************************/
/* chkbuf ()								*/
/************************************************************************/
void   chkbuf(ptext_t p)
{
    if( p >= ELIMIT ) {
	Msg_Temp = GET_MSG (1065);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	fatal (1065);
    }
}


/************************************************************************
**  gather_chars : collect chars until a matching one is found.
**  skip backslashed chars. moves the chars into the buffer,
**  returns a ptr past the last char copied.
************************************************************************/
ptext_t   gather_chars(REG ptext_t p, UCHAR match_c)
{
    UCHAR	c;

    *p++ = match_c;
    for(;;) {
	if(p > ELIMIT) {
	    return(ELIMIT);
	}
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    Msg_Temp = GET_MSG (2001);
       	    SET_MSG (Msg_Text, Msg_Temp);
	    error(2001);
	    UNGETCH();
	    c = match_c;
	    /*
			**  FALLTHROUGH
			*/
	case LX_DQUOTE:
	case LX_SQUOTE:
	    if(c == match_c) {
		*p++ = c;
		return(p);		/* only way out */
	    }
	    break;
	case LX_EOS:
	    if(handle_eos() != BACKSLASH_EOS) {
		continue;
	    }
	    else {
		/* got backslash */
		*p++ = '\\';
		c = get_non_eof();
		if((c == '\\') && (checknl())) {
		    continue;
		}
	    }
	    break;
	case LX_LEADBYTE:
	    *p++ = c;
	    c = get_non_eof();
	    break;
	}
	*p++ = c;
    }
}
/************************************************************************
**  END DEFINING MACROS }
************************************************************************/

/************************************************************************
**  BEGIN EXPANDING MACROS {
************************************************************************/
/************************************************************************
**	can_expand:		tries to expand the macro passed to it - returns
**		true if it succeeded in expanding it.  It will only return FALSE
**		if a macro name was found, a paren was expected, and a paren was
**		not the next non white character.
************************************************************************/
int can_expand(pdefn_t pdef)
{
    UCHAR		c;
    int			n_formals;
    int			return_value = FALSE;

    Tiny_lexer_nesting = 0;
    Save_Exp_ptr = Exp_ptr;		/* not necessarily EXP_BUFFER */
    Macro_line = Linenumber;
expand_name:

    P_actuals = Act_ptr;
    N_actuals = 0;

    n_formals = DEFN_NFORMALS(pdef);
    if( PRE_DEFINED(pdef) ) {
	push_macro(pdef);
	DEFN_EXPANDING(CURRENT_MACRO)++;
	if(rescan_expansion()) {
	    return(TRUE);			/* could expand macro */
	}
    }
    else if( n_formals == 0 ) {
	return_value = TRUE;
	if(DEFN_TEXT(pdef)) {
	    push_macro(pdef);
	    expand_definition();
	}
	else {
	    /*
		**	Macro expands to nothing (no definition).  Since it
		**	didn't have any actuals, Act_ptr is already correct.
		**	Exp_ptr must be changed however to delete the
		**	identifier from the expanded text.
		*/
	    Exp_ptr = Save_Exp_ptr;
	}
    }
    else {
	if( n_formals == -1 ) {
	    n_formals = 0;
	}
name_comment_paren:
	if( can_get_non_white()) {
	    if(CHARMAP(CHECKCH()) == LX_SLASH) {
		SKIPCH();
		if(skip_comment()) {
		    goto name_comment_paren;
		}
		else {
		    UNGETCH();
		}
	    }
	    if(CHARMAP(CHECKCH())==LX_OPAREN) {
		SKIPCH();
		return_value = TRUE;
		get_actuals(pdef, n_formals);
	    }
	    else {
		/*
				**	#define xx(a) a
				**  xx bar();
				**  don't lose white space between "xx" and "bar"
				*/
		ptext_t	p = Exp_ptr;

		push_macro(pdef);
		DEFN_EXPANDING(CURRENT_MACRO)++;
		Exp_ptr = p;
		if( rescan_expansion() ) {
		    return(FALSE);
		}
	    }
	}
	else {
	}
    }
    /*
	**	makes sure a macro is being worked on. At this point, there will
	**	be a macro to expand, unless the macro expand_the_named_macro was
	**	passed had no definition text.  If it had no defintion text,
	**	Tiny_lexer_nesting was not incremented.
	*/
    while(Tiny_lexer_nesting != 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	switch(CHARMAP(c = GETCH())) {
	case LX_ID:
	case LX_MACFORMAL:
	    Save_Exp_ptr = Exp_ptr;
	    if(tl_getid(c) && ((pdef = get_defined())!= 0)) {
		if(DEFN_EXPANDING(pdef)) {
		    /*
						**	the macro is already being expanded, so just
						**	write the do not expand marker and the
						**	identifier to the expand area.  The do not
						**	expand marker is necessary so this macro
						**	doesn't get expanded on the rescan
						*/
		    int		len = Reuse_1_length - 1;

		    *Exp_ptr++ = LX_NOEXPANDMARK;
		    *Exp_ptr++ = ((UCHAR)len);
		}
		else {
		    /*
						** a legal identifier was read, it is defined, and
						** it is not currently being expanded.  This means
						** there is reason to believe it can be expanded.
						*/
		    goto expand_name;
		}
	    }
	    if(InIf &&(memcmp(Reuse_1, "defined", 8) ==0)) {
		do_defined(Reuse_1);
	    }
	    continue;
	    break;
	case LX_NUMBER:
	    /* getnum with Prep on to keep leading 0x on number */
	    {
		int	Save_prep = Prep;
		Prep = TRUE;
		getnum(c);
		Prep = Save_prep;
	    }
	    continue;
	    break;
	case LX_DOT:
	    *Exp_ptr++ = '.';
dot_switch:
	    switch(CHARMAP(c = GETCH())) {
	    case LX_EOS:
		if(handle_eos() != BACKSLASH_EOS) {
		    if(Tiny_lexer_nesting > 0) {
			goto dot_switch;
		    }
		    continue;
		}
		break;
	    case LX_DOT:
		*Exp_ptr++ = '.';
		if( ! checkop('.')) {
		    break;	/* error will be caught on rescan */
		}
		*Exp_ptr++ = '.';
		continue;
		break;
	    case LX_NUMBER:
		*Exp_ptr++ = c;
		get_real(Exp_ptr);
		continue;
	    }
	    UNGETCH();
	    continue;
	case LX_CHARFORMAL:
	    move_to_exp_esc('\'', do_strformal());
	    continue;
	    break;
	case LX_STRFORMAL:
	    move_to_exp_esc('"', do_strformal());
	    continue;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    /*
	    ** 	gather_chars is called even though the error reported
	    **	on overflow may need to be changed.
	    */
	    Exp_ptr = gather_chars(Exp_ptr, c);
	    continue;
	    break;
	case LX_WHITE:
	    while(LXC_IS_WHITE(GETCH())) {
		;
	    }
	    UNGETCH();
	    c = ' ';
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		*Exp_ptr++ = c;
		c = GETCH();
		break;
	    }
	    continue;
	    break;
	}
	*Exp_ptr++ = c;
    }
    return(return_value);
}


/************************************************************************
**  get_actuals :  Paren must already be found.  If all the actuals can
**		be read, the macro is pushed and expansion begins. Otherwise,
**		this function is quickly exited and lets the tiny lexer take
**		care of rescanning.
************************************************************************/
void   get_actuals(pdefn_t pdef, int n_formals)
{
    /*
    **	The only concern with this is that a rescan could finish while
    **	this is trying to collect actuals.  When a rescan finishes, it
    **	may reset Act_ptr and Exp_ptr.  Unless these are saved before the
    **	end of rescan is handled, the part of the actual collected so far
    **	would be lost.
    */
    REG	ptext_t	start;
    UCHAR		c;
    ptext_t	actuals_start;
    int			paste;
    int			level;

    *Exp_ptr++ = PREVCH();			/* must be oparen */
    level = 0;
    actuals_start = Act_ptr;

    while( level >= 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
more_white:
	if( ! can_get_non_white()) {
	    return;
	}
	if(CHARMAP(CHECKCH()) == LX_SLASH) {
	    SKIPCH();
	    if(skip_comment()) {
		goto more_white;
	    }
	    else {
		start = Exp_ptr;
		*Exp_ptr++ = '/';
	    }
	}
	else {
	    start = Exp_ptr;
	}
	paste = FALSE;

	for(;;) {
	    switch(CHARMAP(c = GETCH())) {
	    case LX_CPAREN:
		if(--level < 0) {
		    goto leave_loop;
		}
		break;
	    case LX_COMMA:
		/*
		**	if the comma is not at level == 0, it is part of
		**	a parenthesized list and not a delimiter
		*/
		if(level == 0) {
		    goto leave_loop;
		}
		break;
	    case LX_SLASH:
		if( ! skip_comment()) {
		    break;
		}
		if(*(Exp_ptr - 1) == ' ') {
		    continue;
		}
		c = ' ';
		break;
	    case LX_CR:
	    case LX_NL:
	    case LX_WHITE:
		UNGETCH();		/* This char is valid white space */
		if( ! can_get_non_white()) {
		    return;
		}
		continue;
		break;
	    case LX_OPAREN:
		++level;
		break;
	    case LX_DQUOTE:
	    case LX_SQUOTE:
		Exp_ptr = gather_chars(Exp_ptr, c);
		continue;
		break;
	    case LX_ID:
		*Exp_ptr++ = c;
		while(LXC_IS_IDENT(c = GETCH())) {
		    if(Exp_ptr >= ELIMIT) {
			fatal_in_macro(10056);
		    }
		    *Exp_ptr++ = c;
		}
		if(CHARMAP(c) != LX_MACFORMAL) {
		    UNGETCH();
		    continue;
		}
		paste = TRUE;
		/*
		**	FALLTHROUGH
		*/
	    case LX_MACFORMAL:
		move_to_exp(do_macformal(&paste));
		continue;
		break;
	    case LX_STRFORMAL:
		move_to_exp_esc('"', do_strformal());
		continue;
		break;
	    case LX_CHARFORMAL:
		move_to_exp_esc('\'', do_strformal());
		continue;
		break;
	    case LX_EOS:
		/*
		**	Will saving this pointers create dead space in the
		**	buffers?  Yes, but only temporarily.
		**
		**	handle_eos() may reset Act_ptr and Exp_ptr to the
		**	beginning of the buffers if a rescan is finishing
		**	and Macro_depth is going to be 0.  ANSI allows
		**	actuals to start within a macro defintion and be
		**	completed (further actuals and closing paren) later
		**	in the text.
		**
		**	These buffer pointers will eventually be reset to
		**	the beginnings of their respective buffers when the
		**	macro for the actuals being collected right now
		**	finish rescan
		**
		**	This is special handling for folks who use
		**	unbalanced parens in macro definitions
		*/
		{
		    ptext_t	Exp_save;
		    ptext_t	Act_save;
		    int	eos_res;

		    Exp_save = Exp_ptr;
		    Act_save = Act_ptr;
		    if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
			return;
		    }
		    Act_ptr = Act_save;
		    Exp_ptr = Exp_save;
		    if(eos_res == BACKSLASH_EOS) {	/* ??? DFP QUESTION  */
			*Exp_ptr++ = c;		/*  save the \  */
			c = get_non_eof();	/*  get char following \  */
			break;
		    }
		}
		continue;
		break;
	    }
	    *Exp_ptr++ = c;
	}
leave_loop:
	/*
		**	if the last character was whitespace, hose it
		*/
	if(CHARMAP(*(Exp_ptr - 1)) == LX_WHITE) {
	    Exp_ptr--;
	}
	/*
	**	if Exp_ptr <= start, foo() was read, don't incr N_actuals
	*/
	if(Exp_ptr > start) {
	    N_actuals++;
	    move_to_actual(start, Exp_ptr);
	}
	*Exp_ptr++ = c;
    }

    P_actuals = actuals_start;
    if(n_formals < N_actuals) {
	Msg_Temp = GET_MSG (4002);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4002);
    }
    else if(n_formals > N_actuals) {
	Msg_Temp = GET_MSG (4003);
        SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	warning(4003);
    }

    if(DEFN_TEXT(pdef)) {
	push_macro(pdef);
	expand_macro();
    }
    else {
	/*
		**	the macro expands to nothing (no definition)
		**	This essentially means delete the macro and its actuals
		**	from the expanded text
		*/
	Act_ptr = P_actuals;	/* reset pointer to get rid of actuals */
	Exp_ptr = Save_Exp_ptr;	/* delete macro & actuals from exp text */
    }
}

/************************************************************************
**	rescan_expansion:	pops a level off of tiny lexer.  If this is the
**		original macro called, the rescan is set up, otherwise the MACRO
**		(not only the tiny lexer level) is popped.
************************************************************************/
int rescan_expansion(void)
{
    if(--Tiny_lexer_nesting == 0) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = EOS_CHAR;
	*Exp_ptr++ = EOS_RESCAN;
	Current_char = CURRENT_TEXT;
	return(TRUE);			/* rescan the expanded text */
    }
    else {
	/* reset Current_char, pop the macro */

	Current_char = CURRENT_STRING;
	Act_ptr = CURRENT_ACTUALS;	/* don't need its actuals */
	DEFN_EXPANDING(CURRENT_MACRO)--;
	--Macro_depth;
	return(FALSE);			/* do not rescan expanded text */
    }
}


/************************************************************************
** move_to_actual:	moves the string located between start and finish
**		inclusive to the current location in ACT_BUFFER as a new actual.
************************************************************************/
void   move_to_actual(ptext_t start, ptext_t finish)
{
    REG	ptext_t	p;
    REG	int			len;

    len = (int)(finish - start);
    if(Act_ptr + len >= ALIMIT - 2) {
	fatal_in_macro(10056);
    }
    strncpy(ACTUAL_TEXT(Act_ptr), start, len);
    p = ACTUAL_TEXT(Act_ptr) + len;
    if ((((ULONG_PTR)p) & 1) == 0) {
        *p++ = EOS_CHAR;
        *p++ = EOS_ACTUAL;
    }
    else {
        *p++ = EOS_CHAR;
        *p++ = EOS_PAD;
        *p++ = EOS_ACTUAL;
    }
    ACTUAL_SIZE(Act_ptr) = (short)(p - Act_ptr);
    Act_ptr = p;
}


/************************************************************************
** move_to_exp_esc:	moves zero terminated string starting at source to
**	the current position in EXP_BUFFER, with quotes placed around the
**	string and interior backslashes and dquotes are escaped with a
**	backslash.  The terminating null should not be copied.  The null
**	does not come from the property of a string, but rather is the
**	marker used to indicate there is no more actual.
************************************************************************/
void   move_to_exp_esc(int quote_char, REG ptext_t source)
{
    int		mapped_c;
    int		mapped_quote;
    int		in_quoted = FALSE;

    if( ! source ) {
	return;
    }

    *Exp_ptr++ = (char)quote_char;
    for(;;) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	switch(mapped_c = CHARMAP(*source)) {
	case LX_EOS:
	    if(*source == EOS_CHAR) {
		goto leave_move_stringize;
	    }
	    /* got BACKSLASH */
	    /* but it can't be backslash-newline combination because
				** we are reprocessing text already read in
				*/
	    if(in_quoted) {
		*Exp_ptr++ = '\\';
	    }
	    break;
	    break;
	case LX_DQUOTE:
	    if(CHARMAP(quote_char) == LX_DQUOTE) {
		*Exp_ptr++ = '\\';
	    }
	    /*
			**	FALLTHROUGH
			*/
	case LX_SQUOTE:
	    if(CHARMAP(quote_char) == LX_SQUOTE) {
		break;
	    }
	    if(in_quoted ) {
		if(mapped_c == mapped_quote) {
		    in_quoted = FALSE;
		}
	    }
	    else {
		in_quoted = TRUE;
		mapped_quote = mapped_c;
	    }
	    break;
	case LX_LEADBYTE:
	    *Exp_ptr++ = *source++;
	    break;
	}
	*Exp_ptr++ = *source++;
    }

leave_move_stringize:
    *Exp_ptr++ = (char)quote_char;
}


/************************************************************************
**	move_to_exp:	moves zero terminated string starting at source to
**		the current position in EXP_BUFFER.  The terminating null should
**		not be copied.
************************************************************************/
void   move_to_exp(REG ptext_t source)
{
    if( ! source ) {
	return;
    }

    while( *source ) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = *source++;
    }
}


/************************************************************************
** push_macro:			pushes macro information onto the macro stack.
**	Information such as the current location in the Exp and Act buffers
**	will be used by whatever macros this one may call.
************************************************************************/
void   push_macro(pdefn_t pdef)
{
	/*
	**	note that increment leaves element 0 of the macro stack unused.
	**	this element can be reserved for links to dynamically allocated
	**	macro expansion stacks, if they become desirable
	*/
    if(++Macro_depth > LIMIT_MACRO_DEPTH) {
	Msg_Temp = GET_MSG (1009);
	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	fatal (1009);
    }
    Tiny_lexer_nesting++;
    CURRENT_MACRO = pdef;
    CURRENT_ACTUALS = P_actuals;
    CURRENT_NACTUALS = (UCHAR)N_actuals;
    CURRENT_NACTSEXPANDED = 0;
    CURRENT_STRING = Current_char;
    CURRENT_TEXT = Exp_ptr = Save_Exp_ptr;
}


/************************************************************************
**expand_definition:		sets the input stream to start reading from
**		the macro definition.  Also marks the macro as in the process of
**		expanding so if it eventually invokes itself, it will not expand
**		the new occurence.
************************************************************************/
void   expand_definition(void)
{
    Current_char = DEFN_TEXT(CURRENT_MACRO);
    DEFN_EXPANDING(CURRENT_MACRO)++;
}


/************************************************************************
**expand_actual:	sets the input stream to start reading from
**		the actual specified in actual.
************************************************************************/
void   expand_actual(UCHAR actual)
{
    ptext_t	p;
    p = CURRENT_ACTUALS;
    while(--actual) {
	p = ACTUAL_NEXT(p);
    }
    Current_char = ACTUAL_TEXT(p);
}

/************************************************************************
**	expand_macro:		if there are still actuals for this macro to be
**		expanded, the next one is set up, otherwise this sets up to
**		expand the macro definition
************************************************************************/
void   expand_macro(void)
{
    if(CURRENT_NACTUALS > CURRENT_NACTSEXPANDED) {
	expand_actual(++CURRENT_NACTSEXPANDED);
    }
    else {
	expand_definition();
    }
}


/************************************************************************
**post_paste:		looks ahead one character to find out if a paste has
**	been requested immediately after this identifier.  If the next
**	character can continue an identifier, or is the macformal marker,
**	a paste should be done.  This is called after a macformal is found
**	to find out if the expanded or unexpanded actual should be used.
************************************************************************/
int  post_paste(void)
{
    UCHAR	c;

    if((CHARMAP(c = GETCH()) == LX_MACFORMAL) || (LXC_IS_IDENT(c))) {
	UNGETCH();
	return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}

/************************************************************************
**do_macformal:		This function is called after a macformal marker is
**	found.  It reads the next character to find out which macformal is
**	wanted.  Then it checks to see if a paste is wanted, to find out
**	if the expanded or unexpanded actual should be used.  The return
**	value is a pointer to the text of the actual wanted, or NULL if the
**	actual asked for was not provided.
************************************************************************/
ptext_t   do_macformal(int *pre_paste)
{
    UCHAR		n;
    ptext_t	p;
    int	temp_paste;

    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
	return(NULL);		/* already output warning */
    }
    temp_paste = post_paste();
    if(( ! (*pre_paste)) && ( ! temp_paste) ) {
	/*
	**	if the programmer provided x actuals, actuals x+1 to 2x are
	**	those actuals expanded
	*/
	n += CURRENT_NACTUALS;
    }
    *pre_paste = temp_paste;
    if (n != 0)
	while(--n) {
	    p = ACTUAL_NEXT(p);
	}

    return(ACTUAL_TEXT(p));
}


/************************************************************************
**tl_getid:		This function reads an identifier for the tiny lexer
**		into EXP_BUFFER.  if macformal is found, the text of that actual
**		(expanded or not) is appended to the identifier.  It is possible
**		that this text will contain characters that are not legal
**		identifiers so return value is whether checking to see if the
**		"identifier" is defined is worth the bother.
************************************************************************/
int tl_getid(UCHAR c)
{
    UCHAR	*p;
    int		paste;
    int		legal_identifier;
    int		length = 0;

    p = Exp_ptr;
    paste = FALSE;
    legal_identifier = TRUE;

do_handle_macformal:
    if(CHARMAP(c) == LX_MACFORMAL) {
	ptext_t	p_buf;

	if((p_buf = do_macformal(&paste)) != 0) {
	    while( *p_buf ) {
		if( ! LXC_IS_IDENT(*p_buf)) {
		    legal_identifier = FALSE;
		}
		if(Exp_ptr >= ELIMIT) {
		    fatal_in_macro(10056);
		}
		*Exp_ptr++ = *p_buf++;
	    }
	}
    }
    else {
	*Exp_ptr++ = c;
    }

do_handle_eos:
    while(LXC_IS_IDENT(c = GETCH())) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	*Exp_ptr++ = c;
    }

    if(CHARMAP(c) == LX_NOEXPAND) {
	length = (int)GETCH();			/* just skip length */
	goto do_handle_eos;
    }

    if(CHARMAP(c) == LX_MACFORMAL) {
	paste = TRUE;
	goto do_handle_macformal;
    }

    UNGETCH();
    if(legal_identifier && (length == (Exp_ptr - p))) {
	legal_identifier = FALSE;
    }

    if(legal_identifier) {
	if(((Exp_ptr - p) > LIMIT_ID_LENGTH) && ( ! Prep)) {
	    Exp_ptr = &p[LIMIT_ID_LENGTH];
	    *Exp_ptr = '\0';	/* terminates identifier for warning */
	    Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, Msg_Temp, p);
	    warning(4011);		/* id truncated */
	}
	else {
	    *Exp_ptr = '\0';	/* terminates identifier for expandable check */
	}
	/*
	**	Whether or not we are doing Prep output, we still have to make
	**	sure the identifier will fit in Reuse_1
	*/
	if((Exp_ptr - p) > sizeof(Reuse_1)) {
	    Exp_ptr = &p[LIMIT_ID_LENGTH];
	    *Exp_ptr = '\0';
	    Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, Msg_Temp, p);
	    warning(4011);
	}
	/*
	**	copy into Reuse_1 for warnings about mismatched number of
	**	formals/actuals, and in case it's not expandable
	*/
	memcpy(Reuse_1, p, (int)((Exp_ptr - p) + 1));
	Reuse_1_hash = local_c_hash(Reuse_1);
	/*
	**	the characters from Exp_ptr to p inclusive do not include the
	**	the hash character, the length character, and the terminating
	**	null.
	*/
	Reuse_1_length = (UCHAR)((Exp_ptr - p) + 1);
    }
    return(legal_identifier);
}


/************************************************************************
**	do_strformal:	returns pointer to the actual requested without
**		checking for paste (a legal token is not possible, so if a paste
**		is being done on a strformal, the behavior is undefined
************************************************************************/
ptext_t   do_strformal(void)
{
    UCHAR		n;
    ptext_t	p;

    /* use unexpanded actual */
    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
	return(NULL);		/* already output warning */
    }
    if (n != 0)
	while(--n) {
	    p = ACTUAL_NEXT(p);
	}
    return(ACTUAL_TEXT(p));
}


/************************************************************************
**	can_get_non_white:	tries to get the next non white character
**		using P1 rules for white space (NL included).  If the end of
**		an actual, or a rescan is found, this returns FALSE, so control
**		can drop into one of the lexers.
************************************************************************/
int	  can_get_non_white(void)
{
    int		return_value = FALSE;
    int		white_found = FALSE;

    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:
	    if(On_pound_line) {
		UNGETCH();
		goto leave_cgnw;
	    }
	    Linenumber++;
	    /*
				**	FALLTHROUGH
				*/
	case LX_WHITE:
	case LX_CR:
	    white_found = TRUE;
	    break;
	case LX_EOS:
	    {
		int	eos_res;
		if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
		    goto leave_cgnw;
		}
		if(eos_res != BACKSLASH_EOS) {
		    break;
		}
	    }
	    /*
				**	FALLTHROUGH
				*/
	default:
	    UNGETCH();
	    return_value = TRUE;
	    goto leave_cgnw;
	    break;
	}
    }
leave_cgnw:
    if(white_found) {
	if(Exp_ptr >= ELIMIT) {
	    fatal_in_macro(10056);
	}
	if(*(Exp_ptr - 1) != ' ') {
	    *Exp_ptr++ = ' ';
	}
    }
    return(return_value);		/* could you get next non white? */
}


/************************************************************************/
/* fatal_in_macro ()							*/
/************************************************************************/
void fatal_in_macro(int e)
{
    Linenumber = Macro_line;
    Msg_Temp = GET_MSG(e);
    SET_MSG (Msg_Text, Msg_Temp);
    fatal (e);
}


/************************************************************************
**  handle_eos : handle the end of a string.
************************************************************************/
int   handle_eos(void)
{
    if(PREVCH() == '\\') {
	if(checknl()) {
	    return(FILE_EOS);
	}
	else {
	    return(BACKSLASH_EOS);
	}
    }
    if(Macro_depth == 0) {	/* found end of file buffer or backslash */
	if(io_eob()) {		/* end of buffer in here is bad */
	    Msg_Temp = GET_MSG(1004);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1004);
	}
	return(FILE_EOS);
    }

    again:
    switch(GETCH()) {
    case EOS_PAD:
        goto again;
    case EOS_ACTUAL:
	/*
	** Just finished expanding actual.  Check to see if there are
	** any more actuals to be expanded.  If there are, set up to
	** expand them and return.  Otherwise, set up to expand defn
	*/

	/* move expanded text of this actual to act_buffer */
	move_to_actual(CURRENT_TEXT, Exp_ptr);

	/* reset Exp_ptr for more expansions at this macro depth */
	Exp_ptr = CURRENT_TEXT;

	/* expand next actual if there, otherwise expand definition */
	expand_macro();

	return(ACTUAL_EOS);
	break;
    case EOS_DEFINITION:
	if(rescan_expansion()) {
	    return(RESCAN_EOS);
	}
	else {
	    return(DEFINITION_EOS);
	}
	break;
    case EOS_RESCAN:
	/*
	** Reset Current_char, Exp_ptr and Act_ptr, pop the macro
	*/

	/*	get input from the previous stream */
	Current_char = CURRENT_STRING;

	/* mark this macro as not expanding */
	DEFN_EXPANDING(CURRENT_MACRO)--;


	/*
	**	if looking for the actuals of a macro, these pointers
	**	should really not be reset, however, it is cleaner to
	**	save them before calling handle_eos, and restore them
	**	upon returning, than check a static variable here.
	*/
	if(Macro_depth == 1) {
	    Act_ptr = ACT_BUFFER;
	    Exp_ptr = EXP_BUFFER;
	}
	--Macro_depth;
	return(DEFINITION_EOS);
	break;
	/* the following conditional compile is so brackets match */

    DEFAULT_UNREACHABLE;
    }
}
/************************************************************************
**	END EXPANDING MACRO }
************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p0prepro.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0PREPRO.C - Main Preprocessor					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "grammar.h"
#include "trees.h"
#include "p1types.h"

/************************************************************************/
/* Internal constants							*/
/************************************************************************/
#define GOT_IF			1	/* last nesting command was an if.. */
#define GOT_ELIF		2	/* last nesting command was an if.. */
#define GOT_ELSE		3	/* last nesting command was an else */
#define	GOT_ENDIF		4	/* found endif */
#define ELSE_OR_ENDIF		5	/* skip to either #else or #endif */
#define ENDIF_ONLY		6	/* skip to #endif -- #else is an error*/

int	ifstack[IFSTACK_SIZE];


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
void chk_newline(PCHAR);
void in_standard(void);
int incr_ifstack(void);
token_t next_control(void);
void pragma(void);
int skipto(int);
void skip_quoted(int);
PUCHAR sysinclude(void);


/************************************************************************/
/* incr_ifstack - Increment the IF nesting stack			*/
/************************************************************************/

int incr_ifstack(void)
{
    if(++Prep_ifstack >= IFSTACK_SIZE) {
	Msg_Temp = GET_MSG (1052);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal (1052);
    }
    return(Prep_ifstack);
}


/************************************************************************
 * SYSINCLUDE - process a system include : #include <foo>
 *
 * ARGUMENTS - none
 *
 * RETURNS - none
 *
 * SIDE EFFECTS - none
 *
 * DESCRIPTION  
 *	Get the system include file name.  Since the name is not a "string",
 *	the name must be built much the same as the -E option rebuilds the text
 *	by using the Tokstring expansion for tokens with no expansion already
 *
 *  NOTE : IS THIS ANSI? note we're just reading chars, and not expanding
 * any macros. NO, it's not. it must expand the macros.
 * TODO : have it call yylex() unless and until it finds a '>' or a newline.
 * (probably have to set On_pound_line to have yylex return the newline.)
 *
 * AUTHOR
 *			Ralph Ryan	Sep. 1982
 *
 * MODIFICATIONS - none
 *
 *
 ************************************************************************/
PUCHAR sysinclude(void)
{
    REG	int		c;
    REG	char	*p_fname;

    p_fname = Reuse_1;
    c = skip_cwhite();
    if( c == '\n' ) {
	UNGETCH();
	Msg_Temp = GET_MSG (2012);
    	SET_MSG (Msg_Text, Msg_Temp);
	error(2012);	/* missing name after '<' */
	return(NULL);
    }
    while( c != '>' && c != '\n' ) {
	*p_fname++ = (UCHAR)c;		/* check for buffer overflow ??? */
	c = get_non_eof();
    }
    if( c == '\n' ) {
	UNGETCH();
	Msg_Temp = GET_MSG (2013);
    	SET_MSG (Msg_Text, Msg_Temp);
	error(2013);	/* missing '>' */
	return(NULL);
    }
    if(p_fname != Reuse_1) {
	p_fname--;
	while((p_fname >= Reuse_1) && isspace(*p_fname)) {
	    p_fname--;
	}
	p_fname++;
    }
    *p_fname = '\0';
    return(Reuse_1);
}


/************************************************************************
**  preprocess : the scanner found a # which was the first non-white char
**  on a line.
************************************************************************/
void   preprocess(void)
{
    REG		UCHAR	c;
    long		eval;
    int			condition;
    token_t		deftok;
    hln_t		identifier;

    if(Macro_depth != 0) {	/* # only when not in a macro */
	return;
    }
    switch(CHARMAP(c = skip_cwhite())) {
    case LX_ID:
	getid(c);
	HLN_NAME(identifier) = Reuse_1;
	HLN_LENGTH(identifier) = (UCHAR)Reuse_1_length;
	HLN_HASH(identifier) = Reuse_1_hash;
	break;
    case LX_NL:
	UNGETCH();
	return;
    default:
	Msg_Temp = GET_MSG (2019);
    	SET_MSG (Msg_Text, Msg_Temp, c);
	error(2019);	/* unknown preprocessor command */
	skip_cnew();	/* finds a newline */
	return;
    }

    On_pound_line = TRUE;
start:
    switch(deftok = is_pkeyword(HLN_IDENTP_NAME(&identifier))) {
	int			old_prep;

    case P0_DEFINE :
	define();
	break;
    case P0_LINE :
	old_prep = Prep;
	Prep = FALSE;
	yylex();
	if(Basic_token != L_CINTEGER) {		/* #line needs line number */
	    Msg_Temp = GET_MSG (2005);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2005);	/* unknown preprocessor command */
	    Prep = old_prep;
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	}
	/*
	**  -1 because there's a newline at the end of this line
	**  which will be counted later when we find it.
	**  the #line says the next line is the number we've given
	*/
	Linenumber = TR_LVALUE(yylval.yy_tree) - 1;
	yylex();
	Prep = old_prep;
	switch(Basic_token) {
	case L_STRING:
	    if( strcmp(Filename, yylval.yy_string.str_ptr) != 0) {
		strncpy(Filename,
		    yylval.yy_string.str_ptr,
		    sizeof(Filebuff)
		    );
	    }
	case L_NOTOKEN:
	    break;
	default:
	    Msg_Temp = GET_MSG (2130);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2130);	 /* #line needs a string */
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	    break;
	}
	emit_line();
	chk_newline("#line");
	break;
    case P0_INCLUDE :
	old_prep = Prep;
	Prep = FALSE;
	InInclude = TRUE;
	yylex();
	InInclude = FALSE;
	Prep = old_prep;
	switch(Basic_token) {
	case L_LT:
	    if((sysinclude()) == NULL) {
		skip_cnew();
		On_pound_line = FALSE;
		return;
		break;		/* error already emitted */
	    }
	    yylval.yy_string.str_ptr = Reuse_1;
	    break;
	case L_STRING:
	    break;
	default:
	    Msg_Temp = GET_MSG (2006);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    error(2006);	/* needs file name */
	    skip_cnew();
	    On_pound_line = FALSE;
	    return;
	    break;
	}
	chk_newline("#include");
	if( strchr(Path_chars, *yylval.yy_string.str_ptr) ||
	    (strchr(Path_chars, ':') && (yylval.yy_string.str_ptr[1] == ':'))) {
	    /*
	    **  we have a string which either has a 1st char which is a path
	    **  delimiter or, if ':' is a path delimiter (DOS), which has
	    **  "<drive letter>:" as the first two characters.  Such names
	    **  specify a fully qualified pathnames. Do not append the search
	    **  list, just look it up.
	    */
	    if( ! newinput(yylval.yy_string.str_ptr,MAY_OPEN)) {
		Msg_Temp = GET_MSG (1015);
		SET_MSG (Msg_Text, Msg_Temp, yylval.yy_string.str_ptr);
		fatal (1015); /* can't find include file */
	    }
	}
	else if( (Basic_token != L_STRING) || (! nested_include())) {
	    in_standard();
	}
	break;
    case P0_IFDEF :
    case P0_IFNDEF :
	if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    Msg_Temp = GET_MSG (1016);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1016);
	}
	getid(c);
	eval = (get_defined()) ? TRUE : FALSE;
	chk_newline((deftok == P0_IFDEF) ? "#ifdef" : "#ifndef");
	if(deftok == P0_IFNDEF) {
	    eval = ( ! eval );
	}
	if(	eval
	    ||
	    ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE)
	    ) {
	    /*
	**  expression is TRUE or when we skipped the false part
	**  we found a #else that will be expanded.
	*/
	    ifstack[incr_ifstack()] = GOT_IF;
	}
	else if(condition == GOT_ELIF) {
	    /* hash is wrong, but it won't be used */
	    HLN_NAME(identifier) = "if";		/* sleazy HACK */
	    goto start;
	}
	break;
    case P0_IF :
	old_prep = Prep;
	Prep = FALSE;
	InIf = TRUE;
	eval = do_constexpr();
	InIf = FALSE;
	Prep = old_prep;
	chk_newline(PPifel_str /* "#if/#elif" */);
	if(	(eval)
	    ||
	    ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE)
	    ) {
	    /*
		**  expression is TRUE or when we skipped the false part
		**  we found a #else that will be expanded.
		*/
	    ifstack[incr_ifstack()] = GOT_IF;
	    if(Eflag && !eval)
		emit_line();
	}
	/*
	**  here the #if's expression was false, so we skipped until we found
	**  an #elif. we'll restart and fake that we're processing a #if
	*/
	else {
	    if(Eflag)
		emit_line();
	    if(condition == GOT_ELIF) {
		/* hash is wrong, but it won't be needed */
		HLN_NAME(identifier) = "if";		/* sleazy HACK */
		goto start;
	    }
	}
	break;
    case P0_ELIF :
	/*
		**  here, we have found a #elif. first check to make sure that
		**  this is not an occurrance of a #elif with no preceding #if.
		**  (if Prep_ifstack < 0) then there is no preceding #if.
		*/
	if(Prep_ifstack-- < 0) {
	    Msg_Temp = GET_MSG (1018);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1018);
	}
		/*
		**  now, the preceding #if/#elif was true, and we've
		**  just found the next #elif. we want to skip all #else's
		**  and #elif's from here until we find the enclosing #endif
		*/
	while(skipto(ELSE_OR_ENDIF) != GOT_ENDIF) {
	    ;
	}
	if(Eflag)
	    emit_line();
	break;
    case P0_ELSE :	/*  the preceding #if/#elif was true  */
	if((Prep_ifstack < 0) || (ifstack[Prep_ifstack--] != GOT_IF)) {
	    Msg_Temp = GET_MSG (1019);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1019); /*  make sure there was one  */
	}
	chk_newline(PPelse_str /* "#else" */);
	skipto(ENDIF_ONLY);
	if(Eflag)
	    emit_line();
	break;
    case P0_ENDIF :	/*  only way here is a lonely #endif  */
	if(Prep_ifstack-- < 0) {
	    Msg_Temp = GET_MSG (1020);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal (1020);
	}
	if(Eflag)
	    emit_line();
	chk_newline(PPendif_str /* "#endif" */);
	break;
    case P0_PRAGMA :
	pragma();
	break;
    case P0_UNDEF :
	if(CHARMAP(c = skip_cwhite()) != LX_ID) {
	    Msg_Temp = GET_MSG (4006);
    	    SET_MSG (Msg_Text, Msg_Temp);
	    warning(4006);	/* missing identifier on #undef */
	}
	else {
	    getid(c);
	    undefine();
	}
	chk_newline("#undef");
	break;
    case P0_ERROR:
	{
	    PUCHAR	p;

	    p = Reuse_1;
	    while((c = get_non_eof()) != LX_EOS) {
		if(c == '\n') {
		    UNGETCH();
		    break;
		}
		*p++ = c;
	    }
	    *p = '\0';
	}
	Msg_Temp = GET_MSG (2188);
    	SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	error(2188);
	chk_newline("#error");
	break;
    case P0_IDENT:
	old_prep = Prep ;
	Prep = FALSE;
	yylex();
	Prep = old_prep;
	if(Basic_token != L_STRING) {
	    Msg_Temp = GET_MSG (4079);
    	    SET_MSG (Msg_Text, Msg_Temp, TS_STR(Basic_token));
	    warning(4079);
	}
	chk_newline("#error");
	break;
    case P0_NOTOKEN:
	Msg_Temp = GET_MSG (1021);
	SET_MSG (Msg_Text, Msg_Temp, HLN_IDENTP_NAME(&identifier));
	fatal (1021);
	break;
    }
    On_pound_line = FALSE;
}


/************************************************************************ 
 * SKIPTO - skip code until the end of an undefined block is reached.
 *
 * ARGUMENTS
 *	short key - skip to an ELSE or ENDIF or just an ENDIF
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS  
 *	- throws away input
 *
 * DESCRIPTION  
 *	The preprocessor is skipping code between failed ifdef, etc. and
 *	the corresponding ELSE or ENDIF (when key == ELSE_OR_ENDIF).
 *	Or it is skipping code between a failed ELSE and the ENDIF (when
 *	key == ENDIF_ONLY).
 *
 * AUTHOR - Ralph Ryan, Sept. 16, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int skipto(int key)
{
    REG	int		level;
    REG	token_t	tok;

    level = 0;
    tok = P0_NOTOKEN;
    for(;;) {
	/* make sure that IF [ELSE] ENDIF s are balanced */
	switch(next_control()) {
	case P0_IFDEF:
	case P0_IFNDEF:
	case P0_IF:
	    level++;
	    break;
	case P0_ELSE:
	    tok = P0_ELSE;
	    /*
			**  FALLTHROUGH
			*/
	case P0_ELIF:
	    /*
	    **  we found a #else or a #elif. these have their only chance
	    **  at being valid if they're at level 0.
	    **  if we're at any other level,
	    **  then this else/elif belongs to some other #if and we skip them.
	    **  if we were looking for an endif, the we have an error.
	    */
	    if(level != 0) {
		tok = P0_NOTOKEN;
		break;
	    }
	    if(key == ENDIF_ONLY) {
		Msg_Temp = GET_MSG (1022);
		SET_MSG (Msg_Text, Msg_Temp);
		fatal (1022);	/* expected #endif */
	    }
	    else if(tok == P0_ELSE) {
		chk_newline(PPelse_str /* "#else" */);
		return(GOT_ELSE);
	    }
	    else {
		return(GOT_ELIF);
	    }
	    break;
	case P0_ENDIF:
	    if(level == 0) {
		chk_newline(PPendif_str /* "#endif" */);
		return(GOT_ENDIF);
	    }
	    else {
		level--;
	    }
	    break;
	}
    }
}


/*************************************************************************
**  in_standard : search for the given file name in the directory list.
**		Input : ptr to include file name.
**		Output : fatal error if not found.
*************************************************************************/
void in_standard(void)
{
    int		i;
    int		stop;
    char	*p_dir;
    char	*p_file;
    char	*p_tmp;

    stop = Includes.li_top;

    for(i = MAXLIST-1; i >= stop; i--) {
	p_file = yylval.yy_string.str_ptr;
	if( ((p_dir = Includes.li_defns[i])!=0) &&(strcmp(p_dir, "./") != 0) ) {
	    /*
	    **  there is a directory to prepend and it's not './'
	    */
	    p_tmp = Exp_ptr;
	    while((*p_tmp++ = *p_dir++) != 0)
		;
	    /*
		**  above loop increments p_tmp past null.
		**  this replaces that null with a '/' if needed.  Not needed if the
		**  last character of the directory spec is a path delimiter.
		**  we then point to the char after the '/'
		*/
	    if(strchr(Path_chars, p_dir[-2]) == 0) {
		p_tmp[-1] = '/';
	    }
	    else {
		--p_tmp;
	    }
	    while((*p_tmp++ = *p_file++) != 0)
		;
	    p_file = Exp_ptr;
	}
	if(newinput(p_file,MAY_OPEN)) {	/* this is the non-error way out */
	    return;
	}
    }
    Msg_Temp = GET_MSG (1015);
    SET_MSG (Msg_Text, Msg_Temp, yylval.yy_string.str_ptr);
    fatal (1015);	/* can't find include file */
}


/*************************************************************************
**  chk_newline : check for whitespace only before a newline.
**  eat the newline.
*************************************************************************/
void chk_newline(PCHAR cmd)
{
    if(skip_cwhite() != '\n') {
	Msg_Temp = GET_MSG (4067);
    	SET_MSG (Msg_Text, Msg_Temp, cmd);
	warning(4067);		/* cmd expected newline */
	skip_cnew();
    }
    else {
	UNGETCH();
    }
}

/*************************************************************************
**  skip_quoted : skips chars until it finds a char which matches its arg.
*************************************************************************/
void skip_quoted(int sc)
{
    REG	UCHAR		c;

    for(;;) {
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    Msg_Temp = GET_MSG (4093);
    	    SET_MSG (Msg_Text, Msg_Temp);
	    warning(4093);
	    UNGETCH();
	    return;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    if(c == (UCHAR)sc)
		return;
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		SKIPCH();	/* might be /" !! */

	    }
	    break;
	case LX_LEADBYTE:	
	    get_non_eof();			
	    break;
	}
    }
}


/*************************************************************************
**  next_control : find a newline. find a pound sign as the first non-white.
**  find an id start char, build an id look it up and return the token.
**  this knows about strings/char const and such.
*************************************************************************/
token_t	  next_control(void)
{
    REG	UCHAR		c;

    for(;;) {
	c = skip_cwhite();
first_switch:
	switch(CHARMAP(c)) {
	case LX_NL:
	    Linenumber++;
	    if(Prep) {
		fputc('\n', OUTPUTFILE);
	    }
	    if((c = skip_cwhite()) == '#') {
		if(LX_IS_IDENT(c = skip_cwhite())) {
		    /*
		    **  this is the only way to return to the caller.
		    */
		    getid(c);
		    return(is_pkeyword(Reuse_1));	/* if its predefined  */
		}
	    }
	    goto first_switch;
	    break;
	case LX_DQUOTE:
	case LX_SQUOTE:
	    skip_quoted(c);
	    break;
	case LX_EOS:
	    if(handle_eos() == BACKSLASH_EOS) {
		SKIPCH();	/* might be \" !! */
	    }
	    break;
	}
    }
}


/*************************************************************************
**  do_defined : does the work for the defined(id)
**		should parens be counted, or just be used as delimiters (ie the
**		first open paren matches the first close paren)? If this is ever
**		an issue, it really means that there is not a legal identifier
**		between the parens, causing an error anyway, but consider:
**		#if (defined(2*(x-1))) || 1
**		#endif
**		It is friendlier to allow compilation to continue
*************************************************************************/
int	do_defined(PUCHAR p_tmp)
{
    REG	UINT	c;
    REG	int		value=0;
    int		paren_level = 0;

    /*
	** we want to allow:
	**	#define FOO			defined
	**	#define BAR(a,b)	a FOO | b
	**	#define	SNAFOO		0
	**	#if FOO BAR
	**	print("BAR is defined");
	**	#endif
	**	#if BAR(defined, SNAFOO)
	**	print("FOO is defined");
	**	#endif
	*/
    if(strcmp(p_tmp,"defined") != 0) {
	return(0);
    }
    if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
	/* NL encountered */
	return(value);
    }
    if((c = CHECKCH())== '(') {	/* assumes no other CHARMAP form of OPAREN */
	*Exp_ptr++ = (UCHAR)c;
	SKIPCH();
	paren_level++;
	if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
	    /* NL encountered */
	    return(value);
	}
    }
    if(Tiny_lexer_nesting>0) {
	if((CHARMAP(c=CHECKCH())==LX_MACFORMAL) || (CHARMAP(c)==LX_ID)) {
	    SKIPCH();
	    tl_getid((UCHAR)c);
	}
    }
    else {
	if(LX_IS_IDENT(c = CHECKCH())) {
	    SKIPCH();
	    if(Macro_depth >0) {
		lex_getid((UCHAR)c);
	    }
	    else {
		getid((UCHAR)c);
	    }
	    value = (get_defined()) ? TRUE : FALSE;
	}
	else {
	    if(paren_level==0) {
		Msg_Temp = GET_MSG (2003);
    		SET_MSG (Msg_Text, Msg_Temp);
		error(2003);
	    }
	    else {
		Msg_Temp = GET_MSG (2004);
    		SET_MSG (Msg_Text, Msg_Temp);
		error(2004);
	    }
	}
    }
    if((CHARMAP(c = CHECKCH()) == LX_WHITE) || (CHARMAP(c) == LX_EOS)) {
	if( ! can_get_non_white()) {
	    return(value);
	}
    }
    if(paren_level) {
	if((CHARMAP(c = CHECKCH()) == LX_CPAREN)) {
	    SKIPCH();
	    paren_level--;
	    *Exp_ptr++ = (UCHAR)c;
	}
    }
    if((paren_level > 0) && (Tiny_lexer_nesting == 0)) {
	Msg_Temp = GET_MSG (4004);
    	SET_MSG (Msg_Text, Msg_Temp);
	warning(4004);
    }
    return(value);
}


/*************************************************************************
 * NEXTIS - The lexical interface for #if expression parsing.
 * If the next token does not match what is wanted, return FALSE.
 * otherwise Set Currtok to L_NOTOKEN to force scanning on the next call.
 * Return TRUE.
 * will leave a newline as next char if it finds one.
 *************************************************************************/
int nextis(register token_t tok)
{
    if(Currtok != L_NOTOKEN) {
	if(tok == Currtok) {
	    Currtok = L_NOTOKEN;			/*  use up the token  */
	    return(TRUE);
	}
	else {
	    return(FALSE);
	}
    }
    switch(yylex()) {				/*  acquire a new token  */
    case 0:
	break;
    case L_CONSTANT:
	if( ! IS_INTEGRAL(TR_BTYPE(yylval.yy_tree))) {
		Msg_Temp = GET_MSG (1017);
    		SET_MSG (Msg_Text, Msg_Temp);
    		fatal (1017);
	}
	else {
	    Currval = TR_LVALUE(yylval.yy_tree);
	}
	if(tok == L_CINTEGER) {
	    return(TRUE);
	}
	Currtok = L_CINTEGER;
	break;
    case L_IDENT:
	Currval = do_defined(HLN_IDENTP_NAME(&yylval.yy_ident));
	if(tok == L_CINTEGER) {
	    return(TRUE);
	}
	Currtok = L_CINTEGER;
	break;
    default:
	if(tok == Basic_token) {
	    return(TRUE);
	}
	Currtok = Basic_token;
	break;
    }
    return(FALSE);
}


/************************************************************************
**  skip_cnew : reads up to and including the next newline.
************************************************************************/
void   skip_cnew(void)
{
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:		
	    UNGETCH();				
	    return;
	case LX_SLASH:	
	    skip_comment();			
	    break;
	case LX_EOS:	
	    handle_eos();			
	    break;
	}
    }
}


/************************************************************************
**  skip_NLonly : reads up to the next newline, disallowing comments
************************************************************************/
void   skip_NLonly(void)
{
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_NL:		
	    UNGETCH();				
	    return;
	case LX_EOS:	
	    handle_eos();			
	    break;
	}
    }
}


/************************************************************************
**  pragma : handle processing the pragma directive
**  called by preprocess() after we have seen the #pragma
**  and are ready to handle the keyword which follows.
************************************************************************/
void   pragma(void)
{
    if(Prep) {
	UCHAR	c;

	fwrite("#pragma", 7, 1, OUTPUTFILE);
	while((c = get_non_eof()) != '\n') {
	    fputc(c, OUTPUTFILE);
	}
	UNGETCH();
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p1sup.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P1SUP.C - First pass C stuff which probably is not used		*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p1types.h"
#include "trees.h"
#include "grammar.h"
#include "strings.h"

/* trees */
#define	LEFT			1
#define	RIGHT			2

#define	MORE_CHECKING	2

int TypeCount;
int TreeCount;
char * TypePool;
char * TreePool;

type_entry_t    *Type_table[TYPE_TABLE_SIZE];


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
ptype_t  hash_type(ptype_t);
int types_equal(ptype_t, ptype_t);


/************************************************************************
**  hash_type : returns a pointer to an already built type, if it
**  exists, or builds one.
************************************************************************/
ptype_t  hash_type(type_t  * p_type)
{
    REG type_entry_t    *p_tmp;
    type_entry_t    **p_start;

    /* Try to get a unique hash value for every type...keep
     * type_equal in mind if changing this
     */
    p_start = &Type_table[(TY_BTYPE(p_type) + TY_DTYPE(p_type) + (INT_PTR) TY_INDIR(p_type)) & (TYPE_TABLE_SIZE - 1)];

    for (p_tmp= *p_start; p_tmp; p_tmp = p_tmp->te_next ) {
        if (types_equal(p_type,&(p_tmp->te_type))) {
            return(&(p_tmp->te_type));
        }
    }
    p_tmp = malloc(sizeof(type_entry_t));
    if (p_tmp == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    p_tmp->te_next = *p_start;
    *p_start = p_tmp;
    p_tmp->te_type = *p_type;
    TY_TINDEX(&(p_tmp->te_type)) = 0;
    return(&(p_tmp->te_type));
}


/************************************************************************
**  types_equal : are two types equal?
************************************************************************/
int types_equal(REG ptype_t p1, REG ptype_t p2)
{
    return( (TY_BTYPE(p1) == TY_BTYPE(p2))
            &&
            (TY_DTYPE(p1) == TY_DTYPE(p2))
            &&
            TY_INDIR(p1) == TY_INDIR(p2)
          );
}

/************************************************************************
**	build_const - builds and returns a pointer to a constant tree.
**		Input	: constant type.
**			: ptr to a union containing the value of the constant
**		Output	: Pointer to constant tree.
************************************************************************/
ptree_t build_const(REG token_t type, value_t *value)
{
    REG ptree_t     res;
    ptype_t     p_type;
    btype_t     btype;

    res = malloc(sizeof(tree_t));
    if (res == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    TR_SHAPE(res) = TTconstant;
    TR_TOKEN(res) = type;
    switch ( type ) {
        case L_CINTEGER:
        case L_LONGINT:
        case L_CUNSIGNED:
        case L_LONGUNSIGNED:
            if ( type == L_CUNSIGNED || type == L_LONGUNSIGNED ) {
                btype = (btype_t)(BT_UNSIGNED |
                                  (btype_t)((type == L_CUNSIGNED) ? BTint : BTlong));
            } else {
                btype = (btype_t)((type == L_CINTEGER) ? BTint : BTlong);
            }
            if ((TR_LVALUE(res) = PV_LONG(value)) == 0) {
                TR_SHAPE(res) |= TTzero;
            }
            break;
        case L_CFLOAT:
            btype = BTfloat;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CDOUBLE:
            btype = BTdouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CLDOUBLE:
            btype = BTldouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        default:
            btype=BTundef;
            break;
    }
    p_type = malloc(sizeof(type_t));
    if (p_type == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    TY_BTYPE(p_type) = (btype_t)(btype | BT_CONST);
    TR_P1TYPE(res) = hash_type(p_type);
    return(res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\p1types.h ===
/*
**  symbols basic types
**  if the values are changed check : init'd arrays in globals.c
*/
#define	BTundef		0
#define	BTchar		1
#define	BTshort		2
#define	BTint		3
#define	BTlong		4
#define	BTenumuse	5
#define	BTfloat		6
#define	BTdouble	7
#define	BTldouble	8
#define	BTseg		9
#define	BTBASIC		9   /* used elsewhere to indicate the last basic type */
#define	BTvoid		10
#define	BTenum		11
#define	BTstruct	12
#define	BTunion		13
#define	BTstuse		14
#define	BTunuse		15

#define	BT_MASK		0x0f	/* basic type mask */

/*
**  the following are also used in indirection strings as modifiers
**  to the basic indirections.
**  NOTE THIS DOESN'T really work for C600, but for just one case.
**  if a typedef has 'near' on it, 'consolidate_types' will consider
**  it to be a 'signed' bit, and remove it, thus, near never gets
**  added to whatever the typedef is used on.
*/
#define	BT_UNSIGNED		0x0010	/* unsigned keyword used */
#define	BT_SIGNED		0x0020	/* signed keyword used */
#define	SU_MASK			0x0030	/* signed/unsigned mask */

#define	BT_NEAR			0x0040	/* near keyword used */
#define	BT_FAR			0x0080	/* far keyword used */
#define	BT_HUGE			0x00c0	/* huge keyword used */
#define	NFH_MASK		0x00c0	/* near/far/huge mask */

#define	BT_INTERRUPT	0x0100	/* interrupt seen */
#define	BT_SAVEREGS		0x0200	/* dynalink seen */
#define	BT_EXPORT		0x0400	/* export seen */
#define	BT_LOADDS		0x0800	/* loadds seen */
#define	CODEMOD_MASK	0x0f00	/* code modifiers */

#define	BT_CONST		0x1000	/* constant keyword used */
#define	BT_VOLATILE		0x2000	/* volatile keyword used */
#define	CV_MASK			0x3000	/* const/volatile mask */

#define	BT_CDECL		0x4000	/* cdecl keyword used */
#define	BT_FORTRAN		0x8000	/* fortran keyword used */
#define	BT_PASCAL		0xc000	/* pascal keyword used */
#define	LANGUAGE_MASK	0xc000	/* cdecl/fortran/pascal mask */

#define	MODIFIER_MASK	(NFH_MASK | LANGUAGE_MASK | CODEMOD_MASK | CV_MASK)
#define	ALL_MODIFIERS	(MODIFIER_MASK | SU_MASK)
/*
**	macros for getting/setting basic type information
**  Q_* to query the flag.
**	S_* to set the flag.
**  the Q_near/far/huge things are defined later, and are called IS_*.
*/
#define	IS_BTBASIC(P)		((P) <= BTBASIC)
#define	IS_BTINTEGRAL(P)	((P) <= BTenumuse)
#define	IS_BTFLOAT(P)		((BTfloat <= (P)) && ((P) <= BTldouble))
#define	IS_BTVOID(P)		((P) == BTvoid)

#define	IS_BASIC(P)		(IS_BTBASIC(Q_BTYPE(P)))
#define	IS_INTEGRAL(P)	(IS_BTINTEGRAL(Q_BTYPE(P)))
#define	IS_FLOAT(P)		(IS_BTFLOAT(Q_BTYPE(P)))
#define	IS_VOID(P)		(IS_BTVOID(Q_BTYPE(P)))

#define	IS_MULTIBYTE(P)	((BTstruct <= (P)) && ((P) <= BTunuse))
#define	IS_UNSIGNED(P)	((P) & BT_UNSIGNED)
#define	IS_SIGNED(P)	((P) & BT_SIGNED)
#define	CLR_SIGNED(P)	((P) &= ~BT_SIGNED)

#define	S_UNSIGNED(P)	((P) |= BT_UNSIGNED)
#define	S_SIGNED(P)		((P) |= BT_SIGNED)
#define	S_CONST(P)		((P) |= BT_CONST)
#define	S_VOLATILE(P)	((P) |= BT_VOLATILE)
#define	S_NEAR(P)		((P) |= BT_NEAR)
#define	S_FAR(P)		((P) |= BT_FAR)
#define	S_HUGE(P)		((P) |= BT_HUGE)
#define	S_CDECL(P)		((P) |= BT_CDECL)
#define	S_FORTRAN(P)	((P) |= BT_FORTRAN)
#define	S_PASCAL(P)		((P) |= BT_PASCAL)
#define	S_INTERRUPT(P)	((P) |= BT_INTERRUPT)
#define	S_SAVEREGS(P)	((P) |= BT_SAVEREGS)

#define	Q_BTYPE(P)		((P) & ( BT_MASK ))
#define	S_BTYPE(P,V)	((P) = (((P) & ( ~ BT_MASK )) | V))

struct	s_flist		{			/* formal parameter list of types */
	ptype_t		fl_type;		/* type of formal */
	pflist_t	fl_next;		/* next one */
	};

#define	FL_NEXT(P)		((P)->fl_next)
#define	FL_TYPE(P)		((P)->fl_type)

union	u_ivalue	{
	abnd_t		ind_subscr;		/*  array subscript size  */
	psym_t		ind_formals;	/*  formal symbol list  */
	pflist_t	ind_flist;		/*  formal type list  */
	psym_t		ind_basesym;	/*  segment we're based on  */
	ptype_t		ind_basetype;	/*  type we're based on  */
	phln_t		ind_baseid;		/*  id we're based on  */
	};

#define	PIVALUE_ISUB(P)			((P)->ind_subscr)
#define	PIVALUE_IFORMALS(P)		((P)->ind_formals)
#define	PIVALUE_IFLIST(P)		((P)->ind_flist)
#define	PIVALUE_BASEDSYM(P)		((P)->ind_basesym)
#define	PIVALUE_BASEDTYPE(P)	((P)->ind_basetype)
#define	PIVALUE_BASEDID(P)		((P)->ind_baseid)

#define	IVALUE_ISUB(P)			(PIVALUE_ISUB(&(P)))
#define	IVALUE_IFORMALS(P)		(PIVALUE_IFORMALS(&(P)))
#define	IVALUE_IFLIST(P)		(PIVALUE_IFLIST(&(P)))
#define	IVALUE_BASEDSYM(P)		(PIVALUE_BASEDSYM(&(P)))
#define	IVALUE_BASEDTYPE(P)		(PIVALUE_BASEDTYPE(&(P)))
#define	IVALUE_BASEDID(P)		(PIVALUE_BASEDID(&(P)))

struct	s_indir	{
	btype_t		ind_type;		/*  what kind ?  */
	pindir_t	ind_next;		/*  next one  */
	ivalue_t	ind_info;		/*  subscript/function's params  */
	};

#define	INDIR_INEXT(P)		((P)->ind_next)
#define	INDIR_ITYPE(P)		((P)->ind_type)
#define	INDIR_INFO(P)		((P)->ind_info)
#define	INDIR_ISUB(P)		(IVALUE_ISUB(INDIR_INFO(P)))
#define	INDIR_IFORMALS(P)	(IVALUE_IFORMALS(INDIR_INFO(P)))
#define	INDIR_IFLIST(P)		(IVALUE_IFLIST(INDIR_INFO(P)))
#define	INDIR_BASEDSYM(P)	(IVALUE_BASEDSYM(INDIR_INFO(P)))
#define	INDIR_BASEDTYPE(P)	(IVALUE_BASEDTYPE(INDIR_INFO(P)))
#define	INDIR_BASEDID(P)	(IVALUE_BASEDID(INDIR_INFO(P)))
/*
**  optimal choices for these things.
**  however, everyone uses macros to test them, so if i'm wrong,
**  it should be easy to change the values, but think well !!!
*/
#define	IN_FUNC				0x00
#define	IN_PFUNC			0x01
#define	IN_ARRAY			0x02
#define	IN_PDATA			0x03
#define	IN_VOIDLIST			0x04
#define	IN_VARARGS			0x08
#define	IN_MASK				(IN_ARRAY | IN_PDATA | IN_PFUNC | IN_FUNC)
#define	IN_ADDRESS			(IN_ARRAY | IN_PDATA | IN_PFUNC)
#define	IN_DATA_ADDRESS		(IN_ARRAY & IN_PDATA)	/* yes, i meant '&' */
#define	IN_POINTER			(IN_PFUNC & IN_PDATA)	/* yes, i meant '&' */
#if IN_DATA_ADDRESS == 0
#error IN_DATA_ADDRESS is ZERO
#endif
#if IN_POINTER == 0
#error IN_POINTER is ZERO
#endif
#define	IS_ARRAY(I)			(((I) & IN_MASK) == IN_ARRAY)
#define	IS_PDATA(I)			(((I) & IN_MASK) == IN_PDATA)
#define	IS_PFUNC(I)			(((I) & IN_MASK) == IN_PFUNC)
#define	IS_FUNC(I)			(((I) & IN_MASK) == IN_FUNC)
#define	IS_EXTRACT(I)		((I) & IN_POINTER)
#define	IS_DATA_ADDRESS(I)	((I) & IN_DATA_ADDRESS)
#define	IS_ADDRESS(I)		((I) & IN_ADDRESS)
#define	IS_INDIR(I)			((I) & IN_MASK)
#define	MASK_INDIR(I)		((I) & IN_MASK)
#define	IS_VOIDLIST(I)		((I) & IN_VOIDLIST)
#define	IS_VARARGS(I)		((I) & IN_VARARGS)

#define	IS_NFH(I)			((I) & NFH_MASK)
#define	IS_NEARNFH(I)		((I) == BT_NEAR)
#define	IS_FARNFH(I)		((I) == BT_FAR)
#define	IS_HUGENFH(I)		((I) == BT_HUGE)
#define	IS_BASEDNFH(I)		((I) >= BT_BASED)
#define	IS_BASEDSELFNFH(I)	((I) == BT_BASEDSELF)
#define	IS_BASEDIDNFH(I)	((I) == BT_BASEDID)
#define	IS_BASEDSYMNFH(I)	((I) == BT_BASEDSYM)
#define	IS_BASEDTYPENFH(I)	((I) == BT_BASEDTYPE)

#define	IS_NEAR(I)			(IS_NEARNFH(IS_NFH(I)))
#define	IS_FAR(I)			(IS_FARNFH(IS_NFH(I)))
#define	IS_HUGE(I)			(IS_HUGENFH(IS_NFH(I)))
#define	IS_BASED(I)			(IS_BASEDNFH(IS_NFH(I)))
#define	IS_BASEDSELF(I)		(IS_BASEDSELFNFH(IS_NFH(I)))
#define	IS_BASEDID(I)		(IS_BASEDIDNFH(IS_NFH(I)))
#define	IS_BASEDSYM(I)		(IS_BASEDSYMNFH(IS_NFH(I)))
#define	IS_BASEDTYPE(I)		(IS_BASEDTYPENFH(IS_NFH(I)))

#define	IS_INTERRUPT(I)		((I) & BT_INTERRUPT)
#define	IS_SAVEREGS(I)		((I) & BT_SAVEREGS)
#define	IS_EXPORT(I)		((I) & BT_EXPORT)
#define	IS_LOADDS(I)		((I) & BT_LOADDS)
#define	IS_CODEMOD(I)		((I) & CODEMOD_MASK)

#define	IS_CONST(I)			((I) & BT_CONST)
#define	IS_VOLATILE(I)		((I) & BT_VOLATILE)

#define	IS_MODIFIED(I)		((I) & (MODIFIER_MASK))
#define	ANY_MODIFIER(I)		((I) & (ALL_MODIFIERS))

#define INTERF(I)			(MASK_INDIR(I) + (((I) & NFH_MASK) > 4))

#define	S_ITYPE(I,V)	((I) = ((I) & ( ~ IN_MASK )) | (V))
#define	S_INFH(I,V)		((I) = ((I) & ( ~ NFH_MASK )) | (V))
/*
**  type info for symbols
*/
struct	s_type	{
	btype_t		ty_bt;		/*  base type specifiers  */
	pindir_t	ty_indir;	/*  indirection string  */
	p1key_t		ty_dtype;	/*  derived type */
	psym_t		ty_esu;		/*  enum/structure/union/static defining type  */
	USHORT		ty_index;	/*	unique index of type for debugger */
	};
/*
**  help getting type info. P is pointer to TYPE (struct s_type).
**	TYPE contains the basic type, adjectives and an optional pointer
**	to a symbol which is an enumeration, structure, union which is the type
**	of this TYPE.
*/
#define	TY_BTYPE(P)		((P)->ty_bt)	/*  basic type  */
#define	TY_DTYPE(P)		((P)->ty_dtype)	/*  derived type  */
#define	TY_ESU(P)		((P)->ty_esu)	/*  ptr to parent enum/struct/union  */
#define	TY_INDIR(P)		((P)->ty_indir)	/*  indirection string  */
#define	TY_TINDEX(P)	((P)->ty_index)	/*  type index */
#define	TY_INEXT(P)		(INDIR_INEXT(TY_INDIR(P)))
#define	TY_ITYPE(P)		(INDIR_ITYPE(TY_INDIR(P)))
#define	TY_ISUB(P)		(INDIR_ISUB(TY_INDIR(P)))
#define	TY_IFORMALS(P)	(INDIR_IFORMALS(TY_INDIR(P)))
#define	TY_IFLIST(P)	(INDIR_IFLIST(TY_INDIR(P)))

typedef	struct	s_indir_entry	indir_entry_t;
typedef	struct	s_type_entry	type_entry_t;

struct	s_indir_entry	{
	indir_entry_t	*ind_next;
	indir_t			ind_type;
	};

struct	s_type_entry	{
	type_entry_t	*te_next;
	type_t			te_type;
	};

#define	TYPE_TABLE_SIZE		0x100
#define	INDIR_TABLE_SIZE	0x040
/*
**  HASH_MASK : is a value which consists of the bits in common
**  between upper and lower case. we mask each char we read with this
**  to sum them for a hash value. we do this so that all names consisting
**  of the same chars (case insensitive), will hash to the same location.
*/
#define	HASH_MASK			0x5f

#define	DATASEGMENT			0
#define	TEXTSEGMENT			1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcppext.h ===
extern	char 	Union_str[];
extern	char 	Struct_str[];
extern	char 	Cdecl_str[];
extern	char 	Cdecl1_str[];
extern	char 	Fortran_str[];
extern	char 	Fortran1_str[];
extern	char 	Pascal_str[];
extern	char 	Pascal1_str[];
extern	char 	PPelse_str[];
extern	char 	PPendif_str[];
extern	char 	PPifel_str[];
extern	char 	Syntax_str[];

extern	FILE	* ErrFile;
extern	FILE 	* Errfl;
extern	FILE	* OUTPUTFILE;

extern	char	* A_string;
extern	char	* Debug;
extern	char	* Input_file;
extern	char	* Output_file;
extern	char	* Q_string;
extern	char	* Version;
extern  char    * gpszNLSoptions;
extern	int		In_alloc_text;
extern	int		Bad_pragma;
extern	int		Cross_compile;
extern	int		Ehxtension;
extern	int		HugeModel;
extern	LIST	Defs;
extern	LIST	Includes;
extern	lextype_t yylval;
extern	token_t	Basic_token;
extern	char	* BTarray[];
extern	char	* Basename;
extern	char	* ErrFilName;
extern	char	* Path_chars;
extern	int		Char_align;
extern	int		Dump_tables;
extern	int		StunOpSeen;
extern	int		Inteltypes;
extern	int		List_type;
extern	int		Need_enddata;
extern	int		Nerrors;
extern	int		NoPasFor;

extern	int		Cmd_intrinsic;
extern	int		Cmd_pointer_check;
extern	int		Pointer_check;
extern	int		Cmd_stack_check;
extern	int		Stack_check;
extern	int		Cmd_loop_opt;
extern	int		Loop_opt;
extern	int		Cmd_pack_size;
extern	int		Pack_size;

extern	int		N_types;
extern	int		Got_type;
extern	int		Out_funcdef;
extern	int		Plm;
extern	int		Prep;
extern	int		Prep_ifstack;
extern	int		Ret_seen;
extern	int		Srclist;
extern	int		Stack_depth;
extern	int		Symbolic_debug;
extern	int		Table_index;
extern	int		Switch_check;
extern	int		Load_ds_with;
extern	int		Plmn;
extern	int		Plmf;
extern	int 	Cflag;
extern	int 	Eflag;
extern	int 	Jflag;
extern	int 	Pflag;
extern	int 	Rflag;
extern	int		ZcFlag;
extern	int		StunDepth;

extern	long	Enum_val;
extern	char	Size_of[];
extern	long	Max_ival[];
extern	table_t	*Table_stack[];

extern	int		Extension;

extern	char	*Filename;
extern	int		Linenumber;
extern	UCHAR	Filebuff[MED_BUFFER + 1];
extern	UCHAR	Reuse_1[BIG_BUFFER];
extern	hash_t	Reuse_1_hash;
extern	UINT	Reuse_1_length;
extern	UCHAR	Macro_buffer[BIG_BUFFER * 4];
extern	int		In_define;
extern	int		InIf;
extern	int		InInclude;
extern	int		Macro_depth;
extern	int		On_pound_line;
extern	int		Listing_value;
extern	token_t	Currtok;

extern	long		Currval;
extern	int		Comment_type;
extern	char		*Comment_string;
extern	int		Tiny_lexer_nesting;
extern	UCHAR		*Exp_ptr;
extern	int		ifstack[IFSTACK_SIZE];

extern unsigned char	Contmap[], Charmap[];

extern keytab_t		Tokstrings[];

#define EXTENSION	(Extension || Ehxtension)

/*** I/O Variable for PreProcessor ***/
extern	ptext_t	Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
extern char	Msg_Text[];
extern char *	Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcpptype.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* RCPPTYPE.H - Type definitions for RCPP				*/
/*									*/
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

/************************************************************************/
/* Define types for greater visibility and easier portability		*/
/************************************************************************/

#ifndef _WINDOWS_
typedef char		CHAR;
typedef unsigned char	BYTE;
typedef CHAR *		PCHAR;
typedef unsigned short  WCHAR;
typedef unsigned char	UCHAR;
typedef UCHAR *		PUCHAR;

typedef short		SHORT;
typedef SHORT *		PSHORT;
typedef unsigned short	USHORT;
typedef USHORT *	PUSHORT;

typedef int		INT;
typedef INT		BOOL;
typedef INT *		PINT;
typedef unsigned int	UINT;
typedef UINT *		PUINT;

typedef long		LONG;
typedef LONG *		PLONG;
typedef unsigned long	ULONG;
typedef ULONG *		PULONG;

typedef void		VOID;
typedef VOID *		PVOID;
#endif

typedef double		DOUBLE;
typedef DOUBLE *	PDOUBLE;


/************************************************************************/
/*									*/
/* Define internal types						*/
/*									*/
/************************************************************************/

#define	TRUE	1
#define FALSE	0

#define EXTERN	extern
#define REG	register
#define STATIC	static


#define	BIG_BUFFER	512
#define MED_BUFFER	256
#define SMALL_BUFFER	128
#define TINY_BUFFER	32
#define MSG_BUFF_SIZE	256
#define IFSTACK_SIZE	TINY_BUFFER


/*
**	some commonly used typdefs for scalar items
*/
typedef	UINT		p1key_t;
typedef	UCHAR		hash_t;
typedef	UCHAR		token_t;
typedef	UCHAR		shape_t;

typedef	UCHAR		blknum_t;	/*  lexical level  */
typedef	UCHAR		class_t;

typedef	USHORT	btype_t;	/*  basic type specifier  */
typedef	USHORT	refcnt_t;	/*  symbol's reference count  */
typedef	USHORT	hey_t;		/*  unique keys  */
typedef	USHORT	offset_t;	/*  members offset within a struct  */

typedef	ULONG		abnd_t;		/*  array bound type  */
typedef	ULONG 	len_t;		/*  number of bytes/bits of member/field  */

typedef	struct	s_adj		symadj_t;
typedef	struct	s_defn		defn_t;
typedef	struct	s_flist		flist_t;
typedef	struct	s_indir		indir_t;
typedef	struct	s_stack		stack_t;
typedef	struct	s_sym		sym_t;
typedef	struct	s_table		table_t;
typedef	struct	s_toklist	toklist_t;
typedef	struct	s_tree		tree_t;
typedef	struct	s_type		type_t;
typedef	struct	s_case		case_t;

typedef	union	u_ivalue	ivalue_t;

/*
**	abstract char pointer types
*/
typedef	PUCHAR		ptext_t;	/* wherever input text comes from */ 

/*
**	other abstract pointer types
*/
typedef	type_t *	ptype_t;		/* ptr to types */
typedef	indir_t *	pindir_t;		/* ptr to indirections */
typedef	flist_t *	pflist_t;		/* ptr to formal list type */
typedef	sym_t *		psym_t;		/* symbol ptrs */
typedef	defn_t *	pdefn_t;		/* #define names */

typedef	tree_t *	ptree_t;


typedef struct s_realt {
    LONG	S_sizet;
    DOUBLE	S_realt;
} Srealt_t;


/* declspec type */
struct s_declspec {
    class_t ds_calss;
    ptype_t ds_type;
};
typedef struct s_declspec	declspec_t;
typedef	declspec_t *		pdeclspec_t;


/* string type */
struct s_string {
    CHAR *	str_ptr;
    USHORT	str_len;
};
typedef struct s_string		string_t;
typedef string_t *		pstring_t;


/* rcon type */
struct rcon {
    Srealt_t	rcon_real;
};
typedef struct rcon		rcon_t;
typedef struct rcon *		prcon_t;


/* hln type */
struct s_hln {
    PCHAR hln_name;
    UCHAR hln_hash;
    UCHAR hln_length;
};
typedef	struct	s_hln		hln_t;
typedef	hln_t *			phln_t;


/*
**	union used to return values from the lexer
*/
typedef	union	s_lextype	{
	btype_t		yy_btype;
	PCHAR		yy_cstr;
	int			yy_int;
	int			yy_class;
	long		yy_long;
	hln_t		yy_ident;
	declspec_t	yy_declspec;
	string_t	yy_string;
	psym_t		yy_symbol;
	token_t		yy_token;
	ptree_t		yy_tree;
	ptype_t		yy_type;
	} lextype_t;

/* value_t definition */
union u_value {
    prcon_t	v_rcon;
    long	v_long;
    string_t	v_string;
    psym_t	v_symbol;
};
typedef	union	u_value		value_t;

/* keytab_t definition */
typedef struct {
    char *	k_text;
    UCHAR	k_token;
} keytab_t;


/************************************************************************/
/* LIST definition for \D values					*/
/************************************************************************/
#define	MAXLIST	100

typedef struct LIST {
	INT	li_top;
	CHAR *	li_defns[MAXLIST];
} LIST;

#define UNREFERENCED_PARAMETER(x) (x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcppdecl.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* RCPPDECL.H - RCPP function prototype declarations			*/
/*									*/
/* 04-Dec-90 w-BrianM  Created						*/
/*									*/
/************************************************************************/

/************************************************************************/
/* ERROR.C								*/
/************************************************************************/
void error	(int);
void fatal	(int);
void warning	(int);

/************************************************************************/
/* GETMSG.C								*/
/************************************************************************/
char * GET_MSG	(int);
void __cdecl SET_MSG	(char *, char *, ...);

/************************************************************************/
/* GETFLAGS.C								*/
/************************************************************************/
#if i386 == 1
int crack_cmd	(struct cmdtab *, char *, char *(*)(void), int);
#else /* MIPS */
struct cmdtab;
int crack_cmd	(struct cmdtab *, char *, char *(*)(void), int);
#endif /* i386 */

/************************************************************************/
/* LTOA.C								*/
/************************************************************************/
int zltoa	(long, char *, int);

/************************************************************************/
/* P0EXPR.C								*/
/************************************************************************/
long do_constexpr	(void);

/************************************************************************/
/* P0GETTOK.C								*/
/************************************************************************/
token_t		yylex(void);
int		lex_getid (UCHAR);

/************************************************************************/
/* P0IO.C								*/
/************************************************************************/
void		emit_line (void);
UCHAR		fpop (void);
unsigned short 		wchCheckWideChar (void);
int		io_eob (void);
int		newinput (char *, int);
int		nested_include (void);
void		p0_init (PCHAR, PCHAR, LIST *);

/************************************************************************/
/* P0KEYS.C								*/
/************************************************************************/
token_t		is_pkeyword (char *);

/************************************************************************/
/* P0MACROS.C								*/
/************************************************************************/
int		can_get_non_white (void);
int		can_expand (pdefn_t);
void 		define (void);
void		definstall (ptext_t, int, int);
pdefn_t		get_defined (void);
int		handle_eos (void);
int		tl_getid (UCHAR);
void		undefine (void);

/************************************************************************/
/* P0PREPRO.C								*/
/************************************************************************/
int		do_defined (PUCHAR);
int		nextis (token_t);
void		preprocess (void);
void		skip_cnew (void);
void		skip_NLonly (void);

/************************************************************************/
/* P1SUP.C								*/
/************************************************************************/
ptree_t		build_const (token_t, value_t *);

/************************************************************************/
/* RCPPUTIL.C								*/
/************************************************************************/
char *		pstrdup (char *);
char *		pstrndup (char *, int);
char *		strappend (char *, char *);

/************************************************************************/
/* SCANNER.C								*/
/************************************************************************/
token_t		char_const (void);
int		checknl (void);
int		checkop (int);
void		do_newline (void);
void		dump_comment (void);
void		DumpSlashComment (void);
void		getid (UINT);
UCHAR		get_non_eof (void);
token_t		getnum (UCHAR);
token_t		get_real (PUCHAR);
hash_t		local_c_hash (char *);
void		prep_string (UCHAR);
UCHAR		skip_cwhite (void);
int		skip_comment (void);
void		str_const (void);

/************************************************************************/
/* P0 I/O MACROS							*/
/************************************************************************/
#define	GETCH()		(*Current_char++)
#define	CHECKCH()	(*Current_char)
#define	UNGETCH()	(Current_char--)
#define	PREVCH()	(*(Current_char - 1))
#define	SKIPCH()	(Current_char++)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\strings.h ===
#define RCON_REAL(p)	((p)->rcon_real)

/*
**  given a VALUE ptr, return the various fields.
*/
#define	PV_RCON(P)		((P)->v_rcon)
#define	PV_DOUBLE(P)	(PV_RCON(P)->rcon_real)
#define	PV_LONG(P)		((P)->v_long)
#define	PV_STRPTR(P)	((P)->v_string.str_ptr)
#define	PV_STRLEN(P)	((P)->v_string.str_len)
#define PV_SYM(P)		((P)->v_symbol)
/*
**  given a reference to a VALUE, return the given field
*/
#define	V_RCON(V)	((V).v_rcon)
#define	V_DOUBLE(V)	(V_RCON(V)->rcon_real)
#define	V_LONG(V)	((V).v_long)
#define	V_STRPTR(V)	((V).v_string.str_ptr)
#define	V_STRLEN(V)	((V).v_string.str_len)
#define V_SYM(V)	((V).v_symbol)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rcpp 16-bit unicode support.  It contains
	the translatation table for codepage 1252.  This was taken from the
	nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#ifndef __RCUNICOD

#define __RCUNICOD

#define IN
#define OUT


#define DFT_TEST_SIZE			10	// The number of words to test to get
									// an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN		0	// File type not yet determined.
#define DFT_FILE_IS_8_BIT		1	// File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT		2	// File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV	3	// File is reversed 16-bit unicode file.

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      FILE	*fpInputFile
    );

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN	1	// Return values from determine system
#define DSE_SYS_BIG_ENDIAN		2	// endian type.

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
	VOID
    );


#endif  // __RCUNICOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
    Note that as of Aug 91, rcpp will not fully transfer the unicode
    characters but only the string constants are guaranteed to be passed
    cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include <stdio.h>
#include <ctype.h>
#include <process.h>
#include "windows.h"
#include "rcunicod.h"


INT
DetermineFileType (
                  IN      FILE    *fpInputFile
                  )

/*++

Routine Description:

    This function is used to determine what type of file is being read.
    Note that it assumes that the first few bytes of the given file contain
    mostly ascii characters.  This routine was originally intended for use
    on .rc files and include files.
    Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile			- File pointer to file we are checking, must be
                          open with read permissions.

Return Value:

    DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
                              we were checking.  This usually happens when EOF
                              is unexpectedly reached.
    DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
                              format.
    DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
                              which can be directly read into a WCHAR array.
    DFT_FILE_IS_16_BIT_REV  - File was determined to be a 16 bit unicode file
                              which has it's bytes reversed in order.

--*/

{
    CHAR    rgchTestBytes [DFT_TEST_SIZE << 2]; // Storage for test data.
    INT     cNumberBytesTested = 0;         // Test information.
    INT     cNumberOddZerosFound = 0;
    INT     cNumberEvenZerosFound = 0;
    INT     cNumberAsciiFound = 0;
    INT     cCountRead;                     // Temp storage for count read.
    LONG    lStartFilePos;                  // Storage for file position.
    INT     fSysEndianType;                 // System endian type.
    INT     fFileType = DFT_FILE_IS_UNKNOWN;// File type, when found.

    fSysEndianType = DetermineSysEndianType ();

    //
    // Store position so we can get back to it.
    //
    lStartFilePos = ftell (fpInputFile);

    //
    // Make sure we start on an even byte to simplify routines.
    //
    if (lStartFilePos % 2) {

        fgetc (fpInputFile);
    }

    do {
        INT     wT;

        //
        // Read in the first test segment.
        //

        cCountRead = fread (rgchTestBytes, sizeof (CHAR), DFT_TEST_SIZE << 2,
                            fpInputFile);

        //
        // Determine results and add to totals.
        //

        for (wT = 0; wT < cCountRead; wT++) {

            if (rgchTestBytes [wT] == 0) {

                if (wT % 2) {

                    cNumberOddZerosFound++;

                } else {

                    cNumberEvenZerosFound++;
                }
            }

            if (isprint (rgchTestBytes [wT]) ||
                rgchTestBytes[wT] == '\t' ||
                rgchTestBytes[wT] == '\n' ||
                rgchTestBytes[wT] == '\r' ) {

                cNumberAsciiFound++;
            }
        }

        cNumberBytesTested += cCountRead;

        //
        // Check if we have a definite pattern.
        //

        {
            INT     cMajorityTested;        // 80% of the bytes tested.

            cMajorityTested = cNumberBytesTested << 2;
            cMajorityTested /= 5;

            if (cNumberAsciiFound > cMajorityTested) {

                fFileType = DFT_FILE_IS_8_BIT;

            } else if (cNumberOddZerosFound > (cMajorityTested >> 1)) {

                //
                // File type was determined to be little endian.
                // If system is also little endian, byte order is correct.
                //
                fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ?
                            DFT_FILE_IS_16_BIT : DFT_FILE_IS_16_BIT_REV;

            } else if (cNumberEvenZerosFound > (cMajorityTested >> 1)) {

                //
                // File type was determined to be big endian.
                // If system is also big endian, byte order is correct.
                //
                fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ?
                            DFT_FILE_IS_16_BIT_REV : DFT_FILE_IS_16_BIT;

            }
        }

    } while (cCountRead == (DFT_TEST_SIZE << 2) &&
             fFileType == DFT_FILE_IS_UNKNOWN);

    //
    // Return to starting file position.  (usually beginning)
    //

    if (fseek (fpInputFile, lStartFilePos, SEEK_SET) == -1)
        fFileType = DFT_FILE_IS_UNKNOWN;

    return (fFileType);
}


INT
DetermineSysEndianType (
                       VOID
                       )

/*++

Routine Description:

    This function is used to determine how the current system stores its
    integers in memory.

    For those of us who are confused by little endian and big endian formats,
    here is a breif recap.

    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
         is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80

    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high order bytes of a short or long are stored lower
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            80
             01            40
             02            20
             03            10
       This looks correct when memory is dumped in order: 80 40 20 10

Arguments:

    None.

Return Value:

    DSE_SYS_LITTLE_ENDIAN   - The system stores integers in little endian
                              format.  (this is 80x86 default).
    DSE_SYS_BIG_ENDIAN  	- The system stores integers in big endian format.

--*/

{
    INT     nCheckInteger;
    CHAR    rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT *)rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (UCHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT *)rgchTestBytes);

    //
    // See if value was stored in low order of integer.
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF) {

        return (DSE_SYS_LITTLE_ENDIAN);
    } else {

        return (DSE_SYS_LITTLE_ENDIAN);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\scanner.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* SCANNER.C - Routines for token scanning				*/
/*									*/
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <limits.h>
#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"
#include "charmap.h"
#include "grammar.h"
#include "rcunicod.h"


#define ABS(x) ((x > 0) ? x : -1 * x)


#define ALERT_CHAR	'\007'		/* ANSI alert character is ASCII BEL */

extern int vfCurrFileType;	//- Added for 16-bit file support.


/************************************************************************/
/* Local Function Prototypes						*/
/************************************************************************/
token_t	c_size(long);
int	ctoi(int);
int	escape(int);
token_t	get_real(PUCHAR);
token_t	l_size(long);
long	matol(PUCHAR, int);
token_t	uc_size(long);
token_t	ul_size(long);
void	skip_1comment(void);



/************************************************************************/
/* local_c_hash								*/
/************************************************************************/
hash_t	local_c_hash(REG char *name)
{
    REG	hash_t 	i;

    i = 0;
    while(*name) {
	i += (*name & HASH_MASK);
	name++;
    }
    return(i);
}


/************************************************************************ 
 * GETID - Get an identifier or keyword.
 * (we know that we're given at least 1 id char)
 * in addition, we'll hash the value using 'c'.
 ************************************************************************/
void getid(REG	UINT	c)
{
    REG	UCHAR	*p;

    p = Reuse_1;
    *p++ = (UCHAR)c;
    c &= HASH_MASK;

repeat:
    while(LXC_IS_IDENT(*p = GETCH())) {    /* while it's an id char . . . */
	c += (*p & HASH_MASK);			/* hash it */
	p++;
    }
    if(*p != EOS_CHAR) {
	if((*p == '\\') && (checknl())) {
	    goto repeat;
	}
	UNGETCH();
	if(p >= LIMIT(Reuse_1)) {
	    Msg_Temp = GET_MSG (1067);
	    SET_MSG (Msg_Text, Msg_Temp);
	    fatal(1067);
	}
	if(	((p - Reuse_1) > LIMIT_ID_LENGTH) && ( ! Prep )) {
	    p = Reuse_1 + LIMIT_ID_LENGTH;
	    *p++ = '\0';
	    c = local_c_hash(Reuse_1);
	    Msg_Temp = GET_MSG (4011);
	    SET_MSG (Msg_Text, Msg_Temp, Reuse_1);
	    warning(4011);	/* id truncated */
	}
	else {
	    *p++ = '\0';
	}
	Reuse_1_hash = (UCHAR)c;
	Reuse_1_length = (UCHAR)(p - Reuse_1);
	return;
    }
    if(io_eob()) {			/* end of file in middle of id */
	Msg_Temp = GET_MSG (1004);
	SET_MSG (Msg_Text, Msg_Temp);
	fatal(1004);
    }
    goto repeat;
}


/************************************************************************
**	prep_string : outputs char/string constants when preprocessing only
************************************************************************/
void   prep_string(REG UCHAR c)
{
    REG char *p_buf;
    int term_char;

    p_buf = Reuse_1;
    term_char = c;

    *p_buf++ = c;		/*  save the open quote  */

    //-
    //- The following check was added to support 16-bit files.
    //- For the 8-bit file, the code has not changed at all.
    //-
    if (vfCurrFileType == DFT_FILE_IS_8_BIT) {

	for(;;) {
	    switch(CHARMAP(c = GETCH())) {
	    case LX_DQUOTE:
	    case LX_SQUOTE:
		if(c == (UCHAR)term_char) {
		    *p_buf++ = (UCHAR)term_char;/* save the terminating quote */
		    goto out_of_loop;
		}
		break;
	    case LX_BACKSLASH:
	    case LX_LEADBYTE:
		*p_buf++ = c;
		c = get_non_eof();
		break;
	    case LX_CR:								
		continue;
	    case LX_NL:		
		UNGETCH();				
		goto out_of_loop;
	    case LX_EOS:
		if(c == '\\') {
		    *p_buf++ = c;
		    c = get_non_eof();
		    break;
		}
		handle_eos();
		continue;
		break;
	    }
	    *p_buf++ = c;
	    if(p_buf == &Reuse_1[MED_BUFFER - 1]) {
		*p_buf = '\0';
		fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
		p_buf = Reuse_1;
	    }
	}

    } else {

	WCHAR 	wchCurr;

	for(;;) {

	    wchCurr = (WCHAR)wchCheckWideChar ();
	    c = GETCH ();    //- Make sure buffers increment normally.

	    if (wchCurr < 127) {

		switch(CHARMAP(c)) {

		case LX_DQUOTE:
		case LX_SQUOTE:
		    if(c == (UCHAR)term_char) {
			*p_buf++ = (UCHAR)term_char;/* save the quote */
			goto out_of_loop;
		    }
		    break;
		case LX_BACKSLASH:
		    *p_buf++ = c;
		    break;
		case LX_CR:
		    continue;
		case LX_NL:		
		    UNGETCH();				
		    goto out_of_loop;
		case LX_EOS:
		    handle_eos ();
		    continue;
		}

		*p_buf++ = c;

	    } else {

		//- Write out as 6 octal characters.
		//- This is the safest way to do it.

		*p_buf++ = '\\';
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 15) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 12) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 9) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 6) & 7));
		*p_buf++ = (CHAR)('0' + ((wchCurr >> 3) & 7));
		*p_buf++ = (CHAR)('0' + (wchCurr & 7));
	    }

	    if(p_buf > &Reuse_1[MED_BUFFER - 10]) {
		*p_buf = '\0';
		fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
		p_buf = Reuse_1;
	    }
	}
    }

out_of_loop:
	*p_buf = '\0';
	fwrite(Reuse_1, (size_t)(p_buf - Reuse_1), 1, OUTPUTFILE);
}


/************************************************************************
**	char_const : gather up a character constant
**  we're called after finding the openning single quote.
************************************************************************/
token_t char_const(void)
{
    REG UCHAR c;
    value_t value;
    token_t	tok;

    tok = (token_t)(Jflag ? L_CUNSIGNED : L_CINTEGER);
first_switch:
    switch(CHARMAP(c = GETCH())) {
    case LX_BACKSLASH:
	break;
    case LX_SQUOTE:
	Msg_Temp = GET_MSG (2137);
	SET_MSG (Msg_Text, Msg_Temp); /* empty character constant */
	error(2137);
	value.v_long = 0;
	UNGETCH();
	break;
    case LX_EOS:		/* ??? assumes i/o buffering > 1 char */
	if(handle_eos() != BACKSLASH_EOS) {
	    goto first_switch;
	}
	value.v_long = escape(get_non_eof());
	if( tok == L_CUNSIGNED ) {		/* don't sign extend */
	    value.v_long &= 0xff;
	}
	break;
    case LX_NL:
	/* newline in character constant */
	Msg_Temp = GET_MSG (2001);
	SET_MSG(Msg_Text, Msg_Temp);
	error (2001);
	UNGETCH();
	/*
		**  FALLTHROUGH
		*/
    default:
	value.v_long = c;
	break;
    }
    if((c = get_non_eof()) != '\'') {
	Msg_Temp = GET_MSG (2015);
	SET_MSG (Msg_Text, Msg_Temp);
	error (2015);		/* too many chars in constant */
	do {
	    if(c == '\n') {
		Msg_Temp = GET_MSG (2016);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2016);		/* missing closing ' */
		    break;
	    }
	} while((c = get_non_eof()) != '\'');
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**	str_const : gather up a string constant
************************************************************************/
void   str_const(VOID)
{
    REG UCHAR c;
    REG PUCHAR	p_buf;
    int not_warned_yet = TRUE;

    p_buf = yylval.yy_string.str_ptr = Macro_buffer;
    /*
	**	Is it possible that reading this string during a rescan will
	**	overwrite the expansion being rescanned?  No, because a macro
	**	expansion is limited to the top half of Macro_buffer.  
	**	For Macro_depth > 0, this is like copying the string from 
	**	somewhere in the top half of Macro_buffer to the bottom half
	**	of Macro_buffer.
	**	Note that the restriction on the size of an expanded macro is
	**	stricter than the limit on an L_STRING length.  An expanded
	**	macro is limited to around 1019 bytes, but an L_STRING is
	**	limited to 2043 bytes.
	*/
    for(;;) {
	switch(CHARMAP(c = GETCH())) {
	case LX_NL:
	    UNGETCH();
	    Msg_Temp = GET_MSG (2001);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error(2001);
	    /*
			**  FALLTHROUGH
			*/
	case LX_DQUOTE:
	    *p_buf++ = '\0';
	    yylval.yy_string.str_len = (USHORT)(p_buf-yylval.yy_string.str_ptr);
	    return;
	    break;
	case LX_LEADBYTE:
	    *p_buf++ = c;
	    c = get_non_eof();
	    break;
	case LX_EOS:
	    if(handle_eos() != BACKSLASH_EOS) {
		continue;
	    }
	    if(InInclude) {
		break;
	    }
	    else {
		c = (UCHAR)escape(get_non_eof());  /* process escaped char */
	    }
	    break;
	}
	if(p_buf - Macro_buffer > LIMIT_STRING_LENGTH) {
	    if( not_warned_yet ) {
		Msg_Temp = GET_MSG (4009);
		SET_MSG (Msg_Text, Msg_Temp);
		warning(4009);		/* string too big, truncating */
		not_warned_yet = FALSE;
	    }
	}
	else {
	    *p_buf++ = c;
	}
    }
}


/************************************************************************
**  do_newline : does work after a newline has been found.
************************************************************************/
void   do_newline()
{
    ++Linenumber;
    for(;;) {
	switch(CHARMAP(GETCH())) {
	case LX_CR:						
	    break;
	case LX_POUND:	
	    preprocess();	
	    break;
	case LX_SLASH:
	    if( ! skip_comment()) {
		goto leave_do_newline;
	    }
	    break;
	case LX_NL:
	    Linenumber++;
	    /*
			**  FALLTHROUGH
			*/
	case LX_WHITE:
	    if( Prep ) {	/*  preprocessing only, output whitespace  */
		fputc(PREVCH(), OUTPUTFILE);
	    }
	    else {
		do {
		    ;
		} while(LXC_IS_WHITE(GETCH()));
		UNGETCH();
	    }
	    break;
	case LX_EOS:
	    if(PREVCH() == EOS_CHAR || PREVCH() == CONTROL_Z) {
		if(io_eob()) {		/* leaves us pointing at a valid char */
		    return;
		}
		break;
	    }
	    if(checknl()) {
		continue;
	    }
	    /* it's a backslash */
	    /*
			**	FALLTHROUGH
			*/
	default:		/* first non-white is not a '#', leave */

leave_do_newline:

	    UNGETCH();
	    return;
	}
    }
}


/************************************************************************
 * GETNUM - Get a number from the input stream.
 *
 * ARGUMENTS
 *	radix - the radix of the number to be accumulated.  Can only be 8, 10,
 *			or 16
 *	pval - a pointer to a VALUE union to be filled in with the value
 *
 * RETURNS - type of the token (L_CINTEGER or L_CFLOAT)
 *
 * SIDE EFFECTS - 
 *	does push back on the input stream.
 *	writes into pval by reference
 *  uses buffer Reuse_1
 *
 * DESCRIPTION - 
 *	Accumulate the number according to the rules for each radix.
 *	Set up the format string according to the radix (or distinguish
 *	integer from float if radix is 10) and convert to binary.
 *
 * AUTHOR - Ralph Ryan, Sept. 8, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
token_t getnum(REG	UCHAR		c)
{
    REG	char	*p;
    UCHAR	*start;
    int		radix;
    token_t	tok;
    value_t	value;

    tok = L_CINTEGER;
    start = (Tiny_lexer_nesting ? Exp_ptr : Reuse_1);
    p = start;
    if( c == '0' ) {
	c = get_non_eof();
	if( IS_X(c) ) {
	    radix = 16;
	    if( Prep ) {
		*p++ = '0';
		*p++ = 'x';
	    }
	    for(c = get_non_eof(); LXC_IS_XDIGIT(c); c = get_non_eof()) {
		/* no check for overflow? */
		*p++ = c;
	    }
	    if((p == Reuse_1) && (Tiny_lexer_nesting == 0)) {
		Msg_Temp = GET_MSG (2153);
		SET_MSG (Msg_Text, Msg_Temp);
		error(2153);
	    }
	    goto check_suffix;
	}
	else {
	    radix = 8;
	    *p++ = '0';	/* for preprocessing or 0.xxx case */
	}
    }
    else {
	radix = 10;
    }

    while( LXC_IS_DIGIT(c) ) {
	*p++ = c;
	c = get_non_eof();
    }

    if( IS_DOT(c) || IS_E(c) ) {
	UNGETCH();
	return(get_real(p));
    }

check_suffix:
    if( IS_EL(c) ) {
	if( Prep ) {
	    *p++ = c;
	}
	c = get_non_eof();
	if( IS_U(c) ) {
	    if(Prep) {
		*p++ = c;
	    }
	    tok = L_LONGUNSIGNED;
	}
	else {
	    tok = L_LONGINT;
	    UNGETCH();
	}
    }
    else if( IS_U(c) ) {
	if( Prep ) {
	    *p++ = c;
	}
	c = get_non_eof();
	if( IS_EL(c) ) {
	    if( Prep ) {
		*p++ = c;
	    }
	    tok = L_LONGUNSIGNED;
	}
	else {
	    tok = L_CUNSIGNED;
	    UNGETCH();
	}
    }
    else {
	UNGETCH();
    }
    *p = '\0';
    if( start == Exp_ptr ) {
	Exp_ptr = p;
	return(L_NOTOKEN);
    }
    else if( Prep ) {
	fwrite( Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
	return(L_NOTOKEN);
    }
    value.v_long = matol(Reuse_1,radix);
    switch(tok) {
    case L_CINTEGER:
	tok = (radix == 10)
	    ? c_size(value.v_long)
	    : uc_size(value.v_long)
	    ;
	break;
    case L_LONGINT:
	tok = l_size(value.v_long);
	break;
    case L_CUNSIGNED:
	tok = ul_size(value.v_long);
	break;
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**  get_real : gathers the real part/exponent of a real number.
**		Input  : ptr to the null terminator of the whole part
**				 pointer to receive value.
**		Output : L_CFLOAT
**
**  ASSUMES whole part is either at Exp_ptr or Reuse_1.
************************************************************************/
token_t	   get_real(REG	PUCHAR p)
{
    REG	int		c;
    token_t	tok;

    c = get_non_eof();
    if(Cross_compile && (Tiny_lexer_nesting == 0)) {
	Msg_Temp = GET_MSG (4012);
	SET_MSG (Msg_Text, Msg_Temp);
	warning(4012);	/* float constant in cross compilation */
	Cross_compile = FALSE;	/*  only one msg per file */
    }
    /*
**  if the next char is a digit, then we've been called after
**  finding a '.'. if this is true, then
**  we want to find the fractional part of the number.
**  if it's a '.', then we've been called after finding
**  a whole part, and we want the fraction.
*/
    if( LXC_IS_DIGIT(c) || IS_DOT(c) ) {
	do {
	    *p++ = (UCHAR)c;
	    c = (int)get_non_eof();
	} while( LXC_IS_DIGIT(c) );
    }
    if( IS_E(c) ) {			/*  now have found the exponent  */
	*p++ = (UCHAR)c;		/*  save the 'e'  */
	c = (UCHAR)get_non_eof();	/*  skip it  */
	if( IS_SIGN(c) ) {		/*  optional sign  */
	    *p++ = (UCHAR)c;		/*  save the sign  */
	    c = (int)get_non_eof();
	}
	if( ! LXC_IS_DIGIT(c)) {
	    if( ! Rflag ) {
	        if(Tiny_lexer_nesting == 0) {
		    Msg_Temp = GET_MSG (2021);
		    SET_MSG (Msg_Text, Msg_Temp, c);
		    error(2021); /* missing or malformed exponent */
	        }
	        *p++ = '0';
	    }
	}
	else {
	    do {			/* gather the exponent */
		*p++ = (UCHAR)c;
		c = (int)get_non_eof();
	    } while( LXC_IS_DIGIT(c) );
	}
    }
    if( IS_F(c) ) {
	tok = L_CFLOAT;
	if( Prep ) {
	    *p++ = (UCHAR)c;
	}
    }
    else if( IS_EL(c) ) {
	tok = L_CLDOUBLE;
	if( Prep ) {
	    *p++ = (UCHAR)c;
	}
    }
    else {
	UNGETCH();
	tok = L_CDOUBLE;
    }
    *p = '\0';
    if( Tiny_lexer_nesting > 0 ) {
	Exp_ptr = p;
	return(L_NOTOKEN);
    }
    else if( Prep ) {
	fwrite( Reuse_1, (size_t)(p - Reuse_1), 1, OUTPUTFILE);
	return(L_NOTOKEN);
    }
    /*
	** reals aren't used during preprocessing
	*/
    return(tok);
}


/************************************************************************
**  matol : ascii to long, given a radix.
************************************************************************/
long	   matol(REG PUCHAR p_start,REG int radix)
{
    long	result, old_result;
    unsigned	int	i;

    old_result = result = 0;
    while(*p_start) {
	result *= radix;
	i = ctoi(*p_start);
	if( ((int)i >= radix) && (! Prep) ) {
	    Msg_Temp = GET_MSG (2020);
	    SET_MSG (Msg_Text, Msg_Temp, *p_start, radix);
	    error(2020); /* illegal digit % for base % */
	}
	result += i;
	p_start++;
	if(radix == 10) {
	    if(result < old_result) {
		p_start--;   /*  fix the string ptr since we have overflowed  */
		break;
	    }
	}
	else if(*p_start) {
	    /*
		**  the loop is not finished.
		**  we will multiply by the radix again
		**  check the upper bits. if they're on, then
		**  that mult will overflow the value
		*/
	    if(radix == 8) {
		if(result & 0xe0000000) {
		    break;
		}
	    }
	    else if(result & 0xf0000000) {
		break;
	    }
	}
	old_result = result;
    }
    if(*p_start) {
	Msg_Temp = GET_MSG (2177);
	SET_MSG (Msg_Text, Msg_Temp);
	error(2177);		/* constant too big */
	result = 0;
    }
    return(result);
}


/************************************************************************
**  uc_size : returns 'int' or 'long' (virtual unsigned).
**  if their are no bits in the upper part of the value,
**  then it's an int. otherwise, it's a long.
**  this is valid too if target sizeof(int) != sizeof(long).
**  then L_CINTEGER and L_LONGINT are synonymous.
************************************************************************/
token_t	uc_size(long value)
{
    return((token_t)((value > INT_MAX) ? L_CUNSIGNED : L_CINTEGER));
}


/************************************************************************
**  c_size : returns 'int' or 'long' for signed numbers.
**  if the sign bit of the lower word is on or any bits
**  in the upper word are on, then we must use 'long'.
************************************************************************/
token_t c_size(long value)
{
    return((token_t)((ABS(value) > INT_MAX) ? L_LONGINT : L_CINTEGER));
}


/************************************************************************
**  l_size : returns 'longint' or 'longunsigned' for long numbers.
**  if the sign bit of the high word is on this is 'longunsigned';
************************************************************************/
token_t	l_size(long	value)
{
    return((token_t)((value > LONG_MAX) ? L_LONGUNSIGNED : L_LONGINT));
}


/************************************************************************
**	ul_size : returns 'unsigned' or 'longunsigned' for unsigned numbers.
**	if the number can't be represented as unsigned, it is promoted to
**	unsignedlong.
************************************************************************/
token_t	ul_size(long value)
{
    return((token_t)((ABS(value) > UINT_MAX-1) ? L_LONGUNSIGNED : L_CUNSIGNED));
}


/************************************************************************
**  ctoi : character to int.
************************************************************************/
int	  ctoi(int	c)
{
    if(LXC_IS_DIGIT(c)) {
	return(c - '0');
    }
    else {
	return(toupper(c) - toupper('A') + 10);
    }
}


/************************************************************************
 * ESCAPE - get an escaped character
 *
 * ARGUMENTS - none
 *
 * RETURNS - value of escaped character
 *
 * SIDE EFFECTS - may push back input
 *
 * DESCRIPTION - An escape ( '\' ) was discovered in the input.  Translate
 *	 the next symbol or symbols into an escape sequence.
 *
 * AUTHOR - Ralph Ryan, Sept. 7, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int escape(REG int c)
{
    REG int value;
    int cnt;

escape_again:
    if( LXC_IS_ODIGIT(c) ) {/* \ooo is an octal number, must fit into a byte */
	cnt = 1;
	for(value = ctoi(c), c = get_non_eof();
	    (cnt < 3) && LXC_IS_ODIGIT(c);
	    cnt++, c = get_non_eof()
	    ) {
	    value *= 8;
	    value += ctoi(c);
	}
	if( ! Prep ) {
	    if(value > 255) {
		Msg_Temp = GET_MSG (2022);
		SET_MSG (Msg_Text, Msg_Temp, value);
		error (2022);
	    }
	}
	UNGETCH();
	return((char)value);
    }
    switch( c ) {
    case 'a':	
	return(ALERT_CHAR);	
	break;
    case 'b':	
	return('\b');		
	break;
    case 'f':	
	return('\f');		
	break;
    case 'n':	
	return('\n');		
	break;
    case 'r':	
	return('\r');		
	break;
    case 't':	
	return('\t');		
	break;
    case 'v':	
	return('\v');		
	break;
    case 'x':
	cnt = 0;
	value = 0;
	c = get_non_eof();
	while((cnt < 3) && LXC_IS_XDIGIT(c)) {
	    value *= 16;
	    value += ctoi(c);
	    c = get_non_eof();
	    cnt++;
	}
	if(cnt == 0) {
	    Msg_Temp = GET_MSG (2153);
	    SET_MSG (Msg_Text, Msg_Temp);
	    error (2153);
	}
	UNGETCH();
	return((char)value);	/* cast to get sign extend */
    default:
	if(c != '\\') {
	    return(c);
	}
	else {
	    if(checknl()) {
		c = get_non_eof();
		goto escape_again;
	    }
	    else {
		return(c);
	    }
	}
    }
}


/************************************************************************ 
 * CHECKOP - Check whether the next input character matches the argument.
 *
 * ARGUMENTS
 *	short op - the character to be checked against
 *
 * RETURNS  
 *	TRUE or FALSE
 *
 * SIDE EFFECTS  
 *	Will push character back onto the input if there is no match.
 *
 * DESCRIPTION  
 *	If the next input character matches op, return TRUE.  Otherwise
 *	push it back onto the input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int checkop(int op)
{
    if(op == (int)get_non_eof()) {
	return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}


/************************************************************************
**  DumpSlashComment : while skipping a comment, output it.
************************************************************************/
void   DumpSlashComment(VOID)
{
    if( ! Cflag ) {
	skip_NLonly();
	return;
    }
    fwrite("//", 2, 1, OUTPUTFILE);
    for(;;) {
	REG UCHAR c;

	switch(CHARMAP(c = GETCH())) {
	case LX_CR:								
	    continue;
	case LX_EOS:	
	    handle_eos();			
	    continue;
	case LX_NL:		
	    UNGETCH();				
	    return;
	}
	fputc(c, OUTPUTFILE);
    }
}


/************************************************************************
**  dump_comment : while skipping a comment, output it.
************************************************************************/
void   dump_comment()
{
    if( ! Cflag ) {
	skip_1comment();
	return;
    }
    fwrite("/*", 2, 1, OUTPUTFILE);
    for(;;) {
	REG UCHAR c;

	switch(CHARMAP(c = GETCH())) {
	case LX_STAR:
	    if(checkop('/')) {
		fwrite("*/", 2, 1, OUTPUTFILE);
		return;
	    }
	    break;
	case LX_EOS:	
	    handle_eos();			
	    continue;
	case LX_NL:		
	    Linenumber++;			
	    break;	/* output below */
	case LX_CR:								
	    continue;
	}
	fputc(c, OUTPUTFILE);
    }
}

/************************************************************************/
/* skip_comment()							*/
/************************************************************************/
int skip_comment(void)
{
    if(checkop('*')) {
	skip_1comment();
	return(TRUE);
    }
    else if(checkop('/')) {
	skip_NLonly();
	return(TRUE);
    }
    else {
	return(FALSE);
    }
}


/************************************************************************
**  skip_1comment : we're called when we're already in a comment.
**  we're looking for the comment close. we also count newlines
**  and output them if we're preprocessing.
************************************************************************/
void   skip_1comment(void)
{
    UINT	c;

    for(;;) {
	c = GETCH();
	if(c == '*') {

recheck:

	    c = GETCH();
	    if(c == '/') {	/* end of comment */
		return;
	    }
	    else if(c == '*') {
		/*
		**  if we get another '*' go back and check for a slash
		*/
		goto recheck;
	    }
	    else if(c == EOS_CHAR) {
		handle_eos();
		goto recheck;
	    }
	}
	/*
	**  note we fall through here. we know this baby is not a '*'
	**  we used to unget the char and continue. since we check for
	**  another '*' inside the above test, we can fall through here
	**  without ungetting/getting and checking again.
	*/
	if(c <= '\n') {
	    /*
	    **  hopefully, the above test is less expensive than doing two tests
	    */
	    if(c == '\n') {
		Linenumber++;
		if(Prep) {
		    fputc('\n', OUTPUTFILE);
		}
	    }
	    else if(c == EOS_CHAR) {
		handle_eos();
	    }
	}
    }
}


/************************************************************************
**  skip_cwhite : while the current character is whitespace or a comment.
**  a newline is NOT whitespace.
************************************************************************/
UCHAR	  skip_cwhite(void)
{
    REG	UCHAR		c;

skip_cwhite_again:
    while((c = GETCH()) <= '/') {	/* many chars are above this */
	if(c == '/') {
	    if( ! skip_comment()) {
		return('/');
	    }
	}
	else if(c > ' ') {		/* char is between '!' and '.' */
	    return(c);
	}
	else {
	    switch(CHARMAP(c)) {
	    case LX_EOS:
		handle_eos();
		break;
	    case LX_WHITE:	
		continue;	
		break;
	    case LX_CR:		
		continue;	
		break;
	    default:		
		return(c);	
		break;
	    }
	}
    }
    if((c == '\\') && (checknl())) {
	goto skip_cwhite_again;
    }
    return(c);
}


/************************************************************************
**  checknl : check for newline, skipping carriage return if there is one.
**  also increments Linenumber, so this should be used by routines which
**  will not push the newline back in such a way that rawtok() will be invoked,
**  find the newline and do another increment.
************************************************************************/
int checknl(void)
{
    REG	UCHAR		c;

    for(;;) {
	c = GETCH();
	if(c > '\r') {
	    UNGETCH();
	    return(FALSE);
	}
	switch(c) {
	case '\n':
	    Linenumber++;
	    if( Prep ) {
		fputc('\n', OUTPUTFILE);
	    }
	    return(TRUE);
	    break;
	case '\r':							
	    continue;		
	    break;
	case EOS_CHAR:
	    handle_eos();
	    PREVCH() = '\\';	/* M00HACK - needs pushback */
	    continue;
	    break;
	default:		
	    UNGETCH();			
	    return(FALSE);	
	    break;
	}
    }
}


/************************************************************************
**  get_non_eof : get a real char.
************************************************************************/
UCHAR	  get_non_eof(void)
{
    UCHAR		c;

get_non_eof_again:
    while((c = GETCH()) <= '\r') {
	if(c == '\r') {
	    continue;
	}
	else if(c != EOS_CHAR) {
	    break;
	}
	if(Tiny_lexer_nesting > 0) {
	    break;
	}
	handle_eos();
    }
    if((c == '\\') && (checknl())) {
	goto get_non_eof_again;
    }
    return(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\rcpputil.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* RCPPTIL.C - Utility routines for RCPP                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include <malloc.h>
#include <string.h>
#include "rcpptype.h"
#include "rcppdecl.h"

extern void     error(int);
extern char     Msg_Text[];
extern char *   Msg_Temp;

/************************************************************************
 * PSTRDUP - Create a duplicate of string s and return a pointer to it.
 ************************************************************************/
char *pstrdup(char *s)
{
    char *p = malloc(strlen(s)+1);
    if (p)
        return(strcpy(p, s));
    else
        return NULL;
}


/************************************************************************
**  pstrndup : copies n bytes from the string to a newly allocated
**  near memory location.
************************************************************************/
char * pstrndup(char *s, int n)
{
    char        *r;
    char        *res;

    r = res = malloc(n+1);
    if (res == NULL) {
        Msg_Temp = GET_MSG (1002);
        SET_MSG (Msg_Text, Msg_Temp);
        error(1002);
        return NULL;
    }
    while(n--) {
        *r++ = *s++;
    }
    *r = '\0';
    return(res);
}


/************************************************************************
**      strappend : appends src to the dst,
**  returns a ptr in dst to the null terminator.
************************************************************************/
char * strappend(register char *dst, register char *src)
{
    while ((*dst++ = *src++) != 0);
    return(--dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\tokdat.h ===
/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC
 * and inline assembler.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
/* token	TEXT		MAPPED TO 	IL OPCODE	ASM TOKEN */

DAT(L_NOTOKEN,	"newline",	L_NOTOKEN,	MAX_OPCODE,	ML_NL)
DAT(L_IDENT,	"identifier",	L_IDENT,	OPname,		ML_IDENT)
DAT(L_STRING,	"string",	L_STRING,	OPconstant,	ML_NOTOKEN)
DAT(L_CFLOAT,	"float constant", L_CONSTANT,	OPconstant,	ML_NOTOKEN)
DAT(L_CDOUBLE,	"double constant", L_CONSTANT,	OPconstant,	ML_NOTOKEN)
DAT(L_CLDOUBLE,	"long double constant",L_CONSTANT, OPconstant,	ML_NOTOKEN)
DAT(L_CINTEGER,	"int constant",	L_CONSTANT,	OPconstant,	ML_CONSTANT)
DAT(L_LONGINT,	"long constant", L_CONSTANT,	OPconstant,	ML_CONSTANT)
DAT(L_CUNSIGNED,"unsigned int constant",L_CONSTANT,OPconstant,	ML_CONSTANT)
DAT(L_LONGUNSIGNED,"unsigned long constant",L_CONSTANT,OPconstant,ML_CONSTANT)
DAT(L_AUTO,	"auto",		L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_STATIC,	"static",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_EXTERN,	"extern",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_REGISTER,	"register",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_TYPEDEF,	"typedef",	L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_FORTRAN,	Fortran_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_PASCAL,	Pascal_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_C,	Cdecl_str,	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_INTERRUPT,"interrupt",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_SAVEREGS,	"saveregs",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_LOADDS,	"loadds",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_EXPORT,	"export",	L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_ASM,	"_asm",		L_ASM,		MAX_OPCODE,	ML_NL)
DAT(L_NEAR,	"near",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_FAR,	"far",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_HUGE,	"huge",		L_MODIFIER,	MAX_OPCODE,	ML_IDENT)
DAT(L_CONST,	"const",	L_MODIFIER,	MAX_OPCODE,	ML_CDATATYPE)
DAT(L_VOLATILE,	"volatile",	L_MODIFIER,	MAX_OPCODE,	ML_CDATATYPE)
DAT(L_CHAR,	"char",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_INT,	"int",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_FLOAT,	"float",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_DOUBLE,	"double",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_SHORT,	"short",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_LONG,	"long",		L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_VOID,	"void",		L_TYPE,		MAX_OPCODE,	ML_IDENT)
DAT(L_SIGNED,	"signed",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_UNSIGNED,	"unsigned",	L_TYPE,		MAX_OPCODE,	ML_CDATATYPE)
DAT(L_ENUM,	"enum",		L_ENUM,		MAX_OPCODE,	ML_IDENT)
DAT(L_ENUM_TAG,	"enum tag",	L_ENUM_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_STRUCT,	"struct",	L_STRUCT,	MAX_OPCODE,	ML_IDENT)
DAT(L_STRUCT_TAG,"struct tag",	L_STRUCT_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_UNION,	"union",	L_UNION,	MAX_OPCODE,	ML_IDENT)
DAT(L_UNION_TAG,"union tag",	L_UNION_TAG,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_AND,	"&",		L_AND,		OPband,		ML_AND)
DAT(L_ANDAND,	"&&",		L_ANDAND,	OPandif,	ML_NOTOKEN)
DAT(L_ANDEQ,	"&=",		L_ASOP,		OPandeq,	ML_NOTOKEN)
DAT(L_ASSIGN,	"=",		L_ASSIGN,	OPassign,	ML_NOTOKEN)
DAT(L_BIT,	"bit field",	L_BIT,		OPbit,		ML_NOTOKEN)
DAT(L_COLON,	":",		L_COLON, 	OPcolon,	ML_COLON)
DAT(L_COMMA,	",", 		L_COMMA,	OPcomma,	ML_COMMA)
DAT(L_DECR,	"--",		L_INCOP,	OPpostdecr,	ML_NOTOKEN)
DAT(L_DIV,	"/",		L_DIVOP,	OPdiv,		ML_DIV)
DAT(L_DIVEQ,	"/=",		L_ASOP,		OPdiveq,	ML_NOTOKEN)
DAT(L_EQUALS,	"==",		L_EQUOP,	OPeq,		ML_EQ)
DAT(L_EXCLAIM,	"!",		L_EXCLAIM,	OPnot,		ML_NOTOKEN)
DAT(L_EXTRACT,	"*",		L_EXTRACT,	OPextract,	ML_NOTOKEN)
DAT(L_GT,	">",		L_RELOP,	OPgt,		ML_GT)
DAT(L_GTEQ,	">=",		L_RELOP,	OPge,		ML_GE)
DAT(L_INCR,	"++",		L_INCOP,	OPpostincr,	ML_NOTOKEN)
DAT(L_LBRACK,	"[",		L_LBRACK,	OPindex,	ML_LBRACK)
DAT(L_LSHFTEQ,	"<<=",		L_ASOP,		OPlsheq,	ML_NOTOKEN)
DAT(L_LSHIFT,	"<<",		L_SHIFTOP,	OPlshift,	ML_SHL)
DAT(L_LT,	"<",		L_RELOP,	OPlt,		ML_LT)
DAT(L_LTEQ,	"<=",		L_RELOP,	OPle,		ML_LE)
DAT(L_MINUS,	"-",		L_MINUS,	OPminus,	ML_SUB)
DAT(L_MINUSEQ,	"-=",		L_ASOP,		OPminuseq,	ML_NOTOKEN)
DAT(L_MOD,	"%",		L_DIVOP,	OPrem,		ML_MOD)
DAT(L_MODEQ,	"%=",		L_ASOP,		OPremeq,	ML_NOTOKEN)
DAT(L_MULT,	"*",		L_MULT,		OPmult,		ML_MUL)
DAT(L_MULTEQ,	"*=",		L_ASOP,		OPmulteq,	ML_NOTOKEN)
DAT(L_NOTEQ,	"!=",		L_EQUOP,	OPne,		ML_NE)
DAT(L_OR,	"|",		L_OR,		OPbor,		ML_OR)
DAT(L_OREQ,	"|=",		L_ASOP,		OPoreq,		ML_NOTOKEN)
DAT(L_OROR,	"||",		L_OROR,		OPorelse,	ML_NOTOKEN)
DAT(L_PERIOD,	".",		L_STUNOP,	OPfield,	ML_PERIOD)
DAT(L_PLUS,	"+",		L_PLUS,		OPplus,		ML_ADD)
DAT(L_PLUSEQ,	"+=",		L_ASOP,		OPpluseq,	ML_NOTOKEN)
DAT(L_POINTSTO,	"->",		L_STUNOP,	OPfield,	ML_NOTOKEN)
DAT(L_PREDECR,	"--",		L_INCOP,	OPminuseq,	ML_NOTOKEN)
DAT(L_PREINCR,	"++",		L_INCOP,	OPpluseq,	ML_NOTOKEN)
DAT(L_QUEST,	"?",		L_QUEST,	OPquestion,	ML_NOTOKEN)
DAT(L_RSHFTEQ,	">>=",		L_ASOP,		OPrsheq,	ML_NOTOKEN)
DAT(L_RSHIFT,	">>",		L_SHIFTOP,	OPrshift,	ML_SHR)
DAT(L_TILDE,	"~",		L_TILDE,	OPcompl,	ML_NOT)
DAT(L_UMINUS,	"unary minus",	L_UMINUS,	OPneg,		ML_NOTOKEN)
DAT(L_XOR,	"^",		L_XOR,		OPxor,		ML_XOR)
DAT(L_XOREQ,	"^=",		L_ASOP,		OPxoreq,	ML_NOTOKEN)
DAT(L_ARG,	"argument",	L_ARG,		OPargument,	ML_NOTOKEN)
DAT(L_ASOP,	"assign op",	L_ASOP,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_BREAK,	"break",	L_BREAK,	MAX_OPCODE,	ML_IDENT)
DAT(L_CASE,	"case",		L_CASE,		OPcase,		ML_IDENT)
DAT(L_CAST,	"cast",		L_CAST,		OPcast,		ML_NOTOKEN)
DAT(L_CLASS,	"storage class",L_CLASS,	MAX_OPCODE,	ML_IDENT)
DAT(L_CONSTANT,	"constant",	L_CONSTANT,	MAX_OPCODE,	ML_MAPPED)
DAT(L_CONTINUE,	"continue",	L_CONTINUE,	MAX_OPCODE,	ML_IDENT)
DAT(L_DEFAULT,	"default",	L_DEFAULT,	MAX_OPCODE,	ML_IDENT)
DAT(L_DIVOP,	"div op",	L_DIVOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_DO,	"do",		L_DO,		MAX_OPCODE,	ML_IDENT)
DAT(L_ELLIPSIS,	"...",		L_ELLIPSIS,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_ELSE,	"else",		L_ELSE,		MAX_OPCODE,	ML_IDENT)
DAT(L_ENTRY,	"entry",	L_ENTRY,	OPentry,	ML_NOTOKEN)
DAT(L_EOF,	"end of file",	0,		MAX_OPCODE,	ML_EOF)
DAT(L_EQUOP,	"equ op",	L_EQUOP,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_FILE,	0,		L_FILE,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_FOR,	"for",		L_FOR,		MAX_OPCODE,	ML_IDENT)
DAT(L_FUNCTION,	"argument",	L_FUNCTION,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_GOTO,	"goto",		L_GOTO,		MAX_OPCODE,	ML_IDENT)
DAT(L_IF,	"if",		L_IF,		MAX_OPCODE,	ML_IDENT)
DAT(L_INCOP,	"incr op",	L_INCOP,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_INIT,	"initializing",	L_INIT,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_LCURLY,	"{",		L_LCURLY,	MAX_OPCODE,	ML_LCURLY)
DAT(L_LINE,	"line",		L_LINE,		MAX_OPCODE,	ML_NOTOKEN)
DAT(L_LPAREN,	"(",		L_LPAREN,	OPfunction,	ML_LPAREN)
DAT(L_INTRINSIC,"intrinsic",	L_INTRINSIC,	OPintrinsic,	ML_NOTOKEN)
DAT(L_MODIFIER,	"modifier",	L_MODIFIER,	MAX_OPCODE,	ML_MAPPED)
DAT(L_MODULE,	"module",	L_MODULE,	MAX_OPCODE,	ML_NOTOKEN)
DAT(L_RBRACK,	"]",		L_RBRACK,	MAX_OPCODE,	ML_RBRACK)
DAT(L_RCURLY,	"}",		L_RCURLY,	MAX_OPCODE,	ML_NL)
DAT(L_RELOP,	"rel op",	L_RELOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_RETURN,	"return",	L_RETURN,	MAX_OPCODE,	ML_IDENT)
DAT(L_RPAREN,	")",		L_RPAREN,	MAX_OPCODE,	ML_RPAREN)
DAT(L_SELF,	"_self",	L_SELF,		OPself,		ML_IDENT)
DAT(L_SEMI,	";",		L_SEMI,		MAX_OPCODE,	ML_SEMI)
DAT(L_SHIFTOP,	"shift op",	L_SHIFTOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_SIZEOF,	"sizeof",	L_SIZEOF,	MAX_OPCODE,	ML_IDENT)
DAT(L_STUNOP,	"struct op",	L_STUNOP,	MAX_OPCODE,	ML_MAPPED)
DAT(L_SW,	"switch",	L_SW,		OPswitch,	ML_IDENT)
DAT(L_SWEXP,	0,		L_SWEXP,	OPswexp,	ML_NOTOKEN)
DAT(L_TYPE,	"type",		L_TYPE,		MAX_OPCODE,	ML_MAPPED)
DAT(L_TYPENAME,	"typedef name",	L_TYPENAME,	MAX_OPCODE,	ML_CTYPENAME)
DAT(L_UPLUS,	"unary plus", 	L_UPLUS,	OPparen,	ML_NOTOKEN)
DAT(L_WHILE,	"while",	L_WHILE,	MAX_OPCODE,	ML_IDENT)
DAT(0,	0,		0,	MAX_OPCODE,	ML_NOTOKEN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\tokens.c ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* TOKENS.C - Token stuff, probably removable from RCPP			*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/

#include <stdio.h>
#include "rcpptype.h"
#include "rcppext.h"
#include "grammar.h"

/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
keytab_t Tokstrings[] = {
#define	DAT(tok1, name2, map3, il4, mmap5)	{ name2, map3 },
#include "tokdat.h"
#undef DAT
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\symbols.h ===
/*
**  Symbol types . . .
*/
#define	SYMV_SYMBOL		0x001
#define	SYMV_RAWSYMBOL	0x002
#define	SYMV_FORMAL		0x004
#define	SYMV_SEGMENT	0x008

#define	SYMV_FUNCTION	0x010
#define	SYMV_INTRINSIC	0x020
#define	SYMV_LABEL		0x040

#define	SYMV_TAG		0x080
#define	SYMV_MOE		0x100
#define	SYMV_MEMBER		0x200
#define	SYMV_FIELD		0x400
#define	SYMV_OPC		0x800

#define	SYMV_ABSTRSYM	0x1000

#define	SYM_ISSYMBOL(p)		(SYM_ANYVTAG(p) & SYMV_SYMBOL)
#define	SYM_ISFUNCTION(p)	(SYM_ANYVTAG(p) & SYMV_FUNCTION)
#define	SYM_ISFORMAL(p)		(SYM_ANYVTAG(p) & SYMV_FORMAL)
#define	SYM_ISABSTRSYM(p)	(SYM_ANYVTAG(p) & SYMV_ABSTRSYM)
#define	SYM_ISLABEL(p)		(SYM_ANYVTAG(p) & SYMV_LABEL)
#define	SYM_ISTAG(p)		(SYM_ANYVTAG(p) & SYMV_TAG)
#define	SYM_ISMOE(p)		(SYM_ANYVTAG(p) & SYMV_MOE)
#define	SYM_ISMEMBER(p)		(SYM_ANYVTAG(p) & SYMV_MEMBER)
#define	SYM_ISFIELD(p)		(SYM_ANYVTAG(p) & SYMV_FIELD)
#define	SYM_ISINTRINSIC(p)	(SYM_ANYVTAG(p) & SYMV_INTRINSIC)
#define	SYM_ISRAWSYMBOL(p)	(SYM_ANYVTAG(p) & SYMV_RAWSYMBOL)
#define	SYM_ISSEGMENT(p)	(SYM_ANYVTAG(p) & SYMV_SEGMENT)
/*
**  parameter list types
*/
#define	NO_LIST		0
#define	EMPTY_LIST	1
#define	NAME_LIST	2
#define	PASCAL_LIST	3
#define	TYPE_LIST	4
/*
**  symbol storage classes
**  symbol adjectives, these have nothing to do with types.
*/
#define	SCundef		0
#define	SCauto		0x01
#define	SCextern	0x02
#define	SCregister	0x04
#define	SCstatic	0x08
#define	SCtypedef	0x10
#define	SCglobal	0x20
#define	SCabsolute	0x40
#define	SCreally	0x80	/* used w/ SCregister by p2 if it allocs a reg */

#define	SCp2stuff	SCreally

/*
**  symbol table sizes
*/
#define	LEVEL_0		0xff
#define	LEVEL_N		0x0f

struct	s_adj	{
	uchar_t	bit_0:1;
	uchar_t	bit_1:1;
	uchar_t	bit_2:1;
	uchar_t	bit_3:1;

	uchar_t	bit_4:1;
	uchar_t	bit_5:1;
	uchar_t	bit_6:1;
	uchar_t	bit_7:1;

	uchar_t	bit_8:1;
	uchar_t	bit_9:1;
	uchar_t	bit_10:1;
	uchar_t	bit_11:1;

	uchar_t	bit_12:1;
	uchar_t	bit_13:1;
	uchar_t	bit_14:1;
	uchar_t	bit_15:1;
	};

#if VERS_DEBUG
/*
 * d=DEFINED o=OUTPUT S=INASEGMENT n=NEAR
 * v=VISIBLE p=PASCAL i=INIT s=STRING
 * N=HASANAMELIST E=DEFNBEFOREUSE C=CODESEGNAME D=DATASEGNAME
 * B=ISBACKREF F=FORWARDREF
 */
#define	SYM_ADJFMT				"??FBDCENsipvnSod"	/* prword() fmt */
#endif

#define	IS_INVISIBLE			0
#define	IS_VISIBLE				1

#define	SYM_ISDEFINED(s)		((SYM_ANYADJ(s)).bit_0)	/* all */
#define	SYM_ISOUTPUT(s)			((SYM_ANYADJ(s)).bit_1)	/* all */
#define	SYM_ISINASEGMENT(s)		((SYM_ANYADJ(s)).bit_2)	/* all */
#define	SYM_ISNEAR(s)			((SYM_ANYADJ(s)).bit_3)	/* all */
#define	SYM_ISVISIBLE(s)		((SYM_ANYADJ(s)).bit_4)	/* all */
#define	SYM_ISPASCAL(s)			((SYM_ANYADJ(s)).bit_5)	/* all */

#define	SYM_ISINITIALIZED(s)	((SYM_ANYADJ(s)).bit_6)	/* symbol */
#define	SYM_ISSTRING(s)			((SYM_ANYADJ(s)).bit_7)	/* symbol */

#define	SYM_HASANAMELIST(s)		((SYM_ANYADJ(s)).bit_8)	/* funcs */
#define	SYM_DEFNBEFOREUSE(s)	((SYM_ANYADJ(s)).bit_9)	/* overload for QC */

#define	SYM_ISCODESEGNAME(s)	((SYM_ANYADJ(s)).bit_10)/* segment */
#define	SYM_ISDATASEGNAME(s)	((SYM_ANYADJ(s)).bit_11)/* segment */

#define	SYM_ISBACKREF(s)		((SYM_ANYADJ(s)).bit_12)/* label */
#define	SYM_ISFORWARDREF(s)		((SYM_ANYADJ(s)).bit_13)/* label */
#define SYM_ISMASM(s)			((SYM_ANYADJ(s)).bit_14)/* label */
#define SYM_TOLEVEL0(s)			((SYM_ANYADJ(s)).bit_15)/* funcs moved to 0 */

typedef	struct	sym_200	{			/* for fields */
	uchar_t		field_bitstart;		/* in which bit does the field start */
	uchar_t		field_nbits;		/* number of bits in this field */
	} sym_200_t;

typedef	struct	sym_190	{			/* struct/union members/fields */
	fpsym_t		member_prev;		/* previous member */
	ushort_t	member_offset;		/* offset of this member in the struct */
	sym_200_t	m200;
	} sym_190_t;

#define	SOB_sym_190	(sizeof(sym_190_t) - sizeof(sym_200_t))

typedef	struct	sym_180	{			/* struct/union/enum tags */
	len_t		tag_size;			/* sizeof the struct/union */
	ushort_t	tag_align;			/* alignment of this struct */
	} sym_180_t;

typedef	struct	sym_170	{			/* intrinsics */
	ushort_t	intrin_ino;			/* intrinsic number */
	ushort_t	intrin_nparms;		/* number of actuals it takes */
	} sym_170_t;

typedef	struct	sym_160	{			/* labels */
	NA_TYPE		label_template;		/* label template */
	} sym_160_t;

typedef	struct	sym_150	{			/* formals */
	fpsym_t		formal_prev;		/* ptr to previous formal */
	} sym_150_t;

typedef	struct	sym_140	{			/* raw symbols */
	hash_t		raw_hash;			/* the hash of this symbol */
	} sym_140_t;

typedef	union	sym_135	{
	sym_140_t	m140;				/* raw symbols */
	sym_150_t	m150;				/* formals */
	sym_160_t	m160;				/* labels */
	} sym_135_t;

typedef	struct	sym_130	{
/*
	SYMV_SYMBOL
	SYMV_RAWSYMBOL
	SYMV_FORMAL
	SYMV_SEGMENT
	SYMV_FUNCTION
	SYMV_LABEL
*/
	fpsym_t		sym_anysegment;		/* ptr to segment this is alloc'd in */
	sym_135_t	m135;
	} sym_130_t;

#define	SOB_sym_130	(sizeof(sym_130_t) - sizeof(sym_135_t))

typedef	union	sym_125	{
	sym_130_t	m130;
	sym_170_t	m170;
	} sym_125_t;

typedef	struct	sym_120	{
/*
	case SYMV_SYMBOL:
	case SYMV_RAWSYMBOL:
	case SYMV_FORMAL:
	case SYMV_SEGMENT:
	case SYMV_FUNCTION:
	case SYMV_INTRINSIC:
	case SYMV_LABEL:
*/
	refcnt_t	sym_anyrefcnt;	/* reference count  */
	class_t		sym_anyclass;	/* symbol's class */
	symadj_t	sym_anyadj;		/* adjectives  */
	sym_125_t	m125;
	} sym_120_t;

#define	SOB_sym_120	(sizeof(sym_120_t) - sizeof(sym_125_t))

typedef	union	sym_115	{
	sym_120_t	m120;
	sym_180_t	m180;
	} sym_115_t;

typedef	struct	sym_110	{
/*
	case SYMV_SYMBOL:
	case SYMV_RAWSYMBOL:
	case SYMV_FORMAL:
	case SYMV_SEGMENT:
	case SYMV_FUNCTION:
	case SYMV_INTRINSIC:
	case SYMV_LABEL:
	case SYMV_TAG:
*/
	p1key_t		sym_anykey;
	sym_115_t	m115;
	} sym_110_t;

#define	SOB_sym_110	(sizeof(sym_110_t) - sizeof(sym_115_t))

typedef	union	sym_105	{
	sym_110_t	m110;
	sym_190_t	m190;
	} sym_105_t;

typedef	struct	sym_100	{
	ptype_t		sym_anytype;
	sym_105_t	m105;
	} sym_100_t;

#define	SOB_sym_100	(sizeof(sym_100_t) - sizeof(sym_105_t))

typedef	union	sym_95	{
	long		moe_value;
	sym_100_t	m100;
	} sym_95_t;

struct	s_sym	{
	fpsym_t		sym_anynext;		/*  pointer to next ident  */
	fpuchar_t	sym_anyname;		/*  pointer to name */
	ushort_t	sym_anyvtag;		/*  which variant do we have? */
	sym_95_t		m95;
	};

#define	M95(p)	((p)->m95)
#define	M100(p)	((p)->m95.m100)
#define	M105(p)	((p)->m95.m100.m105)
#define	M110(p)	 ((p)->m95.m100.m105.m110)
#define	M115(p)	  ((p)->m95.m100.m105.m110.m115)
#define	M120(p)	   ((p)->m95.m100.m105.m110.m115.m120)
#define	M125(p)	    ((p)->m95.m100.m105.m110.m115.m120.m125)
#define	M130(p)	     ((p)->m95.m100.m105.m110.m115.m120.m125.m130)
#define	M135(p)	      (M130(p).m135)
#define	M140(p)	       (M135(p).m140)
#define	M150(p)	       (M135(p).m150)
#define	M160(p)	       (M135(p).m160)
#define	M170(p)	      ((p)->m95.m100.m105.m110.m115.m120.m125.m170)
#define	M180(p)	   ((p)->m95.m100.m105.m110.m115.m180)
#define	M190(p)	 ((p)->m95.m100.m105.m190)
#define	M200(p)	  (M190(p).m200)

#define	SO_BASICSYM	(sizeof(sym_t) - sizeof(sym_95_t))

#define	SO_SYMBOL		(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ SOB_sym_120\
							+ SOB_sym_130\
							)
#define	SO_SEGMENT		(SO_SYMBOL)
#define	SO_FUNCTION		(SO_SYMBOL)
#define	SO_RAWSYMBOL	(	SO_SYMBOL\
							+ sizeof(sym_140_t)\
							)
#define	SO_FORMAL		(	SO_SYMBOL\
							+ sizeof(sym_150_t)\
							)
#define	SO_LABEL		(	SO_SYMBOL\
							+ sizeof(sym_160_t)\
							)
#define	SO_INTRINSIC	(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ SOB_sym_120\
							+ sizeof(sym_170_t)\
							)
#define	SO_TAG			(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_110\
							+ sizeof(sym_180_t)\
							)

#define	SO_MEMBER		(	SO_BASICSYM\
							+ SOB_sym_100\
							+ SOB_sym_190\
							)
#define	SO_FIELD		(	SO_MEMBER\
							+ sizeof(sym_200_t)\
							)
#define	SO_MOE			(SO_BASICSYM + sizeof(long))	/* sizeof(moe_value) */

#if 0	/* this is just a big comment */

*all* use s_sym and the following parts.

SYMV_SYMBOL(and SYMV_SEGMENT, SYMV_FUNCTION)
				uses : sym_100, sym_110, sym_120, sym_130

SYMV_RAWSYMBOL	uses : SYMV_SYMBOL *and* sym_140
SYMV_FORMAL		uses : SYMV_SYMBOL *and* sym_150
SYMV_LABEL		uses : SYMV_SYMBOL *and* sym_160

SYMV_INTRINSIC	uses : sym_100, sym_110, sym_120, sym_170

SYMV_TAG		uses : sym_100, sym_110, sym_180

SYMV_MEMBER		uses : sym_100, sym_190

SYMV_FIELD		uses : SYMV_MEMBER *and* sym_200

SYMV_MOE		uses : moe_value

SYMV_OPC

#endif

#define	SYM_ANYNEXT(p)		((p)->sym_anynext)
#define	SYM_ANYNAME(p)		((p)->sym_anyname)
#define	SYM_ANYVTAG(p)		((p)->sym_anyvtag)

#define	SYM_ANYTYPE(p)		((p)->m95.m100.sym_anytype)
#define	SYM_ANYKEY(p)		((p)->m95.m100.m105.m110.sym_anykey)
#define	SYM_ANYREFCNT(p)	((p)->m95.m100.m105.m110.m115.m120.sym_anyrefcnt)
#define	SYM_ANYCLASS(p)		((p)->m95.m100.m105.m110.m115.m120.sym_anyclass)
#define	SYM_ANYADJ(p)		((p)->m95.m100.m105.m110.m115.m120.sym_anyadj)
#define	SYM_ANYSEGMENT(p)	(M130(p).sym_anysegment)
#define	SYM_ANYAOFF(p)		(M130(p).sym_anyaoff)	/* P-2 allocation offset */
#define	SYM_ANYAREGS(p)		(M130(p).sym_anyaregs)	/* P-2 allocation regs */
#define	SYM_ANYASEG(p)		(M130(p).sym_anyaseg)	/* P-2 allocation segment */

#define	SYM_SYNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_SYNAME(p)		(SYM_ANYNAME(p))
#define	SYM_SYTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_SYKEY(p)		(SYM_ANYKEY(p))
#define	SYM_SYREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_SYCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_SYADJ(p)		(SYM_ANYADJ(p))
#define	SYM_SYSEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_SYAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_SYASEG(p)		(SYM_ANYASEG(p))

#define	SYM_SENEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_SENAME(p)		(SYM_ANYNAME(p))
#define	SYM_SETYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_SEKEY(p)		(SYM_ANYKEY(p))
#define	SYM_SEREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_SECLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_SEADJ(p)		(SYM_ANYADJ(p))
#define	SYM_SEAOFF(p)		(SYM_ANYAOFF(p))

#define	SYM_RANAME(p)		(SYM_ANYNAME(p))
#define	SYM_RATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_RASEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_RAHASH(p)		(M140(p).raw_hash)

#define	SYM_FUNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FUNAME(p)		(SYM_ANYNAME(p))
#define	SYM_FUTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FUKEY(p)		(SYM_ANYKEY(p))
#define	SYM_FUREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_FUCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_FUADJ(p)		(SYM_ANYADJ(p))
#define	SYM_FUSEGMENT(p)	(SYM_ANYSEGMENT(p))
#define	SYM_FUAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_FUASEG(p)		(SYM_ANYASEG(p))

#define	SYM_FONEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FONAME(p)		(SYM_ANYNAME(p))
#define	SYM_FOTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FOKEY(p)		(SYM_ANYKEY(p))
#define	SYM_FOREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_FOCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_FOADJ(p)		(SYM_ANYADJ(p))
#define	SYM_FOAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_FOPREV(p)		(M150(p).formal_prev)

#define	SYM_LANEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_LANAME(p)		(SYM_ANYNAME(p))
#define	SYM_LATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_LAKEY(p)		(SYM_ANYKEY(p))
#define	SYM_LAREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_LACLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_LAADJ(p)		(SYM_ANYADJ(p))
#define	SYM_LAAOFF(p)		(SYM_ANYAOFF(p))
#define	SYM_LAASEG(p)		(SYM_ANYASEG(p))
#define	SYM_LATEMPLATE(p)	(M160(p).label_template)

#define	SYM_INNEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_INNAME(p)		(SYM_ANYNAME(p))
#define	SYM_INTYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_INKEY(p)		(SYM_ANYKEY(p))
#define	SYM_INREFCNT(p)		(SYM_ANYREFCNT(p))
#define	SYM_INCLASS(p)		(SYM_ANYCLASS(p))
#define	SYM_INADJ(p)		(SYM_ANYADJ(p))
#define	SYM_INNUMBER(p)		(M170(p).intrin_ino)
#define	SYM_INNPARMS(p)		(M170(p).intrin_nparms)

#define	SYM_TANEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_TANAME(p)		(SYM_ANYNAME(p))
#define	SYM_TATYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_TAKEY(p)		(SYM_ANYKEY(p))
#define	SYM_TASIZE(p)		(M180(p).tag_size)
#define	SYM_TAALIGN(p)		(M180(p).tag_align)

#define	SYM_MENEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_MENAME(p)		(SYM_ANYNAME(p))
#define	SYM_METYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_MEPREV(p)		(M190(p).member_prev)
#define	SYM_MEOFFSET(p)		(M190(p).member_offset)
#define	SYM_MEVACCESS(p)	(M190(p).member_vaccess)

#define	SYM_FINEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_FINAME(p)		(SYM_ANYNAME(p))
#define	SYM_FITYPE(p)		(SYM_ANYTYPE(p))
#define	SYM_FIPREV(p)		(M190(p).member_prev)
#define	SYM_FIOFFSET(p)		(M190(p).member_offset)
#define	SYM_FIVACCESS(p)	(M190(p).member_vaccess)
#define	SYM_FIBITSTART(p)	(M200(p).field_bitstart)
#define	SYM_FINBITS(p)		(M200(p).field_nbits)

#define	SYM_MONEXT(p)		(SYM_ANYNEXT(p))
#define	SYM_MONAME(p)		(SYM_ANYNAME(p))
#define	SYM_MOVALUE(p)		((p)->m95.moe_value)

/*
**	macros for acessing informmation on symbols type
*/
#define	SYM_ANYBTYPE(P)		(TY_BTYPE(SYM_ANYTYPE(P)))
#define	SYM_ANYESU(P)		(TY_ESU(SYM_ANYTYPE(P)))
#define	SYM_ANYTINDEX(P)	(TY_TINDEX(SYM_ANYTYPE(P)))
#define	SYM_ANYINDIR(P)		(TY_INDIR(SYM_SYTYPE(P)))

#define	SYM_ANYISUB(P)		(INDIR_ISUB(SYM_ANYINDIR(P)))
#define	SYM_ANYINEXT(P)		(INDIR_INEXT(SYM_ANYINDIR(P)))
#define	SYM_ANYITYPE(P)		(INDIR_ITYPE(SYM_ANYINDIR(P)))
#define	SYM_ANYIFORMALS(P)	(INDIR_IFORMALS(SYM_ANYINDIR(P)))

#define	SYM_NEAR(P)			(IS_NEAR(SYM_ANYBTYPE(P)))
#define	SYM_FAR(P)			(IS_FAR(SYM_ANYBTYPE(P)))
#define	SYM_HUGE(P)			(IS_HUGE(SYM_ANYBTYPE(P)))
#define	SYM_CONST(P)		(IS_CONST(SYM_ANYBTYPE(P)))
/*
**  the symbol table
*/
struct	s_table	{
	table_t		*st_next;	/*  link to next  */
	table_t		*st_incl;	/*  block is included in block pointer  */
	fpsym_t		*st_table;	/*  ptr to hash table  */
	blknum_t	st_level;	/*  block level  */
	uchar_t		st_size;	/*  number of entries in hash table  */
	};
/*
**  macros for accessing the symbol tables.
**	`level' is the level of interest.
**	`ptab' is a ptr to a symbol table
*/
#define	ST_NEXT(ptab)			((ptab)->st_next)
#define	ST_INCL(ptab)			((ptab)->st_incl)
#define	ST_SYM(ptab)			((ptab)->st_table)
#define	ST_LEVEL(ptab)			((ptab)->st_level)
#define	ST_MOD(ptab)			((ptab)->st_size)

#define	ST_TABLE(level)			((level) ? Table_n : Table_0)
#define	ST_BUCKET(ptab,hash)	(((ptab)->st_table[hash & ST_MOD(ptab)]))

/*
**	A Hash/Length/Name string is one where the first character is the hash
**	of the name.  The second character is the length of the identifier
**	including the hash and length characters.  The name begins at the third
**	character. 
*/
#define	HLN_IDENT_HASH(P)		(HLN_HASH(*(P)))
#define	HLN_IDENT_LENGTH(P)		(HLN_LENGTH(*(P)))
#define	HLN_IDENTP_NAME(P)		(HLN_NAME(*(P)))
/*
**  delcaration specifiers, used by to hold both the class and the type.
*/
struct	s_declspec	{
	class_t	ds_class;
	ptype_t	ds_type;
	};

#define	DSP_CLASS(p)	((p)->ds_class)
#define	DSP_TYPE(p)		((p)->ds_type)
#define	DS_CLASS(p)		((p).ds_class)
#define	DS_TYPE(p)		((p).ds_type)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\clistviews.h ===
//
// CListViews -- Class Descriptions for the main list views.
//
// 
// File: Globals.h
// Contains Global definitions for the Hotfix OCX
//

#include "Resource.h"

typedef struct _FILELIST
{
	_TCHAR		FileName[255];
	_TCHAR		InstallPath[255];
	_TCHAR		FileVersion[255];
	_TCHAR      IsCurrent[255];
	_TCHAR      FileDate[255];

	struct _FILELIST * pPrev;
	struct _FILELIST * pNext;
} * PFILELIST,FILELIST;

typedef struct _HOTFIXLIST
{
	_TCHAR      HotfixName[255];
	_TCHAR		Description[255];
	_TCHAR		InstalledDate[255];
	_TCHAR		InstalledBy[255];
	_TCHAR		Type[255];
	_TCHAR		Locale[255];
	_TCHAR		PackageCode[255];
	_TCHAR		ServicePack[255];
	_TCHAR      Uninstall[255];
	struct _HOTFIXLIST * pPrev;
	struct _HOTFIXLIST * pNext;
	PFILELIST FileList;
} * PHOTFIXLIST,HOTFIXLIST;

typedef struct _ProductNode {
	_TCHAR ProductName[255];
	_ProductNode * pPrev;
	_ProductNode * pNext;
	PHOTFIXLIST      HotfixList;
} * PPRODUCT, PRODUCTLIST;

static BOOL m_SortOrder ;   // True = Acending false = Decending
static HWND  TopList;
class CListViews
{

private:
	
	
	HWND  BottomList;
	PPRODUCT DataBase ;
	BOOL FreeDatabase();
	BOOL FreeHotfixList(PHOTFIXLIST CurrentHotfix);
	BOOL FreeFileList(PFILELIST CurrentFile);
//	BOOL    BuildDataBase(_TCHAR * ComputerName);
	PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey );
	PPRODUCT BuildDatabase(_TCHAR * lpszComputerName);
	PFILELIST GetFileInfo(HKEY* hHotfixKey);
	VOID VerifyFiles(PPRODUCT Database);
	BOOL AddItemsTop();
	BOOL   AddItemsBottom ();

    BOOL   bUserAbort;
	HWND hDlgPrint;

	_TCHAR  m_ProductName[255];
	DWORD   m_CurrentView;					// TRUE = By Hotfix, FALSE = BY File
	HINSTANCE m_hInst;
	_TCHAR CurrentProductName[255];
	_TCHAR CurrentFile[255];
	_TCHAR m_ComputerName[255];
	HWND    m_WebButton;
	HWND    m_UninstButton;
	HWND    m_RptButton;
	
public:
	_TCHAR m_CurrentHotfix[255];	
	BOOL      m_bRemoted;
	CListViews() {DataBase = NULL; m_CurrentView = VIEW_ALL_HOTFIX; m_SortOrder = TRUE;}
	~CListViews() {;}
	BOOL    Initialize( HWND ParentWnd, HINSTANCE hInst,_TCHAR *ComputerName, 
		                         HWND WebButton, HWND UninstButton, HWND RptButton);
	BOOL    Initialize( _TCHAR * ComputerName);
	BOOL    ShowLists(RECT * rc);
	BOOL    Resize(RECT *rc);
	DWORD     GetCurrentView () { return m_CurrentView;}
	
	void    SetViewMode(DWORD ViewType) ;
/*	void    RefreshView (BOOL Reload) {;}	// TRUE - if we just uninstalled or Refresh option selected
																    // FALSE - for view and product selection changes. */
	void PrintReport();
	void    SetProductName(_TCHAR * NewName);
	DWORD GetState();
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled, HWND m_hWnd);
	_TCHAR * GetCurrentHotfix();
	BOOL  Uninstall();
	HWND GetTopList() { return TopList; }
	void SaveToCSV();
	 static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
//	BOOL CALLBACK AbortProc(HDC PrinterDC, int iCode);
//	BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hivepp\trees.h ===
/*
**	Tree types
*/
#define	TTfree			0x0
#define	TTconstant		0x01
#define	TTsymbol		0x02
#define	TTunary			0x04
#define	TTleaf			0x08
#define	TTbinary		0x10
#define	TThybrid		0x20
#define	TTBasicShape	(TTfree|TTconstant|TTsymbol|TTunary|TTbinary|TThybrid)
#define	TTzero			0x40

typedef	USHORT		p2type_t;
typedef	p2type_t	*pp2type_t;

typedef	struct	tree_200	{
	ptree_t		tr_left;	/*  left child  */
	ptree_t		tr_right;	/*  right child  */
	} tree_200_st;

typedef	struct	tree_190	{
	ptree_t		tr_uchild;	/*  unary child  */
	} tree_190_st;

typedef	struct	tree_180	{
	psym_t		tr_symbol;	/*  symbol  */
	} tree_180_st;

typedef	struct	tree_170	{
	value_t		tr_value;	/*  value of the tree  */
	} tree_170_st;

typedef	union	tree_100	{
	tree_200_st	t200;
	tree_190_st	t190;
	tree_180_st	t180;
	tree_170_st	t170;
	} tree_100_st;

struct	s_tree	{
	token_t		tr_token;	/*  tree's token  */
	shape_t		tr_shape;	/*  tree shape  */
	ptype_t		tr_p1type;	/*  p1's view of the type  */
	p2type_t	tr_p2type;	/*  p1's view of the type p2 should have */
	tree_100_st	t100;
	};

#define	TR_SHAPE(P)		((P)->tr_shape)
#define	BASIC_SHAPE(S)	((S) & TTBasicShape)
#define	TR_TOKEN(P)		((P)->tr_token)
#define	TR_P1TYPE(P)	((P)->tr_p1type)		/*  resultant type  */
#define	TR_P2TYPE(P)	((P)->tr_p2type)		/*  resultant type  */
#define	TR_ISZERO(P)	(TR_SHAPE(P) & TTzero)

#define	TR_LEFT(P)		((P)->t100.t200.tr_left)	/*  left child  */
#define	TR_RIGHT(P)		((P)->t100.t200.tr_right)	/*  right child  */
#define	TR_UCHILD(P)	((P)->t100.t190.tr_uchild)	/*  unary's child */
#define	TR_SVALUE(P)	((P)->t100.t180.tr_symbol)	/*  ptr to the symbol */
#define	TR_VALUE(P)		((P)->t100.t170.tr_value)	/*  value of tree  */

#define	TR_RCON(P)		(TR_VALUE(P).v_rcon)		/*  real constant  */
#define	TR_DVALUE(P)	(TR_RCON(P)->rcon_real)	/*  double value  */
#define	TR_LVALUE(P)	(TR_VALUE(P).v_long)		/*  long value  */
#define	TR_STRING(P)	(TR_VALUE(P).v_string)	/*  string value  */

#define	TR_CVALUE(P)	(TR_STRING(P).str_ptr)	/*  ptr to string  */
#define	TR_CLEN(P)		(TR_STRING(P).str_len)	/*  length of string  */

#define	TR_BTYPE(P)		(TY_BTYPE(TR_P1TYPE(P)))/*  base type  */
#define	TR_ESU(P)		(TY_ESU(TR_P1TYPE(P)))	/*  parent enum/struct/union  */
#define	TR_INDIR(P)		(TY_INDIR(TR_P1TYPE(P)))

#define	TR_INEXT(P)		(INDIR_INEXT(TR_INDIR(P)))
#define	TR_ITYPE(P)		(INDIR_ITYPE(TR_INDIR(P)))
#define	TR_ISUB(P)		(INDIR_ISUB(TR_INDIR(P)))
#define	TR_IFORMALS(P)	(INDIR_IFORMALS(TR_INDIR(P)))
/*
**  for cases
*/
struct	s_case	{
	case_t	*c_next;	/*  next in list  */
	long	c_expr;		/*  value of constant expression  */
	p1key_t	c_label;	/*  label to which to jump if expr  */
	};

#define	NEXT_CASE(p)	((p)->c_next)
#define	CASE_EXPR(p)	((p)->c_expr)
#define	CASE_LABEL(p)	((p)->c_label)

/*
**  loop inversion structs
**  for( init; test; incr ) { ... }
**  we handle : sym | const relop sym | const; sym op sym | const
*/
typedef	struct	s_loopia	 loopia_t, *loopiap_t;
typedef	struct	s_liarray	 liarray_t, *liarrayp_t;

struct	s_loopia	{
	token_t		lia_token;
	union	{
		psym_t		lia_sym;
		long		lia_value;
		liarrayp_t	lia_array;
		} lia_union;
	};

#define	LIA_TOKEN(p)	((p)->lia_token)
#define	LIA_SYM(p)		((p)->lia_union.lia_sym)
#define	LIA_VALUE(p)	((p)->lia_union.lia_value)
#define	LIA_ARRAY(p)	((p)->lia_union.lia_array)

typedef	struct	s_liarray	{
	loopia_t	liar_left;
	loopia_t	liar_right;
	};

#define	LIAR_LEFT(p)	(&((p)->liar_left))
#define	LIAR_RIGHT(p)	(&((p)->liar_right))

typedef	struct	s_loopi	{
	int			li_relop;
	int			li_incop;
	loopia_t	li_w;
	loopia_t	li_x;
	loopia_t	li_y;
	loopia_t	li_z;
	} loopi_t, *loopip_t;

#define	LOOP_RELOP(p)	((p)->li_relop)
#define	LOOP_INCOP(p)	((p)->li_incop)

#define	LOOP_W(p)		(&((p)->li_w))
#define	LOOP_X(p)		(&((p)->li_x))
#define	LOOP_Y(p)		(&((p)->li_y))
#define	LOOP_Z(p)		(&((p)->li_z))

#define	LOOP_W_TOKEN(p)	LIA_TOKEN(LOOP_W(p))
#define	LOOP_X_TOKEN(p)	LIA_TOKEN(LOOP_X(p))
#define	LOOP_Y_TOKEN(p)	LIA_TOKEN(LOOP_Y(p))
#define	LOOP_Z_TOKEN(p)	LIA_TOKEN(LOOP_Z(p))

#define	LOOP_W_SYM(p)	LIA_SYM(LOOP_W(p))
#define	LOOP_X_SYM(p)	LIA_SYM(LOOP_X(p))
#define	LOOP_Y_SYM(p)	LIA_SYM(LOOP_Y(p))
#define	LOOP_Z_SYM(p)	LIA_SYM(LOOP_Z(p))

#define	LOOP_W_VALUE(p)	LIA_VALUE(LOOP_W(p))
#define	LOOP_X_VALUE(p)	LIA_VALUE(LOOP_X(p))
#define	LOOP_Y_VALUE(p)	LIA_VALUE(LOOP_Y(p))
#define	LOOP_Z_VALUE(p)	LIA_VALUE(LOOP_Z(p))
/*
**	stack structure for saving items which must be stacked at various places
*/
struct	s_stack	{
	stack_t	*stk_next;
	union	{
		ptree_t		sv_tree;
		psym_t		sv_sym;
		int			sv_int;
		loopip_t	sv_loopi;
		} stk_value;
	};

#define	TEST_LAB		(Test->stk_value.sv_tree)
#define	START_LAB		(Start->stk_value.sv_tree)
#define	CONTINUE_LAB	(Continue->stk_value.sv_tree)
#define	BREAK_LAB		(Break->stk_value.sv_tree)
#define	CA_LAB			(Case->stk_value.sv_tree)
#define	DEFAULT_LAB		(Default->stk_value.sv_tree)

#define	LOOPI(p)		((p)->stk_value.sv_loopi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\database.cpp ===
//
// File: Database.cpp
// BY:   Anthony V. Demarco
// Date: 12/28/1999
// Description: Contains routines for reading system update registry entries into an
//						internal database. See Database.h for database structure.
// Copyright (c) Microsoft Corporation 1999-2000
//


#include "stdafx.h"
#include "Database.h"
#define BUFFER_SIZE   255
PPRODUCT BuildDatabase(_TCHAR * lpszComputerName)
{

	HKEY		 hPrimaryKey;						// Handle of the target system HKLM 
//	_TCHAR    szPrimaryPath;			 // Path to the update key;

	HKEY		hUpdatesKey;					  // Handle to the updates key.
	_TCHAR   szUpdatesPath[BUFFER_SIZE];				// Path to the udates key
	DWORD   dwUpdatesIndex;			  // index of current updates subkey
	DWORD   dwBufferSize;				  // Size of the product name buffer.



	_TCHAR	 szProductPath[BUFFER_SIZE];				// Path of the current product key
	_TCHAR  szProductName[BUFFER_SIZE];			  // Name of product; also path to product key

	PPRODUCT	pProductList = NULL;			// Pointer to the head of the product list.
	PPRODUCT    pNewProdNode;					// Pointer used to allocate new nodes in the product list.
	PPRODUCT    pCurrProdNode;					  // Used to walk the Products List;

    // Connect to the target registry
	RegConnectRegistry(lpszComputerName,HKEY_LOCAL_MACHINE, &hPrimaryKey);
	// insert error handling here......

	if (hPrimaryKey != NULL)
	{
		// Initialize the primary path not localized since registry keys are not localized.
	    _tcscpy (szUpdatesPath, _T("SOFTWARE\\Microsoft\\Updates"));
		// open the udates key
		RegOpenKeyEx(hPrimaryKey,szUpdatesPath, 0, KEY_READ ,&hUpdatesKey);

		// Enumerate the Updates key.
		dwUpdatesIndex = 0;
		while (	RegEnumKeyEx(hUpdatesKey,dwUpdatesIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{
			// Create a node for the current product 
			pNewProdNode = (PPRODUCT) malloc(sizeof(PPRODUCT));
			_tcscpy(pNewProdNode->ProductName,szProductName);

			_tcscpy (szProductPath, szProductName);
			// now get the hotfix for the current product.
			pNewProdNode->HotfixList = GetHotfixInfo(szProductName, &hUpdatesKey);

			 // Insert the new node into the list.
			 pCurrProdNode=pProductList;
			 if (pCurrProdNode == NULL)						// Head of the list
			 {
				 pProductList = pNewProdNode;
				 pProductList->pPrev = NULL;
				 pProductList->pNext = NULL;
			 }
			 else
			 {
				 //Find the end of the list.
				 while (pCurrProdNode->pNext != NULL)
						pCurrProdNode = pCurrProdNode->pNext;
				 // Now insert the new node at the end of the list.
				 pCurrProdNode->pNext = pNewProdNode;
				 pNewProdNode->pPrev = pCurrProdNode;
				 pNewProdNode->pNext = NULL;
			 }

			// increment index and clear the szProducts name string for the next pass.
			
			dwUpdatesIndex++;
			_tcscpy (szProductName,_T("\0"));
			_tcscpy(szProductPath, _T("\0"));
			dwBufferSize = 255;					
		}
	}
	// close the open keys
    RegCloseKey(hUpdatesKey);
	RegCloseKey(hPrimaryKey);
	// return a pointer to the head of our database.
	return pProductList;
}

PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey )
{
	HKEY			   hHotfix;						// Handle of the hotfix key being processed.
	HKEY			   hProduct;				   // Handle to the current product key

	_TCHAR          szHotfixName[BUFFER_SIZE];    // Name of the current hotfix.
//	_TCHAR			szHotfixPath[BUFFER_SIZE];	 // Path of the current hotfix key
    _TCHAR          szValueName[BUFFER_SIZE];
	


	PHOTFIXLIST	 pHotfixList = NULL; // Pointer to the head of the hotfix list.
	PHOTFIXLIST  pCurrNode;				  // Used to walk the list of hotfixes
	PHOTFIXLIST  pNewNode;				 // Used to create nodes to be added to the list.

	DWORD		   dwBufferSize;			// Size of the product name buffer.
	DWORD          dwValIndex;					  // index of current value.
	DWORD		   dwHotfixIndex = 0;
	BYTE				*Data;
	DWORD			dwDataSize = BUFFER_SIZE;
	DWORD			dwValType;

	Data = (BYTE *) malloc(BUFFER_SIZE);


	// Open the current product key
	RegOpenKeyEx(*hUpdateKey,pszProductName,0 , KEY_READ, &hProduct);
	dwHotfixIndex = 0;
	dwBufferSize = BUFFER_SIZE;
	while (RegEnumKeyEx(hProduct,dwHotfixIndex, szHotfixName,&dwBufferSize, 0, NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
	{
			// now create a new node
			pNewNode = (PHOTFIXLIST) malloc (sizeof(PHOTFIXLIST));
			pNewNode->pNext = NULL;
			pNewNode->FileList = NULL;
			_tcscpy(pNewNode->HotfixName,szHotfixName);

			// open the hotfix key
			RegOpenKeyEx(hProduct,szHotfixName,0,KEY_READ,&hHotfix);
			// Now enumerate the values of the current hotfix.
			dwValIndex = 0;
			dwBufferSize =BUFFER_SIZE;
			dwDataSize = BUFFER_SIZE;
			while (RegEnumValue(hHotfix,dwValIndex, szValueName,&dwBufferSize, 0,&dwValType, Data, &dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
					// Fill in the hotfix data members.
					
					++ dwValIndex;
					_tcscpy (szValueName, _T("\0"));
					ZeroMemory(Data,BUFFER_SIZE);
					dwValType = 0;
					dwBufferSize =BUFFER_SIZE;
					dwDataSize   = BUFFER_SIZE;
			}
			// Get the file list for the current hotfix.
			pNewNode->FileList = GetFileInfo(&hHotfix);

			//insert the new node at the end of the hotfix list.
           
			if (pHotfixList = NULL)
			{
				pHotfixList = pNewNode;
				pHotfixList->pPrev = NULL;
				pHotfixList->pNext = NULL;


			}
			else
			{
				 pCurrNode = pHotfixList;
				 while (pCurrNode->pNext != NULL)
					 pCurrNode = pCurrNode->pNext;
				 pCurrNode->pNext = pNewNode;
				 pNewNode->pPrev = pCurrNode;
				 pNewNode->pNext = NULL;
			}
			// Close the current Hotfix Key
			RegCloseKey(hHotfix);

			// Clear the strings.
			_tcscpy(szHotfixName,_T("\0"));

			// increment the current index
			++dwHotfixIndex;
			dwBufferSize = BUFFER_SIZE;
	}
	// Close all open keys
	RegCloseKey(hProduct);
	if (Data != NULL)
		free (Data);
	return pHotfixList;
}

PFILELIST GetFileInfo(HKEY* hHotfixKey)
{
		PFILELIST			   pFileList = NULL;				   // Pointer to the head of the file list.
//		_TCHAR				 szFilePath;				// Path to the files subkey.
		PFILELIST			   pNewNode = NULL;
		PFILELIST			   pCurrNode = NULL;;
		BYTE *					Data;
		DWORD				 dwBufferSize = BUFFER_SIZE;
		DWORD				 dwDataSize	  = BUFFER_SIZE;
		DWORD				 dwFileIndex	= 0;
		DWORD				 dwPrimeIndex = 0;
		DWORD				 dwValType = 0;
		HKEY					hPrimaryFile;
		HKEY					hFileKey;
		_TCHAR				 szFileSubKey[BUFFER_SIZE];
		_TCHAR				 szValueName[BUFFER_SIZE];
	
		Data = (BYTE *) malloc(BUFFER_SIZE);
			ZeroMemory(Data,BUFFER_SIZE);
		// Open the files subkey of the current hotfix
		RegOpenKeyEx(*hHotfixKey, _T("Files"),0,KEY_READ,&hPrimaryFile);
		while (RegEnumKeyEx(hPrimaryFile,dwPrimeIndex,szFileSubKey, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{

			// open the subfile key
			RegOpenKeyEx(hPrimaryFile,szFileSubKey,0,KEY_READ,&hFileKey);

		// Enumerate the file(x) subkeys of the file subkey
			while (RegEnumValue(hFileKey,dwFileIndex,szValueName,&dwBufferSize,0,&dwValType,Data,&dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
				pNewNode = (PFILELIST) malloc (sizeof(PFILELIST));
				pNewNode->pNext = NULL;
				pNewNode->pPrev = NULL;
				dwFileIndex ++;
				_tcscpy(szValueName,_T("\0"));
				ZeroMemory(Data,BUFFER_SIZE);
				dwValType = 0;
				dwBufferSize = BUFFER_SIZE;
				dwDataSize = BUFFER_SIZE;
			}
			RegCloseKey(hFileKey);
			    // add the current node to the list
			if (pFileList == NULL)
			{
				pFileList = pNewNode;
			}
			else
			{
				pCurrNode = pFileList;
				while (pCurrNode->pNext != NULL)
					pCurrNode = pCurrNode->pNext;
				pCurrNode->pNext = pNewNode;
			}
			
		} // end enum of primary file key
		RegCloseKey(hPrimaryFile);
		if (Data != NUL)
			free (Data);
		return pFileList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\clistviews.cpp ===
//
// Implementation file for the CListViews Class
//
#include <Windows.h>
#include "stdafx.h"
#include "CListViews.h"
#include "resource.h"
#include <wbemidl.h>
#include <comdef.h>
#include <Commctrl.h>
#include  <io.h>
#include <Math.h>
#include <commdlg.h>
#define   FILENAME_FIELD_WIDTH  10
#define   VERSION_FIELD_WIDTH    13
#define   DATE_FIELD_WIDTH   9
#define   CURRENT_FIELD_WIDTH 8
#define   PATH_FIELD_WIDTH   13

BOOL bUserAbort;
BOOL bSuccess;
HWND hDlgPrint;
#define BUFFER_SIZE 255
LRESULT CListViews::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled,HWND m_hWnd)
{
	LPNMHDR  lpnmh = (LPNMHDR) lParam;
	NM_LISTVIEW *pnm = (NM_LISTVIEW *)lParam;
	LPNMITEMACTIVATE lpnmia;
 HWND     hwndListView = ::GetDlgItem(m_hWnd, 1001);
_TCHAR  ItemName[255];
_TCHAR FileName[255];
_TCHAR TempProduct[255];
    if ( lpnmh->idFrom != 1001)
	{
	
			return 0;
	}
	

	switch(lpnmh->code)
	{

	case LVN_ITEMCHANGED:
			lpnmia = (LPNMITEMACTIVATE)lParam;
			switch (m_CurrentView) 
			{
			case VIEW_ALL_FILE:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,TempProduct,255);
				ListView_GetItemText(hwndListView, lpnmia->iItem,1,ItemName, 255);
				
				_tcscpy(CurrentProductName,TempProduct);
				_tcscpy(m_CurrentHotfix, ItemName);
				_tcscpy (m_ProductName,_T("\0"));

				AddItemsBottom();
				break;
			case VIEW_ALL_HOTFIX:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,TempProduct,255);
				ListView_GetItemText(hwndListView, lpnmia->iItem,1,ItemName, 255);
				_tcscpy(CurrentProductName,TempProduct);
					_tcscpy(m_CurrentHotfix, ItemName);
					_tcscpy (m_ProductName,_T("\0"));

					AddItemsBottom();

				break;
			case VIEW_BY_FILE:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,ItemName, 255);
					ListView_GetItemText(hwndListView, lpnmia->iItem,0,FileName, 255);
					_tcscpy(CurrentFile, FileName);
					_tcscpy(m_CurrentHotfix, ItemName);
					AddItemsBottom();
				break;
			case VIEW_BY_HOTFIX:
				ListView_GetItemText(hwndListView, lpnmia->iItem,0,ItemName, 255);
					_tcscpy(m_CurrentHotfix, ItemName);
					AddItemsBottom();
				break;
			} // end switch
		    //_tcscpy(m_CurrentHotfix, ItemName);
			 // Process LVN_COLUMNCLICK to sort items by column. 
			break;
        case LVN_COLUMNCLICK:
		{
			//Message(TEXT("NotifyListView: LVN_COLUMNCLICK"), -1, NULL);
            ListView_SortItemsEx(
				lpnmh->hwndFrom, 
				CompareFunc, 
				pnm->iSubItem);
			    m_SortOrder = !m_SortOrder;
            break;
		}
			

		break;
	
	} // end switch


				DWORD Status = GetState();
			
				::EnableWindow(m_WebButton,FALSE);
				::EnableWindow(m_UninstButton,FALSE);
				::EnableWindow(m_RptButton,FALSE);
			
				if (Status & UNINSTALL_OK)
					::EnableWindow(m_UninstButton,TRUE);
				if (Status & HOTFIX_SELECTED)
					::EnableWindow(m_WebButton,TRUE);
				if (Status & OK_TO_PRINT)
					::EnableWindow(m_RptButton,TRUE);
			
			//	SetFocus(m_WebButton);


	bHandled = TRUE;	
	return 0;
}

BOOL CListViews::Initialize( _TCHAR * ComputerName)
{
	LVCOLUMN Col;
	_TCHAR TempComputer[255];



	_tcscpy(m_ProductName,_T("\0"));
	EnableWindow(m_WebButton, FALSE);
	EnableWindow(m_UninstButton,FALSE);
	for (DWORD  i = 0; i< 3000000;i++) ;
	_tcscpy ( m_ComputerName, ComputerName);
	if (DataBase)
		FreeDatabase();
	DataBase = NULL;

	Col.mask = LVCF_WIDTH;
	SendMessage(TopList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(TopList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(TopList,0,&Col))
			ListView_DeleteColumn(TopList,0);

	
	// Clear the bottom list 
   
	SendMessage(BottomList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(BottomList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(BottomList,0,&Col))
			ListView_DeleteColumn(BottomList,0);

	SendMessage(BottomList, WM_SETREDRAW,TRUE, 0);
		
		
         Col.mask = LVCF_FMT | LVCF_TEXT;
         Col.fmt =  LVCFMT_LEFT;
		Col.pszText = _T("Hotfix Manager");
	
		ListView_InsertColumn(TopList,0,&Col);
		LVITEM LvItem;
		LvItem.mask = LVIF_TEXT;
		LvItem.iItem = 0;
		_TCHAR Message[255];
		_tcscpy(Message,_T("\0"));
		LoadString(m_hInst,IDS_RETRIEVE_DATA,Message,255);
		LvItem.pszText = Message;
	    LvItem.iSubItem = 0;
		ListView_InsertItem(TopList,&LvItem);
		SendMessage(TopList, WM_SETREDRAW,TRUE, 0);
	
	DataBase = BuildDatabase (ComputerName);

	DWORD dwLength = 255;
	GetComputerName(TempComputer, &dwLength);
	if (_tcscmp(ComputerName, TempComputer))
		m_bRemoted = TRUE;
	else
		m_bRemoted = FALSE;


	_tcscpy (m_ProductName,_T("\0"));
   	_tcscpy(m_CurrentHotfix, _T("\0"));
	
	AddItemsTop();
   AddItemsBottom();
	return TRUE;
}




BOOL CListViews::Initialize( HWND ParentWnd, HINSTANCE hInst,_TCHAR * ComputerName, 
							                  HWND WebButton, HWND UninstButton, HWND RptButton)
{
	m_bRemoted = FALSE;
	m_WebButton = WebButton;
	m_UninstButton = UninstButton;
	m_RptButton = RptButton;
	m_hInst = hInst;
	m_CurrentView = VIEW_ALL_HOTFIX;
	_tcscpy (m_ProductName,_T("\0"));
	DWORD dwStyle =  
            WS_CHILD | 
            WS_BORDER | 
            LVS_AUTOARRANGE |
		//	LVS_SORTDESCENDING|
            LVS_REPORT | 
            LVS_SHAREIMAGELISTS |
            WS_VISIBLE | LVS_SHOWSELALWAYS   ;

	
	
	TopList = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW,               // class name - defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 ParentWnd,                // parent
                                 (HMENU)1001,       // ID
                                 hInst,                   // instance
                                 NULL);                     // no extra data


	dwStyle |= LVS_NOSORTHEADER;
	BottomList = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW,               // class name - defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 ParentWnd,                // parent
                                 NULL,       // ID
                                 hInst,                   // instance
                                 NULL);                     // no extra data

		ListView_SetExtendedListViewStyle(TopList, LVS_EX_FULLROWSELECT);
		ListView_SetExtendedListViewStyle(BottomList, LVS_EX_FULLROWSELECT);
		_tcscpy (m_ProductName,_T("\0"));
		_tcscpy (m_CurrentHotfix,_T("\0"));
	return TRUE;
}

BOOL    CListViews::Resize(RECT *rc)
{
	MoveWindow( TopList, 
            rc->left,
            rc->top,
            rc->right - rc->left,
            (rc->bottom -50) /2 - 2,
            TRUE);

	MoveWindow( BottomList, 
            rc->left,
           ( rc->bottom-50) / 2 ,
            rc->right - rc->left,
           rc->bottom-50 - (rc->bottom -50) /2,
            TRUE);
	return TRUE;

}

BOOL    CListViews::ShowLists(RECT * rc)
{
	ShowWindow(TopList,TRUE);
	ShowWindow(BottomList, TRUE);
	Resize(rc);
	return TRUE;
}


BOOL CListViews::AddItemsTop()
{

		// Top View First
	LVITEM     LvItem;
	LVCOLUMN Col;
	_TCHAR      szBuffer[255];
	PHOTFIXLIST CurrentHotfix;
	PFILELIST       CurrentFile;
    int itemnum = 0;
//	int iSubItem = 0;
	PPRODUCT CurrentEntry; 
    
	LvItem.iItem = itemnum;
	LvItem.mask = LVIF_TEXT ;
    Col.mask = LVCF_WIDTH;
	SendMessage(TopList, LVM_DELETEALLITEMS, 0, 0);
  
	SendMessage(TopList, WM_SETREDRAW, FALSE, 0);
	while (ListView_GetColumn(TopList,0,&Col))
			ListView_DeleteColumn(TopList,0);

	
	 Col.cx =100;
  Col.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
   Col.fmt =  LVCFMT_LEFT;
    
	switch (m_CurrentView )
	{
	case VIEW_ALL_HOTFIX:			// default for primary node.
		{
		CurrentEntry = DataBase;
		
		
    	LoadString(m_hInst,IDS_PRODUCT_NAME,szBuffer ,255);
		Col.pszText = _T("Product Name");
		ListView_InsertColumn(TopList,0,&Col);

		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,1,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,2,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,3,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,4,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,5,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,6,&Col);

		LvItem.mask = LVIF_TEXT ;
   
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
			SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		while (CurrentEntry != NULL)
		{
			// first insert the product name
		    	

			// Now walk down the hotfix list.
			CurrentHotfix = CurrentEntry->HotfixList;
			while (CurrentHotfix != NULL)
			{
				LvItem.mask |= LVIF_PARAM;
				LvItem.iItem = itemnum;
				
			
				LvItem.pszText = CurrentEntry->ProductName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(TopList,&LvItem);
			
			
				ListView_SetItemText(TopList, itemnum, 1, CurrentHotfix->HotfixName);
				ListView_SetItemText(TopList, itemnum, 2 , CurrentHotfix->Description);
				ListView_SetItemText(TopList, itemnum, 3, CurrentHotfix->ServicePack);
			
				ListView_SetItemText(TopList, itemnum, 4, CurrentHotfix->InstalledBy);
					ListView_SetItemText(TopList, itemnum, 5, CurrentHotfix->InstalledDate);
				ListView_SetItemText(TopList, itemnum, 6, CurrentHotfix->Type);

				if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
			
				itemnum++;
			
				CurrentHotfix = CurrentHotfix->pNext;
			}
		
			CurrentEntry = CurrentEntry->pNext;
		}
		 
	
		}
	
	break;

	case VIEW_ALL_FILE:					// View all of the files updated by all products.
		CurrentEntry = DataBase;
		
//		MessageBox(NULL,_T("Viewing all by file"),NULL,MB_OK);
    LoadString(m_hInst,IDS_PRODUCT_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,0,&Col);

	LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,1,&Col);

	LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,2,&Col);
	
	LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,3,&Col);

	LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,4,&Col);

	LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,5,&Col);

	LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,6,&Col);

	
	if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
			SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL,_T("No Database"),NULL,MB_OK);
			return FALSE;
		}
	
    
		LvItem.mask = LVIF_TEXT;
		
		while (CurrentEntry != NULL)
		{
		
			// first insert the product name
		  	// Now walk down the hotfix list.
			CurrentHotfix = CurrentEntry->HotfixList;
			while (CurrentHotfix != NULL)
			{
				CurrentFile = CurrentHotfix->FileList;
				LvItem.iItem = itemnum;
			
				while (CurrentFile != NULL)
				{
					
				    LvItem.pszText = CurrentEntry->ProductName;
	    	    	LvItem.iSubItem = 0;
					ListView_InsertItem(TopList,&LvItem);
				
					ListView_SetItemText(TopList, itemnum, 1, CurrentHotfix->HotfixName);
					ListView_SetItemText(TopList, itemnum, 2 , CurrentFile->FileName);
					ListView_SetItemText(TopList, itemnum, 3, CurrentFile->FileDate);
					ListView_SetItemText(TopList, itemnum, 4, CurrentFile->IsCurrent);
					ListView_SetItemText(TopList, itemnum, 5, CurrentFile->FileVersion);
						ListView_SetItemText(TopList, itemnum, 6, CurrentFile->InstallPath);
					itemnum++;
					
					CurrentFile = CurrentFile->pNext;
					LvItem.iItem = itemnum;
				}	
				CurrentHotfix = CurrentHotfix->pNext;
			}
			CurrentEntry = CurrentEntry->pNext;
		}
		
	break;
    case VIEW_BY_HOTFIX:

		CurrentEntry = DataBase;
			if (CurrentEntry == NULL)
			{
				LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
				return FALSE;
			}
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,0,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,1,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,2,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,3,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,4,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(TopList,5,&Col);

		LvItem.mask = LVIF_TEXT;
       
		while ( _tcscmp(CurrentEntry->ProductName, m_ProductName) && (CurrentEntry != NULL))
			CurrentEntry = CurrentEntry->pNext;
			// first insert the product name
		
			

			// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		CurrentHotfix = CurrentEntry->HotfixList;
		while (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			LvItem.pszText = CurrentHotfix->HotfixName;
	    	LvItem.iSubItem = 0;
			ListView_InsertItem(TopList,&LvItem);
		
			ListView_SetItemText(TopList, itemnum, 1 , CurrentHotfix->Description);
			ListView_SetItemText(TopList, itemnum, 2, CurrentHotfix->ServicePack);
			ListView_SetItemText(TopList, itemnum, 4, CurrentHotfix->InstalledDate);
			ListView_SetItemText(TopList, itemnum, 3, CurrentHotfix->InstalledBy);
			ListView_SetItemText(TopList, itemnum, 5, CurrentHotfix->Type);

				if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
			itemnum++;
		
			CurrentHotfix = CurrentHotfix->pNext;
		}
		break;
	case VIEW_BY_FILE:				// Displays all files modified by all updates for the current product.
		CurrentEntry = DataBase;
		
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
	Col.pszText = szBuffer;
    ListView_InsertColumn(TopList,1,&Col);

	LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,2,&Col);
	
	LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,3,&Col);

	LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,4,&Col);

	LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,5,&Col);

	LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
	Col.pszText = szBuffer;
	ListView_InsertColumn(TopList,6,&Col);
	if (CurrentEntry == FALSE)
	{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
	}
    
		LvItem.mask = LVIF_TEXT;
		// first insert locate the product name
		while ( (_tcscmp(CurrentEntry->ProductName,m_ProductName) )&& (CurrentEntry != NULL))
				CurrentEntry = CurrentEntry->pNext;
		
		  	// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(TopList,&LvItem);
				SendMessage(TopList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}

		CurrentHotfix = CurrentEntry->HotfixList;
		while (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			CurrentFile = CurrentHotfix->FileList;
			
			while (CurrentFile != NULL)
			{
				LvItem.pszText = CurrentHotfix->HotfixName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(TopList,&LvItem);
				ListView_SetItemText(TopList, itemnum, 1 , CurrentFile->FileName);
				ListView_SetItemText(TopList, itemnum, 2, CurrentFile->FileDate);
				ListView_SetItemText(TopList, itemnum, 3, CurrentFile->IsCurrent);
				ListView_SetItemText(TopList, itemnum, 4, CurrentFile->FileVersion);
					ListView_SetItemText(TopList, itemnum, 5, CurrentFile->InstallPath);
						if (itemnum == 0)
				{
//					MessageBox(NULL,CurrentEntry->ProductName, _T("Selecting Product"),MB_OK);
					_tcscpy(CurrentProductName,CurrentEntry->ProductName);
					
					_tcscpy(m_CurrentHotfix, CurrentEntry->HotfixList->HotfixName );
					ListView_SetItemState(TopList, 0,LVIS_SELECTED,LVIS_STATEIMAGEMASK | LVIS_SELECTED);
					::EnableWindow(m_WebButton,FALSE);
					::EnableWindow(m_UninstButton,FALSE);
					::EnableWindow(m_RptButton,FALSE);
			        DWORD Status = GetState();
					if (Status & UNINSTALL_OK)
						::EnableWindow(m_UninstButton,TRUE);
					if (Status & HOTFIX_SELECTED)
						::EnableWindow(m_WebButton,TRUE);
					if (Status & OK_TO_PRINT)
						::EnableWindow(m_RptButton,TRUE);
			
					SetFocus(m_WebButton);
				}
				itemnum++;
				LvItem.iItem = itemnum;
				CurrentFile = CurrentFile->pNext;
			}	
			CurrentHotfix = CurrentHotfix->pNext;
		}
	

	break;	
	} // end switch			
	SendMessage(TopList, WM_SETREDRAW, TRUE, 0);


	return TRUE;
}

BOOL CListViews::AddItemsBottom ()
{
	LVITEM     LvItem;
	LVCOLUMN Col;
	_TCHAR      szBuffer[255];
	PHOTFIXLIST CurrentHotfix;
	PFILELIST       CurrentFile;
    int itemnum = 0;
//	int iSubItem = 0;
//	int ItemCount = 0;
	BOOL Done = FALSE;


	LvItem.mask = LVIF_TEXT;
	LvItem.iItem = itemnum;
	PPRODUCT CurrentEntry; 
    // Clear the List View and prepare it for updating....
	SendMessage(BottomList, LVM_DELETEALLITEMS, 0, 0);
  	SendMessage(BottomList, WM_SETREDRAW, FALSE, 0);


	

	Col.mask =LVCF_WIDTH;
	while (ListView_GetColumn(BottomList,0,&Col))
			ListView_DeleteColumn(BottomList,0);

	Col.mask = LVCF_TEXT | LVCF_WIDTH;
	Col.cx = 100;

	
    switch (m_CurrentView)
	{
	case VIEW_ALL_FILE:
	case VIEW_BY_FILE:
		CurrentEntry = DataBase;
	
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,0,&Col);

		LoadString(m_hInst,IDS_DESCRIPTION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,1,&Col);
		
		LoadString(m_hInst,IDS_SERVICE_PACK,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,2,&Col);

		LoadString(m_hInst,IDS_INSTALLED_BY,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,3,&Col);
		
		LoadString(m_hInst,IDS_INSTALL_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,4,&Col);

		LoadString(m_hInst,IDS_UPDATE_TYPE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,5,&Col);
	SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
		LvItem.mask = LVIF_TEXT;
       
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Database is NULL"),_T("No Items"), MB_OK);
			return FALSE;
		}
		Done = FALSE;
		
		if (_tcscmp (m_ProductName,_T("\0")))
		{
			while (  (!Done) && (CurrentEntry != NULL))
			{
			
				if (!_tcscmp(CurrentEntry->ProductName, m_ProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		else
		{
		
			while (  (!Done) && (CurrentEntry != NULL))
			{
		
				if (!_tcscmp(CurrentEntry->ProductName, CurrentProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
				// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Product Not found or not selected"), _T("No Items"),MB_OK);
			return FALSE;
		
		}
		CurrentHotfix = CurrentEntry->HotfixList;
		while ( (CurrentHotfix != NULL) && (_tcscmp(CurrentHotfix->HotfixName, m_CurrentHotfix)))
			CurrentHotfix = CurrentHotfix->pNext;

		if (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			LvItem.pszText = CurrentHotfix->HotfixName, 
	    	LvItem.iSubItem = 0;
			ListView_InsertItem(BottomList,&LvItem);
		
			ListView_SetItemText(BottomList, itemnum, 1 , CurrentHotfix->Description);
			ListView_SetItemText(BottomList, itemnum, 2, CurrentHotfix->ServicePack);
			ListView_SetItemText(BottomList, itemnum, 3, CurrentHotfix->InstalledBy);
			ListView_SetItemText(BottomList, itemnum, 4, CurrentHotfix->InstalledDate);
			ListView_SetItemText(BottomList, itemnum, 5, CurrentHotfix->Type);
			itemnum++;
		
			CurrentHotfix = CurrentHotfix->pNext;
		}
		else
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("No Hotfix Found"), _T("No Items"),MB_OK);
			return FALSE;
		}
		break;

	case VIEW_ALL_HOTFIX:
	case VIEW_BY_HOTFIX:
		CurrentEntry = DataBase;
		
		LoadString(m_hInst,IDS_ARTICLE_NUMBER,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,1,&Col);

		LoadString(m_hInst,IDS_FILE_NAME,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,2,&Col);
		
		LoadString(m_hInst,IDS_FILE_DATE,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,3,&Col);

		LoadString(m_hInst,IDS_FILE_CURRENT,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,4,&Col);

		LoadString(m_hInst,IDS_FILE_VERSION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,5,&Col);

		LoadString(m_hInst,IDS_FILE_LOCATION,szBuffer ,255);
		Col.pszText = szBuffer;
		ListView_InsertColumn(BottomList,6,&Col);
    
		SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
		LvItem.mask = LVIF_TEXT ;
		// first insert locate the product name
/*		if (!_tcscmp(m_ProductName,_T("\0")))

		{	LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
			
		}
		*/
		if (CurrentEntry == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("No Database"), _T("No Items"),MB_OK);
			return FALSE;
		}

		
		
		if (_tcscmp (m_ProductName,_T("\0")))
		{
			
			while (  (!Done) && (CurrentEntry != NULL))
			{
		
				if (!_tcscmp(CurrentEntry->ProductName, m_ProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		else
		{
		
			while (  (!Done) && (CurrentEntry != NULL))
			{
			
				if (!_tcscmp(CurrentEntry->ProductName, CurrentProductName))
					Done = TRUE;
				else
					CurrentEntry = CurrentEntry->pNext;
			}
		}
		
		  	// Now walk down the hotfix list.
		if (CurrentEntry == NULL)
		{
			
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem. lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
		
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL, _T("Product Not found or not selected"), _T("No Items"),MB_OK);
			return FALSE;
		}

		CurrentHotfix = CurrentEntry->HotfixList;
		while ((CurrentHotfix != NULL) && (_tcscmp(CurrentHotfix->HotfixName, m_CurrentHotfix)))
			CurrentHotfix = CurrentHotfix->pNext;

		if ( CurrentHotfix == NULL)
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox(NULL,_T("No Hotfix Found"), _T("No Items"), MB_OK);
			return FALSE;
		}
		if (CurrentHotfix != NULL)
		{
			LvItem.iItem = itemnum;
			
			CurrentFile = CurrentHotfix->FileList;
			if (CurrentFile == NULL)
			{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			LvItem.lParam = NULL;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
//			MessageBox (NULL, _T("No Files Found"), _T("No Items"), MB_OK);
			return FALSE;
			}
			while (CurrentFile != NULL)
			{
				LvItem.pszText = CurrentHotfix->HotfixName;
	    		LvItem.iSubItem = 0;
				ListView_InsertItem(BottomList,&LvItem);
				ListView_SetItemText(BottomList, itemnum, 1 , CurrentFile->FileName);
				ListView_SetItemText(BottomList, itemnum, 2, CurrentFile->FileDate);
				ListView_SetItemText(BottomList, itemnum, 3, CurrentFile->IsCurrent);
				ListView_SetItemText(BottomList, itemnum, 4, CurrentFile->FileVersion);
				ListView_SetItemText(BottomList, itemnum, 5, CurrentFile->InstallPath);
				itemnum++;
				LvItem.iItem = itemnum;
				CurrentFile = CurrentFile->pNext;
			}	
			CurrentHotfix = CurrentHotfix->pNext;
		}
		else
		{
			LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
			return FALSE;
		}
		break;	
		default:
				LoadString(m_hInst,IDS_NO_ITEMS,szBuffer, 255);
			LvItem.iSubItem = 0;
			LvItem.pszText = szBuffer;
			ListView_InsertItem(BottomList,&LvItem);
			return FALSE;
		
	}	// end switch
	SendMessage(BottomList, WM_SETREDRAW, TRUE, 0);
	return TRUE;
}
PPRODUCT CListViews::BuildDatabase(_TCHAR * lpszComputerName)
{

	HKEY		 hPrimaryKey;						// Handle of the target system HKLM 
//	_TCHAR    szPrimaryPath;			 // Path to the update key;

	HKEY		hUpdatesKey;					  // Handle to the updates key.
	_TCHAR   szUpdatesPath[BUFFER_SIZE];				// Path to the udates key
	DWORD   dwUpdatesIndex;			  // index of current updates subkey
	DWORD   dwBufferSize;				  // Size of the product name buffer.



	_TCHAR	 szProductPath[BUFFER_SIZE];				// Path of the current product key
	_TCHAR  szProductName[BUFFER_SIZE];			  // Name of product; also path to product key

	PPRODUCT	pProductList = NULL;			// Pointer to the head of the product list.
	PPRODUCT    pNewProdNode;					// Pointer used to allocate new nodes in the product list.
	PPRODUCT    pCurrProdNode;					  // Used to walk the Products List;

    // Connect to the target registry
	RegConnectRegistry(lpszComputerName,HKEY_LOCAL_MACHINE, &hPrimaryKey);
	// insert error handling here......

	if (hPrimaryKey != NULL)
	{
		// Initialize the primary path not localized since registry keys are not localized.
	    _tcscpy (szUpdatesPath, _T("SOFTWARE\\Microsoft\\Updates"));
		// open the udates key
		RegOpenKeyEx(hPrimaryKey,szUpdatesPath, 0, KEY_READ ,&hUpdatesKey);
        if (hUpdatesKey != NULL)
		{
			// Enumerate the Updates key.
			dwUpdatesIndex = 0;
			while (	RegEnumKeyEx(hUpdatesKey,dwUpdatesIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
			{
				// Create a node for the current product 
				pNewProdNode = (PPRODUCT) malloc(sizeof(PRODUCTLIST));
				_tcscpy(pNewProdNode->ProductName,szProductName);
				
				_tcscpy (szProductPath, szProductName);
				// now get the hotfix for the current product.
				pNewProdNode->HotfixList = GetHotfixInfo(szProductName, &hUpdatesKey);

				 // Insert the new node into the list.
				 pCurrProdNode=pProductList;
				 if (pCurrProdNode == NULL)						// Head of the list
				 {
					 pProductList = pNewProdNode;
					 pProductList->pPrev = NULL;
					 pProductList->pNext = NULL;
				 }
				 else
				 {
					 //Find the end of the list.
					 while (pCurrProdNode->pNext != NULL)
							pCurrProdNode = pCurrProdNode->pNext;
					 // Now insert the new node at the end of the list.
					 pCurrProdNode->pNext = pNewProdNode;
					 pNewProdNode->pPrev = pCurrProdNode;
					 pNewProdNode->pNext = NULL;
				 }

				// increment index and clear the szProducts name string for the next pass.
				
				dwUpdatesIndex++;
				_tcscpy (szProductName,_T("\0"));
				_tcscpy(szProductPath, _T("\0"));
				dwBufferSize = 255;					
			}
		}
		// close the open keys
		RegCloseKey(hUpdatesKey);
		RegCloseKey(hPrimaryKey);
	}
	// return a pointer to the head of our database.
	VerifyFiles(pProductList);
	return pProductList;
}


void BuildQuery (_TCHAR * Path, _TCHAR * FileName, _TCHAR * Result)
{

	_TCHAR * src;
	_TCHAR * dest;
	_TCHAR Temp[255];


	src = Path;
	dest = Temp;


	while (*src != _T('\0'))
	{
		if (*src == _T('\\'))  // if we hit a \ character we need to insert four of them in the dest string.
		{
			for (int i = 0; i < 4; i++)
			{
				*dest = *src;
				++dest;
			}
			++src;
		
		}
		else
		{
			*dest = *src;
			++src;
			++dest;
		}
	
	}
	*dest = _T('\0');

	_stprintf(Result,_T("SELECT * from CIM_DataFile WHERE Name = '%s\\\\\\\\%s'"), Temp, FileName);
	
}
	
BOOL VerifyVersion(_TCHAR * Ver1, _TCHAR * Ver2)
{
	_TCHAR *src1;
	_TCHAR *src2;
	_TCHAR *dest1, *dest2;
	_TCHAR temp[20];
	_TCHAR temp2[20];
	BOOL  Done = FALSE;
	BOOL  Status = TRUE;
	src1 =  Ver1;
	src2 = Ver2;
	dest1 = temp;
	dest2 = temp2;

	if ((!src1) || (!src2))
		return FALSE;

	if (!_tcscmp (src1, src2))
		return TRUE;
	  
	while ( (*src1 != _T('\0')) && (!Done) )
	{
		_tcscpy (temp, _T("\0"));
		_tcscpy (temp2, _T("\0"));
		dest1 = temp;
		dest2 = temp2;
		// Get the next field of the registry string
		while( (*src1 != _T('.')) && (*src1 != _T('\0')))
		{
			*dest1 = *src1;
			++dest1;
			++src1;
		}
		if ( *src1 != _T('\0'))
			++src1; // skip the .
		*dest1 = _T('\0');
		++dest1;
		*dest1= _T('\0');

		// Now get the next field from the WMI returned version.
		while ( (*src2 != _T('.') ) && (*src2 != _T('\0')) )
		{
			*dest2= *src2;
			++dest2;
			++src2;

		}
		if ( *src2 != _T('\0'))
			++src2; // skip the .
		*dest2 = _T('\0');
		++dest2;
		*dest2= _T('\0');
	
        // Now convert the strings to integers.

		if ( _ttol (temp) != _ttol (temp2) )
		{
			Status = FALSE;
			Done = TRUE;
		}
	
		if ( (*src1 == _T('\0')) && (*src2 != _T('\0')) )
		{
			Done = TRUE;
			Status = FALSE;
		}
		if ( ( *src1 != _T('\0')) && (*src2 == _T('\0')) )
		{
			Done = TRUE;
			Status = FALSE;
		}
	}
	return Status;
}

VOID CListViews::VerifyFiles(PPRODUCT Database)
{

	PPRODUCT CurrentProduct = NULL;
	PHOTFIXLIST CurrentHotfix    = NULL;
	PFILELIST CurrentFile        = NULL;
    HRESULT     hres;
	_TCHAR      ConnectString[255];
	_TCHAR     TempBuffer[255];
	 
	    
	    IWbemLocator *pLoc = 0;
		hres = CoCreateInstance(CLSID_WbemLocator, 0,CLSCTX_INPROC_SERVER,IID_IWbemLocator, (LPVOID *) &pLoc);
		if ( FAILED (hres))
		{
//			MessageBox(NULL, _T("Failed to create IWebmLocator Object"),NULL,MB_OK);
		}
		else
		{
			IWbemServices *pSvc = NULL;
			// Build the connection string.
			if (!_tcscmp(m_ComputerName,_T("\0")))
				_stprintf(ConnectString,_T("ROOT\\CIMV2"));
			else
				_stprintf(ConnectString,_T("\\\\%s\\ROOT\\CIMV2"), m_ComputerName);
			_TCHAR * ConnectString1;
			ConnectString1 = SysAllocString(ConnectString);
			// Connect to the default namespace 
			hres = pLoc->ConnectServer(
				ConnectString1,
				NULL,NULL,0,NULL,0,0,&pSvc);
			SysFreeString(ConnectString1);
			if ( FAILED (hres))
			{
				;				
			}
			else
			{
					CoSetProxyBlanket(pSvc, RPC_C_AUTHN_WINNT,RPC_C_AUTHZ_NONE,
					NULL,
					RPC_C_AUTHN_LEVEL_CALL,
					RPC_C_IMP_LEVEL_IMPERSONATE,
					NULL,
					EOAC_NONE);
				IEnumWbemClassObject *pEnum = NULL;
				IWbemClassObject *pObj = NULL;

                // Now Update the Current field of all of the File Entries.
				CurrentProduct = Database;
				_TCHAR Query[255];
				while (CurrentProduct != NULL)
				{
		
					CurrentHotfix = CurrentProduct->HotfixList;
				    while (CurrentHotfix != NULL)
					{
						CurrentFile = CurrentHotfix->FileList;
						while (CurrentFile != NULL)
						{
							_tcscpy (Query,_T("\0"));
							BuildQuery(CurrentFile->InstallPath, CurrentFile->FileName,  Query);

							_TCHAR * bstrQuery = SysAllocString(Query);
							_TCHAR * bstrType = SysAllocString(_T("WQL"));
							hres = pSvc->ExecQuery(bstrType,
								                                       bstrQuery,
																	   WBEM_FLAG_FORWARD_ONLY,
																	   NULL, 
																	   &pEnum);
							SysFreeString (bstrQuery);
							SysFreeString(bstrType);
							if (hres == WBEM_S_NO_ERROR)
							{
									ULONG uReturned = 1;
									while (uReturned == 1)
									{
										hres = pEnum->Next(WBEM_INFINITE ,1,&pObj, &uReturned);
										if ( (SUCCEEDED (hres))  && (uReturned == 1))
										{
												VARIANT pVal;
												VariantClear (&pVal);

												BSTR propName = SysAllocString(L"Version");
    											hres = pObj->Get(propName,
												0L,
												&pVal,
												NULL,
												NULL);


												if  (pVal.vt == VT_NULL)
													;
												else if (pVal.vt == VT_BSTR)
												{
													TCHAR  NewVal[255];
													    _tcscpy (NewVal, pVal.bstrVal);
														//_bstr_t NewVal(pVal.bstrVal,FALSE); 
														if (! _tcscmp(CurrentFile->FileVersion, _T("\0")))
															_tcscpy (CurrentFile->IsCurrent, _T("N\\A"));
														else
														{
															if (VerifyVersion ( CurrentFile->FileVersion, NewVal) )
															{
																LoadString(m_hInst, IDS_YES, TempBuffer, 255);
																_tcscpy(CurrentFile->IsCurrent, TempBuffer);
															}
															else 
															{
																LoadString(m_hInst, IDS_NO, TempBuffer, 255);
																_tcscpy(CurrentFile->IsCurrent,_T("\0"));
															}
														}

													
												}
												if (pObj) pObj->Release();
												
										}
										else
											;
									} // end while uReturned
								
							} 
							// Done with this enumerator
							if (pEnum) pEnum->Release();
							CurrentFile = CurrentFile->pNext;
						}// end while CurrentFile != NULL
						CurrentHotfix = CurrentHotfix->pNext;
					}// end while hotfix != NULL
					CurrentProduct = CurrentProduct->pNext;
				} // end while product != NULL
			}//end else
		} // end else
} // end


					
					
					
				
			
			



PHOTFIXLIST CListViews::GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey )
{
	HKEY			   hHotfixKey = NULL;						// Handle of the hotfix key being processed.
	HKEY			   hProduct = NULL ;				   // Handle to the current product key
    HKEY               hSPKey = NULL; 
	_TCHAR          szHotfixName[BUFFER_SIZE];    // Name of the current hotfix.
    _TCHAR          szValueName[BUFFER_SIZE];
	_TCHAR          szSPName[BUFFER_SIZE];


	PHOTFIXLIST	 pHotfixList = NULL; // Pointer to the head of the hotfix list.
	PHOTFIXLIST  pCurrNode = NULL;				  // Used to walk the list of hotfixes
	PHOTFIXLIST  pNewNode = NULL;				 // Used to create nodes to be added to the list.

	DWORD		   dwBufferSize;			// Size of the product name buffer.
	DWORD          dwValIndex;					  // index of current value.
	DWORD		   dwHotfixIndex = 0;
	BYTE				*Data = NULL;
	DWORD			dwDataSize = BUFFER_SIZE;
	DWORD			dwValType;
	DWORD           dwSPIndex = 0;


	Data = (BYTE *) malloc(BUFFER_SIZE);
    if (Data == NULL)
		return NULL;

	// Open the current product key
	if (*hUpdateKey != NULL)
	{
		RegOpenKeyEx(*hUpdateKey,pszProductName,0 , KEY_READ, &hProduct);
		if (hProduct != NULL)
		{
			dwHotfixIndex = 0;
			dwBufferSize = BUFFER_SIZE;
			dwSPIndex = 0;
			while (RegEnumKeyEx(hProduct,dwSPIndex, szSPName,&dwBufferSize, 0, NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
			{
				 // Open the Service pack Key
				RegOpenKeyEx(hProduct,szSPName,0,KEY_READ,&hSPKey);
				if (hSPKey != NULL)
				{
					// Enumerate the Service Pack key to get the hotfix keys.
					dwBufferSize = BUFFER_SIZE;
					dwHotfixIndex = 0;
					while (RegEnumKeyEx(hSPKey,dwHotfixIndex, szHotfixName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
					{
						
						// now create a new node
							pNewNode = (PHOTFIXLIST) malloc (sizeof(HOTFIXLIST));
							pNewNode->pNext = NULL;
							pNewNode->FileList = NULL;
							_tcscpy(pNewNode->HotfixName,szHotfixName);
							_tcscpy(pNewNode->ServicePack,szSPName);
								_tcscpy(pNewNode->Uninstall,_T("\0"));
							// Open the Hotfix Key
							RegOpenKeyEx(hSPKey,szHotfixName, 0, KEY_READ,&hHotfixKey);
						
						
							if (hHotfixKey != NULL)
							{
								// Now enumerate the values of the current hotfix.
								dwValIndex = 0;
								dwBufferSize =BUFFER_SIZE;
								dwDataSize = BUFFER_SIZE;
								while (RegEnumValue(hHotfixKey,dwValIndex, szValueName,&dwBufferSize, 0,&dwValType, Data, &dwDataSize) != ERROR_NO_MORE_ITEMS)
								{
										// Fill in the hotfix data members.
										_tcslwr(szValueName);
										if (!_tcscmp(szValueName,_T("description")))
											_tcscpy(pNewNode->Description,(_TCHAR *) Data);

										if (!_tcscmp(szValueName,_T("installeddate")))
											_tcscpy(pNewNode->InstalledDate,(_TCHAR *) Data);

										if (!_tcscmp(szValueName,_T("type")))
											_tcscpy(pNewNode->Type,(_TCHAR*) Data);

										if (!_tcscmp(szValueName,_T("installedby")))
											_tcscpy(pNewNode->InstalledBy , (_TCHAR*) Data);

										if (!_tcscmp(szValueName,_T("uninstallcommand")))
											_tcscpy(pNewNode->Uninstall, (_TCHAR*)Data);
										++ dwValIndex;
										_tcscpy (szValueName, _T("\0"));
										ZeroMemory(Data,BUFFER_SIZE);
										dwValType = 0;
										dwBufferSize =BUFFER_SIZE;
										dwDataSize   = BUFFER_SIZE;
								}
								// Get the file list for the current hotfix.
								pNewNode->FileList = GetFileInfo(&hHotfixKey);
								//insert the new node at the end of the hotfix list.
							   pCurrNode = pHotfixList;
								if (pCurrNode == NULL)
								{
									pHotfixList = pNewNode;
									pHotfixList->pPrev = NULL;
									pHotfixList->pNext = NULL;


								}
								else
								{
									 pCurrNode = pHotfixList;
									 while (pCurrNode->pNext != NULL)
										 pCurrNode = pCurrNode->pNext;
									 pCurrNode->pNext = pNewNode;
									 pNewNode->pPrev = pCurrNode;
									 pNewNode->pNext = NULL;
								}
								// Close the current Hotfix Key
								RegCloseKey(hHotfixKey);

								// Clear the strings.
							 _tcscpy(szHotfixName,_T("\0"));

								// increment the current index
								++dwHotfixIndex;
								dwBufferSize = BUFFER_SIZE;
							}
					}
					RegCloseKey(hSPKey);
					_tcscpy (szSPName,_T("\0"));
					dwBufferSize = BUFFER_SIZE;
					dwSPIndex++;
				}
			}// end enum SP keys.
			// Close all open keys
			RegCloseKey(hProduct);
		}
		if (Data != NULL)
			free (Data);
	}
	return pHotfixList;
}
PFILELIST CListViews::GetFileInfo(HKEY* hHotfixKey)
{
		PFILELIST			   pFileList = NULL;				   // Pointer to the head of the file list.
//		_TCHAR				 szFilePath;				// Path to the files subkey.
		PFILELIST			   pNewNode = NULL;
		PFILELIST			   pCurrNode = NULL;;
		BYTE *					Data;
		DWORD				 dwBufferSize = BUFFER_SIZE;
		DWORD				 dwDataSize	  = BUFFER_SIZE;
		DWORD				 dwFileIndex	= 0;
		DWORD				 dwPrimeIndex = 0;
		DWORD				 dwValType = 0;
		HKEY					hPrimaryFile;
		HKEY					hFileKey;
		_TCHAR				 szFileSubKey[BUFFER_SIZE];
		_TCHAR				 szValueName[BUFFER_SIZE];
	
		Data = (BYTE *) malloc(BUFFER_SIZE);
			ZeroMemory(Data,BUFFER_SIZE);
		// Open the files subkey of the current hotfix
	   if (RegOpenKeyEx(*hHotfixKey, _T("FileList"),0,KEY_READ,&hPrimaryFile) != ERROR_SUCCESS)
	   {
		     
			return NULL;
	   }
		_tcscpy(szValueName,_T("\0"));
		while (RegEnumKeyEx(hPrimaryFile,dwPrimeIndex,szFileSubKey, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
		{

			// open the subfile key
			RegOpenKeyEx(hPrimaryFile,szFileSubKey,0,KEY_READ,&hFileKey);
			dwFileIndex = 0;
		// Enumerate the file(x) subkeys of the file subkey
			dwDataSize	  = BUFFER_SIZE;
			dwBufferSize = BUFFER_SIZE;
			pNewNode = (PFILELIST) malloc (sizeof(FILELIST));
			pNewNode->pNext = NULL;
			pNewNode->pPrev = NULL;
			_tcscpy (pNewNode->IsCurrent,_T("\0"));
			_tcscpy(pNewNode->FileDate,_T("\0"));
		
			while (RegEnumValue(hFileKey,dwFileIndex,szValueName,&dwBufferSize,0,&dwValType,Data,&dwDataSize) != ERROR_NO_MORE_ITEMS)
			{
				
				_tcslwr(szValueName);

				// now find out which value we have and insert it into the node
				if (! _tcscmp(szValueName,_T("filename")))
				{
					_tcscpy(pNewNode->FileName,(_TCHAR *) Data);
				}
				if (! _tcscmp(szValueName,_T("version")))
				{
					_tcscpy(pNewNode->FileVersion,(_TCHAR*)Data);
				}
				if (!_tcscmp(szValueName,_T("builddate")))
				{		    
					_tcscpy(pNewNode->FileDate,(_TCHAR*) Data);
				}
				if (! _tcscmp(szValueName, _T("location")))
				{
					_tcscpy(pNewNode->InstallPath, (_TCHAR*) Data);
			
				}

				dwFileIndex ++;
				_tcscpy(szValueName,_T("\0"));
				ZeroMemory(Data,BUFFER_SIZE);
				dwValType = 0;
				dwBufferSize = BUFFER_SIZE;
				dwDataSize = BUFFER_SIZE;
			}
			RegCloseKey(hFileKey);
			    // add the current node to the list if not stored in dll cache
			_TCHAR TempString[255];
			_tcscpy (TempString, pNewNode->InstallPath);
			_tcslwr(TempString);
			if (  (_tcsstr (TempString, _T("dllcache")) == NULL ) && (_tcsstr (TempString, _T("driver cache") )== NULL))
			{
				pCurrNode = pFileList;
				if (pNewNode != NULL)
				{
					if (pFileList == NULL)
					{
						pFileList = pNewNode;
					}
					else
					{
						
						while (pCurrNode->pNext != NULL)
							pCurrNode = pCurrNode->pNext;
						pCurrNode->pNext = pNewNode;
						pNewNode->pPrev = pCurrNode;
					}
				}
			}
			else // otherwise free the node.
				free (pNewNode);
			++dwPrimeIndex;
		} // end enum of primary file key
		RegCloseKey(hPrimaryFile);
		if (Data != NULL)
			free (Data);
		return pFileList;
}

_TCHAR * CListViews::GetCurrentHotfix()
{
	return m_CurrentHotfix;
}


void CListViews::SetViewMode(DWORD ViewType) 
{
	m_CurrentView = ViewType;
    _tcscpy (m_CurrentHotfix,_T("\0"));
	EnableWindow(m_UninstButton,FALSE);
	EnableWindow(m_WebButton,FALSE);
	switch (ViewType)
	{
	case VIEW_BY_FILE:
			if (! _tcscmp(m_ProductName,_T("\0")))
				m_CurrentView = VIEW_ALL_FILE;
			else
				m_CurrentView = VIEW_BY_FILE;
		break;
	case VIEW_BY_HOTFIX:
	        if (! _tcscmp(m_ProductName,_T("\0")))
				m_CurrentView =VIEW_ALL_HOTFIX;
			else
				m_CurrentView = VIEW_BY_HOTFIX;
			
	    break;
	}
	AddItemsTop();
	AddItemsBottom();
	
}

void CListViews::SetProductName(_TCHAR * NewName) 
{ 
	_tcscpy (m_ProductName,NewName);
	 _tcscpy(m_ProductName, NewName);
	 EnableWindow(m_WebButton, FALSE);
	 EnableWindow(m_UninstButton,FALSE);
	_tcscpy(m_CurrentHotfix, _T("\0"));
	if (_tcscmp(NewName, _T("\0")))
	{
		switch (m_CurrentView)
		{
		case VIEW_ALL_FILE:
			m_CurrentView = VIEW_BY_FILE;
			break;
		case VIEW_ALL_HOTFIX:
			m_CurrentView = VIEW_BY_HOTFIX;
			break;
	
		}
	}
	if (!_tcscmp(NewName, _T("\0")))
	{
		switch (m_CurrentView)
		{
		case VIEW_BY_FILE:
			m_CurrentView = VIEW_ALL_FILE;
					break;
		case VIEW_BY_HOTFIX:
			m_CurrentView = VIEW_ALL_HOTFIX;
			break;
		default:
			m_CurrentView = VIEW_ALL_HOTFIX;
		}
			_tcscpy(m_ProductName,_T("\0"));
			_tcscpy(m_CurrentHotfix,_T("\0"));
	}

	
	AddItemsTop();
	AddItemsBottom();
}

BOOL CListViews::FreeFileList(PFILELIST CurrentFile)
{
	while (CurrentFile->pNext->pNext != NULL)
			CurrentFile = CurrentFile->pNext;

		//Remove the file list
	while ( (CurrentFile->pPrev != NULL) && (CurrentFile->pNext != NULL) )
	{
		free ( CurrentFile->pNext );
		CurrentFile = CurrentFile->pPrev ;
	}
	if (CurrentFile != NULL)
	free (CurrentFile);
	CurrentFile = NULL;
	return TRUE;
}

BOOL CListViews::FreeHotfixList (PHOTFIXLIST CurrentHotfix)
{
	PFILELIST CurrentFile;

	while (CurrentHotfix->pNext != NULL)
			CurrentHotfix = CurrentHotfix->pNext;

	if (CurrentHotfix->pPrev != NULL)
		CurrentHotfix = CurrentHotfix->pPrev;
		//Remove the Hotfix list
	while ( (CurrentHotfix->pPrev != NULL) && (CurrentHotfix->pNext != NULL) )
	{
		CurrentFile = CurrentHotfix->pNext->FileList ;
		FreeFileList (CurrentFile);
		free ( CurrentHotfix->pNext );
		CurrentHotfix = CurrentHotfix->pPrev ;
	}
	if (CurrentHotfix != NULL)
	free (CurrentHotfix);
	return TRUE;
}
BOOL CListViews::FreeDatabase()
{


	PPRODUCT CurrentProduct = DataBase;
	PHOTFIXLIST CurrentHotfix;
	PFILELIST   CurrentFile;

	while (CurrentProduct->pNext->pNext != NULL) 
			CurrentProduct = CurrentProduct->pNext;

	while (CurrentProduct->pPrev != NULL)
	{
	
		CurrentHotfix = CurrentProduct->HotfixList;
		FreeHotfixList(CurrentHotfix);
		CurrentProduct = CurrentProduct->pPrev ;
	}

	if (CurrentProduct != NULL)
		free(CurrentProduct);
	DataBase = NULL;
	return TRUE;
}

BOOL CListViews::Uninstall()
{
	char temp[255];
	
	PPRODUCT pProduct = NULL;
	PHOTFIXLIST pHotfix = NULL;
    
	
	pProduct = DataBase;
	BOOL Done = FALSE;

	if (_tcscmp  (m_ProductName,_T("\0")))
	{
		while (  (!Done) && (pProduct != NULL))
		{
		
			 if (!_tcscmp(pProduct->ProductName, m_ProductName))
				Done = TRUE;
			else
				pProduct = pProduct->pNext;
		}
	}
	else
	{
		while (  (!Done) && (pProduct != NULL))
		{
		
			 if (!_tcscmp(pProduct->ProductName, CurrentProductName))
				Done = TRUE;
			else
				pProduct = pProduct->pNext;
		}
	}


	if (pProduct != NULL)
		pHotfix = pProduct->HotfixList;

	if (pHotfix != NULL)
	{
		Done = FALSE;
		while( (!Done) && (pHotfix != NULL) )
		{ 
			if ( ! _tcscmp(pHotfix->HotfixName,m_CurrentHotfix)) 
				Done = TRUE;
			else
				pHotfix = pHotfix->pNext;
		}
		if (pHotfix != NULL)
		{
			if (_tcscmp(pHotfix->Uninstall, _T("\0")))
			{
				_TCHAR TempString[255];
				_TCHAR TempString2[255];
				LoadString(m_hInst,IDS_UNINSTAL_WRN,TempString,255);
				_tcscat (TempString, pHotfix->HotfixName);
				LoadString(m_hInst,IDS_UNINSTAL_WRN_TITLE,TempString2,255);
				if (::MessageBox(NULL,TempString,TempString2, MB_OKCANCEL) != IDCANCEL)
				{
					wcstombs(temp,pHotfix->Uninstall,255);
      				WinExec( (char*)temp, SW_SHOWNORMAL);
					// Free the database
					FreeDatabase();
					DataBase = NULL;
					BuildDatabase( m_ComputerName);
				}
			}
		}
	}
	return TRUE;
}


	void InitializeOfn(OPENFILENAME *ofn)
	{


		static _TCHAR szFilter[] =  _T("Text (Comma Delimited) (*.csv)\0*.csv\0\0") ;
													
											

		ofn->lStructSize = sizeof (OPENFILENAME);
		ofn->hwndOwner = NULL;
		ofn->hInstance = NULL;
		ofn->lpstrFilter = szFilter;
		ofn->lpstrCustomFilter = NULL;
		ofn->nMaxCustFilter = 0;
		ofn->lpstrFile = NULL;
		ofn->nMaxFile = MAX_PATH;
		ofn->lpstrFileTitle = NULL;
		ofn->Flags = OFN_OVERWRITEPROMPT;
		ofn->nFileOffset = 0;
		ofn->nFileExtension  = 0;
		ofn->lpstrDefExt = _T("csv");
		ofn->lCustData = 0L;
		ofn->lpfnHook = NULL;
		ofn->lpTemplateName = NULL;
	}
void CListViews::SaveToCSV()
{
	PPRODUCT    pProduct = NULL;
	PHOTFIXLIST pHotfix = NULL; 
	PFILELIST       pFileList = NULL;
	_TCHAR        *Buffer;
	DWORD        LineLength = 0;
	HANDLE		 hFile = NULL;
	DWORD		 BytesWritten = 0;
	DWORD LineSize = 0;

	char			  *Buffer2;


	static OPENFILENAME ofn;
	 _TCHAR FileName[MAX_PATH];
	_tcscpy (FileName,_T("\0"));
	 InitializeOfn (&ofn);
	 ofn.lpstrFile = FileName;
	 if ( !GetSaveFileName(&ofn) )
	 {
		 return;
	 }
	// open the file
    hFile = CreateFile( FileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	
	if ( hFile == INVALID_HANDLE_VALUE)
	{
	
		LPVOID lpMsgBuf;
FormatMessage( 
    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
    FORMAT_MESSAGE_FROM_SYSTEM | 
    FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL,
    GetLastError(),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
    (LPTSTR) &lpMsgBuf,
    0,
    NULL 
);
// Process any inserts in lpMsgBuf.
// ...
// Display the string.
//	MessageBox( NULL, (LPCTSTR)lpMsgBuf,_T(" Error"), MB_OK | MB_ICONINFORMATION );
// Free the buffer.
LocalFree( lpMsgBuf );

		return;
	} 
	// Store Headers
	Buffer = (_TCHAR *) malloc (2000);
	Buffer2 = (char*) malloc(2000);
	LoadString(m_hInst,IDS_CSV_HEADER,Buffer,1000);
	//_stprintf(Buffer, _T("Product,Service Pack,Article,InstalledBy,InstalledDate,FileName,FileVersion,FileDate,InstallPath,Current\r"));
	wcstombs(Buffer2,Buffer, _msize(Buffer2) );
	WriteFile(hFile,Buffer2, strlen(Buffer2), &BytesWritten, NULL);

	if (Buffer)
		free (Buffer);
	if (Buffer2)
		free (Buffer2);

	Buffer = NULL;
	Buffer2 = NULL;



	// Run through the Data base and write the info to the file.
	pProduct = DataBase;
	while (pProduct != NULL)
	{
		pHotfix = pProduct->HotfixList;

		while (pHotfix != NULL)
		{
			pFileList = pHotfix->FileList;
			while (pFileList != NULL)
			{
				// Build the CSV output string
				// Product,Article,Description, ServicePack, By, Date, Type, FileName, Version, Date,Current,InstallPath
			
				// Add up the string lengths and allocata a large enough buffer.
				LineLength = _tcslen(pProduct->ProductName) + _tcslen(pHotfix->ServicePack)+
									   _tcslen(pHotfix->HotfixName) + _tcslen(pHotfix->Description )+ _tcslen(pHotfix->InstalledBy ) +
										_tcslen(pHotfix->InstalledDate)  +  _tcslen(pHotfix->Type) +
										_tcslen(pFileList->FileName ) + _tcslen(pFileList->FileVersion ) +
										_tcslen(pFileList->FileDate  ) + _tcslen(pFileList->InstallPath )+
										_tcslen(pFileList->IsCurrent  );
				Buffer = (_TCHAR *) malloc ( LineLength * sizeof (_TCHAR ) *2) ;
				Buffer2 = (char  *) malloc (LineLength *2);
				//ZeroMemory(Buffer, (LineLength * sizeof (_TCHAR)) +2);
				_tcscpy (Buffer,_T("\0"));
				strcpy(Buffer2,"\0");
				if (!Buffer)
					MessageBox (NULL,_T("NO Memory"),NULL, MB_OK);
				else
				{
				_stprintf(Buffer,_T("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\r\0\0"),pProduct->ProductName,
					pHotfix->ServicePack,pHotfix->HotfixName,pHotfix->Description ,pHotfix->InstalledBy, pHotfix->InstalledDate, 
					pHotfix->Type,pFileList->FileName,pFileList->FileVersion,pFileList->FileDate ,
					pFileList->InstallPath,pFileList->IsCurrent);
				
				// Write the line to the file
				LineSize = 0;
				LineSize = 	wcstombs(Buffer2,Buffer, _msize (Buffer2) );
				strcat(Buffer2,"\0");
				WriteFile(hFile, Buffer2, LineSize, &BytesWritten, NULL);
				}
				// Free the buffer and zero the line length for next pass.
				if (Buffer)
				{
					free (Buffer);
					free (Buffer2);
				}
				Buffer = NULL;
				Buffer2 = NULL;
				LineLength = 0;
				pFileList = pFileList->pNext;
			}
			pHotfix = pHotfix->pNext;
		}
		pProduct = pProduct->pNext;
	}
	CloseHandle(hFile);
}


DWORD CListViews::GetState()
{
	DWORD dwStatus =0;
    PPRODUCT CurrentProduct;
	PHOTFIXLIST CurrentHotfix;
	BOOL Done = FALSE;;


	switch (m_CurrentView)
	{
	case VIEW_ALL_FILE:
	case VIEW_BY_FILE:
		dwStatus |= STATE_VIEW_FILE;
		break;
	case VIEW_ALL_HOTFIX:
	case VIEW_BY_HOTFIX:
		dwStatus |= STATE_VIEW_HOTFIX;
		break;
	}

	// Do we have a database.
	if (DataBase == NULL)
		return dwStatus;

	// Does the database contain any data...
	    // A case can arise if a hotfix is installed and then uninstalled where the Registry keys 
	    // for the Product and Service Pack are not removed. We need to have at least 1 hotfix list.
     CurrentProduct = DataBase;
	 while ( (CurrentProduct != NULL) && (!Done))
	 {
		 if (CurrentProduct ->HotfixList != NULL)
			 Done = TRUE;
		 CurrentProduct = CurrentProduct->pNext;
	 }
	 if (!Done)
	 {
		//dwStatus = 0;
		 return dwStatus;
	 }
	 else 
	 {
		 // We do have data in the database so we can enable the Export list and Print options.
		 dwStatus |= DATA_TO_SAVE;
		 dwStatus |= OK_TO_PRINT;
	 }
	 	
	// Do we have a hotfix selected 
	if (_tcscmp(m_CurrentHotfix,_T("\0")))
		dwStatus |= HOTFIX_SELECTED;
    else
	{
		// If we don't have a selected hotfix we cant view the web or uninstall so 
		// Just return the current status

		return dwStatus;
	}

	// Now we need to see if we have an uninstall string for the current hotfix
	CurrentProduct = DataBase;
	// Find the selected product
	Done = FALSE;
	while ( (CurrentProduct != NULL) && (!Done))
	{
		if (!_tcscmp(CurrentProduct->ProductName ,m_ProductName))
		{
			// Find the selected hotfix
			CurrentHotfix = CurrentProduct->HotfixList;
			while ((CurrentHotfix != NULL) && (!Done))
			{
				if (! _tcscmp (CurrentHotfix->HotfixName, m_CurrentHotfix))
				{
						// Now verify the uninstall string exists
					    if (_tcscmp(CurrentHotfix->Uninstall, _T("\0")))
						{
							
							// Now verify the directory still exists
							_TCHAR TempString[255];
							_tcscpy (TempString,CurrentHotfix->Uninstall);
							PathRemoveArgs(TempString);
						    if (  PathFileExists( TempString  ))
							{
								// Yes it does we can enable uninstall
								dwStatus |=UNINSTALL_OK;
							}
							
						}
						Done = TRUE;
				}
				CurrentHotfix = CurrentHotfix->pNext;
				
			}
		}
		CurrentProduct = CurrentProduct->pNext;
	}

	

	return dwStatus;
}

_TCHAR * BuildDocument()
{


//	_TCHAR Document;
	return NULL;
}

BOOL CALLBACK AbortProc(HDC hPrinterDC, int iCode)
{
	MSG msg;
	while (!bUserAbort && PeekMessage (&msg, NULL,0,0,PM_REMOVE))
	{
		if (!hDlgPrint || !IsDialogMessage (hDlgPrint, &msg))
		{
			TranslateMessage (&msg);
			DispatchMessage (&msg);
		}
	}
	return !bUserAbort;
}

BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
	case WM_INITDIALOG :
		EnableMenuItem (GetSystemMenu (hDlg,FALSE), SC_CLOSE, MF_GRAYED);
		return TRUE;
	case WM_COMMAND:
		bUserAbort = TRUE;
		EnableWindow (GetParent (hDlg), TRUE);
		DestroyWindow (hDlg);
	    hDlgPrint = NULL;
		return TRUE;
	}
	return FALSE;
}

BOOL JustifyString( _TCHAR* String, int FieldLength, BOOL Left)
{
	_TCHAR TempString[255];
    int   i= 0;
	int   NumSpaces = 0;
	_TCHAR Message[100];
	_TCHAR *src, *dest;



	if (String == NULL)
	{
		return FALSE;
	}

	if (Left)
	{
			// String leading spaces.
		src = String;
		dest = TempString;
		while (*src == _T(' '))
			++src;

		while (*src != _T('\0'))
		{
			*dest = *src;
			++src;
			++dest;
		}
		*dest = _T('\0');
		++dest;
		*dest = _T('\0');
		NumSpaces = (FieldLength - _tcslen(TempString) );
		_stprintf(Message,_T("FieldSize: %d, String Length: %d"),FieldLength, _tcslen(TempString));
	//	MessageBox(NULL,Message,_T("Justify"),MB_OK);
		while (NumSpaces >0)
		{
			_tcscat(TempString,_T(" "));
			--NumSpaces;
		}
	    _tcscpy (String, TempString);
		_stprintf(Message,_T("NewString Length: %d"),_tcslen(String));
	//	MessageBox(NULL,Message,_T("New String Length"),MB_OK);
		
	}
	else
	{

		_tcscpy(TempString,_T("\0"));

		NumSpaces = FieldLength - _tcslen(String);
		if (NumSpaces > 0 )
		{
			for (i = 0 ; i < NumSpaces;i++)
				TempString[i] = _T(' ');
			TempString[i] = _T('\0');
			_tcscat(TempString,String);
			_tcscpy(String,TempString);
		}
	}
	return TRUE;
}

void GetFont ( int PointSize, BOOL Bold, BOOL Underlined, LOGFONT * lf, HDC hDC)
{
	POINT pt;

	lf->lfHeight = PointSize * 10;
	pt.y = GetDeviceCaps(hDC, LOGPIXELSY) * lf->lfHeight;
	pt.y /= 720;    // 72 points/inch, 10 decipoints/point
	DPtoLP(hDC, &pt, 1);
	POINT ptOrg = { 0, 0 };
	DPtoLP(hDC, &ptOrg, 1);
	lf->lfHeight = -abs(pt.y - ptOrg.y);
	if (Underlined)
		lf->lfUnderline = TRUE;
	else
		lf->lfUnderline = FALSE;
	if (Bold)
		lf->lfWeight = FW_BOLD;
	else
		lf->lfWeight = FW_NORMAL;
	

}


void NewPage (HDC hDC, _TCHAR *Header1, _TCHAR * Header2, DWORD * CurrentLine, LOGFONT * lf)
{
	TEXTMETRIC tm;
	SIZE size;
	DWORD xStart;
	DWORD yChar;
	RECT  rect;


	rect.left = (LONG) (0 + GetDeviceCaps(hDC, LOGPIXELSX) * 0.5);
	rect.right =  (LONG) (GetDeviceCaps(hDC, PHYSICALWIDTH) -(1+ (GetDeviceCaps(hDC, LOGPIXELSX) / 2)));
	rect.top =  (LONG) (1 + GetDeviceCaps(hDC, LOGPIXELSY) * 0.5);
	rect.bottom =  (LONG) (GetDeviceCaps(hDC, PHYSICALHEIGHT) - GetDeviceCaps(hDC, LOGPIXELSX) * 0.5);
	if (StartPage(hDC) > 0)
	{
		*CurrentLine = 1;
		GetFont (12,TRUE,TRUE,lf,hDC);
		SelectObject(hDC, CreateFontIndirect(lf));
		GetTextMetrics(hDC,&tm);
		yChar = tm.tmHeight + tm.tmExternalLeading ;
		GetTextExtentPoint32(hDC, Header1,_tcslen(Header1),&size);

		xStart = (rect.right - rect.left)/2 - size.cx/2 ;
		TextOut (hDC, xStart,(*CurrentLine)* yChar ,Header1, _tcslen(Header1) );

		GetFont (10,FALSE, FALSE, lf, hDC);
		SelectObject(hDC, CreateFontIndirect (lf));
		GetTextMetrics (hDC, &tm);
		yChar = tm.tmHeight + tm.tmExternalLeading ;
		xStart = rect.right - ((_tcslen(Header2) +2) * tm.tmAveCharWidth);
		TextOut(hDC, xStart,(*CurrentLine) * yChar, Header2, _tcslen(Header2));

		(*CurrentLine) += 4;
	}
	


}
void CListViews::PrintReport()
{
	static DOCINFO	di = {sizeof (DOCINFO)  } ;
	static PRINTDLG pd;
	BOOL			bSuccess;
	int				yChar, iCharsPerLine, iLinesPerPage;


	_TCHAR			Header1[255];
	_TCHAR			Header2[255];
	TEXTMETRIC		tm;

	_TCHAR			Line [255];
	PPRODUCT		CurrentProduct;
	PHOTFIXLIST		CurrentHotfix;
	PFILELIST		CurrentFile;
	DWORD			CurrentLine = 0;
	DWORD			yStart = 0;
	_TCHAR			TempBuffer[255];
	RECT			rect;
    SIZE			size;
	_TCHAR *		src;
	DWORD			xStart;
	static LOGFONT	lf;
	SYSTEMTIME		systime;
	BOOL			Done = FALSE;
	_TCHAR			SystemDate[255];
	_TCHAR			SystemTime[255];

	_TCHAR			TempBuffer1[255];
	_TCHAR			TempBuffer2[255];
	// invoke Print common dialog box

	GetLocalTime(&systime);
	GetDateFormatW (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,NULL, SystemDate,255);
	GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &systime,NULL,SystemTime,255);
	CurrentProduct = DataBase;
	pd.lStructSize = sizeof (PRINTDLG);
	pd.hwndOwner = TopList; //m_hWnd;
	pd.hDevMode = NULL;
	pd.hDevNames= NULL;
	pd.hDC= NULL;
	pd.Flags = PD_ALLPAGES | PD_COLLATE |
					   PD_RETURNDC | PD_NOSELECTION ;
	pd.nFromPage = 0;
	pd.nToPage = 0;
	pd.nMinPage = 0;
	pd.nMaxPage = 0;
	pd.nCopies = 1;
	pd.hInstance = NULL;
	pd.lCustData = 0L;
	pd.lpfnPrintHook = NULL;
	pd.lpfnSetupHook = NULL;
	pd.lpPrintTemplateName = NULL;
	pd.lpSetupTemplateName = NULL;
	pd.hPrintTemplate = NULL;
	pd.hSetupTemplate = NULL;
 	
	if (!PrintDlg (&pd) )
			return; //TRUE;

	else
	{
		
		// Setup the printer dimensions.
		
		rect.left = (LONG) (0 + GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.right =  (LONG) (GetDeviceCaps(pd.hDC, PHYSICALWIDTH) - GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.top =  (LONG) (1 + GetDeviceCaps(pd.hDC, LOGPIXELSY) * 0.5);
		rect.bottom = (LONG) ( GetDeviceCaps(pd.hDC, PHYSICALHEIGHT) - GetDeviceCaps(pd.hDC, LOGPIXELSX) * 0.5);
		rect.bottom -= 100;


		bSuccess = TRUE;
		bUserAbort = TRUE;
		hDlgPrint = CreateDialog(m_hInst, _T("PrintDlgBox"),
		TopList, PrintDlgProc );
	   
		di.lpszDocName = _T("Hotfix Manager"); 
		SetAbortProc(pd.hDC, AbortProc);

		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		_tcscpy(logFont.lfFaceName, _T("Dlg Shell Font"));
		
		LoadString(m_hInst, IDS_UPDATE_REPORT, TempBuffer, 255);
		_stprintf(Header1,_T("%s %s"), TempBuffer,m_ComputerName);
		_stprintf(Header2, _T("%s %s"),SystemDate,SystemTime);

		StartDoc(pd.hDC,&di);
			
			
					_tcscpy (Line,_T("\0"));
							
					NewPage (pd.hDC, Header1,Header2, &CurrentLine, &logFont);
					GetTextMetrics(pd.hDC,&tm);
					yChar = tm.tmHeight + tm.tmExternalLeading ;
    				iCharsPerLine = GetDeviceCaps (pd.hDC, HORZRES) / tm.tmAveCharWidth ;
					iLinesPerPage = GetDeviceCaps (pd.hDC, VERTRES) / yChar ;
					_tcscpy (Line,_T("\0"));
					xStart = rect.left;
					while ( (CurrentProduct != NULL) && (!Done))
					{
						
						_tcscpy (Line,_T("\0"));
						LoadString(m_hInst,IDS_PRODUCT_NAME, TempBuffer,255);
						logFont.lfWeight = FW_BOLD;
						SelectObject(pd.hDC,CreateFontIndirect (&logFont));
						GetTextMetrics (pd.hDC, &tm);
					
						_stprintf (Line, _T("%s: "), TempBuffer);
						yStart = CurrentLine * yChar;
						if (yStart >=  (UINT) rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						}
					
						TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
						xStart = rect.left + ((_tcslen(Line) + 4 )* tm.tmAveCharWidth);
						logFont.lfWeight = FW_NORMAL;
						SelectObject(pd.hDC,CreateFontIndirect (&logFont));
						GetTextMetrics (pd.hDC, &tm);
					
						_tcscpy (Line, CurrentProduct->ProductName);
					
						TextOut(pd.hDC, xStart, yStart , Line, _tcslen(Line) );
						CurrentLine ++;
						yStart = CurrentLine * yChar;
						if (yStart >=   (UINT)rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						}
						xStart = rect.left; 
						CurrentHotfix = CurrentProduct->HotfixList;
						while ( (CurrentHotfix != NULL ) && (!Done))
						{
							
							_stprintf (Line, _T("%s \t%s"),CurrentHotfix->HotfixName,CurrentHotfix->Description );
							TabbedTextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line),0,NULL,0 );
							++CurrentLine;
							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							}
							LoadString (m_hInst,IDS_SERVICE_PACK, TempBuffer, 255);
							LoadString (m_hInst,IDS_INSTALL_DATE, TempBuffer1, 255);
							LoadString (m_hInst,IDS_INSTALLED_BY, TempBuffer2, 255);
						
							_stprintf(Line, _T("\t\t%s: %s \t%s: %s \t%s: %s"), TempBuffer,   CurrentHotfix->ServicePack,
																		TempBuffer1, CurrentHotfix->InstalledDate,
																		TempBuffer2, CurrentHotfix->InstalledBy);
						//	_stprintf (Line, _T("\t\tService Pack: %s\tInstall Date: %s\tInstalled By %s"),
							//	CurrentHotfix->ServicePack,CurrentHotfix->InstalledDate, CurrentHotfix->InstalledBy);
							TabbedTextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line),0,NULL,0 );

							CurrentLine +=2;
							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							} 
							CurrentFile = CurrentHotfix->FileList ;
							if (CurrentFile == NULL)
							{
								_tcscpy (Line, _T("\0"));
								LoadString(m_hInst,IDS_NO_FILES,Line,255);
								TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
								CurrentLine += 2;
								if (yStart >=  (UINT) rect.bottom)
								{
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
							}
							else
							{
								logFont.lfUnderline = TRUE;
								logFont.lfWeight = FW_BOLD;
								SelectObject(pd.hDC, CreateFontIndirect (&logFont));
								_tcscpy (Line, _T("\0"));
								LoadString (m_hInst, IDS_FILE,TempBuffer,255);
							    JustifyString(TempBuffer,FILENAME_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILEDATE,TempBuffer,255);
							    JustifyString(TempBuffer,DATE_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 29 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );
								
								LoadString (m_hInst, IDS_FILEVERSION,TempBuffer,255);
							    JustifyString(TempBuffer,VERSION_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 45 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILECURRENT,TempBuffer,255);
							    JustifyString(TempBuffer,CURRENT_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart + 61* tm.tmAveCharWidth,yStart ,TempBuffer, _tcslen(TempBuffer) );

								LoadString (m_hInst, IDS_FILEPATH,TempBuffer,255);
							    JustifyString(TempBuffer,PATH_FIELD_WIDTH,TRUE);
								TextOut( pd.hDC, xStart+72 * tm.tmAveCharWidth ,yStart ,TempBuffer, _tcslen(TempBuffer) );
								++ CurrentLine;
								yStart = CurrentLine * yChar;
								if (yStart >=   (UINT)rect.bottom)
								{
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
							}
							while ( (CurrentFile != NULL) && (!Done) )
							{
								logFont.lfWeight = FW_NORMAL;
								logFont.lfUnderline = FALSE;
								SelectObject(pd.hDC, CreateFontIndirect (&logFont));
								_tcscpy (Line, _T("\0"));

								_tcscpy (Line, CurrentFile->FileName);
							//	JustifyString(Line,40, TRUE);
								TextOut (pd.hDC, xStart,yStart ,Line, _tcslen(Line) );
							//_tcscat (Line,TempBuffer);

								_tcscpy (Line, CurrentFile->FileDate);
							//	JustifyString(Line,20, TRUE);
								TextOut (pd.hDC, xStart + 29 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line, CurrentFile->FileVersion );
							//	JustifyString(Line,18, TRUE);
								TextOut (pd.hDC, xStart + 45 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line, CurrentFile->IsCurrent);
							//	JustifyString(Line,12, TRUE);
								TextOut (pd.hDC, xStart + 61 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );

								_tcscpy (Line,CurrentFile->InstallPath);
								TextOut (pd.hDC, xStart + 72 * tm.tmAveCharWidth,yStart ,Line, _tcslen(Line) );
								++CurrentLine;

								yStart = CurrentLine * yChar;
								if (yStart >=   (UINT)rect.bottom)
								{
//									MessageBox (NULL,_T("Hit Page Break Code"),NULL,MB_OK);
									EndPage(pd.hDC);
									NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
									yStart = CurrentLine * yChar;
								} 
								CurrentFile = CurrentFile->pNext;
								if (!bUserAbort)
									Done = TRUE;
								
							} // End While Current File
							++CurrentLine;

							yStart = CurrentLine * yChar;
							if (yStart >=   (UINT)rect.bottom)
							{
								EndPage(pd.hDC);
								NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
								yStart = CurrentLine * yChar;
							} 
							CurrentHotfix = CurrentHotfix->pNext;
							if (!bUserAbort)
								Done = TRUE;
						}
						++CurrentLine;
						yStart = CurrentLine * yChar;
						if (yStart >=   (UINT)rect.bottom)
						{
							EndPage(pd.hDC);
							NewPage(pd.hDC, Header1,Header2, &CurrentLine, &logFont);
							yStart = CurrentLine * yChar;
						} 
						CurrentProduct = CurrentProduct->pNext;
						if (!bUserAbort)
							Done = TRUE;
					}

					if (EndPage(pd.hDC) > 0)
						EndDoc(pd.hDC);
					DeleteDC(pd.hDC);
					DestroyWindow(hDlgPrint);
				
				
			
		

		
	}
	return; //FALSE;
}


int CALLBACK CListViews::CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int Result = -1;
	int SubItemIndex = (INT) lParamSort;
	
	_TCHAR String1[1000];
	_TCHAR String2 [1000];


	ListView_GetItemText( TopList, lParam1, SubItemIndex, String1, 1000);
	ListView_GetItemText( TopList, lParam2, SubItemIndex, String2, 1000);
	if (! (String1 && String2) )
		return 1;
	if (m_SortOrder)   // Sort Acending
	{
		Result = _tcscmp(String1,String2);
	}
	else						// Sort Decending
	{
		Result = -_tcscmp(String1,String2);
	}
	if (Result == 0)
		Result = -1;
	return Result; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\database.h ===
//
// File:	Database.h
// By:		Anthony V. DeMarco (ademar)
// Date:  12/28/1999
// Description:  Contains the internal hotfix database data structures.
// Copyright (c) Microsoft Corporation 1999-2000
//

typedef struct _FILELIST
{
	_TCHAR FileName[255];
	_TCHAR CheckSum;
	struct _FILELIST * pPrev;
	struct _FILELIST * pNext;
} * PFILELIST;

typedef struct _HOTFIXLIST
{
	_TCHAR HotfixName[255];
	struct _HOTFIXLIST * pPrev;
	struct _HOTFIXLIST * pNext;
	PFILELIST FileList;
} * PHOTFIXLIST;

typedef struct _ProductNode {
	_TCHAR ProductName[255];
	_ProductNode * pPrev;
	_ProductNode * pNext;
	PHOTFIXLIST      HotfixList;
} * PPRODUCT;

PHOTFIXLIST GetHotfixInfo( _TCHAR * pszProductName, HKEY* hUpdateKey );
PPRODUCT BuildDatabase(_TCHAR * lpszComputerName);
PFILELIST GetFileInfo(HKEY* hHotfixKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( HotfixManager )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( HotfixManager ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-c