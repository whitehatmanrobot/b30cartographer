    {0x02, 0x11, 0x42, 0x06, 0x8e},
    {0x07, 0x42, 0x02, 0x45, 0x9f},
    {0x03, 0x84, 0x47, 0xb5, 0xdd},
    {0x01, 0x81, 0x47, 0x43, 0xce},
    {0x02, 0x84, 0x47, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0x06, 0x8e},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x06, 0x8e},
    {0x01, 0x0a, 0x42, 0x46, 0x8e},
    {0x02, 0x01, 0x42, 0x06, 0x8e},
    {0x06, 0x42, 0x02, 0x06, 0x8e},
    {0x03, 0x08, 0x42, 0x07, 0x7d},
    {0x04, 0x0a, 0x42, 0x46, 0x8e},
    {0x02, 0x08, 0x42, 0x07, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x83, 0x47, 0x03, 0xce},
    {0x05, 0x42, 0x02, 0x06, 0x8e},
    {0x03, 0x81, 0x47, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x81, 0x47, 0x02, 0xbd},
    {0x0c, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x07, 0x7d},
    {0x01, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x0a, 0x42, 0x07, 0x7d},
    {0x06, 0x47, 0x02, 0x06, 0x8e},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0x45, 0x9f},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x06, 0x8e},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0e},
    {0x03, 0xb4, 0xf5, 0x00, 0x0e},
    {0x01, 0xb4, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0xf5, 0x00, 0x0e},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0xf5, 0x40, 0x00, 0x06},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x5d, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0xf5, 0x00, 0x88},
    {0x01, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x0c, 0xf5, 0x00, 0x88},
    {0x06, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0xf2, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0xf5, 0x00, 0x99},
    {0x01, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x14, 0xf5, 0x00, 0x99},
    {0x06, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x82, 0x5d, 0xb5, 0xff},
    {0x04, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x82, 0x5d, 0xb5, 0xff},
    {0x08, 0xf5, 0x40, 0x00, 0x06},
    {0x03, 0x18, 0xf5, 0x00, 0x99},
    {0x01, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x18, 0xf5, 0x00, 0x99},
    {0x05, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x0e, 0xf5, 0x00, 0x88},
    {0x04, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x0e, 0xf5, 0x00, 0x88},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0xf5, 0x00, 0x99},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0xf5, 0x00, 0x99},
    {0x06, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0xf5, 0x00, 0x99},
    {0x01, 0x14, 0xf5, 0x40, 0xaa},
    {0x02, 0x17, 0xf5, 0x00, 0x99},
    {0x06, 0x4c, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0xf5, 0x00, 0xaa},
    {0x03, 0x1b, 0xf5, 0x00, 0x99},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0xf5, 0x00, 0x99},
    {0x05, 0x4c, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x5d, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0xf5, 0x00, 0xaa},
    {0x01, 0x18, 0xf5, 0x40, 0xaa},
    {0x02, 0x27, 0xf5, 0x00, 0xaa},
    {0x06, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x10, 0xf5, 0x00, 0x88},
    {0x04, 0x18, 0xf5, 0x40, 0xaa},
    {0x02, 0x10, 0xf5, 0x00, 0x88},
    {0x07, 0x4b, 0xb5, 0x40, 0xaa},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0xf5, 0x00, 0x99},
    {0x01, 0x1c, 0xf5, 0x40, 0xaa},
    {0x02, 0x13, 0xf5, 0x00, 0x99},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0xf5, 0x40, 0xaa},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0xf5, 0x00, 0xaa},
    {0x03, 0x37, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0xf5, 0x00, 0xaa},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x5d, 0xb5, 0xff},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0x5d, 0xb5, 0xff},
    {0x0c, 0x5d, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x46, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0xf5, 0x00, 0xaa},
    {0x01, 0x17, 0xf5, 0x40, 0xaa},
    {0x02, 0x2d, 0xf5, 0x00, 0xaa},
    {0x06, 0x54, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x46, 0xb5, 0xbf},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x46, 0xf5, 0xbf},
    {0x03, 0x35, 0xf5, 0x00, 0xaa},
    {0x01, 0x1b, 0xf5, 0x40, 0xaa},
    {0x02, 0x35, 0xf5, 0x00, 0xaa},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0xf5, 0x40, 0xaa},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x06, 0xf5, 0xbf},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0xf5, 0x00, 0xaa},
    {0x01, 0x27, 0x46, 0xf5, 0xbf},
    {0x02, 0x23, 0xf5, 0x00, 0xaa},
    {0x06, 0x58, 0x06, 0xb5, 0xbf},
    {0x03, 0x82, 0x43, 0x06, 0xbf},
    {0x04, 0x27, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x43, 0x06, 0xbf},
    {0x08, 0x4b, 0x46, 0xb5, 0xbf},
    {0x03, 0x33, 0xf5, 0x00, 0xaa},
    {0x01, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x33, 0xf5, 0x00, 0xaa},
    {0x05, 0x58, 0x06, 0xb5, 0xbf},
    {0x03, 0x0f, 0xf5, 0x00, 0x88},
    {0x04, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0xf5, 0x00, 0x88},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0xf5, 0x00, 0xaa},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0xf5, 0x00, 0xaa},
    {0x06, 0x4e, 0xb5, 0x00, 0xaa},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0xb5, 0x40, 0xaa},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0xb5, 0x00, 0xaa},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0xf5, 0x00, 0x88},
    {0x01, 0x13, 0xf5, 0x40, 0xaa},
    {0x02, 0x0d, 0xf5, 0x00, 0x88},
    {0x06, 0x5c, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0xf5, 0x00, 0xaa},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x46, 0xf5, 0xbf},
    {0x03, 0x2b, 0xf5, 0x00, 0xaa},
    {0x01, 0x37, 0x46, 0xf5, 0xbf},
    {0x02, 0x2b, 0xf5, 0x00, 0xaa},
    {0x06, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x11, 0xf5, 0x00, 0x88},
    {0x04, 0x37, 0x46, 0xf5, 0xbf},
    {0x02, 0x11, 0xf5, 0x00, 0x88},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0xf5, 0x00, 0x88},
    {0x01, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x01, 0xf5, 0x00, 0x88},
    {0x06, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x81, 0x43, 0x06, 0xbf},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x06, 0xbf},
    {0x0c, 0x43, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0xf5, 0x00, 0xaa},
    {0x01, 0x2d, 0x46, 0xf5, 0xbf},
    {0x02, 0x1d, 0xf5, 0x00, 0xaa},
    {0x06, 0x57, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x4c, 0x41, 0xb5, 0xcf},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x4b, 0x41, 0xf5, 0xcf},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x54, 0x01, 0xf5, 0xcf},
    {0x03, 0x9a, 0x43, 0x01, 0xcf},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x43, 0x01, 0xcf},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x03, 0x01, 0xb5, 0xcf},
    {0x03, 0x21, 0xf5, 0x00, 0xaa},
    {0x01, 0x35, 0x46, 0xf5, 0xbf},
    {0x02, 0x21, 0xf5, 0x00, 0xaa},
    {0x06, 0x5b, 0x06, 0xb5, 0xbf},
    {0x03, 0x82, 0x4b, 0x01, 0xcf},
    {0x04, 0x35, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x4b, 0x01, 0xcf},
    {0x08, 0x4c, 0x41, 0xb5, 0xcf},
    {0x03, 0x31, 0xf5, 0x00, 0xaa},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0xf5, 0x00, 0xaa},
    {0x05, 0x5b, 0x06, 0xb5, 0xbf},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc2, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x3d, 0xf5, 0x00, 0xaa},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0xf5, 0x00, 0xaa},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0xf5, 0x00, 0xaa},
    {0x01, 0x23, 0x46, 0xf5, 0xbf},
    {0x02, 0x2f, 0xf5, 0x00, 0xaa},
    {0x06, 0x67, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0x46, 0xb5, 0xbf},
    {0x03, 0x3b, 0xf5, 0x00, 0xaa},
    {0x01, 0x82, 0x43, 0x41, 0xcf},
    {0x02, 0x3b, 0xf5, 0x00, 0xaa},
    {0x05, 0x67, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0x41, 0xf5, 0xcf},
    {0x03, 0x29, 0xf5, 0x00, 0xaa},
    {0x01, 0x33, 0x46, 0xf5, 0xbf},
    {0x02, 0x29, 0xf5, 0x00, 0xaa},
    {0x06, 0x50, 0xb5, 0x00, 0xaa},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x46, 0xf5, 0xbf},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x58, 0x01, 0xf5, 0xcf},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0xb5, 0x00, 0xaa},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0xf5, 0x00, 0xaa},
    {0x01, 0x3f, 0x46, 0xf5, 0xbf},
    {0x02, 0x1f, 0xf5, 0x00, 0xaa},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x46, 0xf5, 0xbf},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x46, 0xb5, 0xbf},
    {0x03, 0x39, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0xf5, 0x00, 0xaa},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0x01, 0xcf},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x4b, 0x01, 0xcf},
    {0x0c, 0x4b, 0x41, 0xf5, 0xcf},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0x06, 0xf5, 0xbf},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0xdd, 0x46, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0xf5, 0x00, 0x99},
    {0x01, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x16, 0xf5, 0x00, 0x99},
    {0x06, 0x53, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x46, 0xf5, 0xbf},
    {0x03, 0x1a, 0xf5, 0x00, 0x99},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0xf5, 0x00, 0x99},
    {0x06, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x5c, 0x01, 0xf5, 0xcf},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0xf5, 0x00, 0xaa},
    {0x01, 0x2b, 0x46, 0xf5, 0xbf},
    {0x02, 0x25, 0xf5, 0x00, 0xaa},
    {0x06, 0x77, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x45, 0x06, 0xbf},
    {0x04, 0x2b, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x45, 0x06, 0xbf},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0xf5, 0x00, 0x99},
    {0x01, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x19, 0xf5, 0x00, 0x99},
    {0x05, 0x77, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0xf5, 0x00, 0xaa},
    {0x03, 0x12, 0xf5, 0x00, 0x99},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0xf5, 0x00, 0x99},
    {0x05, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0x46, 0xf5, 0xbf},
    {0x03, 0x15, 0xf5, 0x00, 0x99},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0xf5, 0x00, 0x99},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0xb5, 0x40, 0x99},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x43, 0x41, 0xcf},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0x43, 0x01, 0xcf},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x43, 0x01, 0xcf},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x06, 0xbf},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x06, 0xbf},
    {0x0c, 0x45, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x9c, 0xf5, 0x00, 0x0d},
    {0x01, 0x1d, 0x46, 0xf5, 0xbf},
    {0x02, 0x9c, 0xf5, 0x00, 0x0d},
    {0x06, 0x6d, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x54, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6d, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x4c, 0x43, 0xf5, 0xdf},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x57, 0x01, 0xf5, 0xcf},
    {0x03, 0x9a, 0x4b, 0x03, 0xdf},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0x4b, 0x03, 0xdf},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0x0b, 0x03, 0xb5, 0xdf},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x4c, 0x03, 0xdf},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x4c, 0x03, 0xdf},
    {0x08, 0x54, 0x43, 0xb5, 0xdf},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x03, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x43, 0x43, 0xdf},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0x43, 0x43, 0xdf},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x46, 0xf5, 0xbf},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x75, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x0b, 0x6d},
    {0x04, 0x21, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x0b, 0x6d},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0x4b, 0x43, 0xdf},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x75, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x0b, 0x6d},
    {0x04, 0x82, 0x4b, 0x43, 0xdf},
    {0x02, 0x05, 0x43, 0x0b, 0x6d},
    {0x0b, 0x4c, 0x43, 0xf5, 0xdf},
    {0x03, 0x28, 0xf5, 0x00, 0xaa},
    {0x01, 0x31, 0x46, 0xf5, 0xbf},
    {0x02, 0x28, 0xf5, 0x00, 0xaa},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x46, 0xf5, 0xbf},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x5b, 0x01, 0xf5, 0xcf},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x0b, 0x6d},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x0b, 0x6d},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x46, 0xf5, 0xbf},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x46, 0xf5, 0xbf},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0xf5, 0x00, 0xaa},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4c, 0x03, 0xdf},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x4c, 0x03, 0xdf},
    {0x0c, 0x4c, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x0b, 0x6d},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x0b, 0x6d},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x0b, 0x6d},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x0b, 0x6d},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x0b, 0x6d},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x0b, 0x6d},
    {0xe1, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0xf5, 0x00, 0xaa},
    {0x01, 0x2f, 0x46, 0xf5, 0xbf},
    {0x02, 0x2e, 0xf5, 0x00, 0xaa},
    {0x06, 0x63, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x03, 0x6d},
    {0x04, 0x2f, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x41, 0x03, 0x6d},
    {0x09, 0x58, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x03, 0x7d},
    {0x01, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x0b, 0x43, 0x03, 0x7d},
    {0x05, 0x63, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x03, 0x6d},
    {0x04, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x05, 0x41, 0x03, 0x6d},
    {0x0a, 0x49, 0x41, 0xf5, 0xcf},
    {0x03, 0x36, 0xf5, 0x00, 0xaa},
    {0x01, 0x3b, 0x46, 0xf5, 0xbf},
    {0x02, 0x36, 0xf5, 0x00, 0xaa},
    {0x06, 0xc2, 0x03, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x03, 0x7d},
    {0x04, 0x3b, 0x46, 0xf5, 0xbf},
    {0x02, 0x09, 0x43, 0x03, 0x7d},
    {0x07, 0x67, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x03, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x03, 0x6d},
    {0x04, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x06, 0x41, 0x03, 0x6d},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0xf5, 0x00, 0xaa},
    {0x01, 0x29, 0x46, 0xf5, 0xbf},
    {0x02, 0x24, 0xf5, 0x00, 0xaa},
    {0x06, 0x73, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x49, 0x01, 0xcf},
    {0x04, 0x29, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x49, 0x01, 0xcf},
    {0x08, 0x58, 0x43, 0xb5, 0xdf},
    {0x03, 0x34, 0xf5, 0x00, 0xaa},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0xf5, 0x00, 0xaa},
    {0x05, 0x73, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0xf5, 0x00, 0xaa},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0xf5, 0x00, 0xaa},
    {0x06, 0x4f, 0xb5, 0x00, 0xaa},
    {0x03, 0x04, 0x41, 0x03, 0x6d},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x03, 0x6d},
    {0x07, 0x50, 0x06, 0xf5, 0xbf},
    {0x03, 0x02, 0x41, 0x03, 0x6d},
    {0x01, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x41, 0x03, 0x6d},
    {0x05, 0x4f, 0xb5, 0x00, 0xaa},
    {0x03, 0x07, 0x41, 0x03, 0x6d},
    {0x04, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x41, 0x03, 0x6d},
    {0xc6, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x46, 0xf5, 0xbf},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x7f, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0x0b, 0x6d},
    {0x04, 0x1f, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x42, 0x0b, 0x6d},
    {0x09, 0x4e, 0x41, 0xb5, 0xcf},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x7f, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0x0b, 0x6d},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x0b, 0x6d},
    {0x0b, 0x49, 0x41, 0xf5, 0xcf},
    {0x03, 0x2c, 0xf5, 0x00, 0xaa},
    {0x01, 0x39, 0x46, 0xf5, 0xbf},
    {0x02, 0x2c, 0xf5, 0x00, 0xaa},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x46, 0xf5, 0xbf},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xc9, 0xb5, 0x40, 0x0d},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4b, 0x43, 0xdf},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x0b, 0x6d},
    {0x04, 0x81, 0x4b, 0x43, 0xdf},
    {0x02, 0x06, 0x42, 0x0b, 0x6d},
    {0x4e, 0x0b, 0x03, 0xb5, 0xdf},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x03, 0x7d},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x03, 0x7d},
    {0x08, 0x4e, 0x41, 0xb5, 0xcf},
    {0x03, 0x83, 0x4b, 0x03, 0xdf},
    {0x01, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x83, 0x4b, 0x03, 0xdf},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x49, 0x01, 0xcf},
    {0x04, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x81, 0x49, 0x01, 0xcf},
    {0x0c, 0x49, 0x41, 0xf5, 0xcf},
    {0x03, 0x0a, 0x43, 0x03, 0x7d},
    {0x01, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x0a, 0x43, 0x03, 0x7d},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x0b, 0x6d},
    {0x04, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x0b, 0x6d},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x0b, 0x6d},
    {0x01, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x0b, 0x6d},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x0b, 0x6d},
    {0x04, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x0b, 0x6d},
    {0xf4, 0x43, 0x03, 0xf5, 0xff},
    {0x03, 0x1e, 0xf5, 0x00, 0xaa},
    {0x01, 0x16, 0xf5, 0x40, 0xaa},
    {0x02, 0x1e, 0xf5, 0x00, 0xaa},
    {0x06, 0x4d, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x5c, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x53, 0x01, 0xf5, 0xcf},
    {0x03, 0x9a, 0x45, 0x01, 0xcf},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x45, 0x01, 0xcf},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x05, 0x01, 0xb5, 0xcf},
    {0x03, 0x22, 0xf5, 0x00, 0xaa},
    {0x01, 0x1a, 0xf5, 0x40, 0xaa},
    {0x02, 0x22, 0xf5, 0x00, 0xaa},
    {0x06, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xda, 0xb5, 0x0d},
    {0x04, 0x1a, 0xf5, 0x40, 0xaa},
    {0x02, 0x82, 0xda, 0xb5, 0x0d},
    {0x08, 0x5c, 0x43, 0xb5, 0xdf},
    {0x03, 0x32, 0xf5, 0x00, 0xaa},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0xf5, 0x00, 0xaa},
    {0x05, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0xf5, 0x00, 0xaa},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0xf5, 0x00, 0xaa},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0xb5, 0x40, 0xaa},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0xf5, 0x00, 0xaa},
    {0x01, 0x25, 0x46, 0xf5, 0xbf},
    {0x02, 0x30, 0xf5, 0x00, 0xaa},
    {0x06, 0x6b, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0xf5, 0x00, 0xaa},
    {0x03, 0x3c, 0xf5, 0x00, 0xaa},
    {0x01, 0x82, 0x45, 0x41, 0xcf},
    {0x02, 0x3c, 0xf5, 0x00, 0xaa},
    {0x05, 0x6b, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x2a, 0xf5, 0x00, 0xaa},
    {0x01, 0x19, 0xf5, 0x40, 0xaa},
    {0x02, 0x2a, 0xf5, 0x00, 0xaa},
    {0x06, 0x51, 0xb5, 0x00, 0xaa},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0xf5, 0x40, 0xaa},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x77, 0x03, 0xf5, 0xdf},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0xb5, 0x00, 0xaa},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0xf5, 0x00, 0xaa},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0xf5, 0x00, 0xaa},
    {0x06, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0xf5, 0x00, 0xaa},
    {0x03, 0x3a, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0xf5, 0x00, 0xaa},
    {0x05, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xda, 0xb5, 0x0d},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xda, 0xb5, 0x0d},
    {0x0c, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xe5, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x44, 0x03, 0x6d},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x03, 0x6d},
    {0x09, 0x42, 0xf5, 0x00, 0xaa},
    {0x03, 0x0b, 0x42, 0x03, 0x7d},
    {0x01, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x0b, 0x42, 0x03, 0x7d},
    {0x05, 0x41, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x44, 0x03, 0x6d},
    {0x04, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x05, 0x44, 0x03, 0x6d},
    {0x0a, 0x46, 0x46, 0xf5, 0xbf},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0xf5, 0x40, 0xaa},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x03, 0x7d},
    {0x04, 0x12, 0xf5, 0x40, 0xaa},
    {0x02, 0x09, 0x42, 0x03, 0x7d},
    {0x07, 0x4a, 0xb5, 0x40, 0xaa},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x03, 0x6d},
    {0x04, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x06, 0x44, 0x03, 0x6d},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0xf5, 0x00, 0xaa},
    {0x01, 0x15, 0xf5, 0x40, 0xaa},
    {0x02, 0x26, 0xf5, 0x00, 0xaa},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x06, 0xbf},
    {0x04, 0x15, 0xf5, 0x40, 0xaa},
    {0x02, 0x82, 0x46, 0x06, 0xbf},
    {0x08, 0x42, 0xf5, 0x00, 0xaa},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x03, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x03, 0x6d},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x03, 0x6d},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x03, 0x6d},
    {0x01, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x44, 0x03, 0x6d},
    {0x05, 0xc1, 0x03, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x03, 0x6d},
    {0x04, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x44, 0x03, 0x6d},
    {0x81, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0xf5, 0x00, 0xaa},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0x46, 0xf5, 0xbf},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x43, 0x43, 0xdf},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x43, 0x43, 0xdf},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x43, 0x03, 0xdf},
    {0x01, 0x81, 0x45, 0x41, 0xcf},
    {0x02, 0x84, 0x43, 0x03, 0xdf},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x03, 0x7d},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x03, 0x7d},
    {0x08, 0x47, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0x45, 0x01, 0xcf},
    {0x01, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x83, 0x45, 0x01, 0xcf},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x06, 0xbf},
    {0x04, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x81, 0x46, 0x06, 0xbf},
    {0x0c, 0x46, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0x03, 0x7d},
    {0x01, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x0a, 0x42, 0x03, 0x7d},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0x9f, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5d, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x4a, 0xb5, 0x6d},
    {0x04, 0x9f, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4a, 0xb5, 0x6d},
    {0x09, 0x57, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x49, 0xb5, 0x7d},
    {0x01, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x0b, 0x49, 0xb5, 0x7d},
    {0x05, 0x5d, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x4a, 0xb5, 0x6d},
    {0x04, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x05, 0x4a, 0xb5, 0x6d},
    {0x0a, 0x61, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x49, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x49, 0xb5, 0x7d},
    {0x07, 0x6d, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4a, 0xb5, 0x6d},
    {0x04, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x06, 0x4a, 0xb5, 0x6d},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x61, 0xb5, 0xff},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x61, 0xb5, 0xff},
    {0x08, 0x57, 0x43, 0xb5, 0xdf},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4a, 0xb5, 0x6d},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0x4a, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4a, 0xb5, 0x6d},
    {0x01, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x4a, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4a, 0xb5, 0x6d},
    {0x04, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x4a, 0xb5, 0x6d},
    {0x52, 0x82, 0xf5, 0x00, 0x0f},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x61, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0xc2, 0xb5, 0x0f},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0xc2, 0xb5, 0x0f},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0x82, 0xf5, 0x00, 0x0f},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0x82, 0xb5, 0x0f},
    {0x03, 0x08, 0x49, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x49, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0x82, 0xb5, 0x0f},
    {0x03, 0x81, 0x61, 0xb5, 0xff},
    {0x04, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x81, 0x61, 0xb5, 0xff},
    {0x0c, 0x61, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x49, 0xb5, 0x7d},
    {0x01, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x0a, 0x49, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdf, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x5b, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x61, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x75, 0x03, 0xf5, 0xdf},
    {0x03, 0x87, 0xc2, 0xb5, 0x0f},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xc2, 0xb5, 0x0f},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0x46, 0xf5, 0xbf},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x5b, 0x43, 0xb5, 0xdf},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0xda, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7d, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0x46, 0xf5, 0xbf},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0x46, 0xf5, 0xbf},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc7, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0x46, 0xf5, 0xbf},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x46, 0x82, 0x6f},
    {0x04, 0x2e, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x46, 0x82, 0x6f},
    {0x09, 0x68, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x82, 0x7f},
    {0x01, 0x03, 0x41, 0xc2, 0x7f},
    {0x02, 0x0b, 0x41, 0x82, 0x7f},
    {0x05, 0x6f, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x46, 0x82, 0x6f},
    {0x04, 0x03, 0x41, 0xc2, 0x7f},
    {0x02, 0x05, 0x46, 0x82, 0x6f},
    {0x0a, 0x71, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0x82, 0x8f},
    {0x01, 0x0b, 0x43, 0xc2, 0x8f},
    {0x02, 0x0c, 0x43, 0x82, 0x8f},
    {0x06, 0x43, 0x03, 0x82, 0x8f},
    {0x03, 0x09, 0x41, 0x82, 0x7f},
    {0x04, 0x0b, 0x43, 0xc2, 0x8f},
    {0x02, 0x09, 0x41, 0x82, 0x7f},
    {0x07, 0x63, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x49, 0x03, 0xdf},
    {0x01, 0x05, 0x41, 0xc2, 0x7f},
    {0x02, 0x9a, 0x49, 0x03, 0xdf},
    {0x05, 0x43, 0x03, 0x82, 0x8f},
    {0x03, 0x06, 0x46, 0x82, 0x6f},
    {0x04, 0x05, 0x41, 0xc2, 0x7f},
    {0x02, 0x06, 0x46, 0x82, 0x6f},
    {0x4d, 0x09, 0x03, 0xb5, 0xdf},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0x46, 0xf5, 0xbf},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x71, 0xb5, 0xff},
    {0x04, 0x36, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x71, 0xb5, 0xff},
    {0x08, 0x68, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0xc2, 0x8f},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0x01, 0xb5, 0xcf},
    {0x03, 0x0e, 0x43, 0x82, 0x8f},
    {0x04, 0x09, 0x43, 0xc2, 0x8f},
    {0x02, 0x0e, 0x43, 0x82, 0x8f},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x82, 0x8f},
    {0x03, 0x04, 0x46, 0x82, 0x6f},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x82, 0x6f},
    {0x07, 0xc2, 0x82, 0xf5, 0x0f},
    {0x03, 0x02, 0x46, 0x82, 0x6f},
    {0x01, 0x06, 0x41, 0xc2, 0x7f},
    {0x02, 0x02, 0x46, 0x82, 0x6f},
    {0x05, 0x45, 0x03, 0x82, 0x8f},
    {0x03, 0x07, 0x46, 0x82, 0x6f},
    {0x04, 0x06, 0x41, 0xc2, 0x7f},
    {0x02, 0x07, 0x46, 0x82, 0x6f},
    {0xd6, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0x46, 0xf5, 0xbf},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x09, 0x6d},
    {0x04, 0x24, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x09, 0x6d},
    {0x09, 0x50, 0x41, 0xb5, 0xcf},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x49, 0x43, 0xdf},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x09, 0x6d},
    {0x04, 0x82, 0x49, 0x43, 0xdf},
    {0x02, 0x05, 0x43, 0x09, 0x6d},
    {0x0b, 0x71, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0x46, 0xf5, 0xbf},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x82, 0x8f},
    {0x04, 0x34, 0x46, 0xf5, 0xbf},
    {0x02, 0x10, 0x43, 0x82, 0x8f},
    {0x07, 0x73, 0x03, 0xf5, 0xdf},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x09, 0x6d},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x09, 0x6d},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0x46, 0xf5, 0xbf},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x82, 0x7f},
    {0x04, 0x00, 0x46, 0xf5, 0xbf},
    {0x02, 0x08, 0x41, 0x82, 0x7f},
    {0x08, 0x50, 0x41, 0xb5, 0xcf},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0xc2, 0x7f},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x71, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xc2, 0x7f},
    {0x02, 0x81, 0x71, 0xb5, 0xff},
    {0x0c, 0x71, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0x82, 0x7f},
    {0x01, 0x02, 0x41, 0xc2, 0x7f},
    {0x02, 0x0a, 0x41, 0x82, 0x7f},
    {0x06, 0x46, 0x03, 0x82, 0x8f},
    {0x03, 0x04, 0x43, 0x09, 0x6d},
    {0x04, 0x02, 0x41, 0xc2, 0x7f},
    {0x02, 0x04, 0x43, 0x09, 0x6d},
    {0x07, 0x4f, 0x06, 0xf5, 0xbf},
    {0x03, 0x02, 0x43, 0x09, 0x6d},
    {0x01, 0x07, 0x41, 0xc2, 0x7f},
    {0x02, 0x02, 0x43, 0x09, 0x6d},
    {0x05, 0x46, 0x03, 0x82, 0x8f},
    {0x03, 0x07, 0x43, 0x09, 0x6d},
    {0x04, 0x07, 0x41, 0xc2, 0x7f},
    {0x02, 0x07, 0x43, 0x09, 0x6d},
    {0xde, 0x46, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xcd, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x5f, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x4e, 0x43, 0xf5, 0xdf},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7f, 0x03, 0xf5, 0xdf},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0x46, 0xf5, 0xbf},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x4e, 0x03, 0xdf},
    {0x04, 0x2c, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x4e, 0x03, 0xdf},
    {0x08, 0xcd, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0x82, 0x8f},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x82, 0x8f},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0xc2, 0xb5, 0x0f},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xc2, 0xb5, 0x0f},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xd0, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x82, 0x8f},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x82, 0x8f},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x09, 0x6d},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x09, 0x6d},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0xc2, 0x8f},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x09, 0x6d},
    {0x04, 0x08, 0x43, 0xc2, 0x8f},
    {0x02, 0x05, 0x42, 0x09, 0x6d},
    {0x0b, 0x4e, 0x43, 0xf5, 0xdf},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x82, 0x8f},
    {0x03, 0x11, 0x43, 0x82, 0x8f},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0x82, 0x8f},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x49, 0x43, 0xdf},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0x82, 0x8f},
    {0x03, 0x06, 0x42, 0x09, 0x6d},
    {0x04, 0x81, 0x49, 0x43, 0xdf},
    {0x02, 0x06, 0x42, 0x09, 0x6d},
    {0x4e, 0x09, 0x03, 0xb5, 0xdf},
    {0x03, 0x01, 0x43, 0x82, 0x8f},
    {0x01, 0x0a, 0x43, 0xc2, 0x8f},
    {0x02, 0x01, 0x43, 0x82, 0x8f},
    {0x06, 0x42, 0x03, 0x82, 0x8f},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xc2, 0x8f},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x49, 0x03, 0xdf},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x49, 0x03, 0xdf},
    {0x05, 0x42, 0x03, 0x82, 0x8f},
    {0x03, 0x81, 0x4e, 0x03, 0xdf},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x4e, 0x03, 0xdf},
    {0x0c, 0x4e, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0x82, 0x8f},
    {0x03, 0x04, 0x42, 0x09, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x09, 0x6d},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x09, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x09, 0x6d},
    {0x05, 0x47, 0x03, 0x82, 0x8f},
    {0x03, 0x07, 0x42, 0x09, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x09, 0x6d},
    {0xb4, 0x82, 0xb5, 0x00, 0x0f},
    {0x03, 0x9d, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0x46, 0xf5, 0xbf},
    {0x02, 0x9d, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x53, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x7d, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x06, 0xf5, 0xbf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x7d, 0xb5, 0xff},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x7d, 0xb5, 0xff},
    {0x08, 0x53, 0x43, 0xb5, 0xdf},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x05, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x45, 0x43, 0xdf},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x45, 0x43, 0xdf},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0xcc, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x46, 0xf5, 0xbf},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x22, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x48, 0x46, 0xb5, 0xbf},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x7d, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0x46, 0xf5, 0xbf},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x46, 0xf5, 0xbf},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0xd8, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x46, 0xf5, 0xbf},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x46, 0xf5, 0xbf},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x46, 0xb5, 0xbf},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x7d, 0xb5, 0xff},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x7d, 0xb5, 0xff},
    {0x0c, 0x7d, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe3, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0x46, 0xf5, 0xbf},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x05, 0x6d},
    {0x04, 0x30, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x41, 0x05, 0x6d},
    {0x09, 0x78, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x05, 0x7d},
    {0x01, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x0b, 0x43, 0x05, 0x7d},
    {0x05, 0x65, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x05, 0x6d},
    {0x04, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x05, 0x41, 0x05, 0x6d},
    {0x0a, 0x44, 0x46, 0xf5, 0xbf},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0x46, 0xf5, 0xbf},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x05, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x05, 0x7d},
    {0x04, 0x3c, 0x46, 0xf5, 0xbf},
    {0x02, 0x09, 0x43, 0x05, 0x7d},
    {0x07, 0x6b, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0xc2, 0xb5, 0x0f},
    {0x01, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x88, 0xc2, 0xb5, 0x0f},
    {0x05, 0xc2, 0x05, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x05, 0x6d},
    {0x04, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x06, 0x41, 0x05, 0x6d},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0x46, 0xf5, 0xbf},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0x06, 0xb5, 0xbf},
    {0x03, 0x82, 0x44, 0x06, 0xbf},
    {0x04, 0x2a, 0x46, 0xf5, 0xbf},
    {0x02, 0x82, 0x44, 0x06, 0xbf},
    {0x08, 0x78, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0x06, 0xb5, 0xbf},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x05, 0x6d},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x05, 0x6d},
    {0x07, 0x51, 0x06, 0xf5, 0xbf},
    {0x03, 0x02, 0x41, 0x05, 0x6d},
    {0x01, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x41, 0x05, 0x6d},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x05, 0x6d},
    {0x04, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x41, 0x05, 0x6d},
    {0xc8, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x46, 0xf5, 0xbf},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x20, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x44, 0x46, 0xf5, 0xbf},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0x46, 0xf5, 0xbf},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x46, 0xf5, 0xbf},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xd4, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x05, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x05, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x06, 0xbf},
    {0x04, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x81, 0x44, 0x06, 0xbf},
    {0x0c, 0x44, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x43, 0x05, 0x7d},
    {0x01, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x0a, 0x43, 0x05, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x45, 0x03, 0xf5, 0xff},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x82, 0x6f},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x82, 0x6f},
    {0x09, 0x4a, 0x46, 0xb5, 0xbf},
    {0x03, 0x0b, 0x44, 0x82, 0x7f},
    {0x01, 0x03, 0x44, 0xc2, 0x7f},
    {0x02, 0x0b, 0x44, 0x82, 0x7f},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x82, 0x6f},
    {0x04, 0x03, 0x44, 0xc2, 0x7f},
    {0x02, 0x05, 0x45, 0x82, 0x6f},
    {0x0a, 0x42, 0x46, 0xf5, 0xbf},
    {0x03, 0x0c, 0x42, 0x82, 0x8f},
    {0x01, 0x0b, 0x42, 0xc2, 0x8f},
    {0x02, 0x0c, 0x42, 0x82, 0x8f},
    {0x06, 0x43, 0x02, 0x82, 0x8f},
    {0x03, 0x09, 0x44, 0x82, 0x7f},
    {0x04, 0x0b, 0x42, 0xc2, 0x8f},
    {0x02, 0x09, 0x44, 0x82, 0x7f},
    {0x07, 0x41, 0x06, 0xf5, 0xbf},
    {0x03, 0x9a, 0x46, 0x01, 0xcf},
    {0x01, 0x05, 0x44, 0xc2, 0x7f},
    {0x02, 0x9a, 0x46, 0x01, 0xcf},
    {0x05, 0x43, 0x02, 0x82, 0x8f},
    {0x03, 0x06, 0x45, 0x82, 0x6f},
    {0x04, 0x05, 0x44, 0xc2, 0x7f},
    {0x02, 0x06, 0x45, 0x82, 0x6f},
    {0x4d, 0x06, 0x01, 0xb5, 0xcf},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0x06, 0xb5, 0xbf},
    {0x03, 0x82, 0x42, 0x06, 0xbf},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x06, 0xbf},
    {0x08, 0x4a, 0x46, 0xb5, 0xbf},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0xc2, 0x8f},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0x06, 0xb5, 0xbf},
    {0x03, 0x0e, 0x42, 0x82, 0x8f},
    {0x04, 0x09, 0x42, 0xc2, 0x8f},
    {0x02, 0x0e, 0x42, 0x82, 0x8f},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x82, 0x8f},
    {0x03, 0x04, 0x45, 0x82, 0x6f},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x82, 0x6f},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x82, 0x6f},
    {0x01, 0x06, 0x44, 0xc2, 0x7f},
    {0x02, 0x02, 0x45, 0x82, 0x6f},
    {0x05, 0x45, 0x02, 0x82, 0x8f},
    {0x03, 0x07, 0x45, 0x82, 0x6f},
    {0x04, 0x06, 0x44, 0xc2, 0x7f},
    {0x02, 0x07, 0x45, 0x82, 0x6f},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0x46, 0xf5, 0xbf},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0x06, 0xb5, 0xbf},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0x46, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0x41, 0xcf},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0x06, 0xb5, 0xbf},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0x46, 0xf5, 0xbf},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x82, 0x8f},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x82, 0x8f},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x82, 0x7f},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x82, 0x7f},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0xc2, 0x7f},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x06, 0xbf},
    {0x04, 0x04, 0x44, 0xc2, 0x7f},
    {0x02, 0x81, 0x42, 0x06, 0xbf},
    {0x0c, 0x42, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x44, 0x82, 0x7f},
    {0x01, 0x02, 0x44, 0xc2, 0x7f},
    {0x02, 0x0a, 0x44, 0x82, 0x7f},
    {0x06, 0x46, 0x02, 0x82, 0x8f},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0xc2, 0x7f},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0x82, 0xf5, 0x0f},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0xc2, 0x7f},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0x82, 0x8f},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0xc2, 0x7f},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xe7, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x05, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x05, 0x6d},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x05, 0x7d},
    {0x01, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x0b, 0x42, 0x05, 0x7d},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x05, 0x6d},
    {0x04, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x05, 0x44, 0x05, 0x6d},
    {0x0a, 0x47, 0x46, 0xf5, 0xbf},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x05, 0x7d},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x05, 0x7d},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0xc2, 0xb5, 0x0f},
    {0x01, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x8a, 0xc2, 0xb5, 0x0f},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x05, 0x6d},
    {0x04, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x06, 0x44, 0x05, 0x6d},
    {0x50, 0x82, 0xf5, 0x00, 0x0f},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0x82, 0xb5, 0x0f},
    {0x03, 0x82, 0x47, 0x06, 0xbf},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x06, 0xbf},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x82, 0xb5, 0x0f},
    {0x03, 0x0f, 0x42, 0x82, 0x8f},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x82, 0x8f},
    {0x40, 0x82, 0xf5, 0x00, 0x0f},
    {0x03, 0x86, 0xc2, 0xb5, 0x0f},
    {0x01, 0x84, 0xc2, 0xf5, 0x0f},
    {0x02, 0x86, 0xc2, 0xb5, 0x0f},
    {0x06, 0xc1, 0x05, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x05, 0x6d},
    {0x04, 0x84, 0xc2, 0xf5, 0x0f},
    {0x02, 0x04, 0x44, 0x05, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x05, 0x6d},
    {0x01, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x44, 0x05, 0x6d},
    {0x05, 0xc1, 0x05, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x05, 0x6d},
    {0x04, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x44, 0x05, 0x6d},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x82, 0x8f},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x82, 0x8f},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xc2, 0x8f},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0xc2, 0x8f},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0x46, 0xf5, 0xbf},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x45, 0x43, 0xdf},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x82, 0x8f},
    {0x03, 0x11, 0x42, 0x82, 0x8f},
    {0x04, 0x83, 0x45, 0x43, 0xdf},
    {0x02, 0x11, 0x42, 0x82, 0x8f},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x45, 0x03, 0xdf},
    {0x01, 0x81, 0x46, 0x41, 0xcf},
    {0x02, 0x84, 0x45, 0x03, 0xdf},
    {0x05, 0x44, 0x02, 0x82, 0x8f},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0x82, 0x8f},
    {0x01, 0x0a, 0x42, 0xc2, 0x8f},
    {0x02, 0x01, 0x42, 0x82, 0x8f},
    {0x06, 0x42, 0x02, 0x82, 0x8f},
    {0x03, 0x08, 0x42, 0x05, 0x7d},
    {0x04, 0x0a, 0x42, 0xc2, 0x8f},
    {0x02, 0x08, 0x42, 0x05, 0x7d},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0x01, 0xcf},
    {0x01, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x83, 0x46, 0x01, 0xcf},
    {0x05, 0x42, 0x02, 0x82, 0x8f},
    {0x03, 0x81, 0x47, 0x06, 0xbf},
    {0x04, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x81, 0x47, 0x06, 0xbf},
    {0x0c, 0x47, 0x46, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0x05, 0x7d},
    {0x01, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x0a, 0x42, 0x05, 0x7d},
    {0x06, 0x47, 0x02, 0x82, 0x8f},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0x82, 0x8f},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x6e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x4b, 0xb5, 0x7e},
    {0x01, 0x03, 0x4b, 0xf5, 0x7e},
    {0x02, 0x0b, 0x4b, 0xb5, 0x7e},
    {0x05, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x4b, 0xf5, 0x7e},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x6f, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x48, 0xb5, 0x8e},
    {0x01, 0x0b, 0x48, 0xf5, 0x8e},
    {0x02, 0x0c, 0x48, 0xb5, 0x8e},
    {0x06, 0x43, 0x08, 0xb5, 0x8e},
    {0x03, 0x09, 0x4b, 0xb5, 0x7e},
    {0x04, 0x0b, 0x48, 0xf5, 0x8e},
    {0x02, 0x09, 0x4b, 0xb5, 0x7e},
    {0x07, 0x5d, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x4b, 0xf5, 0x7e},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x08, 0xb5, 0x8e},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x4b, 0xf5, 0x7e},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x46, 0xb5, 0x9d},
    {0x01, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x14, 0x46, 0xb5, 0x9d},
    {0x06, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x82, 0x6f, 0xb5, 0xff},
    {0x04, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x82, 0x6f, 0xb5, 0xff},
    {0x08, 0x6e, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x46, 0xb5, 0x9d},
    {0x01, 0x09, 0x48, 0xf5, 0x8e},
    {0x02, 0x18, 0x46, 0xb5, 0x9d},
    {0x05, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x0e, 0x48, 0xb5, 0x8e},
    {0x04, 0x09, 0x48, 0xf5, 0x8e},
    {0x02, 0x0e, 0x48, 0xb5, 0x8e},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x46, 0xb5, 0x9d},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x46, 0xb5, 0x9d},
    {0x06, 0x45, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x4b, 0xf5, 0x7e},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x4b, 0xf5, 0x7e},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x46, 0xb5, 0x9d},
    {0x01, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x17, 0x46, 0xb5, 0x9d},
    {0x06, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x1b, 0x46, 0xb5, 0x9d},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x46, 0xb5, 0x9d},
    {0x05, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x6f, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x41, 0xb5, 0xad},
    {0x01, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x27, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x10, 0x48, 0xb5, 0x8e},
    {0x04, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x48, 0xb5, 0x8e},
    {0x07, 0x4b, 0x01, 0xf5, 0xad},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x46, 0xb5, 0x9d},
    {0x01, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x13, 0x46, 0xb5, 0x9d},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0x4b, 0xb5, 0x7e},
    {0x04, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x08, 0x4b, 0xb5, 0x7e},
    {0x08, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x37, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x4b, 0xf5, 0x7e},
    {0x02, 0x37, 0x41, 0xb5, 0xad},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x6f, 0xb5, 0xff},
    {0x04, 0x04, 0x4b, 0xf5, 0x7e},
    {0x02, 0x81, 0x6f, 0xb5, 0xff},
    {0x0c, 0x6f, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x4b, 0xb5, 0x7e},
    {0x01, 0x02, 0x4b, 0xf5, 0x7e},
    {0x02, 0x0a, 0x4b, 0xb5, 0x7e},
    {0x06, 0x46, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x4b, 0xf5, 0x7e},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x4b, 0xf5, 0x7e},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x4b, 0xf5, 0x7e},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x41, 0xb5, 0xad},
    {0x01, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x2d, 0x41, 0xb5, 0xad},
    {0x06, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x35, 0x41, 0xb5, 0xad},
    {0x01, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x35, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x03, 0xf5, 0xbd},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x41, 0xb5, 0xad},
    {0x01, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x41, 0xb5, 0xad},
    {0x06, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x03, 0xbd},
    {0x04, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x03, 0xbd},
    {0x08, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x33, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x33, 0x41, 0xb5, 0xad},
    {0x05, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x48, 0xb5, 0x8e},
    {0x04, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x48, 0xb5, 0x8e},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x41, 0xb5, 0xad},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x41, 0xb5, 0xad},
    {0x06, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0x48, 0xb5, 0x8e},
    {0x01, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x0d, 0x48, 0xb5, 0x8e},
    {0x06, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x48, 0xf5, 0x8e},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x48, 0xf5, 0x8e},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x2b, 0x41, 0xb5, 0xad},
    {0x01, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x08, 0xb5, 0x8e},
    {0x03, 0x11, 0x48, 0xb5, 0x8e},
    {0x04, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x48, 0xb5, 0x8e},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x08, 0xb5, 0x8e},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x48, 0xb5, 0x8e},
    {0x01, 0x0a, 0x48, 0xf5, 0x8e},
    {0x02, 0x01, 0x48, 0xb5, 0x8e},
    {0x06, 0x42, 0x08, 0xb5, 0x8e},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x48, 0xf5, 0x8e},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x08, 0xb5, 0x8e},
    {0x03, 0x81, 0x43, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x03, 0xbd},
    {0x0c, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x41, 0xb5, 0xad},
    {0x01, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x41, 0xb5, 0xad},
    {0x06, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x76, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x7b, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x61, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x21, 0x41, 0xb5, 0xad},
    {0x01, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x41, 0xb5, 0xad},
    {0x06, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x7b, 0xb5, 0xff},
    {0x04, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x7b, 0xb5, 0xff},
    {0x08, 0x76, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x41, 0xb5, 0xad},
    {0x05, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc3, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x3d, 0x41, 0xb5, 0xad},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0xd4, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x41, 0xb5, 0xad},
    {0x01, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x41, 0xb5, 0xad},
    {0x06, 0x68, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x82, 0x6d},
    {0x04, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x82, 0x6d},
    {0x09, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x3b, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x3b, 0x41, 0xb5, 0xad},
    {0x05, 0x68, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x82, 0x6d},
    {0x04, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x82, 0x6d},
    {0x0b, 0x7b, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x41, 0xb5, 0xad},
    {0x01, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x41, 0xb5, 0xad},
    {0x06, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x71, 0x03, 0xf5, 0xdf},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x82, 0x6d},
    {0x04, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x82, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x41, 0xb5, 0xad},
    {0x01, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x41, 0xb5, 0xad},
    {0x06, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x39, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x41, 0xb5, 0xad},
    {0x05, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x7b, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x7b, 0xb5, 0xff},
    {0x0c, 0x7b, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x82, 0x6d},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x82, 0x6d},
    {0x07, 0x4e, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x82, 0x6d},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x82, 0x6d},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x82, 0x6d},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x82, 0x6d},
    {0xdd, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x46, 0xb5, 0x9d},
    {0x01, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x16, 0x46, 0xb5, 0x9d},
    {0x06, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xc8, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x46, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x46, 0xb5, 0x9d},
    {0x06, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7d, 0x03, 0xf5, 0xdf},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x41, 0xb5, 0xad},
    {0x01, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x41, 0xb5, 0xad},
    {0x06, 0x78, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x45, 0x03, 0xbd},
    {0x04, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x03, 0xbd},
    {0x08, 0xc8, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x46, 0xb5, 0x9d},
    {0x01, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x19, 0x46, 0xb5, 0x9d},
    {0x05, 0x78, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xce, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x82, 0x6d},
    {0x04, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x82, 0x6d},
    {0x09, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x46, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x46, 0xb5, 0x9d},
    {0x05, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x82, 0x6d},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x82, 0x6d},
    {0x0b, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x46, 0xb5, 0x9d},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x46, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x06, 0xf5, 0x9d},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x82, 0x6d},
    {0x04, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x82, 0x6d},
    {0x4e, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xc2, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0xc2, 0xb5, 0x0d},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x03, 0xbd},
    {0x0c, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x82, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x82, 0x6d},
    {0x07, 0x47, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x82, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x82, 0x6d},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x82, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x82, 0x6d},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa2, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0xa2, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x64, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6e, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x69, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x6f, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x69, 0xb5, 0xff},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x69, 0xb5, 0xff},
    {0x08, 0x64, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x10, 0xb5, 0x40, 0xff},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x50, 0xf5, 0xff},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x50, 0xf5, 0xff},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0xca, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x76, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x76, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x69, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x41, 0xb5, 0xad},
    {0x01, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x7b, 0x03, 0xf5, 0xdf},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x41, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x69, 0xb5, 0xff},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x69, 0xb5, 0xff},
    {0x0c, 0x69, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe2, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x41, 0xb5, 0xad},
    {0x01, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x41, 0xb5, 0xad},
    {0x06, 0x64, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x10, 0x6f},
    {0x04, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x10, 0x6f},
    {0x09, 0x74, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x10, 0x7f},
    {0x01, 0x03, 0x43, 0x50, 0x7f},
    {0x02, 0x0b, 0x43, 0x10, 0x7f},
    {0x05, 0x64, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x10, 0x6f},
    {0x04, 0x03, 0x43, 0x50, 0x7f},
    {0x02, 0x05, 0x41, 0x10, 0x6f},
    {0x0a, 0x50, 0x43, 0xf5, 0xdf},
    {0x03, 0x36, 0x41, 0xb5, 0xad},
    {0x01, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0x10, 0xb5, 0xff},
    {0x03, 0x09, 0x43, 0x10, 0x7f},
    {0x04, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x10, 0x7f},
    {0x07, 0x69, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x50, 0x7f},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x10, 0xb5, 0xff},
    {0x03, 0x06, 0x41, 0x10, 0x6f},
    {0x04, 0x05, 0x43, 0x50, 0x7f},
    {0x02, 0x06, 0x41, 0x10, 0x6f},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x41, 0xb5, 0xad},
    {0x01, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x41, 0xb5, 0xad},
    {0x06, 0x74, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x50, 0x03, 0xdf},
    {0x04, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x50, 0x03, 0xdf},
    {0x08, 0x74, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x41, 0xb5, 0xad},
    {0x05, 0x74, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x41, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x41, 0xb5, 0xad},
    {0x06, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x10, 0x6f},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x10, 0x6f},
    {0x07, 0x50, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x10, 0x6f},
    {0x01, 0x06, 0x43, 0x50, 0x7f},
    {0x02, 0x02, 0x41, 0x10, 0x6f},
    {0x05, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x10, 0x6f},
    {0x04, 0x06, 0x43, 0x50, 0x7f},
    {0x02, 0x07, 0x41, 0x10, 0x6f},
    {0xc7, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x40, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x4f, 0x41, 0xb5, 0xcf},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x40, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x50, 0x43, 0xf5, 0xdf},
    {0x03, 0x2c, 0x41, 0xb5, 0xad},
    {0x01, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xd0, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x10, 0x7f},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x10, 0x7f},
    {0x08, 0x4f, 0x41, 0xb5, 0xcf},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x50, 0x7f},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x50, 0x03, 0xdf},
    {0x04, 0x04, 0x43, 0x50, 0x7f},
    {0x02, 0x81, 0x50, 0x03, 0xdf},
    {0x0c, 0x50, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x43, 0x10, 0x7f},
    {0x01, 0x02, 0x43, 0x50, 0x7f},
    {0x02, 0x0a, 0x43, 0x10, 0x7f},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x50, 0x7f},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x50, 0x7f},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x50, 0x7f},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x50, 0xf5, 0x40, 0x0f},
    {0x03, 0x1e, 0x41, 0xb5, 0xad},
    {0x01, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x1e, 0x41, 0xb5, 0xad},
    {0x06, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x40, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x5f, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x4f, 0xb5, 0xee},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x4f, 0xb5, 0xee},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x0f, 0xb5, 0x00, 0xee},
    {0x03, 0x22, 0x41, 0xb5, 0xad},
    {0x01, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x22, 0x41, 0xb5, 0xad},
    {0x06, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0x40, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x41, 0xb5, 0xad},
    {0x05, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x41, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0xd8, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x30, 0x41, 0xb5, 0xad},
    {0x01, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x41, 0xb5, 0xad},
    {0x06, 0x6c, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x0f, 0x6e},
    {0x04, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x0f, 0x6e},
    {0x09, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3c, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0x4f, 0xf5, 0xee},
    {0x02, 0x3c, 0x41, 0xb5, 0xad},
    {0x05, 0x6c, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x0f, 0x6e},
    {0x04, 0x82, 0x4f, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0f, 0x6e},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x2a, 0x41, 0xb5, 0xad},
    {0x01, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x2a, 0x41, 0xb5, 0xad},
    {0x06, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x79, 0x03, 0xf5, 0xdf},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x0f, 0x6e},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x0f, 0x6e},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x41, 0xb5, 0xad},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x41, 0xb5, 0xad},
    {0x06, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3a, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x41, 0xb5, 0xad},
    {0x05, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x0f, 0x6e},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x0f, 0x6e},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x0f, 0x6e},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x0f, 0x6e},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x0f, 0x6e},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x0f, 0x6e},
    {0xe6, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x10, 0x6f},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x10, 0x6f},
    {0x09, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x10, 0x7f},
    {0x01, 0x03, 0x42, 0x50, 0x7f},
    {0x02, 0x0b, 0x42, 0x10, 0x7f},
    {0x05, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x10, 0x6f},
    {0x04, 0x03, 0x42, 0x50, 0x7f},
    {0x02, 0x05, 0x44, 0x10, 0x6f},
    {0x0a, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x10, 0x7f},
    {0x04, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x10, 0x7f},
    {0x07, 0x4a, 0x01, 0xf5, 0xad},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x50, 0x7f},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x10, 0x6f},
    {0x04, 0x05, 0x42, 0x50, 0x7f},
    {0x02, 0x06, 0x44, 0x10, 0x6f},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x41, 0xb5, 0xad},
    {0x01, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x26, 0x41, 0xb5, 0xad},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x03, 0xbd},
    {0x04, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x03, 0xbd},
    {0x08, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x10, 0xb5, 0xff},
    {0x03, 0x04, 0x44, 0x10, 0x6f},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x10, 0x6f},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x10, 0x6f},
    {0x01, 0x06, 0x42, 0x50, 0x7f},
    {0x02, 0x02, 0x44, 0x10, 0x6f},
    {0x05, 0xc1, 0x10, 0xb5, 0xff},
    {0x03, 0x07, 0x44, 0x10, 0x6f},
    {0x04, 0x06, 0x42, 0x50, 0x7f},
    {0x02, 0x07, 0x44, 0x10, 0x6f},
    {0xc1, 0x41, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x0f, 0x6e},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x0f, 0x6e},
    {0x09, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x0f, 0x6e},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x0f, 0x6e},
    {0x0b, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x50, 0xf5, 0xff},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x50, 0xf5, 0xff},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x50, 0xb5, 0xff},
    {0x01, 0x81, 0x4f, 0xf5, 0xee},
    {0x02, 0x84, 0x50, 0xb5, 0xff},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x0f, 0x6e},
    {0x04, 0x81, 0x4f, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0f, 0x6e},
    {0x4e, 0x0f, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x10, 0x7f},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x10, 0x7f},
    {0x08, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0x4f, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0x50, 0x7f},
    {0x02, 0x83, 0x4f, 0xb5, 0xee},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x50, 0x7f},
    {0x02, 0x81, 0x46, 0x03, 0xbd},
    {0x0c, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x10, 0x7f},
    {0x01, 0x02, 0x42, 0x50, 0x7f},
    {0x02, 0x0a, 0x42, 0x10, 0x7f},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x0f, 0x6e},
    {0x04, 0x02, 0x42, 0x50, 0x7f},
    {0x02, 0x04, 0x42, 0x0f, 0x6e},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x0f, 0x6e},
    {0x01, 0x07, 0x42, 0x50, 0x7f},
    {0x02, 0x02, 0x42, 0x0f, 0x6e},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x0f, 0x6e},
    {0x04, 0x07, 0x42, 0x50, 0x7f},
    {0x02, 0x07, 0x42, 0x0f, 0x6e},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0x9e, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5e, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0x9e, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x4d, 0x41, 0xb5, 0xcf},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x5f, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0x01, 0xf5, 0xcf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x5f, 0xb5, 0xff},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x5f, 0xb5, 0xff},
    {0x08, 0x4d, 0x41, 0xb5, 0xcf},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x5f, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x5f, 0xb5, 0xff},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x5f, 0xb5, 0xff},
    {0x0c, 0x5f, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe0, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0xd9, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x62, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x48, 0x41, 0xf5, 0xcf},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x5a, 0x01, 0xf5, 0xcf},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x48, 0x01, 0xcf},
    {0x04, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0x01, 0xcf},
    {0x08, 0xd9, 0xf5, 0x00, 0x0f},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0xc5, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7e, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x48, 0x41, 0xf5, 0xcf},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xcc, 0xb5, 0x40, 0x0e},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0x01, 0xcf},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x48, 0x01, 0xcf},
    {0x0c, 0x48, 0x41, 0xf5, 0xcf},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x6c, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x70, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x79, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x65, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x44, 0x01, 0xcf},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x44, 0x01, 0xcf},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x04, 0x01, 0xb5, 0xcf},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0x79, 0xb5, 0xff},
    {0x04, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x79, 0xb5, 0xff},
    {0x08, 0x6c, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0x01, 0xb5, 0xcf},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0x41, 0xb5, 0xcf},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0x41, 0xcf},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0x79, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x59, 0x01, 0xf5, 0xcf},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x51, 0x41, 0xb5, 0xcf},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x79, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x79, 0xb5, 0xff},
    {0x0c, 0x79, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xd5, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x60, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0xc5, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0xc4, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0x01, 0xb5, 0xcf},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xd5, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0x01, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xd2, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x44, 0x41, 0xcf},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0x01, 0xcf},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x44, 0x01, 0xcf},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa6, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0xa6, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x41, 0x41, 0xb5, 0xcf},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x4a, 0x41, 0xf5, 0xcf},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0x01, 0xcf},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0x42, 0x01, 0xcf},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0x02, 0x01, 0xb5, 0xcf},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x4a, 0x01, 0xcf},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x4a, 0x01, 0xcf},
    {0x08, 0x41, 0x41, 0xb5, 0xcf},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x06, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x46, 0x43, 0xdf},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x46, 0x43, 0xdf},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0x42, 0x41, 0xcf},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0x41, 0xf5, 0xcf},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0x52, 0x01, 0xf5, 0xcf},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0x01, 0xcf},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x4a, 0x01, 0xcf},
    {0x0c, 0x4a, 0x41, 0xf5, 0xcf},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xe4, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0x01, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x06, 0x6d},
    {0x04, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x06, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x06, 0x7d},
    {0x01, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x0b, 0x43, 0x06, 0x7d},
    {0x05, 0x66, 0x01, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x06, 0x6d},
    {0x04, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x05, 0x41, 0x06, 0x6d},
    {0x0a, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x06, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x06, 0x7d},
    {0x04, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x06, 0x7d},
    {0x07, 0x55, 0x01, 0xf5, 0xcf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x06, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x06, 0x6d},
    {0x04, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x06, 0x41, 0x06, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x03, 0xbd},
    {0x04, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x03, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x06, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x06, 0x6d},
    {0x07, 0x51, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x06, 0x6d},
    {0x01, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x41, 0x06, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x06, 0x6d},
    {0x04, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x41, 0x06, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x42, 0x41, 0xcf},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x06, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x06, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0x42, 0x01, 0xcf},
    {0x01, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x83, 0x42, 0x01, 0xcf},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x81, 0x44, 0x03, 0xbd},
    {0x0c, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x06, 0x7d},
    {0x01, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x0a, 0x43, 0x06, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x46, 0x03, 0xf5, 0xff},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x41, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0x01, 0xcf},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x47, 0x01, 0xcf},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x07, 0x01, 0xb5, 0xcf},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x03, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x03, 0xbd},
    {0x08, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0x41, 0xcf},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0x41, 0xcf},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x03, 0xbd},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0x42, 0x03, 0xbd},
    {0x0c, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xe8, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x06, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x06, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x06, 0x7d},
    {0x01, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x0b, 0x42, 0x06, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x06, 0x6d},
    {0x04, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x05, 0x44, 0x06, 0x6d},
    {0x0a, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x06, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x06, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x06, 0x6d},
    {0x04, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x06, 0x44, 0x06, 0x6d},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x47, 0x03, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x03, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x06, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x06, 0x6d},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x06, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x06, 0x6d},
    {0x01, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x44, 0x06, 0x6d},
    {0x05, 0xc1, 0x06, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x06, 0x6d},
    {0x04, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x44, 0x06, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x46, 0x43, 0xdf},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x46, 0x43, 0xdf},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x46, 0x03, 0xdf},
    {0x01, 0x81, 0x47, 0x41, 0xcf},
    {0x02, 0x84, 0x46, 0x03, 0xdf},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x41, 0xcf},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x01, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x06, 0x7d},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x06, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x01, 0xcf},
    {0x01, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x83, 0x47, 0x01, 0xcf},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x47, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x81, 0x47, 0x03, 0xbd},
    {0x0c, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x06, 0x7d},
    {0x01, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x0a, 0x42, 0x06, 0x7d},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0xb4, 0xf5, 0x00, 0x0d},
    {0x01, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0xb4, 0xf5, 0x00, 0x0d},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x5e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0xf5, 0x00, 0x88},
    {0x01, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x0c, 0xf5, 0x00, 0x88},
    {0x06, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0xf5, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0x4d, 0xb5, 0xee},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0x4d, 0xb5, 0xee},
    {0x05, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0x0d, 0xb5, 0x00, 0xee},
    {0x03, 0x14, 0x47, 0xb5, 0x9e},
    {0x01, 0x0c, 0x47, 0xf5, 0x9e},
    {0x02, 0x14, 0x47, 0xb5, 0x9e},
    {0x06, 0x4b, 0x07, 0xb5, 0x9e},
    {0x03, 0x82, 0x56, 0xb5, 0xee},
    {0x04, 0x0c, 0x47, 0xf5, 0x9e},
    {0x02, 0x82, 0x56, 0xb5, 0xee},
    {0x08, 0x5e, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x47, 0xb5, 0x9e},
    {0x01, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x18, 0x47, 0xb5, 0x9e},
    {0x05, 0x4b, 0x07, 0xb5, 0x9e},
    {0x03, 0x0e, 0xf5, 0x00, 0x88},
    {0x04, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x0e, 0xf5, 0x00, 0x88},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x47, 0xb5, 0x9e},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x47, 0xb5, 0x9e},
    {0x06, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x47, 0xb5, 0x9e},
    {0x01, 0x14, 0x45, 0xf5, 0xae},
    {0x02, 0x17, 0x47, 0xb5, 0x9e},
    {0x06, 0x4c, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x43, 0x0d, 0x6e},
    {0x04, 0x14, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x43, 0x0d, 0x6e},
    {0x09, 0x43, 0x45, 0xb5, 0xae},
    {0x03, 0x1b, 0x47, 0xb5, 0x9e},
    {0x01, 0x82, 0x4d, 0xf5, 0xee},
    {0x02, 0x1b, 0x47, 0xb5, 0x9e},
    {0x05, 0x4c, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x43, 0x0d, 0x6e},
    {0x04, 0x82, 0x4d, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0d, 0x6e},
    {0x0b, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x27, 0x45, 0xb5, 0xae},
    {0x01, 0x18, 0x45, 0xf5, 0xae},
    {0x02, 0x27, 0x45, 0xb5, 0xae},
    {0x06, 0x49, 0x07, 0xb5, 0x9e},
    {0x03, 0x10, 0xf5, 0x00, 0x88},
    {0x04, 0x18, 0x45, 0xf5, 0xae},
    {0x02, 0x10, 0xf5, 0x00, 0x88},
    {0x07, 0x4b, 0x05, 0xf5, 0xae},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x47, 0xf5, 0x9e},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x07, 0xb5, 0x9e},
    {0x03, 0x06, 0x43, 0x0d, 0x6e},
    {0x04, 0x0e, 0x47, 0xf5, 0x9e},
    {0x02, 0x06, 0x43, 0x0d, 0x6e},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x47, 0xb5, 0x9e},
    {0x01, 0x1c, 0x45, 0xf5, 0xae},
    {0x02, 0x13, 0x47, 0xb5, 0x9e},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0x45, 0xf5, 0xae},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0x45, 0xb5, 0xae},
    {0x03, 0x37, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0x45, 0xb5, 0xae},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x56, 0xb5, 0xee},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0x56, 0xb5, 0xee},
    {0x0c, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x43, 0x0d, 0x6e},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0x0d, 0x6e},
    {0x07, 0x45, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x43, 0x0d, 0x6e},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0x0d, 0x6e},
    {0x05, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x43, 0x0d, 0x6e},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0x0d, 0x6e},
    {0xdc, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x45, 0xb5, 0xae},
    {0x01, 0x17, 0x45, 0xf5, 0xae},
    {0x02, 0x2d, 0x45, 0xb5, 0xae},
    {0x06, 0x54, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x44, 0xb5, 0xbe},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x35, 0x45, 0xb5, 0xae},
    {0x01, 0x1b, 0x45, 0xf5, 0xae},
    {0x02, 0x35, 0x45, 0xb5, 0xae},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x45, 0xf5, 0xae},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x04, 0xf5, 0xbe},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x45, 0xb5, 0xae},
    {0x01, 0x27, 0x44, 0xf5, 0xbe},
    {0x02, 0x23, 0x45, 0xb5, 0xae},
    {0x06, 0x58, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x43, 0x04, 0xbe},
    {0x04, 0x27, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x43, 0x04, 0xbe},
    {0x08, 0x4b, 0x44, 0xb5, 0xbe},
    {0x03, 0x33, 0x45, 0xb5, 0xae},
    {0x01, 0x10, 0x47, 0xf5, 0x9e},
    {0x02, 0x33, 0x45, 0xb5, 0xae},
    {0x05, 0x58, 0x04, 0xb5, 0xbe},
    {0x03, 0x0f, 0xf5, 0x00, 0x88},
    {0x04, 0x10, 0x47, 0xf5, 0x9e},
    {0x02, 0x0f, 0xf5, 0x00, 0x88},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x45, 0xb5, 0xae},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x45, 0xb5, 0xae},
    {0x06, 0x4e, 0x05, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x05, 0xf5, 0xae},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x05, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0xf5, 0x00, 0x88},
    {0x01, 0x13, 0x45, 0xf5, 0xae},
    {0x02, 0x0d, 0xf5, 0x00, 0x88},
    {0x06, 0x5c, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x42, 0x0d, 0x6e},
    {0x04, 0x13, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x42, 0x0d, 0x6e},
    {0x09, 0x45, 0x45, 0xb5, 0xae},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x42, 0x0d, 0x6e},
    {0x04, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x05, 0x42, 0x0d, 0x6e},
    {0x0b, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x2b, 0x45, 0xb5, 0xae},
    {0x01, 0x37, 0x44, 0xf5, 0xbe},
    {0x02, 0x2b, 0x45, 0xb5, 0xae},
    {0x06, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x11, 0xf5, 0x00, 0x88},
    {0x04, 0x37, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0xf5, 0x00, 0x88},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4d, 0xf5, 0xee},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0x42, 0x0d, 0x6e},
    {0x04, 0x81, 0x4d, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0d, 0x6e},
    {0x4e, 0x0d, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0xf5, 0x00, 0x88},
    {0x01, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x01, 0xf5, 0x00, 0x88},
    {0x06, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x4d, 0xb5, 0xee},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0x4d, 0xb5, 0xee},
    {0x05, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x81, 0x43, 0x04, 0xbe},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x04, 0xbe},
    {0x0c, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x42, 0x0d, 0x6e},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x0d, 0x6e},
    {0x07, 0x46, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x42, 0x0d, 0x6e},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x0d, 0x6e},
    {0x05, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x42, 0x0d, 0x6e},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x0d, 0x6e},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x45, 0xb5, 0xae},
    {0x01, 0x2d, 0x44, 0xf5, 0xbe},
    {0x02, 0x1d, 0x45, 0xb5, 0xae},
    {0x06, 0x57, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x4c, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x54, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x43, 0x02, 0xce},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x43, 0x02, 0xce},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x03, 0x02, 0xb5, 0xce},
    {0x03, 0x21, 0x45, 0xb5, 0xae},
    {0x01, 0x35, 0x44, 0xf5, 0xbe},
    {0x02, 0x21, 0x45, 0xb5, 0xae},
    {0x06, 0x5b, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x4b, 0x02, 0xce},
    {0x04, 0x35, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x4b, 0x02, 0xce},
    {0x08, 0x4c, 0x42, 0xb5, 0xce},
    {0x03, 0x31, 0x45, 0xb5, 0xae},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x45, 0xb5, 0xae},
    {0x05, 0x5b, 0x04, 0xb5, 0xbe},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc2, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x45, 0xb5, 0xae},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x45, 0xb5, 0xae},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x45, 0xb5, 0xae},
    {0x01, 0x23, 0x44, 0xf5, 0xbe},
    {0x02, 0x2f, 0x45, 0xb5, 0xae},
    {0x06, 0x67, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0x44, 0xb5, 0xbe},
    {0x03, 0x3b, 0x45, 0xb5, 0xae},
    {0x01, 0x82, 0x43, 0x42, 0xce},
    {0x02, 0x3b, 0x45, 0xb5, 0xae},
    {0x05, 0x67, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x29, 0x45, 0xb5, 0xae},
    {0x01, 0x33, 0x44, 0xf5, 0xbe},
    {0x02, 0x29, 0x45, 0xb5, 0xae},
    {0x06, 0x50, 0x05, 0xb5, 0xae},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x58, 0x02, 0xf5, 0xce},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x47, 0xf5, 0x9e},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x05, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0x47, 0xf5, 0x9e},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x45, 0xb5, 0xae},
    {0x01, 0x3f, 0x44, 0xf5, 0xbe},
    {0x02, 0x1f, 0x45, 0xb5, 0xae},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x44, 0xb5, 0xbe},
    {0x03, 0x39, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x45, 0xb5, 0xae},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0x02, 0xce},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x4b, 0x02, 0xce},
    {0x0c, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0xdd, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x47, 0xb5, 0x9e},
    {0x01, 0x0d, 0x47, 0xf5, 0x9e},
    {0x02, 0x16, 0x47, 0xb5, 0x9e},
    {0x06, 0x53, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x47, 0xf5, 0x9e},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x47, 0xb5, 0x9e},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x47, 0xb5, 0x9e},
    {0x06, 0x48, 0x07, 0xb5, 0x9e},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x5c, 0x02, 0xf5, 0xce},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x07, 0xb5, 0x9e},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x45, 0xb5, 0xae},
    {0x01, 0x2b, 0x44, 0xf5, 0xbe},
    {0x02, 0x25, 0x45, 0xb5, 0xae},
    {0x06, 0x77, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x04, 0xbe},
    {0x04, 0x2b, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x45, 0x04, 0xbe},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0x47, 0xb5, 0x9e},
    {0x01, 0x11, 0x47, 0xf5, 0x9e},
    {0x02, 0x19, 0x47, 0xb5, 0x9e},
    {0x05, 0x77, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x47, 0xf5, 0x9e},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x47, 0xf5, 0x9e},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x07, 0xb5, 0x9e},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0x47, 0xf5, 0x9e},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0x45, 0xb5, 0xae},
    {0x03, 0x12, 0x47, 0xb5, 0x9e},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x47, 0xb5, 0x9e},
    {0x05, 0x4a, 0x07, 0xb5, 0x9e},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x47, 0xb5, 0x9e},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x47, 0xb5, 0x9e},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x07, 0xf5, 0x9e},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x43, 0x42, 0xce},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x43, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x43, 0x02, 0xce},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x04, 0xbe},
    {0x0c, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa0, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x44, 0xf5, 0xbe},
    {0x02, 0xa0, 0xf5, 0x00, 0x0e},
    {0x06, 0x6d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x62, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x57, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x5a, 0xb5, 0xee},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x5a, 0xb5, 0xee},
    {0x08, 0x62, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x08, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x48, 0xf5, 0xee},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0x48, 0xf5, 0xee},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x44, 0xf5, 0xbe},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x75, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x21, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x75, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x28, 0x45, 0xb5, 0xae},
    {0x01, 0x31, 0x44, 0xf5, 0xbe},
    {0x02, 0x28, 0x45, 0xb5, 0xae},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x5b, 0x02, 0xf5, 0xce},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x44, 0xf5, 0xbe},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x45, 0xb5, 0xae},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x5a, 0xb5, 0xee},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x5a, 0xb5, 0xee},
    {0x0c, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe1, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x45, 0xb5, 0xae},
    {0x01, 0x2f, 0x44, 0xf5, 0xbe},
    {0x02, 0x2e, 0x45, 0xb5, 0xae},
    {0x06, 0x63, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x08, 0x6e},
    {0x04, 0x2f, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x08, 0x6e},
    {0x09, 0x72, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x08, 0x7e},
    {0x01, 0x03, 0x43, 0x48, 0x7e},
    {0x02, 0x0b, 0x43, 0x08, 0x7e},
    {0x05, 0x63, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x08, 0x6e},
    {0x04, 0x03, 0x43, 0x48, 0x7e},
    {0x02, 0x05, 0x41, 0x08, 0x6e},
    {0x0a, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x36, 0x45, 0xb5, 0xae},
    {0x01, 0x3b, 0x44, 0xf5, 0xbe},
    {0x02, 0x36, 0x45, 0xb5, 0xae},
    {0x06, 0xc2, 0x08, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x08, 0x7e},
    {0x04, 0x3b, 0x44, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x08, 0x7e},
    {0x07, 0x68, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x48, 0x7e},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x08, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x08, 0x6e},
    {0x04, 0x05, 0x43, 0x48, 0x7e},
    {0x02, 0x06, 0x41, 0x08, 0x6e},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x45, 0xb5, 0xae},
    {0x01, 0x29, 0x44, 0xf5, 0xbe},
    {0x02, 0x24, 0x45, 0xb5, 0xae},
    {0x06, 0x73, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x49, 0x02, 0xce},
    {0x04, 0x29, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x49, 0x02, 0xce},
    {0x08, 0x72, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x45, 0xb5, 0xae},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x45, 0xb5, 0xae},
    {0x05, 0x73, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x45, 0xb5, 0xae},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x45, 0xb5, 0xae},
    {0x06, 0x4f, 0x05, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0x08, 0x6e},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x08, 0x6e},
    {0x07, 0x50, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x08, 0x6e},
    {0x01, 0x06, 0x43, 0x48, 0x7e},
    {0x02, 0x02, 0x41, 0x08, 0x6e},
    {0x05, 0x4f, 0x05, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0x08, 0x6e},
    {0x04, 0x06, 0x43, 0x48, 0x7e},
    {0x02, 0x07, 0x41, 0x08, 0x6e},
    {0xc6, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x44, 0xf5, 0xbe},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x7f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x1f, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x4e, 0x42, 0xb5, 0xce},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x7f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x2c, 0x45, 0xb5, 0xae},
    {0x01, 0x39, 0x44, 0xf5, 0xbe},
    {0x02, 0x2c, 0x45, 0xb5, 0xae},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xce, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x08, 0x7e},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x08, 0x7e},
    {0x08, 0x4e, 0x42, 0xb5, 0xce},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x48, 0x7e},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x49, 0x02, 0xce},
    {0x04, 0x04, 0x43, 0x48, 0x7e},
    {0x02, 0x81, 0x49, 0x02, 0xce},
    {0x0c, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x08, 0x7e},
    {0x01, 0x02, 0x43, 0x48, 0x7e},
    {0x02, 0x0a, 0x43, 0x08, 0x7e},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x48, 0x7e},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x48, 0x7e},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x48, 0x7e},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x48, 0xf5, 0x00, 0x0e},
    {0x03, 0x1e, 0x45, 0xb5, 0xae},
    {0x01, 0x16, 0x45, 0xf5, 0xae},
    {0x02, 0x1e, 0x45, 0xb5, 0xae},
    {0x06, 0x4d, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x7e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x53, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x45, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x45, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x05, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x45, 0xb5, 0xae},
    {0x01, 0x1a, 0x45, 0xf5, 0xae},
    {0x02, 0x22, 0x45, 0xb5, 0xae},
    {0x06, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x1a, 0x45, 0xf5, 0xae},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0x7e, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x45, 0xb5, 0xae},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x45, 0xb5, 0xae},
    {0x05, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x45, 0xb5, 0xae},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x45, 0xb5, 0xae},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x05, 0xf5, 0xae},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0x45, 0xb5, 0xae},
    {0x01, 0x25, 0x44, 0xf5, 0xbe},
    {0x02, 0x30, 0x45, 0xb5, 0xae},
    {0x06, 0x6b, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0x45, 0xb5, 0xae},
    {0x03, 0x3c, 0x45, 0xb5, 0xae},
    {0x01, 0x82, 0x45, 0x42, 0xce},
    {0x02, 0x3c, 0x45, 0xb5, 0xae},
    {0x05, 0x6b, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x2a, 0x45, 0xb5, 0xae},
    {0x01, 0x19, 0x45, 0xf5, 0xae},
    {0x02, 0x2a, 0x45, 0xb5, 0xae},
    {0x06, 0x51, 0x05, 0xb5, 0xae},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x45, 0xf5, 0xae},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x78, 0x03, 0xf5, 0xdf},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x05, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x45, 0xb5, 0xae},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x45, 0xb5, 0xae},
    {0x06, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x45, 0xb5, 0xae},
    {0x03, 0x3a, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x45, 0xb5, 0xae},
    {0x05, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xe5, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x44, 0x08, 0x6e},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x08, 0x6e},
    {0x09, 0x42, 0x45, 0xb5, 0xae},
    {0x03, 0x0b, 0x42, 0x08, 0x7e},
    {0x01, 0x03, 0x42, 0x48, 0x7e},
    {0x02, 0x0b, 0x42, 0x08, 0x7e},
    {0x05, 0x41, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x44, 0x08, 0x6e},
    {0x04, 0x03, 0x42, 0x48, 0x7e},
    {0x02, 0x05, 0x44, 0x08, 0x6e},
    {0x0a, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x45, 0xf5, 0xae},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x08, 0x7e},
    {0x04, 0x12, 0x45, 0xf5, 0xae},
    {0x02, 0x09, 0x42, 0x08, 0x7e},
    {0x07, 0x4a, 0x05, 0xf5, 0xae},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x48, 0x7e},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x08, 0x6e},
    {0x04, 0x05, 0x42, 0x48, 0x7e},
    {0x02, 0x06, 0x44, 0x08, 0x6e},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x45, 0xb5, 0xae},
    {0x01, 0x15, 0x45, 0xf5, 0xae},
    {0x02, 0x26, 0x45, 0xb5, 0xae},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x04, 0xbe},
    {0x04, 0x15, 0x45, 0xf5, 0xae},
    {0x02, 0x82, 0x46, 0x04, 0xbe},
    {0x08, 0x42, 0x45, 0xb5, 0xae},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x08, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x08, 0x6e},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x08, 0x6e},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x08, 0x6e},
    {0x01, 0x06, 0x42, 0x48, 0x7e},
    {0x02, 0x02, 0x44, 0x08, 0x6e},
    {0x05, 0xc1, 0x08, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x08, 0x6e},
    {0x04, 0x06, 0x42, 0x48, 0x7e},
    {0x02, 0x07, 0x44, 0x08, 0x6e},
    {0xc1, 0x45, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0x45, 0xb5, 0xae},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x48, 0xf5, 0xee},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x48, 0xf5, 0xee},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x48, 0xb5, 0xee},
    {0x01, 0x81, 0x45, 0x42, 0xce},
    {0x02, 0x84, 0x48, 0xb5, 0xee},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x08, 0x7e},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x08, 0x7e},
    {0x08, 0x47, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x45, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x48, 0x7e},
    {0x02, 0x83, 0x45, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0x48, 0x7e},
    {0x02, 0x81, 0x46, 0x04, 0xbe},
    {0x0c, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x08, 0x7e},
    {0x01, 0x02, 0x42, 0x48, 0x7e},
    {0x02, 0x0a, 0x42, 0x08, 0x7e},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0x48, 0x7e},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0x48, 0x7e},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0x48, 0x7e},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0xa3, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x4b, 0xb5, 0x6d},
    {0x04, 0xa3, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4b, 0xb5, 0x6d},
    {0x09, 0x70, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x48, 0xb5, 0x7d},
    {0x01, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x0b, 0x48, 0xb5, 0x7d},
    {0x05, 0x5d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x4b, 0xb5, 0x6d},
    {0x04, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x05, 0x4b, 0xb5, 0x6d},
    {0x0a, 0x65, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x48, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x48, 0xb5, 0x7d},
    {0x07, 0x6e, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4b, 0xb5, 0x6d},
    {0x04, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x06, 0x4b, 0xb5, 0x6d},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x65, 0xb5, 0xff},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x65, 0xb5, 0xff},
    {0x08, 0x70, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4b, 0xb5, 0x6d},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0x4b, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4b, 0xb5, 0x6d},
    {0x01, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x4b, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4b, 0xb5, 0x6d},
    {0x04, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x4b, 0xb5, 0x6d},
    {0x52, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x65, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0x44, 0xb5, 0xee},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0x44, 0xb5, 0xee},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0x04, 0xb5, 0xee},
    {0x03, 0x08, 0x48, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x48, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0x04, 0xb5, 0xee},
    {0x03, 0x81, 0x65, 0xb5, 0xff},
    {0x04, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x81, 0x65, 0xb5, 0xff},
    {0x0c, 0x65, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x48, 0xb5, 0x7d},
    {0x01, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x0a, 0x48, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdf, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x7c, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x61, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x76, 0x03, 0xf5, 0xdf},
    {0x03, 0x87, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0x44, 0xb5, 0xee},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0x44, 0xf5, 0xbe},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x7c, 0xf5, 0x00, 0xee},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0xdb, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0x44, 0xf5, 0xbe},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc8, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0x44, 0xf5, 0xbe},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0x04, 0x6e},
    {0x04, 0x2e, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0x04, 0x6e},
    {0x09, 0x6a, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x04, 0x7e},
    {0x01, 0x03, 0x41, 0x44, 0x7e},
    {0x02, 0x0b, 0x41, 0x04, 0x7e},
    {0x05, 0x6f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0x04, 0x6e},
    {0x04, 0x03, 0x41, 0x44, 0x7e},
    {0x02, 0x05, 0x46, 0x04, 0x6e},
    {0x0a, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0x04, 0x8e},
    {0x01, 0x0b, 0x43, 0x44, 0x8e},
    {0x02, 0x0c, 0x43, 0x04, 0x8e},
    {0x06, 0x43, 0x03, 0x04, 0x8e},
    {0x03, 0x09, 0x41, 0x04, 0x7e},
    {0x04, 0x0b, 0x43, 0x44, 0x8e},
    {0x02, 0x09, 0x41, 0x04, 0x7e},
    {0x07, 0x64, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x51, 0xb5, 0xee},
    {0x01, 0x05, 0x41, 0x44, 0x7e},
    {0x02, 0x9a, 0x51, 0xb5, 0xee},
    {0x05, 0x43, 0x03, 0x04, 0x8e},
    {0x03, 0x06, 0x46, 0x04, 0x6e},
    {0x04, 0x05, 0x41, 0x44, 0x7e},
    {0x02, 0x06, 0x46, 0x04, 0x6e},
    {0x4d, 0x11, 0xb5, 0x00, 0xee},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0x44, 0xf5, 0xbe},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x59, 0xb5, 0xee},
    {0x04, 0x36, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x59, 0xb5, 0xee},
    {0x08, 0x6a, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x44, 0x8e},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0x02, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0x04, 0x8e},
    {0x04, 0x09, 0x43, 0x44, 0x8e},
    {0x02, 0x0e, 0x43, 0x04, 0x8e},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x46, 0x04, 0x6e},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x04, 0x6e},
    {0x07, 0xc2, 0x04, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x04, 0x6e},
    {0x01, 0x06, 0x41, 0x44, 0x7e},
    {0x02, 0x02, 0x46, 0x04, 0x6e},
    {0x05, 0x45, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x46, 0x04, 0x6e},
    {0x04, 0x06, 0x41, 0x44, 0x7e},
    {0x02, 0x07, 0x46, 0x04, 0x6e},
    {0xd7, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0x44, 0xf5, 0xbe},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x11, 0x6e},
    {0x04, 0x24, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x11, 0x6e},
    {0x09, 0x50, 0x42, 0xb5, 0xce},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x51, 0xf5, 0xee},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x11, 0x6e},
    {0x04, 0x82, 0x51, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x11, 0x6e},
    {0x0b, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0x44, 0xf5, 0xbe},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x04, 0x8e},
    {0x04, 0x34, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0x04, 0x8e},
    {0x07, 0x74, 0x03, 0xf5, 0xdf},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x11, 0x6e},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x11, 0x6e},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0x44, 0xf5, 0xbe},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x04, 0x7e},
    {0x04, 0x00, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0x04, 0x7e},
    {0x08, 0x50, 0x42, 0xb5, 0xce},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x44, 0x7e},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x59, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0x44, 0x7e},
    {0x02, 0x81, 0x59, 0xb5, 0xee},
    {0x0c, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0x04, 0x7e},
    {0x01, 0x02, 0x41, 0x44, 0x7e},
    {0x02, 0x0a, 0x41, 0x04, 0x7e},
    {0x06, 0x46, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x43, 0x11, 0x6e},
    {0x04, 0x02, 0x41, 0x44, 0x7e},
    {0x02, 0x04, 0x43, 0x11, 0x6e},
    {0x07, 0x4f, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x11, 0x6e},
    {0x01, 0x07, 0x41, 0x44, 0x7e},
    {0x02, 0x02, 0x43, 0x11, 0x6e},
    {0x05, 0x46, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x43, 0x11, 0x6e},
    {0x04, 0x07, 0x41, 0x44, 0x7e},
    {0x02, 0x07, 0x43, 0x11, 0x6e},
    {0xde, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xd1, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x5f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x4f, 0x43, 0xf5, 0xdf},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x40, 0x03, 0xf5, 0xdf},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0x44, 0xf5, 0xbe},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x4f, 0x03, 0xdf},
    {0x04, 0x2c, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x4f, 0x03, 0xdf},
    {0x08, 0xd1, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x04, 0x8e},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x04, 0x8e},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x44, 0xb5, 0xee},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x44, 0xb5, 0xee},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xd1, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x04, 0x8e},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x04, 0x8e},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x11, 0x6e},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x11, 0x6e},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x44, 0x8e},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x11, 0x6e},
    {0x04, 0x08, 0x43, 0x44, 0x8e},
    {0x02, 0x05, 0x42, 0x11, 0x6e},
    {0x0b, 0x4f, 0x43, 0xf5, 0xdf},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x04, 0x8e},
    {0x03, 0x11, 0x43, 0x04, 0x8e},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0x04, 0x8e},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x51, 0xf5, 0xee},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0x04, 0x8e},
    {0x03, 0x06, 0x42, 0x11, 0x6e},
    {0x04, 0x81, 0x51, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x11, 0x6e},
    {0x4e, 0x11, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x43, 0x04, 0x8e},
    {0x01, 0x0a, 0x43, 0x44, 0x8e},
    {0x02, 0x01, 0x43, 0x04, 0x8e},
    {0x06, 0x42, 0x03, 0x04, 0x8e},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0x44, 0x8e},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x51, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x51, 0xb5, 0xee},
    {0x05, 0x42, 0x03, 0x04, 0x8e},
    {0x03, 0x81, 0x4f, 0x03, 0xdf},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x4f, 0x03, 0xdf},
    {0x0c, 0x4f, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x42, 0x11, 0x6e},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x11, 0x6e},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x11, 0x6e},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x11, 0x6e},
    {0x05, 0x47, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x42, 0x11, 0x6e},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x11, 0x6e},
    {0xf4, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x9e, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0x44, 0xf5, 0xbe},
    {0x02, 0x9e, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x60, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0xc5, 0xf5, 0x40, 0x0f},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x04, 0xf5, 0xbe},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0xc5, 0xb5, 0x0f},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0xc5, 0xb5, 0x0f},
    {0x08, 0x60, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x81, 0xb5, 0x40, 0x0e},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0xc1, 0xf5, 0x0e},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0xc1, 0xf5, 0x0e},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0xcd, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x44, 0xf5, 0xbe},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x22, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x48, 0x44, 0xb5, 0xbe},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0xc5, 0xf5, 0x40, 0x0f},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0x44, 0xf5, 0xbe},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0xdb, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x44, 0xf5, 0xbe},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x44, 0xb5, 0xbe},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc5, 0xb5, 0x0f},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0xc5, 0xb5, 0x0f},
    {0x0c, 0xc5, 0xf5, 0x40, 0x0f},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe3, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0x44, 0xf5, 0xbe},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x81, 0x6e},
    {0x04, 0x30, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x81, 0x6e},
    {0x09, 0x7a, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x81, 0x7e},
    {0x01, 0x03, 0x43, 0xc1, 0x7e},
    {0x02, 0x0b, 0x43, 0x81, 0x7e},
    {0x05, 0x65, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x81, 0x6e},
    {0x04, 0x03, 0x43, 0xc1, 0x7e},
    {0x02, 0x05, 0x41, 0x81, 0x6e},
    {0x0a, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0x44, 0xf5, 0xbe},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x81, 0xb5, 0x0e},
    {0x03, 0x09, 0x43, 0x81, 0x7e},
    {0x04, 0x3c, 0x44, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x81, 0x7e},
    {0x07, 0x6c, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0xc1, 0x7e},
    {0x02, 0x88, 0x44, 0xb5, 0xee},
    {0x05, 0xc2, 0x81, 0xb5, 0x0e},
    {0x03, 0x06, 0x41, 0x81, 0x6e},
    {0x04, 0x05, 0x43, 0xc1, 0x7e},
    {0x02, 0x06, 0x41, 0x81, 0x6e},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0x44, 0xf5, 0xbe},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x44, 0x04, 0xbe},
    {0x04, 0x2a, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x44, 0x04, 0xbe},
    {0x08, 0x7a, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0x04, 0xb5, 0xbe},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x81, 0x6e},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x81, 0x6e},
    {0x07, 0x51, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x81, 0x6e},
    {0x01, 0x06, 0x43, 0xc1, 0x7e},
    {0x02, 0x02, 0x41, 0x81, 0x6e},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x81, 0x6e},
    {0x04, 0x06, 0x43, 0xc1, 0x7e},
    {0x02, 0x07, 0x41, 0x81, 0x6e},
    {0xc9, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x44, 0xf5, 0xbe},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x20, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0x44, 0xf5, 0xbe},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xd6, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x81, 0x7e},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x81, 0x7e},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xc1, 0x7e},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x04, 0xbe},
    {0x04, 0x04, 0x43, 0xc1, 0x7e},
    {0x02, 0x81, 0x44, 0x04, 0xbe},
    {0x0c, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0x81, 0x7e},
    {0x01, 0x02, 0x43, 0xc1, 0x7e},
    {0x02, 0x0a, 0x43, 0x81, 0x7e},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xc1, 0x7e},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xc1, 0x7e},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xc1, 0x7e},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0x81, 0xb5, 0x00, 0x0e},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x04, 0x6e},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x04, 0x6e},
    {0x09, 0x4a, 0x44, 0xb5, 0xbe},
    {0x03, 0x0b, 0x44, 0x04, 0x7e},
    {0x01, 0x03, 0x44, 0x44, 0x7e},
    {0x02, 0x0b, 0x44, 0x04, 0x7e},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x04, 0x6e},
    {0x04, 0x03, 0x44, 0x44, 0x7e},
    {0x02, 0x05, 0x45, 0x04, 0x6e},
    {0x0a, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x0c, 0x42, 0x04, 0x8e},
    {0x01, 0x0b, 0x42, 0x44, 0x8e},
    {0x02, 0x0c, 0x42, 0x04, 0x8e},
    {0x06, 0x43, 0x02, 0x04, 0x8e},
    {0x03, 0x09, 0x44, 0x04, 0x7e},
    {0x04, 0x0b, 0x42, 0x44, 0x8e},
    {0x02, 0x09, 0x44, 0x04, 0x7e},
    {0x07, 0x41, 0x04, 0xf5, 0xbe},
    {0x03, 0x9a, 0x46, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0x44, 0x7e},
    {0x02, 0x9a, 0x46, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0x04, 0x8e},
    {0x03, 0x06, 0x45, 0x04, 0x6e},
    {0x04, 0x05, 0x44, 0x44, 0x7e},
    {0x02, 0x06, 0x45, 0x04, 0x6e},
    {0x4d, 0x06, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x42, 0x04, 0xbe},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x04, 0xbe},
    {0x08, 0x4a, 0x44, 0xb5, 0xbe},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x44, 0x8e},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0x04, 0xb5, 0xbe},
    {0x03, 0x0e, 0x42, 0x04, 0x8e},
    {0x04, 0x09, 0x42, 0x44, 0x8e},
    {0x02, 0x0e, 0x42, 0x04, 0x8e},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x45, 0x04, 0x6e},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x04, 0x6e},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x04, 0x6e},
    {0x01, 0x06, 0x44, 0x44, 0x7e},
    {0x02, 0x02, 0x45, 0x04, 0x6e},
    {0x05, 0x45, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x45, 0x04, 0x6e},
    {0x04, 0x06, 0x44, 0x44, 0x7e},
    {0x02, 0x07, 0x45, 0x04, 0x6e},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0x44, 0xf5, 0xbe},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0x42, 0xce},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x04, 0x8e},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x04, 0x8e},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x04, 0x7e},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x04, 0x7e},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x44, 0x7e},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x04, 0xbe},
    {0x04, 0x04, 0x44, 0x44, 0x7e},
    {0x02, 0x81, 0x42, 0x04, 0xbe},
    {0x0c, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x44, 0x04, 0x7e},
    {0x01, 0x02, 0x44, 0x44, 0x7e},
    {0x02, 0x0a, 0x44, 0x04, 0x7e},
    {0x06, 0x46, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0x44, 0x7e},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0x04, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0x44, 0x7e},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0x44, 0x7e},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xe7, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x81, 0x6e},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x81, 0x6e},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x81, 0x7e},
    {0x01, 0x03, 0x42, 0xc1, 0x7e},
    {0x02, 0x0b, 0x42, 0x81, 0x7e},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x81, 0x6e},
    {0x04, 0x03, 0x42, 0xc1, 0x7e},
    {0x02, 0x05, 0x44, 0x81, 0x6e},
    {0x0a, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x81, 0x7e},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x81, 0x7e},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0xc1, 0x7e},
    {0x02, 0x8a, 0x44, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x81, 0x6e},
    {0x04, 0x05, 0x42, 0xc1, 0x7e},
    {0x02, 0x06, 0x44, 0x81, 0x6e},
    {0x50, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0x04, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x04, 0xbe},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x04, 0xbe},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x04, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x04, 0x8e},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x04, 0x8e},
    {0x40, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x44, 0xb5, 0xee},
    {0x01, 0x84, 0x44, 0xf5, 0xee},
    {0x02, 0x86, 0x44, 0xb5, 0xee},
    {0x06, 0xc1, 0x81, 0xb5, 0x0e},
    {0x03, 0x04, 0x44, 0x81, 0x6e},
    {0x04, 0x84, 0x44, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x81, 0x6e},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x81, 0x6e},
    {0x01, 0x06, 0x42, 0xc1, 0x7e},
    {0x02, 0x02, 0x44, 0x81, 0x6e},
    {0x05, 0xc1, 0x81, 0xb5, 0x0e},
    {0x03, 0x07, 0x44, 0x81, 0x6e},
    {0x04, 0x06, 0x42, 0xc1, 0x7e},
    {0x02, 0x07, 0x44, 0x81, 0x6e},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x04, 0x8e},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x04, 0x8e},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0x44, 0x8e},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0x44, 0x8e},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0xc1, 0xf5, 0x0e},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x04, 0x8e},
    {0x03, 0x11, 0x42, 0x04, 0x8e},
    {0x04, 0x83, 0xc1, 0xf5, 0x0e},
    {0x02, 0x11, 0x42, 0x04, 0x8e},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0xc1, 0xb5, 0x0e},
    {0x01, 0x81, 0x46, 0x42, 0xce},
    {0x02, 0x84, 0xc1, 0xb5, 0x0e},
    {0x05, 0x44, 0x02, 0x04, 0x8e},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x04, 0x8e},
    {0x01, 0x0a, 0x42, 0x44, 0x8e},
    {0x02, 0x01, 0x42, 0x04, 0x8e},
    {0x06, 0x42, 0x02, 0x04, 0x8e},
    {0x03, 0x08, 0x42, 0x81, 0x7e},
    {0x04, 0x0a, 0x42, 0x44, 0x8e},
    {0x02, 0x08, 0x42, 0x81, 0x7e},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0xc1, 0x7e},
    {0x02, 0x83, 0x46, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0x04, 0x8e},
    {0x03, 0x81, 0x47, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0xc1, 0x7e},
    {0x02, 0x81, 0x47, 0x04, 0xbe},
    {0x0c, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x81, 0x7e},
    {0x01, 0x02, 0x42, 0xc1, 0x7e},
    {0x02, 0x0a, 0x42, 0x81, 0x7e},
    {0x06, 0x47, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0xc1, 0x7e},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0xc1, 0x7e},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0xc1, 0x7e},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0x4e, 0xb5, 0x6e},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0x4e, 0xb5, 0x6e},
    {0x09, 0x56, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x4c, 0xb5, 0x7e},
    {0x01, 0x03, 0x4c, 0xf5, 0x7e},
    {0x02, 0x0b, 0x4c, 0xb5, 0x7e},
    {0x05, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0x4e, 0xb5, 0x6e},
    {0x04, 0x03, 0x4c, 0xf5, 0x7e},
    {0x02, 0x05, 0x4e, 0xb5, 0x6e},
    {0x0a, 0x4d, 0x43, 0xf5, 0xdf},
    {0x03, 0x0c, 0x47, 0xb5, 0x8d},
    {0x01, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x0c, 0x47, 0xb5, 0x8d},
    {0x06, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x09, 0x4c, 0xb5, 0x7e},
    {0x04, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x09, 0x4c, 0xb5, 0x7e},
    {0x07, 0x5e, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x41, 0xb5, 0xee},
    {0x01, 0x05, 0x4c, 0xf5, 0x7e},
    {0x02, 0x9a, 0x41, 0xb5, 0xee},
    {0x05, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0x4e, 0xb5, 0x6e},
    {0x04, 0x05, 0x4c, 0xf5, 0x7e},
    {0x02, 0x06, 0x4e, 0xb5, 0x6e},
    {0x4d, 0x01, 0xb5, 0x00, 0xee},
    {0x03, 0x14, 0x45, 0xb5, 0x9d},
    {0x01, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x14, 0x45, 0xb5, 0x9d},
    {0x06, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x82, 0x4d, 0x03, 0xdf},
    {0x04, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x82, 0x4d, 0x03, 0xdf},
    {0x08, 0x56, 0x43, 0xb5, 0xdf},
    {0x03, 0x18, 0x45, 0xb5, 0x9d},
    {0x01, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x18, 0x45, 0xb5, 0x9d},
    {0x05, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x0e, 0x47, 0xb5, 0x8d},
    {0x04, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x0e, 0x47, 0xb5, 0x8d},
    {0x4f, 0x0a, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x45, 0xb5, 0x9d},
    {0x01, 0x9a, 0x4a, 0xf5, 0xee},
    {0x02, 0x1c, 0x45, 0xb5, 0x9d},
    {0x06, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x4e, 0xb5, 0x6e},
    {0x04, 0x9a, 0x4a, 0xf5, 0xee},
    {0x02, 0x04, 0x4e, 0xb5, 0x6e},
    {0x07, 0x43, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x4e, 0xb5, 0x6e},
    {0x01, 0x06, 0x4c, 0xf5, 0x7e},
    {0x02, 0x02, 0x4e, 0xb5, 0x6e},
    {0x05, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x4e, 0xb5, 0x6e},
    {0x04, 0x06, 0x4c, 0xf5, 0x7e},
    {0x02, 0x07, 0x4e, 0xb5, 0x6e},
    {0x52, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x45, 0xb5, 0x9d},
    {0x01, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x17, 0x45, 0xb5, 0x9d},
    {0x06, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0x01, 0x6e},
    {0x04, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0x01, 0x6e},
    {0x09, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x1b, 0x45, 0xb5, 0x9d},
    {0x01, 0x82, 0x41, 0xf5, 0xee},
    {0x02, 0x1b, 0x45, 0xb5, 0x9d},
    {0x05, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0x01, 0x6e},
    {0x04, 0x82, 0x41, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x01, 0x6e},
    {0x0b, 0x4d, 0x43, 0xf5, 0xdf},
    {0x03, 0x27, 0x44, 0xb5, 0xad},
    {0x01, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x27, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x10, 0x47, 0xb5, 0x8d},
    {0x04, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x47, 0xb5, 0x8d},
    {0x07, 0x4b, 0x04, 0xf5, 0xad},
    {0x03, 0x89, 0x42, 0xb5, 0xee},
    {0x01, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x89, 0x42, 0xb5, 0xee},
    {0x05, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0x01, 0x6e},
    {0x04, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x01, 0x6e},
    {0x51, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x45, 0xb5, 0x9d},
    {0x01, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x13, 0x45, 0xb5, 0x9d},
    {0x06, 0xda, 0x02, 0xb5, 0xee},
    {0x03, 0x08, 0x4c, 0xb5, 0x7e},
    {0x04, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x08, 0x4c, 0xb5, 0x7e},
    {0x08, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x37, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x4c, 0xf5, 0x7e},
    {0x02, 0x37, 0x44, 0xb5, 0xad},
    {0x05, 0xda, 0x02, 0xb5, 0xee},
    {0x03, 0x81, 0x4d, 0x03, 0xdf},
    {0x04, 0x04, 0x4c, 0xf5, 0x7e},
    {0x02, 0x81, 0x4d, 0x03, 0xdf},
    {0x0c, 0x4d, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x4c, 0xb5, 0x7e},
    {0x01, 0x02, 0x4c, 0xf5, 0x7e},
    {0x02, 0x0a, 0x4c, 0xb5, 0x7e},
    {0x06, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x43, 0x01, 0x6e},
    {0x04, 0x02, 0x4c, 0xf5, 0x7e},
    {0x02, 0x04, 0x43, 0x01, 0x6e},
    {0x07, 0x45, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0x01, 0x6e},
    {0x01, 0x07, 0x4c, 0xf5, 0x7e},
    {0x02, 0x02, 0x43, 0x01, 0x6e},
    {0x05, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x43, 0x01, 0x6e},
    {0x04, 0x07, 0x4c, 0xf5, 0x7e},
    {0x02, 0x07, 0x43, 0x01, 0x6e},
    {0xdc, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x44, 0xb5, 0xad},
    {0x01, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x2d, 0x44, 0xb5, 0xad},
    {0x06, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0x0a, 0x6e},
    {0x04, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0x0a, 0x6e},
    {0x09, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0x0a, 0x7e},
    {0x01, 0x03, 0x43, 0x4a, 0x7e},
    {0x02, 0x0b, 0x43, 0x0a, 0x7e},
    {0x05, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0x0a, 0x6e},
    {0x04, 0x03, 0x43, 0x4a, 0x7e},
    {0x02, 0x05, 0x41, 0x0a, 0x6e},
    {0x0a, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x35, 0x44, 0xb5, 0xad},
    {0x01, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x35, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0x0a, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x0a, 0x7e},
    {0x04, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0x0a, 0x7e},
    {0x07, 0x4c, 0x02, 0xf5, 0xbd},
    {0x03, 0x87, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x4a, 0x7e},
    {0x02, 0x87, 0x42, 0xb5, 0xee},
    {0x05, 0xc2, 0x0a, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x0a, 0x6e},
    {0x04, 0x05, 0x43, 0x4a, 0x7e},
    {0x02, 0x06, 0x41, 0x0a, 0x6e},
    {0x57, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x23, 0x44, 0xb5, 0xad},
    {0x01, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x44, 0xb5, 0xad},
    {0x06, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x02, 0xbd},
    {0x04, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x02, 0xbd},
    {0x08, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x33, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x33, 0x44, 0xb5, 0xad},
    {0x05, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x47, 0xb5, 0x8d},
    {0x04, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x47, 0xb5, 0x8d},
    {0x54, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x3f, 0x44, 0xb5, 0xad},
    {0x01, 0x89, 0x46, 0xf5, 0xff},
    {0x02, 0x3f, 0x44, 0xb5, 0xad},
    {0x06, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x0a, 0x6e},
    {0x04, 0x89, 0x46, 0xf5, 0xff},
    {0x02, 0x04, 0x41, 0x0a, 0x6e},
    {0x07, 0x49, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0x0a, 0x6e},
    {0x01, 0x06, 0x43, 0x4a, 0x7e},
    {0x02, 0x02, 0x41, 0x0a, 0x6e},
    {0x05, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x0a, 0x6e},
    {0x04, 0x06, 0x43, 0x4a, 0x7e},
    {0x02, 0x07, 0x41, 0x0a, 0x6e},
    {0x59, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x0d, 0x47, 0xb5, 0x8d},
    {0x01, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x0d, 0x47, 0xb5, 0x8d},
    {0x06, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0x01, 0x6e},
    {0x04, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0x01, 0x6e},
    {0x09, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x97, 0x46, 0xb5, 0xff},
    {0x01, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x97, 0x46, 0xb5, 0xff},
    {0x05, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0x01, 0x6e},
    {0x04, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x05, 0x42, 0x01, 0x6e},
    {0x0b, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x2b, 0x44, 0xb5, 0xad},
    {0x01, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x11, 0x47, 0xb5, 0x8d},
    {0x04, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x47, 0xb5, 0x8d},
    {0x07, 0xda, 0x06, 0xf5, 0xff},
    {0x03, 0x93, 0x46, 0xb5, 0xff},
    {0x01, 0x81, 0x41, 0xf5, 0xee},
    {0x02, 0x93, 0x46, 0xb5, 0xff},
    {0x05, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0x42, 0x01, 0x6e},
    {0x04, 0x81, 0x41, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x01, 0x6e},
    {0x4e, 0x01, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x47, 0xb5, 0x8d},
    {0x01, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x01, 0x47, 0xb5, 0x8d},
    {0x06, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x08, 0x43, 0x0a, 0x7e},
    {0x04, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x08, 0x43, 0x0a, 0x7e},
    {0x08, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0x41, 0xb5, 0xee},
    {0x01, 0x04, 0x43, 0x4a, 0x7e},
    {0x02, 0x83, 0x41, 0xb5, 0xee},
    {0x05, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x81, 0x43, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0x4a, 0x7e},
    {0x02, 0x81, 0x43, 0x02, 0xbd},
    {0x0c, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x0a, 0x7e},
    {0x01, 0x02, 0x43, 0x4a, 0x7e},
    {0x02, 0x0a, 0x43, 0x0a, 0x7e},
    {0x06, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x42, 0x01, 0x6e},
    {0x04, 0x02, 0x43, 0x4a, 0x7e},
    {0x02, 0x04, 0x42, 0x01, 0x6e},
    {0x07, 0x46, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x01, 0x6e},
    {0x01, 0x07, 0x43, 0x4a, 0x7e},
    {0x02, 0x02, 0x42, 0x01, 0x6e},
    {0x05, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x42, 0x01, 0x6e},
    {0x04, 0x07, 0x43, 0x4a, 0x7e},
    {0x02, 0x07, 0x42, 0x01, 0x6e},
    {0xf4, 0x4a, 0xf5, 0x00, 0x0e},
    {0x03, 0x1d, 0x44, 0xb5, 0xad},
    {0x01, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x44, 0xb5, 0xad},
    {0x06, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0x02, 0x6e},
    {0x04, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x02, 0x6e},
    {0x09, 0x5a, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x41, 0x02, 0x7e},
    {0x01, 0x03, 0x41, 0x42, 0x7e},
    {0x02, 0x0b, 0x41, 0x02, 0x7e},
    {0x05, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0x02, 0x6e},
    {0x04, 0x03, 0x41, 0x42, 0x7e},
    {0x02, 0x05, 0x46, 0x02, 0x6e},
    {0x0a, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0x02, 0x8e},
    {0x01, 0x0b, 0x43, 0x42, 0x8e},
    {0x02, 0x0c, 0x43, 0x02, 0x8e},
    {0x06, 0x43, 0x03, 0x02, 0x8e},
    {0x03, 0x09, 0x41, 0x02, 0x7e},
    {0x04, 0x0b, 0x43, 0x42, 0x8e},
    {0x02, 0x09, 0x41, 0x02, 0x7e},
    {0x07, 0x62, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x48, 0x03, 0xdf},
    {0x01, 0x05, 0x41, 0x42, 0x7e},
    {0x02, 0x9a, 0x48, 0x03, 0xdf},
    {0x05, 0x43, 0x03, 0x02, 0x8e},
    {0x03, 0x06, 0x46, 0x02, 0x6e},
    {0x04, 0x05, 0x41, 0x42, 0x7e},
    {0x02, 0x06, 0x46, 0x02, 0x6e},
    {0x4d, 0x08, 0x03, 0xb5, 0xdf},
    {0x03, 0x21, 0x44, 0xb5, 0xad},
    {0x01, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x44, 0xb5, 0xad},
    {0x06, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x52, 0xb5, 0xee},
    {0x04, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x52, 0xb5, 0xee},
    {0x08, 0x5a, 0x43, 0xb5, 0xdf},
    {0x03, 0x31, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0x42, 0x8e},
    {0x02, 0x31, 0x44, 0xb5, 0xad},
    {0x05, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0x02, 0x8e},
    {0x04, 0x09, 0x43, 0x42, 0x8e},
    {0x02, 0x0e, 0x43, 0x02, 0x8e},
    {0xc3, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x44, 0xb5, 0xad},
    {0x01, 0x87, 0x46, 0xf5, 0xff},
    {0x02, 0x3d, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x46, 0x02, 0x6e},
    {0x04, 0x87, 0x46, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x02, 0x6e},
    {0x07, 0xc2, 0x02, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x02, 0x6e},
    {0x01, 0x06, 0x41, 0x42, 0x7e},
    {0x02, 0x02, 0x46, 0x02, 0x6e},
    {0x05, 0x45, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x46, 0x02, 0x6e},
    {0x04, 0x06, 0x41, 0x42, 0x7e},
    {0x02, 0x07, 0x46, 0x02, 0x6e},
    {0xd5, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x44, 0xb5, 0xad},
    {0x01, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x44, 0xb5, 0xad},
    {0x06, 0x68, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x08, 0x6d},
    {0x04, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x08, 0x6d},
    {0x09, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x3b, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0x48, 0x43, 0xdf},
    {0x02, 0x3b, 0x44, 0xb5, 0xad},
    {0x05, 0x68, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x08, 0x6d},
    {0x04, 0x82, 0x48, 0x43, 0xdf},
    {0x02, 0x05, 0x43, 0x08, 0x6d},
    {0x0b, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x44, 0xb5, 0xad},
    {0x01, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x44, 0xb5, 0xad},
    {0x06, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0x02, 0x8e},
    {0x04, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x02, 0x8e},
    {0x07, 0x72, 0x03, 0xf5, 0xdf},
    {0x03, 0x8f, 0x46, 0xb5, 0xff},
    {0x01, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x8f, 0x46, 0xb5, 0xff},
    {0x05, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x08, 0x6d},
    {0x04, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x08, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x44, 0xb5, 0xad},
    {0x01, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x44, 0xb5, 0xad},
    {0x06, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x02, 0x7e},
    {0x04, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x02, 0x7e},
    {0x08, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x39, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0x42, 0x7e},
    {0x02, 0x39, 0x44, 0xb5, 0xad},
    {0x05, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x52, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0x42, 0x7e},
    {0x02, 0x81, 0x52, 0xb5, 0xee},
    {0x0c, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0x02, 0x7e},
    {0x01, 0x02, 0x41, 0x42, 0x7e},
    {0x02, 0x0a, 0x41, 0x02, 0x7e},
    {0x06, 0x46, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x43, 0x08, 0x6d},
    {0x04, 0x02, 0x41, 0x42, 0x7e},
    {0x02, 0x04, 0x43, 0x08, 0x6d},
    {0x07, 0x4e, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x08, 0x6d},
    {0x01, 0x07, 0x41, 0x42, 0x7e},
    {0x02, 0x02, 0x43, 0x08, 0x6d},
    {0x05, 0x46, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x43, 0x08, 0x6d},
    {0x04, 0x07, 0x41, 0x42, 0x7e},
    {0x02, 0x07, 0x43, 0x08, 0x6d},
    {0xdd, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x45, 0xb5, 0x9d},
    {0x01, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x16, 0x45, 0xb5, 0x9d},
    {0x06, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0x0a, 0x6e},
    {0x04, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0x0a, 0x6e},
    {0x09, 0xca, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0x0a, 0x7e},
    {0x01, 0x03, 0x42, 0x4a, 0x7e},
    {0x02, 0x0b, 0x42, 0x0a, 0x7e},
    {0x05, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0x0a, 0x6e},
    {0x04, 0x03, 0x42, 0x4a, 0x7e},
    {0x02, 0x05, 0x44, 0x0a, 0x6e},
    {0x0a, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x45, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x45, 0xb5, 0x9d},
    {0x06, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0x0a, 0x7e},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x0a, 0x7e},
    {0x07, 0x7e, 0x03, 0xf5, 0xdf},
    {0x03, 0x8b, 0x46, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x4a, 0x7e},
    {0x02, 0x8b, 0x46, 0xb5, 0xff},
    {0x05, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0x0a, 0x6e},
    {0x04, 0x05, 0x42, 0x4a, 0x7e},
    {0x02, 0x06, 0x44, 0x0a, 0x6e},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x44, 0xb5, 0xad},
    {0x01, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x44, 0xb5, 0xad},
    {0x06, 0x78, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x02, 0xbd},
    {0x04, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x02, 0xbd},
    {0x08, 0xca, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x45, 0xb5, 0x9d},
    {0x01, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x19, 0x45, 0xb5, 0x9d},
    {0x05, 0x78, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x02, 0x8e},
    {0x04, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0x02, 0x8e},
    {0x55, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x85, 0x42, 0xb5, 0xee},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x42, 0xb5, 0xee},
    {0x06, 0xc1, 0x0a, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x0a, 0x6e},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x0a, 0x6e},
    {0x07, 0x44, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0x0a, 0x6e},
    {0x01, 0x06, 0x42, 0x4a, 0x7e},
    {0x02, 0x02, 0x44, 0x0a, 0x6e},
    {0x05, 0xc1, 0x0a, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x0a, 0x6e},
    {0x04, 0x06, 0x42, 0x4a, 0x7e},
    {0x02, 0x07, 0x44, 0x0a, 0x6e},
    {0xcf, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x02, 0x8e},
    {0x01, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0x02, 0x8e},
    {0x06, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x08, 0x6d},
    {0x04, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x08, 0x6d},
    {0x09, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x45, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0x42, 0x8e},
    {0x02, 0x12, 0x45, 0xb5, 0x9d},
    {0x05, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x08, 0x6d},
    {0x04, 0x08, 0x43, 0x42, 0x8e},
    {0x02, 0x05, 0x42, 0x08, 0x6d},
    {0x0b, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x45, 0xb5, 0x9d},
    {0x01, 0x83, 0x4a, 0xf5, 0xee},
    {0x02, 0x15, 0x45, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0x02, 0x8e},
    {0x03, 0x11, 0x43, 0x02, 0x8e},
    {0x04, 0x83, 0x4a, 0xf5, 0xee},
    {0x02, 0x11, 0x43, 0x02, 0x8e},
    {0x07, 0x42, 0x05, 0xf5, 0x9d},
    {0x03, 0x84, 0x4a, 0xb5, 0xee},
    {0x01, 0x81, 0x48, 0x43, 0xdf},
    {0x02, 0x84, 0x4a, 0xb5, 0xee},
    {0x05, 0x44, 0x03, 0x02, 0x8e},
    {0x03, 0x06, 0x42, 0x08, 0x6d},
    {0x04, 0x81, 0x48, 0x43, 0xdf},
    {0x02, 0x06, 0x42, 0x08, 0x6d},
    {0x4e, 0x08, 0x03, 0xb5, 0xdf},
    {0x03, 0x01, 0x43, 0x02, 0x8e},
    {0x01, 0x0a, 0x43, 0x42, 0x8e},
    {0x02, 0x01, 0x43, 0x02, 0x8e},
    {0x06, 0x42, 0x03, 0x02, 0x8e},
    {0x03, 0x08, 0x42, 0x0a, 0x7e},
    {0x04, 0x0a, 0x43, 0x42, 0x8e},
    {0x02, 0x08, 0x42, 0x0a, 0x7e},
    {0x08, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0x48, 0x03, 0xdf},
    {0x01, 0x04, 0x42, 0x4a, 0x7e},
    {0x02, 0x83, 0x48, 0x03, 0xdf},
    {0x05, 0x42, 0x03, 0x02, 0x8e},
    {0x03, 0x81, 0x45, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x4a, 0x7e},
    {0x02, 0x81, 0x45, 0x02, 0xbd},
    {0x0c, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x0a, 0x7e},
    {0x01, 0x02, 0x42, 0x4a, 0x7e},
    {0x02, 0x0a, 0x42, 0x0a, 0x7e},
    {0x06, 0x47, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x42, 0x08, 0x6d},
    {0x04, 0x02, 0x42, 0x4a, 0x7e},
    {0x02, 0x04, 0x42, 0x08, 0x6d},
    {0x07, 0x47, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x08, 0x6d},
    {0x01, 0x07, 0x42, 0x4a, 0x7e},
    {0x02, 0x02, 0x42, 0x08, 0x6d},
    {0x05, 0x47, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x42, 0x08, 0x6d},
    {0x04, 0x07, 0x42, 0x4a, 0x7e},
    {0x02, 0x07, 0x42, 0x08, 0x6d},
    {0xf4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0xa4, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0xa4, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x66, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0x06, 0x7f},
    {0x01, 0x03, 0x46, 0x46, 0x7f},
    {0x02, 0x0b, 0x46, 0x06, 0x7f},
    {0x05, 0x6e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0x46, 0x7f},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x41, 0x06, 0x8f},
    {0x01, 0x0b, 0x41, 0x46, 0x8f},
    {0x02, 0x0c, 0x41, 0x06, 0x8f},
    {0x06, 0x43, 0x01, 0x06, 0x8f},
    {0x03, 0x09, 0x46, 0x06, 0x7f},
    {0x04, 0x0b, 0x41, 0x46, 0x8f},
    {0x02, 0x09, 0x46, 0x06, 0x7f},
    {0x07, 0x70, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc3, 0xb5, 0x0e},
    {0x01, 0x05, 0x46, 0x46, 0x7f},
    {0x02, 0x9a, 0xc3, 0xb5, 0x0e},
    {0x05, 0x43, 0x01, 0x06, 0x8f},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0x46, 0x7f},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0x83, 0xb5, 0x00, 0x0e},
    {0x03, 0x14, 0x43, 0x06, 0x9f},
    {0x01, 0x0c, 0x43, 0x46, 0x9f},
    {0x02, 0x14, 0x43, 0x06, 0x9f},
    {0x06, 0x4b, 0x03, 0x06, 0x9f},
    {0x03, 0x82, 0x55, 0xb5, 0xee},
    {0x04, 0x0c, 0x43, 0x46, 0x9f},
    {0x02, 0x82, 0x55, 0xb5, 0xee},
    {0x08, 0x66, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0x06, 0x9f},
    {0x01, 0x09, 0x41, 0x46, 0x8f},
    {0x02, 0x18, 0x43, 0x06, 0x9f},
    {0x05, 0x4b, 0x03, 0x06, 0x9f},
    {0x03, 0x0e, 0x41, 0x06, 0x8f},
    {0x04, 0x09, 0x41, 0x46, 0x8f},
    {0x02, 0x0e, 0x41, 0x06, 0x8f},
    {0x4f, 0x04, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x43, 0x06, 0x9f},
    {0x01, 0x9a, 0x44, 0x43, 0xdf},
    {0x02, 0x1c, 0x43, 0x06, 0x9f},
    {0x06, 0x45, 0x01, 0x06, 0x8f},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x44, 0x43, 0xdf},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0x46, 0x9f},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0x46, 0x7f},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0x06, 0x8f},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0x46, 0x7f},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0xcb, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x43, 0x06, 0x9f},
    {0x01, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0x06, 0x9f},
    {0x06, 0x76, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x83, 0x6e},
    {0x04, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x83, 0x6e},
    {0x09, 0xc2, 0x46, 0xb5, 0xff},
    {0x03, 0x1b, 0x43, 0x06, 0x9f},
    {0x01, 0x82, 0xc3, 0xf5, 0x0e},
    {0x02, 0x1b, 0x43, 0x06, 0x9f},
    {0x05, 0x76, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x83, 0x6e},
    {0x04, 0x82, 0xc3, 0xf5, 0x0e},
    {0x02, 0x05, 0x43, 0x83, 0x6e},
    {0x0b, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x28, 0x44, 0xb5, 0xad},
    {0x01, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0x06, 0x9f},
    {0x03, 0x10, 0x41, 0x06, 0x8f},
    {0x04, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0x06, 0x8f},
    {0x07, 0x7c, 0x03, 0xf5, 0xdf},
    {0x03, 0x8d, 0x46, 0xb5, 0xff},
    {0x01, 0x0e, 0x43, 0x46, 0x9f},
    {0x02, 0x8d, 0x46, 0xb5, 0xff},
    {0x05, 0x49, 0x03, 0x06, 0x9f},
    {0x03, 0x06, 0x43, 0x83, 0x6e},
    {0x04, 0x0e, 0x43, 0x46, 0x9f},
    {0x02, 0x06, 0x43, 0x83, 0x6e},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0x06, 0x9f},
    {0x01, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0x06, 0x9f},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0x06, 0x7f},
    {0x04, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0x06, 0x7f},
    {0x08, 0xc2, 0x46, 0xb5, 0xff},
    {0x03, 0x38, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0x46, 0x7f},
    {0x02, 0x38, 0x44, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x55, 0xb5, 0xee},
    {0x04, 0x04, 0x46, 0x46, 0x7f},
    {0x02, 0x81, 0x55, 0xb5, 0xee},
    {0x0c, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x46, 0x06, 0x7f},
    {0x01, 0x02, 0x46, 0x46, 0x7f},
    {0x02, 0x0a, 0x46, 0x06, 0x7f},
    {0x06, 0x46, 0x01, 0x06, 0x8f},
    {0x03, 0x04, 0x43, 0x83, 0x6e},
    {0x04, 0x02, 0x46, 0x46, 0x7f},
    {0x02, 0x04, 0x43, 0x83, 0x6e},
    {0x07, 0x45, 0x03, 0x46, 0x9f},
    {0x03, 0x02, 0x43, 0x83, 0x6e},
    {0x01, 0x07, 0x46, 0x46, 0x7f},
    {0x02, 0x02, 0x43, 0x83, 0x6e},
    {0x05, 0x46, 0x01, 0x06, 0x8f},
    {0x03, 0x07, 0x43, 0x83, 0x6e},
    {0x04, 0x07, 0x46, 0x46, 0x7f},
    {0x02, 0x07, 0x43, 0x83, 0x6e},
    {0xe2, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x44, 0xb5, 0xad},
    {0x01, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x44, 0xb5, 0xad},
    {0x06, 0x64, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x04, 0x6d},
    {0x04, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x04, 0x6d},
    {0x09, 0x59, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x04, 0x7d},
    {0x01, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x0b, 0x43, 0x04, 0x7d},
    {0x05, 0x64, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x04, 0x6d},
    {0x04, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x05, 0x41, 0x04, 0x6d},
    {0x0a, 0x51, 0x43, 0xf5, 0xdf},
    {0x03, 0x36, 0x44, 0xb5, 0xad},
    {0x01, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0x04, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x04, 0x7d},
    {0x04, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x04, 0x7d},
    {0x07, 0x6a, 0x03, 0xf5, 0xdf},
    {0x03, 0x88, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x88, 0x42, 0xb5, 0xee},
    {0x05, 0xc2, 0x04, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x04, 0x6d},
    {0x04, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x06, 0x41, 0x04, 0x6d},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x44, 0xb5, 0xad},
    {0x01, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x44, 0xb5, 0xad},
    {0x06, 0x74, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x51, 0x03, 0xdf},
    {0x04, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x51, 0x03, 0xdf},
    {0x08, 0x59, 0x43, 0xb5, 0xdf},
    {0x03, 0x34, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0x46, 0x9f},
    {0x02, 0x34, 0x44, 0xb5, 0xad},
    {0x05, 0x74, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0x06, 0x8f},
    {0x04, 0x10, 0x43, 0x46, 0x9f},
    {0x02, 0x0f, 0x41, 0x06, 0x8f},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x44, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x44, 0xb5, 0xad},
    {0x06, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x04, 0x6d},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x04, 0x6d},
    {0x07, 0x50, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x04, 0x6d},
    {0x01, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x41, 0x04, 0x6d},
    {0x05, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x04, 0x6d},
    {0x04, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x41, 0x04, 0x6d},
    {0xc7, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0x06, 0x8f},
    {0x01, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0x06, 0x8f},
    {0x06, 0x40, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x83, 0x6e},
    {0x04, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x83, 0x6e},
    {0x09, 0x4f, 0x42, 0xb5, 0xce},
    {0x03, 0x99, 0x46, 0xb5, 0xff},
    {0x01, 0x08, 0x41, 0x46, 0x8f},
    {0x02, 0x99, 0x46, 0xb5, 0xff},
    {0x05, 0x40, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x83, 0x6e},
    {0x04, 0x08, 0x41, 0x46, 0x8f},
    {0x02, 0x05, 0x42, 0x83, 0x6e},
    {0x0b, 0x51, 0x43, 0xf5, 0xdf},
    {0x03, 0x2c, 0x44, 0xb5, 0xad},
    {0x01, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0x06, 0x8f},
    {0x03, 0x11, 0x41, 0x06, 0x8f},
    {0x04, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0x06, 0x8f},
    {0x07, 0xd2, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0x46, 0xb5, 0xff},
    {0x01, 0x81, 0xc3, 0xf5, 0x0e},
    {0x02, 0x95, 0x46, 0xb5, 0xff},
    {0x05, 0x44, 0x01, 0x06, 0x8f},
    {0x03, 0x06, 0x42, 0x83, 0x6e},
    {0x04, 0x81, 0xc3, 0xf5, 0x0e},
    {0x02, 0x06, 0x42, 0x83, 0x6e},
    {0x4e, 0x83, 0xb5, 0x00, 0x0e},
    {0x03, 0x01, 0x41, 0x06, 0x8f},
    {0x01, 0x0a, 0x41, 0x46, 0x8f},
    {0x02, 0x01, 0x41, 0x06, 0x8f},
    {0x06, 0x42, 0x01, 0x06, 0x8f},
    {0x03, 0x08, 0x43, 0x04, 0x7d},
    {0x04, 0x0a, 0x41, 0x46, 0x8f},
    {0x02, 0x08, 0x43, 0x04, 0x7d},
    {0x08, 0x4f, 0x42, 0xb5, 0xce},
    {0x03, 0x83, 0xc3, 0xb5, 0x0e},
    {0x01, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x83, 0xc3, 0xb5, 0x0e},
    {0x05, 0x42, 0x01, 0x06, 0x8f},
    {0x03, 0x81, 0x51, 0x03, 0xdf},
    {0x04, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x81, 0x51, 0x03, 0xdf},
    {0x0c, 0x51, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x43, 0x04, 0x7d},
    {0x01, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x0a, 0x43, 0x04, 0x7d},
    {0x06, 0x47, 0x01, 0x06, 0x8f},
    {0x03, 0x04, 0x42, 0x83, 0x6e},
    {0x04, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0x83, 0x6e},
    {0x07, 0x46, 0x03, 0x46, 0x9f},
    {0x03, 0x02, 0x42, 0x83, 0x6e},
    {0x01, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0x83, 0x6e},
    {0x05, 0x47, 0x01, 0x06, 0x8f},
    {0x03, 0x07, 0x42, 0x83, 0x6e},
    {0x04, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0x83, 0x6e},
    {0xf4, 0x44, 0x03, 0xf5, 0xff},
    {0x03, 0x1e, 0x44, 0xb5, 0xad},
    {0x01, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x1e, 0x44, 0xb5, 0xad},
    {0x06, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0x02, 0x6e},
    {0x04, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0x02, 0x6e},
    {0x09, 0xc6, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x44, 0x02, 0x7e},
    {0x01, 0x03, 0x44, 0x42, 0x7e},
    {0x02, 0x0b, 0x44, 0x02, 0x7e},
    {0x05, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0x02, 0x6e},
    {0x04, 0x03, 0x44, 0x42, 0x7e},
    {0x02, 0x05, 0x45, 0x02, 0x6e},
    {0x0a, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x0c, 0x42, 0x02, 0x8e},
    {0x01, 0x0b, 0x42, 0x42, 0x8e},
    {0x02, 0x0c, 0x42, 0x02, 0x8e},
    {0x06, 0x43, 0x02, 0x02, 0x8e},
    {0x03, 0x09, 0x44, 0x02, 0x7e},
    {0x04, 0x0b, 0x42, 0x42, 0x8e},
    {0x02, 0x09, 0x44, 0x02, 0x7e},
    {0x07, 0x60, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x01, 0x05, 0x44, 0x42, 0x7e},
    {0x02, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x05, 0x43, 0x02, 0x02, 0x8e},
    {0x03, 0x06, 0x45, 0x02, 0x6e},
    {0x04, 0x05, 0x44, 0x42, 0x7e},
    {0x02, 0x06, 0x45, 0x02, 0x6e},
    {0x4d, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x22, 0x44, 0xb5, 0xad},
    {0x01, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x22, 0x44, 0xb5, 0xad},
    {0x06, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xc4, 0xb5, 0x0e},
    {0x04, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0xc4, 0xb5, 0x0e},
    {0x08, 0xc6, 0xf5, 0x00, 0x0e},
    {0x03, 0x32, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0x42, 0x8e},
    {0x02, 0x32, 0x44, 0xb5, 0xad},
    {0x05, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0x02, 0x8e},
    {0x04, 0x09, 0x42, 0x42, 0x8e},
    {0x02, 0x0e, 0x42, 0x02, 0x8e},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x44, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x45, 0x02, 0x6e},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0x02, 0x6e},
    {0x07, 0x48, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0x02, 0x6e},
    {0x01, 0x06, 0x44, 0x42, 0x7e},
    {0x02, 0x02, 0x45, 0x02, 0x6e},
    {0x05, 0x45, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x45, 0x02, 0x6e},
    {0x04, 0x06, 0x44, 0x42, 0x7e},
    {0x02, 0x07, 0x45, 0x02, 0x6e},
    {0xd9, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x30, 0x44, 0xb5, 0xad},
    {0x01, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x44, 0xb5, 0xad},
    {0x06, 0x6c, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x81, 0x6d},
    {0x04, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x81, 0x6d},
    {0x09, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3c, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x3c, 0x44, 0xb5, 0xad},
    {0x05, 0x6c, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x81, 0x6d},
    {0x04, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x81, 0x6d},
    {0x0b, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x2a, 0x44, 0xb5, 0xad},
    {0x01, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x2a, 0x44, 0xb5, 0xad},
    {0x06, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0x02, 0x8e},
    {0x04, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0x02, 0x8e},
    {0x07, 0x7a, 0x03, 0xf5, 0xdf},
    {0x03, 0x91, 0x46, 0xb5, 0xff},
    {0x01, 0x0f, 0x43, 0x46, 0x9f},
    {0x02, 0x91, 0x46, 0xb5, 0xff},
    {0x05, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x81, 0x6d},
    {0x04, 0x0f, 0x43, 0x46, 0x9f},
    {0x02, 0x06, 0x43, 0x81, 0x6d},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x44, 0xb5, 0xad},
    {0x01, 0x85, 0x46, 0xf5, 0xff},
    {0x02, 0x20, 0x44, 0xb5, 0xad},
    {0x06, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0x02, 0x7e},
    {0x04, 0x85, 0x46, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x02, 0x7e},
    {0x08, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3a, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0x42, 0x7e},
    {0x02, 0x3a, 0x44, 0xb5, 0xad},
    {0x05, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc4, 0xb5, 0x0e},
    {0x04, 0x04, 0x44, 0x42, 0x7e},
    {0x02, 0x81, 0xc4, 0xb5, 0x0e},
    {0x0c, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x0a, 0x44, 0x02, 0x7e},
    {0x01, 0x02, 0x44, 0x42, 0x7e},
    {0x02, 0x0a, 0x44, 0x02, 0x7e},
    {0x06, 0x46, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x43, 0x81, 0x6d},
    {0x04, 0x02, 0x44, 0x42, 0x7e},
    {0x02, 0x04, 0x43, 0x81, 0x6d},
    {0x07, 0xc1, 0x02, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x81, 0x6d},
    {0x01, 0x07, 0x44, 0x42, 0x7e},
    {0x02, 0x02, 0x43, 0x81, 0x6d},
    {0x05, 0x46, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x43, 0x81, 0x6d},
    {0x04, 0x07, 0x44, 0x42, 0x7e},
    {0x02, 0x07, 0x43, 0x81, 0x6d},
    {0xe6, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0x06, 0x9f},
    {0x01, 0x0d, 0x43, 0x46, 0x9f},
    {0x02, 0x16, 0x43, 0x06, 0x9f},
    {0x06, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x04, 0x6d},
    {0x04, 0x0d, 0x43, 0x46, 0x9f},
    {0x02, 0x03, 0x44, 0x04, 0x6d},
    {0x09, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x04, 0x7d},
    {0x01, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x0b, 0x42, 0x04, 0x7d},
    {0x05, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x04, 0x6d},
    {0x04, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x05, 0x44, 0x04, 0x6d},
    {0x0a, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0x06, 0x9f},
    {0x01, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0x06, 0x9f},
    {0x06, 0x48, 0x03, 0x06, 0x9f},
    {0x03, 0x09, 0x42, 0x04, 0x7d},
    {0x04, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x04, 0x7d},
    {0x07, 0x4a, 0x04, 0xf5, 0xad},
    {0x03, 0x8a, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x8a, 0x42, 0xb5, 0xee},
    {0x05, 0x48, 0x03, 0x06, 0x9f},
    {0x03, 0x06, 0x44, 0x04, 0x6d},
    {0x04, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x06, 0x44, 0x04, 0x6d},
    {0x50, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x44, 0xb5, 0xad},
    {0x01, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x26, 0x44, 0xb5, 0xad},
    {0x06, 0xc3, 0x02, 0xb5, 0xee},
    {0x03, 0x82, 0x46, 0x02, 0xbd},
    {0x04, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x02, 0xbd},
    {0x08, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0x06, 0x9f},
    {0x01, 0x11, 0x43, 0x46, 0x9f},
    {0x02, 0x19, 0x43, 0x06, 0x9f},
    {0x05, 0xc3, 0x02, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x02, 0x8e},
    {0x04, 0x11, 0x43, 0x46, 0x9f},
    {0x02, 0x0f, 0x42, 0x02, 0x8e},
    {0x40, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x42, 0xb5, 0xee},
    {0x01, 0x84, 0x42, 0xf5, 0xee},
    {0x02, 0x86, 0x42, 0xb5, 0xee},
    {0x06, 0xc1, 0x04, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x04, 0x6d},
    {0x04, 0x84, 0x42, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x04, 0x6d},
    {0x07, 0x44, 0x03, 0x46, 0x9f},
    {0x03, 0x02, 0x44, 0x04, 0x6d},
    {0x01, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x44, 0x04, 0x6d},
    {0x05, 0xc1, 0x04, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x04, 0x6d},
    {0x04, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x44, 0x04, 0x6d},
    {0xc1, 0x44, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0x02, 0x8e},
    {0x01, 0x01, 0x43, 0x46, 0x9f},
    {0x02, 0x0d, 0x42, 0x02, 0x8e},
    {0x06, 0x4a, 0x03, 0x06, 0x9f},
    {0x03, 0x03, 0x42, 0x81, 0x6d},
    {0x04, 0x01, 0x43, 0x46, 0x9f},
    {0x02, 0x03, 0x42, 0x81, 0x6d},
    {0x09, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0x06, 0x9f},
    {0x01, 0x08, 0x42, 0x42, 0x8e},
    {0x02, 0x12, 0x43, 0x06, 0x9f},
    {0x05, 0x4a, 0x03, 0x06, 0x9f},
    {0x03, 0x05, 0x42, 0x81, 0x6d},
    {0x04, 0x08, 0x42, 0x42, 0x8e},
    {0x02, 0x05, 0x42, 0x81, 0x6d},
    {0x0b, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0x06, 0x9f},
    {0x01, 0x83, 0x44, 0x43, 0xdf},
    {0x02, 0x15, 0x43, 0x06, 0x9f},
    {0x06, 0x44, 0x02, 0x02, 0x8e},
    {0x03, 0x11, 0x42, 0x02, 0x8e},
    {0x04, 0x83, 0x44, 0x43, 0xdf},
    {0x02, 0x11, 0x42, 0x02, 0x8e},
    {0x07, 0x42, 0x03, 0x46, 0x9f},
    {0x03, 0x84, 0x44, 0x03, 0xdf},
    {0x01, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x84, 0x44, 0x03, 0xdf},
    {0x05, 0x44, 0x02, 0x02, 0x8e},
    {0x03, 0x06, 0x42, 0x81, 0x6d},
    {0x04, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x81, 0x6d},
    {0x4e, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x42, 0x02, 0x8e},
    {0x01, 0x0a, 0x42, 0x42, 0x8e},
    {0x02, 0x01, 0x42, 0x02, 0x8e},
    {0x06, 0x42, 0x02, 0x02, 0x8e},
    {0x03, 0x08, 0x42, 0x04, 0x7d},
    {0x04, 0x0a, 0x42, 0x42, 0x8e},
    {0x02, 0x08, 0x42, 0x04, 0x7d},
    {0x08, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0xc1, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x83, 0xc1, 0xb5, 0x0d},
    {0x05, 0x42, 0x02, 0x02, 0x8e},
    {0x03, 0x81, 0x46, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x81, 0x46, 0x02, 0xbd},
    {0x0c, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x04, 0x7d},
    {0x01, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x0a, 0x42, 0x04, 0x7d},
    {0x06, 0x47, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x42, 0x81, 0x6d},
    {0x04, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0x81, 0x6d},
    {0x07, 0x47, 0x03, 0x46, 0x9f},
    {0x03, 0x02, 0x42, 0x81, 0x6d},
    {0x01, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0x81, 0x6d},
    {0x05, 0x47, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x42, 0x81, 0x6d},
    {0x04, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0x81, 0x6d},
    {0xf4, 0x46, 0xf5, 0x40, 0x0f},
    {0x03, 0xb4, 0x46, 0xb5, 0xff},
    {0x01, 0xa7, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0x46, 0xb5, 0xff},
    {0x06, 0x5e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x4c, 0xb5, 0x6d},
    {0x04, 0xa7, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4c, 0xb5, 0x6d},
    {0x09, 0x4d, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x4c, 0xb5, 0x6d},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0x4c, 0xb5, 0x6d},
    {0x0a, 0x41, 0x43, 0xf5, 0xdf},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x4a, 0x03, 0xdf},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0x4a, 0x03, 0xdf},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x4c, 0xb5, 0x6d},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0x4c, 0xb5, 0x6d},
    {0x4d, 0x0a, 0x03, 0xb5, 0xdf},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x41, 0x03, 0xdf},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x41, 0x03, 0xdf},
    {0x08, 0x4d, 0x42, 0xb5, 0xce},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0x02, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0x42, 0x43, 0xdf},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x4c, 0xb5, 0x6d},
    {0x04, 0x9a, 0x42, 0x43, 0xdf},
    {0x02, 0x04, 0x4c, 0xb5, 0x6d},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x4c, 0xb5, 0x6d},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x4c, 0xb5, 0x6d},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x4c, 0xb5, 0x6d},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x4c, 0xb5, 0x6d},
    {0x52, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x0a, 0x6d},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x0a, 0x6d},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0x4a, 0x43, 0xdf},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x0a, 0x6d},
    {0x04, 0x82, 0x4a, 0x43, 0xdf},
    {0x02, 0x05, 0x43, 0x0a, 0x6d},
    {0x0b, 0x41, 0x43, 0xf5, 0xdf},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0x47, 0xb5, 0xee},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0x47, 0xb5, 0xee},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x0a, 0x6d},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x0a, 0x6d},
    {0x51, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0x07, 0xb5, 0xee},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0x07, 0xb5, 0xee},
    {0x03, 0x81, 0x41, 0x03, 0xdf},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x41, 0x03, 0xdf},
    {0x0c, 0x41, 0x43, 0xf5, 0xdf},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x0a, 0x6d},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0x0a, 0x6d},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x0a, 0x6d},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0x0a, 0x6d},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x0a, 0x6d},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0x0a, 0x6d},
    {0xe0, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x02, 0x6d},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0x02, 0x6d},
    {0x09, 0x52, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x02, 0x7d},
    {0x01, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x0b, 0x43, 0x02, 0x7d},
    {0x05, 0x62, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x02, 0x6d},
    {0x04, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x05, 0x41, 0x02, 0x6d},
    {0x0a, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x02, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x02, 0x7d},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0x02, 0x7d},
    {0x07, 0x5a, 0x02, 0xf5, 0xce},
    {0x03, 0x87, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x87, 0x47, 0xb5, 0xee},
    {0x05, 0xc2, 0x02, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x02, 0x6d},
    {0x04, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x06, 0x41, 0x02, 0x6d},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x48, 0x02, 0xce},
    {0x04, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0x02, 0xce},
    {0x08, 0x52, 0x43, 0xb5, 0xdf},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x02, 0x6d},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x02, 0x6d},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0x02, 0x6d},
    {0x01, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x41, 0x02, 0x6d},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x02, 0x6d},
    {0x04, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x41, 0x02, 0x6d},
    {0xc5, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x0a, 0x6d},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x0a, 0x6d},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0x46, 0xb5, 0xff},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0x46, 0xb5, 0xff},
    {0x05, 0x7e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x0a, 0x6d},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x0a, 0x6d},
    {0x0b, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xca, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0x46, 0xb5, 0xff},
    {0x01, 0x81, 0x4a, 0x43, 0xdf},
    {0x02, 0x94, 0x46, 0xb5, 0xff},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x0a, 0x6d},
    {0x04, 0x81, 0x4a, 0x43, 0xdf},
    {0x02, 0x06, 0x42, 0x0a, 0x6d},
    {0x4e, 0x0a, 0x03, 0xb5, 0xdf},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0x02, 0x7d},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0x02, 0x7d},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x4a, 0x03, 0xdf},
    {0x01, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x83, 0x4a, 0x03, 0xdf},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0x02, 0xce},
    {0x04, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x81, 0x48, 0x02, 0xce},
    {0x0c, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x02, 0x7d},
    {0x01, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x0a, 0x43, 0x02, 0x7d},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x0a, 0x6d},
    {0x04, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x0a, 0x6d},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x0a, 0x6d},
    {0x01, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x0a, 0x6d},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x0a, 0x6d},
    {0x04, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x0a, 0x6d},
    {0xf4, 0x42, 0x03, 0xf5, 0xff},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0x07, 0x6e},
    {0x04, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x07, 0x6e},
    {0x09, 0x55, 0x43, 0xb5, 0xdf},
    {0x03, 0x0b, 0x41, 0x07, 0x7e},
    {0x01, 0x03, 0x41, 0x47, 0x7e},
    {0x02, 0x0b, 0x41, 0x07, 0x7e},
    {0x05, 0x70, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0x07, 0x6e},
    {0x04, 0x03, 0x41, 0x47, 0x7e},
    {0x02, 0x05, 0x46, 0x07, 0x6e},
    {0x0a, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x43, 0x07, 0x8e},
    {0x01, 0x0b, 0x43, 0x47, 0x8e},
    {0x02, 0x0c, 0x43, 0x07, 0x8e},
    {0x06, 0x43, 0x03, 0x07, 0x8e},
    {0x03, 0x09, 0x41, 0x07, 0x7e},
    {0x04, 0x0b, 0x43, 0x47, 0x8e},
    {0x02, 0x09, 0x41, 0x07, 0x7e},
    {0x07, 0x66, 0x03, 0xf5, 0xdf},
    {0x03, 0x9a, 0x44, 0x02, 0xce},
    {0x01, 0x05, 0x41, 0x47, 0x7e},
    {0x02, 0x9a, 0x44, 0x02, 0xce},
    {0x05, 0x43, 0x03, 0x07, 0x8e},
    {0x03, 0x06, 0x46, 0x07, 0x6e},
    {0x04, 0x05, 0x41, 0x47, 0x7e},
    {0x02, 0x06, 0x46, 0x07, 0x6e},
    {0x4d, 0x04, 0x02, 0xb5, 0xce},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc3, 0xb5, 0x0d},
    {0x04, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc3, 0xb5, 0x0d},
    {0x08, 0x55, 0x43, 0xb5, 0xdf},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x47, 0x8e},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0x02, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0x07, 0x8e},
    {0x04, 0x09, 0x43, 0x47, 0x8e},
    {0x02, 0x0e, 0x43, 0x07, 0x8e},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0x46, 0xf5, 0xff},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x46, 0x07, 0x6e},
    {0x04, 0x88, 0x46, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x07, 0x6e},
    {0x07, 0xc2, 0x07, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x07, 0x6e},
    {0x01, 0x06, 0x41, 0x47, 0x7e},
    {0x02, 0x02, 0x46, 0x07, 0x6e},
    {0x05, 0x45, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x46, 0x07, 0x6e},
    {0x04, 0x06, 0x41, 0x47, 0x7e},
    {0x02, 0x07, 0x46, 0x07, 0x6e},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0x42, 0xb5, 0xce},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0x42, 0xce},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x07, 0x8e},
    {0x04, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x07, 0x8e},
    {0x07, 0x59, 0x02, 0xf5, 0xce},
    {0x03, 0x90, 0x46, 0xb5, 0xff},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0x46, 0xb5, 0xff},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x07, 0x7e},
    {0x04, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x07, 0x7e},
    {0x08, 0x51, 0x42, 0xb5, 0xce},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x47, 0x7e},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc3, 0xb5, 0x0d},
    {0x04, 0x04, 0x41, 0x47, 0x7e},
    {0x02, 0x81, 0xc3, 0xb5, 0x0d},
    {0x0c, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x41, 0x07, 0x7e},
    {0x01, 0x02, 0x41, 0x47, 0x7e},
    {0x02, 0x0a, 0x41, 0x07, 0x7e},
    {0x06, 0x46, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0x47, 0x7e},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0x47, 0x7e},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0x47, 0x7e},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0x02, 0x6d},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0x02, 0x6d},
    {0x09, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x0b, 0x42, 0x02, 0x7d},
    {0x01, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x0b, 0x42, 0x02, 0x7d},
    {0x05, 0x60, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0x02, 0x6d},
    {0x04, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x05, 0x44, 0x02, 0x6d},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0x02, 0x7d},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x02, 0x7d},
    {0x07, 0xc6, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0x46, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x8c, 0x46, 0xb5, 0xff},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0x02, 0x6d},
    {0x04, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x06, 0x44, 0x02, 0x6d},
    {0xc4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x07, 0x8e},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x07, 0x8e},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x47, 0xb5, 0xee},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x47, 0xb5, 0xee},
    {0x06, 0xc1, 0x02, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x02, 0x6d},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x02, 0x6d},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0x02, 0x6d},
    {0x01, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x44, 0x02, 0x6d},
    {0x05, 0xc1, 0x02, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x02, 0x6d},
    {0x04, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x44, 0x02, 0x6d},
    {0xd3, 0x43, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x07, 0x8e},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x07, 0x8e},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x47, 0x8e},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0x47, 0x8e},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0x42, 0x43, 0xdf},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x07, 0x8e},
    {0x03, 0x11, 0x43, 0x07, 0x8e},
    {0x04, 0x83, 0x42, 0x43, 0xdf},
    {0x02, 0x11, 0x43, 0x07, 0x8e},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0x42, 0x03, 0xdf},
    {0x01, 0x81, 0x44, 0x42, 0xce},
    {0x02, 0x84, 0x42, 0x03, 0xdf},
    {0x05, 0x44, 0x03, 0x07, 0x8e},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0x07, 0x8e},
    {0x01, 0x0a, 0x43, 0x47, 0x8e},
    {0x02, 0x01, 0x43, 0x07, 0x8e},
    {0x06, 0x42, 0x03, 0x07, 0x8e},
    {0x03, 0x08, 0x42, 0x02, 0x7d},
    {0x04, 0x0a, 0x43, 0x47, 0x8e},
    {0x02, 0x08, 0x42, 0x02, 0x7d},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x83, 0x44, 0x02, 0xce},
    {0x05, 0x42, 0x03, 0x07, 0x8e},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0x02, 0x7d},
    {0x01, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x0a, 0x42, 0x02, 0x7d},
    {0x06, 0x47, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xf4, 0x47, 0xf5, 0x00, 0x0e},
    {0x03, 0xa8, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0xa8, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0x06, 0x6f},
    {0x04, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0x06, 0x6f},
    {0x09, 0x41, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x45, 0x06, 0x7f},
    {0x01, 0x03, 0x45, 0x46, 0x7f},
    {0x02, 0x0b, 0x45, 0x06, 0x7f},
    {0x05, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0x06, 0x6f},
    {0x04, 0x03, 0x45, 0x46, 0x7f},
    {0x02, 0x05, 0x47, 0x06, 0x6f},
    {0x0a, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x0c, 0x44, 0x06, 0x8f},
    {0x01, 0x0b, 0x44, 0x46, 0x8f},
    {0x02, 0x0c, 0x44, 0x06, 0x8f},
    {0x06, 0x43, 0x04, 0x06, 0x8f},
    {0x03, 0x09, 0x45, 0x06, 0x7f},
    {0x04, 0x0b, 0x44, 0x46, 0x8f},
    {0x02, 0x09, 0x45, 0x06, 0x7f},
    {0x07, 0x4d, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0x02, 0xce},
    {0x01, 0x05, 0x45, 0x46, 0x7f},
    {0x02, 0x9a, 0x42, 0x02, 0xce},
    {0x05, 0x43, 0x04, 0x06, 0x8f},
    {0x03, 0x06, 0x47, 0x06, 0x6f},
    {0x04, 0x05, 0x45, 0x46, 0x7f},
    {0x02, 0x06, 0x47, 0x06, 0x6f},
    {0x4d, 0x02, 0x02, 0xb5, 0xce},
    {0x03, 0x14, 0x42, 0x06, 0x9f},
    {0x01, 0x0c, 0x42, 0x46, 0x9f},
    {0x02, 0x14, 0x42, 0x06, 0x9f},
    {0x06, 0x4b, 0x02, 0x06, 0x9f},
    {0x03, 0x82, 0x4a, 0x02, 0xce},
    {0x04, 0x0c, 0x42, 0x46, 0x9f},
    {0x02, 0x82, 0x4a, 0x02, 0xce},
    {0x08, 0x41, 0x42, 0xb5, 0xce},
    {0x03, 0x18, 0x42, 0x06, 0x9f},
    {0x01, 0x09, 0x44, 0x46, 0x8f},
    {0x02, 0x18, 0x42, 0x06, 0x9f},
    {0x05, 0x4b, 0x02, 0x06, 0x9f},
    {0x03, 0x0e, 0x44, 0x06, 0x8f},
    {0x04, 0x09, 0x44, 0x46, 0x8f},
    {0x02, 0x0e, 0x44, 0x06, 0x8f},
    {0x4f, 0x07, 0x03, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0x06, 0x9f},
    {0x01, 0x9a, 0x47, 0x43, 0xdf},
    {0x02, 0x1c, 0x42, 0x06, 0x9f},
    {0x06, 0x45, 0x04, 0x06, 0x8f},
    {0x03, 0x04, 0x47, 0x06, 0x6f},
    {0x04, 0x9a, 0x47, 0x43, 0xdf},
    {0x02, 0x04, 0x47, 0x06, 0x6f},
    {0x07, 0x43, 0x02, 0x46, 0x9f},
    {0x03, 0x02, 0x47, 0x06, 0x6f},
    {0x01, 0x06, 0x45, 0x46, 0x7f},
    {0x02, 0x02, 0x47, 0x06, 0x6f},
    {0x05, 0x45, 0x04, 0x06, 0x8f},
    {0x03, 0x07, 0x47, 0x06, 0x6f},
    {0x04, 0x06, 0x45, 0x46, 0x7f},
    {0x02, 0x07, 0x47, 0x06, 0x6f},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0x06, 0x9f},
    {0x01, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0x06, 0x9f},
    {0x06, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0x06, 0x9f},
    {0x01, 0x82, 0x42, 0x42, 0xce},
    {0x02, 0x1b, 0x42, 0x06, 0x9f},
    {0x05, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0x06, 0x9f},
    {0x03, 0x10, 0x44, 0x06, 0x8f},
    {0x04, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0x06, 0x8f},
    {0x07, 0x52, 0x02, 0xf5, 0xce},
    {0x03, 0x8e, 0x46, 0xb5, 0xff},
    {0x01, 0x0e, 0x42, 0x46, 0x9f},
    {0x02, 0x8e, 0x46, 0xb5, 0xff},
    {0x05, 0x49, 0x02, 0x06, 0x9f},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0x46, 0x9f},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0x06, 0x9f},
    {0x01, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0x06, 0x9f},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0x06, 0x7f},
    {0x04, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0x06, 0x7f},
    {0x08, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0x46, 0x7f},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0x02, 0xce},
    {0x04, 0x04, 0x45, 0x46, 0x7f},
    {0x02, 0x81, 0x4a, 0x02, 0xce},
    {0x0c, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x45, 0x06, 0x7f},
    {0x01, 0x02, 0x45, 0x46, 0x7f},
    {0x02, 0x0a, 0x45, 0x06, 0x7f},
    {0x06, 0x46, 0x04, 0x06, 0x8f},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0x46, 0x7f},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0x46, 0x9f},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0x46, 0x7f},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0x06, 0x8f},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0x46, 0x7f},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xe4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x07, 0x6d},
    {0x04, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x07, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x07, 0x7d},
    {0x01, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x0b, 0x43, 0x07, 0x7d},
    {0x05, 0x66, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x07, 0x6d},
    {0x04, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x05, 0x41, 0x07, 0x6d},
    {0x0a, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x07, 0x03, 0xdf},
    {0x03, 0x09, 0x43, 0x07, 0x7d},
    {0x04, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x07, 0x7d},
    {0x07, 0x55, 0x02, 0xf5, 0xce},
    {0x03, 0x88, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x88, 0x47, 0xb5, 0xee},
    {0x05, 0xc2, 0x07, 0x03, 0xdf},
    {0x03, 0x06, 0x41, 0x07, 0x6d},
    {0x04, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x06, 0x41, 0x07, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x02, 0xbd},
    {0x04, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x02, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0x46, 0x9f},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0x06, 0x8f},
    {0x04, 0x10, 0x42, 0x46, 0x9f},
    {0x02, 0x0f, 0x44, 0x06, 0x8f},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x07, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x07, 0x6d},
    {0x07, 0x51, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x07, 0x6d},
    {0x01, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x41, 0x07, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x07, 0x6d},
    {0x04, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x41, 0x07, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0x06, 0x8f},
    {0x01, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0x06, 0x8f},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0x46, 0xb5, 0xff},
    {0x03, 0x9b, 0x46, 0xb5, 0xff},
    {0x01, 0x08, 0x44, 0x46, 0x8f},
    {0x02, 0x9b, 0x46, 0xb5, 0xff},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0x46, 0x8f},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0x06, 0x8f},
    {0x03, 0x11, 0x44, 0x06, 0x8f},
    {0x04, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0x06, 0x8f},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0x46, 0xb5, 0xff},
    {0x01, 0x81, 0x42, 0x42, 0xce},
    {0x02, 0x96, 0x46, 0xb5, 0xff},
    {0x05, 0x44, 0x04, 0x06, 0x8f},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x44, 0x06, 0x8f},
    {0x01, 0x0a, 0x44, 0x46, 0x8f},
    {0x02, 0x01, 0x44, 0x06, 0x8f},
    {0x06, 0x42, 0x04, 0x06, 0x8f},
    {0x03, 0x08, 0x43, 0x07, 0x7d},
    {0x04, 0x0a, 0x44, 0x46, 0x8f},
    {0x02, 0x08, 0x43, 0x07, 0x7d},
    {0x08, 0xc1, 0x46, 0xb5, 0xff},
    {0x03, 0x83, 0x42, 0x02, 0xce},
    {0x01, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x83, 0x42, 0x02, 0xce},
    {0x05, 0x42, 0x04, 0x06, 0x8f},
    {0x03, 0x81, 0x44, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x81, 0x44, 0x02, 0xbd},
    {0x0c, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x07, 0x7d},
    {0x01, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x0a, 0x43, 0x07, 0x7d},
    {0x06, 0x47, 0x04, 0x06, 0x8f},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0x46, 0x9f},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0x06, 0x8f},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x47, 0x03, 0xf5, 0xff},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x07, 0x6e},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x07, 0x6e},
    {0x09, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0x07, 0x7e},
    {0x01, 0x03, 0x44, 0x47, 0x7e},
    {0x02, 0x0b, 0x44, 0x07, 0x7e},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x07, 0x6e},
    {0x04, 0x03, 0x44, 0x47, 0x7e},
    {0x02, 0x05, 0x45, 0x07, 0x6e},
    {0x0a, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0x07, 0x8e},
    {0x01, 0x0b, 0x42, 0x47, 0x8e},
    {0x02, 0x0c, 0x42, 0x07, 0x8e},
    {0x06, 0x43, 0x02, 0x07, 0x8e},
    {0x03, 0x09, 0x44, 0x07, 0x7e},
    {0x04, 0x0b, 0x42, 0x47, 0x8e},
    {0x02, 0x09, 0x44, 0x07, 0x7e},
    {0x07, 0x41, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0x47, 0x7e},
    {0x02, 0x9a, 0x47, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0x07, 0x8e},
    {0x03, 0x06, 0x45, 0x07, 0x6e},
    {0x04, 0x05, 0x44, 0x47, 0x7e},
    {0x02, 0x06, 0x45, 0x07, 0x6e},
    {0x4d, 0x07, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x02, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x02, 0xbd},
    {0x08, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x47, 0x8e},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0x07, 0x8e},
    {0x04, 0x09, 0x42, 0x47, 0x8e},
    {0x02, 0x0e, 0x42, 0x07, 0x8e},
    {0x53, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0x46, 0xf5, 0xff},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x45, 0x07, 0x6e},
    {0x04, 0x8a, 0x46, 0xf5, 0xff},
    {0x02, 0x04, 0x45, 0x07, 0x6e},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x07, 0x6e},
    {0x01, 0x06, 0x44, 0x47, 0x7e},
    {0x02, 0x02, 0x45, 0x07, 0x6e},
    {0x05, 0x45, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x45, 0x07, 0x6e},
    {0x04, 0x06, 0x44, 0x47, 0x7e},
    {0x02, 0x07, 0x45, 0x07, 0x6e},
    {0x58, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0x42, 0xce},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x07, 0x8e},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x07, 0x8e},
    {0x07, 0xc3, 0x06, 0xf5, 0xff},
    {0x03, 0x92, 0x46, 0xb5, 0xff},
    {0x01, 0x0f, 0x42, 0x46, 0x9f},
    {0x02, 0x92, 0x46, 0xb5, 0xff},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0x46, 0x9f},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0x06, 0xf5, 0x40, 0xff},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0x46, 0xf5, 0xff},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0x06, 0xb5, 0xff},
    {0x03, 0x08, 0x44, 0x07, 0x7e},
    {0x04, 0x86, 0x46, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x07, 0x7e},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x47, 0x7e},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0x06, 0xb5, 0xff},
    {0x03, 0x81, 0x42, 0x02, 0xbd},
    {0x04, 0x04, 0x44, 0x47, 0x7e},
    {0x02, 0x81, 0x42, 0x02, 0xbd},
    {0x0c, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0x07, 0x7e},
    {0x01, 0x02, 0x44, 0x47, 0x7e},
    {0x02, 0x0a, 0x44, 0x07, 0x7e},
    {0x06, 0x46, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0x47, 0x7e},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0x07, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0x47, 0x7e},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0x47, 0x7e},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xe8, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0x06, 0x9f},
    {0x01, 0x0d, 0x42, 0x46, 0x9f},
    {0x02, 0x16, 0x42, 0x06, 0x9f},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x07, 0x6d},
    {0x04, 0x0d, 0x42, 0x46, 0x9f},
    {0x02, 0x03, 0x44, 0x07, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x07, 0x7d},
    {0x01, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x0b, 0x42, 0x07, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x07, 0x6d},
    {0x04, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x05, 0x44, 0x07, 0x6d},
    {0x0a, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0x06, 0x9f},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0x06, 0x9f},
    {0x06, 0x48, 0x02, 0x06, 0x9f},
    {0x03, 0x09, 0x42, 0x07, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x07, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x8a, 0x47, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0x06, 0x9f},
    {0x03, 0x06, 0x44, 0x07, 0x6d},
    {0x04, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x06, 0x44, 0x07, 0x6d},
    {0x50, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0x07, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x02, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x02, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0x06, 0x9f},
    {0x01, 0x11, 0x42, 0x46, 0x9f},
    {0x02, 0x19, 0x42, 0x06, 0x9f},
    {0x05, 0xc3, 0x07, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x07, 0x8e},
    {0x04, 0x11, 0x42, 0x46, 0x9f},
    {0x02, 0x0f, 0x42, 0x07, 0x8e},
    {0x40, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x47, 0xb5, 0xee},
    {0x01, 0x84, 0x47, 0xf5, 0xee},
    {0x02, 0x86, 0x47, 0xb5, 0xee},
    {0x06, 0xc1, 0x07, 0x03, 0xdf},
    {0x03, 0x04, 0x44, 0x07, 0x6d},
    {0x04, 0x84, 0x47, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x07, 0x6d},
    {0x07, 0x44, 0x02, 0x46, 0x9f},
    {0x03, 0x02, 0x44, 0x07, 0x6d},
    {0x01, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x44, 0x07, 0x6d},
    {0x05, 0xc1, 0x07, 0x03, 0xdf},
    {0x03, 0x07, 0x44, 0x07, 0x6d},
    {0x04, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x44, 0x07, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x07, 0x8e},
    {0x01, 0x01, 0x42, 0x46, 0x9f},
    {0x02, 0x0d, 0x42, 0x07, 0x8e},
    {0x06, 0x4a, 0x02, 0x06, 0x9f},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0x46, 0x9f},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0x06, 0x9f},
    {0x01, 0x08, 0x42, 0x47, 0x8e},
    {0x02, 0x12, 0x42, 0x06, 0x9f},
    {0x05, 0x4a, 0x02, 0x06, 0x9f},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0x47, 0x8e},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0x06, 0x9f},
    {0x01, 0x83, 0x47, 0x43, 0xdf},
    {0x02, 0x15, 0x42, 0x06, 0x9f},
    {0x06, 0x44, 0x02, 0x07, 0x8e},
    {0x03, 0x11, 0x42, 0x07, 0x8e},
    {0x04, 0x83, 0x47, 0x43, 0xdf},
    {0x02, 0x11, 0x42, 0x07, 0x8e},
    {0x07, 0x42, 0x02, 0x46, 0x9f},
    {0x03, 0x84, 0x47, 0x03, 0xdf},
    {0x01, 0x81, 0x47, 0x42, 0xce},
    {0x02, 0x84, 0x47, 0x03, 0xdf},
    {0x05, 0x44, 0x02, 0x07, 0x8e},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x07, 0x8e},
    {0x01, 0x0a, 0x42, 0x47, 0x8e},
    {0x02, 0x01, 0x42, 0x07, 0x8e},
    {0x06, 0x42, 0x02, 0x07, 0x8e},
    {0x03, 0x08, 0x42, 0x07, 0x7d},
    {0x04, 0x0a, 0x42, 0x47, 0x8e},
    {0x02, 0x08, 0x42, 0x07, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x83, 0x47, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0x07, 0x8e},
    {0x03, 0x81, 0x47, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x81, 0x47, 0x02, 0xbd},
    {0x0c, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x07, 0x7d},
    {0x01, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x0a, 0x42, 0x07, 0x7d},
    {0x06, 0x47, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0x46, 0x9f},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0f},
    {0x03, 0xb4, 0xf5, 0x00, 0x0f},
    {0x01, 0xb4, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0f},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf2, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0xf2, 0x00, 0x66},
    {0x09, 0xf2, 0x40, 0x00, 0x06},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf2, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf2, 0x00, 0x66},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0xf5, 0x00, 0x88},
    {0x01, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x0c, 0xf5, 0x00, 0x88},
    {0x06, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0xf2, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0xf2, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf2, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0xf5, 0x00, 0x99},
    {0x01, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x14, 0xf5, 0x00, 0x99},
    {0x06, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0xf2, 0x40, 0x00, 0x06},
    {0x03, 0x18, 0xf5, 0x00, 0x99},
    {0x01, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x18, 0xf5, 0x00, 0x99},
    {0x05, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x0e, 0xf5, 0x00, 0x88},
    {0x04, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x0e, 0xf5, 0x00, 0x88},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0xf5, 0x00, 0x99},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0xf5, 0x00, 0x99},
    {0x06, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0xf2, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf2, 0x00, 0x66},
    {0x07, 0x43, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0xf2, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf2, 0x00, 0x66},
    {0x05, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0xf2, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf2, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0xf5, 0x00, 0x99},
    {0x01, 0x14, 0xf5, 0x40, 0xaa},
    {0x02, 0x17, 0xf5, 0x00, 0x99},
    {0x06, 0x4c, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0xf5, 0x00, 0xaa},
    {0x03, 0x1b, 0xf5, 0x00, 0x99},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0xf5, 0x00, 0x99},
    {0x05, 0x4c, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x27, 0xf5, 0x00, 0xaa},
    {0x01, 0x18, 0xf5, 0x40, 0xaa},
    {0x02, 0x27, 0xf5, 0x00, 0xaa},
    {0x06, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x10, 0xf5, 0x00, 0x88},
    {0x04, 0x18, 0xf5, 0x40, 0xaa},
    {0x02, 0x10, 0xf5, 0x00, 0x88},
    {0x07, 0x4b, 0xb5, 0x40, 0xaa},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0xf5, 0x00, 0x99},
    {0x01, 0x1c, 0xf5, 0x40, 0xaa},
    {0x02, 0x13, 0xf5, 0x00, 0x99},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0xf5, 0x40, 0xaa},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0xf5, 0x00, 0xaa},
    {0x03, 0x37, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0xf5, 0x00, 0xaa},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0x9c, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0x2d, 0xf5, 0x00, 0xaa},
    {0x01, 0x17, 0xf5, 0x40, 0xaa},
    {0x02, 0x2d, 0xf5, 0x00, 0xaa},
    {0x06, 0x54, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0xf5, 0x00, 0xbb},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0xf5, 0x40, 0xbb},
    {0x03, 0x35, 0xf5, 0x00, 0xaa},
    {0x01, 0x1b, 0xf5, 0x40, 0xaa},
    {0x02, 0x35, 0xf5, 0x00, 0xaa},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0xf5, 0x40, 0xaa},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0xb5, 0x40, 0xbb},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0xf5, 0x00, 0xaa},
    {0x01, 0x27, 0xf5, 0x40, 0xbb},
    {0x02, 0x23, 0xf5, 0x00, 0xaa},
    {0x06, 0x58, 0xb5, 0x00, 0xbb},
    {0x03, 0x82, 0x43, 0xb5, 0xbb},
    {0x04, 0x27, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x43, 0xb5, 0xbb},
    {0x08, 0x4b, 0xf5, 0x00, 0xbb},
    {0x03, 0x33, 0xf5, 0x00, 0xaa},
    {0x01, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x33, 0xf5, 0x00, 0xaa},
    {0x05, 0x58, 0xb5, 0x00, 0xbb},
    {0x03, 0x0f, 0xf5, 0x00, 0x88},
    {0x04, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0xf5, 0x00, 0x88},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0xf5, 0x00, 0xaa},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0xf5, 0x00, 0xaa},
    {0x06, 0x4e, 0xb5, 0x00, 0xaa},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0xb5, 0x40, 0xaa},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0xb5, 0x00, 0xaa},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0xf5, 0x00, 0x88},
    {0x01, 0x13, 0xf5, 0x40, 0xaa},
    {0x02, 0x0d, 0xf5, 0x00, 0x88},
    {0x06, 0x5c, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0xf5, 0x00, 0xaa},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0xf5, 0x40, 0xbb},
    {0x03, 0x2b, 0xf5, 0x00, 0xaa},
    {0x01, 0x37, 0xf5, 0x40, 0xbb},
    {0x02, 0x2b, 0xf5, 0x00, 0xaa},
    {0x06, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x11, 0xf5, 0x00, 0x88},
    {0x04, 0x37, 0xf5, 0x40, 0xbb},
    {0x02, 0x11, 0xf5, 0x00, 0x88},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0xf5, 0x00, 0x88},
    {0x01, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x01, 0xf5, 0x00, 0x88},
    {0x06, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x81, 0x43, 0xb5, 0xbb},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0xb5, 0xbb},
    {0x0c, 0x43, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0xf5, 0x00, 0xaa},
    {0x01, 0x2d, 0xf5, 0x40, 0xbb},
    {0x02, 0x1d, 0xf5, 0x00, 0xaa},
    {0x06, 0x57, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x4c, 0xf5, 0x00, 0xcc},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x4b, 0xf5, 0x40, 0xcc},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x54, 0xb5, 0x40, 0xcc},
    {0x03, 0x9a, 0x43, 0xb5, 0xcc},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x43, 0xb5, 0xcc},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x03, 0xb5, 0x00, 0xcc},
    {0x03, 0x21, 0xf5, 0x00, 0xaa},
    {0x01, 0x35, 0xf5, 0x40, 0xbb},
    {0x02, 0x21, 0xf5, 0x00, 0xaa},
    {0x06, 0x5b, 0xb5, 0x00, 0xbb},
    {0x03, 0x82, 0x4b, 0xb5, 0xcc},
    {0x04, 0x35, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x4b, 0xb5, 0xcc},
    {0x08, 0x4c, 0xf5, 0x00, 0xcc},
    {0x03, 0x31, 0xf5, 0x00, 0xaa},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0xf5, 0x00, 0xaa},
    {0x05, 0x5b, 0xb5, 0x00, 0xbb},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0x82, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0xf5, 0x00, 0xaa},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0xf5, 0x00, 0xaa},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0xf5, 0x00, 0xaa},
    {0x01, 0x23, 0xf5, 0x40, 0xbb},
    {0x02, 0x2f, 0xf5, 0x00, 0xaa},
    {0x06, 0x67, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0xf5, 0x00, 0xbb},
    {0x03, 0x3b, 0xf5, 0x00, 0xaa},
    {0x01, 0x82, 0x43, 0xf5, 0xcc},
    {0x02, 0x3b, 0xf5, 0x00, 0xaa},
    {0x05, 0x67, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0xf5, 0x40, 0xcc},
    {0x03, 0x29, 0xf5, 0x00, 0xaa},
    {0x01, 0x33, 0xf5, 0x40, 0xbb},
    {0x02, 0x29, 0xf5, 0x00, 0xaa},
    {0x06, 0x50, 0xb5, 0x00, 0xaa},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0xf5, 0x40, 0xbb},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x58, 0xb5, 0x40, 0xcc},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0xb5, 0x00, 0xaa},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0xf5, 0x00, 0xaa},
    {0x01, 0x3f, 0xf5, 0x40, 0xbb},
    {0x02, 0x1f, 0xf5, 0x00, 0xaa},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0xf5, 0x40, 0xbb},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0xf5, 0x00, 0xbb},
    {0x03, 0x39, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0xf5, 0x00, 0xaa},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0xb5, 0xcc},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x4b, 0xb5, 0xcc},
    {0x0c, 0x4b, 0xf5, 0x40, 0xcc},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0xb5, 0x40, 0xbb},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0x9d, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0x16, 0xf5, 0x00, 0x99},
    {0x01, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x16, 0xf5, 0x00, 0x99},
    {0x06, 0x53, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0xf5, 0x40, 0xbb},
    {0x03, 0x1a, 0xf5, 0x00, 0x99},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0xf5, 0x00, 0x99},
    {0x06, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x5c, 0xb5, 0x40, 0xcc},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0xf5, 0x00, 0xaa},
    {0x01, 0x2b, 0xf5, 0x40, 0xbb},
    {0x02, 0x25, 0xf5, 0x00, 0xaa},
    {0x06, 0x77, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x45, 0xb5, 0xbb},
    {0x04, 0x2b, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x45, 0xb5, 0xbb},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0xf5, 0x00, 0x99},
    {0x01, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x19, 0xf5, 0x00, 0x99},
    {0x05, 0x77, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0xf5, 0x00, 0xaa},
    {0x03, 0x12, 0xf5, 0x00, 0x99},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0xf5, 0x00, 0x99},
    {0x05, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0xf5, 0x40, 0xbb},
    {0x03, 0x15, 0xf5, 0x00, 0x99},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0xf5, 0x00, 0x99},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0xb5, 0x40, 0x99},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x43, 0xf5, 0xcc},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0x43, 0xb5, 0xcc},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x43, 0xb5, 0xcc},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0xb5, 0xbb},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0xb5, 0xbb},
    {0x0c, 0x45, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x9c, 0xf5, 0x00, 0x0d},
    {0x01, 0x1d, 0xf5, 0x40, 0xbb},
    {0x02, 0x9c, 0xf5, 0x00, 0x0d},
    {0x06, 0x6d, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x54, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6d, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x4c, 0xf5, 0x40, 0xdd},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x57, 0xb5, 0x40, 0xcc},
    {0x03, 0x9a, 0x4b, 0xb5, 0xdd},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0x4b, 0xb5, 0xdd},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0x0b, 0xb5, 0x00, 0xdd},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x4c, 0xb5, 0xdd},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x4c, 0xb5, 0xdd},
    {0x08, 0x54, 0xf5, 0x00, 0xdd},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x03, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x43, 0xf5, 0xdd},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0x43, 0xf5, 0xdd},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0xf5, 0x40, 0xbb},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x75, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x0b, 0x6d},
    {0x04, 0x21, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x0b, 0x6d},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0x4b, 0xf5, 0xdd},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x75, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x0b, 0x6d},
    {0x04, 0x82, 0x4b, 0xf5, 0xdd},
    {0x02, 0x05, 0x43, 0x0b, 0x6d},
    {0x0b, 0x4c, 0xf5, 0x40, 0xdd},
    {0x03, 0x28, 0xf5, 0x00, 0xaa},
    {0x01, 0x31, 0xf5, 0x40, 0xbb},
    {0x02, 0x28, 0xf5, 0x00, 0xaa},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0xf5, 0x40, 0xbb},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x5b, 0xb5, 0x40, 0xcc},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x0b, 0x6d},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x0b, 0x6d},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0xf5, 0x40, 0xbb},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0xf5, 0x40, 0xbb},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0xf5, 0x00, 0xaa},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4c, 0xb5, 0xdd},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x4c, 0xb5, 0xdd},
    {0x0c, 0x4c, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x0b, 0x6d},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x0b, 0x6d},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x0b, 0x6d},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x0b, 0x6d},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x0b, 0x6d},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x0b, 0x6d},
    {0xa1, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2e, 0xf5, 0x00, 0xaa},
    {0x01, 0x2f, 0xf5, 0x40, 0xbb},
    {0x02, 0x2e, 0xf5, 0x00, 0xaa},
    {0x06, 0x63, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0x03, 0x6d},
    {0x04, 0x2f, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x41, 0x03, 0x6d},
    {0x09, 0x58, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x43, 0x03, 0x7d},
    {0x01, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x0b, 0x43, 0x03, 0x7d},
    {0x05, 0x63, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0x03, 0x6d},
    {0x04, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x05, 0x41, 0x03, 0x6d},
    {0x0a, 0x49, 0xf5, 0x40, 0xcc},
    {0x03, 0x36, 0xf5, 0x00, 0xaa},
    {0x01, 0x3b, 0xf5, 0x40, 0xbb},
    {0x02, 0x36, 0xf5, 0x00, 0xaa},
    {0x06, 0xc2, 0x03, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x03, 0x7d},
    {0x04, 0x3b, 0xf5, 0x40, 0xbb},
    {0x02, 0x09, 0x43, 0x03, 0x7d},
    {0x07, 0x67, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x03, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x03, 0x6d},
    {0x04, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x06, 0x41, 0x03, 0x6d},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0xf5, 0x00, 0xaa},
    {0x01, 0x29, 0xf5, 0x40, 0xbb},
    {0x02, 0x24, 0xf5, 0x00, 0xaa},
    {0x06, 0x73, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x49, 0xb5, 0xcc},
    {0x04, 0x29, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x49, 0xb5, 0xcc},
    {0x08, 0x58, 0xf5, 0x00, 0xdd},
    {0x03, 0x34, 0xf5, 0x00, 0xaa},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0xf5, 0x00, 0xaa},
    {0x05, 0x73, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0xf5, 0x00, 0xaa},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0xf5, 0x00, 0xaa},
    {0x06, 0x4f, 0xb5, 0x00, 0xaa},
    {0x03, 0x04, 0x41, 0x03, 0x6d},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x03, 0x6d},
    {0x07, 0x50, 0xb5, 0x40, 0xbb},
    {0x03, 0x02, 0x41, 0x03, 0x6d},
    {0x01, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x41, 0x03, 0x6d},
    {0x05, 0x4f, 0xb5, 0x00, 0xaa},
    {0x03, 0x07, 0x41, 0x03, 0x6d},
    {0x04, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x41, 0x03, 0x6d},
    {0x86, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0xf5, 0x40, 0xbb},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x7f, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x42, 0x0b, 0x6d},
    {0x04, 0x1f, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x42, 0x0b, 0x6d},
    {0x09, 0x4e, 0xf5, 0x00, 0xcc},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x7f, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x42, 0x0b, 0x6d},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x0b, 0x6d},
    {0x0b, 0x49, 0xf5, 0x40, 0xcc},
    {0x03, 0x2c, 0xf5, 0x00, 0xaa},
    {0x01, 0x39, 0xf5, 0x40, 0xbb},
    {0x02, 0x2c, 0xf5, 0x00, 0xaa},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0xf5, 0x40, 0xbb},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xc9, 0xb5, 0x40, 0x0d},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4b, 0xf5, 0xdd},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x0b, 0x6d},
    {0x04, 0x81, 0x4b, 0xf5, 0xdd},
    {0x02, 0x06, 0x42, 0x0b, 0x6d},
    {0x4e, 0x0b, 0xb5, 0x00, 0xdd},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x03, 0x7d},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x03, 0x7d},
    {0x08, 0x4e, 0xf5, 0x00, 0xcc},
    {0x03, 0x83, 0x4b, 0xb5, 0xdd},
    {0x01, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x83, 0x4b, 0xb5, 0xdd},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x49, 0xb5, 0xcc},
    {0x04, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x81, 0x49, 0xb5, 0xcc},
    {0x0c, 0x49, 0xf5, 0x40, 0xcc},
    {0x03, 0x0a, 0x43, 0x03, 0x7d},
    {0x01, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x0a, 0x43, 0x03, 0x7d},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x0b, 0x6d},
    {0x04, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x0b, 0x6d},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x0b, 0x6d},
    {0x01, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x0b, 0x6d},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x0b, 0x6d},
    {0x04, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x0b, 0x6d},
    {0xf4, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x1e, 0xf5, 0x00, 0xaa},
    {0x01, 0x16, 0xf5, 0x40, 0xaa},
    {0x02, 0x1e, 0xf5, 0x00, 0xaa},
    {0x06, 0x4d, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0xf5, 0x40, 0xaa},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x5c, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x53, 0xb5, 0x40, 0xcc},
    {0x03, 0x9a, 0x45, 0xb5, 0xcc},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x45, 0xb5, 0xcc},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x05, 0xb5, 0x00, 0xcc},
    {0x03, 0x22, 0xf5, 0x00, 0xaa},
    {0x01, 0x1a, 0xf5, 0x40, 0xaa},
    {0x02, 0x22, 0xf5, 0x00, 0xaa},
    {0x06, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xda, 0xb5, 0x0d},
    {0x04, 0x1a, 0xf5, 0x40, 0xaa},
    {0x02, 0x82, 0xda, 0xb5, 0x0d},
    {0x08, 0x5c, 0xf5, 0x00, 0xdd},
    {0x03, 0x32, 0xf5, 0x00, 0xaa},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0xf5, 0x00, 0xaa},
    {0x05, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0xf5, 0x00, 0xaa},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0xf5, 0x00, 0xaa},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0xb5, 0x40, 0xaa},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0xf5, 0x00, 0xaa},
    {0x01, 0x25, 0xf5, 0x40, 0xbb},
    {0x02, 0x30, 0xf5, 0x00, 0xaa},
    {0x06, 0x6b, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0xf5, 0x00, 0xaa},
    {0x03, 0x3c, 0xf5, 0x00, 0xaa},
    {0x01, 0x82, 0x45, 0xf5, 0xcc},
    {0x02, 0x3c, 0xf5, 0x00, 0xaa},
    {0x05, 0x6b, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x2a, 0xf5, 0x00, 0xaa},
    {0x01, 0x19, 0xf5, 0x40, 0xaa},
    {0x02, 0x2a, 0xf5, 0x00, 0xaa},
    {0x06, 0x51, 0xb5, 0x00, 0xaa},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0xf5, 0x40, 0xaa},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x77, 0xb5, 0x40, 0xdd},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0xb5, 0x00, 0xaa},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0xf5, 0x00, 0xaa},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0xf5, 0x00, 0xaa},
    {0x06, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0xf5, 0x00, 0xaa},
    {0x03, 0x3a, 0xf5, 0x00, 0xaa},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0xf5, 0x00, 0xaa},
    {0x05, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xda, 0xb5, 0x0d},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xda, 0xb5, 0x0d},
    {0x0c, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xa5, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0xb5, 0x00, 0xaa},
    {0x03, 0x03, 0x44, 0x03, 0x6d},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x03, 0x6d},
    {0x09, 0x42, 0xf5, 0x00, 0xaa},
    {0x03, 0x0b, 0x42, 0x03, 0x7d},
    {0x01, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x0b, 0x42, 0x03, 0x7d},
    {0x05, 0x41, 0xb5, 0x00, 0xaa},
    {0x03, 0x05, 0x44, 0x03, 0x6d},
    {0x04, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x05, 0x44, 0x03, 0x6d},
    {0x0a, 0x46, 0xf5, 0x40, 0xbb},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0xf5, 0x40, 0xaa},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x03, 0x7d},
    {0x04, 0x12, 0xf5, 0x40, 0xaa},
    {0x02, 0x09, 0x42, 0x03, 0x7d},
    {0x07, 0x4a, 0xb5, 0x40, 0xaa},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x03, 0x6d},
    {0x04, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x06, 0x44, 0x03, 0x6d},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0xf5, 0x00, 0xaa},
    {0x01, 0x15, 0xf5, 0x40, 0xaa},
    {0x02, 0x26, 0xf5, 0x00, 0xaa},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0xb5, 0xbb},
    {0x04, 0x15, 0xf5, 0x40, 0xaa},
    {0x02, 0x82, 0x46, 0xb5, 0xbb},
    {0x08, 0x42, 0xf5, 0x00, 0xaa},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x03, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x03, 0x6d},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x03, 0x6d},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x03, 0x6d},
    {0x01, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x44, 0x03, 0x6d},
    {0x05, 0xc1, 0x03, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x03, 0x6d},
    {0x04, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x44, 0x03, 0x6d},
    {0x81, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0xf5, 0x00, 0xaa},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0xf5, 0x40, 0xbb},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x43, 0xf5, 0xdd},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x43, 0xf5, 0xdd},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x43, 0xb5, 0xdd},
    {0x01, 0x81, 0x45, 0xf5, 0xcc},
    {0x02, 0x84, 0x43, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x03, 0x7d},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x03, 0x7d},
    {0x08, 0x47, 0xf5, 0x00, 0xaa},
    {0x03, 0x83, 0x45, 0xb5, 0xcc},
    {0x01, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x83, 0x45, 0xb5, 0xcc},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0xb5, 0xbb},
    {0x04, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x81, 0x46, 0xb5, 0xbb},
    {0x0c, 0x46, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x42, 0x03, 0x7d},
    {0x01, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x0a, 0x42, 0x03, 0x7d},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0x9c, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5d, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x4a, 0xb5, 0x6d},
    {0x04, 0x9c, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0x4a, 0xb5, 0x6d},
    {0x09, 0x57, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x49, 0xb5, 0x7d},
    {0x01, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x0b, 0x49, 0xb5, 0x7d},
    {0x05, 0x5d, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x4a, 0xb5, 0x6d},
    {0x04, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x05, 0x4a, 0xb5, 0x6d},
    {0x0a, 0x54, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x49, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x49, 0xb5, 0x7d},
    {0x07, 0x6d, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x4c, 0xb5, 0xee},
    {0x01, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x9a, 0x4c, 0xb5, 0xee},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4a, 0xb5, 0x6d},
    {0x04, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x06, 0x4a, 0xb5, 0x6d},
    {0x4d, 0x0c, 0xb5, 0x00, 0xee},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x54, 0xb5, 0xee},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x54, 0xb5, 0xee},
    {0x08, 0x57, 0xf5, 0x00, 0xdd},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0x0b, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0x4b, 0xf5, 0xee},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4a, 0xb5, 0x6d},
    {0x04, 0x9a, 0x4b, 0xf5, 0xee},
    {0x02, 0x04, 0x4a, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4a, 0xb5, 0x6d},
    {0x01, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x4a, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4a, 0xb5, 0x6d},
    {0x04, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x4a, 0xb5, 0x6d},
    {0x52, 0x03, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x0c, 0x6e},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x0c, 0x6e},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0x4c, 0xf5, 0xee},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x0c, 0x6e},
    {0x04, 0x82, 0x4c, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0c, 0x6e},
    {0x0b, 0x54, 0xf5, 0x40, 0xee},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0x43, 0xb5, 0xee},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0x43, 0xb5, 0xee},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x0c, 0x6e},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x0c, 0x6e},
    {0x51, 0x03, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0x03, 0xb5, 0xee},
    {0x03, 0x08, 0x49, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x49, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0x03, 0xb5, 0xee},
    {0x03, 0x81, 0x54, 0xb5, 0xee},
    {0x04, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x81, 0x54, 0xb5, 0xee},
    {0x0c, 0x54, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x49, 0xb5, 0x7d},
    {0x01, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x0a, 0x49, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x0c, 0x6e},
    {0x04, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0x0c, 0x6e},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x0c, 0x6e},
    {0x01, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0x0c, 0x6e},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x0c, 0x6e},
    {0x04, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0x0c, 0x6e},
    {0x9f, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0x0b, 0x6e},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0x0b, 0x6e},
    {0x09, 0x5b, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x43, 0x0b, 0x7e},
    {0x01, 0x03, 0x43, 0x4b, 0x7e},
    {0x02, 0x0b, 0x43, 0x0b, 0x7e},
    {0x05, 0x61, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0x0b, 0x6e},
    {0x04, 0x03, 0x43, 0x4b, 0x7e},
    {0x02, 0x05, 0x41, 0x0b, 0x6e},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x0b, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x0b, 0x7e},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0x0b, 0x7e},
    {0x07, 0x75, 0xb5, 0x40, 0xdd},
    {0x03, 0x87, 0x43, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x4b, 0x7e},
    {0x02, 0x87, 0x43, 0xb5, 0xee},
    {0x05, 0xc2, 0x0b, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x0b, 0x6e},
    {0x04, 0x05, 0x43, 0x4b, 0x7e},
    {0x02, 0x06, 0x41, 0x0b, 0x6e},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0xf5, 0x40, 0xbb},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x5b, 0xf5, 0x00, 0xdd},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x0b, 0x6e},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x0b, 0x6e},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0x0b, 0x6e},
    {0x01, 0x06, 0x43, 0x4b, 0x7e},
    {0x02, 0x02, 0x41, 0x0b, 0x6e},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x0b, 0x6e},
    {0x04, 0x06, 0x43, 0x4b, 0x7e},
    {0x02, 0x07, 0x41, 0x0b, 0x6e},
    {0x9a, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x42, 0x0c, 0x6e},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x0c, 0x6e},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7d, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x42, 0x0c, 0x6e},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x0c, 0x6e},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0xf5, 0x40, 0xbb},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0xf5, 0x40, 0xbb},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc7, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4c, 0xf5, 0xee},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x0c, 0x6e},
    {0x04, 0x81, 0x4c, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0c, 0x6e},
    {0x4e, 0x0c, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0x0b, 0x7e},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0x0b, 0x7e},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x4c, 0xb5, 0xee},
    {0x01, 0x04, 0x43, 0x4b, 0x7e},
    {0x02, 0x83, 0x4c, 0xb5, 0xee},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0x4b, 0x7e},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0x0b, 0x7e},
    {0x01, 0x02, 0x43, 0x4b, 0x7e},
    {0x02, 0x0a, 0x43, 0x0b, 0x7e},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x0c, 0x6e},
    {0x04, 0x02, 0x43, 0x4b, 0x7e},
    {0x02, 0x04, 0x42, 0x0c, 0x6e},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x0c, 0x6e},
    {0x01, 0x07, 0x43, 0x4b, 0x7e},
    {0x02, 0x02, 0x42, 0x0c, 0x6e},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x0c, 0x6e},
    {0x04, 0x07, 0x43, 0x4b, 0x7e},
    {0x02, 0x07, 0x42, 0x0c, 0x6e},
    {0xf4, 0x4b, 0xf5, 0x00, 0x0e},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0xf5, 0x40, 0xbb},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x46, 0x03, 0x6e},
    {0x04, 0x2e, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x46, 0x03, 0x6e},
    {0x09, 0x67, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x03, 0x7e},
    {0x01, 0x03, 0x41, 0x43, 0x7e},
    {0x02, 0x0b, 0x41, 0x03, 0x7e},
    {0x05, 0x6f, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x46, 0x03, 0x6e},
    {0x04, 0x03, 0x41, 0x43, 0x7e},
    {0x02, 0x05, 0x46, 0x03, 0x6e},
    {0x0a, 0x58, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0x03, 0x8e},
    {0x01, 0x0b, 0x43, 0x43, 0x8e},
    {0x02, 0x0c, 0x43, 0x03, 0x8e},
    {0x06, 0x43, 0x03, 0x03, 0x8e},
    {0x03, 0x09, 0x41, 0x03, 0x7e},
    {0x04, 0x0b, 0x43, 0x43, 0x8e},
    {0x02, 0x09, 0x41, 0x03, 0x7e},
    {0x07, 0x63, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x49, 0xb5, 0xdd},
    {0x01, 0x05, 0x41, 0x43, 0x7e},
    {0x02, 0x9a, 0x49, 0xb5, 0xdd},
    {0x05, 0x43, 0x03, 0x03, 0x8e},
    {0x03, 0x06, 0x46, 0x03, 0x6e},
    {0x04, 0x05, 0x41, 0x43, 0x7e},
    {0x02, 0x06, 0x46, 0x03, 0x6e},
    {0x4d, 0x09, 0xb5, 0x00, 0xdd},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0xf5, 0x40, 0xbb},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x58, 0xb5, 0xee},
    {0x04, 0x36, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x58, 0xb5, 0xee},
    {0x08, 0x67, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x43, 0x8e},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0xb5, 0x00, 0xcc},
    {0x03, 0x0e, 0x43, 0x03, 0x8e},
    {0x04, 0x09, 0x43, 0x43, 0x8e},
    {0x02, 0x0e, 0x43, 0x03, 0x8e},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x03, 0x8e},
    {0x03, 0x04, 0x46, 0x03, 0x6e},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x03, 0x6e},
    {0x07, 0xc2, 0x03, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x03, 0x6e},
    {0x01, 0x06, 0x41, 0x43, 0x7e},
    {0x02, 0x02, 0x46, 0x03, 0x6e},
    {0x05, 0x45, 0x03, 0x03, 0x8e},
    {0x03, 0x07, 0x46, 0x03, 0x6e},
    {0x04, 0x06, 0x41, 0x43, 0x7e},
    {0x02, 0x07, 0x46, 0x03, 0x6e},
    {0x96, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0xf5, 0x40, 0xbb},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x09, 0x6d},
    {0x04, 0x24, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x09, 0x6d},
    {0x09, 0x50, 0xf5, 0x00, 0xcc},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x49, 0xf5, 0xdd},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x09, 0x6d},
    {0x04, 0x82, 0x49, 0xf5, 0xdd},
    {0x02, 0x05, 0x43, 0x09, 0x6d},
    {0x0b, 0x58, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0xf5, 0x40, 0xbb},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x03, 0x8e},
    {0x04, 0x34, 0xf5, 0x40, 0xbb},
    {0x02, 0x10, 0x43, 0x03, 0x8e},
    {0x07, 0x73, 0xb5, 0x40, 0xdd},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x09, 0x6d},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x09, 0x6d},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0xf5, 0x40, 0xbb},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x03, 0x7e},
    {0x04, 0x00, 0xf5, 0x40, 0xbb},
    {0x02, 0x08, 0x41, 0x03, 0x7e},
    {0x08, 0x50, 0xf5, 0x00, 0xcc},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x43, 0x7e},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x58, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0x43, 0x7e},
    {0x02, 0x81, 0x58, 0xb5, 0xee},
    {0x0c, 0x58, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0x03, 0x7e},
    {0x01, 0x02, 0x41, 0x43, 0x7e},
    {0x02, 0x0a, 0x41, 0x03, 0x7e},
    {0x06, 0x46, 0x03, 0x03, 0x8e},
    {0x03, 0x04, 0x43, 0x09, 0x6d},
    {0x04, 0x02, 0x41, 0x43, 0x7e},
    {0x02, 0x04, 0x43, 0x09, 0x6d},
    {0x07, 0x4f, 0xb5, 0x40, 0xbb},
    {0x03, 0x02, 0x43, 0x09, 0x6d},
    {0x01, 0x07, 0x41, 0x43, 0x7e},
    {0x02, 0x02, 0x43, 0x09, 0x6d},
    {0x05, 0x46, 0x03, 0x03, 0x8e},
    {0x03, 0x07, 0x43, 0x09, 0x6d},
    {0x04, 0x07, 0x41, 0x43, 0x7e},
    {0x02, 0x07, 0x43, 0x09, 0x6d},
    {0x9e, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x44, 0x0b, 0x6e},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0x0b, 0x6e},
    {0x09, 0xc9, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0x0b, 0x7e},
    {0x01, 0x03, 0x42, 0x4b, 0x7e},
    {0x02, 0x0b, 0x42, 0x0b, 0x7e},
    {0x05, 0x5f, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x44, 0x0b, 0x6e},
    {0x04, 0x03, 0x42, 0x4b, 0x7e},
    {0x02, 0x05, 0x44, 0x0b, 0x6e},
    {0x0a, 0x4e, 0xf5, 0x40, 0xdd},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0x0b, 0x7e},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x0b, 0x7e},
    {0x07, 0x7f, 0xb5, 0x40, 0xdd},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0x4b, 0x7e},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0x0b, 0x6e},
    {0x04, 0x05, 0x42, 0x4b, 0x7e},
    {0x02, 0x06, 0x44, 0x0b, 0x6e},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0xf5, 0x40, 0xbb},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x4e, 0xb5, 0xdd},
    {0x04, 0x2c, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x4e, 0xb5, 0xdd},
    {0x08, 0xc9, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x43, 0x03, 0x8e},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x03, 0x8e},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x43, 0xb5, 0xee},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x43, 0xb5, 0xee},
    {0x06, 0xc1, 0x0b, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x0b, 0x6e},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x0b, 0x6e},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0x0b, 0x6e},
    {0x01, 0x06, 0x42, 0x4b, 0x7e},
    {0x02, 0x02, 0x44, 0x0b, 0x6e},
    {0x05, 0xc1, 0x0b, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x0b, 0x6e},
    {0x04, 0x06, 0x42, 0x4b, 0x7e},
    {0x02, 0x07, 0x44, 0x0b, 0x6e},
    {0x90, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0x03, 0x8e},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x03, 0x8e},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x09, 0x6d},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x09, 0x6d},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x43, 0x8e},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x09, 0x6d},
    {0x04, 0x08, 0x43, 0x43, 0x8e},
    {0x02, 0x05, 0x42, 0x09, 0x6d},
    {0x0b, 0x4e, 0xf5, 0x40, 0xdd},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0x4b, 0xf5, 0xee},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x03, 0x8e},
    {0x03, 0x11, 0x43, 0x03, 0x8e},
    {0x04, 0x83, 0x4b, 0xf5, 0xee},
    {0x02, 0x11, 0x43, 0x03, 0x8e},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0x4b, 0xb5, 0xee},
    {0x01, 0x81, 0x49, 0xf5, 0xdd},
    {0x02, 0x84, 0x4b, 0xb5, 0xee},
    {0x05, 0x44, 0x03, 0x03, 0x8e},
    {0x03, 0x06, 0x42, 0x09, 0x6d},
    {0x04, 0x81, 0x49, 0xf5, 0xdd},
    {0x02, 0x06, 0x42, 0x09, 0x6d},
    {0x4e, 0x09, 0xb5, 0x00, 0xdd},
    {0x03, 0x01, 0x43, 0x03, 0x8e},
    {0x01, 0x0a, 0x43, 0x43, 0x8e},
    {0x02, 0x01, 0x43, 0x03, 0x8e},
    {0x06, 0x42, 0x03, 0x03, 0x8e},
    {0x03, 0x08, 0x42, 0x0b, 0x7e},
    {0x04, 0x0a, 0x43, 0x43, 0x8e},
    {0x02, 0x08, 0x42, 0x0b, 0x7e},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x49, 0xb5, 0xdd},
    {0x01, 0x04, 0x42, 0x4b, 0x7e},
    {0x02, 0x83, 0x49, 0xb5, 0xdd},
    {0x05, 0x42, 0x03, 0x03, 0x8e},
    {0x03, 0x81, 0x4e, 0xb5, 0xdd},
    {0x04, 0x04, 0x42, 0x4b, 0x7e},
    {0x02, 0x81, 0x4e, 0xb5, 0xdd},
    {0x0c, 0x4e, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x42, 0x0b, 0x7e},
    {0x01, 0x02, 0x42, 0x4b, 0x7e},
    {0x02, 0x0a, 0x42, 0x0b, 0x7e},
    {0x06, 0x47, 0x03, 0x03, 0x8e},
    {0x03, 0x04, 0x42, 0x09, 0x6d},
    {0x04, 0x02, 0x42, 0x4b, 0x7e},
    {0x02, 0x04, 0x42, 0x09, 0x6d},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x09, 0x6d},
    {0x01, 0x07, 0x42, 0x4b, 0x7e},
    {0x02, 0x02, 0x42, 0x09, 0x6d},
    {0x05, 0x47, 0x03, 0x03, 0x8e},
    {0x03, 0x07, 0x42, 0x09, 0x6d},
    {0x04, 0x07, 0x42, 0x4b, 0x7e},
    {0x02, 0x07, 0x42, 0x09, 0x6d},
    {0xf4, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x9d, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0xf5, 0x40, 0xbb},
    {0x02, 0x9d, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x53, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x5c, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0xb5, 0x40, 0xbb},
    {0x03, 0x9a, 0xda, 0xb5, 0x0e},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0xda, 0xb5, 0x0e},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0x9a, 0xb5, 0x00, 0x0e},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x5c, 0xb5, 0xee},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x5c, 0xb5, 0xee},
    {0x08, 0x53, 0xf5, 0x00, 0xdd},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x05, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x45, 0xf5, 0xdd},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x45, 0xf5, 0xdd},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0x8c, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0xf5, 0x40, 0xbb},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x43, 0x9a, 0x6e},
    {0x04, 0x22, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x9a, 0x6e},
    {0x09, 0x48, 0xf5, 0x00, 0xbb},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0xda, 0xf5, 0x0e},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x43, 0x9a, 0x6e},
    {0x04, 0x82, 0xda, 0xf5, 0x0e},
    {0x02, 0x05, 0x43, 0x9a, 0x6e},
    {0x0b, 0x5c, 0xf5, 0x40, 0xee},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0xf5, 0x40, 0xbb},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0xf5, 0x40, 0xbb},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0xd7, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x9a, 0x6e},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x9a, 0x6e},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0xf5, 0x40, 0xbb},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0xf5, 0x40, 0xbb},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0xf5, 0x00, 0xbb},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x5c, 0xb5, 0xee},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x5c, 0xb5, 0xee},
    {0x0c, 0x5c, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x9a, 0x6e},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x9a, 0x6e},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x9a, 0x6e},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x9a, 0x6e},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x9a, 0x6e},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x9a, 0x6e},
    {0xa3, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0xf5, 0x40, 0xbb},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0x05, 0x6d},
    {0x04, 0x30, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x41, 0x05, 0x6d},
    {0x09, 0x77, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x05, 0x7d},
    {0x01, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x0b, 0x43, 0x05, 0x7d},
    {0x05, 0x65, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0x05, 0x6d},
    {0x04, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x05, 0x41, 0x05, 0x6d},
    {0x0a, 0x44, 0xf5, 0x40, 0xbb},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0xf5, 0x40, 0xbb},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x05, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x05, 0x7d},
    {0x04, 0x3c, 0xf5, 0x40, 0xbb},
    {0x02, 0x09, 0x43, 0x05, 0x7d},
    {0x07, 0x6b, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0x43, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x88, 0x43, 0xb5, 0xee},
    {0x05, 0xc2, 0x05, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x05, 0x6d},
    {0x04, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x06, 0x41, 0x05, 0x6d},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0xf5, 0x40, 0xbb},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0xb5, 0x00, 0xbb},
    {0x03, 0x82, 0x44, 0xb5, 0xbb},
    {0x04, 0x2a, 0xf5, 0x40, 0xbb},
    {0x02, 0x82, 0x44, 0xb5, 0xbb},
    {0x08, 0x77, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0xb5, 0x00, 0xbb},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x05, 0x6d},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x05, 0x6d},
    {0x07, 0x51, 0xb5, 0x40, 0xbb},
    {0x03, 0x02, 0x41, 0x05, 0x6d},
    {0x01, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x41, 0x05, 0x6d},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x05, 0x6d},
    {0x04, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x41, 0x05, 0x6d},
    {0x88, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0xf5, 0x40, 0xbb},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x9a, 0x6e},
    {0x04, 0x20, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x42, 0x9a, 0x6e},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x9a, 0x6e},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x9a, 0x6e},
    {0x0b, 0x44, 0xf5, 0x40, 0xbb},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0xf5, 0x40, 0xbb},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0xf5, 0x40, 0xbb},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xd3, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xda, 0xf5, 0x0e},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x9a, 0x6e},
    {0x04, 0x81, 0xda, 0xf5, 0x0e},
    {0x02, 0x06, 0x42, 0x9a, 0x6e},
    {0x4e, 0x9a, 0xb5, 0x00, 0x0e},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x05, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x05, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0xda, 0xb5, 0x0e},
    {0x01, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x83, 0xda, 0xb5, 0x0e},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0xb5, 0xbb},
    {0x04, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x81, 0x44, 0xb5, 0xbb},
    {0x0c, 0x44, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x43, 0x05, 0x7d},
    {0x01, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x0a, 0x43, 0x05, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x9a, 0x6e},
    {0x04, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0x9a, 0x6e},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x9a, 0x6e},
    {0x01, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0x9a, 0x6e},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x9a, 0x6e},
    {0x04, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0x9a, 0x6e},
    {0xf4, 0x45, 0xb5, 0x40, 0x0d},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x03, 0x6e},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x03, 0x6e},
    {0x09, 0x4a, 0xf5, 0x00, 0xbb},
    {0x03, 0x0b, 0x44, 0x03, 0x7e},
    {0x01, 0x03, 0x44, 0x43, 0x7e},
    {0x02, 0x0b, 0x44, 0x03, 0x7e},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x03, 0x6e},
    {0x04, 0x03, 0x44, 0x43, 0x7e},
    {0x02, 0x05, 0x45, 0x03, 0x6e},
    {0x0a, 0x42, 0xf5, 0x40, 0xbb},
    {0x03, 0x0c, 0x42, 0x03, 0x8e},
    {0x01, 0x0b, 0x42, 0x43, 0x8e},
    {0x02, 0x0c, 0x42, 0x03, 0x8e},
    {0x06, 0x43, 0x02, 0x03, 0x8e},
    {0x03, 0x09, 0x44, 0x03, 0x7e},
    {0x04, 0x0b, 0x42, 0x43, 0x8e},
    {0x02, 0x09, 0x44, 0x03, 0x7e},
    {0x07, 0x41, 0xb5, 0x40, 0xbb},
    {0x03, 0x9a, 0x46, 0xb5, 0xcc},
    {0x01, 0x05, 0x44, 0x43, 0x7e},
    {0x02, 0x9a, 0x46, 0xb5, 0xcc},
    {0x05, 0x43, 0x02, 0x03, 0x8e},
    {0x03, 0x06, 0x45, 0x03, 0x6e},
    {0x04, 0x05, 0x44, 0x43, 0x7e},
    {0x02, 0x06, 0x45, 0x03, 0x6e},
    {0x4d, 0x06, 0xb5, 0x00, 0xcc},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0xb5, 0x00, 0xbb},
    {0x03, 0x82, 0x42, 0xb5, 0xbb},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0xb5, 0xbb},
    {0x08, 0x4a, 0xf5, 0x00, 0xbb},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x43, 0x8e},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0xb5, 0x00, 0xbb},
    {0x03, 0x0e, 0x42, 0x03, 0x8e},
    {0x04, 0x09, 0x42, 0x43, 0x8e},
    {0x02, 0x0e, 0x42, 0x03, 0x8e},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x03, 0x8e},
    {0x03, 0x04, 0x45, 0x03, 0x6e},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x03, 0x6e},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x03, 0x6e},
    {0x01, 0x06, 0x44, 0x43, 0x7e},
    {0x02, 0x02, 0x45, 0x03, 0x6e},
    {0x05, 0x45, 0x02, 0x03, 0x8e},
    {0x03, 0x07, 0x45, 0x03, 0x6e},
    {0x04, 0x06, 0x44, 0x43, 0x7e},
    {0x02, 0x07, 0x45, 0x03, 0x6e},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0xf5, 0x40, 0xbb},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0xb5, 0x00, 0xbb},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0xf5, 0x40, 0xbb},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0xf5, 0xcc},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0xb5, 0x00, 0xbb},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0xf5, 0x40, 0xbb},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x03, 0x8e},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x03, 0x8e},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x03, 0x7e},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x03, 0x7e},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x43, 0x7e},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0xb5, 0xbb},
    {0x04, 0x04, 0x44, 0x43, 0x7e},
    {0x02, 0x81, 0x42, 0xb5, 0xbb},
    {0x0c, 0x42, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x44, 0x03, 0x7e},
    {0x01, 0x02, 0x44, 0x43, 0x7e},
    {0x02, 0x0a, 0x44, 0x03, 0x7e},
    {0x06, 0x46, 0x02, 0x03, 0x8e},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0x43, 0x7e},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0x03, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0x43, 0x7e},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0x03, 0x8e},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0x43, 0x7e},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xa7, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x05, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x05, 0x6d},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x05, 0x7d},
    {0x01, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x0b, 0x42, 0x05, 0x7d},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x05, 0x6d},
    {0x04, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x05, 0x44, 0x05, 0x6d},
    {0x0a, 0x47, 0xf5, 0x40, 0xbb},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x05, 0x7d},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x05, 0x7d},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0x43, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x8a, 0x43, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x05, 0x6d},
    {0x04, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x06, 0x44, 0x05, 0x6d},
    {0x50, 0x03, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0x03, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0xb5, 0xbb},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0xb5, 0xbb},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x03, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x03, 0x8e},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x03, 0x8e},
    {0x40, 0x03, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x43, 0xb5, 0xee},
    {0x01, 0x84, 0x43, 0xf5, 0xee},
    {0x02, 0x86, 0x43, 0xb5, 0xee},
    {0x06, 0xc1, 0x05, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x05, 0x6d},
    {0x04, 0x84, 0x43, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x05, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x05, 0x6d},
    {0x01, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x44, 0x05, 0x6d},
    {0x05, 0xc1, 0x05, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x05, 0x6d},
    {0x04, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x44, 0x05, 0x6d},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x03, 0x8e},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x03, 0x8e},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0x43, 0x8e},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0x43, 0x8e},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0xf5, 0x40, 0xbb},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x45, 0xf5, 0xdd},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x03, 0x8e},
    {0x03, 0x11, 0x42, 0x03, 0x8e},
    {0x04, 0x83, 0x45, 0xf5, 0xdd},
    {0x02, 0x11, 0x42, 0x03, 0x8e},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x45, 0xb5, 0xdd},
    {0x01, 0x81, 0x46, 0xf5, 0xcc},
    {0x02, 0x84, 0x45, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0x03, 0x8e},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x42, 0x03, 0x8e},
    {0x01, 0x0a, 0x42, 0x43, 0x8e},
    {0x02, 0x01, 0x42, 0x03, 0x8e},
    {0x06, 0x42, 0x02, 0x03, 0x8e},
    {0x03, 0x08, 0x42, 0x05, 0x7d},
    {0x04, 0x0a, 0x42, 0x43, 0x8e},
    {0x02, 0x08, 0x42, 0x05, 0x7d},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0xb5, 0xcc},
    {0x01, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x83, 0x46, 0xb5, 0xcc},
    {0x05, 0x42, 0x02, 0x03, 0x8e},
    {0x03, 0x81, 0x47, 0xb5, 0xbb},
    {0x04, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x81, 0x47, 0xb5, 0xbb},
    {0x0c, 0x47, 0xf5, 0x40, 0xbb},
    {0x03, 0x0a, 0x42, 0x05, 0x7d},
    {0x01, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x0a, 0x42, 0x05, 0x7d},
    {0x06, 0x47, 0x02, 0x03, 0x8e},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0x03, 0x8e},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0x4d, 0xb5, 0x6e},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0x4d, 0xb5, 0x6e},
    {0x09, 0x6d, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x4a, 0xb5, 0x7e},
    {0x01, 0x03, 0x4a, 0xf5, 0x7e},
    {0x02, 0x0b, 0x4a, 0xb5, 0x7e},
    {0x05, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0x4d, 0xb5, 0x6e},
    {0x04, 0x03, 0x4a, 0xf5, 0x7e},
    {0x02, 0x05, 0x4d, 0xb5, 0x6e},
    {0x0a, 0x57, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x49, 0xb5, 0x8e},
    {0x01, 0x0b, 0x49, 0xf5, 0x8e},
    {0x02, 0x0c, 0x49, 0xb5, 0x8e},
    {0x06, 0x43, 0x09, 0xb5, 0x8e},
    {0x03, 0x09, 0x4a, 0xb5, 0x7e},
    {0x04, 0x0b, 0x49, 0xf5, 0x8e},
    {0x02, 0x09, 0x4a, 0xb5, 0x7e},
    {0x07, 0x5d, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x4a, 0xf5, 0x7e},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x09, 0xb5, 0x8e},
    {0x03, 0x06, 0x4d, 0xb5, 0x6e},
    {0x04, 0x05, 0x4a, 0xf5, 0x7e},
    {0x02, 0x06, 0x4d, 0xb5, 0x6e},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x46, 0xb5, 0x9d},
    {0x01, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x14, 0x46, 0xb5, 0x9d},
    {0x06, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x82, 0x57, 0xb5, 0xee},
    {0x04, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x82, 0x57, 0xb5, 0xee},
    {0x08, 0x6d, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x46, 0xb5, 0x9d},
    {0x01, 0x09, 0x49, 0xf5, 0x8e},
    {0x02, 0x18, 0x46, 0xb5, 0x9d},
    {0x05, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x0e, 0x49, 0xb5, 0x8e},
    {0x04, 0x09, 0x49, 0xf5, 0x8e},
    {0x02, 0x0e, 0x49, 0xb5, 0x8e},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x46, 0xb5, 0x9d},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x46, 0xb5, 0x9d},
    {0x06, 0x45, 0x09, 0xb5, 0x8e},
    {0x03, 0x04, 0x4d, 0xb5, 0x6e},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0x4d, 0xb5, 0x6e},
    {0x07, 0x43, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x4d, 0xb5, 0x6e},
    {0x01, 0x06, 0x4a, 0xf5, 0x7e},
    {0x02, 0x02, 0x4d, 0xb5, 0x6e},
    {0x05, 0x45, 0x09, 0xb5, 0x8e},
    {0x03, 0x07, 0x4d, 0xb5, 0x6e},
    {0x04, 0x06, 0x4a, 0xf5, 0x7e},
    {0x02, 0x07, 0x4d, 0xb5, 0x6e},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x46, 0xb5, 0x9d},
    {0x01, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x17, 0x46, 0xb5, 0x9d},
    {0x06, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x1b, 0x46, 0xb5, 0x9d},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x46, 0xb5, 0x9d},
    {0x05, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x57, 0xf5, 0x40, 0xee},
    {0x03, 0x27, 0x41, 0xb5, 0xad},
    {0x01, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x27, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x10, 0x49, 0xb5, 0x8e},
    {0x04, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x49, 0xb5, 0x8e},
    {0x07, 0x4b, 0x01, 0xf5, 0xad},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x46, 0xb5, 0x9d},
    {0x01, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x13, 0x46, 0xb5, 0x9d},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0x4a, 0xb5, 0x7e},
    {0x04, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x08, 0x4a, 0xb5, 0x7e},
    {0x08, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x37, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x4a, 0xf5, 0x7e},
    {0x02, 0x37, 0x41, 0xb5, 0xad},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x57, 0xb5, 0xee},
    {0x04, 0x04, 0x4a, 0xf5, 0x7e},
    {0x02, 0x81, 0x57, 0xb5, 0xee},
    {0x0c, 0x57, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x4a, 0xb5, 0x7e},
    {0x01, 0x02, 0x4a, 0xf5, 0x7e},
    {0x02, 0x0a, 0x4a, 0xb5, 0x7e},
    {0x06, 0x46, 0x09, 0xb5, 0x8e},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x4a, 0xf5, 0x7e},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x4a, 0xf5, 0x7e},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x09, 0xb5, 0x8e},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x4a, 0xf5, 0x7e},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x41, 0xb5, 0xad},
    {0x01, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x2d, 0x41, 0xb5, 0xad},
    {0x06, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x35, 0x41, 0xb5, 0xad},
    {0x01, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x35, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x03, 0xf5, 0xbd},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x41, 0xb5, 0xad},
    {0x01, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x41, 0xb5, 0xad},
    {0x06, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x03, 0xbd},
    {0x04, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x03, 0xbd},
    {0x08, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x33, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x33, 0x41, 0xb5, 0xad},
    {0x05, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x49, 0xb5, 0x8e},
    {0x04, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x49, 0xb5, 0x8e},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x41, 0xb5, 0xad},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x41, 0xb5, 0xad},
    {0x06, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0x49, 0xb5, 0x8e},
    {0x01, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x0d, 0x49, 0xb5, 0x8e},
    {0x06, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x49, 0xf5, 0x8e},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x49, 0xf5, 0x8e},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x2b, 0x41, 0xb5, 0xad},
    {0x01, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x09, 0xb5, 0x8e},
    {0x03, 0x11, 0x49, 0xb5, 0x8e},
    {0x04, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x49, 0xb5, 0x8e},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x09, 0xb5, 0x8e},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x49, 0xb5, 0x8e},
    {0x01, 0x0a, 0x49, 0xf5, 0x8e},
    {0x02, 0x01, 0x49, 0xb5, 0x8e},
    {0x06, 0x42, 0x09, 0xb5, 0x8e},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x49, 0xf5, 0x8e},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x09, 0xb5, 0x8e},
    {0x03, 0x81, 0x43, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x03, 0xbd},
    {0x0c, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x09, 0xb5, 0x8e},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x09, 0xb5, 0x8e},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x41, 0xb5, 0xad},
    {0x01, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x41, 0xb5, 0xad},
    {0x06, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x75, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x5b, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x61, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x21, 0x41, 0xb5, 0xad},
    {0x01, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x41, 0xb5, 0xad},
    {0x06, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x5b, 0xb5, 0xee},
    {0x04, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x5b, 0xb5, 0xee},
    {0x08, 0x75, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x41, 0xb5, 0xad},
    {0x05, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0x83, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x41, 0xb5, 0xad},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x94, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x2f, 0x41, 0xb5, 0xad},
    {0x01, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x41, 0xb5, 0xad},
    {0x06, 0x68, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x82, 0x6d},
    {0x04, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x82, 0x6d},
    {0x09, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x3b, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x3b, 0x41, 0xb5, 0xad},
    {0x05, 0x68, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x82, 0x6d},
    {0x04, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x82, 0x6d},
    {0x0b, 0x5b, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x41, 0xb5, 0xad},
    {0x01, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x41, 0xb5, 0xad},
    {0x06, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x71, 0xb5, 0x40, 0xdd},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x82, 0x6d},
    {0x04, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x82, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x41, 0xb5, 0xad},
    {0x01, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x41, 0xb5, 0xad},
    {0x06, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x39, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x41, 0xb5, 0xad},
    {0x05, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x5b, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x5b, 0xb5, 0xee},
    {0x0c, 0x5b, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x82, 0x6d},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x82, 0x6d},
    {0x07, 0x4e, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x82, 0x6d},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x82, 0x6d},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x82, 0x6d},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x82, 0x6d},
    {0xdd, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x46, 0xb5, 0x9d},
    {0x01, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x16, 0x46, 0xb5, 0x9d},
    {0x06, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xc7, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x46, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x46, 0xb5, 0x9d},
    {0x06, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7d, 0xb5, 0x40, 0xdd},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x41, 0xb5, 0xad},
    {0x01, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x41, 0xb5, 0xad},
    {0x06, 0x78, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x45, 0x03, 0xbd},
    {0x04, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x03, 0xbd},
    {0x08, 0xc7, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x46, 0xb5, 0x9d},
    {0x01, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x19, 0x46, 0xb5, 0x9d},
    {0x05, 0x78, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x8e, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x82, 0x6d},
    {0x04, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x82, 0x6d},
    {0x09, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x46, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x46, 0xb5, 0x9d},
    {0x05, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x82, 0x6d},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x82, 0x6d},
    {0x0b, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x46, 0xb5, 0x9d},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x46, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x06, 0xf5, 0x9d},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x82, 0x6d},
    {0x04, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x82, 0x6d},
    {0x4e, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xc2, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0xc2, 0xb5, 0x0d},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x03, 0xbd},
    {0x0c, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x82, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x82, 0x6d},
    {0x07, 0x47, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x82, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x82, 0x6d},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x82, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x82, 0x6d},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa1, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0xa1, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x63, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6e, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x68, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x6f, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x68, 0xb5, 0xff},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x68, 0xb5, 0xff},
    {0x08, 0x63, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x09, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x49, 0xf5, 0xee},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x49, 0xf5, 0xee},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0x8a, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x76, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x76, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x68, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x41, 0xb5, 0xad},
    {0x01, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x7b, 0xb5, 0x40, 0xdd},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x41, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x68, 0xb5, 0xff},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x68, 0xb5, 0xff},
    {0x0c, 0x68, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xa2, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2e, 0x41, 0xb5, 0xad},
    {0x01, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x41, 0xb5, 0xad},
    {0x06, 0x64, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0x09, 0x6e},
    {0x04, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x09, 0x6e},
    {0x09, 0x73, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x09, 0x7e},
    {0x01, 0x03, 0x43, 0x49, 0x7e},
    {0x02, 0x0b, 0x43, 0x09, 0x7e},
    {0x05, 0x64, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0x09, 0x6e},
    {0x04, 0x03, 0x43, 0x49, 0x7e},
    {0x02, 0x05, 0x41, 0x09, 0x6e},
    {0x0a, 0x50, 0xf5, 0x40, 0xdd},
    {0x03, 0x36, 0x41, 0xb5, 0xad},
    {0x01, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0x09, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x09, 0x7e},
    {0x04, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x09, 0x7e},
    {0x07, 0x69, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x49, 0x7e},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x09, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x09, 0x6e},
    {0x04, 0x05, 0x43, 0x49, 0x7e},
    {0x02, 0x06, 0x41, 0x09, 0x6e},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x41, 0xb5, 0xad},
    {0x01, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x41, 0xb5, 0xad},
    {0x06, 0x74, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x50, 0xb5, 0xdd},
    {0x04, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x50, 0xb5, 0xdd},
    {0x08, 0x73, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x41, 0xb5, 0xad},
    {0x05, 0x74, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x41, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x41, 0xb5, 0xad},
    {0x06, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x09, 0x6e},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x09, 0x6e},
    {0x07, 0x50, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x09, 0x6e},
    {0x01, 0x06, 0x43, 0x49, 0x7e},
    {0x02, 0x02, 0x41, 0x09, 0x6e},
    {0x05, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x09, 0x6e},
    {0x04, 0x06, 0x43, 0x49, 0x7e},
    {0x02, 0x07, 0x41, 0x09, 0x6e},
    {0x87, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x40, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x4f, 0xf5, 0x00, 0xcc},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x40, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x50, 0xf5, 0x40, 0xdd},
    {0x03, 0x2c, 0x41, 0xb5, 0xad},
    {0x01, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xcf, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x09, 0x7e},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x09, 0x7e},
    {0x08, 0x4f, 0xf5, 0x00, 0xcc},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x49, 0x7e},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x50, 0xb5, 0xdd},
    {0x04, 0x04, 0x43, 0x49, 0x7e},
    {0x02, 0x81, 0x50, 0xb5, 0xdd},
    {0x0c, 0x50, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x43, 0x09, 0x7e},
    {0x01, 0x02, 0x43, 0x49, 0x7e},
    {0x02, 0x0a, 0x43, 0x09, 0x7e},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x49, 0x7e},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x49, 0x7e},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x49, 0x7e},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x49, 0xf5, 0x00, 0x0e},
    {0x03, 0x1e, 0x41, 0xb5, 0xad},
    {0x01, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x1e, 0x41, 0xb5, 0xad},
    {0x06, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x7f, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x5f, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x4e, 0xb5, 0xee},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x4e, 0xb5, 0xee},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x0e, 0xb5, 0x00, 0xee},
    {0x03, 0x22, 0x41, 0xb5, 0xad},
    {0x01, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x22, 0x41, 0xb5, 0xad},
    {0x06, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0x7f, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x41, 0xb5, 0xad},
    {0x05, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x41, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x98, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x30, 0x41, 0xb5, 0xad},
    {0x01, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x41, 0xb5, 0xad},
    {0x06, 0x6c, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x0e, 0x6e},
    {0x04, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x0e, 0x6e},
    {0x09, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3c, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0x4e, 0xf5, 0xee},
    {0x02, 0x3c, 0x41, 0xb5, 0xad},
    {0x05, 0x6c, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x0e, 0x6e},
    {0x04, 0x82, 0x4e, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0e, 0x6e},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x2a, 0x41, 0xb5, 0xad},
    {0x01, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x2a, 0x41, 0xb5, 0xad},
    {0x06, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x79, 0xb5, 0x40, 0xdd},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x0e, 0x6e},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x0e, 0x6e},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x41, 0xb5, 0xad},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x41, 0xb5, 0xad},
    {0x06, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3a, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x41, 0xb5, 0xad},
    {0x05, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x0e, 0x6e},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x0e, 0x6e},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x0e, 0x6e},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x0e, 0x6e},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x0e, 0x6e},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x0e, 0x6e},
    {0xa6, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x09, 0x6e},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x09, 0x6e},
    {0x09, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x09, 0x7e},
    {0x01, 0x03, 0x42, 0x49, 0x7e},
    {0x02, 0x0b, 0x42, 0x09, 0x7e},
    {0x05, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x09, 0x6e},
    {0x04, 0x03, 0x42, 0x49, 0x7e},
    {0x02, 0x05, 0x44, 0x09, 0x6e},
    {0x0a, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x09, 0x7e},
    {0x04, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x09, 0x7e},
    {0x07, 0x4a, 0x01, 0xf5, 0xad},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x49, 0x7e},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x09, 0x6e},
    {0x04, 0x05, 0x42, 0x49, 0x7e},
    {0x02, 0x06, 0x44, 0x09, 0x6e},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x41, 0xb5, 0xad},
    {0x01, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x26, 0x41, 0xb5, 0xad},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x03, 0xbd},
    {0x04, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x03, 0xbd},
    {0x08, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x09, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x09, 0x6e},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x09, 0x6e},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x09, 0x6e},
    {0x01, 0x06, 0x42, 0x49, 0x7e},
    {0x02, 0x02, 0x44, 0x09, 0x6e},
    {0x05, 0xc1, 0x09, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x09, 0x6e},
    {0x04, 0x06, 0x42, 0x49, 0x7e},
    {0x02, 0x07, 0x44, 0x09, 0x6e},
    {0xc1, 0x41, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x0e, 0x6e},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x0e, 0x6e},
    {0x09, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x0e, 0x6e},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x0e, 0x6e},
    {0x0b, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x49, 0xf5, 0xee},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x49, 0xf5, 0xee},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x49, 0xb5, 0xee},
    {0x01, 0x81, 0x4e, 0xf5, 0xee},
    {0x02, 0x84, 0x49, 0xb5, 0xee},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x0e, 0x6e},
    {0x04, 0x81, 0x4e, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0e, 0x6e},
    {0x4e, 0x0e, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x09, 0x7e},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x09, 0x7e},
    {0x08, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0x4e, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0x49, 0x7e},
    {0x02, 0x83, 0x4e, 0xb5, 0xee},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x49, 0x7e},
    {0x02, 0x81, 0x46, 0x03, 0xbd},
    {0x0c, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x09, 0x7e},
    {0x01, 0x02, 0x42, 0x49, 0x7e},
    {0x02, 0x0a, 0x42, 0x09, 0x7e},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x0e, 0x6e},
    {0x04, 0x02, 0x42, 0x49, 0x7e},
    {0x02, 0x04, 0x42, 0x0e, 0x6e},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x0e, 0x6e},
    {0x01, 0x07, 0x42, 0x49, 0x7e},
    {0x02, 0x02, 0x42, 0x0e, 0x6e},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x0e, 0x6e},
    {0x04, 0x07, 0x42, 0x49, 0x7e},
    {0x02, 0x07, 0x42, 0x0e, 0x6e},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0x9d, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5e, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0x9d, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x4d, 0xf5, 0x00, 0xcc},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x53, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0xb5, 0x40, 0xcc},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x53, 0xb5, 0xee},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x53, 0xb5, 0xee},
    {0x08, 0x4d, 0xf5, 0x00, 0xcc},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0x05, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x53, 0xf5, 0x40, 0xee},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0x45, 0xb5, 0xee},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0x45, 0xb5, 0xee},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0x05, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0x05, 0xb5, 0xee},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0x05, 0xb5, 0xee},
    {0x03, 0x81, 0x53, 0xb5, 0xee},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x53, 0xb5, 0xee},
    {0x0c, 0x53, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xa0, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0xd8, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x62, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x48, 0xf5, 0x40, 0xcc},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x5a, 0xb5, 0x40, 0xcc},
    {0x03, 0x87, 0x45, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0x45, 0xb5, 0xee},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x48, 0xb5, 0xcc},
    {0x04, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0xb5, 0xcc},
    {0x08, 0xd8, 0xf5, 0x00, 0x0f},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x85, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7e, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x48, 0xf5, 0x40, 0xcc},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xcb, 0xb5, 0x40, 0x0e},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0xb5, 0xcc},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x48, 0xb5, 0xcc},
    {0x0c, 0x48, 0xf5, 0x40, 0xcc},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x46, 0x05, 0x6e},
    {0x04, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x05, 0x6e},
    {0x09, 0x6b, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x05, 0x7e},
    {0x01, 0x03, 0x41, 0x45, 0x7e},
    {0x02, 0x0b, 0x41, 0x05, 0x7e},
    {0x05, 0x70, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x46, 0x05, 0x6e},
    {0x04, 0x03, 0x41, 0x45, 0x7e},
    {0x02, 0x05, 0x46, 0x05, 0x6e},
    {0x0a, 0x78, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0x05, 0x8e},
    {0x01, 0x0b, 0x43, 0x45, 0x8e},
    {0x02, 0x0c, 0x43, 0x05, 0x8e},
    {0x06, 0x43, 0x03, 0x05, 0x8e},
    {0x03, 0x09, 0x41, 0x05, 0x7e},
    {0x04, 0x0b, 0x43, 0x45, 0x8e},
    {0x02, 0x09, 0x41, 0x05, 0x7e},
    {0x07, 0x65, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x44, 0xb5, 0xcc},
    {0x01, 0x05, 0x41, 0x45, 0x7e},
    {0x02, 0x9a, 0x44, 0xb5, 0xcc},
    {0x05, 0x43, 0x03, 0x05, 0x8e},
    {0x03, 0x06, 0x46, 0x05, 0x6e},
    {0x04, 0x05, 0x41, 0x45, 0x7e},
    {0x02, 0x06, 0x46, 0x05, 0x6e},
    {0x4d, 0x04, 0xb5, 0x00, 0xcc},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0x78, 0xb5, 0xff},
    {0x04, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x78, 0xb5, 0xff},
    {0x08, 0x6b, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x45, 0x8e},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0xb5, 0x00, 0xcc},
    {0x03, 0x0e, 0x43, 0x05, 0x8e},
    {0x04, 0x09, 0x43, 0x45, 0x8e},
    {0x02, 0x0e, 0x43, 0x05, 0x8e},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x05, 0x8e},
    {0x03, 0x04, 0x46, 0x05, 0x6e},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x05, 0x6e},
    {0x07, 0xc2, 0x05, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x05, 0x6e},
    {0x01, 0x06, 0x41, 0x45, 0x7e},
    {0x02, 0x02, 0x46, 0x05, 0x6e},
    {0x05, 0x45, 0x03, 0x05, 0x8e},
    {0x03, 0x07, 0x46, 0x05, 0x6e},
    {0x04, 0x06, 0x41, 0x45, 0x7e},
    {0x02, 0x07, 0x46, 0x05, 0x6e},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0xf5, 0x00, 0xcc},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0xf5, 0xcc},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0x78, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x05, 0x8e},
    {0x04, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x05, 0x8e},
    {0x07, 0x59, 0xb5, 0x40, 0xcc},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x05, 0x7e},
    {0x04, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x05, 0x7e},
    {0x08, 0x51, 0xf5, 0x00, 0xcc},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x45, 0x7e},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x78, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0x45, 0x7e},
    {0x02, 0x81, 0x78, 0xb5, 0xff},
    {0x0c, 0x78, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0x05, 0x7e},
    {0x01, 0x02, 0x41, 0x45, 0x7e},
    {0x02, 0x0a, 0x41, 0x05, 0x7e},
    {0x06, 0x46, 0x03, 0x05, 0x8e},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0x45, 0x7e},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0x45, 0x7e},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0x05, 0x8e},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0x45, 0x7e},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xd4, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x60, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0xc5, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x84, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0xb5, 0x00, 0xcc},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xd4, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0xb5, 0x00, 0xcc},
    {0x03, 0x0f, 0x43, 0x05, 0x8e},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x05, 0x8e},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x45, 0xb5, 0xee},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x45, 0xb5, 0xee},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x92, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0x05, 0x8e},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x05, 0x8e},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x45, 0x8e},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0x45, 0x8e},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x05, 0x8e},
    {0x03, 0x11, 0x43, 0x05, 0x8e},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0x05, 0x8e},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x44, 0xf5, 0xcc},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0x05, 0x8e},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x43, 0x05, 0x8e},
    {0x01, 0x0a, 0x43, 0x45, 0x8e},
    {0x02, 0x01, 0x43, 0x05, 0x8e},
    {0x06, 0x42, 0x03, 0x05, 0x8e},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0x45, 0x8e},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0xb5, 0xcc},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x44, 0xb5, 0xcc},
    {0x05, 0x42, 0x03, 0x05, 0x8e},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0x05, 0x8e},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0x05, 0x8e},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xf4, 0x45, 0xf5, 0x00, 0x0e},
    {0x03, 0xa5, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0xa5, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x41, 0xf5, 0x00, 0xcc},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x4a, 0xf5, 0x40, 0xcc},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0xb5, 0xcc},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0x42, 0xb5, 0xcc},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0x02, 0xb5, 0x00, 0xcc},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x4a, 0xb5, 0xcc},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x4a, 0xb5, 0xcc},
    {0x08, 0x41, 0xf5, 0x00, 0xcc},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x06, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x46, 0xf5, 0xdd},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x46, 0xf5, 0xdd},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0x42, 0xf5, 0xcc},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0xf5, 0x40, 0xcc},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0x52, 0xb5, 0x40, 0xcc},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0xb5, 0xcc},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x4a, 0xb5, 0xcc},
    {0x0c, 0x4a, 0xf5, 0x40, 0xcc},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xa4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0xb5, 0x00, 0xcc},
    {0x03, 0x03, 0x41, 0x06, 0x6d},
    {0x04, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x06, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x06, 0x7d},
    {0x01, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x0b, 0x43, 0x06, 0x7d},
    {0x05, 0x66, 0xb5, 0x00, 0xcc},
    {0x03, 0x05, 0x41, 0x06, 0x6d},
    {0x04, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x05, 0x41, 0x06, 0x6d},
    {0x0a, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x06, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x06, 0x7d},
    {0x04, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x06, 0x7d},
    {0x07, 0x55, 0xb5, 0x40, 0xcc},
    {0x03, 0x88, 0x45, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x88, 0x45, 0xb5, 0xee},
    {0x05, 0xc2, 0x06, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x06, 0x6d},
    {0x04, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x06, 0x41, 0x06, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x03, 0xbd},
    {0x04, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x03, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x06, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x06, 0x6d},
    {0x07, 0x51, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x06, 0x6d},
    {0x01, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x41, 0x06, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x06, 0x6d},
    {0x04, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x41, 0x06, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x42, 0xf5, 0xcc},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x06, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x06, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0x42, 0xb5, 0xcc},
    {0x01, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x83, 0x42, 0xb5, 0xcc},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x81, 0x44, 0x03, 0xbd},
    {0x0c, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x06, 0x7d},
    {0x01, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x0a, 0x43, 0x06, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x46, 0xb5, 0x40, 0x0d},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x05, 0x6e},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x05, 0x6e},
    {0x09, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0x05, 0x7e},
    {0x01, 0x03, 0x44, 0x45, 0x7e},
    {0x02, 0x0b, 0x44, 0x05, 0x7e},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x05, 0x6e},
    {0x04, 0x03, 0x44, 0x45, 0x7e},
    {0x02, 0x05, 0x45, 0x05, 0x6e},
    {0x0a, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0x05, 0x8e},
    {0x01, 0x0b, 0x42, 0x45, 0x8e},
    {0x02, 0x0c, 0x42, 0x05, 0x8e},
    {0x06, 0x43, 0x02, 0x05, 0x8e},
    {0x03, 0x09, 0x44, 0x05, 0x7e},
    {0x04, 0x0b, 0x42, 0x45, 0x8e},
    {0x02, 0x09, 0x44, 0x05, 0x7e},
    {0x07, 0x41, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0xb5, 0xcc},
    {0x01, 0x05, 0x44, 0x45, 0x7e},
    {0x02, 0x9a, 0x47, 0xb5, 0xcc},
    {0x05, 0x43, 0x02, 0x05, 0x8e},
    {0x03, 0x06, 0x45, 0x05, 0x6e},
    {0x04, 0x05, 0x44, 0x45, 0x7e},
    {0x02, 0x06, 0x45, 0x05, 0x6e},
    {0x4d, 0x07, 0xb5, 0x00, 0xcc},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x03, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x03, 0xbd},
    {0x08, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x45, 0x8e},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0x05, 0x8e},
    {0x04, 0x09, 0x42, 0x45, 0x8e},
    {0x02, 0x0e, 0x42, 0x05, 0x8e},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x05, 0x8e},
    {0x03, 0x04, 0x45, 0x05, 0x6e},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x05, 0x6e},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x05, 0x6e},
    {0x01, 0x06, 0x44, 0x45, 0x7e},
    {0x02, 0x02, 0x45, 0x05, 0x6e},
    {0x05, 0x45, 0x02, 0x05, 0x8e},
    {0x03, 0x07, 0x45, 0x05, 0x6e},
    {0x04, 0x06, 0x44, 0x45, 0x7e},
    {0x02, 0x07, 0x45, 0x05, 0x6e},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0xf5, 0xcc},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0xf5, 0xcc},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x05, 0x8e},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x05, 0x8e},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x05, 0x7e},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x05, 0x7e},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x45, 0x7e},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x03, 0xbd},
    {0x04, 0x04, 0x44, 0x45, 0x7e},
    {0x02, 0x81, 0x42, 0x03, 0xbd},
    {0x0c, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0x05, 0x7e},
    {0x01, 0x02, 0x44, 0x45, 0x7e},
    {0x02, 0x0a, 0x44, 0x05, 0x7e},
    {0x06, 0x46, 0x02, 0x05, 0x8e},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0x45, 0x7e},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0x05, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0x45, 0x7e},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0x05, 0x8e},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0x45, 0x7e},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xa8, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x06, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x06, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x06, 0x7d},
    {0x01, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x0b, 0x42, 0x06, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x06, 0x6d},
    {0x04, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x05, 0x44, 0x06, 0x6d},
    {0x0a, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x06, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x06, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0x45, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x8a, 0x45, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x06, 0x6d},
    {0x04, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x06, 0x44, 0x06, 0x6d},
    {0x50, 0x05, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0x05, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x03, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x03, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x05, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x05, 0x8e},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x05, 0x8e},
    {0x40, 0x05, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x45, 0xb5, 0xee},
    {0x01, 0x84, 0x45, 0xf5, 0xee},
    {0x02, 0x86, 0x45, 0xb5, 0xee},
    {0x06, 0xc1, 0x06, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x06, 0x6d},
    {0x04, 0x84, 0x45, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x06, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x06, 0x6d},
    {0x01, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x44, 0x06, 0x6d},
    {0x05, 0xc1, 0x06, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x06, 0x6d},
    {0x04, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x44, 0x06, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x05, 0x8e},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x05, 0x8e},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0x45, 0x8e},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0x45, 0x8e},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x46, 0xf5, 0xdd},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x05, 0x8e},
    {0x03, 0x11, 0x42, 0x05, 0x8e},
    {0x04, 0x83, 0x46, 0xf5, 0xdd},
    {0x02, 0x11, 0x42, 0x05, 0x8e},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x46, 0xb5, 0xdd},
    {0x01, 0x81, 0x47, 0xf5, 0xcc},
    {0x02, 0x84, 0x46, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0x05, 0x8e},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0xf5, 0xcc},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0xb5, 0x00, 0xcc},
    {0x03, 0x01, 0x42, 0x05, 0x8e},
    {0x01, 0x0a, 0x42, 0x45, 0x8e},
    {0x02, 0x01, 0x42, 0x05, 0x8e},
    {0x06, 0x42, 0x02, 0x05, 0x8e},
    {0x03, 0x08, 0x42, 0x06, 0x7d},
    {0x04, 0x0a, 0x42, 0x45, 0x8e},
    {0x02, 0x08, 0x42, 0x06, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0xb5, 0xcc},
    {0x01, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x83, 0x47, 0xb5, 0xcc},
    {0x05, 0x42, 0x02, 0x05, 0x8e},
    {0x03, 0x81, 0x47, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x81, 0x47, 0x03, 0xbd},
    {0x0c, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x06, 0x7d},
    {0x01, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x0a, 0x42, 0x06, 0x7d},
    {0x06, 0x47, 0x02, 0x05, 0x8e},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x05, 0x8e},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0xb4, 0xf5, 0x00, 0x0d},
    {0x01, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0xb4, 0xf5, 0x00, 0x0d},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x5d, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x6e, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x4b, 0xb5, 0x8f},
    {0x01, 0x0b, 0x4b, 0xf5, 0x8f},
    {0x02, 0x0c, 0x4b, 0xb5, 0x8f},
    {0x06, 0x43, 0x0b, 0xb5, 0x8f},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0x4b, 0xf5, 0x8f},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0xf5, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x0b, 0xb5, 0x8f},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x48, 0xb5, 0x9f},
    {0x01, 0x0c, 0x48, 0xf5, 0x9f},
    {0x02, 0x14, 0x48, 0xb5, 0x9f},
    {0x06, 0x4b, 0x08, 0xb5, 0x9f},
    {0x03, 0x82, 0x6e, 0xb5, 0xff},
    {0x04, 0x0c, 0x48, 0xf5, 0x9f},
    {0x02, 0x82, 0x6e, 0xb5, 0xff},
    {0x08, 0x5d, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x48, 0xb5, 0x9f},
    {0x01, 0x09, 0x4b, 0xf5, 0x8f},
    {0x02, 0x18, 0x48, 0xb5, 0x9f},
    {0x05, 0x4b, 0x08, 0xb5, 0x9f},
    {0x03, 0x0e, 0x4b, 0xb5, 0x8f},
    {0x04, 0x09, 0x4b, 0xf5, 0x8f},
    {0x02, 0x0e, 0x4b, 0xb5, 0x8f},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x48, 0xb5, 0x9f},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x48, 0xb5, 0x9f},
    {0x06, 0x45, 0x0b, 0xb5, 0x8f},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x08, 0xf5, 0x9f},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x0b, 0xb5, 0x8f},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x48, 0xb5, 0x9f},
    {0x01, 0x14, 0x46, 0xf5, 0xae},
    {0x02, 0x17, 0x48, 0xb5, 0x9f},
    {0x06, 0x4c, 0x06, 0xb5, 0xae},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x46, 0xf5, 0xae},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x46, 0xb5, 0xae},
    {0x03, 0x1b, 0x48, 0xb5, 0x9f},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x48, 0xb5, 0x9f},
    {0x05, 0x4c, 0x06, 0xb5, 0xae},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x6e, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x46, 0xb5, 0xae},
    {0x01, 0x18, 0x46, 0xf5, 0xae},
    {0x02, 0x27, 0x46, 0xb5, 0xae},
    {0x06, 0x49, 0x08, 0xb5, 0x9f},
    {0x03, 0x10, 0x4b, 0xb5, 0x8f},
    {0x04, 0x18, 0x46, 0xf5, 0xae},
    {0x02, 0x10, 0x4b, 0xb5, 0x8f},
    {0x07, 0x4b, 0x06, 0xf5, 0xae},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x48, 0xf5, 0x9f},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x08, 0xb5, 0x9f},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x48, 0xf5, 0x9f},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x48, 0xb5, 0x9f},
    {0x01, 0x1c, 0x46, 0xf5, 0xae},
    {0x02, 0x13, 0x48, 0xb5, 0x9f},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0x46, 0xf5, 0xae},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0x46, 0xb5, 0xae},
    {0x03, 0x37, 0x46, 0xb5, 0xae},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0x46, 0xb5, 0xae},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x6e, 0xb5, 0xff},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0x6e, 0xb5, 0xff},
    {0x0c, 0x6e, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0x0b, 0xb5, 0x8f},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x08, 0xf5, 0x9f},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x0b, 0xb5, 0x8f},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x41, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x46, 0xb5, 0xae},
    {0x01, 0x17, 0x46, 0xf5, 0xae},
    {0x02, 0x2d, 0x46, 0xb5, 0xae},
    {0x06, 0x54, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x46, 0xf5, 0xae},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x41, 0xb5, 0xbe},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x41, 0xf5, 0xbe},
    {0x03, 0x35, 0x46, 0xb5, 0xae},
    {0x01, 0x1b, 0x46, 0xf5, 0xae},
    {0x02, 0x35, 0x46, 0xb5, 0xae},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x46, 0xf5, 0xae},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x01, 0xf5, 0xbe},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x46, 0xb5, 0xae},
    {0x01, 0x27, 0x41, 0xf5, 0xbe},
    {0x02, 0x23, 0x46, 0xb5, 0xae},
    {0x06, 0x58, 0x01, 0xb5, 0xbe},
    {0x03, 0x82, 0x43, 0x01, 0xbe},
    {0x04, 0x27, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x43, 0x01, 0xbe},
    {0x08, 0x4b, 0x41, 0xb5, 0xbe},
    {0x03, 0x33, 0x46, 0xb5, 0xae},
    {0x01, 0x10, 0x48, 0xf5, 0x9f},
    {0x02, 0x33, 0x46, 0xb5, 0xae},
    {0x05, 0x58, 0x01, 0xb5, 0xbe},
    {0x03, 0x0f, 0x4b, 0xb5, 0x8f},
    {0x04, 0x10, 0x48, 0xf5, 0x9f},
    {0x02, 0x0f, 0x4b, 0xb5, 0x8f},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x46, 0xb5, 0xae},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x46, 0xb5, 0xae},
    {0x06, 0x4e, 0x06, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x06, 0xf5, 0xae},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x06, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0x4b, 0xb5, 0x8f},
    {0x01, 0x13, 0x46, 0xf5, 0xae},
    {0x02, 0x0d, 0x4b, 0xb5, 0x8f},
    {0x06, 0x5c, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x46, 0xf5, 0xae},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x46, 0xb5, 0xae},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x4b, 0xf5, 0x8f},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x4b, 0xf5, 0x8f},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x41, 0xf5, 0xbe},
    {0x03, 0x2b, 0x46, 0xb5, 0xae},
    {0x01, 0x37, 0x41, 0xf5, 0xbe},
    {0x02, 0x2b, 0x46, 0xb5, 0xae},
    {0x06, 0x44, 0x0b, 0xb5, 0x8f},
    {0x03, 0x11, 0x4b, 0xb5, 0x8f},
    {0x04, 0x37, 0x41, 0xf5, 0xbe},
    {0x02, 0x11, 0x4b, 0xb5, 0x8f},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x0b, 0xb5, 0x8f},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x4b, 0xb5, 0x8f},
    {0x01, 0x0a, 0x4b, 0xf5, 0x8f},
    {0x02, 0x01, 0x4b, 0xb5, 0x8f},
    {0x06, 0x42, 0x0b, 0xb5, 0x8f},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x4b, 0xf5, 0x8f},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x46, 0xb5, 0xae},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x0b, 0xb5, 0x8f},
    {0x03, 0x81, 0x43, 0x01, 0xbe},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x01, 0xbe},
    {0x0c, 0x43, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x0b, 0xb5, 0x8f},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x08, 0xf5, 0x9f},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x0b, 0xb5, 0x8f},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x46, 0xb5, 0xae},
    {0x01, 0x2d, 0x41, 0xf5, 0xbe},
    {0x02, 0x1d, 0x46, 0xb5, 0xae},
    {0x06, 0x57, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x4c, 0x43, 0xb5, 0xce},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x4b, 0x43, 0xf5, 0xce},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x54, 0x03, 0xf5, 0xce},
    {0x03, 0x9a, 0x43, 0x03, 0xce},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x43, 0x03, 0xce},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x03, 0x03, 0xb5, 0xce},
    {0x03, 0x21, 0x46, 0xb5, 0xae},
    {0x01, 0x35, 0x41, 0xf5, 0xbe},
    {0x02, 0x21, 0x46, 0xb5, 0xae},
    {0x06, 0x5b, 0x01, 0xb5, 0xbe},
    {0x03, 0x82, 0x4b, 0x03, 0xce},
    {0x04, 0x35, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x4b, 0x03, 0xce},
    {0x08, 0x4c, 0x43, 0xb5, 0xce},
    {0x03, 0x31, 0x46, 0xb5, 0xae},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x46, 0xb5, 0xae},
    {0x05, 0x5b, 0x01, 0xb5, 0xbe},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc2, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x46, 0xb5, 0xae},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x46, 0xb5, 0xae},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x46, 0xb5, 0xae},
    {0x01, 0x23, 0x41, 0xf5, 0xbe},
    {0x02, 0x2f, 0x46, 0xb5, 0xae},
    {0x06, 0x67, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0x41, 0xb5, 0xbe},
    {0x03, 0x3b, 0x46, 0xb5, 0xae},
    {0x01, 0x82, 0x43, 0x43, 0xce},
    {0x02, 0x3b, 0x46, 0xb5, 0xae},
    {0x05, 0x67, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0x43, 0xf5, 0xce},
    {0x03, 0x29, 0x46, 0xb5, 0xae},
    {0x01, 0x33, 0x41, 0xf5, 0xbe},
    {0x02, 0x29, 0x46, 0xb5, 0xae},
    {0x06, 0x50, 0x06, 0xb5, 0xae},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x41, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x58, 0x03, 0xf5, 0xce},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x48, 0xf5, 0x9f},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x06, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0x48, 0xf5, 0x9f},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x46, 0xb5, 0xae},
    {0x01, 0x3f, 0x41, 0xf5, 0xbe},
    {0x02, 0x1f, 0x46, 0xb5, 0xae},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x41, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x41, 0xb5, 0xbe},
    {0x03, 0x39, 0x46, 0xb5, 0xae},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x46, 0xb5, 0xae},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0x03, 0xce},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x4b, 0x03, 0xce},
    {0x0c, 0x4b, 0x43, 0xf5, 0xce},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0x01, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0xdd, 0x41, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x48, 0xb5, 0x9f},
    {0x01, 0x0d, 0x48, 0xf5, 0x9f},
    {0x02, 0x16, 0x48, 0xb5, 0x9f},
    {0x06, 0x53, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x48, 0xf5, 0x9f},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x41, 0xf5, 0xbe},
    {0x03, 0x1a, 0x48, 0xb5, 0x9f},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x48, 0xb5, 0x9f},
    {0x06, 0x48, 0x08, 0xb5, 0x9f},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x5c, 0x03, 0xf5, 0xce},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x08, 0xb5, 0x9f},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x46, 0xb5, 0xae},
    {0x01, 0x2b, 0x41, 0xf5, 0xbe},
    {0x02, 0x25, 0x46, 0xb5, 0xae},
    {0x06, 0x77, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x01, 0xbe},
    {0x04, 0x2b, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x45, 0x01, 0xbe},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0x48, 0xb5, 0x9f},
    {0x01, 0x11, 0x48, 0xf5, 0x9f},
    {0x02, 0x19, 0x48, 0xb5, 0x9f},
    {0x05, 0x77, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x48, 0xf5, 0x9f},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x08, 0xf5, 0x9f},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x48, 0xf5, 0x9f},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x08, 0xb5, 0x9f},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0x48, 0xf5, 0x9f},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0x46, 0xb5, 0xae},
    {0x03, 0x12, 0x48, 0xb5, 0x9f},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x48, 0xb5, 0x9f},
    {0x05, 0x4a, 0x08, 0xb5, 0x9f},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0x41, 0xf5, 0xbe},
    {0x03, 0x15, 0x48, 0xb5, 0x9f},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x48, 0xb5, 0x9f},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x08, 0xf5, 0x9f},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x43, 0x43, 0xce},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x46, 0xb5, 0xae},
    {0x03, 0x83, 0x43, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x43, 0x03, 0xce},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x01, 0xbe},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x01, 0xbe},
    {0x0c, 0x45, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0x08, 0xf5, 0x9f},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x9f, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x41, 0xf5, 0xbe},
    {0x02, 0x9f, 0xf5, 0x00, 0x0e},
    {0x06, 0x6d, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x61, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6d, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x76, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x57, 0x03, 0xf5, 0xce},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x76, 0xb5, 0xff},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x76, 0xb5, 0xff},
    {0x08, 0x61, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x82, 0xb5, 0x40, 0x0e},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0xc2, 0xf5, 0x0e},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0xc2, 0xf5, 0x0e},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x41, 0xf5, 0xbe},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x75, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x21, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x75, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x76, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x46, 0xb5, 0xae},
    {0x01, 0x31, 0x41, 0xf5, 0xbe},
    {0x02, 0x28, 0x46, 0xb5, 0xae},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x41, 0xf5, 0xbe},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x5b, 0x03, 0xf5, 0xce},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x41, 0xf5, 0xbe},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x41, 0xf5, 0xbe},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x46, 0xb5, 0xae},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x46, 0xb5, 0xae},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x76, 0xb5, 0xff},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x76, 0xb5, 0xff},
    {0x0c, 0x76, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe1, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x46, 0xb5, 0xae},
    {0x01, 0x2f, 0x41, 0xf5, 0xbe},
    {0x02, 0x2e, 0x46, 0xb5, 0xae},
    {0x06, 0x63, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x82, 0x6e},
    {0x04, 0x2f, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x82, 0x6e},
    {0x09, 0x71, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x82, 0x7e},
    {0x01, 0x03, 0x43, 0xc2, 0x7e},
    {0x02, 0x0b, 0x43, 0x82, 0x7e},
    {0x05, 0x63, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x82, 0x6e},
    {0x04, 0x03, 0x43, 0xc2, 0x7e},
    {0x02, 0x05, 0x41, 0x82, 0x6e},
    {0x0a, 0x49, 0x43, 0xf5, 0xce},
    {0x03, 0x36, 0x46, 0xb5, 0xae},
    {0x01, 0x3b, 0x41, 0xf5, 0xbe},
    {0x02, 0x36, 0x46, 0xb5, 0xae},
    {0x06, 0xc2, 0x82, 0xb5, 0x0e},
    {0x03, 0x09, 0x43, 0x82, 0x7e},
    {0x04, 0x3b, 0x41, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x82, 0x7e},
    {0x07, 0x68, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xc2, 0x7e},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x82, 0xb5, 0x0e},
    {0x03, 0x06, 0x41, 0x82, 0x6e},
    {0x04, 0x05, 0x43, 0xc2, 0x7e},
    {0x02, 0x06, 0x41, 0x82, 0x6e},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x46, 0xb5, 0xae},
    {0x01, 0x29, 0x41, 0xf5, 0xbe},
    {0x02, 0x24, 0x46, 0xb5, 0xae},
    {0x06, 0x73, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x49, 0x03, 0xce},
    {0x04, 0x29, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x49, 0x03, 0xce},
    {0x08, 0x71, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x46, 0xb5, 0xae},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x46, 0xb5, 0xae},
    {0x05, 0x73, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x46, 0xb5, 0xae},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x46, 0xb5, 0xae},
    {0x06, 0x4f, 0x06, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0x82, 0x6e},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x82, 0x6e},
    {0x07, 0x50, 0x01, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x82, 0x6e},
    {0x01, 0x06, 0x43, 0xc2, 0x7e},
    {0x02, 0x02, 0x41, 0x82, 0x6e},
    {0x05, 0x4f, 0x06, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0x82, 0x6e},
    {0x04, 0x06, 0x43, 0xc2, 0x7e},
    {0x02, 0x07, 0x41, 0x82, 0x6e},
    {0xc6, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x41, 0xf5, 0xbe},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x7f, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x1f, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x4e, 0x43, 0xb5, 0xce},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x7f, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x49, 0x43, 0xf5, 0xce},
    {0x03, 0x2c, 0x46, 0xb5, 0xae},
    {0x01, 0x39, 0x41, 0xf5, 0xbe},
    {0x02, 0x2c, 0x46, 0xb5, 0xae},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x41, 0xf5, 0xbe},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xcd, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x82, 0x7e},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x82, 0x7e},
    {0x08, 0x4e, 0x43, 0xb5, 0xce},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xc2, 0x7e},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x49, 0x03, 0xce},
    {0x04, 0x04, 0x43, 0xc2, 0x7e},
    {0x02, 0x81, 0x49, 0x03, 0xce},
    {0x0c, 0x49, 0x43, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x82, 0x7e},
    {0x01, 0x02, 0x43, 0xc2, 0x7e},
    {0x02, 0x0a, 0x43, 0x82, 0x7e},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xc2, 0x7e},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xc2, 0x7e},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xc2, 0x7e},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0x82, 0xb5, 0x00, 0x0e},
    {0x03, 0x1e, 0x46, 0xb5, 0xae},
    {0x01, 0x16, 0x46, 0xf5, 0xae},
    {0x02, 0x1e, 0x46, 0xb5, 0xae},
    {0x06, 0x4d, 0x06, 0xb5, 0xae},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x46, 0xf5, 0xae},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x7d, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x06, 0xb5, 0xae},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xc8, 0xf5, 0x40, 0x0f},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x53, 0x03, 0xf5, 0xce},
    {0x03, 0x9a, 0x45, 0x03, 0xce},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x45, 0x03, 0xce},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x05, 0x03, 0xb5, 0xce},
    {0x03, 0x22, 0x46, 0xb5, 0xae},
    {0x01, 0x1a, 0x46, 0xf5, 0xae},
    {0x02, 0x22, 0x46, 0xb5, 0xae},
    {0x06, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xc8, 0xb5, 0x0f},
    {0x04, 0x1a, 0x46, 0xf5, 0xae},
    {0x02, 0x82, 0xc8, 0xb5, 0x0f},
    {0x08, 0x7d, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x46, 0xb5, 0xae},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x46, 0xb5, 0xae},
    {0x05, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x46, 0xb5, 0xae},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x46, 0xb5, 0xae},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x06, 0xf5, 0xae},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0x46, 0xb5, 0xae},
    {0x01, 0x25, 0x41, 0xf5, 0xbe},
    {0x02, 0x30, 0x46, 0xb5, 0xae},
    {0x06, 0x6b, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0x46, 0xb5, 0xae},
    {0x03, 0x3c, 0x46, 0xb5, 0xae},
    {0x01, 0x82, 0x45, 0x43, 0xce},
    {0x02, 0x3c, 0x46, 0xb5, 0xae},
    {0x05, 0x6b, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xc8, 0xf5, 0x40, 0x0f},
    {0x03, 0x2a, 0x46, 0xb5, 0xae},
    {0x01, 0x19, 0x46, 0xf5, 0xae},
    {0x02, 0x2a, 0x46, 0xb5, 0xae},
    {0x06, 0x51, 0x06, 0xb5, 0xae},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x46, 0xf5, 0xae},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x78, 0xb5, 0x40, 0xdd},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x06, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x46, 0xb5, 0xae},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x46, 0xb5, 0xae},
    {0x06, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x46, 0xb5, 0xae},
    {0x03, 0x3a, 0x46, 0xb5, 0xae},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x46, 0xb5, 0xae},
    {0x05, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc8, 0xb5, 0x0f},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xc8, 0xb5, 0x0f},
    {0x0c, 0xc8, 0xf5, 0x40, 0x0f},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xe5, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x06, 0xb5, 0xae},
    {0x03, 0x03, 0x44, 0x82, 0x6e},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x82, 0x6e},
    {0x09, 0x42, 0x46, 0xb5, 0xae},
    {0x03, 0x0b, 0x42, 0x82, 0x7e},
    {0x01, 0x03, 0x42, 0xc2, 0x7e},
    {0x02, 0x0b, 0x42, 0x82, 0x7e},
    {0x05, 0x41, 0x06, 0xb5, 0xae},
    {0x03, 0x05, 0x44, 0x82, 0x6e},
    {0x04, 0x03, 0x42, 0xc2, 0x7e},
    {0x02, 0x05, 0x44, 0x82, 0x6e},
    {0x0a, 0x46, 0x41, 0xf5, 0xbe},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x46, 0xf5, 0xae},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x82, 0x7e},
    {0x04, 0x12, 0x46, 0xf5, 0xae},
    {0x02, 0x09, 0x42, 0x82, 0x7e},
    {0x07, 0x4a, 0x06, 0xf5, 0xae},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0xc2, 0x7e},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x82, 0x6e},
    {0x04, 0x05, 0x42, 0xc2, 0x7e},
    {0x02, 0x06, 0x44, 0x82, 0x6e},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x46, 0xb5, 0xae},
    {0x01, 0x15, 0x46, 0xf5, 0xae},
    {0x02, 0x26, 0x46, 0xb5, 0xae},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x01, 0xbe},
    {0x04, 0x15, 0x46, 0xf5, 0xae},
    {0x02, 0x82, 0x46, 0x01, 0xbe},
    {0x08, 0x42, 0x46, 0xb5, 0xae},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x82, 0xb5, 0x0e},
    {0x03, 0x04, 0x44, 0x82, 0x6e},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x82, 0x6e},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x82, 0x6e},
    {0x01, 0x06, 0x42, 0xc2, 0x7e},
    {0x02, 0x02, 0x44, 0x82, 0x6e},
    {0x05, 0xc1, 0x82, 0xb5, 0x0e},
    {0x03, 0x07, 0x44, 0x82, 0x6e},
    {0x04, 0x06, 0x42, 0xc2, 0x7e},
    {0x02, 0x07, 0x44, 0x82, 0x6e},
    {0xc1, 0x46, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0x46, 0xb5, 0xae},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0x41, 0xf5, 0xbe},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0xc2, 0xf5, 0x0e},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0xc2, 0xf5, 0x0e},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0xc2, 0xb5, 0x0e},
    {0x01, 0x81, 0x45, 0x43, 0xce},
    {0x02, 0x84, 0xc2, 0xb5, 0x0e},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x82, 0x7e},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x82, 0x7e},
    {0x08, 0x47, 0x46, 0xb5, 0xae},
    {0x03, 0x83, 0x45, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0xc2, 0x7e},
    {0x02, 0x83, 0x45, 0x03, 0xce},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x01, 0xbe},
    {0x04, 0x04, 0x42, 0xc2, 0x7e},
    {0x02, 0x81, 0x46, 0x01, 0xbe},
    {0x0c, 0x46, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x82, 0x7e},
    {0x01, 0x02, 0x42, 0xc2, 0x7e},
    {0x02, 0x0a, 0x42, 0x82, 0x7e},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0xc2, 0x7e},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0xc2, 0x7e},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0xc2, 0x7e},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0xa2, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5d, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x4b, 0xb5, 0x6d},
    {0x04, 0xa2, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4b, 0xb5, 0x6d},
    {0x09, 0x6f, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x48, 0xb5, 0x7d},
    {0x01, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x0b, 0x48, 0xb5, 0x7d},
    {0x05, 0x5d, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x4b, 0xb5, 0x6d},
    {0x04, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x05, 0x4b, 0xb5, 0x6d},
    {0x0a, 0x64, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x48, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x48, 0xb5, 0x7d},
    {0x07, 0x6e, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4b, 0xb5, 0x6d},
    {0x04, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x06, 0x4b, 0xb5, 0x6d},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x64, 0xb5, 0xff},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x64, 0xb5, 0xff},
    {0x08, 0x6f, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4b, 0xb5, 0x6d},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0x4b, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4b, 0xb5, 0x6d},
    {0x01, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x4b, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4b, 0xb5, 0x6d},
    {0x04, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x4b, 0xb5, 0x6d},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x64, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0x48, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x48, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x64, 0xb5, 0xff},
    {0x04, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x81, 0x64, 0xb5, 0xff},
    {0x0c, 0x64, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x48, 0xb5, 0x7d},
    {0x01, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x0a, 0x48, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdf, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x7b, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x61, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x76, 0xb5, 0x40, 0xdd},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0x41, 0xf5, 0xbe},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x7b, 0xf5, 0x00, 0xee},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x9b, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7d, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0x41, 0xf5, 0xbe},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0x41, 0xf5, 0xbe},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc8, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0x41, 0xf5, 0xbe},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2e, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x69, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x6f, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x74, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x64, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x50, 0xb5, 0xee},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x50, 0xb5, 0xee},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x10, 0xb5, 0x00, 0xee},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0x41, 0xf5, 0xbe},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x74, 0xb5, 0xff},
    {0x04, 0x36, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x74, 0xb5, 0xff},
    {0x08, 0x69, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0x03, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x97, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0x41, 0xf5, 0xbe},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x10, 0x6e},
    {0x04, 0x24, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x10, 0x6e},
    {0x09, 0x50, 0x43, 0xb5, 0xce},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x50, 0xf5, 0xee},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x10, 0x6e},
    {0x04, 0x82, 0x50, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x10, 0x6e},
    {0x0b, 0x74, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0x41, 0xf5, 0xbe},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x34, 0x41, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x74, 0xb5, 0x40, 0xdd},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x10, 0x6e},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x10, 0x6e},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0x41, 0xf5, 0xbe},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x00, 0x41, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x50, 0x43, 0xb5, 0xce},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x74, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x74, 0xb5, 0xff},
    {0x0c, 0x74, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x10, 0x6e},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x10, 0x6e},
    {0x07, 0x4f, 0x01, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x10, 0x6e},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x10, 0x6e},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x10, 0x6e},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x10, 0x6e},
    {0xde, 0x41, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xd0, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x5f, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x4f, 0xf5, 0x40, 0xdd},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x40, 0xb5, 0x40, 0xdd},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0x41, 0xf5, 0xbe},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x4f, 0xb5, 0xdd},
    {0x04, 0x2c, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x4f, 0xb5, 0xdd},
    {0x08, 0xd0, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x91, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x10, 0x6e},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x10, 0x6e},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x10, 0x6e},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x10, 0x6e},
    {0x0b, 0x4f, 0xf5, 0x40, 0xdd},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x50, 0xf5, 0xee},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x10, 0x6e},
    {0x04, 0x81, 0x50, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x10, 0x6e},
    {0x4e, 0x10, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x50, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x50, 0xb5, 0xee},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x4f, 0xb5, 0xdd},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x4f, 0xb5, 0xdd},
    {0x0c, 0x4f, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x10, 0x6e},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x10, 0x6e},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x10, 0x6e},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x10, 0x6e},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x10, 0x6e},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x10, 0x6e},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x9e, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0x41, 0xf5, 0xbe},
    {0x02, 0x9e, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x5f, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x40, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x01, 0xf5, 0xbe},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x40, 0xb5, 0xff},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x40, 0xb5, 0xff},
    {0x08, 0x5f, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x0f, 0xb5, 0x40, 0xff},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x4f, 0xf5, 0xff},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x4f, 0xf5, 0xff},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0x8d, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x41, 0xf5, 0xbe},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x22, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x48, 0x41, 0xb5, 0xbe},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x40, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0x41, 0xf5, 0xbe},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x41, 0xf5, 0xbe},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0xd9, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x41, 0xf5, 0xbe},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x41, 0xf5, 0xbe},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x41, 0xb5, 0xbe},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x40, 0xb5, 0xff},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x40, 0xb5, 0xff},
    {0x0c, 0x40, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe3, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0x41, 0xf5, 0xbe},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x0f, 0x6f},
    {0x04, 0x30, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x0f, 0x6f},
    {0x09, 0x79, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x0f, 0x7f},
    {0x01, 0x03, 0x43, 0x4f, 0x7f},
    {0x02, 0x0b, 0x43, 0x0f, 0x7f},
    {0x05, 0x65, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x0f, 0x6f},
    {0x04, 0x03, 0x43, 0x4f, 0x7f},
    {0x02, 0x05, 0x41, 0x0f, 0x6f},
    {0x0a, 0x44, 0x41, 0xf5, 0xbe},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0x41, 0xf5, 0xbe},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x0f, 0xb5, 0xff},
    {0x03, 0x09, 0x43, 0x0f, 0x7f},
    {0x04, 0x3c, 0x41, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x0f, 0x7f},
    {0x07, 0x6c, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x4f, 0x7f},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x0f, 0xb5, 0xff},
    {0x03, 0x06, 0x41, 0x0f, 0x6f},
    {0x04, 0x05, 0x43, 0x4f, 0x7f},
    {0x02, 0x06, 0x41, 0x0f, 0x6f},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0x41, 0xf5, 0xbe},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0x01, 0xb5, 0xbe},
    {0x03, 0x82, 0x44, 0x01, 0xbe},
    {0x04, 0x2a, 0x41, 0xf5, 0xbe},
    {0x02, 0x82, 0x44, 0x01, 0xbe},
    {0x08, 0x79, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0x01, 0xb5, 0xbe},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x0f, 0x6f},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x0f, 0x6f},
    {0x07, 0x51, 0x01, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x0f, 0x6f},
    {0x01, 0x06, 0x43, 0x4f, 0x7f},
    {0x02, 0x02, 0x41, 0x0f, 0x6f},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x0f, 0x6f},
    {0x04, 0x06, 0x43, 0x4f, 0x7f},
    {0x02, 0x07, 0x41, 0x0f, 0x6f},
    {0x89, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x41, 0xf5, 0xbe},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x20, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x44, 0x41, 0xf5, 0xbe},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0x41, 0xf5, 0xbe},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x41, 0xf5, 0xbe},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xd5, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x0f, 0x7f},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x0f, 0x7f},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x4f, 0x7f},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x01, 0xbe},
    {0x04, 0x04, 0x43, 0x4f, 0x7f},
    {0x02, 0x81, 0x44, 0x01, 0xbe},
    {0x0c, 0x44, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0x0f, 0x7f},
    {0x01, 0x02, 0x43, 0x4f, 0x7f},
    {0x02, 0x0a, 0x43, 0x0f, 0x7f},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x4f, 0x7f},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x4f, 0x7f},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x4f, 0x7f},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x4f, 0xf5, 0x40, 0x0f},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x4a, 0x41, 0xb5, 0xbe},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0x42, 0x41, 0xf5, 0xbe},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x41, 0x01, 0xf5, 0xbe},
    {0x03, 0x9a, 0x46, 0x03, 0xce},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x46, 0x03, 0xce},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x06, 0x03, 0xb5, 0xce},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0x01, 0xb5, 0xbe},
    {0x03, 0x82, 0x42, 0x01, 0xbe},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x01, 0xbe},
    {0x08, 0x4a, 0x41, 0xb5, 0xbe},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0x01, 0xb5, 0xbe},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0x41, 0xf5, 0xbe},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0x01, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0x41, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0x43, 0xce},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0x01, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0x41, 0xf5, 0xbe},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x01, 0xbe},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0x42, 0x01, 0xbe},
    {0x0c, 0x42, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xe7, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x0f, 0x6f},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x0f, 0x6f},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x0f, 0x7f},
    {0x01, 0x03, 0x42, 0x4f, 0x7f},
    {0x02, 0x0b, 0x42, 0x0f, 0x7f},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x0f, 0x6f},
    {0x04, 0x03, 0x42, 0x4f, 0x7f},
    {0x02, 0x05, 0x44, 0x0f, 0x6f},
    {0x0a, 0x47, 0x41, 0xf5, 0xbe},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x0f, 0x7f},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x0f, 0x7f},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x4f, 0x7f},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x0f, 0x6f},
    {0x04, 0x05, 0x42, 0x4f, 0x7f},
    {0x02, 0x06, 0x44, 0x0f, 0x6f},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x47, 0x01, 0xbe},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x01, 0xbe},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x0f, 0xb5, 0xff},
    {0x03, 0x04, 0x44, 0x0f, 0x6f},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x0f, 0x6f},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x0f, 0x6f},
    {0x01, 0x06, 0x42, 0x4f, 0x7f},
    {0x02, 0x02, 0x44, 0x0f, 0x6f},
    {0x05, 0xc1, 0x0f, 0xb5, 0xff},
    {0x03, 0x07, 0x44, 0x0f, 0x6f},
    {0x04, 0x06, 0x42, 0x4f, 0x7f},
    {0x02, 0x07, 0x44, 0x0f, 0x6f},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0x41, 0xf5, 0xbe},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x4f, 0xf5, 0xff},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x4f, 0xf5, 0xff},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x4f, 0xb5, 0xff},
    {0x01, 0x81, 0x46, 0x43, 0xce},
    {0x02, 0x84, 0x4f, 0xb5, 0xff},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x0f, 0x7f},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x0f, 0x7f},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0x4f, 0x7f},
    {0x02, 0x83, 0x46, 0x03, 0xce},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x47, 0x01, 0xbe},
    {0x04, 0x04, 0x42, 0x4f, 0x7f},
    {0x02, 0x81, 0x47, 0x01, 0xbe},
    {0x0c, 0x47, 0x41, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x0f, 0x7f},
    {0x01, 0x02, 0x42, 0x4f, 0x7f},
    {0x02, 0x0a, 0x42, 0x0f, 0x7f},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0x4f, 0x7f},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0x4f, 0x7f},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0x4f, 0x7f},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xde, 0xb5, 0x00, 0x0f},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x56, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xde, 0xb5, 0x00, 0x0f},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x4d, 0xf5, 0x40, 0xdd},
    {0x03, 0x0c, 0x47, 0xb5, 0x8d},
    {0x01, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x0c, 0x47, 0xb5, 0x8d},
    {0x06, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0x5e, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x45, 0xb5, 0x9d},
    {0x01, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x14, 0x45, 0xb5, 0x9d},
    {0x06, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x82, 0x4d, 0xb5, 0xdd},
    {0x04, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x82, 0x4d, 0xb5, 0xdd},
    {0x08, 0x56, 0xf5, 0x00, 0xdd},
    {0x03, 0x18, 0x45, 0xb5, 0x9d},
    {0x01, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x18, 0x45, 0xb5, 0x9d},
    {0x05, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x0e, 0x47, 0xb5, 0x8d},
    {0x04, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x0e, 0x47, 0xb5, 0x8d},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x45, 0xb5, 0x9d},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x45, 0xb5, 0x9d},
    {0x06, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x45, 0xb5, 0x9d},
    {0x01, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x17, 0x45, 0xb5, 0x9d},
    {0x06, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x1b, 0x45, 0xb5, 0x9d},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x45, 0xb5, 0x9d},
    {0x05, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x4d, 0xf5, 0x40, 0xdd},
    {0x03, 0x27, 0x44, 0xb5, 0xad},
    {0x01, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x27, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x10, 0x47, 0xb5, 0x8d},
    {0x04, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x47, 0xb5, 0x8d},
    {0x07, 0x4b, 0x04, 0xf5, 0xad},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x45, 0xb5, 0x9d},
    {0x01, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x13, 0x45, 0xb5, 0x9d},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x37, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0x44, 0xb5, 0xad},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x4d, 0xb5, 0xdd},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0x4d, 0xb5, 0xdd},
    {0x0c, 0x4d, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x44, 0xb5, 0xad},
    {0x01, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x2d, 0x44, 0xb5, 0xad},
    {0x06, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x35, 0x44, 0xb5, 0xad},
    {0x01, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x35, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x02, 0xf5, 0xbd},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x44, 0xb5, 0xad},
    {0x01, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x44, 0xb5, 0xad},
    {0x06, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x02, 0xbd},
    {0x04, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x02, 0xbd},
    {0x08, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x33, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x33, 0x44, 0xb5, 0xad},
    {0x05, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x47, 0xb5, 0x8d},
    {0x04, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x47, 0xb5, 0x8d},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x44, 0xb5, 0xad},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x44, 0xb5, 0xad},
    {0x06, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0x47, 0xb5, 0x8d},
    {0x01, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x0d, 0x47, 0xb5, 0x8d},
    {0x06, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x2b, 0x44, 0xb5, 0xad},
    {0x01, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x11, 0x47, 0xb5, 0x8d},
    {0x04, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x47, 0xb5, 0x8d},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x47, 0xb5, 0x8d},
    {0x01, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x01, 0x47, 0xb5, 0x8d},
    {0x06, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x81, 0x43, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x02, 0xbd},
    {0x0c, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x44, 0xb5, 0xad},
    {0x01, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x44, 0xb5, 0xad},
    {0x06, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x5a, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x62, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x48, 0xb5, 0xdd},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x48, 0xb5, 0xdd},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x08, 0xb5, 0x00, 0xdd},
    {0x03, 0x21, 0x44, 0xb5, 0xad},
    {0x01, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x44, 0xb5, 0xad},
    {0x06, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0x5a, 0xf5, 0x00, 0xdd},
    {0x03, 0x31, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x44, 0xb5, 0xad},
    {0x05, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc3, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x44, 0xb5, 0xad},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x95, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x2f, 0x44, 0xb5, 0xad},
    {0x01, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x44, 0xb5, 0xad},
    {0x06, 0x68, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x08, 0x6d},
    {0x04, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x08, 0x6d},
    {0x09, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x3b, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0x48, 0xf5, 0xdd},
    {0x02, 0x3b, 0x44, 0xb5, 0xad},
    {0x05, 0x68, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x08, 0x6d},
    {0x04, 0x82, 0x48, 0xf5, 0xdd},
    {0x02, 0x05, 0x43, 0x08, 0x6d},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x29, 0x44, 0xb5, 0xad},
    {0x01, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x44, 0xb5, 0xad},
    {0x06, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x72, 0xb5, 0x40, 0xdd},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x08, 0x6d},
    {0x04, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x08, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x44, 0xb5, 0xad},
    {0x01, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x44, 0xb5, 0xad},
    {0x06, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x39, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x44, 0xb5, 0xad},
    {0x05, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x08, 0x6d},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x08, 0x6d},
    {0x07, 0x4e, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x08, 0x6d},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x08, 0x6d},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x08, 0x6d},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x08, 0x6d},
    {0xdd, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x45, 0xb5, 0x9d},
    {0x01, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x16, 0x45, 0xb5, 0x9d},
    {0x06, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xcc, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x45, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x45, 0xb5, 0x9d},
    {0x06, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7e, 0xb5, 0x40, 0xdd},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x44, 0xb5, 0xad},
    {0x01, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x44, 0xb5, 0xad},
    {0x06, 0x78, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x02, 0xbd},
    {0x04, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x02, 0xbd},
    {0x08, 0xcc, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x45, 0xb5, 0x9d},
    {0x01, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x19, 0x45, 0xb5, 0x9d},
    {0x05, 0x78, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0x8f, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x08, 0x6d},
    {0x04, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x08, 0x6d},
    {0x09, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x45, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x45, 0xb5, 0x9d},
    {0x05, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x08, 0x6d},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x08, 0x6d},
    {0x0b, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x45, 0xb5, 0x9d},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x45, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x05, 0xf5, 0x9d},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x48, 0xf5, 0xdd},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x08, 0x6d},
    {0x04, 0x81, 0x48, 0xf5, 0xdd},
    {0x02, 0x06, 0x42, 0x08, 0x6d},
    {0x4e, 0x08, 0xb5, 0x00, 0xdd},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0x48, 0xb5, 0xdd},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x48, 0xb5, 0xdd},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x02, 0xbd},
    {0x0c, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x08, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x08, 0x6d},
    {0x07, 0x47, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x08, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x08, 0x6d},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x08, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x08, 0x6d},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa3, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0xa3, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x65, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6e, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x6c, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x70, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x6c, 0xb5, 0xff},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x6c, 0xb5, 0xff},
    {0x08, 0x65, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x04, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x44, 0xf5, 0xdd},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x44, 0xf5, 0xdd},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0x8b, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x76, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x76, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x6c, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x44, 0xb5, 0xad},
    {0x01, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x7c, 0xb5, 0x40, 0xdd},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x44, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x6c, 0xb5, 0xff},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x6c, 0xb5, 0xff},
    {0x0c, 0x6c, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe2, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x44, 0xb5, 0xad},
    {0x01, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x44, 0xb5, 0xad},
    {0x06, 0x64, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x04, 0x6d},
    {0x04, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x04, 0x6d},
    {0x09, 0x59, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x43, 0x04, 0x7d},
    {0x01, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x0b, 0x43, 0x04, 0x7d},
    {0x05, 0x64, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x04, 0x6d},
    {0x04, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x05, 0x41, 0x04, 0x6d},
    {0x0a, 0x51, 0xf5, 0x40, 0xdd},
    {0x03, 0x36, 0x44, 0xb5, 0xad},
    {0x01, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0x04, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x04, 0x7d},
    {0x04, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x04, 0x7d},
    {0x07, 0x6a, 0xb5, 0x40, 0xdd},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x04, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x04, 0x6d},
    {0x04, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x06, 0x41, 0x04, 0x6d},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x44, 0xb5, 0xad},
    {0x01, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x44, 0xb5, 0xad},
    {0x06, 0x74, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x51, 0xb5, 0xdd},
    {0x04, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x51, 0xb5, 0xdd},
    {0x08, 0x59, 0xf5, 0x00, 0xdd},
    {0x03, 0x34, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x44, 0xb5, 0xad},
    {0x05, 0x74, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x44, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x44, 0xb5, 0xad},
    {0x06, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x04, 0x6d},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x04, 0x6d},
    {0x07, 0x50, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x04, 0x6d},
    {0x01, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x41, 0x04, 0x6d},
    {0x05, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x04, 0x6d},
    {0x04, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x41, 0x04, 0x6d},
    {0xc7, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x40, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x4f, 0x43, 0xb5, 0xce},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x40, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x51, 0xf5, 0x40, 0xdd},
    {0x03, 0x2c, 0x44, 0xb5, 0xad},
    {0x01, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xd1, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x04, 0x7d},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x04, 0x7d},
    {0x08, 0x4f, 0x43, 0xb5, 0xce},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x51, 0xb5, 0xdd},
    {0x04, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x81, 0x51, 0xb5, 0xdd},
    {0x0c, 0x51, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x43, 0x04, 0x7d},
    {0x01, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x0a, 0x43, 0x04, 0x7d},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x44, 0xb5, 0x40, 0x0d},
    {0x03, 0x1e, 0x44, 0xb5, 0xad},
    {0x01, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x1e, 0x44, 0xb5, 0xad},
    {0x06, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0xc5, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x60, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x22, 0x44, 0xb5, 0xad},
    {0x01, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x22, 0x44, 0xb5, 0xad},
    {0x06, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0xc5, 0xf5, 0x00, 0x0e},
    {0x03, 0x32, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x44, 0xb5, 0xad},
    {0x05, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x44, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x99, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x30, 0x44, 0xb5, 0xad},
    {0x01, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x44, 0xb5, 0xad},
    {0x06, 0x6c, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x81, 0x6d},
    {0x04, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x81, 0x6d},
    {0x09, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3c, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x3c, 0x44, 0xb5, 0xad},
    {0x05, 0x6c, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x81, 0x6d},
    {0x04, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x81, 0x6d},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x2a, 0x44, 0xb5, 0xad},
    {0x01, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x2a, 0x44, 0xb5, 0xad},
    {0x06, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x7a, 0xb5, 0x40, 0xdd},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x81, 0x6d},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x81, 0x6d},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x44, 0xb5, 0xad},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x44, 0xb5, 0xad},
    {0x06, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3a, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x44, 0xb5, 0xad},
    {0x05, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x81, 0x6d},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x81, 0x6d},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x81, 0x6d},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x81, 0x6d},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x81, 0x6d},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x81, 0x6d},
    {0xe6, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x04, 0x6d},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x04, 0x6d},
    {0x09, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x04, 0x7d},
    {0x01, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x0b, 0x42, 0x04, 0x7d},
    {0x05, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x04, 0x6d},
    {0x04, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x05, 0x44, 0x04, 0x6d},
    {0x0a, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x04, 0x7d},
    {0x04, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x04, 0x7d},
    {0x07, 0x4a, 0x04, 0xf5, 0xad},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x04, 0x6d},
    {0x04, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x06, 0x44, 0x04, 0x6d},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x44, 0xb5, 0xad},
    {0x01, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x26, 0x44, 0xb5, 0xad},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x02, 0xbd},
    {0x04, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x02, 0xbd},
    {0x08, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x04, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x04, 0x6d},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x04, 0x6d},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x04, 0x6d},
    {0x01, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x44, 0x04, 0x6d},
    {0x05, 0xc1, 0x04, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x04, 0x6d},
    {0x04, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x44, 0x04, 0x6d},
    {0xc1, 0x44, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x81, 0x6d},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x81, 0x6d},
    {0x09, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x81, 0x6d},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x81, 0x6d},
    {0x0b, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x44, 0xf5, 0xdd},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x44, 0xf5, 0xdd},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x44, 0xb5, 0xdd},
    {0x01, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x84, 0x44, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x81, 0x6d},
    {0x04, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x81, 0x6d},
    {0x4e, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x04, 0x7d},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x04, 0x7d},
    {0x08, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0xc1, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x83, 0xc1, 0xb5, 0x0d},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x81, 0x46, 0x02, 0xbd},
    {0x0c, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x04, 0x7d},
    {0x01, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x0a, 0x42, 0x04, 0x7d},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x81, 0x6d},
    {0x04, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0x81, 0x6d},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x81, 0x6d},
    {0x01, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0x81, 0x6d},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x81, 0x6d},
    {0x04, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0x81, 0x6d},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0xa6, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5e, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x4c, 0xb5, 0x6d},
    {0x04, 0xa6, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4c, 0xb5, 0x6d},
    {0x09, 0x4d, 0x43, 0xb5, 0xce},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x4c, 0xb5, 0x6d},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0x4c, 0xb5, 0x6d},
    {0x0a, 0x41, 0xf5, 0x40, 0xdd},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0x03, 0xf5, 0xce},
    {0x03, 0x9a, 0x4a, 0xb5, 0xdd},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0x4a, 0xb5, 0xdd},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x4c, 0xb5, 0x6d},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0x4c, 0xb5, 0x6d},
    {0x4d, 0x0a, 0xb5, 0x00, 0xdd},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x41, 0xb5, 0xdd},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x41, 0xb5, 0xdd},
    {0x08, 0x4d, 0x43, 0xb5, 0xce},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0x02, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0x42, 0xf5, 0xdd},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x4c, 0xb5, 0x6d},
    {0x04, 0x9a, 0x42, 0xf5, 0xdd},
    {0x02, 0x04, 0x4c, 0xb5, 0x6d},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x4c, 0xb5, 0x6d},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x4c, 0xb5, 0x6d},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x4c, 0xb5, 0x6d},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x4c, 0xb5, 0x6d},
    {0x52, 0x06, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x0a, 0x6d},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x0a, 0x6d},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0x4a, 0xf5, 0xdd},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x0a, 0x6d},
    {0x04, 0x82, 0x4a, 0xf5, 0xdd},
    {0x02, 0x05, 0x43, 0x0a, 0x6d},
    {0x0b, 0x41, 0xf5, 0x40, 0xdd},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0x46, 0xb5, 0xee},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0x46, 0xb5, 0xee},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x0a, 0x6d},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x0a, 0x6d},
    {0x51, 0x06, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0x06, 0xb5, 0xee},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0x06, 0xb5, 0xee},
    {0x03, 0x81, 0x41, 0xb5, 0xdd},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x41, 0xb5, 0xdd},
    {0x0c, 0x41, 0xf5, 0x40, 0xdd},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x0a, 0x6d},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0x0a, 0x6d},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x0a, 0x6d},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0x0a, 0x6d},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x0a, 0x6d},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0x0a, 0x6d},
    {0xe0, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x02, 0x6d},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0x02, 0x6d},
    {0x09, 0x52, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x43, 0x02, 0x7d},
    {0x01, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x0b, 0x43, 0x02, 0x7d},
    {0x05, 0x62, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x02, 0x6d},
    {0x04, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x05, 0x41, 0x02, 0x6d},
    {0x0a, 0x48, 0x43, 0xf5, 0xce},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x02, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x02, 0x7d},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0x02, 0x7d},
    {0x07, 0x5a, 0x03, 0xf5, 0xce},
    {0x03, 0x87, 0x46, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x87, 0x46, 0xb5, 0xee},
    {0x05, 0xc2, 0x02, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x02, 0x6d},
    {0x04, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x06, 0x41, 0x02, 0x6d},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0x48, 0x03, 0xce},
    {0x04, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0x03, 0xce},
    {0x08, 0x52, 0xf5, 0x00, 0xdd},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x02, 0x6d},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x02, 0x6d},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0x02, 0x6d},
    {0x01, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x41, 0x02, 0x6d},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x02, 0x6d},
    {0x04, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x41, 0x02, 0x6d},
    {0xc5, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x0a, 0x6d},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x0a, 0x6d},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7e, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x0a, 0x6d},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x0a, 0x6d},
    {0x0b, 0x48, 0x43, 0xf5, 0xce},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xca, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4a, 0xf5, 0xdd},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x0a, 0x6d},
    {0x04, 0x81, 0x4a, 0xf5, 0xdd},
    {0x02, 0x06, 0x42, 0x0a, 0x6d},
    {0x4e, 0x0a, 0xb5, 0x00, 0xdd},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0x02, 0x7d},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0x02, 0x7d},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x4a, 0xb5, 0xdd},
    {0x01, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x83, 0x4a, 0xb5, 0xdd},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0x03, 0xce},
    {0x04, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x81, 0x48, 0x03, 0xce},
    {0x0c, 0x48, 0x43, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x02, 0x7d},
    {0x01, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x0a, 0x43, 0x02, 0x7d},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x0a, 0x6d},
    {0x04, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x0a, 0x6d},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x0a, 0x6d},
    {0x01, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x0a, 0x6d},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x0a, 0x6d},
    {0x04, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x0a, 0x6d},
    {0xf4, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0x06, 0x6e},
    {0x04, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x06, 0x6e},
    {0x09, 0x55, 0xf5, 0x00, 0xdd},
    {0x03, 0x0b, 0x41, 0x06, 0x7e},
    {0x01, 0x03, 0x41, 0x46, 0x7e},
    {0x02, 0x0b, 0x41, 0x06, 0x7e},
    {0x05, 0x70, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0x06, 0x6e},
    {0x04, 0x03, 0x41, 0x46, 0x7e},
    {0x02, 0x05, 0x46, 0x06, 0x6e},
    {0x0a, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x43, 0x06, 0x8e},
    {0x01, 0x0b, 0x43, 0x46, 0x8e},
    {0x02, 0x0c, 0x43, 0x06, 0x8e},
    {0x06, 0x43, 0x03, 0x06, 0x8e},
    {0x03, 0x09, 0x41, 0x06, 0x7e},
    {0x04, 0x0b, 0x43, 0x46, 0x8e},
    {0x02, 0x09, 0x41, 0x06, 0x7e},
    {0x07, 0x66, 0xb5, 0x40, 0xdd},
    {0x03, 0x9a, 0x44, 0x03, 0xce},
    {0x01, 0x05, 0x41, 0x46, 0x7e},
    {0x02, 0x9a, 0x44, 0x03, 0xce},
    {0x05, 0x43, 0x03, 0x06, 0x8e},
    {0x03, 0x06, 0x46, 0x06, 0x6e},
    {0x04, 0x05, 0x41, 0x46, 0x7e},
    {0x02, 0x06, 0x46, 0x06, 0x6e},
    {0x4d, 0x04, 0x03, 0xb5, 0xce},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0xc3, 0xb5, 0x0d},
    {0x04, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc3, 0xb5, 0x0d},
    {0x08, 0x55, 0xf5, 0x00, 0xdd},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x46, 0x8e},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0x03, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0x06, 0x8e},
    {0x04, 0x09, 0x43, 0x46, 0x8e},
    {0x02, 0x0e, 0x43, 0x06, 0x8e},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x06, 0x8e},
    {0x03, 0x04, 0x46, 0x06, 0x6e},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x06, 0x6e},
    {0x07, 0xc2, 0x06, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x06, 0x6e},
    {0x01, 0x06, 0x41, 0x46, 0x7e},
    {0x02, 0x02, 0x46, 0x06, 0x6e},
    {0x05, 0x45, 0x03, 0x06, 0x8e},
    {0x03, 0x07, 0x46, 0x06, 0x6e},
    {0x04, 0x06, 0x41, 0x46, 0x7e},
    {0x02, 0x07, 0x46, 0x06, 0x6e},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0x43, 0xb5, 0xce},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0x43, 0xce},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x06, 0x8e},
    {0x04, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x06, 0x8e},
    {0x07, 0x59, 0x03, 0xf5, 0xce},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x06, 0x7e},
    {0x04, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x06, 0x7e},
    {0x08, 0x51, 0x43, 0xb5, 0xce},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x46, 0x7e},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc3, 0xb5, 0x0d},
    {0x04, 0x04, 0x41, 0x46, 0x7e},
    {0x02, 0x81, 0xc3, 0xb5, 0x0d},
    {0x0c, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x41, 0x06, 0x7e},
    {0x01, 0x02, 0x41, 0x46, 0x7e},
    {0x02, 0x0a, 0x41, 0x06, 0x7e},
    {0x06, 0x46, 0x03, 0x06, 0x8e},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0x46, 0x7e},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0x46, 0x7e},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0x06, 0x8e},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0x46, 0x7e},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0x02, 0x6d},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0x02, 0x6d},
    {0x09, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x0b, 0x42, 0x02, 0x7d},
    {0x01, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x0b, 0x42, 0x02, 0x7d},
    {0x05, 0x60, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0x02, 0x6d},
    {0x04, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x05, 0x44, 0x02, 0x6d},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0x02, 0x7d},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x02, 0x7d},
    {0x07, 0xc6, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0x02, 0x6d},
    {0x04, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x06, 0x44, 0x02, 0x6d},
    {0xc4, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0x03, 0xb5, 0xce},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0x03, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x06, 0x8e},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x06, 0x8e},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x46, 0xb5, 0xee},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x46, 0xb5, 0xee},
    {0x06, 0xc1, 0x02, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x02, 0x6d},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x02, 0x6d},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0x02, 0x6d},
    {0x01, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x44, 0x02, 0x6d},
    {0x05, 0xc1, 0x02, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x02, 0x6d},
    {0x04, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x44, 0x02, 0x6d},
    {0x93, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0x0d, 0x43, 0x06, 0x8e},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x06, 0x8e},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x46, 0x8e},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0x46, 0x8e},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0x42, 0xf5, 0xdd},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x06, 0x8e},
    {0x03, 0x11, 0x43, 0x06, 0x8e},
    {0x04, 0x83, 0x42, 0xf5, 0xdd},
    {0x02, 0x11, 0x43, 0x06, 0x8e},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0x42, 0xb5, 0xdd},
    {0x01, 0x81, 0x44, 0x43, 0xce},
    {0x02, 0x84, 0x42, 0xb5, 0xdd},
    {0x05, 0x44, 0x03, 0x06, 0x8e},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0x06, 0x8e},
    {0x01, 0x0a, 0x43, 0x46, 0x8e},
    {0x02, 0x01, 0x43, 0x06, 0x8e},
    {0x06, 0x42, 0x03, 0x06, 0x8e},
    {0x03, 0x08, 0x42, 0x02, 0x7d},
    {0x04, 0x0a, 0x43, 0x46, 0x8e},
    {0x02, 0x08, 0x42, 0x02, 0x7d},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x83, 0x44, 0x03, 0xce},
    {0x05, 0x42, 0x03, 0x06, 0x8e},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0x02, 0x7d},
    {0x01, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x0a, 0x42, 0x02, 0x7d},
    {0x06, 0x47, 0x03, 0x06, 0x8e},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0x06, 0x8e},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xf4, 0x46, 0xf5, 0x00, 0x0e},
    {0x03, 0xa7, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0xa7, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x41, 0x43, 0xb5, 0xce},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x4a, 0x43, 0xf5, 0xce},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0x03, 0xce},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0x42, 0x03, 0xce},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0x02, 0x03, 0xb5, 0xce},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x4a, 0x03, 0xce},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x4a, 0x03, 0xce},
    {0x08, 0x41, 0x43, 0xb5, 0xce},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x07, 0xb5, 0x40, 0xdd},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x47, 0xf5, 0xdd},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x47, 0xf5, 0xdd},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0x42, 0x43, 0xce},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0x43, 0xf5, 0xce},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0x52, 0x03, 0xf5, 0xce},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0x03, 0xce},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x4a, 0x03, 0xce},
    {0x0c, 0x4a, 0x43, 0xf5, 0xce},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xe4, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0x03, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x07, 0x6d},
    {0x04, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x07, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x07, 0x7d},
    {0x01, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x0b, 0x43, 0x07, 0x7d},
    {0x05, 0x66, 0x03, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x07, 0x6d},
    {0x04, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x05, 0x41, 0x07, 0x6d},
    {0x0a, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x07, 0xb5, 0xdd},
    {0x03, 0x09, 0x43, 0x07, 0x7d},
    {0x04, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x07, 0x7d},
    {0x07, 0x55, 0x03, 0xf5, 0xce},
    {0x03, 0x88, 0x46, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x88, 0x46, 0xb5, 0xee},
    {0x05, 0xc2, 0x07, 0xb5, 0xdd},
    {0x03, 0x06, 0x41, 0x07, 0x6d},
    {0x04, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x06, 0x41, 0x07, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x02, 0xbd},
    {0x04, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x02, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x07, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x07, 0x6d},
    {0x07, 0x51, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x07, 0x6d},
    {0x01, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x41, 0x07, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x07, 0x6d},
    {0x04, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x41, 0x07, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x42, 0x43, 0xce},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x07, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x07, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0x42, 0x03, 0xce},
    {0x01, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x83, 0x42, 0x03, 0xce},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x81, 0x44, 0x02, 0xbd},
    {0x0c, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x07, 0x7d},
    {0x01, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x0a, 0x43, 0x07, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x47, 0xb5, 0x40, 0x0d},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x06, 0x6e},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x06, 0x6e},
    {0x09, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0x06, 0x7e},
    {0x01, 0x03, 0x44, 0x46, 0x7e},
    {0x02, 0x0b, 0x44, 0x06, 0x7e},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x06, 0x6e},
    {0x04, 0x03, 0x44, 0x46, 0x7e},
    {0x02, 0x05, 0x45, 0x06, 0x6e},
    {0x0a, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0x06, 0x8e},
    {0x01, 0x0b, 0x42, 0x46, 0x8e},
    {0x02, 0x0c, 0x42, 0x06, 0x8e},
    {0x06, 0x43, 0x02, 0x06, 0x8e},
    {0x03, 0x09, 0x44, 0x06, 0x7e},
    {0x04, 0x0b, 0x42, 0x46, 0x8e},
    {0x02, 0x09, 0x44, 0x06, 0x7e},
    {0x07, 0x41, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0x03, 0xce},
    {0x01, 0x05, 0x44, 0x46, 0x7e},
    {0x02, 0x9a, 0x47, 0x03, 0xce},
    {0x05, 0x43, 0x02, 0x06, 0x8e},
    {0x03, 0x06, 0x45, 0x06, 0x6e},
    {0x04, 0x05, 0x44, 0x46, 0x7e},
    {0x02, 0x06, 0x45, 0x06, 0x6e},
    {0x4d, 0x07, 0x03, 0xb5, 0xce},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x02, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x02, 0xbd},
    {0x08, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x46, 0x8e},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0x06, 0x8e},
    {0x04, 0x09, 0x42, 0x46, 0x8e},
    {0x02, 0x0e, 0x42, 0x06, 0x8e},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x06, 0x8e},
    {0x03, 0x04, 0x45, 0x06, 0x6e},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x06, 0x6e},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x06, 0x6e},
    {0x01, 0x06, 0x44, 0x46, 0x7e},
    {0x02, 0x02, 0x45, 0x06, 0x6e},
    {0x05, 0x45, 0x02, 0x06, 0x8e},
    {0x03, 0x07, 0x45, 0x06, 0x6e},
    {0x04, 0x06, 0x44, 0x46, 0x7e},
    {0x02, 0x07, 0x45, 0x06, 0x6e},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0x43, 0xce},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0x43, 0xce},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x06, 0x8e},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x06, 0x8e},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x06, 0x7e},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x06, 0x7e},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x46, 0x7e},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x02, 0xbd},
    {0x04, 0x04, 0x44, 0x46, 0x7e},
    {0x02, 0x81, 0x42, 0x02, 0xbd},
    {0x0c, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0x06, 0x7e},
    {0x01, 0x02, 0x44, 0x46, 0x7e},
    {0x02, 0x0a, 0x44, 0x06, 0x7e},
    {0x06, 0x46, 0x02, 0x06, 0x8e},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0x46, 0x7e},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0x06, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0x46, 0x7e},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0x06, 0x8e},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0x46, 0x7e},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xe8, 0x43, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x07, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x07, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x07, 0x7d},
    {0x01, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x0b, 0x42, 0x07, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x07, 0x6d},
    {0x04, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x05, 0x44, 0x07, 0x6d},
    {0x0a, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x07, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x07, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0x46, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x8a, 0x46, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x07, 0x6d},
    {0x04, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x06, 0x44, 0x07, 0x6d},
    {0x50, 0x06, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0x06, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x02, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x02, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x06, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x06, 0x8e},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x06, 0x8e},
    {0x40, 0x06, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x46, 0xb5, 0xee},
    {0x01, 0x84, 0x46, 0xf5, 0xee},
    {0x02, 0x86, 0x46, 0xb5, 0xee},
    {0x06, 0xc1, 0x07, 0xb5, 0xdd},
    {0x03, 0x04, 0x44, 0x07, 0x6d},
    {0x04, 0x84, 0x46, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x07, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x07, 0x6d},
    {0x01, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x44, 0x07, 0x6d},
    {0x05, 0xc1, 0x07, 0xb5, 0xdd},
    {0x03, 0x07, 0x44, 0x07, 0x6d},
    {0x04, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x44, 0x07, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x06, 0x8e},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x06, 0x8e},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0x46, 0x8e},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0x46, 0x8e},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x47, 0xf5, 0xdd},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x06, 0x8e},
    {0x03, 0x11, 0x42, 0x06, 0x8e},
    {0x04, 0x83, 0x47, 0xf5, 0xdd},
    {0x02, 0x11, 0x42, 0x06, 0x8e},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x47, 0xb5, 0xdd},
    {0x01, 0x81, 0x47, 0x43, 0xce},
    {0x02, 0x84, 0x47, 0xb5, 0xdd},
    {0x05, 0x44, 0x02, 0x06, 0x8e},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x43, 0xce},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x03, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x06, 0x8e},
    {0x01, 0x0a, 0x42, 0x46, 0x8e},
    {0x02, 0x01, 0x42, 0x06, 0x8e},
    {0x06, 0x42, 0x02, 0x06, 0x8e},
    {0x03, 0x08, 0x42, 0x07, 0x7d},
    {0x04, 0x0a, 0x42, 0x46, 0x8e},
    {0x02, 0x08, 0x42, 0x07, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x03, 0xce},
    {0x01, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x83, 0x47, 0x03, 0xce},
    {0x05, 0x42, 0x02, 0x06, 0x8e},
    {0x03, 0x81, 0x47, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x81, 0x47, 0x02, 0xbd},
    {0x0c, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x07, 0x7d},
    {0x01, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x0a, 0x42, 0x07, 0x7d},
    {0x06, 0x47, 0x02, 0x06, 0x8e},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x06, 0x8e},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0e},
    {0x03, 0xb4, 0xf5, 0x00, 0x0e},
    {0x01, 0xb4, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0xf5, 0x00, 0x0e},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0xf5, 0x40, 0x00, 0x06},
    {0x03, 0x0b, 0xf5, 0x00, 0x77},
    {0x01, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x0b, 0xf5, 0x00, 0x77},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0xf5, 0x40, 0x77},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x5e, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0xf5, 0x00, 0x88},
    {0x01, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x0c, 0xf5, 0x00, 0x88},
    {0x06, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x09, 0xf5, 0x00, 0x77},
    {0x04, 0x0b, 0xf5, 0x40, 0x88},
    {0x02, 0x09, 0xf5, 0x00, 0x77},
    {0x07, 0xf2, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0x56, 0xb5, 0xff},
    {0x01, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x9a, 0x56, 0xb5, 0xff},
    {0x05, 0x43, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0xf5, 0x40, 0x77},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0x16, 0xb5, 0x00, 0xff},
    {0x03, 0x14, 0xf5, 0x00, 0x99},
    {0x01, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x14, 0xf5, 0x00, 0x99},
    {0x06, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x82, 0x5e, 0xb5, 0xff},
    {0x04, 0x0c, 0xf5, 0x40, 0x99},
    {0x02, 0x82, 0x5e, 0xb5, 0xff},
    {0x08, 0xf5, 0x40, 0x00, 0x06},
    {0x03, 0x18, 0xf5, 0x00, 0x99},
    {0x01, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x18, 0xf5, 0x00, 0x99},
    {0x05, 0x4b, 0xb5, 0x00, 0x99},
    {0x03, 0x0e, 0xf5, 0x00, 0x88},
    {0x04, 0x09, 0xf5, 0x40, 0x88},
    {0x02, 0x0e, 0xf5, 0x00, 0x88},
    {0x4f, 0x0d, 0xb5, 0x40, 0xff},
    {0x03, 0x1c, 0xf5, 0x00, 0x99},
    {0x01, 0x9a, 0x4d, 0xf5, 0xff},
    {0x02, 0x1c, 0xf5, 0x00, 0x99},
    {0x06, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0x4d, 0xf5, 0xff},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0xf5, 0x00, 0x99},
    {0x01, 0x14, 0x47, 0xf5, 0xaf},
    {0x02, 0x17, 0xf5, 0x00, 0x99},
    {0x06, 0x4c, 0x07, 0xb5, 0xaf},
    {0x03, 0x03, 0x43, 0x16, 0x6f},
    {0x04, 0x14, 0x47, 0xf5, 0xaf},
    {0x02, 0x03, 0x43, 0x16, 0x6f},
    {0x09, 0x43, 0x47, 0xb5, 0xaf},
    {0x03, 0x1b, 0xf5, 0x00, 0x99},
    {0x01, 0x82, 0x56, 0xf5, 0xff},
    {0x02, 0x1b, 0xf5, 0x00, 0x99},
    {0x05, 0x4c, 0x07, 0xb5, 0xaf},
    {0x03, 0x05, 0x43, 0x16, 0x6f},
    {0x04, 0x82, 0x56, 0xf5, 0xff},
    {0x02, 0x05, 0x43, 0x16, 0x6f},
    {0x0b, 0x5e, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x47, 0xb5, 0xaf},
    {0x01, 0x18, 0x47, 0xf5, 0xaf},
    {0x02, 0x27, 0x47, 0xb5, 0xaf},
    {0x06, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x10, 0xf5, 0x00, 0x88},
    {0x04, 0x18, 0x47, 0xf5, 0xaf},
    {0x02, 0x10, 0xf5, 0x00, 0x88},
    {0x07, 0x4b, 0x07, 0xf5, 0xaf},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x43, 0x16, 0x6f},
    {0x04, 0x0e, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0x16, 0x6f},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0xf5, 0x00, 0x99},
    {0x01, 0x1c, 0x47, 0xf5, 0xaf},
    {0x02, 0x13, 0xf5, 0x00, 0x99},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0xf5, 0x00, 0x77},
    {0x04, 0x1c, 0x47, 0xf5, 0xaf},
    {0x02, 0x08, 0xf5, 0x00, 0x77},
    {0x08, 0x43, 0x47, 0xb5, 0xaf},
    {0x03, 0x37, 0x47, 0xb5, 0xaf},
    {0x01, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x37, 0x47, 0xb5, 0xaf},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x5e, 0xb5, 0xff},
    {0x04, 0x04, 0xf5, 0x40, 0x77},
    {0x02, 0x81, 0x5e, 0xb5, 0xff},
    {0x0c, 0x5e, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0xf5, 0x00, 0x77},
    {0x01, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x0a, 0xf5, 0x00, 0x77},
    {0x06, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x43, 0x16, 0x6f},
    {0x04, 0x02, 0xf5, 0x40, 0x77},
    {0x02, 0x04, 0x43, 0x16, 0x6f},
    {0x07, 0x45, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x43, 0x16, 0x6f},
    {0x01, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x02, 0x43, 0x16, 0x6f},
    {0x05, 0x46, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x43, 0x16, 0x6f},
    {0x04, 0x07, 0xf5, 0x40, 0x77},
    {0x02, 0x07, 0x43, 0x16, 0x6f},
    {0xdc, 0x45, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0x47, 0xb5, 0xaf},
    {0x01, 0x17, 0x47, 0xf5, 0xaf},
    {0x02, 0x2d, 0x47, 0xb5, 0xaf},
    {0x06, 0x54, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x41, 0x0d, 0x6f},
    {0x04, 0x17, 0x47, 0xf5, 0xaf},
    {0x02, 0x03, 0x41, 0x0d, 0x6f},
    {0x09, 0x4b, 0x45, 0xb5, 0xbf},
    {0x03, 0x0b, 0x43, 0x0d, 0x7f},
    {0x01, 0x03, 0x43, 0x4d, 0x7f},
    {0x02, 0x0b, 0x43, 0x0d, 0x7f},
    {0x05, 0x54, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x41, 0x0d, 0x6f},
    {0x04, 0x03, 0x43, 0x4d, 0x7f},
    {0x02, 0x05, 0x41, 0x0d, 0x6f},
    {0x0a, 0x43, 0x45, 0xf5, 0xbf},
    {0x03, 0x35, 0x47, 0xb5, 0xaf},
    {0x01, 0x1b, 0x47, 0xf5, 0xaf},
    {0x02, 0x35, 0x47, 0xb5, 0xaf},
    {0x06, 0xc2, 0x0d, 0xb5, 0xff},
    {0x03, 0x09, 0x43, 0x0d, 0x7f},
    {0x04, 0x1b, 0x47, 0xf5, 0xaf},
    {0x02, 0x09, 0x43, 0x0d, 0x7f},
    {0x07, 0x4c, 0x05, 0xf5, 0xbf},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x4d, 0x7f},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x0d, 0xb5, 0xff},
    {0x03, 0x06, 0x41, 0x0d, 0x6f},
    {0x04, 0x05, 0x43, 0x4d, 0x7f},
    {0x02, 0x06, 0x41, 0x0d, 0x6f},
    {0x57, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x23, 0x47, 0xb5, 0xaf},
    {0x01, 0x27, 0x45, 0xf5, 0xbf},
    {0x02, 0x23, 0x47, 0xb5, 0xaf},
    {0x06, 0x58, 0x05, 0xb5, 0xbf},
    {0x03, 0x82, 0x43, 0x05, 0xbf},
    {0x04, 0x27, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x43, 0x05, 0xbf},
    {0x08, 0x4b, 0x45, 0xb5, 0xbf},
    {0x03, 0x33, 0x47, 0xb5, 0xaf},
    {0x01, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x33, 0x47, 0xb5, 0xaf},
    {0x05, 0x58, 0x05, 0xb5, 0xbf},
    {0x03, 0x0f, 0xf5, 0x00, 0x88},
    {0x04, 0x10, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0xf5, 0x00, 0x88},
    {0x54, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3f, 0x47, 0xb5, 0xaf},
    {0x01, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x3f, 0x47, 0xb5, 0xaf},
    {0x06, 0x4e, 0x07, 0xb5, 0xaf},
    {0x03, 0x04, 0x41, 0x0d, 0x6f},
    {0x04, 0x89, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x41, 0x0d, 0x6f},
    {0x07, 0x49, 0x07, 0xf5, 0xaf},
    {0x03, 0x02, 0x41, 0x0d, 0x6f},
    {0x01, 0x06, 0x43, 0x4d, 0x7f},
    {0x02, 0x02, 0x41, 0x0d, 0x6f},
    {0x05, 0x4e, 0x07, 0xb5, 0xaf},
    {0x03, 0x07, 0x41, 0x0d, 0x6f},
    {0x04, 0x06, 0x43, 0x4d, 0x7f},
    {0x02, 0x07, 0x41, 0x0d, 0x6f},
    {0x59, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x0d, 0xf5, 0x00, 0x88},
    {0x01, 0x13, 0x47, 0xf5, 0xaf},
    {0x02, 0x0d, 0xf5, 0x00, 0x88},
    {0x06, 0x5c, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x42, 0x16, 0x6f},
    {0x04, 0x13, 0x47, 0xf5, 0xaf},
    {0x02, 0x03, 0x42, 0x16, 0x6f},
    {0x09, 0x45, 0x47, 0xb5, 0xaf},
    {0x03, 0x97, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x97, 0xf5, 0x00, 0x0b},
    {0x05, 0x5c, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x42, 0x16, 0x6f},
    {0x04, 0x08, 0xf5, 0x40, 0x88},
    {0x02, 0x05, 0x42, 0x16, 0x6f},
    {0x0b, 0x43, 0x45, 0xf5, 0xbf},
    {0x03, 0x2b, 0x47, 0xb5, 0xaf},
    {0x01, 0x37, 0x45, 0xf5, 0xbf},
    {0x02, 0x2b, 0x47, 0xb5, 0xaf},
    {0x06, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x11, 0xf5, 0x00, 0x88},
    {0x04, 0x37, 0x45, 0xf5, 0xbf},
    {0x02, 0x11, 0xf5, 0x00, 0x88},
    {0x07, 0xda, 0xb5, 0x40, 0x0b},
    {0x03, 0x93, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x56, 0xf5, 0xff},
    {0x02, 0x93, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0xb5, 0x00, 0x88},
    {0x03, 0x06, 0x42, 0x16, 0x6f},
    {0x04, 0x81, 0x56, 0xf5, 0xff},
    {0x02, 0x06, 0x42, 0x16, 0x6f},
    {0x4e, 0x16, 0xb5, 0x00, 0xff},
    {0x03, 0x01, 0xf5, 0x00, 0x88},
    {0x01, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x01, 0xf5, 0x00, 0x88},
    {0x06, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x08, 0x43, 0x0d, 0x7f},
    {0x04, 0x0a, 0xf5, 0x40, 0x88},
    {0x02, 0x08, 0x43, 0x0d, 0x7f},
    {0x08, 0x45, 0x47, 0xb5, 0xaf},
    {0x03, 0x83, 0x56, 0xb5, 0xff},
    {0x01, 0x04, 0x43, 0x4d, 0x7f},
    {0x02, 0x83, 0x56, 0xb5, 0xff},
    {0x05, 0x42, 0xb5, 0x00, 0x88},
    {0x03, 0x81, 0x43, 0x05, 0xbf},
    {0x04, 0x04, 0x43, 0x4d, 0x7f},
    {0x02, 0x81, 0x43, 0x05, 0xbf},
    {0x0c, 0x43, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x43, 0x0d, 0x7f},
    {0x01, 0x02, 0x43, 0x4d, 0x7f},
    {0x02, 0x0a, 0x43, 0x0d, 0x7f},
    {0x06, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x04, 0x42, 0x16, 0x6f},
    {0x04, 0x02, 0x43, 0x4d, 0x7f},
    {0x02, 0x04, 0x42, 0x16, 0x6f},
    {0x07, 0x46, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0x16, 0x6f},
    {0x01, 0x07, 0x43, 0x4d, 0x7f},
    {0x02, 0x02, 0x42, 0x16, 0x6f},
    {0x05, 0x47, 0xb5, 0x00, 0x88},
    {0x03, 0x07, 0x42, 0x16, 0x6f},
    {0x04, 0x07, 0x43, 0x4d, 0x7f},
    {0x02, 0x07, 0x42, 0x16, 0x6f},
    {0xf4, 0x4d, 0xf5, 0x40, 0x0f},
    {0x03, 0x1d, 0x47, 0xb5, 0xaf},
    {0x01, 0x2d, 0x45, 0xf5, 0xbf},
    {0x02, 0x1d, 0x47, 0xb5, 0xaf},
    {0x06, 0x57, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x4c, 0x44, 0xb5, 0xcf},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x4b, 0x44, 0xf5, 0xcf},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x54, 0x04, 0xf5, 0xcf},
    {0x03, 0x9a, 0x43, 0x04, 0xcf},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0x43, 0x04, 0xcf},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x03, 0x04, 0xb5, 0xcf},
    {0x03, 0x21, 0x47, 0xb5, 0xaf},
    {0x01, 0x35, 0x45, 0xf5, 0xbf},
    {0x02, 0x21, 0x47, 0xb5, 0xaf},
    {0x06, 0x5b, 0x05, 0xb5, 0xbf},
    {0x03, 0x82, 0x4b, 0x04, 0xcf},
    {0x04, 0x35, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x4b, 0x04, 0xcf},
    {0x08, 0x4c, 0x44, 0xb5, 0xcf},
    {0x03, 0x31, 0x47, 0xb5, 0xaf},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x47, 0xb5, 0xaf},
    {0x05, 0x5b, 0x05, 0xb5, 0xbf},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc2, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x3d, 0x47, 0xb5, 0xaf},
    {0x01, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x47, 0xb5, 0xaf},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x47, 0xb5, 0xaf},
    {0x01, 0x23, 0x45, 0xf5, 0xbf},
    {0x02, 0x2f, 0x47, 0xb5, 0xaf},
    {0x06, 0x67, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0x45, 0xb5, 0xbf},
    {0x03, 0x3b, 0x47, 0xb5, 0xaf},
    {0x01, 0x82, 0x43, 0x44, 0xcf},
    {0x02, 0x3b, 0x47, 0xb5, 0xaf},
    {0x05, 0x67, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0x44, 0xf5, 0xcf},
    {0x03, 0x29, 0x47, 0xb5, 0xaf},
    {0x01, 0x33, 0x45, 0xf5, 0xbf},
    {0x02, 0x29, 0x47, 0xb5, 0xaf},
    {0x06, 0x50, 0x07, 0xb5, 0xaf},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x45, 0xf5, 0xbf},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x58, 0x04, 0xf5, 0xcf},
    {0x03, 0x8f, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x8f, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x07, 0xb5, 0xaf},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0xf5, 0x40, 0x99},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x47, 0xb5, 0xaf},
    {0x01, 0x3f, 0x45, 0xf5, 0xbf},
    {0x02, 0x1f, 0x47, 0xb5, 0xaf},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x45, 0xf5, 0xbf},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x45, 0xb5, 0xbf},
    {0x03, 0x39, 0x47, 0xb5, 0xaf},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x47, 0xb5, 0xaf},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0x04, 0xcf},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x4b, 0x04, 0xcf},
    {0x0c, 0x4b, 0x44, 0xf5, 0xcf},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0x05, 0xf5, 0xbf},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0xdd, 0x45, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0xf5, 0x00, 0x99},
    {0x01, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x16, 0xf5, 0x00, 0x99},
    {0x06, 0x53, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x44, 0x0d, 0x6f},
    {0x04, 0x0d, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x44, 0x0d, 0x6f},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0x0d, 0x7f},
    {0x01, 0x03, 0x42, 0x4d, 0x7f},
    {0x02, 0x0b, 0x42, 0x0d, 0x7f},
    {0x05, 0x53, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x44, 0x0d, 0x6f},
    {0x04, 0x03, 0x42, 0x4d, 0x7f},
    {0x02, 0x05, 0x44, 0x0d, 0x6f},
    {0x0a, 0x45, 0x45, 0xf5, 0xbf},
    {0x03, 0x1a, 0xf5, 0x00, 0x99},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0xf5, 0x00, 0x99},
    {0x06, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x09, 0x42, 0x0d, 0x7f},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x0d, 0x7f},
    {0x07, 0x5c, 0x04, 0xf5, 0xcf},
    {0x03, 0x8b, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0x4d, 0x7f},
    {0x02, 0x8b, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0xb5, 0x00, 0x99},
    {0x03, 0x06, 0x44, 0x0d, 0x6f},
    {0x04, 0x05, 0x42, 0x4d, 0x7f},
    {0x02, 0x06, 0x44, 0x0d, 0x6f},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x47, 0xb5, 0xaf},
    {0x01, 0x2b, 0x45, 0xf5, 0xbf},
    {0x02, 0x25, 0x47, 0xb5, 0xaf},
    {0x06, 0x77, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x45, 0x05, 0xbf},
    {0x04, 0x2b, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x45, 0x05, 0xbf},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0xf5, 0x00, 0x99},
    {0x01, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x19, 0xf5, 0x00, 0x99},
    {0x05, 0x77, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0xf5, 0x40, 0x99},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x0d, 0xb5, 0xff},
    {0x03, 0x04, 0x44, 0x0d, 0x6f},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x0d, 0x6f},
    {0x07, 0x44, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x44, 0x0d, 0x6f},
    {0x01, 0x06, 0x42, 0x4d, 0x7f},
    {0x02, 0x02, 0x44, 0x0d, 0x6f},
    {0x05, 0xc1, 0x0d, 0xb5, 0xff},
    {0x03, 0x07, 0x44, 0x0d, 0x6f},
    {0x04, 0x06, 0x42, 0x4d, 0x7f},
    {0x02, 0x07, 0x44, 0x0d, 0x6f},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0xf5, 0x40, 0x99},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0x47, 0xb5, 0xaf},
    {0x03, 0x12, 0xf5, 0x00, 0x99},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0xf5, 0x00, 0x99},
    {0x05, 0x4a, 0xb5, 0x00, 0x99},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0x45, 0xf5, 0xbf},
    {0x03, 0x15, 0xf5, 0x00, 0x99},
    {0x01, 0x83, 0x4d, 0xf5, 0xff},
    {0x02, 0x15, 0xf5, 0x00, 0x99},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0x4d, 0xf5, 0xff},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0xb5, 0x40, 0x99},
    {0x03, 0x84, 0x4d, 0xb5, 0xff},
    {0x01, 0x81, 0x43, 0x44, 0xcf},
    {0x02, 0x84, 0x4d, 0xb5, 0xff},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x0d, 0x7f},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x0d, 0x7f},
    {0x08, 0x46, 0x47, 0xb5, 0xaf},
    {0x03, 0x83, 0x43, 0x04, 0xcf},
    {0x01, 0x04, 0x42, 0x4d, 0x7f},
    {0x02, 0x83, 0x43, 0x04, 0xcf},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x05, 0xbf},
    {0x04, 0x04, 0x42, 0x4d, 0x7f},
    {0x02, 0x81, 0x45, 0x05, 0xbf},
    {0x0c, 0x45, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0x0d, 0x7f},
    {0x01, 0x02, 0x42, 0x4d, 0x7f},
    {0x02, 0x0a, 0x42, 0x0d, 0x7f},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0x4d, 0x7f},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0xb5, 0x40, 0x99},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0x4d, 0x7f},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0x4d, 0x7f},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0x9c, 0xf5, 0x00, 0x0d},
    {0x01, 0x1d, 0x45, 0xf5, 0xbf},
    {0x02, 0x9c, 0xf5, 0x00, 0x0d},
    {0x06, 0x6d, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x54, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x46, 0xb5, 0x7b},
    {0x01, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x0b, 0x46, 0xb5, 0x7b},
    {0x05, 0x6d, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0xf5, 0x7b},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x4c, 0x42, 0xf5, 0xdf},
    {0x03, 0x0c, 0x41, 0xb5, 0x8b},
    {0x01, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x0c, 0x41, 0xb5, 0x8b},
    {0x06, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x09, 0x46, 0xb5, 0x7b},
    {0x04, 0x0b, 0x41, 0xf5, 0x8b},
    {0x02, 0x09, 0x46, 0xb5, 0x7b},
    {0x07, 0x57, 0x04, 0xf5, 0xcf},
    {0x03, 0x9a, 0x4b, 0x02, 0xdf},
    {0x01, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x9a, 0x4b, 0x02, 0xdf},
    {0x05, 0x43, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0xf5, 0x7b},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0x0b, 0x02, 0xb5, 0xdf},
    {0x03, 0x14, 0x43, 0xb5, 0x9b},
    {0x01, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x14, 0x43, 0xb5, 0x9b},
    {0x06, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x82, 0x4c, 0x02, 0xdf},
    {0x04, 0x0c, 0x43, 0xf5, 0x9b},
    {0x02, 0x82, 0x4c, 0x02, 0xdf},
    {0x08, 0x54, 0x42, 0xb5, 0xdf},
    {0x03, 0x18, 0x43, 0xb5, 0x9b},
    {0x01, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x18, 0x43, 0xb5, 0x9b},
    {0x05, 0x4b, 0x03, 0xb5, 0x9b},
    {0x03, 0x0e, 0x41, 0xb5, 0x8b},
    {0x04, 0x09, 0x41, 0xf5, 0x8b},
    {0x02, 0x0e, 0x41, 0xb5, 0x8b},
    {0x4f, 0x03, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x43, 0xb5, 0x9b},
    {0x01, 0x9a, 0x43, 0x42, 0xdf},
    {0x02, 0x1c, 0x43, 0xb5, 0x9b},
    {0x06, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0x43, 0x42, 0xdf},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0xb5, 0x9b},
    {0x01, 0x21, 0x45, 0xf5, 0xbf},
    {0x02, 0x17, 0x43, 0xb5, 0x9b},
    {0x06, 0x75, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x0b, 0x6d},
    {0x04, 0x21, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x0b, 0x6d},
    {0x09, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x1b, 0x43, 0xb5, 0x9b},
    {0x01, 0x82, 0x4b, 0x42, 0xdf},
    {0x02, 0x1b, 0x43, 0xb5, 0x9b},
    {0x05, 0x75, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x0b, 0x6d},
    {0x04, 0x82, 0x4b, 0x42, 0xdf},
    {0x02, 0x05, 0x43, 0x0b, 0x6d},
    {0x0b, 0x4c, 0x42, 0xf5, 0xdf},
    {0x03, 0x28, 0x47, 0xb5, 0xaf},
    {0x01, 0x31, 0x45, 0xf5, 0xbf},
    {0x02, 0x28, 0x47, 0xb5, 0xaf},
    {0x06, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x10, 0x41, 0xb5, 0x8b},
    {0x04, 0x31, 0x45, 0xf5, 0xbf},
    {0x02, 0x10, 0x41, 0xb5, 0x8b},
    {0x07, 0x5b, 0x04, 0xf5, 0xcf},
    {0x03, 0x8d, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x8d, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0x0b, 0x6d},
    {0x04, 0x0e, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x0b, 0x6d},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0xb5, 0x9b},
    {0x01, 0x3d, 0x45, 0xf5, 0xbf},
    {0x02, 0x13, 0x43, 0xb5, 0x9b},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0xb5, 0x7b},
    {0x04, 0x3d, 0x45, 0xf5, 0xbf},
    {0x02, 0x08, 0x46, 0xb5, 0x7b},
    {0x08, 0xc2, 0xf5, 0x00, 0x0b},
    {0x03, 0x38, 0x47, 0xb5, 0xaf},
    {0x01, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x38, 0x47, 0xb5, 0xaf},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4c, 0x02, 0xdf},
    {0x04, 0x04, 0x46, 0xf5, 0x7b},
    {0x02, 0x81, 0x4c, 0x02, 0xdf},
    {0x0c, 0x4c, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x46, 0xb5, 0x7b},
    {0x01, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x0a, 0x46, 0xb5, 0x7b},
    {0x06, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0x0b, 0x6d},
    {0x04, 0x02, 0x46, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0x0b, 0x6d},
    {0x07, 0x45, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0x0b, 0x6d},
    {0x01, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0x0b, 0x6d},
    {0x05, 0x46, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0x0b, 0x6d},
    {0x04, 0x07, 0x46, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0x0b, 0x6d},
    {0xe1, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x47, 0xb5, 0xaf},
    {0x01, 0x2f, 0x45, 0xf5, 0xbf},
    {0x02, 0x2e, 0x47, 0xb5, 0xaf},
    {0x06, 0x63, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x03, 0x6d},
    {0x04, 0x2f, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x41, 0x03, 0x6d},
    {0x09, 0x58, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x03, 0x7d},
    {0x01, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x0b, 0x43, 0x03, 0x7d},
    {0x05, 0x63, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x03, 0x6d},
    {0x04, 0x03, 0x43, 0x43, 0x7d},
    {0x02, 0x05, 0x41, 0x03, 0x6d},
    {0x0a, 0x49, 0x44, 0xf5, 0xcf},
    {0x03, 0x36, 0x47, 0xb5, 0xaf},
    {0x01, 0x3b, 0x45, 0xf5, 0xbf},
    {0x02, 0x36, 0x47, 0xb5, 0xaf},
    {0x06, 0xc2, 0x03, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x03, 0x7d},
    {0x04, 0x3b, 0x45, 0xf5, 0xbf},
    {0x02, 0x09, 0x43, 0x03, 0x7d},
    {0x07, 0x67, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x03, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x03, 0x6d},
    {0x04, 0x05, 0x43, 0x43, 0x7d},
    {0x02, 0x06, 0x41, 0x03, 0x6d},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x47, 0xb5, 0xaf},
    {0x01, 0x29, 0x45, 0xf5, 0xbf},
    {0x02, 0x24, 0x47, 0xb5, 0xaf},
    {0x06, 0x73, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x49, 0x04, 0xcf},
    {0x04, 0x29, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x49, 0x04, 0xcf},
    {0x08, 0x58, 0x42, 0xb5, 0xdf},
    {0x03, 0x34, 0x47, 0xb5, 0xaf},
    {0x01, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x34, 0x47, 0xb5, 0xaf},
    {0x05, 0x73, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x41, 0xb5, 0x8b},
    {0x04, 0x10, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x41, 0xb5, 0x8b},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x47, 0xb5, 0xaf},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x47, 0xb5, 0xaf},
    {0x06, 0x4f, 0x07, 0xb5, 0xaf},
    {0x03, 0x04, 0x41, 0x03, 0x6d},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x03, 0x6d},
    {0x07, 0x50, 0x05, 0xf5, 0xbf},
    {0x03, 0x02, 0x41, 0x03, 0x6d},
    {0x01, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x41, 0x03, 0x6d},
    {0x05, 0x4f, 0x07, 0xb5, 0xaf},
    {0x03, 0x07, 0x41, 0x03, 0x6d},
    {0x04, 0x06, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x41, 0x03, 0x6d},
    {0xc6, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x41, 0xb5, 0x8b},
    {0x01, 0x1f, 0x45, 0xf5, 0xbf},
    {0x02, 0x0d, 0x41, 0xb5, 0x8b},
    {0x06, 0x7f, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0x0b, 0x6d},
    {0x04, 0x1f, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x42, 0x0b, 0x6d},
    {0x09, 0x4e, 0x44, 0xb5, 0xcf},
    {0x03, 0x99, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x99, 0xf5, 0x00, 0x0b},
    {0x05, 0x7f, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0x0b, 0x6d},
    {0x04, 0x08, 0x41, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0x0b, 0x6d},
    {0x0b, 0x49, 0x44, 0xf5, 0xcf},
    {0x03, 0x2c, 0x47, 0xb5, 0xaf},
    {0x01, 0x39, 0x45, 0xf5, 0xbf},
    {0x02, 0x2c, 0x47, 0xb5, 0xaf},
    {0x06, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x11, 0x41, 0xb5, 0x8b},
    {0x04, 0x39, 0x45, 0xf5, 0xbf},
    {0x02, 0x11, 0x41, 0xb5, 0x8b},
    {0x07, 0xc9, 0xb5, 0x40, 0x0d},
    {0x03, 0x95, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x4b, 0x42, 0xdf},
    {0x02, 0x95, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x01, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0x0b, 0x6d},
    {0x04, 0x81, 0x4b, 0x42, 0xdf},
    {0x02, 0x06, 0x42, 0x0b, 0x6d},
    {0x4e, 0x0b, 0x02, 0xb5, 0xdf},
    {0x03, 0x01, 0x41, 0xb5, 0x8b},
    {0x01, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x01, 0x41, 0xb5, 0x8b},
    {0x06, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x03, 0x7d},
    {0x04, 0x0a, 0x41, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x03, 0x7d},
    {0x08, 0x4e, 0x44, 0xb5, 0xcf},
    {0x03, 0x83, 0x4b, 0x02, 0xdf},
    {0x01, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x83, 0x4b, 0x02, 0xdf},
    {0x05, 0x42, 0x01, 0xb5, 0x8b},
    {0x03, 0x81, 0x49, 0x04, 0xcf},
    {0x04, 0x04, 0x43, 0x43, 0x7d},
    {0x02, 0x81, 0x49, 0x04, 0xcf},
    {0x0c, 0x49, 0x44, 0xf5, 0xcf},
    {0x03, 0x0a, 0x43, 0x03, 0x7d},
    {0x01, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x0a, 0x43, 0x03, 0x7d},
    {0x06, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0x0b, 0x6d},
    {0x04, 0x02, 0x43, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x0b, 0x6d},
    {0x07, 0x46, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x0b, 0x6d},
    {0x01, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x0b, 0x6d},
    {0x05, 0x47, 0x01, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0x0b, 0x6d},
    {0x04, 0x07, 0x43, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x0b, 0x6d},
    {0xf4, 0x43, 0x02, 0xf5, 0xff},
    {0x03, 0x1e, 0x47, 0xb5, 0xaf},
    {0x01, 0x16, 0x47, 0xf5, 0xaf},
    {0x02, 0x1e, 0x47, 0xb5, 0xaf},
    {0x06, 0x4d, 0x07, 0xb5, 0xaf},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x47, 0xf5, 0xaf},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x5c, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x07, 0xb5, 0xaf},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x53, 0x04, 0xf5, 0xcf},
    {0x03, 0x9a, 0x45, 0x04, 0xcf},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x45, 0x04, 0xcf},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x05, 0x04, 0xb5, 0xcf},
    {0x03, 0x22, 0x47, 0xb5, 0xaf},
    {0x01, 0x1a, 0x47, 0xf5, 0xaf},
    {0x02, 0x22, 0x47, 0xb5, 0xaf},
    {0x06, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xda, 0xb5, 0x0d},
    {0x04, 0x1a, 0x47, 0xf5, 0xaf},
    {0x02, 0x82, 0xda, 0xb5, 0x0d},
    {0x08, 0x5c, 0x42, 0xb5, 0xdf},
    {0x03, 0x32, 0x47, 0xb5, 0xaf},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x47, 0xb5, 0xaf},
    {0x05, 0xd7, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x47, 0xb5, 0xaf},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x47, 0xb5, 0xaf},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x07, 0xf5, 0xaf},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0x47, 0xb5, 0xaf},
    {0x01, 0x25, 0x45, 0xf5, 0xbf},
    {0x02, 0x30, 0x47, 0xb5, 0xaf},
    {0x06, 0x6b, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0x47, 0xb5, 0xaf},
    {0x03, 0x3c, 0x47, 0xb5, 0xaf},
    {0x01, 0x82, 0x45, 0x44, 0xcf},
    {0x02, 0x3c, 0x47, 0xb5, 0xaf},
    {0x05, 0x6b, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x2a, 0x47, 0xb5, 0xaf},
    {0x01, 0x19, 0x47, 0xf5, 0xaf},
    {0x02, 0x2a, 0x47, 0xb5, 0xaf},
    {0x06, 0x51, 0x07, 0xb5, 0xaf},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x47, 0xf5, 0xaf},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x77, 0x02, 0xf5, 0xdf},
    {0x03, 0x91, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x91, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x07, 0xb5, 0xaf},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x47, 0xb5, 0xaf},
    {0x01, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x47, 0xb5, 0xaf},
    {0x06, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x47, 0xb5, 0xaf},
    {0x03, 0x3a, 0x47, 0xb5, 0xaf},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x47, 0xb5, 0xaf},
    {0x05, 0xd3, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xda, 0xb5, 0x0d},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xda, 0xb5, 0x0d},
    {0x0c, 0xda, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xe5, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x43, 0xb5, 0x9b},
    {0x01, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x16, 0x43, 0xb5, 0x9b},
    {0x06, 0x41, 0x07, 0xb5, 0xaf},
    {0x03, 0x03, 0x44, 0x03, 0x6d},
    {0x04, 0x0d, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x03, 0x6d},
    {0x09, 0x42, 0x47, 0xb5, 0xaf},
    {0x03, 0x0b, 0x42, 0x03, 0x7d},
    {0x01, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x0b, 0x42, 0x03, 0x7d},
    {0x05, 0x41, 0x07, 0xb5, 0xaf},
    {0x03, 0x05, 0x44, 0x03, 0x6d},
    {0x04, 0x03, 0x42, 0x43, 0x7d},
    {0x02, 0x05, 0x44, 0x03, 0x6d},
    {0x0a, 0x46, 0x45, 0xf5, 0xbf},
    {0x03, 0x1a, 0x43, 0xb5, 0x9b},
    {0x01, 0x12, 0x47, 0xf5, 0xaf},
    {0x02, 0x1a, 0x43, 0xb5, 0x9b},
    {0x06, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x03, 0x7d},
    {0x04, 0x12, 0x47, 0xf5, 0xaf},
    {0x02, 0x09, 0x42, 0x03, 0x7d},
    {0x07, 0x4a, 0x07, 0xf5, 0xaf},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x03, 0x6d},
    {0x04, 0x05, 0x42, 0x43, 0x7d},
    {0x02, 0x06, 0x44, 0x03, 0x6d},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x47, 0xb5, 0xaf},
    {0x01, 0x15, 0x47, 0xf5, 0xaf},
    {0x02, 0x26, 0x47, 0xb5, 0xaf},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x05, 0xbf},
    {0x04, 0x15, 0x47, 0xf5, 0xaf},
    {0x02, 0x82, 0x46, 0x05, 0xbf},
    {0x08, 0x42, 0x47, 0xb5, 0xaf},
    {0x03, 0x19, 0x43, 0xb5, 0x9b},
    {0x01, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x19, 0x43, 0xb5, 0x9b},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x03, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x03, 0x6d},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x03, 0x6d},
    {0x07, 0x44, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x03, 0x6d},
    {0x01, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x44, 0x03, 0x6d},
    {0x05, 0xc1, 0x03, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x03, 0x6d},
    {0x04, 0x06, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x44, 0x03, 0x6d},
    {0xc1, 0x47, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0x47, 0xb5, 0xaf},
    {0x03, 0x12, 0x43, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0xb5, 0x9b},
    {0x05, 0x4a, 0x03, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0x45, 0xf5, 0xbf},
    {0x03, 0x15, 0x43, 0xb5, 0x9b},
    {0x01, 0x83, 0x43, 0x42, 0xdf},
    {0x02, 0x15, 0x43, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x43, 0x42, 0xdf},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0xf5, 0x9b},
    {0x03, 0x84, 0x43, 0x02, 0xdf},
    {0x01, 0x81, 0x45, 0x44, 0xcf},
    {0x02, 0x84, 0x43, 0x02, 0xdf},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x03, 0x7d},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x03, 0x7d},
    {0x08, 0x47, 0x47, 0xb5, 0xaf},
    {0x03, 0x83, 0x45, 0x04, 0xcf},
    {0x01, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x83, 0x45, 0x04, 0xcf},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x05, 0xbf},
    {0x04, 0x04, 0x42, 0x43, 0x7d},
    {0x02, 0x81, 0x46, 0x05, 0xbf},
    {0x0c, 0x46, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0x03, 0x7d},
    {0x01, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x0a, 0x42, 0x03, 0x7d},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0x43, 0x7d},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0x43, 0x7d},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0b},
    {0x03, 0xb4, 0xf5, 0x00, 0x0b},
    {0x01, 0xa0, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0xf5, 0x00, 0x0b},
    {0x06, 0x5d, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x4a, 0xb5, 0x6d},
    {0x04, 0xa0, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4a, 0xb5, 0x6d},
    {0x09, 0x57, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x49, 0xb5, 0x7d},
    {0x01, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x0b, 0x49, 0xb5, 0x7d},
    {0x05, 0x5d, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x4a, 0xb5, 0x6d},
    {0x04, 0x03, 0x49, 0xf5, 0x7d},
    {0x02, 0x05, 0x4a, 0xb5, 0x6d},
    {0x0a, 0x62, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x49, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x49, 0xb5, 0x7d},
    {0x07, 0x6d, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x5a, 0xb5, 0xff},
    {0x01, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x9a, 0x5a, 0xb5, 0xff},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4a, 0xb5, 0x6d},
    {0x04, 0x05, 0x49, 0xf5, 0x7d},
    {0x02, 0x06, 0x4a, 0xb5, 0x6d},
    {0x4d, 0x1a, 0xb5, 0x00, 0xff},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x62, 0xb5, 0xff},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x62, 0xb5, 0xff},
    {0x08, 0x57, 0x42, 0xb5, 0xdf},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4a, 0xb5, 0x6d},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0x4a, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4a, 0xb5, 0x6d},
    {0x01, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x4a, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4a, 0xb5, 0x6d},
    {0x04, 0x06, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x4a, 0xb5, 0x6d},
    {0x52, 0x08, 0xf5, 0x00, 0xff},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x1a, 0x6f},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x1a, 0x6f},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0x5a, 0xf5, 0xff},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x1a, 0x6f},
    {0x04, 0x82, 0x5a, 0xf5, 0xff},
    {0x02, 0x05, 0x43, 0x1a, 0x6f},
    {0x0b, 0x62, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0x48, 0xb5, 0xff},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0x48, 0xb5, 0xff},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x1a, 0x6f},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x1a, 0x6f},
    {0x51, 0x08, 0xf5, 0x00, 0xff},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0x08, 0xb5, 0xff},
    {0x03, 0x08, 0x49, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x49, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0x08, 0xb5, 0xff},
    {0x03, 0x81, 0x62, 0xb5, 0xff},
    {0x04, 0x04, 0x49, 0xf5, 0x7d},
    {0x02, 0x81, 0x62, 0xb5, 0xff},
    {0x0c, 0x62, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x49, 0xb5, 0x7d},
    {0x01, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x0a, 0x49, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x1a, 0x6f},
    {0x04, 0x02, 0x49, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0x1a, 0x6f},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x1a, 0x6f},
    {0x01, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0x1a, 0x6f},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x1a, 0x6f},
    {0x04, 0x07, 0x49, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0x1a, 0x6f},
    {0xdf, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x5b, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x61, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x75, 0x02, 0xf5, 0xdf},
    {0x03, 0x87, 0x48, 0xb5, 0xff},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0x48, 0xb5, 0xff},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0x45, 0xf5, 0xbf},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x5b, 0x42, 0xb5, 0xdf},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0xda, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0x1a, 0x6f},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x1a, 0x6f},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0xf5, 0x00, 0x0b},
    {0x05, 0x7d, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0x1a, 0x6f},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x1a, 0x6f},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0x45, 0xf5, 0xbf},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0x45, 0xf5, 0xbf},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc7, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0x5a, 0xf5, 0xff},
    {0x02, 0x94, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x1a, 0x6f},
    {0x04, 0x81, 0x5a, 0xf5, 0xff},
    {0x02, 0x06, 0x42, 0x1a, 0x6f},
    {0x4e, 0x1a, 0xb5, 0x00, 0xff},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x5a, 0xb5, 0xff},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0x5a, 0xb5, 0xff},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x1a, 0x6f},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x1a, 0x6f},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x1a, 0x6f},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x1a, 0x6f},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x1a, 0x6f},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x1a, 0x6f},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0x45, 0xf5, 0xbf},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x46, 0x08, 0x6f},
    {0x04, 0x2e, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x46, 0x08, 0x6f},
    {0x09, 0x68, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x08, 0x7f},
    {0x01, 0x03, 0x41, 0x48, 0x7f},
    {0x02, 0x0b, 0x41, 0x08, 0x7f},
    {0x05, 0x6f, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x46, 0x08, 0x6f},
    {0x04, 0x03, 0x41, 0x48, 0x7f},
    {0x02, 0x05, 0x46, 0x08, 0x6f},
    {0x0a, 0x72, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0x08, 0x8f},
    {0x01, 0x0b, 0x43, 0x48, 0x8f},
    {0x02, 0x0c, 0x43, 0x08, 0x8f},
    {0x06, 0x43, 0x03, 0x08, 0x8f},
    {0x03, 0x09, 0x41, 0x08, 0x7f},
    {0x04, 0x0b, 0x43, 0x48, 0x8f},
    {0x02, 0x09, 0x41, 0x08, 0x7f},
    {0x07, 0x63, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x49, 0x02, 0xdf},
    {0x01, 0x05, 0x41, 0x48, 0x7f},
    {0x02, 0x9a, 0x49, 0x02, 0xdf},
    {0x05, 0x43, 0x03, 0x08, 0x8f},
    {0x03, 0x06, 0x46, 0x08, 0x6f},
    {0x04, 0x05, 0x41, 0x48, 0x7f},
    {0x02, 0x06, 0x46, 0x08, 0x6f},
    {0x4d, 0x09, 0x02, 0xb5, 0xdf},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0x45, 0xf5, 0xbf},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x72, 0xb5, 0xff},
    {0x04, 0x36, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x72, 0xb5, 0xff},
    {0x08, 0x68, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x48, 0x8f},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0x04, 0xb5, 0xcf},
    {0x03, 0x0e, 0x43, 0x08, 0x8f},
    {0x04, 0x09, 0x43, 0x48, 0x8f},
    {0x02, 0x0e, 0x43, 0x08, 0x8f},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x08, 0x8f},
    {0x03, 0x04, 0x46, 0x08, 0x6f},
    {0x04, 0x88, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x46, 0x08, 0x6f},
    {0x07, 0xc2, 0x08, 0xf5, 0xff},
    {0x03, 0x02, 0x46, 0x08, 0x6f},
    {0x01, 0x06, 0x41, 0x48, 0x7f},
    {0x02, 0x02, 0x46, 0x08, 0x6f},
    {0x05, 0x45, 0x03, 0x08, 0x8f},
    {0x03, 0x07, 0x46, 0x08, 0x6f},
    {0x04, 0x06, 0x41, 0x48, 0x7f},
    {0x02, 0x07, 0x46, 0x08, 0x6f},
    {0xd6, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0x45, 0xf5, 0xbf},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x09, 0x6d},
    {0x04, 0x24, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x09, 0x6d},
    {0x09, 0x50, 0x44, 0xb5, 0xcf},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x49, 0x42, 0xdf},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x09, 0x6d},
    {0x04, 0x82, 0x49, 0x42, 0xdf},
    {0x02, 0x05, 0x43, 0x09, 0x6d},
    {0x0b, 0x72, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0x45, 0xf5, 0xbf},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x08, 0x8f},
    {0x04, 0x34, 0x45, 0xf5, 0xbf},
    {0x02, 0x10, 0x43, 0x08, 0x8f},
    {0x07, 0x73, 0x02, 0xf5, 0xdf},
    {0x03, 0x90, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0xf5, 0x00, 0x0b},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x09, 0x6d},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x09, 0x6d},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0x45, 0xf5, 0xbf},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x08, 0x7f},
    {0x04, 0x00, 0x45, 0xf5, 0xbf},
    {0x02, 0x08, 0x41, 0x08, 0x7f},
    {0x08, 0x50, 0x44, 0xb5, 0xcf},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x48, 0x7f},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xcf, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x72, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0x48, 0x7f},
    {0x02, 0x81, 0x72, 0xb5, 0xff},
    {0x0c, 0x72, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0x08, 0x7f},
    {0x01, 0x02, 0x41, 0x48, 0x7f},
    {0x02, 0x0a, 0x41, 0x08, 0x7f},
    {0x06, 0x46, 0x03, 0x08, 0x8f},
    {0x03, 0x04, 0x43, 0x09, 0x6d},
    {0x04, 0x02, 0x41, 0x48, 0x7f},
    {0x02, 0x04, 0x43, 0x09, 0x6d},
    {0x07, 0x4f, 0x05, 0xf5, 0xbf},
    {0x03, 0x02, 0x43, 0x09, 0x6d},
    {0x01, 0x07, 0x41, 0x48, 0x7f},
    {0x02, 0x02, 0x43, 0x09, 0x6d},
    {0x05, 0x46, 0x03, 0x08, 0x8f},
    {0x03, 0x07, 0x43, 0x09, 0x6d},
    {0x04, 0x07, 0x41, 0x48, 0x7f},
    {0x02, 0x07, 0x43, 0x09, 0x6d},
    {0xde, 0x45, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xce, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x5f, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x4e, 0x42, 0xf5, 0xdf},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7f, 0x02, 0xf5, 0xdf},
    {0x03, 0x8c, 0xf5, 0x00, 0x0b},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0xf5, 0x00, 0x0b},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0x45, 0xf5, 0xbf},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x4e, 0x02, 0xdf},
    {0x04, 0x2c, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x4e, 0x02, 0xdf},
    {0x08, 0xce, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0x08, 0x8f},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x08, 0x8f},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x48, 0xb5, 0xff},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x48, 0xb5, 0xff},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xd0, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x08, 0x8f},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x08, 0x8f},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x09, 0x6d},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x09, 0x6d},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x48, 0x8f},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x09, 0x6d},
    {0x04, 0x08, 0x43, 0x48, 0x8f},
    {0x02, 0x05, 0x42, 0x09, 0x6d},
    {0x0b, 0x4e, 0x42, 0xf5, 0xdf},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x08, 0x8f},
    {0x03, 0x11, 0x43, 0x08, 0x8f},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0x08, 0x8f},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x49, 0x42, 0xdf},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0x08, 0x8f},
    {0x03, 0x06, 0x42, 0x09, 0x6d},
    {0x04, 0x81, 0x49, 0x42, 0xdf},
    {0x02, 0x06, 0x42, 0x09, 0x6d},
    {0x4e, 0x09, 0x02, 0xb5, 0xdf},
    {0x03, 0x01, 0x43, 0x08, 0x8f},
    {0x01, 0x0a, 0x43, 0x48, 0x8f},
    {0x02, 0x01, 0x43, 0x08, 0x8f},
    {0x06, 0x42, 0x03, 0x08, 0x8f},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0x48, 0x8f},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x49, 0x02, 0xdf},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x49, 0x02, 0xdf},
    {0x05, 0x42, 0x03, 0x08, 0x8f},
    {0x03, 0x81, 0x4e, 0x02, 0xdf},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x4e, 0x02, 0xdf},
    {0x0c, 0x4e, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0x08, 0x8f},
    {0x03, 0x04, 0x42, 0x09, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x09, 0x6d},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x09, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x09, 0x6d},
    {0x05, 0x47, 0x03, 0x08, 0x8f},
    {0x03, 0x07, 0x42, 0x09, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x09, 0x6d},
    {0xf4, 0x48, 0xf5, 0x40, 0x0f},
    {0x03, 0x9d, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0x45, 0xf5, 0xbf},
    {0x02, 0x9d, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x47, 0xb5, 0x6b},
    {0x04, 0x1e, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x47, 0xb5, 0x6b},
    {0x09, 0x53, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x45, 0xb5, 0x7b},
    {0x01, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x0b, 0x45, 0xb5, 0x7b},
    {0x05, 0x56, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x47, 0xb5, 0x6b},
    {0x04, 0x03, 0x45, 0xf5, 0x7b},
    {0x02, 0x05, 0x47, 0xb5, 0x6b},
    {0x0a, 0x7e, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x44, 0xb5, 0x8b},
    {0x01, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x0c, 0x44, 0xb5, 0x8b},
    {0x06, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x09, 0x45, 0xb5, 0x7b},
    {0x04, 0x0b, 0x44, 0xf5, 0x8b},
    {0x02, 0x09, 0x45, 0xb5, 0x7b},
    {0x07, 0x4d, 0x05, 0xf5, 0xbf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x47, 0xb5, 0x6b},
    {0x04, 0x05, 0x45, 0xf5, 0x7b},
    {0x02, 0x06, 0x47, 0xb5, 0x6b},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x42, 0xb5, 0x9b},
    {0x01, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x14, 0x42, 0xb5, 0x9b},
    {0x06, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x82, 0x7e, 0xb5, 0xff},
    {0x04, 0x0c, 0x42, 0xf5, 0x9b},
    {0x02, 0x82, 0x7e, 0xb5, 0xff},
    {0x08, 0x53, 0x42, 0xb5, 0xdf},
    {0x03, 0x18, 0x42, 0xb5, 0x9b},
    {0x01, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x18, 0x42, 0xb5, 0x9b},
    {0x05, 0x4b, 0x02, 0xb5, 0x9b},
    {0x03, 0x0e, 0x44, 0xb5, 0x8b},
    {0x04, 0x09, 0x44, 0xf5, 0x8b},
    {0x02, 0x0e, 0x44, 0xb5, 0x8b},
    {0x4f, 0x05, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0xb5, 0x9b},
    {0x01, 0x9a, 0x45, 0x42, 0xdf},
    {0x02, 0x1c, 0x42, 0xb5, 0x9b},
    {0x06, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x47, 0xb5, 0x6b},
    {0x04, 0x9a, 0x45, 0x42, 0xdf},
    {0x02, 0x04, 0x47, 0xb5, 0x6b},
    {0x07, 0x43, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x47, 0xb5, 0x6b},
    {0x01, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x47, 0xb5, 0x6b},
    {0x05, 0x45, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x47, 0xb5, 0x6b},
    {0x04, 0x06, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x47, 0xb5, 0x6b},
    {0xcc, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x42, 0xb5, 0x9b},
    {0x01, 0x22, 0x45, 0xf5, 0xbf},
    {0x02, 0x17, 0x42, 0xb5, 0x9b},
    {0x06, 0x5a, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x22, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x48, 0x45, 0xb5, 0xbf},
    {0x03, 0x1b, 0x42, 0xb5, 0x9b},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x42, 0xb5, 0x9b},
    {0x05, 0x5a, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x7e, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0x45, 0xf5, 0xbf},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x10, 0x44, 0xb5, 0x8b},
    {0x04, 0x32, 0x45, 0xf5, 0xbf},
    {0x02, 0x10, 0x44, 0xb5, 0x8b},
    {0x07, 0xd8, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0xf5, 0x00, 0x0b},
    {0x01, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x8e, 0xf5, 0x00, 0x0b},
    {0x05, 0x49, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0xb5, 0x9b},
    {0x01, 0x3e, 0x45, 0xf5, 0xbf},
    {0x02, 0x13, 0x42, 0xb5, 0x9b},
    {0x06, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0xb5, 0x7b},
    {0x04, 0x3e, 0x45, 0xf5, 0xbf},
    {0x02, 0x08, 0x45, 0xb5, 0x7b},
    {0x08, 0x48, 0x45, 0xb5, 0xbf},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcb, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x7e, 0xb5, 0xff},
    {0x04, 0x04, 0x45, 0xf5, 0x7b},
    {0x02, 0x81, 0x7e, 0xb5, 0xff},
    {0x0c, 0x7e, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x45, 0xb5, 0x7b},
    {0x01, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x0a, 0x45, 0xb5, 0x7b},
    {0x06, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x45, 0xf5, 0x7b},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x45, 0xf5, 0x7b},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe3, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0x45, 0xf5, 0xbf},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x05, 0x6d},
    {0x04, 0x30, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x41, 0x05, 0x6d},
    {0x09, 0x78, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x05, 0x7d},
    {0x01, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x0b, 0x43, 0x05, 0x7d},
    {0x05, 0x65, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x05, 0x6d},
    {0x04, 0x03, 0x43, 0x45, 0x7d},
    {0x02, 0x05, 0x41, 0x05, 0x6d},
    {0x0a, 0x44, 0x45, 0xf5, 0xbf},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0x45, 0xf5, 0xbf},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x05, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x05, 0x7d},
    {0x04, 0x3c, 0x45, 0xf5, 0xbf},
    {0x02, 0x09, 0x43, 0x05, 0x7d},
    {0x07, 0x6b, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0x48, 0xb5, 0xff},
    {0x01, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x88, 0x48, 0xb5, 0xff},
    {0x05, 0xc2, 0x05, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x05, 0x6d},
    {0x04, 0x05, 0x43, 0x45, 0x7d},
    {0x02, 0x06, 0x41, 0x05, 0x6d},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0x45, 0xf5, 0xbf},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0x05, 0xb5, 0xbf},
    {0x03, 0x82, 0x44, 0x05, 0xbf},
    {0x04, 0x2a, 0x45, 0xf5, 0xbf},
    {0x02, 0x82, 0x44, 0x05, 0xbf},
    {0x08, 0x78, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0x05, 0xb5, 0xbf},
    {0x03, 0x0f, 0x44, 0xb5, 0x8b},
    {0x04, 0x10, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x44, 0xb5, 0x8b},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x05, 0x6d},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x05, 0x6d},
    {0x07, 0x51, 0x05, 0xf5, 0xbf},
    {0x03, 0x02, 0x41, 0x05, 0x6d},
    {0x01, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x41, 0x05, 0x6d},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x05, 0x6d},
    {0x04, 0x06, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x41, 0x05, 0x6d},
    {0xc8, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x44, 0xb5, 0x8b},
    {0x01, 0x20, 0x45, 0xf5, 0xbf},
    {0x02, 0x0d, 0x44, 0xb5, 0x8b},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x20, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x9b, 0xf5, 0x00, 0x0b},
    {0x01, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x9b, 0xf5, 0x00, 0x0b},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x44, 0xf5, 0x8b},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x44, 0x45, 0xf5, 0xbf},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0x45, 0xf5, 0xbf},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x11, 0x44, 0xb5, 0x8b},
    {0x04, 0x3a, 0x45, 0xf5, 0xbf},
    {0x02, 0x11, 0x44, 0xb5, 0x8b},
    {0x07, 0xd4, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0xf5, 0x00, 0x0b},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x96, 0xf5, 0x00, 0x0b},
    {0x05, 0x44, 0x04, 0xb5, 0x8b},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x44, 0xb5, 0x8b},
    {0x01, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x01, 0x44, 0xb5, 0x8b},
    {0x06, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x08, 0x43, 0x05, 0x7d},
    {0x04, 0x0a, 0x44, 0xf5, 0x8b},
    {0x02, 0x08, 0x43, 0x05, 0x7d},
    {0x08, 0xc1, 0xf5, 0x00, 0x0b},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x04, 0xb5, 0x8b},
    {0x03, 0x81, 0x44, 0x05, 0xbf},
    {0x04, 0x04, 0x43, 0x45, 0x7d},
    {0x02, 0x81, 0x44, 0x05, 0xbf},
    {0x0c, 0x44, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x43, 0x05, 0x7d},
    {0x01, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x0a, 0x43, 0x05, 0x7d},
    {0x06, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x04, 0xb5, 0x8b},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xf4, 0x45, 0x02, 0xf5, 0xff},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x08, 0x6f},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x08, 0x6f},
    {0x09, 0x4a, 0x45, 0xb5, 0xbf},
    {0x03, 0x0b, 0x44, 0x08, 0x7f},
    {0x01, 0x03, 0x44, 0x48, 0x7f},
    {0x02, 0x0b, 0x44, 0x08, 0x7f},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x08, 0x6f},
    {0x04, 0x03, 0x44, 0x48, 0x7f},
    {0x02, 0x05, 0x45, 0x08, 0x6f},
    {0x0a, 0x42, 0x45, 0xf5, 0xbf},
    {0x03, 0x0c, 0x42, 0x08, 0x8f},
    {0x01, 0x0b, 0x42, 0x48, 0x8f},
    {0x02, 0x0c, 0x42, 0x08, 0x8f},
    {0x06, 0x43, 0x02, 0x08, 0x8f},
    {0x03, 0x09, 0x44, 0x08, 0x7f},
    {0x04, 0x0b, 0x42, 0x48, 0x8f},
    {0x02, 0x09, 0x44, 0x08, 0x7f},
    {0x07, 0x41, 0x05, 0xf5, 0xbf},
    {0x03, 0x9a, 0x46, 0x04, 0xcf},
    {0x01, 0x05, 0x44, 0x48, 0x7f},
    {0x02, 0x9a, 0x46, 0x04, 0xcf},
    {0x05, 0x43, 0x02, 0x08, 0x8f},
    {0x03, 0x06, 0x45, 0x08, 0x6f},
    {0x04, 0x05, 0x44, 0x48, 0x7f},
    {0x02, 0x06, 0x45, 0x08, 0x6f},
    {0x4d, 0x06, 0x04, 0xb5, 0xcf},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0x05, 0xb5, 0xbf},
    {0x03, 0x82, 0x42, 0x05, 0xbf},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x05, 0xbf},
    {0x08, 0x4a, 0x45, 0xb5, 0xbf},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x48, 0x8f},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0x05, 0xb5, 0xbf},
    {0x03, 0x0e, 0x42, 0x08, 0x8f},
    {0x04, 0x09, 0x42, 0x48, 0x8f},
    {0x02, 0x0e, 0x42, 0x08, 0x8f},
    {0x53, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x08, 0x8f},
    {0x03, 0x04, 0x45, 0x08, 0x6f},
    {0x04, 0x8a, 0xf5, 0x40, 0x0b},
    {0x02, 0x04, 0x45, 0x08, 0x6f},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x08, 0x6f},
    {0x01, 0x06, 0x44, 0x48, 0x7f},
    {0x02, 0x02, 0x45, 0x08, 0x6f},
    {0x05, 0x45, 0x02, 0x08, 0x8f},
    {0x03, 0x07, 0x45, 0x08, 0x6f},
    {0x04, 0x06, 0x44, 0x48, 0x7f},
    {0x02, 0x07, 0x45, 0x08, 0x6f},
    {0x58, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0x45, 0xf5, 0xbf},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0x05, 0xb5, 0xbf},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0x45, 0xf5, 0xbf},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0x44, 0xcf},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0x05, 0xb5, 0xbf},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0x45, 0xf5, 0xbf},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x08, 0x8f},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x08, 0x8f},
    {0x07, 0xc3, 0xb5, 0x40, 0x0b},
    {0x03, 0x92, 0xf5, 0x00, 0x0b},
    {0x01, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x92, 0xf5, 0x00, 0x0b},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0xf5, 0x9b},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0xb5, 0x40, 0x40, 0x0b},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x08, 0x44, 0x08, 0x7f},
    {0x04, 0x86, 0xf5, 0x40, 0x0b},
    {0x02, 0x08, 0x44, 0x08, 0x7f},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x48, 0x7f},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0xb5, 0x00, 0x0b},
    {0x03, 0x81, 0x42, 0x05, 0xbf},
    {0x04, 0x04, 0x44, 0x48, 0x7f},
    {0x02, 0x81, 0x42, 0x05, 0xbf},
    {0x0c, 0x42, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x44, 0x08, 0x7f},
    {0x01, 0x02, 0x44, 0x48, 0x7f},
    {0x02, 0x0a, 0x44, 0x08, 0x7f},
    {0x06, 0x46, 0x02, 0x08, 0x8f},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0x48, 0x7f},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0x08, 0xf5, 0xff},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0x48, 0x7f},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0x08, 0x8f},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0x48, 0x7f},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xe7, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x42, 0xb5, 0x9b},
    {0x01, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x16, 0x42, 0xb5, 0x9b},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x05, 0x6d},
    {0x04, 0x0d, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x44, 0x05, 0x6d},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x05, 0x7d},
    {0x01, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x0b, 0x42, 0x05, 0x7d},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x05, 0x6d},
    {0x04, 0x03, 0x42, 0x45, 0x7d},
    {0x02, 0x05, 0x44, 0x05, 0x6d},
    {0x0a, 0x47, 0x45, 0xf5, 0xbf},
    {0x03, 0x1a, 0x42, 0xb5, 0x9b},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0xb5, 0x9b},
    {0x06, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x09, 0x42, 0x05, 0x7d},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x05, 0x7d},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0x48, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x8a, 0x48, 0xb5, 0xff},
    {0x05, 0x48, 0x02, 0xb5, 0x9b},
    {0x03, 0x06, 0x44, 0x05, 0x6d},
    {0x04, 0x05, 0x42, 0x45, 0x7d},
    {0x02, 0x06, 0x44, 0x05, 0x6d},
    {0x50, 0x08, 0xf5, 0x00, 0xff},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0x08, 0xb5, 0xff},
    {0x03, 0x82, 0x47, 0x05, 0xbf},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x05, 0xbf},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0xb5, 0x9b},
    {0x01, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x19, 0x42, 0xb5, 0x9b},
    {0x05, 0xc3, 0x08, 0xb5, 0xff},
    {0x03, 0x0f, 0x42, 0x08, 0x8f},
    {0x04, 0x11, 0x42, 0xf5, 0x9b},
    {0x02, 0x0f, 0x42, 0x08, 0x8f},
    {0x40, 0x08, 0xf5, 0x00, 0xff},
    {0x03, 0x86, 0x48, 0xb5, 0xff},
    {0x01, 0x84, 0x48, 0xf5, 0xff},
    {0x02, 0x86, 0x48, 0xb5, 0xff},
    {0x06, 0xc1, 0x05, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x05, 0x6d},
    {0x04, 0x84, 0x48, 0xf5, 0xff},
    {0x02, 0x04, 0x44, 0x05, 0x6d},
    {0x07, 0x44, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x44, 0x05, 0x6d},
    {0x01, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x44, 0x05, 0x6d},
    {0x05, 0xc1, 0x05, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x05, 0x6d},
    {0x04, 0x06, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x44, 0x05, 0x6d},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x08, 0x8f},
    {0x01, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x0d, 0x42, 0x08, 0x8f},
    {0x06, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0xf5, 0x9b},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0xb5, 0x9b},
    {0x01, 0x08, 0x42, 0x48, 0x8f},
    {0x02, 0x12, 0x42, 0xb5, 0x9b},
    {0x05, 0x4a, 0x02, 0xb5, 0x9b},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0x48, 0x8f},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0x45, 0xf5, 0xbf},
    {0x03, 0x15, 0x42, 0xb5, 0x9b},
    {0x01, 0x83, 0x45, 0x42, 0xdf},
    {0x02, 0x15, 0x42, 0xb5, 0x9b},
    {0x06, 0x44, 0x02, 0x08, 0x8f},
    {0x03, 0x11, 0x42, 0x08, 0x8f},
    {0x04, 0x83, 0x45, 0x42, 0xdf},
    {0x02, 0x11, 0x42, 0x08, 0x8f},
    {0x07, 0x42, 0x02, 0xf5, 0x9b},
    {0x03, 0x84, 0x45, 0x02, 0xdf},
    {0x01, 0x81, 0x46, 0x44, 0xcf},
    {0x02, 0x84, 0x45, 0x02, 0xdf},
    {0x05, 0x44, 0x02, 0x08, 0x8f},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0x08, 0x8f},
    {0x01, 0x0a, 0x42, 0x48, 0x8f},
    {0x02, 0x01, 0x42, 0x08, 0x8f},
    {0x06, 0x42, 0x02, 0x08, 0x8f},
    {0x03, 0x08, 0x42, 0x05, 0x7d},
    {0x04, 0x0a, 0x42, 0x48, 0x8f},
    {0x02, 0x08, 0x42, 0x05, 0x7d},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0x04, 0xcf},
    {0x01, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x83, 0x46, 0x04, 0xcf},
    {0x05, 0x42, 0x02, 0x08, 0x8f},
    {0x03, 0x81, 0x47, 0x05, 0xbf},
    {0x04, 0x04, 0x42, 0x45, 0x7d},
    {0x02, 0x81, 0x47, 0x05, 0xbf},
    {0x0c, 0x47, 0x45, 0xf5, 0xbf},
    {0x03, 0x0a, 0x42, 0x05, 0x7d},
    {0x01, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x0a, 0x42, 0x05, 0x7d},
    {0x06, 0x47, 0x02, 0x08, 0x8f},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0x45, 0x7d},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0xf5, 0x9b},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0x08, 0x8f},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0x45, 0x7d},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x6e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x4b, 0xb5, 0x7e},
    {0x01, 0x03, 0x4b, 0xf5, 0x7e},
    {0x02, 0x0b, 0x4b, 0xb5, 0x7e},
    {0x05, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x4b, 0xf5, 0x7e},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x70, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x48, 0xb5, 0x8e},
    {0x01, 0x0b, 0x48, 0xf5, 0x8e},
    {0x02, 0x0c, 0x48, 0xb5, 0x8e},
    {0x06, 0x43, 0x08, 0xb5, 0x8e},
    {0x03, 0x09, 0x4b, 0xb5, 0x7e},
    {0x04, 0x0b, 0x48, 0xf5, 0x8e},
    {0x02, 0x09, 0x4b, 0xb5, 0x7e},
    {0x07, 0x5d, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x4b, 0xf5, 0x7e},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x08, 0xb5, 0x8e},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x4b, 0xf5, 0x7e},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x46, 0xb5, 0x9d},
    {0x01, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x14, 0x46, 0xb5, 0x9d},
    {0x06, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x82, 0x70, 0xb5, 0xff},
    {0x04, 0x0c, 0x46, 0xf5, 0x9d},
    {0x02, 0x82, 0x70, 0xb5, 0xff},
    {0x08, 0x6e, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x46, 0xb5, 0x9d},
    {0x01, 0x09, 0x48, 0xf5, 0x8e},
    {0x02, 0x18, 0x46, 0xb5, 0x9d},
    {0x05, 0x4b, 0x06, 0xb5, 0x9d},
    {0x03, 0x0e, 0x48, 0xb5, 0x8e},
    {0x04, 0x09, 0x48, 0xf5, 0x8e},
    {0x02, 0x0e, 0x48, 0xb5, 0x8e},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x46, 0xb5, 0x9d},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x46, 0xb5, 0x9d},
    {0x06, 0x45, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x4b, 0xf5, 0x7e},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x4b, 0xf5, 0x7e},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x17, 0x46, 0xb5, 0x9d},
    {0x01, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x17, 0x46, 0xb5, 0x9d},
    {0x06, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x1b, 0x46, 0xb5, 0x9d},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x46, 0xb5, 0x9d},
    {0x05, 0x4c, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x70, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x41, 0xb5, 0xad},
    {0x01, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x27, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x10, 0x48, 0xb5, 0x8e},
    {0x04, 0x18, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x48, 0xb5, 0x8e},
    {0x07, 0x4b, 0x01, 0xf5, 0xad},
    {0x03, 0x89, 0xf5, 0x00, 0x0a},
    {0x01, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x89, 0xf5, 0x00, 0x0a},
    {0x05, 0x49, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x13, 0x46, 0xb5, 0x9d},
    {0x01, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x13, 0x46, 0xb5, 0x9d},
    {0x06, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x08, 0x4b, 0xb5, 0x7e},
    {0x04, 0x1c, 0x41, 0xf5, 0xad},
    {0x02, 0x08, 0x4b, 0xb5, 0x7e},
    {0x08, 0x43, 0x41, 0xb5, 0xad},
    {0x03, 0x37, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x4b, 0xf5, 0x7e},
    {0x02, 0x37, 0x41, 0xb5, 0xad},
    {0x05, 0xda, 0xb5, 0x00, 0x0a},
    {0x03, 0x81, 0x70, 0xb5, 0xff},
    {0x04, 0x04, 0x4b, 0xf5, 0x7e},
    {0x02, 0x81, 0x70, 0xb5, 0xff},
    {0x0c, 0x70, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x4b, 0xb5, 0x7e},
    {0x01, 0x02, 0x4b, 0xf5, 0x7e},
    {0x02, 0x0a, 0x4b, 0xb5, 0x7e},
    {0x06, 0x46, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x4b, 0xf5, 0x7e},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x4b, 0xf5, 0x7e},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x4b, 0xf5, 0x7e},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xdc, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x41, 0xb5, 0xad},
    {0x01, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x2d, 0x41, 0xb5, 0xad},
    {0x06, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x54, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x35, 0x41, 0xb5, 0xad},
    {0x01, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x35, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x4c, 0x03, 0xf5, 0xbd},
    {0x03, 0x87, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x57, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x23, 0x41, 0xb5, 0xad},
    {0x01, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x41, 0xb5, 0xad},
    {0x06, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x03, 0xbd},
    {0x04, 0x27, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x03, 0xbd},
    {0x08, 0x4b, 0x43, 0xb5, 0xbd},
    {0x03, 0x33, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x33, 0x41, 0xb5, 0xad},
    {0x05, 0x58, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x48, 0xb5, 0x8e},
    {0x04, 0x10, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x48, 0xb5, 0x8e},
    {0x54, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x3f, 0x41, 0xb5, 0xad},
    {0x01, 0x89, 0x44, 0xf5, 0xff},
    {0x02, 0x3f, 0x41, 0xb5, 0xad},
    {0x06, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x89, 0x44, 0xf5, 0xff},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0x59, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x0d, 0x48, 0xb5, 0x8e},
    {0x01, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x0d, 0x48, 0xb5, 0x8e},
    {0x06, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x97, 0x44, 0xb5, 0xff},
    {0x01, 0x08, 0x48, 0xf5, 0x8e},
    {0x02, 0x97, 0x44, 0xb5, 0xff},
    {0x05, 0x5c, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x48, 0xf5, 0x8e},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x2b, 0x41, 0xb5, 0xad},
    {0x01, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x08, 0xb5, 0x8e},
    {0x03, 0x11, 0x48, 0xb5, 0x8e},
    {0x04, 0x37, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x48, 0xb5, 0x8e},
    {0x07, 0xda, 0x04, 0xf5, 0xff},
    {0x03, 0x93, 0x44, 0xb5, 0xff},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x93, 0x44, 0xb5, 0xff},
    {0x05, 0x44, 0x08, 0xb5, 0x8e},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x48, 0xb5, 0x8e},
    {0x01, 0x0a, 0x48, 0xf5, 0x8e},
    {0x02, 0x01, 0x48, 0xb5, 0x8e},
    {0x06, 0x42, 0x08, 0xb5, 0x8e},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x48, 0xf5, 0x8e},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x08, 0xb5, 0x8e},
    {0x03, 0x81, 0x43, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x43, 0x03, 0xbd},
    {0x0c, 0x43, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x08, 0xb5, 0x8e},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x08, 0xb5, 0x8e},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x41, 0xb5, 0xad},
    {0x01, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x41, 0xb5, 0xad},
    {0x06, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0xb5, 0x6a},
    {0x04, 0x2d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0xb5, 0x6a},
    {0x09, 0x76, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0xb5, 0x7a},
    {0x01, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x0b, 0x41, 0xb5, 0x7a},
    {0x05, 0x57, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0xb5, 0x6a},
    {0x04, 0x03, 0x41, 0xf5, 0x7a},
    {0x02, 0x05, 0x46, 0xb5, 0x6a},
    {0x0a, 0x7c, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0xb5, 0x8a},
    {0x01, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x0c, 0x43, 0xb5, 0x8a},
    {0x06, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x09, 0x41, 0xb5, 0x7a},
    {0x04, 0x0b, 0x43, 0xf5, 0x8a},
    {0x02, 0x09, 0x41, 0xb5, 0x7a},
    {0x07, 0x61, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x01, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x9a, 0xc2, 0xb5, 0x0d},
    {0x05, 0x43, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x46, 0xb5, 0x6a},
    {0x04, 0x05, 0x41, 0xf5, 0x7a},
    {0x02, 0x06, 0x46, 0xb5, 0x6a},
    {0x4d, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x21, 0x41, 0xb5, 0xad},
    {0x01, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x41, 0xb5, 0xad},
    {0x06, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x7c, 0xb5, 0xff},
    {0x04, 0x35, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x7c, 0xb5, 0xff},
    {0x08, 0x76, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x31, 0x41, 0xb5, 0xad},
    {0x05, 0x5b, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0xb5, 0x8a},
    {0x04, 0x09, 0x43, 0xf5, 0x8a},
    {0x02, 0x0e, 0x43, 0xb5, 0x8a},
    {0xc3, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x3d, 0x41, 0xb5, 0xad},
    {0x01, 0x87, 0x44, 0xf5, 0xff},
    {0x02, 0x3d, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x46, 0xb5, 0x6a},
    {0x04, 0x87, 0x44, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0xb5, 0x6a},
    {0x07, 0xc2, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x46, 0xb5, 0x6a},
    {0x01, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x46, 0xb5, 0x6a},
    {0x05, 0x45, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x46, 0xb5, 0x6a},
    {0x04, 0x06, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x46, 0xb5, 0x6a},
    {0xd4, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x41, 0xb5, 0xad},
    {0x01, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x41, 0xb5, 0xad},
    {0x06, 0x68, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x82, 0x6d},
    {0x04, 0x23, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x82, 0x6d},
    {0x09, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x3b, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x3b, 0x41, 0xb5, 0xad},
    {0x05, 0x68, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x82, 0x6d},
    {0x04, 0x82, 0xc2, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x82, 0x6d},
    {0x0b, 0x7c, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x41, 0xb5, 0xad},
    {0x01, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x41, 0xb5, 0xad},
    {0x06, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0xb5, 0x8a},
    {0x04, 0x33, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0xb5, 0x8a},
    {0x07, 0x71, 0x02, 0xf5, 0xdf},
    {0x03, 0x8f, 0x44, 0xb5, 0xff},
    {0x01, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x8f, 0x44, 0xb5, 0xff},
    {0x05, 0x50, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x82, 0x6d},
    {0x04, 0x0f, 0x46, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x82, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x41, 0xb5, 0xad},
    {0x01, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x41, 0xb5, 0xad},
    {0x06, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0xb5, 0x7a},
    {0x04, 0x3f, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0xb5, 0x7a},
    {0x08, 0x49, 0x43, 0xb5, 0xbd},
    {0x03, 0x39, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x39, 0x41, 0xb5, 0xad},
    {0x05, 0xcd, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x7c, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xf5, 0x7a},
    {0x02, 0x81, 0x7c, 0xb5, 0xff},
    {0x0c, 0x7c, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0xb5, 0x7a},
    {0x01, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x0a, 0x41, 0xb5, 0x7a},
    {0x06, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x82, 0x6d},
    {0x04, 0x02, 0x41, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x82, 0x6d},
    {0x07, 0x4e, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x82, 0x6d},
    {0x01, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x82, 0x6d},
    {0x05, 0x46, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x82, 0x6d},
    {0x04, 0x07, 0x41, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x82, 0x6d},
    {0xdd, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x46, 0xb5, 0x9d},
    {0x01, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x16, 0x46, 0xb5, 0x9d},
    {0x06, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xc8, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x53, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x46, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x46, 0xb5, 0x9d},
    {0x06, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0x7d, 0x02, 0xf5, 0xdf},
    {0x03, 0x8b, 0x44, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8b, 0x44, 0xb5, 0xff},
    {0x05, 0x48, 0x06, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x41, 0xb5, 0xad},
    {0x01, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x41, 0xb5, 0xad},
    {0x06, 0x78, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x45, 0x03, 0xbd},
    {0x04, 0x2b, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x03, 0xbd},
    {0x08, 0xc8, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x46, 0xb5, 0x9d},
    {0x01, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x19, 0x46, 0xb5, 0x9d},
    {0x05, 0x78, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0xb5, 0x8a},
    {0x04, 0x11, 0x46, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0xb5, 0x8a},
    {0x55, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x85, 0xf5, 0x00, 0x0a},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xce, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0xb5, 0x8a},
    {0x01, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0xb5, 0x8a},
    {0x06, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x82, 0x6d},
    {0x04, 0x01, 0x46, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x82, 0x6d},
    {0x09, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x46, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x12, 0x46, 0xb5, 0x9d},
    {0x05, 0x4a, 0x06, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x82, 0x6d},
    {0x04, 0x08, 0x43, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x82, 0x6d},
    {0x0b, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x46, 0xb5, 0x9d},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x46, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x11, 0x43, 0xb5, 0x8a},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0xb5, 0x8a},
    {0x07, 0x42, 0x06, 0xf5, 0x9d},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x82, 0x6d},
    {0x04, 0x81, 0xc2, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x82, 0x6d},
    {0x4e, 0x82, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x43, 0xb5, 0x8a},
    {0x01, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x01, 0x43, 0xb5, 0x8a},
    {0x06, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0xc2, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0xc2, 0xb5, 0x0d},
    {0x05, 0x42, 0x03, 0xb5, 0x8a},
    {0x03, 0x81, 0x45, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0x45, 0x03, 0xbd},
    {0x0c, 0x45, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x82, 0x6d},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x82, 0x6d},
    {0x07, 0x47, 0x06, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x82, 0x6d},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x82, 0x6d},
    {0x05, 0x47, 0x03, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x82, 0x6d},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x82, 0x6d},
    {0xb4, 0xb5, 0x00, 0x00, 0x0a},
    {0x03, 0xa2, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0xa2, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x64, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0x04, 0x7f},
    {0x01, 0x03, 0x46, 0x44, 0x7f},
    {0x02, 0x0b, 0x46, 0x04, 0x7f},
    {0x05, 0x6e, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0x44, 0x7f},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x6a, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x41, 0x04, 0x8f},
    {0x01, 0x0b, 0x41, 0x44, 0x8f},
    {0x02, 0x0c, 0x41, 0x04, 0x8f},
    {0x06, 0x43, 0x01, 0x04, 0x8f},
    {0x03, 0x09, 0x46, 0x04, 0x7f},
    {0x04, 0x0b, 0x41, 0x44, 0x8f},
    {0x02, 0x09, 0x46, 0x04, 0x7f},
    {0x07, 0x6f, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x59, 0xb5, 0xff},
    {0x01, 0x05, 0x46, 0x44, 0x7f},
    {0x02, 0x9a, 0x59, 0xb5, 0xff},
    {0x05, 0x43, 0x01, 0x04, 0x8f},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0x44, 0x7f},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0x19, 0xb5, 0x00, 0xff},
    {0x03, 0x14, 0x43, 0x04, 0x9f},
    {0x01, 0x0c, 0x43, 0x44, 0x9f},
    {0x02, 0x14, 0x43, 0x04, 0x9f},
    {0x06, 0x4b, 0x03, 0x04, 0x9f},
    {0x03, 0x82, 0x6a, 0xb5, 0xff},
    {0x04, 0x0c, 0x43, 0x44, 0x9f},
    {0x02, 0x82, 0x6a, 0xb5, 0xff},
    {0x08, 0x64, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0x04, 0x9f},
    {0x01, 0x09, 0x41, 0x44, 0x8f},
    {0x02, 0x18, 0x43, 0x04, 0x9f},
    {0x05, 0x4b, 0x03, 0x04, 0x9f},
    {0x03, 0x0e, 0x41, 0x04, 0x8f},
    {0x04, 0x09, 0x41, 0x44, 0x8f},
    {0x02, 0x0e, 0x41, 0x04, 0x8f},
    {0x4f, 0x11, 0xb5, 0x40, 0xff},
    {0x03, 0x1c, 0x43, 0x04, 0x9f},
    {0x01, 0x9a, 0x51, 0xf5, 0xff},
    {0x02, 0x1c, 0x43, 0x04, 0x9f},
    {0x06, 0x45, 0x01, 0x04, 0x8f},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x51, 0xf5, 0xff},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0x44, 0x9f},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0x44, 0x7f},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0x04, 0x8f},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0x44, 0x7f},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0xca, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x43, 0x04, 0x9f},
    {0x01, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0x04, 0x9f},
    {0x06, 0x76, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x19, 0x6f},
    {0x04, 0x21, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x19, 0x6f},
    {0x09, 0xc2, 0x44, 0xb5, 0xff},
    {0x03, 0x1b, 0x43, 0x04, 0x9f},
    {0x01, 0x82, 0x59, 0xf5, 0xff},
    {0x02, 0x1b, 0x43, 0x04, 0x9f},
    {0x05, 0x76, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x19, 0x6f},
    {0x04, 0x82, 0x59, 0xf5, 0xff},
    {0x02, 0x05, 0x43, 0x19, 0x6f},
    {0x0b, 0x6a, 0xf5, 0x40, 0xff},
    {0x03, 0x28, 0x41, 0xb5, 0xad},
    {0x01, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x41, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0x04, 0x9f},
    {0x03, 0x10, 0x41, 0x04, 0x8f},
    {0x04, 0x31, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0x04, 0x8f},
    {0x07, 0x7b, 0x02, 0xf5, 0xdf},
    {0x03, 0x8d, 0x44, 0xb5, 0xff},
    {0x01, 0x0e, 0x43, 0x44, 0x9f},
    {0x02, 0x8d, 0x44, 0xb5, 0xff},
    {0x05, 0x49, 0x03, 0x04, 0x9f},
    {0x03, 0x06, 0x43, 0x19, 0x6f},
    {0x04, 0x0e, 0x43, 0x44, 0x9f},
    {0x02, 0x06, 0x43, 0x19, 0x6f},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0x04, 0x9f},
    {0x01, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0x04, 0x9f},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0x04, 0x7f},
    {0x04, 0x3d, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0x04, 0x7f},
    {0x08, 0xc2, 0x44, 0xb5, 0xff},
    {0x03, 0x38, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0x44, 0x7f},
    {0x02, 0x38, 0x41, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x6a, 0xb5, 0xff},
    {0x04, 0x04, 0x46, 0x44, 0x7f},
    {0x02, 0x81, 0x6a, 0xb5, 0xff},
    {0x0c, 0x6a, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x46, 0x04, 0x7f},
    {0x01, 0x02, 0x46, 0x44, 0x7f},
    {0x02, 0x0a, 0x46, 0x04, 0x7f},
    {0x06, 0x46, 0x01, 0x04, 0x8f},
    {0x03, 0x04, 0x43, 0x19, 0x6f},
    {0x04, 0x02, 0x46, 0x44, 0x7f},
    {0x02, 0x04, 0x43, 0x19, 0x6f},
    {0x07, 0x45, 0x03, 0x44, 0x9f},
    {0x03, 0x02, 0x43, 0x19, 0x6f},
    {0x01, 0x07, 0x46, 0x44, 0x7f},
    {0x02, 0x02, 0x43, 0x19, 0x6f},
    {0x05, 0x46, 0x01, 0x04, 0x8f},
    {0x03, 0x07, 0x43, 0x19, 0x6f},
    {0x04, 0x07, 0x46, 0x44, 0x7f},
    {0x02, 0x07, 0x43, 0x19, 0x6f},
    {0xe2, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x41, 0xb5, 0xad},
    {0x01, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x41, 0xb5, 0xad},
    {0x06, 0x64, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x11, 0x6f},
    {0x04, 0x2f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x11, 0x6f},
    {0x09, 0x74, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x11, 0x7f},
    {0x01, 0x03, 0x43, 0x51, 0x7f},
    {0x02, 0x0b, 0x43, 0x11, 0x7f},
    {0x05, 0x64, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x11, 0x6f},
    {0x04, 0x03, 0x43, 0x51, 0x7f},
    {0x02, 0x05, 0x41, 0x11, 0x6f},
    {0x0a, 0x50, 0x42, 0xf5, 0xdf},
    {0x03, 0x36, 0x41, 0xb5, 0xad},
    {0x01, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x41, 0xb5, 0xad},
    {0x06, 0xc2, 0x11, 0xb5, 0xff},
    {0x03, 0x09, 0x43, 0x11, 0x7f},
    {0x04, 0x3b, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x11, 0x7f},
    {0x07, 0x69, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x43, 0x51, 0x7f},
    {0x02, 0x88, 0xf5, 0x00, 0x0a},
    {0x05, 0xc2, 0x11, 0xb5, 0xff},
    {0x03, 0x06, 0x41, 0x11, 0x6f},
    {0x04, 0x05, 0x43, 0x51, 0x7f},
    {0x02, 0x06, 0x41, 0x11, 0x6f},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x41, 0xb5, 0xad},
    {0x01, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x41, 0xb5, 0xad},
    {0x06, 0x74, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x50, 0x02, 0xdf},
    {0x04, 0x29, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x50, 0x02, 0xdf},
    {0x08, 0x74, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x41, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0x44, 0x9f},
    {0x02, 0x34, 0x41, 0xb5, 0xad},
    {0x05, 0x74, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x41, 0x04, 0x8f},
    {0x04, 0x10, 0x43, 0x44, 0x9f},
    {0x02, 0x0f, 0x41, 0x04, 0x8f},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x41, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x41, 0xb5, 0xad},
    {0x06, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x11, 0x6f},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x11, 0x6f},
    {0x07, 0x50, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x11, 0x6f},
    {0x01, 0x06, 0x43, 0x51, 0x7f},
    {0x02, 0x02, 0x41, 0x11, 0x6f},
    {0x05, 0x4f, 0x01, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x11, 0x6f},
    {0x04, 0x06, 0x43, 0x51, 0x7f},
    {0x02, 0x07, 0x41, 0x11, 0x6f},
    {0xc7, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x41, 0x04, 0x8f},
    {0x01, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0x04, 0x8f},
    {0x06, 0x40, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0x19, 0x6f},
    {0x04, 0x1f, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x19, 0x6f},
    {0x09, 0x4f, 0x44, 0xb5, 0xcf},
    {0x03, 0x99, 0x44, 0xb5, 0xff},
    {0x01, 0x08, 0x41, 0x44, 0x8f},
    {0x02, 0x99, 0x44, 0xb5, 0xff},
    {0x05, 0x40, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0x19, 0x6f},
    {0x04, 0x08, 0x41, 0x44, 0x8f},
    {0x02, 0x05, 0x42, 0x19, 0x6f},
    {0x0b, 0x50, 0x42, 0xf5, 0xdf},
    {0x03, 0x2c, 0x41, 0xb5, 0xad},
    {0x01, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x41, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0x04, 0x8f},
    {0x03, 0x11, 0x41, 0x04, 0x8f},
    {0x04, 0x39, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0x04, 0x8f},
    {0x07, 0xd0, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0x44, 0xb5, 0xff},
    {0x01, 0x81, 0x59, 0xf5, 0xff},
    {0x02, 0x95, 0x44, 0xb5, 0xff},
    {0x05, 0x44, 0x01, 0x04, 0x8f},
    {0x03, 0x06, 0x42, 0x19, 0x6f},
    {0x04, 0x81, 0x59, 0xf5, 0xff},
    {0x02, 0x06, 0x42, 0x19, 0x6f},
    {0x4e, 0x19, 0xb5, 0x00, 0xff},
    {0x03, 0x01, 0x41, 0x04, 0x8f},
    {0x01, 0x0a, 0x41, 0x44, 0x8f},
    {0x02, 0x01, 0x41, 0x04, 0x8f},
    {0x06, 0x42, 0x01, 0x04, 0x8f},
    {0x03, 0x08, 0x43, 0x11, 0x7f},
    {0x04, 0x0a, 0x41, 0x44, 0x8f},
    {0x02, 0x08, 0x43, 0x11, 0x7f},
    {0x08, 0x4f, 0x44, 0xb5, 0xcf},
    {0x03, 0x83, 0x59, 0xb5, 0xff},
    {0x01, 0x04, 0x43, 0x51, 0x7f},
    {0x02, 0x83, 0x59, 0xb5, 0xff},
    {0x05, 0x42, 0x01, 0x04, 0x8f},
    {0x03, 0x81, 0x50, 0x02, 0xdf},
    {0x04, 0x04, 0x43, 0x51, 0x7f},
    {0x02, 0x81, 0x50, 0x02, 0xdf},
    {0x0c, 0x50, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x43, 0x11, 0x7f},
    {0x01, 0x02, 0x43, 0x51, 0x7f},
    {0x02, 0x0a, 0x43, 0x11, 0x7f},
    {0x06, 0x47, 0x01, 0x04, 0x8f},
    {0x03, 0x04, 0x42, 0x19, 0x6f},
    {0x04, 0x02, 0x43, 0x51, 0x7f},
    {0x02, 0x04, 0x42, 0x19, 0x6f},
    {0x07, 0x46, 0x03, 0x44, 0x9f},
    {0x03, 0x02, 0x42, 0x19, 0x6f},
    {0x01, 0x07, 0x43, 0x51, 0x7f},
    {0x02, 0x02, 0x42, 0x19, 0x6f},
    {0x05, 0x47, 0x01, 0x04, 0x8f},
    {0x03, 0x07, 0x42, 0x19, 0x6f},
    {0x04, 0x07, 0x43, 0x51, 0x7f},
    {0x02, 0x07, 0x42, 0x19, 0x6f},
    {0xf4, 0x51, 0xf5, 0x40, 0x0f},
    {0x03, 0x1e, 0x41, 0xb5, 0xad},
    {0x01, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x1e, 0x41, 0xb5, 0xad},
    {0x06, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0xb5, 0x6a},
    {0x04, 0x16, 0x41, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0xb5, 0x6a},
    {0x09, 0x40, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0xb5, 0x7a},
    {0x01, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x0b, 0x44, 0xb5, 0x7a},
    {0x05, 0x4d, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0xb5, 0x6a},
    {0x04, 0x03, 0x44, 0xf5, 0x7a},
    {0x02, 0x05, 0x45, 0xb5, 0x6a},
    {0x0a, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0c, 0x42, 0xb5, 0x8a},
    {0x01, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x0c, 0x42, 0xb5, 0x8a},
    {0x06, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x09, 0x44, 0xb5, 0x7a},
    {0x04, 0x0b, 0x42, 0xf5, 0x8a},
    {0x02, 0x09, 0x44, 0xb5, 0x7a},
    {0x07, 0x5f, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x4f, 0xb5, 0xee},
    {0x01, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x9a, 0x4f, 0xb5, 0xee},
    {0x05, 0x43, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x45, 0xb5, 0x6a},
    {0x04, 0x05, 0x44, 0xf5, 0x7a},
    {0x02, 0x06, 0x45, 0xb5, 0x6a},
    {0x4d, 0x0f, 0xb5, 0x00, 0xee},
    {0x03, 0x22, 0x41, 0xb5, 0xad},
    {0x01, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x22, 0x41, 0xb5, 0xad},
    {0x06, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xf5, 0x00, 0x07},
    {0x04, 0x1a, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0xf5, 0x00, 0x07},
    {0x08, 0x40, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x41, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x32, 0x41, 0xb5, 0xad},
    {0x05, 0xd9, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0xb5, 0x8a},
    {0x04, 0x09, 0x42, 0xf5, 0x8a},
    {0x02, 0x0e, 0x42, 0xb5, 0x8a},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x41, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x41, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x45, 0xb5, 0x6a},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0xb5, 0x6a},
    {0x07, 0x48, 0x01, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0xb5, 0x6a},
    {0x01, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x45, 0xb5, 0x6a},
    {0x05, 0x45, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x45, 0xb5, 0x6a},
    {0x04, 0x06, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x45, 0xb5, 0x6a},
    {0xd8, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x30, 0x41, 0xb5, 0xad},
    {0x01, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x41, 0xb5, 0xad},
    {0x06, 0x6c, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x0f, 0x6e},
    {0x04, 0x25, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x0f, 0x6e},
    {0x09, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3c, 0x41, 0xb5, 0xad},
    {0x01, 0x82, 0x4f, 0xf5, 0xee},
    {0x02, 0x3c, 0x41, 0xb5, 0xad},
    {0x05, 0x6c, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x0f, 0x6e},
    {0x04, 0x82, 0x4f, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0f, 0x6e},
    {0x0b, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x2a, 0x41, 0xb5, 0xad},
    {0x01, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x2a, 0x41, 0xb5, 0xad},
    {0x06, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0xb5, 0x8a},
    {0x04, 0x19, 0x41, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0xb5, 0x8a},
    {0x07, 0x79, 0x02, 0xf5, 0xdf},
    {0x03, 0x91, 0x44, 0xb5, 0xff},
    {0x01, 0x0f, 0x43, 0x44, 0x9f},
    {0x02, 0x91, 0x44, 0xb5, 0xff},
    {0x05, 0x51, 0x01, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x0f, 0x6e},
    {0x04, 0x0f, 0x43, 0x44, 0x9f},
    {0x02, 0x06, 0x43, 0x0f, 0x6e},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x41, 0xb5, 0xad},
    {0x01, 0x85, 0x44, 0xf5, 0xff},
    {0x02, 0x20, 0x41, 0xb5, 0xad},
    {0x06, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0xb5, 0x7a},
    {0x04, 0x85, 0x44, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0xb5, 0x7a},
    {0x08, 0x44, 0x41, 0xb5, 0xad},
    {0x03, 0x3a, 0x41, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x3a, 0x41, 0xb5, 0xad},
    {0x05, 0xd5, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xf5, 0x00, 0x07},
    {0x04, 0x04, 0x44, 0xf5, 0x7a},
    {0x02, 0x81, 0xf5, 0x00, 0x07},
    {0x0c, 0xf5, 0x40, 0x40, 0x07},
    {0x03, 0x0a, 0x44, 0xb5, 0x7a},
    {0x01, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x0a, 0x44, 0xb5, 0x7a},
    {0x06, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x43, 0x0f, 0x6e},
    {0x04, 0x02, 0x44, 0xf5, 0x7a},
    {0x02, 0x04, 0x43, 0x0f, 0x6e},
    {0x07, 0xc1, 0xb5, 0x40, 0x0a},
    {0x03, 0x02, 0x43, 0x0f, 0x6e},
    {0x01, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x02, 0x43, 0x0f, 0x6e},
    {0x05, 0x46, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x43, 0x0f, 0x6e},
    {0x04, 0x07, 0x44, 0xf5, 0x7a},
    {0x02, 0x07, 0x43, 0x0f, 0x6e},
    {0xe6, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x43, 0x04, 0x9f},
    {0x01, 0x0d, 0x43, 0x44, 0x9f},
    {0x02, 0x16, 0x43, 0x04, 0x9f},
    {0x06, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x11, 0x6f},
    {0x04, 0x0d, 0x43, 0x44, 0x9f},
    {0x02, 0x03, 0x44, 0x11, 0x6f},
    {0x09, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x11, 0x7f},
    {0x01, 0x03, 0x42, 0x51, 0x7f},
    {0x02, 0x0b, 0x42, 0x11, 0x7f},
    {0x05, 0x41, 0x01, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x11, 0x6f},
    {0x04, 0x03, 0x42, 0x51, 0x7f},
    {0x02, 0x05, 0x44, 0x11, 0x6f},
    {0x0a, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0x04, 0x9f},
    {0x01, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0x04, 0x9f},
    {0x06, 0x48, 0x03, 0x04, 0x9f},
    {0x03, 0x09, 0x42, 0x11, 0x7f},
    {0x04, 0x12, 0x41, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x11, 0x7f},
    {0x07, 0x4a, 0x01, 0xf5, 0xad},
    {0x03, 0x8a, 0xf5, 0x00, 0x0a},
    {0x01, 0x05, 0x42, 0x51, 0x7f},
    {0x02, 0x8a, 0xf5, 0x00, 0x0a},
    {0x05, 0x48, 0x03, 0x04, 0x9f},
    {0x03, 0x06, 0x44, 0x11, 0x6f},
    {0x04, 0x05, 0x42, 0x51, 0x7f},
    {0x02, 0x06, 0x44, 0x11, 0x6f},
    {0x50, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x26, 0x41, 0xb5, 0xad},
    {0x01, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x26, 0x41, 0xb5, 0xad},
    {0x06, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x82, 0x46, 0x03, 0xbd},
    {0x04, 0x15, 0x41, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x03, 0xbd},
    {0x08, 0x42, 0x41, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0x04, 0x9f},
    {0x01, 0x11, 0x43, 0x44, 0x9f},
    {0x02, 0x19, 0x43, 0x04, 0x9f},
    {0x05, 0xc3, 0xb5, 0x00, 0x0a},
    {0x03, 0x0f, 0x42, 0xb5, 0x8a},
    {0x04, 0x11, 0x43, 0x44, 0x9f},
    {0x02, 0x0f, 0x42, 0xb5, 0x8a},
    {0x40, 0xb5, 0x40, 0x00, 0x0a},
    {0x03, 0x86, 0xf5, 0x00, 0x0a},
    {0x01, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x86, 0xf5, 0x00, 0x0a},
    {0x06, 0xc1, 0x11, 0xb5, 0xff},
    {0x03, 0x04, 0x44, 0x11, 0x6f},
    {0x04, 0x84, 0xf5, 0x40, 0x0a},
    {0x02, 0x04, 0x44, 0x11, 0x6f},
    {0x07, 0x44, 0x03, 0x44, 0x9f},
    {0x03, 0x02, 0x44, 0x11, 0x6f},
    {0x01, 0x06, 0x42, 0x51, 0x7f},
    {0x02, 0x02, 0x44, 0x11, 0x6f},
    {0x05, 0xc1, 0x11, 0xb5, 0xff},
    {0x03, 0x07, 0x44, 0x11, 0x6f},
    {0x04, 0x06, 0x42, 0x51, 0x7f},
    {0x02, 0x07, 0x44, 0x11, 0x6f},
    {0xc1, 0x41, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0xb5, 0x8a},
    {0x01, 0x01, 0x43, 0x44, 0x9f},
    {0x02, 0x0d, 0x42, 0xb5, 0x8a},
    {0x06, 0x4a, 0x03, 0x04, 0x9f},
    {0x03, 0x03, 0x42, 0x0f, 0x6e},
    {0x04, 0x01, 0x43, 0x44, 0x9f},
    {0x02, 0x03, 0x42, 0x0f, 0x6e},
    {0x09, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0x04, 0x9f},
    {0x01, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x12, 0x43, 0x04, 0x9f},
    {0x05, 0x4a, 0x03, 0x04, 0x9f},
    {0x03, 0x05, 0x42, 0x0f, 0x6e},
    {0x04, 0x08, 0x42, 0xf5, 0x8a},
    {0x02, 0x05, 0x42, 0x0f, 0x6e},
    {0x0b, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0x04, 0x9f},
    {0x01, 0x83, 0x51, 0xf5, 0xff},
    {0x02, 0x15, 0x43, 0x04, 0x9f},
    {0x06, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x11, 0x42, 0xb5, 0x8a},
    {0x04, 0x83, 0x51, 0xf5, 0xff},
    {0x02, 0x11, 0x42, 0xb5, 0x8a},
    {0x07, 0x42, 0x03, 0x44, 0x9f},
    {0x03, 0x84, 0x51, 0xb5, 0xff},
    {0x01, 0x81, 0x4f, 0xf5, 0xee},
    {0x02, 0x84, 0x51, 0xb5, 0xff},
    {0x05, 0x44, 0x02, 0xb5, 0x8a},
    {0x03, 0x06, 0x42, 0x0f, 0x6e},
    {0x04, 0x81, 0x4f, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0f, 0x6e},
    {0x4e, 0x0f, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x42, 0xb5, 0x8a},
    {0x01, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x01, 0x42, 0xb5, 0x8a},
    {0x06, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x08, 0x42, 0x11, 0x7f},
    {0x04, 0x0a, 0x42, 0xf5, 0x8a},
    {0x02, 0x08, 0x42, 0x11, 0x7f},
    {0x08, 0x47, 0x41, 0xb5, 0xad},
    {0x03, 0x83, 0x4f, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0x51, 0x7f},
    {0x02, 0x83, 0x4f, 0xb5, 0xee},
    {0x05, 0x42, 0x02, 0xb5, 0x8a},
    {0x03, 0x81, 0x46, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x51, 0x7f},
    {0x02, 0x81, 0x46, 0x03, 0xbd},
    {0x0c, 0x46, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x11, 0x7f},
    {0x01, 0x02, 0x42, 0x51, 0x7f},
    {0x02, 0x0a, 0x42, 0x11, 0x7f},
    {0x06, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x04, 0x42, 0x0f, 0x6e},
    {0x04, 0x02, 0x42, 0x51, 0x7f},
    {0x02, 0x04, 0x42, 0x0f, 0x6e},
    {0x07, 0x47, 0x03, 0x44, 0x9f},
    {0x03, 0x02, 0x42, 0x0f, 0x6e},
    {0x01, 0x07, 0x42, 0x51, 0x7f},
    {0x02, 0x02, 0x42, 0x0f, 0x6e},
    {0x05, 0x47, 0x02, 0xb5, 0x8a},
    {0x03, 0x07, 0x42, 0x0f, 0x6e},
    {0x04, 0x07, 0x42, 0x51, 0x7f},
    {0x02, 0x07, 0x42, 0x0f, 0x6e},
    {0xf4, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0xb4, 0x44, 0xb5, 0xff},
    {0x01, 0x9e, 0xf5, 0x40, 0x0e},
    {0x02, 0xb4, 0x44, 0xb5, 0xff},
    {0x06, 0x5e, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0x9e, 0xf5, 0x40, 0x0e},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x4d, 0x44, 0xb5, 0xcf},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x60, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0x04, 0xf5, 0xcf},
    {0x03, 0x9a, 0xf5, 0x00, 0x08},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0xf5, 0x00, 0x08},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x60, 0xb5, 0xff},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x60, 0xb5, 0xff},
    {0x08, 0x4d, 0x44, 0xb5, 0xcf},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0xb5, 0x00, 0x40, 0x09},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0xf5, 0x40, 0x09},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0x81, 0xf5, 0x00, 0x0f},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0xb5, 0x68},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0xb5, 0x68},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0xb5, 0x68},
    {0x04, 0x82, 0xf5, 0x40, 0x08},
    {0x02, 0x05, 0x43, 0xb5, 0x68},
    {0x0b, 0x60, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0xc1, 0xb5, 0x0f},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0xc1, 0xb5, 0x0f},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0xb5, 0x68},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0xb5, 0x68},
    {0x51, 0x81, 0xf5, 0x00, 0x0f},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0x81, 0xb5, 0x0f},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0x81, 0xb5, 0x0f},
    {0x03, 0x81, 0x60, 0xb5, 0xff},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x60, 0xb5, 0xff},
    {0x0c, 0x60, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0xb5, 0x68},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0xb5, 0x68},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0xb5, 0x68},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0xb5, 0x68},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0xb5, 0x68},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0xb5, 0x68},
    {0xe0, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0xb5, 0x69},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0xb5, 0x69},
    {0x09, 0xdb, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x43, 0xb5, 0x79},
    {0x01, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x0b, 0x43, 0xb5, 0x79},
    {0x05, 0x62, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0xb5, 0x69},
    {0x04, 0x03, 0x43, 0xf5, 0x79},
    {0x02, 0x05, 0x41, 0xb5, 0x69},
    {0x0a, 0x48, 0x44, 0xf5, 0xcf},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x09, 0x43, 0xb5, 0x79},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0xb5, 0x79},
    {0x07, 0x5a, 0x04, 0xf5, 0xcf},
    {0x03, 0x87, 0xc1, 0xb5, 0x0f},
    {0x01, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x87, 0xc1, 0xb5, 0x0f},
    {0x05, 0xc2, 0xb5, 0x00, 0x09},
    {0x03, 0x06, 0x41, 0xb5, 0x69},
    {0x04, 0x05, 0x43, 0xf5, 0x79},
    {0x02, 0x06, 0x41, 0xb5, 0x69},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x48, 0x04, 0xcf},
    {0x04, 0x28, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0x04, 0xcf},
    {0x08, 0xdb, 0xf5, 0x00, 0x0f},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0xb5, 0x69},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0xb5, 0x69},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0xb5, 0x69},
    {0x01, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x41, 0xb5, 0x69},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0xb5, 0x69},
    {0x04, 0x06, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x41, 0xb5, 0x69},
    {0xc5, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x42, 0xb5, 0x68},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0xb5, 0x68},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0x44, 0xb5, 0xff},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0x44, 0xb5, 0xff},
    {0x05, 0x7e, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x42, 0xb5, 0x68},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0xb5, 0x68},
    {0x0b, 0x48, 0x44, 0xf5, 0xcf},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xcc, 0xb5, 0x40, 0x0e},
    {0x03, 0x94, 0x44, 0xb5, 0xff},
    {0x01, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x94, 0x44, 0xb5, 0xff},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0xb5, 0x68},
    {0x04, 0x81, 0xf5, 0x40, 0x08},
    {0x02, 0x06, 0x42, 0xb5, 0x68},
    {0x4e, 0xb5, 0x00, 0x00, 0x08},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0xb5, 0x79},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0xb5, 0x79},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0xf5, 0x00, 0x08},
    {0x01, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x83, 0xf5, 0x00, 0x08},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0x04, 0xcf},
    {0x04, 0x04, 0x43, 0xf5, 0x79},
    {0x02, 0x81, 0x48, 0x04, 0xcf},
    {0x0c, 0x48, 0x44, 0xf5, 0xcf},
    {0x03, 0x0a, 0x43, 0xb5, 0x79},
    {0x01, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x0a, 0x43, 0xb5, 0x79},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0xb5, 0x68},
    {0x04, 0x02, 0x43, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0xb5, 0x68},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0xb5, 0x68},
    {0x01, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0xb5, 0x68},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0xb5, 0x68},
    {0x04, 0x07, 0x43, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0xb5, 0x68},
    {0xb4, 0xb5, 0x00, 0x00, 0x09},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x46, 0x81, 0x6f},
    {0x04, 0x2e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x81, 0x6f},
    {0x09, 0x6c, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x81, 0x7f},
    {0x01, 0x03, 0x41, 0xc1, 0x7f},
    {0x02, 0x0b, 0x41, 0x81, 0x7f},
    {0x05, 0x70, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x46, 0x81, 0x6f},
    {0x04, 0x03, 0x41, 0xc1, 0x7f},
    {0x02, 0x05, 0x46, 0x81, 0x6f},
    {0x0a, 0x7a, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x43, 0x81, 0x8f},
    {0x01, 0x0b, 0x43, 0xc1, 0x8f},
    {0x02, 0x0c, 0x43, 0x81, 0x8f},
    {0x06, 0x43, 0x03, 0x81, 0x8f},
    {0x03, 0x09, 0x41, 0x81, 0x7f},
    {0x04, 0x0b, 0x43, 0xc1, 0x8f},
    {0x02, 0x09, 0x41, 0x81, 0x7f},
    {0x07, 0x65, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x44, 0x04, 0xcf},
    {0x01, 0x05, 0x41, 0xc1, 0x7f},
    {0x02, 0x9a, 0x44, 0x04, 0xcf},
    {0x05, 0x43, 0x03, 0x81, 0x8f},
    {0x03, 0x06, 0x46, 0x81, 0x6f},
    {0x04, 0x05, 0x41, 0xc1, 0x7f},
    {0x02, 0x06, 0x46, 0x81, 0x6f},
    {0x4d, 0x04, 0x04, 0xb5, 0xcf},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0x7a, 0xb5, 0xff},
    {0x04, 0x36, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x7a, 0xb5, 0xff},
    {0x08, 0x6c, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0xc1, 0x8f},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0x04, 0xb5, 0xcf},
    {0x03, 0x0e, 0x43, 0x81, 0x8f},
    {0x04, 0x09, 0x43, 0xc1, 0x8f},
    {0x02, 0x0e, 0x43, 0x81, 0x8f},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0x44, 0xf5, 0xff},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x81, 0x8f},
    {0x03, 0x04, 0x46, 0x81, 0x6f},
    {0x04, 0x88, 0x44, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x81, 0x6f},
    {0x07, 0xc2, 0x81, 0xf5, 0x0f},
    {0x03, 0x02, 0x46, 0x81, 0x6f},
    {0x01, 0x06, 0x41, 0xc1, 0x7f},
    {0x02, 0x02, 0x46, 0x81, 0x6f},
    {0x05, 0x45, 0x03, 0x81, 0x8f},
    {0x03, 0x07, 0x46, 0x81, 0x6f},
    {0x04, 0x06, 0x41, 0xc1, 0x7f},
    {0x02, 0x07, 0x46, 0x81, 0x6f},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0x44, 0xb5, 0xcf},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0x44, 0xcf},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0x7a, 0xf5, 0x40, 0xff},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x81, 0x8f},
    {0x04, 0x34, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x81, 0x8f},
    {0x07, 0x59, 0x04, 0xf5, 0xcf},
    {0x03, 0x90, 0x44, 0xb5, 0xff},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0x44, 0xb5, 0xff},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x81, 0x7f},
    {0x04, 0x00, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x81, 0x7f},
    {0x08, 0x51, 0x44, 0xb5, 0xcf},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0xc1, 0x7f},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd1, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x7a, 0xb5, 0xff},
    {0x04, 0x04, 0x41, 0xc1, 0x7f},
    {0x02, 0x81, 0x7a, 0xb5, 0xff},
    {0x0c, 0x7a, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x41, 0x81, 0x7f},
    {0x01, 0x02, 0x41, 0xc1, 0x7f},
    {0x02, 0x0a, 0x41, 0x81, 0x7f},
    {0x06, 0x46, 0x03, 0x81, 0x8f},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0xc1, 0x7f},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0xc1, 0x7f},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0x81, 0x8f},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0xc1, 0x7f},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x43, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x44, 0xb5, 0x69},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0xb5, 0x69},
    {0x09, 0xd6, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0xb5, 0x79},
    {0x01, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x0b, 0x42, 0xb5, 0x79},
    {0x05, 0x60, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x44, 0xb5, 0x69},
    {0x04, 0x03, 0x42, 0xf5, 0x79},
    {0x02, 0x05, 0x44, 0xb5, 0x69},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0xb5, 0x79},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0xb5, 0x79},
    {0x07, 0xc5, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0x44, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x8c, 0x44, 0xb5, 0xff},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0xb5, 0x69},
    {0x04, 0x05, 0x42, 0xf5, 0x79},
    {0x02, 0x06, 0x44, 0xb5, 0x69},
    {0xc4, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0x04, 0xb5, 0xcf},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xd6, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0x04, 0xb5, 0xcf},
    {0x03, 0x0f, 0x43, 0x81, 0x8f},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x81, 0x8f},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0xc1, 0xb5, 0x0f},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0xc1, 0xb5, 0x0f},
    {0x06, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x04, 0x44, 0xb5, 0x69},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0xb5, 0x69},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0xb5, 0x69},
    {0x01, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x44, 0xb5, 0x69},
    {0x05, 0xc1, 0xb5, 0x00, 0x09},
    {0x03, 0x07, 0x44, 0xb5, 0x69},
    {0x04, 0x06, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x44, 0xb5, 0x69},
    {0xd2, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x81, 0x8f},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x81, 0x8f},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0xc1, 0x8f},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0xc1, 0x8f},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x81, 0x8f},
    {0x03, 0x11, 0x43, 0x81, 0x8f},
    {0x04, 0x83, 0xf5, 0x40, 0x09},
    {0x02, 0x11, 0x43, 0x81, 0x8f},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0xf5, 0x00, 0x09},
    {0x01, 0x81, 0x44, 0x44, 0xcf},
    {0x02, 0x84, 0xf5, 0x00, 0x09},
    {0x05, 0x44, 0x03, 0x81, 0x8f},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x43, 0x81, 0x8f},
    {0x01, 0x0a, 0x43, 0xc1, 0x8f},
    {0x02, 0x01, 0x43, 0x81, 0x8f},
    {0x06, 0x42, 0x03, 0x81, 0x8f},
    {0x03, 0x08, 0x42, 0xb5, 0x79},
    {0x04, 0x0a, 0x43, 0xc1, 0x8f},
    {0x02, 0x08, 0x42, 0xb5, 0x79},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0x04, 0xcf},
    {0x01, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x83, 0x44, 0x04, 0xcf},
    {0x05, 0x42, 0x03, 0x81, 0x8f},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0xf5, 0x79},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0xb5, 0x79},
    {0x01, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x0a, 0x42, 0xb5, 0x79},
    {0x06, 0x47, 0x03, 0x81, 0x8f},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0xf5, 0x79},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0x81, 0x8f},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0xf5, 0x79},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xb4, 0x81, 0xb5, 0x00, 0x0f},
    {0x03, 0xa6, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0xa6, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0x04, 0x6f},
    {0x04, 0x1e, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0x04, 0x6f},
    {0x09, 0x41, 0x44, 0xb5, 0xcf},
    {0x03, 0x0b, 0x45, 0x04, 0x7f},
    {0x01, 0x03, 0x45, 0x44, 0x7f},
    {0x02, 0x0b, 0x45, 0x04, 0x7f},
    {0x05, 0x56, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0x04, 0x6f},
    {0x04, 0x03, 0x45, 0x44, 0x7f},
    {0x02, 0x05, 0x47, 0x04, 0x6f},
    {0x0a, 0x4a, 0x44, 0xf5, 0xcf},
    {0x03, 0x0c, 0x44, 0x04, 0x8f},
    {0x01, 0x0b, 0x44, 0x44, 0x8f},
    {0x02, 0x0c, 0x44, 0x04, 0x8f},
    {0x06, 0x43, 0x04, 0x04, 0x8f},
    {0x03, 0x09, 0x45, 0x04, 0x7f},
    {0x04, 0x0b, 0x44, 0x44, 0x8f},
    {0x02, 0x09, 0x45, 0x04, 0x7f},
    {0x07, 0x4d, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0x04, 0xcf},
    {0x01, 0x05, 0x45, 0x44, 0x7f},
    {0x02, 0x9a, 0x42, 0x04, 0xcf},
    {0x05, 0x43, 0x04, 0x04, 0x8f},
    {0x03, 0x06, 0x47, 0x04, 0x6f},
    {0x04, 0x05, 0x45, 0x44, 0x7f},
    {0x02, 0x06, 0x47, 0x04, 0x6f},
    {0x4d, 0x02, 0x04, 0xb5, 0xcf},
    {0x03, 0x14, 0x42, 0x04, 0x9f},
    {0x01, 0x0c, 0x42, 0x44, 0x9f},
    {0x02, 0x14, 0x42, 0x04, 0x9f},
    {0x06, 0x4b, 0x02, 0x04, 0x9f},
    {0x03, 0x82, 0x4a, 0x04, 0xcf},
    {0x04, 0x0c, 0x42, 0x44, 0x9f},
    {0x02, 0x82, 0x4a, 0x04, 0xcf},
    {0x08, 0x41, 0x44, 0xb5, 0xcf},
    {0x03, 0x18, 0x42, 0x04, 0x9f},
    {0x01, 0x09, 0x44, 0x44, 0x8f},
    {0x02, 0x18, 0x42, 0x04, 0x9f},
    {0x05, 0x4b, 0x02, 0x04, 0x9f},
    {0x03, 0x0e, 0x44, 0x04, 0x8f},
    {0x04, 0x09, 0x44, 0x44, 0x8f},
    {0x02, 0x0e, 0x44, 0x04, 0x8f},
    {0x4f, 0x06, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0x04, 0x9f},
    {0x01, 0x9a, 0x46, 0x42, 0xdf},
    {0x02, 0x1c, 0x42, 0x04, 0x9f},
    {0x06, 0x45, 0x04, 0x04, 0x8f},
    {0x03, 0x04, 0x47, 0x04, 0x6f},
    {0x04, 0x9a, 0x46, 0x42, 0xdf},
    {0x02, 0x04, 0x47, 0x04, 0x6f},
    {0x07, 0x43, 0x02, 0x44, 0x9f},
    {0x03, 0x02, 0x47, 0x04, 0x6f},
    {0x01, 0x06, 0x45, 0x44, 0x7f},
    {0x02, 0x02, 0x47, 0x04, 0x6f},
    {0x05, 0x45, 0x04, 0x04, 0x8f},
    {0x03, 0x07, 0x47, 0x04, 0x6f},
    {0x04, 0x06, 0x45, 0x44, 0x7f},
    {0x02, 0x07, 0x47, 0x04, 0x6f},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0x04, 0x9f},
    {0x01, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0x04, 0x9f},
    {0x06, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0x04, 0x9f},
    {0x01, 0x82, 0x42, 0x44, 0xcf},
    {0x02, 0x1b, 0x42, 0x04, 0x9f},
    {0x05, 0x5a, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0x44, 0xf5, 0xcf},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0x04, 0x9f},
    {0x03, 0x10, 0x44, 0x04, 0x8f},
    {0x04, 0x32, 0x43, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0x04, 0x8f},
    {0x07, 0x52, 0x04, 0xf5, 0xcf},
    {0x03, 0x8e, 0x44, 0xb5, 0xff},
    {0x01, 0x0e, 0x42, 0x44, 0x9f},
    {0x02, 0x8e, 0x44, 0xb5, 0xff},
    {0x05, 0x49, 0x02, 0x04, 0x9f},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0x44, 0x9f},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0x04, 0x9f},
    {0x01, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0x04, 0x9f},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0x04, 0x7f},
    {0x04, 0x3e, 0x43, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0x04, 0x7f},
    {0x08, 0x48, 0x43, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0x44, 0x7f},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0x04, 0xcf},
    {0x04, 0x04, 0x45, 0x44, 0x7f},
    {0x02, 0x81, 0x4a, 0x04, 0xcf},
    {0x0c, 0x4a, 0x44, 0xf5, 0xcf},
    {0x03, 0x0a, 0x45, 0x04, 0x7f},
    {0x01, 0x02, 0x45, 0x44, 0x7f},
    {0x02, 0x0a, 0x45, 0x04, 0x7f},
    {0x06, 0x46, 0x04, 0x04, 0x8f},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0x44, 0x7f},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0x44, 0x9f},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0x44, 0x7f},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0x04, 0x8f},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0x44, 0x7f},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xe4, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0x04, 0xb5, 0xcf},
    {0x03, 0x03, 0x41, 0x06, 0x6d},
    {0x04, 0x30, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x06, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x06, 0x7d},
    {0x01, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x0b, 0x43, 0x06, 0x7d},
    {0x05, 0x66, 0x04, 0xb5, 0xcf},
    {0x03, 0x05, 0x41, 0x06, 0x6d},
    {0x04, 0x03, 0x43, 0x46, 0x7d},
    {0x02, 0x05, 0x41, 0x06, 0x6d},
    {0x0a, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x06, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x06, 0x7d},
    {0x04, 0x3c, 0x43, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x06, 0x7d},
    {0x07, 0x55, 0x04, 0xf5, 0xcf},
    {0x03, 0x88, 0xc1, 0xb5, 0x0f},
    {0x01, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x88, 0xc1, 0xb5, 0x0f},
    {0x05, 0xc2, 0x06, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x06, 0x6d},
    {0x04, 0x05, 0x43, 0x46, 0x7d},
    {0x02, 0x06, 0x41, 0x06, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x03, 0xbd},
    {0x04, 0x2a, 0x43, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x03, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0x44, 0x9f},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x03, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0x04, 0x8f},
    {0x04, 0x10, 0x42, 0x44, 0x9f},
    {0x02, 0x0f, 0x44, 0x04, 0x8f},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x06, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x06, 0x6d},
    {0x07, 0x51, 0x03, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x06, 0x6d},
    {0x01, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x41, 0x06, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x06, 0x6d},
    {0x04, 0x06, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x41, 0x06, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0x04, 0x8f},
    {0x01, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0x04, 0x8f},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0x44, 0xb5, 0xff},
    {0x03, 0x9b, 0x44, 0xb5, 0xff},
    {0x01, 0x08, 0x44, 0x44, 0x8f},
    {0x02, 0x9b, 0x44, 0xb5, 0xff},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0x44, 0x8f},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0x04, 0x8f},
    {0x03, 0x11, 0x44, 0x04, 0x8f},
    {0x04, 0x3a, 0x43, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0x04, 0x8f},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0x44, 0xb5, 0xff},
    {0x01, 0x81, 0x42, 0x44, 0xcf},
    {0x02, 0x96, 0x44, 0xb5, 0xff},
    {0x05, 0x44, 0x04, 0x04, 0x8f},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x44, 0x04, 0x8f},
    {0x01, 0x0a, 0x44, 0x44, 0x8f},
    {0x02, 0x01, 0x44, 0x04, 0x8f},
    {0x06, 0x42, 0x04, 0x04, 0x8f},
    {0x03, 0x08, 0x43, 0x06, 0x7d},
    {0x04, 0x0a, 0x44, 0x44, 0x8f},
    {0x02, 0x08, 0x43, 0x06, 0x7d},
    {0x08, 0xc1, 0x44, 0xb5, 0xff},
    {0x03, 0x83, 0x42, 0x04, 0xcf},
    {0x01, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x83, 0x42, 0x04, 0xcf},
    {0x05, 0x42, 0x04, 0x04, 0x8f},
    {0x03, 0x81, 0x44, 0x03, 0xbd},
    {0x04, 0x04, 0x43, 0x46, 0x7d},
    {0x02, 0x81, 0x44, 0x03, 0xbd},
    {0x0c, 0x44, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x06, 0x7d},
    {0x01, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x0a, 0x43, 0x06, 0x7d},
    {0x06, 0x47, 0x04, 0x04, 0x8f},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0x44, 0x9f},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0x04, 0x8f},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x46, 0x02, 0xf5, 0xff},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x81, 0x6f},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x81, 0x6f},
    {0x09, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0x81, 0x7f},
    {0x01, 0x03, 0x44, 0xc1, 0x7f},
    {0x02, 0x0b, 0x44, 0x81, 0x7f},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x81, 0x6f},
    {0x04, 0x03, 0x44, 0xc1, 0x7f},
    {0x02, 0x05, 0x45, 0x81, 0x6f},
    {0x0a, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0x81, 0x8f},
    {0x01, 0x0b, 0x42, 0xc1, 0x8f},
    {0x02, 0x0c, 0x42, 0x81, 0x8f},
    {0x06, 0x43, 0x02, 0x81, 0x8f},
    {0x03, 0x09, 0x44, 0x81, 0x7f},
    {0x04, 0x0b, 0x42, 0xc1, 0x8f},
    {0x02, 0x09, 0x44, 0x81, 0x7f},
    {0x07, 0x41, 0x03, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0x04, 0xcf},
    {0x01, 0x05, 0x44, 0xc1, 0x7f},
    {0x02, 0x9a, 0x47, 0x04, 0xcf},
    {0x05, 0x43, 0x02, 0x81, 0x8f},
    {0x03, 0x06, 0x45, 0x81, 0x6f},
    {0x04, 0x05, 0x44, 0xc1, 0x7f},
    {0x02, 0x06, 0x45, 0x81, 0x6f},
    {0x4d, 0x07, 0x04, 0xb5, 0xcf},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x03, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x03, 0xbd},
    {0x08, 0x4a, 0x43, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0xc1, 0x8f},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x03, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0x81, 0x8f},
    {0x04, 0x09, 0x42, 0xc1, 0x8f},
    {0x02, 0x0e, 0x42, 0x81, 0x8f},
    {0x53, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0x44, 0xf5, 0xff},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x81, 0x8f},
    {0x03, 0x04, 0x45, 0x81, 0x6f},
    {0x04, 0x8a, 0x44, 0xf5, 0xff},
    {0x02, 0x04, 0x45, 0x81, 0x6f},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x81, 0x6f},
    {0x01, 0x06, 0x44, 0xc1, 0x7f},
    {0x02, 0x02, 0x45, 0x81, 0x6f},
    {0x05, 0x45, 0x02, 0x81, 0x8f},
    {0x03, 0x07, 0x45, 0x81, 0x6f},
    {0x04, 0x06, 0x44, 0xc1, 0x7f},
    {0x02, 0x07, 0x45, 0x81, 0x6f},
    {0x58, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x43, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0x44, 0xcf},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x03, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0x44, 0xcf},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x81, 0x8f},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x81, 0x8f},
    {0x07, 0xc3, 0x04, 0xf5, 0xff},
    {0x03, 0x92, 0x44, 0xb5, 0xff},
    {0x01, 0x0f, 0x42, 0x44, 0x9f},
    {0x02, 0x92, 0x44, 0xb5, 0xff},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0x44, 0x9f},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0x04, 0xf5, 0x40, 0xff},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0x44, 0xf5, 0xff},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0x04, 0xb5, 0xff},
    {0x03, 0x08, 0x44, 0x81, 0x7f},
    {0x04, 0x86, 0x44, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x81, 0x7f},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0xc1, 0x7f},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0x04, 0xb5, 0xff},
    {0x03, 0x81, 0x42, 0x03, 0xbd},
    {0x04, 0x04, 0x44, 0xc1, 0x7f},
    {0x02, 0x81, 0x42, 0x03, 0xbd},
    {0x0c, 0x42, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0x81, 0x7f},
    {0x01, 0x02, 0x44, 0xc1, 0x7f},
    {0x02, 0x0a, 0x44, 0x81, 0x7f},
    {0x06, 0x46, 0x02, 0x81, 0x8f},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0xc1, 0x7f},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0x81, 0xf5, 0x0f},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0xc1, 0x7f},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0x81, 0x8f},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0xc1, 0x7f},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xe8, 0x44, 0xf5, 0x40, 0x0f},
    {0x03, 0x16, 0x42, 0x04, 0x9f},
    {0x01, 0x0d, 0x42, 0x44, 0x9f},
    {0x02, 0x16, 0x42, 0x04, 0x9f},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x06, 0x6d},
    {0x04, 0x0d, 0x42, 0x44, 0x9f},
    {0x02, 0x03, 0x44, 0x06, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x06, 0x7d},
    {0x01, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x0b, 0x42, 0x06, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x06, 0x6d},
    {0x04, 0x03, 0x42, 0x46, 0x7d},
    {0x02, 0x05, 0x44, 0x06, 0x6d},
    {0x0a, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0x04, 0x9f},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0x04, 0x9f},
    {0x06, 0x48, 0x02, 0x04, 0x9f},
    {0x03, 0x09, 0x42, 0x06, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x06, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0xc1, 0xb5, 0x0f},
    {0x01, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x8a, 0xc1, 0xb5, 0x0f},
    {0x05, 0x48, 0x02, 0x04, 0x9f},
    {0x03, 0x06, 0x44, 0x06, 0x6d},
    {0x04, 0x05, 0x42, 0x46, 0x7d},
    {0x02, 0x06, 0x44, 0x06, 0x6d},
    {0x50, 0x81, 0xf5, 0x00, 0x0f},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0x81, 0xb5, 0x0f},
    {0x03, 0x82, 0x47, 0x03, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x03, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0x04, 0x9f},
    {0x01, 0x11, 0x42, 0x44, 0x9f},
    {0x02, 0x19, 0x42, 0x04, 0x9f},
    {0x05, 0xc3, 0x81, 0xb5, 0x0f},
    {0x03, 0x0f, 0x42, 0x81, 0x8f},
    {0x04, 0x11, 0x42, 0x44, 0x9f},
    {0x02, 0x0f, 0x42, 0x81, 0x8f},
    {0x40, 0x81, 0xf5, 0x00, 0x0f},
    {0x03, 0x86, 0xc1, 0xb5, 0x0f},
    {0x01, 0x84, 0xc1, 0xf5, 0x0f},
    {0x02, 0x86, 0xc1, 0xb5, 0x0f},
    {0x06, 0xc1, 0x06, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x06, 0x6d},
    {0x04, 0x84, 0xc1, 0xf5, 0x0f},
    {0x02, 0x04, 0x44, 0x06, 0x6d},
    {0x07, 0x44, 0x02, 0x44, 0x9f},
    {0x03, 0x02, 0x44, 0x06, 0x6d},
    {0x01, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x44, 0x06, 0x6d},
    {0x05, 0xc1, 0x06, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x06, 0x6d},
    {0x04, 0x06, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x44, 0x06, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x81, 0x8f},
    {0x01, 0x01, 0x42, 0x44, 0x9f},
    {0x02, 0x0d, 0x42, 0x81, 0x8f},
    {0x06, 0x4a, 0x02, 0x04, 0x9f},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0x44, 0x9f},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0x04, 0x9f},
    {0x01, 0x08, 0x42, 0xc1, 0x8f},
    {0x02, 0x12, 0x42, 0x04, 0x9f},
    {0x05, 0x4a, 0x02, 0x04, 0x9f},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0xc1, 0x8f},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0x04, 0x9f},
    {0x01, 0x83, 0x46, 0x42, 0xdf},
    {0x02, 0x15, 0x42, 0x04, 0x9f},
    {0x06, 0x44, 0x02, 0x81, 0x8f},
    {0x03, 0x11, 0x42, 0x81, 0x8f},
    {0x04, 0x83, 0x46, 0x42, 0xdf},
    {0x02, 0x11, 0x42, 0x81, 0x8f},
    {0x07, 0x42, 0x02, 0x44, 0x9f},
    {0x03, 0x84, 0x46, 0x02, 0xdf},
    {0x01, 0x81, 0x47, 0x44, 0xcf},
    {0x02, 0x84, 0x46, 0x02, 0xdf},
    {0x05, 0x44, 0x02, 0x81, 0x8f},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x44, 0xcf},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x04, 0xb5, 0xcf},
    {0x03, 0x01, 0x42, 0x81, 0x8f},
    {0x01, 0x0a, 0x42, 0xc1, 0x8f},
    {0x02, 0x01, 0x42, 0x81, 0x8f},
    {0x06, 0x42, 0x02, 0x81, 0x8f},
    {0x03, 0x08, 0x42, 0x06, 0x7d},
    {0x04, 0x0a, 0x42, 0xc1, 0x8f},
    {0x02, 0x08, 0x42, 0x06, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x04, 0xcf},
    {0x01, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x83, 0x47, 0x04, 0xcf},
    {0x05, 0x42, 0x02, 0x81, 0x8f},
    {0x03, 0x81, 0x47, 0x03, 0xbd},
    {0x04, 0x04, 0x42, 0x46, 0x7d},
    {0x02, 0x81, 0x47, 0x03, 0xbd},
    {0x0c, 0x47, 0x43, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x06, 0x7d},
    {0x01, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x0a, 0x42, 0x06, 0x7d},
    {0x06, 0x47, 0x02, 0x81, 0x8f},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x46, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0x44, 0x9f},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x81, 0x8f},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x46, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0d},
    {0x03, 0xb4, 0xf5, 0x00, 0x0d},
    {0x01, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0xb4, 0xf5, 0x00, 0x0d},
    {0x06, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0xf5, 0x00, 0x66},
    {0x04, 0xb4, 0xf5, 0x40, 0x0d},
    {0x02, 0x03, 0xf5, 0x00, 0x66},
    {0x09, 0x5e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x4e, 0xb5, 0x7f},
    {0x01, 0x03, 0x4e, 0xf5, 0x7f},
    {0x02, 0x0b, 0x4e, 0xb5, 0x7f},
    {0x05, 0xf2, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0xf5, 0x00, 0x66},
    {0x04, 0x03, 0x4e, 0xf5, 0x7f},
    {0x02, 0x05, 0xf5, 0x00, 0x66},
    {0x0a, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x4c, 0xb5, 0x8f},
    {0x01, 0x0b, 0x4c, 0xf5, 0x8f},
    {0x02, 0x0c, 0x4c, 0xb5, 0x8f},
    {0x06, 0x43, 0x0c, 0xb5, 0x8f},
    {0x03, 0x09, 0x4e, 0xb5, 0x7f},
    {0x04, 0x0b, 0x4c, 0xf5, 0x8f},
    {0x02, 0x09, 0x4e, 0xb5, 0x7f},
    {0x07, 0xf5, 0x00, 0x40, 0x05},
    {0x03, 0x9a, 0x4d, 0xb5, 0xee},
    {0x01, 0x05, 0x4e, 0xf5, 0x7f},
    {0x02, 0x9a, 0x4d, 0xb5, 0xee},
    {0x05, 0x43, 0x0c, 0xb5, 0x8f},
    {0x03, 0x06, 0xf5, 0x00, 0x66},
    {0x04, 0x05, 0x4e, 0xf5, 0x7f},
    {0x02, 0x06, 0xf5, 0x00, 0x66},
    {0x4d, 0x0d, 0xb5, 0x00, 0xee},
    {0x03, 0x14, 0x47, 0xb5, 0x9e},
    {0x01, 0x0c, 0x47, 0xf5, 0x9e},
    {0x02, 0x14, 0x47, 0xb5, 0x9e},
    {0x06, 0x4b, 0x07, 0xb5, 0x9e},
    {0x03, 0x82, 0x56, 0xb5, 0xee},
    {0x04, 0x0c, 0x47, 0xf5, 0x9e},
    {0x02, 0x82, 0x56, 0xb5, 0xee},
    {0x08, 0x5e, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x47, 0xb5, 0x9e},
    {0x01, 0x09, 0x4c, 0xf5, 0x8f},
    {0x02, 0x18, 0x47, 0xb5, 0x9e},
    {0x05, 0x4b, 0x07, 0xb5, 0x9e},
    {0x03, 0x0e, 0x4c, 0xb5, 0x8f},
    {0x04, 0x09, 0x4c, 0xf5, 0x8f},
    {0x02, 0x0e, 0x4c, 0xb5, 0x8f},
    {0x4f, 0x01, 0xb5, 0x40, 0xff},
    {0x03, 0x1c, 0x47, 0xb5, 0x9e},
    {0x01, 0x9a, 0x41, 0xf5, 0xff},
    {0x02, 0x1c, 0x47, 0xb5, 0x9e},
    {0x06, 0x45, 0x0c, 0xb5, 0x8f},
    {0x03, 0x04, 0xf5, 0x00, 0x66},
    {0x04, 0x9a, 0x41, 0xf5, 0xff},
    {0x02, 0x04, 0xf5, 0x00, 0x66},
    {0x07, 0x43, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0xf5, 0x00, 0x66},
    {0x01, 0x06, 0x4e, 0xf5, 0x7f},
    {0x02, 0x02, 0xf5, 0x00, 0x66},
    {0x05, 0x45, 0x0c, 0xb5, 0x8f},
    {0x03, 0x07, 0xf5, 0x00, 0x66},
    {0x04, 0x06, 0x4e, 0xf5, 0x7f},
    {0x02, 0x07, 0xf5, 0x00, 0x66},
    {0x52, 0x0a, 0xf5, 0x00, 0xff},
    {0x03, 0x17, 0x47, 0xb5, 0x9e},
    {0x01, 0x14, 0x45, 0xf5, 0xae},
    {0x02, 0x17, 0x47, 0xb5, 0x9e},
    {0x06, 0x4c, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x43, 0x0d, 0x6e},
    {0x04, 0x14, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x43, 0x0d, 0x6e},
    {0x09, 0x43, 0x45, 0xb5, 0xae},
    {0x03, 0x1b, 0x47, 0xb5, 0x9e},
    {0x01, 0x82, 0x4d, 0xf5, 0xee},
    {0x02, 0x1b, 0x47, 0xb5, 0x9e},
    {0x05, 0x4c, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x43, 0x0d, 0x6e},
    {0x04, 0x82, 0x4d, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x0d, 0x6e},
    {0x0b, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x27, 0x45, 0xb5, 0xae},
    {0x01, 0x18, 0x45, 0xf5, 0xae},
    {0x02, 0x27, 0x45, 0xb5, 0xae},
    {0x06, 0x49, 0x07, 0xb5, 0x9e},
    {0x03, 0x10, 0x4c, 0xb5, 0x8f},
    {0x04, 0x18, 0x45, 0xf5, 0xae},
    {0x02, 0x10, 0x4c, 0xb5, 0x8f},
    {0x07, 0x4b, 0x05, 0xf5, 0xae},
    {0x03, 0x89, 0x4a, 0xb5, 0xff},
    {0x01, 0x0e, 0x47, 0xf5, 0x9e},
    {0x02, 0x89, 0x4a, 0xb5, 0xff},
    {0x05, 0x49, 0x07, 0xb5, 0x9e},
    {0x03, 0x06, 0x43, 0x0d, 0x6e},
    {0x04, 0x0e, 0x47, 0xf5, 0x9e},
    {0x02, 0x06, 0x43, 0x0d, 0x6e},
    {0x51, 0x0a, 0xf5, 0x00, 0xff},
    {0x03, 0x13, 0x47, 0xb5, 0x9e},
    {0x01, 0x1c, 0x45, 0xf5, 0xae},
    {0x02, 0x13, 0x47, 0xb5, 0x9e},
    {0x06, 0xda, 0x0a, 0xb5, 0xff},
    {0x03, 0x08, 0x4e, 0xb5, 0x7f},
    {0x04, 0x1c, 0x45, 0xf5, 0xae},
    {0x02, 0x08, 0x4e, 0xb5, 0x7f},
    {0x08, 0x43, 0x45, 0xb5, 0xae},
    {0x03, 0x37, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x4e, 0xf5, 0x7f},
    {0x02, 0x37, 0x45, 0xb5, 0xae},
    {0x05, 0xda, 0x0a, 0xb5, 0xff},
    {0x03, 0x81, 0x56, 0xb5, 0xee},
    {0x04, 0x04, 0x4e, 0xf5, 0x7f},
    {0x02, 0x81, 0x56, 0xb5, 0xee},
    {0x0c, 0x56, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x4e, 0xb5, 0x7f},
    {0x01, 0x02, 0x4e, 0xf5, 0x7f},
    {0x02, 0x0a, 0x4e, 0xb5, 0x7f},
    {0x06, 0x46, 0x0c, 0xb5, 0x8f},
    {0x03, 0x04, 0x43, 0x0d, 0x6e},
    {0x04, 0x02, 0x4e, 0xf5, 0x7f},
    {0x02, 0x04, 0x43, 0x0d, 0x6e},
    {0x07, 0x45, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x43, 0x0d, 0x6e},
    {0x01, 0x07, 0x4e, 0xf5, 0x7f},
    {0x02, 0x02, 0x43, 0x0d, 0x6e},
    {0x05, 0x46, 0x0c, 0xb5, 0x8f},
    {0x03, 0x07, 0x43, 0x0d, 0x6e},
    {0x04, 0x07, 0x4e, 0xf5, 0x7f},
    {0x02, 0x07, 0x43, 0x0d, 0x6e},
    {0xdc, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x45, 0xb5, 0xae},
    {0x01, 0x17, 0x45, 0xf5, 0xae},
    {0x02, 0x2d, 0x45, 0xb5, 0xae},
    {0x06, 0x54, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x41, 0x01, 0x6f},
    {0x04, 0x17, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x41, 0x01, 0x6f},
    {0x09, 0x4b, 0x44, 0xb5, 0xbe},
    {0x03, 0x0b, 0x43, 0x01, 0x7f},
    {0x01, 0x03, 0x43, 0x41, 0x7f},
    {0x02, 0x0b, 0x43, 0x01, 0x7f},
    {0x05, 0x54, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x41, 0x01, 0x6f},
    {0x04, 0x03, 0x43, 0x41, 0x7f},
    {0x02, 0x05, 0x41, 0x01, 0x6f},
    {0x0a, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x35, 0x45, 0xb5, 0xae},
    {0x01, 0x1b, 0x45, 0xf5, 0xae},
    {0x02, 0x35, 0x45, 0xb5, 0xae},
    {0x06, 0xc2, 0x01, 0xb5, 0xff},
    {0x03, 0x09, 0x43, 0x01, 0x7f},
    {0x04, 0x1b, 0x45, 0xf5, 0xae},
    {0x02, 0x09, 0x43, 0x01, 0x7f},
    {0x07, 0x4c, 0x04, 0xf5, 0xbe},
    {0x03, 0x87, 0x4a, 0xb5, 0xff},
    {0x01, 0x05, 0x43, 0x41, 0x7f},
    {0x02, 0x87, 0x4a, 0xb5, 0xff},
    {0x05, 0xc2, 0x01, 0xb5, 0xff},
    {0x03, 0x06, 0x41, 0x01, 0x6f},
    {0x04, 0x05, 0x43, 0x41, 0x7f},
    {0x02, 0x06, 0x41, 0x01, 0x6f},
    {0x57, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x23, 0x45, 0xb5, 0xae},
    {0x01, 0x27, 0x44, 0xf5, 0xbe},
    {0x02, 0x23, 0x45, 0xb5, 0xae},
    {0x06, 0x58, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x43, 0x04, 0xbe},
    {0x04, 0x27, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x43, 0x04, 0xbe},
    {0x08, 0x4b, 0x44, 0xb5, 0xbe},
    {0x03, 0x33, 0x45, 0xb5, 0xae},
    {0x01, 0x10, 0x47, 0xf5, 0x9e},
    {0x02, 0x33, 0x45, 0xb5, 0xae},
    {0x05, 0x58, 0x04, 0xb5, 0xbe},
    {0x03, 0x0f, 0x4c, 0xb5, 0x8f},
    {0x04, 0x10, 0x47, 0xf5, 0x9e},
    {0x02, 0x0f, 0x4c, 0xb5, 0x8f},
    {0x54, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x3f, 0x45, 0xb5, 0xae},
    {0x01, 0x89, 0x42, 0xf5, 0xff},
    {0x02, 0x3f, 0x45, 0xb5, 0xae},
    {0x06, 0x4e, 0x05, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0x01, 0x6f},
    {0x04, 0x89, 0x42, 0xf5, 0xff},
    {0x02, 0x04, 0x41, 0x01, 0x6f},
    {0x07, 0x49, 0x05, 0xf5, 0xae},
    {0x03, 0x02, 0x41, 0x01, 0x6f},
    {0x01, 0x06, 0x43, 0x41, 0x7f},
    {0x02, 0x02, 0x41, 0x01, 0x6f},
    {0x05, 0x4e, 0x05, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0x01, 0x6f},
    {0x04, 0x06, 0x43, 0x41, 0x7f},
    {0x02, 0x07, 0x41, 0x01, 0x6f},
    {0x59, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x0d, 0x4c, 0xb5, 0x8f},
    {0x01, 0x13, 0x45, 0xf5, 0xae},
    {0x02, 0x0d, 0x4c, 0xb5, 0x8f},
    {0x06, 0x5c, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x42, 0x0d, 0x6e},
    {0x04, 0x13, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x42, 0x0d, 0x6e},
    {0x09, 0x45, 0x45, 0xb5, 0xae},
    {0x03, 0x97, 0x42, 0xb5, 0xff},
    {0x01, 0x08, 0x4c, 0xf5, 0x8f},
    {0x02, 0x97, 0x42, 0xb5, 0xff},
    {0x05, 0x5c, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x42, 0x0d, 0x6e},
    {0x04, 0x08, 0x4c, 0xf5, 0x8f},
    {0x02, 0x05, 0x42, 0x0d, 0x6e},
    {0x0b, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x2b, 0x45, 0xb5, 0xae},
    {0x01, 0x37, 0x44, 0xf5, 0xbe},
    {0x02, 0x2b, 0x45, 0xb5, 0xae},
    {0x06, 0x44, 0x0c, 0xb5, 0x8f},
    {0x03, 0x11, 0x4c, 0xb5, 0x8f},
    {0x04, 0x37, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x4c, 0xb5, 0x8f},
    {0x07, 0xda, 0x02, 0xf5, 0xff},
    {0x03, 0x93, 0x42, 0xb5, 0xff},
    {0x01, 0x81, 0x4d, 0xf5, 0xee},
    {0x02, 0x93, 0x42, 0xb5, 0xff},
    {0x05, 0x44, 0x0c, 0xb5, 0x8f},
    {0x03, 0x06, 0x42, 0x0d, 0x6e},
    {0x04, 0x81, 0x4d, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x0d, 0x6e},
    {0x4e, 0x0d, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x4c, 0xb5, 0x8f},
    {0x01, 0x0a, 0x4c, 0xf5, 0x8f},
    {0x02, 0x01, 0x4c, 0xb5, 0x8f},
    {0x06, 0x42, 0x0c, 0xb5, 0x8f},
    {0x03, 0x08, 0x43, 0x01, 0x7f},
    {0x04, 0x0a, 0x4c, 0xf5, 0x8f},
    {0x02, 0x08, 0x43, 0x01, 0x7f},
    {0x08, 0x45, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x4d, 0xb5, 0xee},
    {0x01, 0x04, 0x43, 0x41, 0x7f},
    {0x02, 0x83, 0x4d, 0xb5, 0xee},
    {0x05, 0x42, 0x0c, 0xb5, 0x8f},
    {0x03, 0x81, 0x43, 0x04, 0xbe},
    {0x04, 0x04, 0x43, 0x41, 0x7f},
    {0x02, 0x81, 0x43, 0x04, 0xbe},
    {0x0c, 0x43, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0x01, 0x7f},
    {0x01, 0x02, 0x43, 0x41, 0x7f},
    {0x02, 0x0a, 0x43, 0x01, 0x7f},
    {0x06, 0x47, 0x0c, 0xb5, 0x8f},
    {0x03, 0x04, 0x42, 0x0d, 0x6e},
    {0x04, 0x02, 0x43, 0x41, 0x7f},
    {0x02, 0x04, 0x42, 0x0d, 0x6e},
    {0x07, 0x46, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x42, 0x0d, 0x6e},
    {0x01, 0x07, 0x43, 0x41, 0x7f},
    {0x02, 0x02, 0x42, 0x0d, 0x6e},
    {0x05, 0x47, 0x0c, 0xb5, 0x8f},
    {0x03, 0x07, 0x42, 0x0d, 0x6e},
    {0x04, 0x07, 0x43, 0x41, 0x7f},
    {0x02, 0x07, 0x42, 0x0d, 0x6e},
    {0xf4, 0x41, 0xf5, 0x40, 0x0f},
    {0x03, 0x1d, 0x45, 0xb5, 0xae},
    {0x01, 0x2d, 0x44, 0xf5, 0xbe},
    {0x02, 0x1d, 0x45, 0xb5, 0xae},
    {0x06, 0x57, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x46, 0x0a, 0x6f},
    {0x04, 0x2d, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0x0a, 0x6f},
    {0x09, 0x4c, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x41, 0x0a, 0x7f},
    {0x01, 0x03, 0x41, 0x4a, 0x7f},
    {0x02, 0x0b, 0x41, 0x0a, 0x7f},
    {0x05, 0x57, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x46, 0x0a, 0x6f},
    {0x04, 0x03, 0x41, 0x4a, 0x7f},
    {0x02, 0x05, 0x46, 0x0a, 0x6f},
    {0x0a, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x0c, 0x43, 0x0a, 0x8f},
    {0x01, 0x0b, 0x43, 0x4a, 0x8f},
    {0x02, 0x0c, 0x43, 0x0a, 0x8f},
    {0x06, 0x43, 0x03, 0x0a, 0x8f},
    {0x03, 0x09, 0x41, 0x0a, 0x7f},
    {0x04, 0x0b, 0x43, 0x4a, 0x8f},
    {0x02, 0x09, 0x41, 0x0a, 0x7f},
    {0x07, 0x54, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x43, 0x02, 0xce},
    {0x01, 0x05, 0x41, 0x4a, 0x7f},
    {0x02, 0x9a, 0x43, 0x02, 0xce},
    {0x05, 0x43, 0x03, 0x0a, 0x8f},
    {0x03, 0x06, 0x46, 0x0a, 0x6f},
    {0x04, 0x05, 0x41, 0x4a, 0x7f},
    {0x02, 0x06, 0x46, 0x0a, 0x6f},
    {0x4d, 0x03, 0x02, 0xb5, 0xce},
    {0x03, 0x21, 0x45, 0xb5, 0xae},
    {0x01, 0x35, 0x44, 0xf5, 0xbe},
    {0x02, 0x21, 0x45, 0xb5, 0xae},
    {0x06, 0x5b, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x4b, 0x02, 0xce},
    {0x04, 0x35, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x4b, 0x02, 0xce},
    {0x08, 0x4c, 0x42, 0xb5, 0xce},
    {0x03, 0x31, 0x45, 0xb5, 0xae},
    {0x01, 0x09, 0x43, 0x4a, 0x8f},
    {0x02, 0x31, 0x45, 0xb5, 0xae},
    {0x05, 0x5b, 0x04, 0xb5, 0xbe},
    {0x03, 0x0e, 0x43, 0x0a, 0x8f},
    {0x04, 0x09, 0x43, 0x4a, 0x8f},
    {0x02, 0x0e, 0x43, 0x0a, 0x8f},
    {0xc2, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x45, 0xb5, 0xae},
    {0x01, 0x87, 0x42, 0xf5, 0xff},
    {0x02, 0x3d, 0x45, 0xb5, 0xae},
    {0x06, 0x45, 0x03, 0x0a, 0x8f},
    {0x03, 0x04, 0x46, 0x0a, 0x6f},
    {0x04, 0x87, 0x42, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x0a, 0x6f},
    {0x07, 0xc2, 0x0a, 0xf5, 0xff},
    {0x03, 0x02, 0x46, 0x0a, 0x6f},
    {0x01, 0x06, 0x41, 0x4a, 0x7f},
    {0x02, 0x02, 0x46, 0x0a, 0x6f},
    {0x05, 0x45, 0x03, 0x0a, 0x8f},
    {0x03, 0x07, 0x46, 0x0a, 0x6f},
    {0x04, 0x06, 0x41, 0x4a, 0x7f},
    {0x02, 0x07, 0x46, 0x0a, 0x6f},
    {0x78, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x45, 0xb5, 0xae},
    {0x01, 0x23, 0x44, 0xf5, 0xbe},
    {0x02, 0x2f, 0x45, 0xb5, 0xae},
    {0x06, 0x67, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x03, 0x6c},
    {0x04, 0x23, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x03, 0x6c},
    {0x09, 0x49, 0x44, 0xb5, 0xbe},
    {0x03, 0x3b, 0x45, 0xb5, 0xae},
    {0x01, 0x82, 0x43, 0x42, 0xce},
    {0x02, 0x3b, 0x45, 0xb5, 0xae},
    {0x05, 0x67, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x03, 0x6c},
    {0x04, 0x82, 0x43, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x03, 0x6c},
    {0x0b, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x29, 0x45, 0xb5, 0xae},
    {0x01, 0x33, 0x44, 0xf5, 0xbe},
    {0x02, 0x29, 0x45, 0xb5, 0xae},
    {0x06, 0x50, 0x05, 0xb5, 0xae},
    {0x03, 0x10, 0x43, 0x0a, 0x8f},
    {0x04, 0x33, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0x0a, 0x8f},
    {0x07, 0x58, 0x02, 0xf5, 0xce},
    {0x03, 0x8f, 0x42, 0xb5, 0xff},
    {0x01, 0x0f, 0x47, 0xf5, 0x9e},
    {0x02, 0x8f, 0x42, 0xb5, 0xff},
    {0x05, 0x50, 0x05, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x03, 0x6c},
    {0x04, 0x0f, 0x47, 0xf5, 0x9e},
    {0x02, 0x06, 0x43, 0x03, 0x6c},
    {0x5e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x45, 0xb5, 0xae},
    {0x01, 0x3f, 0x44, 0xf5, 0xbe},
    {0x02, 0x1f, 0x45, 0xb5, 0xae},
    {0x06, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x41, 0x0a, 0x7f},
    {0x04, 0x3f, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0x0a, 0x7f},
    {0x08, 0x49, 0x44, 0xb5, 0xbe},
    {0x03, 0x39, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x41, 0x4a, 0x7f},
    {0x02, 0x39, 0x45, 0xb5, 0xae},
    {0x05, 0xc9, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4b, 0x02, 0xce},
    {0x04, 0x04, 0x41, 0x4a, 0x7f},
    {0x02, 0x81, 0x4b, 0x02, 0xce},
    {0x0c, 0x4b, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x41, 0x0a, 0x7f},
    {0x01, 0x02, 0x41, 0x4a, 0x7f},
    {0x02, 0x0a, 0x41, 0x0a, 0x7f},
    {0x06, 0x46, 0x03, 0x0a, 0x8f},
    {0x03, 0x04, 0x43, 0x03, 0x6c},
    {0x04, 0x02, 0x41, 0x4a, 0x7f},
    {0x02, 0x04, 0x43, 0x03, 0x6c},
    {0x07, 0x4e, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x03, 0x6c},
    {0x01, 0x07, 0x41, 0x4a, 0x7f},
    {0x02, 0x02, 0x43, 0x03, 0x6c},
    {0x05, 0x46, 0x03, 0x0a, 0x8f},
    {0x03, 0x07, 0x43, 0x03, 0x6c},
    {0x04, 0x07, 0x41, 0x4a, 0x7f},
    {0x02, 0x07, 0x43, 0x03, 0x6c},
    {0xdd, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x47, 0xb5, 0x9e},
    {0x01, 0x0d, 0x47, 0xf5, 0x9e},
    {0x02, 0x16, 0x47, 0xb5, 0x9e},
    {0x06, 0x53, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x44, 0x01, 0x6f},
    {0x04, 0x0d, 0x47, 0xf5, 0x9e},
    {0x02, 0x03, 0x44, 0x01, 0x6f},
    {0x09, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x42, 0x01, 0x7f},
    {0x01, 0x03, 0x42, 0x41, 0x7f},
    {0x02, 0x0b, 0x42, 0x01, 0x7f},
    {0x05, 0x53, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x44, 0x01, 0x6f},
    {0x04, 0x03, 0x42, 0x41, 0x7f},
    {0x02, 0x05, 0x44, 0x01, 0x6f},
    {0x0a, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x47, 0xb5, 0x9e},
    {0x01, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x47, 0xb5, 0x9e},
    {0x06, 0x48, 0x07, 0xb5, 0x9e},
    {0x03, 0x09, 0x42, 0x01, 0x7f},
    {0x04, 0x97, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x01, 0x7f},
    {0x07, 0x5c, 0x02, 0xf5, 0xce},
    {0x03, 0x8b, 0x42, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x41, 0x7f},
    {0x02, 0x8b, 0x42, 0xb5, 0xff},
    {0x05, 0x48, 0x07, 0xb5, 0x9e},
    {0x03, 0x06, 0x44, 0x01, 0x6f},
    {0x04, 0x05, 0x42, 0x41, 0x7f},
    {0x02, 0x06, 0x44, 0x01, 0x6f},
    {0x79, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x45, 0xb5, 0xae},
    {0x01, 0x2b, 0x44, 0xf5, 0xbe},
    {0x02, 0x25, 0x45, 0xb5, 0xae},
    {0x06, 0x77, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x04, 0xbe},
    {0x04, 0x2b, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x45, 0x04, 0xbe},
    {0x08, 0xda, 0xf5, 0x00, 0x0c},
    {0x03, 0x19, 0x47, 0xb5, 0x9e},
    {0x01, 0x11, 0x47, 0xf5, 0x9e},
    {0x02, 0x19, 0x47, 0xb5, 0x9e},
    {0x05, 0x77, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x0a, 0x8f},
    {0x04, 0x11, 0x47, 0xf5, 0x9e},
    {0x02, 0x0f, 0x43, 0x0a, 0x8f},
    {0x55, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x85, 0x4a, 0xb5, 0xff},
    {0x01, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x4a, 0xb5, 0xff},
    {0x06, 0xc1, 0x01, 0xb5, 0xff},
    {0x03, 0x04, 0x44, 0x01, 0x6f},
    {0x04, 0x93, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x01, 0x6f},
    {0x07, 0x44, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x44, 0x01, 0x6f},
    {0x01, 0x06, 0x42, 0x41, 0x7f},
    {0x02, 0x02, 0x44, 0x01, 0x6f},
    {0x05, 0xc1, 0x01, 0xb5, 0xff},
    {0x03, 0x07, 0x44, 0x01, 0x6f},
    {0x04, 0x06, 0x42, 0x41, 0x7f},
    {0x02, 0x07, 0x44, 0x01, 0x6f},
    {0x76, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x43, 0x0a, 0x8f},
    {0x01, 0x01, 0x47, 0xf5, 0x9e},
    {0x02, 0x0d, 0x43, 0x0a, 0x8f},
    {0x06, 0x4a, 0x07, 0xb5, 0x9e},
    {0x03, 0x03, 0x42, 0x03, 0x6c},
    {0x04, 0x01, 0x47, 0xf5, 0x9e},
    {0x02, 0x03, 0x42, 0x03, 0x6c},
    {0x09, 0x46, 0x45, 0xb5, 0xae},
    {0x03, 0x12, 0x47, 0xb5, 0x9e},
    {0x01, 0x08, 0x43, 0x4a, 0x8f},
    {0x02, 0x12, 0x47, 0xb5, 0x9e},
    {0x05, 0x4a, 0x07, 0xb5, 0x9e},
    {0x03, 0x05, 0x42, 0x03, 0x6c},
    {0x04, 0x08, 0x43, 0x4a, 0x8f},
    {0x02, 0x05, 0x42, 0x03, 0x6c},
    {0x0b, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x47, 0xb5, 0x9e},
    {0x01, 0x83, 0x41, 0xf5, 0xff},
    {0x02, 0x15, 0x47, 0xb5, 0x9e},
    {0x06, 0x44, 0x03, 0x0a, 0x8f},
    {0x03, 0x11, 0x43, 0x0a, 0x8f},
    {0x04, 0x83, 0x41, 0xf5, 0xff},
    {0x02, 0x11, 0x43, 0x0a, 0x8f},
    {0x07, 0x42, 0x07, 0xf5, 0x9e},
    {0x03, 0x84, 0x41, 0xb5, 0xff},
    {0x01, 0x81, 0x43, 0x42, 0xce},
    {0x02, 0x84, 0x41, 0xb5, 0xff},
    {0x05, 0x44, 0x03, 0x0a, 0x8f},
    {0x03, 0x06, 0x42, 0x03, 0x6c},
    {0x04, 0x81, 0x43, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x03, 0x6c},
    {0x4e, 0x03, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0x0a, 0x8f},
    {0x01, 0x0a, 0x43, 0x4a, 0x8f},
    {0x02, 0x01, 0x43, 0x0a, 0x8f},
    {0x06, 0x42, 0x03, 0x0a, 0x8f},
    {0x03, 0x08, 0x42, 0x01, 0x7f},
    {0x04, 0x0a, 0x43, 0x4a, 0x8f},
    {0x02, 0x08, 0x42, 0x01, 0x7f},
    {0x08, 0x46, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x43, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x41, 0x7f},
    {0x02, 0x83, 0x43, 0x02, 0xce},
    {0x05, 0x42, 0x03, 0x0a, 0x8f},
    {0x03, 0x81, 0x45, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0x41, 0x7f},
    {0x02, 0x81, 0x45, 0x04, 0xbe},
    {0x0c, 0x45, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x01, 0x7f},
    {0x01, 0x02, 0x42, 0x41, 0x7f},
    {0x02, 0x0a, 0x42, 0x01, 0x7f},
    {0x06, 0x47, 0x03, 0x0a, 0x8f},
    {0x03, 0x04, 0x42, 0x03, 0x6c},
    {0x04, 0x02, 0x42, 0x41, 0x7f},
    {0x02, 0x04, 0x42, 0x03, 0x6c},
    {0x07, 0x47, 0x07, 0xf5, 0x9e},
    {0x03, 0x02, 0x42, 0x03, 0x6c},
    {0x01, 0x07, 0x42, 0x41, 0x7f},
    {0x02, 0x02, 0x42, 0x03, 0x6c},
    {0x05, 0x47, 0x03, 0x0a, 0x8f},
    {0x03, 0x07, 0x42, 0x03, 0x6c},
    {0x04, 0x07, 0x42, 0x41, 0x7f},
    {0x02, 0x07, 0x42, 0x03, 0x6c},
    {0xf4, 0x4a, 0xf5, 0x40, 0x0f},
    {0x03, 0xa0, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x44, 0xf5, 0xbe},
    {0x02, 0xa0, 0xf5, 0x00, 0x0e},
    {0x06, 0x6d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x49, 0xb5, 0x6c},
    {0x04, 0x1d, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x49, 0xb5, 0x6c},
    {0x09, 0x62, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0x02, 0x7f},
    {0x01, 0x03, 0x46, 0x42, 0x7f},
    {0x02, 0x0b, 0x46, 0x02, 0x7f},
    {0x05, 0x6d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x49, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0x42, 0x7f},
    {0x02, 0x05, 0x49, 0xb5, 0x6c},
    {0x0a, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x41, 0x02, 0x8f},
    {0x01, 0x0b, 0x41, 0x42, 0x8f},
    {0x02, 0x0c, 0x41, 0x02, 0x8f},
    {0x06, 0x43, 0x01, 0x02, 0x8f},
    {0x03, 0x09, 0x46, 0x02, 0x7f},
    {0x04, 0x0b, 0x41, 0x42, 0x8f},
    {0x02, 0x09, 0x46, 0x02, 0x7f},
    {0x07, 0x57, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x52, 0xb5, 0xff},
    {0x01, 0x05, 0x46, 0x42, 0x7f},
    {0x02, 0x9a, 0x52, 0xb5, 0xff},
    {0x05, 0x43, 0x01, 0x02, 0x8f},
    {0x03, 0x06, 0x49, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0x42, 0x7f},
    {0x02, 0x06, 0x49, 0xb5, 0x6c},
    {0x4d, 0x12, 0xb5, 0x00, 0xff},
    {0x03, 0x14, 0x43, 0x02, 0x9f},
    {0x01, 0x0c, 0x43, 0x42, 0x9f},
    {0x02, 0x14, 0x43, 0x02, 0x9f},
    {0x06, 0x4b, 0x03, 0x02, 0x9f},
    {0x03, 0x82, 0x5a, 0xb5, 0xee},
    {0x04, 0x0c, 0x43, 0x42, 0x9f},
    {0x02, 0x82, 0x5a, 0xb5, 0xee},
    {0x08, 0x62, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0x02, 0x9f},
    {0x01, 0x09, 0x41, 0x42, 0x8f},
    {0x02, 0x18, 0x43, 0x02, 0x9f},
    {0x05, 0x4b, 0x03, 0x02, 0x9f},
    {0x03, 0x0e, 0x41, 0x02, 0x8f},
    {0x04, 0x09, 0x41, 0x42, 0x8f},
    {0x02, 0x0e, 0x41, 0x02, 0x8f},
    {0x4f, 0x08, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x43, 0x02, 0x9f},
    {0x01, 0x9a, 0x48, 0xf5, 0xee},
    {0x02, 0x1c, 0x43, 0x02, 0x9f},
    {0x06, 0x45, 0x01, 0x02, 0x8f},
    {0x03, 0x04, 0x49, 0xb5, 0x6c},
    {0x04, 0x9a, 0x48, 0xf5, 0xee},
    {0x02, 0x04, 0x49, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0x42, 0x9f},
    {0x03, 0x02, 0x49, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0x42, 0x7f},
    {0x02, 0x02, 0x49, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0x02, 0x8f},
    {0x03, 0x07, 0x49, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0x42, 0x7f},
    {0x02, 0x07, 0x49, 0xb5, 0x6c},
    {0x74, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x43, 0x02, 0x9f},
    {0x01, 0x21, 0x44, 0xf5, 0xbe},
    {0x02, 0x17, 0x43, 0x02, 0x9f},
    {0x06, 0x75, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x12, 0x6f},
    {0x04, 0x21, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x12, 0x6f},
    {0x09, 0xc2, 0x42, 0xb5, 0xff},
    {0x03, 0x1b, 0x43, 0x02, 0x9f},
    {0x01, 0x82, 0x52, 0xf5, 0xff},
    {0x02, 0x1b, 0x43, 0x02, 0x9f},
    {0x05, 0x75, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x12, 0x6f},
    {0x04, 0x82, 0x52, 0xf5, 0xff},
    {0x02, 0x05, 0x43, 0x12, 0x6f},
    {0x0b, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x28, 0x45, 0xb5, 0xae},
    {0x01, 0x31, 0x44, 0xf5, 0xbe},
    {0x02, 0x28, 0x45, 0xb5, 0xae},
    {0x06, 0x49, 0x03, 0x02, 0x9f},
    {0x03, 0x10, 0x41, 0x02, 0x8f},
    {0x04, 0x31, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x41, 0x02, 0x8f},
    {0x07, 0x5b, 0x02, 0xf5, 0xce},
    {0x03, 0x8d, 0x42, 0xb5, 0xff},
    {0x01, 0x0e, 0x43, 0x42, 0x9f},
    {0x02, 0x8d, 0x42, 0xb5, 0xff},
    {0x05, 0x49, 0x03, 0x02, 0x9f},
    {0x03, 0x06, 0x43, 0x12, 0x6f},
    {0x04, 0x0e, 0x43, 0x42, 0x9f},
    {0x02, 0x06, 0x43, 0x12, 0x6f},
    {0x70, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0x02, 0x9f},
    {0x01, 0x3d, 0x44, 0xf5, 0xbe},
    {0x02, 0x13, 0x43, 0x02, 0x9f},
    {0x06, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0x02, 0x7f},
    {0x04, 0x3d, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x46, 0x02, 0x7f},
    {0x08, 0xc2, 0x42, 0xb5, 0xff},
    {0x03, 0x38, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x46, 0x42, 0x7f},
    {0x02, 0x38, 0x45, 0xb5, 0xae},
    {0x05, 0xc7, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x5a, 0xb5, 0xee},
    {0x04, 0x04, 0x46, 0x42, 0x7f},
    {0x02, 0x81, 0x5a, 0xb5, 0xee},
    {0x0c, 0x5a, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x46, 0x02, 0x7f},
    {0x01, 0x02, 0x46, 0x42, 0x7f},
    {0x02, 0x0a, 0x46, 0x02, 0x7f},
    {0x06, 0x46, 0x01, 0x02, 0x8f},
    {0x03, 0x04, 0x43, 0x12, 0x6f},
    {0x04, 0x02, 0x46, 0x42, 0x7f},
    {0x02, 0x04, 0x43, 0x12, 0x6f},
    {0x07, 0x45, 0x03, 0x42, 0x9f},
    {0x03, 0x02, 0x43, 0x12, 0x6f},
    {0x01, 0x07, 0x46, 0x42, 0x7f},
    {0x02, 0x02, 0x43, 0x12, 0x6f},
    {0x05, 0x46, 0x01, 0x02, 0x8f},
    {0x03, 0x07, 0x43, 0x12, 0x6f},
    {0x04, 0x07, 0x46, 0x42, 0x7f},
    {0x02, 0x07, 0x43, 0x12, 0x6f},
    {0xe1, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x45, 0xb5, 0xae},
    {0x01, 0x2f, 0x44, 0xf5, 0xbe},
    {0x02, 0x2e, 0x45, 0xb5, 0xae},
    {0x06, 0x63, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x08, 0x6e},
    {0x04, 0x2f, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x08, 0x6e},
    {0x09, 0x72, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x08, 0x7e},
    {0x01, 0x03, 0x43, 0x48, 0x7e},
    {0x02, 0x0b, 0x43, 0x08, 0x7e},
    {0x05, 0x63, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x08, 0x6e},
    {0x04, 0x03, 0x43, 0x48, 0x7e},
    {0x02, 0x05, 0x41, 0x08, 0x6e},
    {0x0a, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x36, 0x45, 0xb5, 0xae},
    {0x01, 0x3b, 0x44, 0xf5, 0xbe},
    {0x02, 0x36, 0x45, 0xb5, 0xae},
    {0x06, 0xc2, 0x08, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x08, 0x7e},
    {0x04, 0x3b, 0x44, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x08, 0x7e},
    {0x07, 0x68, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0x4a, 0xb5, 0xff},
    {0x01, 0x05, 0x43, 0x48, 0x7e},
    {0x02, 0x88, 0x4a, 0xb5, 0xff},
    {0x05, 0xc2, 0x08, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x08, 0x6e},
    {0x04, 0x05, 0x43, 0x48, 0x7e},
    {0x02, 0x06, 0x41, 0x08, 0x6e},
    {0x6c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x45, 0xb5, 0xae},
    {0x01, 0x29, 0x44, 0xf5, 0xbe},
    {0x02, 0x24, 0x45, 0xb5, 0xae},
    {0x06, 0x73, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x49, 0x02, 0xce},
    {0x04, 0x29, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x49, 0x02, 0xce},
    {0x08, 0x72, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x45, 0xb5, 0xae},
    {0x01, 0x10, 0x43, 0x42, 0x9f},
    {0x02, 0x34, 0x45, 0xb5, 0xae},
    {0x05, 0x73, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0x02, 0x8f},
    {0x04, 0x10, 0x43, 0x42, 0x9f},
    {0x02, 0x0f, 0x41, 0x02, 0x8f},
    {0x64, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x45, 0xb5, 0xae},
    {0x01, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x45, 0xb5, 0xae},
    {0x06, 0x4f, 0x05, 0xb5, 0xae},
    {0x03, 0x04, 0x41, 0x08, 0x6e},
    {0x04, 0x8f, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x08, 0x6e},
    {0x07, 0x50, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x08, 0x6e},
    {0x01, 0x06, 0x43, 0x48, 0x7e},
    {0x02, 0x02, 0x41, 0x08, 0x6e},
    {0x05, 0x4f, 0x05, 0xb5, 0xae},
    {0x03, 0x07, 0x41, 0x08, 0x6e},
    {0x04, 0x06, 0x43, 0x48, 0x7e},
    {0x02, 0x07, 0x41, 0x08, 0x6e},
    {0xc6, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0x02, 0x8f},
    {0x01, 0x1f, 0x44, 0xf5, 0xbe},
    {0x02, 0x0d, 0x41, 0x02, 0x8f},
    {0x06, 0x7f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x12, 0x6f},
    {0x04, 0x1f, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0x12, 0x6f},
    {0x09, 0x4e, 0x42, 0xb5, 0xce},
    {0x03, 0x99, 0x42, 0xb5, 0xff},
    {0x01, 0x08, 0x41, 0x42, 0x8f},
    {0x02, 0x99, 0x42, 0xb5, 0xff},
    {0x05, 0x7f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x12, 0x6f},
    {0x04, 0x08, 0x41, 0x42, 0x8f},
    {0x02, 0x05, 0x42, 0x12, 0x6f},
    {0x0b, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x2c, 0x45, 0xb5, 0xae},
    {0x01, 0x39, 0x44, 0xf5, 0xbe},
    {0x02, 0x2c, 0x45, 0xb5, 0xae},
    {0x06, 0x44, 0x01, 0x02, 0x8f},
    {0x03, 0x11, 0x41, 0x02, 0x8f},
    {0x04, 0x39, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x41, 0x02, 0x8f},
    {0x07, 0xce, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0x42, 0xb5, 0xff},
    {0x01, 0x81, 0x52, 0xf5, 0xff},
    {0x02, 0x95, 0x42, 0xb5, 0xff},
    {0x05, 0x44, 0x01, 0x02, 0x8f},
    {0x03, 0x06, 0x42, 0x12, 0x6f},
    {0x04, 0x81, 0x52, 0xf5, 0xff},
    {0x02, 0x06, 0x42, 0x12, 0x6f},
    {0x4e, 0x12, 0xb5, 0x00, 0xff},
    {0x03, 0x01, 0x41, 0x02, 0x8f},
    {0x01, 0x0a, 0x41, 0x42, 0x8f},
    {0x02, 0x01, 0x41, 0x02, 0x8f},
    {0x06, 0x42, 0x01, 0x02, 0x8f},
    {0x03, 0x08, 0x43, 0x08, 0x7e},
    {0x04, 0x0a, 0x41, 0x42, 0x8f},
    {0x02, 0x08, 0x43, 0x08, 0x7e},
    {0x08, 0x4e, 0x42, 0xb5, 0xce},
    {0x03, 0x83, 0x52, 0xb5, 0xff},
    {0x01, 0x04, 0x43, 0x48, 0x7e},
    {0x02, 0x83, 0x52, 0xb5, 0xff},
    {0x05, 0x42, 0x01, 0x02, 0x8f},
    {0x03, 0x81, 0x49, 0x02, 0xce},
    {0x04, 0x04, 0x43, 0x48, 0x7e},
    {0x02, 0x81, 0x49, 0x02, 0xce},
    {0x0c, 0x49, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x08, 0x7e},
    {0x01, 0x02, 0x43, 0x48, 0x7e},
    {0x02, 0x0a, 0x43, 0x08, 0x7e},
    {0x06, 0x47, 0x01, 0x02, 0x8f},
    {0x03, 0x04, 0x42, 0x12, 0x6f},
    {0x04, 0x02, 0x43, 0x48, 0x7e},
    {0x02, 0x04, 0x42, 0x12, 0x6f},
    {0x07, 0x46, 0x03, 0x42, 0x9f},
    {0x03, 0x02, 0x42, 0x12, 0x6f},
    {0x01, 0x07, 0x43, 0x48, 0x7e},
    {0x02, 0x02, 0x42, 0x12, 0x6f},
    {0x05, 0x47, 0x01, 0x02, 0x8f},
    {0x03, 0x07, 0x42, 0x12, 0x6f},
    {0x04, 0x07, 0x43, 0x48, 0x7e},
    {0x02, 0x07, 0x42, 0x12, 0x6f},
    {0xf4, 0x48, 0xf5, 0x00, 0x0e},
    {0x03, 0x1e, 0x45, 0xb5, 0xae},
    {0x01, 0x16, 0x45, 0xf5, 0xae},
    {0x02, 0x1e, 0x45, 0xb5, 0xae},
    {0x06, 0x4d, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x45, 0x0a, 0x6f},
    {0x04, 0x16, 0x45, 0xf5, 0xae},
    {0x02, 0x03, 0x45, 0x0a, 0x6f},
    {0x09, 0x7e, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x44, 0x0a, 0x7f},
    {0x01, 0x03, 0x44, 0x4a, 0x7f},
    {0x02, 0x0b, 0x44, 0x0a, 0x7f},
    {0x05, 0x4d, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x45, 0x0a, 0x6f},
    {0x04, 0x03, 0x44, 0x4a, 0x7f},
    {0x02, 0x05, 0x45, 0x0a, 0x6f},
    {0x0a, 0xca, 0xf5, 0x40, 0x0f},
    {0x03, 0x0c, 0x42, 0x0a, 0x8f},
    {0x01, 0x0b, 0x42, 0x4a, 0x8f},
    {0x02, 0x0c, 0x42, 0x0a, 0x8f},
    {0x06, 0x43, 0x02, 0x0a, 0x8f},
    {0x03, 0x09, 0x44, 0x0a, 0x7f},
    {0x04, 0x0b, 0x42, 0x4a, 0x8f},
    {0x02, 0x09, 0x44, 0x0a, 0x7f},
    {0x07, 0x53, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x45, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0x4a, 0x7f},
    {0x02, 0x9a, 0x45, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0x0a, 0x8f},
    {0x03, 0x06, 0x45, 0x0a, 0x6f},
    {0x04, 0x05, 0x44, 0x4a, 0x7f},
    {0x02, 0x06, 0x45, 0x0a, 0x6f},
    {0x4d, 0x05, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x45, 0xb5, 0xae},
    {0x01, 0x1a, 0x45, 0xf5, 0xae},
    {0x02, 0x22, 0x45, 0xb5, 0xae},
    {0x06, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xca, 0xb5, 0x0f},
    {0x04, 0x1a, 0x45, 0xf5, 0xae},
    {0x02, 0x82, 0xca, 0xb5, 0x0f},
    {0x08, 0x7e, 0xf5, 0x00, 0xee},
    {0x03, 0x32, 0x45, 0xb5, 0xae},
    {0x01, 0x09, 0x42, 0x4a, 0x8f},
    {0x02, 0x32, 0x45, 0xb5, 0xae},
    {0x05, 0xd8, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0x0a, 0x8f},
    {0x04, 0x09, 0x42, 0x4a, 0x8f},
    {0x02, 0x0e, 0x42, 0x0a, 0x8f},
    {0x5c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x45, 0xb5, 0xae},
    {0x01, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x45, 0xb5, 0xae},
    {0x06, 0x45, 0x02, 0x0a, 0x8f},
    {0x03, 0x04, 0x45, 0x0a, 0x6f},
    {0x04, 0x8b, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0x0a, 0x6f},
    {0x07, 0x48, 0x05, 0xf5, 0xae},
    {0x03, 0x02, 0x45, 0x0a, 0x6f},
    {0x01, 0x06, 0x44, 0x4a, 0x7f},
    {0x02, 0x02, 0x45, 0x0a, 0x6f},
    {0x05, 0x45, 0x02, 0x0a, 0x8f},
    {0x03, 0x07, 0x45, 0x0a, 0x6f},
    {0x04, 0x06, 0x44, 0x4a, 0x7f},
    {0x02, 0x07, 0x45, 0x0a, 0x6f},
    {0x7c, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x30, 0x45, 0xb5, 0xae},
    {0x01, 0x25, 0x44, 0xf5, 0xbe},
    {0x02, 0x30, 0x45, 0xb5, 0xae},
    {0x06, 0x6b, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x05, 0x6c},
    {0x04, 0x25, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x05, 0x6c},
    {0x09, 0x44, 0x45, 0xb5, 0xae},
    {0x03, 0x3c, 0x45, 0xb5, 0xae},
    {0x01, 0x82, 0x45, 0x42, 0xce},
    {0x02, 0x3c, 0x45, 0xb5, 0xae},
    {0x05, 0x6b, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x05, 0x6c},
    {0x04, 0x82, 0x45, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x05, 0x6c},
    {0x0b, 0xca, 0xf5, 0x40, 0x0f},
    {0x03, 0x2a, 0x45, 0xb5, 0xae},
    {0x01, 0x19, 0x45, 0xf5, 0xae},
    {0x02, 0x2a, 0x45, 0xb5, 0xae},
    {0x06, 0x51, 0x05, 0xb5, 0xae},
    {0x03, 0x10, 0x42, 0x0a, 0x8f},
    {0x04, 0x19, 0x45, 0xf5, 0xae},
    {0x02, 0x10, 0x42, 0x0a, 0x8f},
    {0x07, 0x78, 0x02, 0xf5, 0xdf},
    {0x03, 0x91, 0x42, 0xb5, 0xff},
    {0x01, 0x0f, 0x43, 0x42, 0x9f},
    {0x02, 0x91, 0x42, 0xb5, 0xff},
    {0x05, 0x51, 0x05, 0xb5, 0xae},
    {0x03, 0x06, 0x43, 0x05, 0x6c},
    {0x04, 0x0f, 0x43, 0x42, 0x9f},
    {0x02, 0x06, 0x43, 0x05, 0x6c},
    {0x68, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x45, 0xb5, 0xae},
    {0x01, 0x85, 0x42, 0xf5, 0xff},
    {0x02, 0x20, 0x45, 0xb5, 0xae},
    {0x06, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0x0a, 0x7f},
    {0x04, 0x85, 0x42, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x0a, 0x7f},
    {0x08, 0x44, 0x45, 0xb5, 0xae},
    {0x03, 0x3a, 0x45, 0xb5, 0xae},
    {0x01, 0x04, 0x44, 0x4a, 0x7f},
    {0x02, 0x3a, 0x45, 0xb5, 0xae},
    {0x05, 0xd4, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xca, 0xb5, 0x0f},
    {0x04, 0x04, 0x44, 0x4a, 0x7f},
    {0x02, 0x81, 0xca, 0xb5, 0x0f},
    {0x0c, 0xca, 0xf5, 0x40, 0x0f},
    {0x03, 0x0a, 0x44, 0x0a, 0x7f},
    {0x01, 0x02, 0x44, 0x4a, 0x7f},
    {0x02, 0x0a, 0x44, 0x0a, 0x7f},
    {0x06, 0x46, 0x02, 0x0a, 0x8f},
    {0x03, 0x04, 0x43, 0x05, 0x6c},
    {0x04, 0x02, 0x44, 0x4a, 0x7f},
    {0x02, 0x04, 0x43, 0x05, 0x6c},
    {0x07, 0xc1, 0x0a, 0xf5, 0xff},
    {0x03, 0x02, 0x43, 0x05, 0x6c},
    {0x01, 0x07, 0x44, 0x4a, 0x7f},
    {0x02, 0x02, 0x43, 0x05, 0x6c},
    {0x05, 0x46, 0x02, 0x0a, 0x8f},
    {0x03, 0x07, 0x43, 0x05, 0x6c},
    {0x04, 0x07, 0x44, 0x4a, 0x7f},
    {0x02, 0x07, 0x43, 0x05, 0x6c},
    {0xe5, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0x02, 0x9f},
    {0x01, 0x0d, 0x43, 0x42, 0x9f},
    {0x02, 0x16, 0x43, 0x02, 0x9f},
    {0x06, 0x41, 0x05, 0xb5, 0xae},
    {0x03, 0x03, 0x44, 0x08, 0x6e},
    {0x04, 0x0d, 0x43, 0x42, 0x9f},
    {0x02, 0x03, 0x44, 0x08, 0x6e},
    {0x09, 0x42, 0x45, 0xb5, 0xae},
    {0x03, 0x0b, 0x42, 0x08, 0x7e},
    {0x01, 0x03, 0x42, 0x48, 0x7e},
    {0x02, 0x0b, 0x42, 0x08, 0x7e},
    {0x05, 0x41, 0x05, 0xb5, 0xae},
    {0x03, 0x05, 0x44, 0x08, 0x6e},
    {0x04, 0x03, 0x42, 0x48, 0x7e},
    {0x02, 0x05, 0x44, 0x08, 0x6e},
    {0x0a, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x43, 0x02, 0x9f},
    {0x01, 0x12, 0x45, 0xf5, 0xae},
    {0x02, 0x1a, 0x43, 0x02, 0x9f},
    {0x06, 0x48, 0x03, 0x02, 0x9f},
    {0x03, 0x09, 0x42, 0x08, 0x7e},
    {0x04, 0x12, 0x45, 0xf5, 0xae},
    {0x02, 0x09, 0x42, 0x08, 0x7e},
    {0x07, 0x4a, 0x05, 0xf5, 0xae},
    {0x03, 0x8a, 0x4a, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x48, 0x7e},
    {0x02, 0x8a, 0x4a, 0xb5, 0xff},
    {0x05, 0x48, 0x03, 0x02, 0x9f},
    {0x03, 0x06, 0x44, 0x08, 0x6e},
    {0x04, 0x05, 0x42, 0x48, 0x7e},
    {0x02, 0x06, 0x44, 0x08, 0x6e},
    {0x50, 0x0a, 0xf5, 0x00, 0xff},
    {0x03, 0x26, 0x45, 0xb5, 0xae},
    {0x01, 0x15, 0x45, 0xf5, 0xae},
    {0x02, 0x26, 0x45, 0xb5, 0xae},
    {0x06, 0xc3, 0x0a, 0xb5, 0xff},
    {0x03, 0x82, 0x46, 0x04, 0xbe},
    {0x04, 0x15, 0x45, 0xf5, 0xae},
    {0x02, 0x82, 0x46, 0x04, 0xbe},
    {0x08, 0x42, 0x45, 0xb5, 0xae},
    {0x03, 0x19, 0x43, 0x02, 0x9f},
    {0x01, 0x11, 0x43, 0x42, 0x9f},
    {0x02, 0x19, 0x43, 0x02, 0x9f},
    {0x05, 0xc3, 0x0a, 0xb5, 0xff},
    {0x03, 0x0f, 0x42, 0x0a, 0x8f},
    {0x04, 0x11, 0x43, 0x42, 0x9f},
    {0x02, 0x0f, 0x42, 0x0a, 0x8f},
    {0x40, 0x0a, 0xf5, 0x00, 0xff},
    {0x03, 0x86, 0x4a, 0xb5, 0xff},
    {0x01, 0x84, 0x4a, 0xf5, 0xff},
    {0x02, 0x86, 0x4a, 0xb5, 0xff},
    {0x06, 0xc1, 0x08, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x08, 0x6e},
    {0x04, 0x84, 0x4a, 0xf5, 0xff},
    {0x02, 0x04, 0x44, 0x08, 0x6e},
    {0x07, 0x44, 0x03, 0x42, 0x9f},
    {0x03, 0x02, 0x44, 0x08, 0x6e},
    {0x01, 0x06, 0x42, 0x48, 0x7e},
    {0x02, 0x02, 0x44, 0x08, 0x6e},
    {0x05, 0xc1, 0x08, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x08, 0x6e},
    {0x04, 0x06, 0x42, 0x48, 0x7e},
    {0x02, 0x07, 0x44, 0x08, 0x6e},
    {0xc1, 0x45, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x42, 0x0a, 0x8f},
    {0x01, 0x01, 0x43, 0x42, 0x9f},
    {0x02, 0x0d, 0x42, 0x0a, 0x8f},
    {0x06, 0x4a, 0x03, 0x02, 0x9f},
    {0x03, 0x03, 0x42, 0x05, 0x6c},
    {0x04, 0x01, 0x43, 0x42, 0x9f},
    {0x02, 0x03, 0x42, 0x05, 0x6c},
    {0x09, 0x47, 0x45, 0xb5, 0xae},
    {0x03, 0x12, 0x43, 0x02, 0x9f},
    {0x01, 0x08, 0x42, 0x4a, 0x8f},
    {0x02, 0x12, 0x43, 0x02, 0x9f},
    {0x05, 0x4a, 0x03, 0x02, 0x9f},
    {0x03, 0x05, 0x42, 0x05, 0x6c},
    {0x04, 0x08, 0x42, 0x4a, 0x8f},
    {0x02, 0x05, 0x42, 0x05, 0x6c},
    {0x0b, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x43, 0x02, 0x9f},
    {0x01, 0x83, 0x48, 0xf5, 0xee},
    {0x02, 0x15, 0x43, 0x02, 0x9f},
    {0x06, 0x44, 0x02, 0x0a, 0x8f},
    {0x03, 0x11, 0x42, 0x0a, 0x8f},
    {0x04, 0x83, 0x48, 0xf5, 0xee},
    {0x02, 0x11, 0x42, 0x0a, 0x8f},
    {0x07, 0x42, 0x03, 0x42, 0x9f},
    {0x03, 0x84, 0x48, 0xb5, 0xee},
    {0x01, 0x81, 0x45, 0x42, 0xce},
    {0x02, 0x84, 0x48, 0xb5, 0xee},
    {0x05, 0x44, 0x02, 0x0a, 0x8f},
    {0x03, 0x06, 0x42, 0x05, 0x6c},
    {0x04, 0x81, 0x45, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x05, 0x6c},
    {0x4e, 0x05, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x0a, 0x8f},
    {0x01, 0x0a, 0x42, 0x4a, 0x8f},
    {0x02, 0x01, 0x42, 0x0a, 0x8f},
    {0x06, 0x42, 0x02, 0x0a, 0x8f},
    {0x03, 0x08, 0x42, 0x08, 0x7e},
    {0x04, 0x0a, 0x42, 0x4a, 0x8f},
    {0x02, 0x08, 0x42, 0x08, 0x7e},
    {0x08, 0x47, 0x45, 0xb5, 0xae},
    {0x03, 0x83, 0x45, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x48, 0x7e},
    {0x02, 0x83, 0x45, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0x0a, 0x8f},
    {0x03, 0x81, 0x46, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0x48, 0x7e},
    {0x02, 0x81, 0x46, 0x04, 0xbe},
    {0x0c, 0x46, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x08, 0x7e},
    {0x01, 0x02, 0x42, 0x48, 0x7e},
    {0x02, 0x0a, 0x42, 0x08, 0x7e},
    {0x06, 0x47, 0x02, 0x0a, 0x8f},
    {0x03, 0x04, 0x42, 0x05, 0x6c},
    {0x04, 0x02, 0x42, 0x48, 0x7e},
    {0x02, 0x04, 0x42, 0x05, 0x6c},
    {0x07, 0x47, 0x03, 0x42, 0x9f},
    {0x03, 0x02, 0x42, 0x05, 0x6c},
    {0x01, 0x07, 0x42, 0x48, 0x7e},
    {0x02, 0x02, 0x42, 0x05, 0x6c},
    {0x05, 0x47, 0x02, 0x0a, 0x8f},
    {0x03, 0x07, 0x42, 0x05, 0x6c},
    {0x04, 0x07, 0x42, 0x48, 0x7e},
    {0x02, 0x07, 0x42, 0x05, 0x6c},
    {0xf4, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0xb4, 0x42, 0xb5, 0xff},
    {0x01, 0xa4, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0x42, 0xb5, 0xff},
    {0x06, 0x5d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x4b, 0xb5, 0x6d},
    {0x04, 0xa4, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4b, 0xb5, 0x6d},
    {0x09, 0x70, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x48, 0xb5, 0x7d},
    {0x01, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x0b, 0x48, 0xb5, 0x7d},
    {0x05, 0x5d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x4b, 0xb5, 0x6d},
    {0x04, 0x03, 0x48, 0xf5, 0x7d},
    {0x02, 0x05, 0x4b, 0xb5, 0x6d},
    {0x0a, 0x66, 0xf5, 0x40, 0xff},
    {0x03, 0x0c, 0x46, 0xb5, 0x8c},
    {0x01, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x0c, 0x46, 0xb5, 0x8c},
    {0x06, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x09, 0x48, 0xb5, 0x7d},
    {0x04, 0x0b, 0x46, 0xf5, 0x8c},
    {0x02, 0x09, 0x48, 0xb5, 0x7d},
    {0x07, 0x6e, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x55, 0xb5, 0xff},
    {0x01, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x9a, 0x55, 0xb5, 0xff},
    {0x05, 0x43, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x4b, 0xb5, 0x6d},
    {0x04, 0x05, 0x48, 0xf5, 0x7d},
    {0x02, 0x06, 0x4b, 0xb5, 0x6d},
    {0x4d, 0x15, 0xb5, 0x00, 0xff},
    {0x03, 0x14, 0x41, 0xb5, 0x9c},
    {0x01, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x14, 0x41, 0xb5, 0x9c},
    {0x06, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x82, 0x66, 0xb5, 0xff},
    {0x04, 0x0c, 0x41, 0xf5, 0x9c},
    {0x02, 0x82, 0x66, 0xb5, 0xff},
    {0x08, 0x70, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x41, 0xb5, 0x9c},
    {0x01, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x18, 0x41, 0xb5, 0x9c},
    {0x05, 0x4b, 0x01, 0xb5, 0x9c},
    {0x03, 0x0e, 0x46, 0xb5, 0x8c},
    {0x04, 0x09, 0x46, 0xf5, 0x8c},
    {0x02, 0x0e, 0x46, 0xb5, 0x8c},
    {0x4f, 0x83, 0xb5, 0x40, 0x0f},
    {0x03, 0x1c, 0x41, 0xb5, 0x9c},
    {0x01, 0x9a, 0xc3, 0xf5, 0x0f},
    {0x02, 0x1c, 0x41, 0xb5, 0x9c},
    {0x06, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x4b, 0xb5, 0x6d},
    {0x04, 0x9a, 0xc3, 0xf5, 0x0f},
    {0x02, 0x04, 0x4b, 0xb5, 0x6d},
    {0x07, 0x43, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x4b, 0xb5, 0x6d},
    {0x01, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x4b, 0xb5, 0x6d},
    {0x05, 0x45, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x4b, 0xb5, 0x6d},
    {0x04, 0x06, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x4b, 0xb5, 0x6d},
    {0x52, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x41, 0xb5, 0x9c},
    {0x01, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x17, 0x41, 0xb5, 0x9c},
    {0x06, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x15, 0x6f},
    {0x04, 0x14, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x15, 0x6f},
    {0x09, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x1b, 0x41, 0xb5, 0x9c},
    {0x01, 0x82, 0x55, 0xf5, 0xff},
    {0x02, 0x1b, 0x41, 0xb5, 0x9c},
    {0x05, 0x4c, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x15, 0x6f},
    {0x04, 0x82, 0x55, 0xf5, 0xff},
    {0x02, 0x05, 0x43, 0x15, 0x6f},
    {0x0b, 0x66, 0xf5, 0x40, 0xff},
    {0x03, 0x27, 0x43, 0xb5, 0xac},
    {0x01, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x27, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x10, 0x46, 0xb5, 0x8c},
    {0x04, 0x18, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x46, 0xb5, 0x8c},
    {0x07, 0x4b, 0x03, 0xf5, 0xac},
    {0x03, 0x89, 0x44, 0xb5, 0xee},
    {0x01, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x89, 0x44, 0xb5, 0xee},
    {0x05, 0x49, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x15, 0x6f},
    {0x04, 0x0e, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x15, 0x6f},
    {0x51, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x41, 0xb5, 0x9c},
    {0x01, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x13, 0x41, 0xb5, 0x9c},
    {0x06, 0xda, 0x04, 0xb5, 0xee},
    {0x03, 0x08, 0x48, 0xb5, 0x7d},
    {0x04, 0x1c, 0x43, 0xf5, 0xac},
    {0x02, 0x08, 0x48, 0xb5, 0x7d},
    {0x08, 0x43, 0x43, 0xb5, 0xac},
    {0x03, 0x37, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x37, 0x43, 0xb5, 0xac},
    {0x05, 0xda, 0x04, 0xb5, 0xee},
    {0x03, 0x81, 0x66, 0xb5, 0xff},
    {0x04, 0x04, 0x48, 0xf5, 0x7d},
    {0x02, 0x81, 0x66, 0xb5, 0xff},
    {0x0c, 0x66, 0xf5, 0x40, 0xff},
    {0x03, 0x0a, 0x48, 0xb5, 0x7d},
    {0x01, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x0a, 0x48, 0xb5, 0x7d},
    {0x06, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x15, 0x6f},
    {0x04, 0x02, 0x48, 0xf5, 0x7d},
    {0x02, 0x04, 0x43, 0x15, 0x6f},
    {0x07, 0x45, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x15, 0x6f},
    {0x01, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x02, 0x43, 0x15, 0x6f},
    {0x05, 0x46, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x15, 0x6f},
    {0x04, 0x07, 0x48, 0xf5, 0x7d},
    {0x02, 0x07, 0x43, 0x15, 0x6f},
    {0xdf, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x43, 0xb5, 0xac},
    {0x01, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x2d, 0x43, 0xb5, 0xac},
    {0x06, 0x61, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x83, 0x6f},
    {0x04, 0x17, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0x83, 0x6f},
    {0x09, 0x7c, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x83, 0x7f},
    {0x01, 0x03, 0x43, 0xc3, 0x7f},
    {0x02, 0x0b, 0x43, 0x83, 0x7f},
    {0x05, 0x61, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x83, 0x6f},
    {0x04, 0x03, 0x43, 0xc3, 0x7f},
    {0x02, 0x05, 0x41, 0x83, 0x6f},
    {0x0a, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x35, 0x43, 0xb5, 0xac},
    {0x01, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x35, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x83, 0xb5, 0x0f},
    {0x03, 0x09, 0x43, 0x83, 0x7f},
    {0x04, 0x1b, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0x83, 0x7f},
    {0x07, 0x76, 0x02, 0xf5, 0xdf},
    {0x03, 0x87, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0xc3, 0x7f},
    {0x02, 0x87, 0x44, 0xb5, 0xee},
    {0x05, 0xc2, 0x83, 0xb5, 0x0f},
    {0x03, 0x06, 0x41, 0x83, 0x6f},
    {0x04, 0x05, 0x43, 0xc3, 0x7f},
    {0x02, 0x06, 0x41, 0x83, 0x6f},
    {0x72, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x43, 0xb5, 0xac},
    {0x01, 0x28, 0x44, 0xf5, 0xbe},
    {0x02, 0x23, 0x43, 0xb5, 0xac},
    {0x06, 0x71, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc2, 0xb5, 0x0c},
    {0x04, 0x28, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0xc2, 0xb5, 0x0c},
    {0x08, 0x7c, 0xf5, 0x00, 0xee},
    {0x03, 0x33, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x33, 0x43, 0xb5, 0xac},
    {0x05, 0x71, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x46, 0xb5, 0x8c},
    {0x04, 0x10, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x46, 0xb5, 0x8c},
    {0x62, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x43, 0xb5, 0xac},
    {0x01, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x43, 0xb5, 0xac},
    {0x06, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x83, 0x6f},
    {0x04, 0x8d, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x83, 0x6f},
    {0x07, 0x49, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0x83, 0x6f},
    {0x01, 0x06, 0x43, 0xc3, 0x7f},
    {0x02, 0x02, 0x41, 0x83, 0x6f},
    {0x05, 0x4e, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x83, 0x6f},
    {0x04, 0x06, 0x43, 0xc3, 0x7f},
    {0x02, 0x07, 0x41, 0x83, 0x6f},
    {0xdb, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x46, 0xb5, 0x8c},
    {0x01, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x0d, 0x46, 0xb5, 0x8c},
    {0x06, 0x7d, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x15, 0x6f},
    {0x04, 0x13, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x15, 0x6f},
    {0x09, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x98, 0x42, 0xb5, 0xff},
    {0x01, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x98, 0x42, 0xb5, 0xff},
    {0x05, 0x7d, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x15, 0x6f},
    {0x04, 0x08, 0x46, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x15, 0x6f},
    {0x0b, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x2b, 0x43, 0xb5, 0xac},
    {0x01, 0x38, 0x44, 0xf5, 0xbe},
    {0x02, 0x2b, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x11, 0x46, 0xb5, 0x8c},
    {0x04, 0x38, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x46, 0xb5, 0x8c},
    {0x07, 0xc8, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0x42, 0xb5, 0xff},
    {0x01, 0x81, 0x55, 0xf5, 0xff},
    {0x02, 0x94, 0x42, 0xb5, 0xff},
    {0x05, 0x44, 0x06, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x15, 0x6f},
    {0x04, 0x81, 0x55, 0xf5, 0xff},
    {0x02, 0x06, 0x42, 0x15, 0x6f},
    {0x4e, 0x15, 0xb5, 0x00, 0xff},
    {0x03, 0x01, 0x46, 0xb5, 0x8c},
    {0x01, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x01, 0x46, 0xb5, 0x8c},
    {0x06, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0x83, 0x7f},
    {0x04, 0x0a, 0x46, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0x83, 0x7f},
    {0x08, 0x45, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x55, 0xb5, 0xff},
    {0x01, 0x04, 0x43, 0xc3, 0x7f},
    {0x02, 0x83, 0x55, 0xb5, 0xff},
    {0x05, 0x42, 0x06, 0xb5, 0x8c},
    {0x03, 0x81, 0xc2, 0xb5, 0x0c},
    {0x04, 0x04, 0x43, 0xc3, 0x7f},
    {0x02, 0x81, 0xc2, 0xb5, 0x0c},
    {0x0c, 0xc2, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x43, 0x83, 0x7f},
    {0x01, 0x02, 0x43, 0xc3, 0x7f},
    {0x02, 0x0a, 0x43, 0x83, 0x7f},
    {0x06, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x15, 0x6f},
    {0x04, 0x02, 0x43, 0xc3, 0x7f},
    {0x02, 0x04, 0x42, 0x15, 0x6f},
    {0x07, 0x46, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x15, 0x6f},
    {0x01, 0x07, 0x43, 0xc3, 0x7f},
    {0x02, 0x02, 0x42, 0x15, 0x6f},
    {0x05, 0x47, 0x06, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x15, 0x6f},
    {0x04, 0x07, 0x43, 0xc3, 0x7f},
    {0x02, 0x07, 0x42, 0x15, 0x6f},
    {0xb4, 0x83, 0xb5, 0x00, 0x0f},
    {0x03, 0x1d, 0x43, 0xb5, 0xac},
    {0x01, 0x2e, 0x44, 0xf5, 0xbe},
    {0x02, 0x1d, 0x43, 0xb5, 0xac},
    {0x06, 0x6f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0x04, 0x6e},
    {0x04, 0x2e, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x46, 0x04, 0x6e},
    {0x09, 0x6a, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x41, 0x04, 0x7e},
    {0x01, 0x03, 0x41, 0x44, 0x7e},
    {0x02, 0x0b, 0x41, 0x04, 0x7e},
    {0x05, 0x6f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0x04, 0x6e},
    {0x04, 0x03, 0x41, 0x44, 0x7e},
    {0x02, 0x05, 0x46, 0x04, 0x6e},
    {0x0a, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0x04, 0x8e},
    {0x01, 0x0b, 0x43, 0x44, 0x8e},
    {0x02, 0x0c, 0x43, 0x04, 0x8e},
    {0x06, 0x43, 0x03, 0x04, 0x8e},
    {0x03, 0x09, 0x41, 0x04, 0x7e},
    {0x04, 0x0b, 0x43, 0x44, 0x8e},
    {0x02, 0x09, 0x41, 0x04, 0x7e},
    {0x07, 0x64, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x51, 0xb5, 0xee},
    {0x01, 0x05, 0x41, 0x44, 0x7e},
    {0x02, 0x9a, 0x51, 0xb5, 0xee},
    {0x05, 0x43, 0x03, 0x04, 0x8e},
    {0x03, 0x06, 0x46, 0x04, 0x6e},
    {0x04, 0x05, 0x41, 0x44, 0x7e},
    {0x02, 0x06, 0x46, 0x04, 0x6e},
    {0x4d, 0x11, 0xb5, 0x00, 0xee},
    {0x03, 0x21, 0x43, 0xb5, 0xac},
    {0x01, 0x36, 0x44, 0xf5, 0xbe},
    {0x02, 0x21, 0x43, 0xb5, 0xac},
    {0x06, 0x7b, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x59, 0xb5, 0xee},
    {0x04, 0x36, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x59, 0xb5, 0xee},
    {0x08, 0x6a, 0xf5, 0x00, 0xee},
    {0x03, 0x31, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x44, 0x8e},
    {0x02, 0x31, 0x43, 0xb5, 0xac},
    {0x05, 0x7b, 0x02, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0x04, 0x8e},
    {0x04, 0x09, 0x43, 0x44, 0x8e},
    {0x02, 0x0e, 0x43, 0x04, 0x8e},
    {0x5a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x43, 0xb5, 0xac},
    {0x01, 0x88, 0x42, 0xf5, 0xff},
    {0x02, 0x3d, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x46, 0x04, 0x6e},
    {0x04, 0x88, 0x42, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x04, 0x6e},
    {0x07, 0xc2, 0x04, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x04, 0x6e},
    {0x01, 0x06, 0x41, 0x44, 0x7e},
    {0x02, 0x02, 0x46, 0x04, 0x6e},
    {0x05, 0x45, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x46, 0x04, 0x6e},
    {0x04, 0x06, 0x41, 0x44, 0x7e},
    {0x02, 0x07, 0x46, 0x04, 0x6e},
    {0xd7, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x43, 0xb5, 0xac},
    {0x01, 0x24, 0x44, 0xf5, 0xbe},
    {0x02, 0x2f, 0x43, 0xb5, 0xac},
    {0x06, 0x69, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x11, 0x6e},
    {0x04, 0x24, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x11, 0x6e},
    {0x09, 0x50, 0x42, 0xb5, 0xce},
    {0x03, 0x3b, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x51, 0xf5, 0xee},
    {0x02, 0x3b, 0x43, 0xb5, 0xac},
    {0x05, 0x69, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x11, 0x6e},
    {0x04, 0x82, 0x51, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x11, 0x6e},
    {0x0b, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x43, 0xb5, 0xac},
    {0x01, 0x34, 0x44, 0xf5, 0xbe},
    {0x02, 0x29, 0x43, 0xb5, 0xac},
    {0x06, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x04, 0x8e},
    {0x04, 0x34, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x43, 0x04, 0x8e},
    {0x07, 0x74, 0x02, 0xf5, 0xdf},
    {0x03, 0x90, 0x42, 0xb5, 0xff},
    {0x01, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x90, 0x42, 0xb5, 0xff},
    {0x05, 0x50, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x11, 0x6e},
    {0x04, 0x0f, 0x41, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x11, 0x6e},
    {0x60, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x43, 0xb5, 0xac},
    {0x01, 0x00, 0x44, 0xf5, 0xbe},
    {0x02, 0x1f, 0x43, 0xb5, 0xac},
    {0x06, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x04, 0x7e},
    {0x04, 0x00, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x41, 0x04, 0x7e},
    {0x08, 0x50, 0x42, 0xb5, 0xce},
    {0x03, 0x39, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x44, 0x7e},
    {0x02, 0x39, 0x43, 0xb5, 0xac},
    {0x05, 0xd0, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x59, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0x44, 0x7e},
    {0x02, 0x81, 0x59, 0xb5, 0xee},
    {0x0c, 0x59, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0x04, 0x7e},
    {0x01, 0x02, 0x41, 0x44, 0x7e},
    {0x02, 0x0a, 0x41, 0x04, 0x7e},
    {0x06, 0x46, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x43, 0x11, 0x6e},
    {0x04, 0x02, 0x41, 0x44, 0x7e},
    {0x02, 0x04, 0x43, 0x11, 0x6e},
    {0x07, 0x4f, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x43, 0x11, 0x6e},
    {0x01, 0x07, 0x41, 0x44, 0x7e},
    {0x02, 0x02, 0x43, 0x11, 0x6e},
    {0x05, 0x46, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x43, 0x11, 0x6e},
    {0x04, 0x07, 0x41, 0x44, 0x7e},
    {0x02, 0x07, 0x43, 0x11, 0x6e},
    {0xde, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x41, 0xb5, 0x9c},
    {0x01, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x16, 0x41, 0xb5, 0x9c},
    {0x06, 0x5f, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0x83, 0x6f},
    {0x04, 0x0d, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0x83, 0x6f},
    {0x09, 0xd2, 0xf5, 0x00, 0x0f},
    {0x03, 0x0b, 0x42, 0x83, 0x7f},
    {0x01, 0x03, 0x42, 0xc3, 0x7f},
    {0x02, 0x0b, 0x42, 0x83, 0x7f},
    {0x05, 0x5f, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0x83, 0x6f},
    {0x04, 0x03, 0x42, 0xc3, 0x7f},
    {0x02, 0x05, 0x44, 0x83, 0x6f},
    {0x0a, 0x4f, 0x42, 0xf5, 0xdf},
    {0x03, 0x1a, 0x41, 0xb5, 0x9c},
    {0x01, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x41, 0xb5, 0x9c},
    {0x06, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0x83, 0x7f},
    {0x04, 0x99, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x83, 0x7f},
    {0x07, 0x40, 0x02, 0xf5, 0xdf},
    {0x03, 0x8c, 0x42, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0xc3, 0x7f},
    {0x02, 0x8c, 0x42, 0xb5, 0xff},
    {0x05, 0x48, 0x01, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0x83, 0x6f},
    {0x04, 0x05, 0x42, 0xc3, 0x7f},
    {0x02, 0x06, 0x44, 0x83, 0x6f},
    {0x7d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x43, 0xb5, 0xac},
    {0x01, 0x2c, 0x44, 0xf5, 0xbe},
    {0x02, 0x25, 0x43, 0xb5, 0xac},
    {0x06, 0x79, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x4f, 0x02, 0xdf},
    {0x04, 0x2c, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x4f, 0x02, 0xdf},
    {0x08, 0xd2, 0xf5, 0x00, 0x0f},
    {0x03, 0x19, 0x41, 0xb5, 0x9c},
    {0x01, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x19, 0x41, 0xb5, 0x9c},
    {0x05, 0x79, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x04, 0x8e},
    {0x04, 0x11, 0x41, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x04, 0x8e},
    {0x6a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x44, 0xb5, 0xee},
    {0x01, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x44, 0xb5, 0xee},
    {0x06, 0xc1, 0x83, 0xb5, 0x0f},
    {0x03, 0x04, 0x44, 0x83, 0x6f},
    {0x04, 0x95, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x83, 0x6f},
    {0x07, 0x44, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0x83, 0x6f},
    {0x01, 0x06, 0x42, 0xc3, 0x7f},
    {0x02, 0x02, 0x44, 0x83, 0x6f},
    {0x05, 0xc1, 0x83, 0xb5, 0x0f},
    {0x03, 0x07, 0x44, 0x83, 0x6f},
    {0x04, 0x06, 0x42, 0xc3, 0x7f},
    {0x02, 0x07, 0x44, 0x83, 0x6f},
    {0xd1, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x04, 0x8e},
    {0x01, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x04, 0x8e},
    {0x06, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x11, 0x6e},
    {0x04, 0x01, 0x41, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x11, 0x6e},
    {0x09, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x41, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x44, 0x8e},
    {0x02, 0x12, 0x41, 0xb5, 0x9c},
    {0x05, 0x4a, 0x01, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x11, 0x6e},
    {0x04, 0x08, 0x43, 0x44, 0x8e},
    {0x02, 0x05, 0x42, 0x11, 0x6e},
    {0x0b, 0x4f, 0x42, 0xf5, 0xdf},
    {0x03, 0x15, 0x41, 0xb5, 0x9c},
    {0x01, 0x83, 0xc3, 0xf5, 0x0f},
    {0x02, 0x15, 0x41, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x04, 0x8e},
    {0x03, 0x11, 0x43, 0x04, 0x8e},
    {0x04, 0x83, 0xc3, 0xf5, 0x0f},
    {0x02, 0x11, 0x43, 0x04, 0x8e},
    {0x07, 0x42, 0x01, 0xf5, 0x9c},
    {0x03, 0x84, 0xc3, 0xb5, 0x0f},
    {0x01, 0x81, 0x51, 0xf5, 0xee},
    {0x02, 0x84, 0xc3, 0xb5, 0x0f},
    {0x05, 0x44, 0x03, 0x04, 0x8e},
    {0x03, 0x06, 0x42, 0x11, 0x6e},
    {0x04, 0x81, 0x51, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x11, 0x6e},
    {0x4e, 0x11, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x43, 0x04, 0x8e},
    {0x01, 0x0a, 0x43, 0x44, 0x8e},
    {0x02, 0x01, 0x43, 0x04, 0x8e},
    {0x06, 0x42, 0x03, 0x04, 0x8e},
    {0x03, 0x08, 0x42, 0x83, 0x7f},
    {0x04, 0x0a, 0x43, 0x44, 0x8e},
    {0x02, 0x08, 0x42, 0x83, 0x7f},
    {0x08, 0x46, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x51, 0xb5, 0xee},
    {0x01, 0x04, 0x42, 0xc3, 0x7f},
    {0x02, 0x83, 0x51, 0xb5, 0xee},
    {0x05, 0x42, 0x03, 0x04, 0x8e},
    {0x03, 0x81, 0x4f, 0x02, 0xdf},
    {0x04, 0x04, 0x42, 0xc3, 0x7f},
    {0x02, 0x81, 0x4f, 0x02, 0xdf},
    {0x0c, 0x4f, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x42, 0x83, 0x7f},
    {0x01, 0x02, 0x42, 0xc3, 0x7f},
    {0x02, 0x0a, 0x42, 0x83, 0x7f},
    {0x06, 0x47, 0x03, 0x04, 0x8e},
    {0x03, 0x04, 0x42, 0x11, 0x6e},
    {0x04, 0x02, 0x42, 0xc3, 0x7f},
    {0x02, 0x04, 0x42, 0x11, 0x6e},
    {0x07, 0x47, 0x01, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x11, 0x6e},
    {0x01, 0x07, 0x42, 0xc3, 0x7f},
    {0x02, 0x02, 0x42, 0x11, 0x6e},
    {0x05, 0x47, 0x03, 0x04, 0x8e},
    {0x03, 0x07, 0x42, 0x11, 0x6e},
    {0x04, 0x07, 0x42, 0xc3, 0x7f},
    {0x02, 0x07, 0x42, 0x11, 0x6e},
    {0xf4, 0x44, 0xf5, 0x00, 0x0e},
    {0x03, 0x9e, 0xf5, 0x00, 0x0d},
    {0x01, 0x1e, 0x44, 0xf5, 0xbe},
    {0x02, 0x9e, 0xf5, 0x00, 0x0d},
    {0x06, 0x56, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x47, 0x02, 0x6f},
    {0x04, 0x1e, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x47, 0x02, 0x6f},
    {0x09, 0x60, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x45, 0x02, 0x7f},
    {0x01, 0x03, 0x45, 0x42, 0x7f},
    {0x02, 0x0b, 0x45, 0x02, 0x7f},
    {0x05, 0x56, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x47, 0x02, 0x6f},
    {0x04, 0x03, 0x45, 0x42, 0x7f},
    {0x02, 0x05, 0x47, 0x02, 0x6f},
    {0x0a, 0xc6, 0xf5, 0x40, 0x0f},
    {0x03, 0x0c, 0x44, 0x02, 0x8f},
    {0x01, 0x0b, 0x44, 0x42, 0x8f},
    {0x02, 0x0c, 0x44, 0x02, 0x8f},
    {0x06, 0x43, 0x04, 0x02, 0x8f},
    {0x03, 0x09, 0x45, 0x02, 0x7f},
    {0x04, 0x0b, 0x44, 0x42, 0x8f},
    {0x02, 0x09, 0x45, 0x02, 0x7f},
    {0x07, 0x4d, 0x04, 0xf5, 0xbe},
    {0x03, 0x9a, 0xc4, 0xb5, 0x0f},
    {0x01, 0x05, 0x45, 0x42, 0x7f},
    {0x02, 0x9a, 0xc4, 0xb5, 0x0f},
    {0x05, 0x43, 0x04, 0x02, 0x8f},
    {0x03, 0x06, 0x47, 0x02, 0x6f},
    {0x04, 0x05, 0x45, 0x42, 0x7f},
    {0x02, 0x06, 0x47, 0x02, 0x6f},
    {0x4d, 0x84, 0xb5, 0x00, 0x0f},
    {0x03, 0x14, 0x42, 0x02, 0x9f},
    {0x01, 0x0c, 0x42, 0x42, 0x9f},
    {0x02, 0x14, 0x42, 0x02, 0x9f},
    {0x06, 0x4b, 0x02, 0x02, 0x9f},
    {0x03, 0x82, 0xc6, 0xb5, 0x0f},
    {0x04, 0x0c, 0x42, 0x42, 0x9f},
    {0x02, 0x82, 0xc6, 0xb5, 0x0f},
    {0x08, 0x60, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x42, 0x02, 0x9f},
    {0x01, 0x09, 0x44, 0x42, 0x8f},
    {0x02, 0x18, 0x42, 0x02, 0x9f},
    {0x05, 0x4b, 0x02, 0x02, 0x9f},
    {0x03, 0x0e, 0x44, 0x02, 0x8f},
    {0x04, 0x09, 0x44, 0x42, 0x8f},
    {0x02, 0x0e, 0x44, 0x02, 0x8f},
    {0x4f, 0x81, 0xb5, 0x40, 0x0e},
    {0x03, 0x1c, 0x42, 0x02, 0x9f},
    {0x01, 0x9a, 0xc1, 0xf5, 0x0e},
    {0x02, 0x1c, 0x42, 0x02, 0x9f},
    {0x06, 0x45, 0x04, 0x02, 0x8f},
    {0x03, 0x04, 0x47, 0x02, 0x6f},
    {0x04, 0x9a, 0xc1, 0xf5, 0x0e},
    {0x02, 0x04, 0x47, 0x02, 0x6f},
    {0x07, 0x43, 0x02, 0x42, 0x9f},
    {0x03, 0x02, 0x47, 0x02, 0x6f},
    {0x01, 0x06, 0x45, 0x42, 0x7f},
    {0x02, 0x02, 0x47, 0x02, 0x6f},
    {0x05, 0x45, 0x04, 0x02, 0x8f},
    {0x03, 0x07, 0x47, 0x02, 0x6f},
    {0x04, 0x06, 0x45, 0x42, 0x7f},
    {0x02, 0x07, 0x47, 0x02, 0x6f},
    {0xcd, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x42, 0x02, 0x9f},
    {0x01, 0x22, 0x44, 0xf5, 0xbe},
    {0x02, 0x17, 0x42, 0x02, 0x9f},
    {0x06, 0x5a, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0x84, 0x6f},
    {0x04, 0x22, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x84, 0x6f},
    {0x09, 0x48, 0x44, 0xb5, 0xbe},
    {0x03, 0x1b, 0x42, 0x02, 0x9f},
    {0x01, 0x82, 0xc4, 0xf5, 0x0f},
    {0x02, 0x1b, 0x42, 0x02, 0x9f},
    {0x05, 0x5a, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0x84, 0x6f},
    {0x04, 0x82, 0xc4, 0xf5, 0x0f},
    {0x02, 0x05, 0x43, 0x84, 0x6f},
    {0x0b, 0xc6, 0xf5, 0x40, 0x0f},
    {0x03, 0x28, 0x43, 0xb5, 0xac},
    {0x01, 0x32, 0x44, 0xf5, 0xbe},
    {0x02, 0x28, 0x43, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0x02, 0x9f},
    {0x03, 0x10, 0x44, 0x02, 0x8f},
    {0x04, 0x32, 0x44, 0xf5, 0xbe},
    {0x02, 0x10, 0x44, 0x02, 0x8f},
    {0x07, 0xdb, 0xb5, 0x40, 0x0e},
    {0x03, 0x8e, 0x42, 0xb5, 0xff},
    {0x01, 0x0e, 0x42, 0x42, 0x9f},
    {0x02, 0x8e, 0x42, 0xb5, 0xff},
    {0x05, 0x49, 0x02, 0x02, 0x9f},
    {0x03, 0x06, 0x43, 0x84, 0x6f},
    {0x04, 0x0e, 0x42, 0x42, 0x9f},
    {0x02, 0x06, 0x43, 0x84, 0x6f},
    {0x7e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0x02, 0x9f},
    {0x01, 0x3e, 0x44, 0xf5, 0xbe},
    {0x02, 0x13, 0x42, 0x02, 0x9f},
    {0x06, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x45, 0x02, 0x7f},
    {0x04, 0x3e, 0x44, 0xf5, 0xbe},
    {0x02, 0x08, 0x45, 0x02, 0x7f},
    {0x08, 0x48, 0x44, 0xb5, 0xbe},
    {0x03, 0x38, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0x42, 0x7f},
    {0x02, 0x38, 0x43, 0xb5, 0xac},
    {0x05, 0xcc, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc6, 0xb5, 0x0f},
    {0x04, 0x04, 0x45, 0x42, 0x7f},
    {0x02, 0x81, 0xc6, 0xb5, 0x0f},
    {0x0c, 0xc6, 0xf5, 0x40, 0x0f},
    {0x03, 0x0a, 0x45, 0x02, 0x7f},
    {0x01, 0x02, 0x45, 0x42, 0x7f},
    {0x02, 0x0a, 0x45, 0x02, 0x7f},
    {0x06, 0x46, 0x04, 0x02, 0x8f},
    {0x03, 0x04, 0x43, 0x84, 0x6f},
    {0x04, 0x02, 0x45, 0x42, 0x7f},
    {0x02, 0x04, 0x43, 0x84, 0x6f},
    {0x07, 0x45, 0x02, 0x42, 0x9f},
    {0x03, 0x02, 0x43, 0x84, 0x6f},
    {0x01, 0x07, 0x45, 0x42, 0x7f},
    {0x02, 0x02, 0x43, 0x84, 0x6f},
    {0x05, 0x46, 0x04, 0x02, 0x8f},
    {0x03, 0x07, 0x43, 0x84, 0x6f},
    {0x04, 0x07, 0x45, 0x42, 0x7f},
    {0x02, 0x07, 0x43, 0x84, 0x6f},
    {0xe3, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x43, 0xb5, 0xac},
    {0x01, 0x30, 0x44, 0xf5, 0xbe},
    {0x02, 0x2e, 0x43, 0xb5, 0xac},
    {0x06, 0x65, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x81, 0x6e},
    {0x04, 0x30, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x41, 0x81, 0x6e},
    {0x09, 0x7a, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x43, 0x81, 0x7e},
    {0x01, 0x03, 0x43, 0xc1, 0x7e},
    {0x02, 0x0b, 0x43, 0x81, 0x7e},
    {0x05, 0x65, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x81, 0x6e},
    {0x04, 0x03, 0x43, 0xc1, 0x7e},
    {0x02, 0x05, 0x41, 0x81, 0x6e},
    {0x0a, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x36, 0x43, 0xb5, 0xac},
    {0x01, 0x3c, 0x44, 0xf5, 0xbe},
    {0x02, 0x36, 0x43, 0xb5, 0xac},
    {0x06, 0xc2, 0x81, 0xb5, 0x0e},
    {0x03, 0x09, 0x43, 0x81, 0x7e},
    {0x04, 0x3c, 0x44, 0xf5, 0xbe},
    {0x02, 0x09, 0x43, 0x81, 0x7e},
    {0x07, 0x6c, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0xc1, 0x7e},
    {0x02, 0x88, 0x44, 0xb5, 0xee},
    {0x05, 0xc2, 0x81, 0xb5, 0x0e},
    {0x03, 0x06, 0x41, 0x81, 0x6e},
    {0x04, 0x05, 0x43, 0xc1, 0x7e},
    {0x02, 0x06, 0x41, 0x81, 0x6e},
    {0x6e, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x43, 0xb5, 0xac},
    {0x01, 0x2a, 0x44, 0xf5, 0xbe},
    {0x02, 0x24, 0x43, 0xb5, 0xac},
    {0x06, 0x59, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x44, 0x04, 0xbe},
    {0x04, 0x2a, 0x44, 0xf5, 0xbe},
    {0x02, 0x82, 0x44, 0x04, 0xbe},
    {0x08, 0x7a, 0xf5, 0x00, 0xee},
    {0x03, 0x34, 0x43, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0x42, 0x9f},
    {0x02, 0x34, 0x43, 0xb5, 0xac},
    {0x05, 0x59, 0x04, 0xb5, 0xbe},
    {0x03, 0x0f, 0x44, 0x02, 0x8f},
    {0x04, 0x10, 0x42, 0x42, 0x9f},
    {0x02, 0x0f, 0x44, 0x02, 0x8f},
    {0x66, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x43, 0xb5, 0xac},
    {0x01, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x43, 0xb5, 0xac},
    {0x06, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x81, 0x6e},
    {0x04, 0x91, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x81, 0x6e},
    {0x07, 0x51, 0x04, 0xf5, 0xbe},
    {0x03, 0x02, 0x41, 0x81, 0x6e},
    {0x01, 0x06, 0x43, 0xc1, 0x7e},
    {0x02, 0x02, 0x41, 0x81, 0x6e},
    {0x05, 0x4f, 0x03, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x81, 0x6e},
    {0x04, 0x06, 0x43, 0xc1, 0x7e},
    {0x02, 0x07, 0x41, 0x81, 0x6e},
    {0xc9, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x44, 0x02, 0x8f},
    {0x01, 0x20, 0x44, 0xf5, 0xbe},
    {0x02, 0x0d, 0x44, 0x02, 0x8f},
    {0x06, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x84, 0x6f},
    {0x04, 0x20, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x42, 0x84, 0x6f},
    {0x09, 0xc1, 0x42, 0xb5, 0xff},
    {0x03, 0x9b, 0x42, 0xb5, 0xff},
    {0x01, 0x08, 0x44, 0x42, 0x8f},
    {0x02, 0x9b, 0x42, 0xb5, 0xff},
    {0x05, 0xc5, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x84, 0x6f},
    {0x04, 0x08, 0x44, 0x42, 0x8f},
    {0x02, 0x05, 0x42, 0x84, 0x6f},
    {0x0b, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x2c, 0x43, 0xb5, 0xac},
    {0x01, 0x3a, 0x44, 0xf5, 0xbe},
    {0x02, 0x2c, 0x43, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0x02, 0x8f},
    {0x03, 0x11, 0x44, 0x02, 0x8f},
    {0x04, 0x3a, 0x44, 0xf5, 0xbe},
    {0x02, 0x11, 0x44, 0x02, 0x8f},
    {0x07, 0xd6, 0xb5, 0x40, 0x0e},
    {0x03, 0x96, 0x42, 0xb5, 0xff},
    {0x01, 0x81, 0xc4, 0xf5, 0x0f},
    {0x02, 0x96, 0x42, 0xb5, 0xff},
    {0x05, 0x44, 0x04, 0x02, 0x8f},
    {0x03, 0x06, 0x42, 0x84, 0x6f},
    {0x04, 0x81, 0xc4, 0xf5, 0x0f},
    {0x02, 0x06, 0x42, 0x84, 0x6f},
    {0x4e, 0x84, 0xb5, 0x00, 0x0f},
    {0x03, 0x01, 0x44, 0x02, 0x8f},
    {0x01, 0x0a, 0x44, 0x42, 0x8f},
    {0x02, 0x01, 0x44, 0x02, 0x8f},
    {0x06, 0x42, 0x04, 0x02, 0x8f},
    {0x03, 0x08, 0x43, 0x81, 0x7e},
    {0x04, 0x0a, 0x44, 0x42, 0x8f},
    {0x02, 0x08, 0x43, 0x81, 0x7e},
    {0x08, 0xc1, 0x42, 0xb5, 0xff},
    {0x03, 0x83, 0xc4, 0xb5, 0x0f},
    {0x01, 0x04, 0x43, 0xc1, 0x7e},
    {0x02, 0x83, 0xc4, 0xb5, 0x0f},
    {0x05, 0x42, 0x04, 0x02, 0x8f},
    {0x03, 0x81, 0x44, 0x04, 0xbe},
    {0x04, 0x04, 0x43, 0xc1, 0x7e},
    {0x02, 0x81, 0x44, 0x04, 0xbe},
    {0x0c, 0x44, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x43, 0x81, 0x7e},
    {0x01, 0x02, 0x43, 0xc1, 0x7e},
    {0x02, 0x0a, 0x43, 0x81, 0x7e},
    {0x06, 0x47, 0x04, 0x02, 0x8f},
    {0x03, 0x04, 0x42, 0x84, 0x6f},
    {0x04, 0x02, 0x43, 0xc1, 0x7e},
    {0x02, 0x04, 0x42, 0x84, 0x6f},
    {0x07, 0x46, 0x02, 0x42, 0x9f},
    {0x03, 0x02, 0x42, 0x84, 0x6f},
    {0x01, 0x07, 0x43, 0xc1, 0x7e},
    {0x02, 0x02, 0x42, 0x84, 0x6f},
    {0x05, 0x47, 0x04, 0x02, 0x8f},
    {0x03, 0x07, 0x42, 0x84, 0x6f},
    {0x04, 0x07, 0x43, 0xc1, 0x7e},
    {0x02, 0x07, 0x42, 0x84, 0x6f},
    {0xb4, 0x81, 0xb5, 0x00, 0x0e},
    {0x03, 0x1e, 0x43, 0xb5, 0xac},
    {0x01, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x1e, 0x43, 0xb5, 0xac},
    {0x06, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x04, 0x6e},
    {0x04, 0x16, 0x43, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x04, 0x6e},
    {0x09, 0x4a, 0x44, 0xb5, 0xbe},
    {0x03, 0x0b, 0x44, 0x04, 0x7e},
    {0x01, 0x03, 0x44, 0x44, 0x7e},
    {0x02, 0x0b, 0x44, 0x04, 0x7e},
    {0x05, 0x4d, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x04, 0x6e},
    {0x04, 0x03, 0x44, 0x44, 0x7e},
    {0x02, 0x05, 0x45, 0x04, 0x6e},
    {0x0a, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x0c, 0x42, 0x04, 0x8e},
    {0x01, 0x0b, 0x42, 0x44, 0x8e},
    {0x02, 0x0c, 0x42, 0x04, 0x8e},
    {0x06, 0x43, 0x02, 0x04, 0x8e},
    {0x03, 0x09, 0x44, 0x04, 0x7e},
    {0x04, 0x0b, 0x42, 0x44, 0x8e},
    {0x02, 0x09, 0x44, 0x04, 0x7e},
    {0x07, 0x41, 0x04, 0xf5, 0xbe},
    {0x03, 0x9a, 0x46, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0x44, 0x7e},
    {0x02, 0x9a, 0x46, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0x04, 0x8e},
    {0x03, 0x06, 0x45, 0x04, 0x6e},
    {0x04, 0x05, 0x44, 0x44, 0x7e},
    {0x02, 0x06, 0x45, 0x04, 0x6e},
    {0x4d, 0x06, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x43, 0xb5, 0xac},
    {0x01, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x22, 0x43, 0xb5, 0xac},
    {0x06, 0x52, 0x04, 0xb5, 0xbe},
    {0x03, 0x82, 0x42, 0x04, 0xbe},
    {0x04, 0x1a, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x04, 0xbe},
    {0x08, 0x4a, 0x44, 0xb5, 0xbe},
    {0x03, 0x32, 0x43, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x44, 0x8e},
    {0x02, 0x32, 0x43, 0xb5, 0xac},
    {0x05, 0x52, 0x04, 0xb5, 0xbe},
    {0x03, 0x0e, 0x42, 0x04, 0x8e},
    {0x04, 0x09, 0x42, 0x44, 0x8e},
    {0x02, 0x0e, 0x42, 0x04, 0x8e},
    {0x53, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x3e, 0x43, 0xb5, 0xac},
    {0x01, 0x8a, 0x42, 0xf5, 0xff},
    {0x02, 0x3e, 0x43, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x45, 0x04, 0x6e},
    {0x04, 0x8a, 0x42, 0xf5, 0xff},
    {0x02, 0x04, 0x45, 0x04, 0x6e},
    {0x07, 0x48, 0x03, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x04, 0x6e},
    {0x01, 0x06, 0x44, 0x44, 0x7e},
    {0x02, 0x02, 0x45, 0x04, 0x6e},
    {0x05, 0x45, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x45, 0x04, 0x6e},
    {0x04, 0x06, 0x44, 0x44, 0x7e},
    {0x02, 0x07, 0x45, 0x04, 0x6e},
    {0x58, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x30, 0x43, 0xb5, 0xac},
    {0x01, 0x26, 0x44, 0xf5, 0xbe},
    {0x02, 0x30, 0x43, 0xb5, 0xac},
    {0x06, 0x55, 0x04, 0xb5, 0xbe},
    {0x03, 0x03, 0x43, 0x06, 0x6c},
    {0x04, 0x26, 0x44, 0xf5, 0xbe},
    {0x02, 0x03, 0x43, 0x06, 0x6c},
    {0x09, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3c, 0x43, 0xb5, 0xac},
    {0x01, 0x82, 0x46, 0x42, 0xce},
    {0x02, 0x3c, 0x43, 0xb5, 0xac},
    {0x05, 0x55, 0x04, 0xb5, 0xbe},
    {0x03, 0x05, 0x43, 0x06, 0x6c},
    {0x04, 0x82, 0x46, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x06, 0x6c},
    {0x0b, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x2a, 0x43, 0xb5, 0xac},
    {0x01, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x2a, 0x43, 0xb5, 0xac},
    {0x06, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x04, 0x8e},
    {0x04, 0x19, 0x43, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x04, 0x8e},
    {0x07, 0xc3, 0x02, 0xf5, 0xff},
    {0x03, 0x92, 0x42, 0xb5, 0xff},
    {0x01, 0x0f, 0x42, 0x42, 0x9f},
    {0x02, 0x92, 0x42, 0xb5, 0xff},
    {0x05, 0x51, 0x03, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x06, 0x6c},
    {0x04, 0x0f, 0x42, 0x42, 0x9f},
    {0x02, 0x06, 0x43, 0x06, 0x6c},
    {0x56, 0x02, 0xf5, 0x40, 0xff},
    {0x03, 0x20, 0x43, 0xb5, 0xac},
    {0x01, 0x86, 0x42, 0xf5, 0xff},
    {0x02, 0x20, 0x43, 0xb5, 0xac},
    {0x06, 0xc4, 0x02, 0xb5, 0xff},
    {0x03, 0x08, 0x44, 0x04, 0x7e},
    {0x04, 0x86, 0x42, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x04, 0x7e},
    {0x08, 0x44, 0x43, 0xb5, 0xac},
    {0x03, 0x3a, 0x43, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x44, 0x7e},
    {0x02, 0x3a, 0x43, 0xb5, 0xac},
    {0x05, 0xc4, 0x02, 0xb5, 0xff},
    {0x03, 0x81, 0x42, 0x04, 0xbe},
    {0x04, 0x04, 0x44, 0x44, 0x7e},
    {0x02, 0x81, 0x42, 0x04, 0xbe},
    {0x0c, 0x42, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x44, 0x04, 0x7e},
    {0x01, 0x02, 0x44, 0x44, 0x7e},
    {0x02, 0x0a, 0x44, 0x04, 0x7e},
    {0x06, 0x46, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x43, 0x06, 0x6c},
    {0x04, 0x02, 0x44, 0x44, 0x7e},
    {0x02, 0x04, 0x43, 0x06, 0x6c},
    {0x07, 0xc1, 0x04, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x06, 0x6c},
    {0x01, 0x07, 0x44, 0x44, 0x7e},
    {0x02, 0x02, 0x43, 0x06, 0x6c},
    {0x05, 0x46, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x43, 0x06, 0x6c},
    {0x04, 0x07, 0x44, 0x44, 0x7e},
    {0x02, 0x07, 0x43, 0x06, 0x6c},
    {0xe7, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0x02, 0x9f},
    {0x01, 0x0d, 0x42, 0x42, 0x9f},
    {0x02, 0x16, 0x42, 0x02, 0x9f},
    {0x06, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x81, 0x6e},
    {0x04, 0x0d, 0x42, 0x42, 0x9f},
    {0x02, 0x03, 0x44, 0x81, 0x6e},
    {0x09, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x81, 0x7e},
    {0x01, 0x03, 0x42, 0xc1, 0x7e},
    {0x02, 0x0b, 0x42, 0x81, 0x7e},
    {0x05, 0x41, 0x03, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x81, 0x6e},
    {0x04, 0x03, 0x42, 0xc1, 0x7e},
    {0x02, 0x05, 0x44, 0x81, 0x6e},
    {0x0a, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x1a, 0x42, 0x02, 0x9f},
    {0x01, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0x02, 0x9f},
    {0x06, 0x48, 0x02, 0x02, 0x9f},
    {0x03, 0x09, 0x42, 0x81, 0x7e},
    {0x04, 0x12, 0x43, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x81, 0x7e},
    {0x07, 0x4a, 0x03, 0xf5, 0xac},
    {0x03, 0x8a, 0x44, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0xc1, 0x7e},
    {0x02, 0x8a, 0x44, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0x02, 0x9f},
    {0x03, 0x06, 0x44, 0x81, 0x6e},
    {0x04, 0x05, 0x42, 0xc1, 0x7e},
    {0x02, 0x06, 0x44, 0x81, 0x6e},
    {0x50, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x43, 0xb5, 0xac},
    {0x01, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x26, 0x43, 0xb5, 0xac},
    {0x06, 0xc3, 0x04, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x04, 0xbe},
    {0x04, 0x15, 0x43, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x04, 0xbe},
    {0x08, 0x42, 0x43, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0x02, 0x9f},
    {0x01, 0x11, 0x42, 0x42, 0x9f},
    {0x02, 0x19, 0x42, 0x02, 0x9f},
    {0x05, 0xc3, 0x04, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x04, 0x8e},
    {0x04, 0x11, 0x42, 0x42, 0x9f},
    {0x02, 0x0f, 0x42, 0x04, 0x8e},
    {0x40, 0x04, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x44, 0xb5, 0xee},
    {0x01, 0x84, 0x44, 0xf5, 0xee},
    {0x02, 0x86, 0x44, 0xb5, 0xee},
    {0x06, 0xc1, 0x81, 0xb5, 0x0e},
    {0x03, 0x04, 0x44, 0x81, 0x6e},
    {0x04, 0x84, 0x44, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x81, 0x6e},
    {0x07, 0x44, 0x02, 0x42, 0x9f},
    {0x03, 0x02, 0x44, 0x81, 0x6e},
    {0x01, 0x06, 0x42, 0xc1, 0x7e},
    {0x02, 0x02, 0x44, 0x81, 0x6e},
    {0x05, 0xc1, 0x81, 0xb5, 0x0e},
    {0x03, 0x07, 0x44, 0x81, 0x6e},
    {0x04, 0x06, 0x42, 0xc1, 0x7e},
    {0x02, 0x07, 0x44, 0x81, 0x6e},
    {0xc1, 0x43, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x04, 0x8e},
    {0x01, 0x01, 0x42, 0x42, 0x9f},
    {0x02, 0x0d, 0x42, 0x04, 0x8e},
    {0x06, 0x4a, 0x02, 0x02, 0x9f},
    {0x03, 0x03, 0x42, 0x06, 0x6c},
    {0x04, 0x01, 0x42, 0x42, 0x9f},
    {0x02, 0x03, 0x42, 0x06, 0x6c},
    {0x09, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0x02, 0x9f},
    {0x01, 0x08, 0x42, 0x44, 0x8e},
    {0x02, 0x12, 0x42, 0x02, 0x9f},
    {0x05, 0x4a, 0x02, 0x02, 0x9f},
    {0x03, 0x05, 0x42, 0x06, 0x6c},
    {0x04, 0x08, 0x42, 0x44, 0x8e},
    {0x02, 0x05, 0x42, 0x06, 0x6c},
    {0x0b, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x15, 0x42, 0x02, 0x9f},
    {0x01, 0x83, 0xc1, 0xf5, 0x0e},
    {0x02, 0x15, 0x42, 0x02, 0x9f},
    {0x06, 0x44, 0x02, 0x04, 0x8e},
    {0x03, 0x11, 0x42, 0x04, 0x8e},
    {0x04, 0x83, 0xc1, 0xf5, 0x0e},
    {0x02, 0x11, 0x42, 0x04, 0x8e},
    {0x07, 0x42, 0x02, 0x42, 0x9f},
    {0x03, 0x84, 0xc1, 0xb5, 0x0e},
    {0x01, 0x81, 0x46, 0x42, 0xce},
    {0x02, 0x84, 0xc1, 0xb5, 0x0e},
    {0x05, 0x44, 0x02, 0x04, 0x8e},
    {0x03, 0x06, 0x42, 0x06, 0x6c},
    {0x04, 0x81, 0x46, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x06, 0x6c},
    {0x4e, 0x06, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x04, 0x8e},
    {0x01, 0x0a, 0x42, 0x44, 0x8e},
    {0x02, 0x01, 0x42, 0x04, 0x8e},
    {0x06, 0x42, 0x02, 0x04, 0x8e},
    {0x03, 0x08, 0x42, 0x81, 0x7e},
    {0x04, 0x0a, 0x42, 0x44, 0x8e},
    {0x02, 0x08, 0x42, 0x81, 0x7e},
    {0x08, 0x47, 0x43, 0xb5, 0xac},
    {0x03, 0x83, 0x46, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0xc1, 0x7e},
    {0x02, 0x83, 0x46, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0x04, 0x8e},
    {0x03, 0x81, 0x47, 0x04, 0xbe},
    {0x04, 0x04, 0x42, 0xc1, 0x7e},
    {0x02, 0x81, 0x47, 0x04, 0xbe},
    {0x0c, 0x47, 0x44, 0xf5, 0xbe},
    {0x03, 0x0a, 0x42, 0x81, 0x7e},
    {0x01, 0x02, 0x42, 0xc1, 0x7e},
    {0x02, 0x0a, 0x42, 0x81, 0x7e},
    {0x06, 0x47, 0x02, 0x04, 0x8e},
    {0x03, 0x04, 0x42, 0x06, 0x6c},
    {0x04, 0x02, 0x42, 0xc1, 0x7e},
    {0x02, 0x04, 0x42, 0x06, 0x6c},
    {0x07, 0x47, 0x02, 0x42, 0x9f},
    {0x03, 0x02, 0x42, 0x06, 0x6c},
    {0x01, 0x07, 0x42, 0xc1, 0x7e},
    {0x02, 0x02, 0x42, 0x06, 0x6c},
    {0x05, 0x47, 0x02, 0x04, 0x8e},
    {0x03, 0x07, 0x42, 0x06, 0x6c},
    {0x04, 0x07, 0x42, 0xc1, 0x7e},
    {0x02, 0x07, 0x42, 0x06, 0x6c},
    {0xb4, 0xb5, 0x00, 0x00, 0x0c},
    {0x03, 0xb4, 0xf5, 0x00, 0x0c},
    {0x01, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0xb4, 0xf5, 0x00, 0x0c},
    {0x06, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x03, 0x4e, 0xb5, 0x6e},
    {0x04, 0xb4, 0xf5, 0x40, 0x0c},
    {0x02, 0x03, 0x4e, 0xb5, 0x6e},
    {0x09, 0x56, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x4c, 0xb5, 0x7e},
    {0x01, 0x03, 0x4c, 0xf5, 0x7e},
    {0x02, 0x0b, 0x4c, 0xb5, 0x7e},
    {0x05, 0xf5, 0x00, 0x00, 0x04},
    {0x03, 0x05, 0x4e, 0xb5, 0x6e},
    {0x04, 0x03, 0x4c, 0xf5, 0x7e},
    {0x02, 0x05, 0x4e, 0xb5, 0x6e},
    {0x0a, 0x4d, 0x42, 0xf5, 0xdf},
    {0x03, 0x0c, 0x47, 0xb5, 0x8d},
    {0x01, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x0c, 0x47, 0xb5, 0x8d},
    {0x06, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x09, 0x4c, 0xb5, 0x7e},
    {0x04, 0x0b, 0x47, 0xf5, 0x8d},
    {0x02, 0x09, 0x4c, 0xb5, 0x7e},
    {0x07, 0x5e, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x41, 0xb5, 0xee},
    {0x01, 0x05, 0x4c, 0xf5, 0x7e},
    {0x02, 0x9a, 0x41, 0xb5, 0xee},
    {0x05, 0x43, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0x4e, 0xb5, 0x6e},
    {0x04, 0x05, 0x4c, 0xf5, 0x7e},
    {0x02, 0x06, 0x4e, 0xb5, 0x6e},
    {0x4d, 0x01, 0xb5, 0x00, 0xee},
    {0x03, 0x14, 0x45, 0xb5, 0x9d},
    {0x01, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x14, 0x45, 0xb5, 0x9d},
    {0x06, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x82, 0x4d, 0x02, 0xdf},
    {0x04, 0x0c, 0x45, 0xf5, 0x9d},
    {0x02, 0x82, 0x4d, 0x02, 0xdf},
    {0x08, 0x56, 0x42, 0xb5, 0xdf},
    {0x03, 0x18, 0x45, 0xb5, 0x9d},
    {0x01, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x18, 0x45, 0xb5, 0x9d},
    {0x05, 0x4b, 0x05, 0xb5, 0x9d},
    {0x03, 0x0e, 0x47, 0xb5, 0x8d},
    {0x04, 0x09, 0x47, 0xf5, 0x8d},
    {0x02, 0x0e, 0x47, 0xb5, 0x8d},
    {0x4f, 0x0a, 0xb5, 0x40, 0xee},
    {0x03, 0x1c, 0x45, 0xb5, 0x9d},
    {0x01, 0x9a, 0x4a, 0xf5, 0xee},
    {0x02, 0x1c, 0x45, 0xb5, 0x9d},
    {0x06, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x4e, 0xb5, 0x6e},
    {0x04, 0x9a, 0x4a, 0xf5, 0xee},
    {0x02, 0x04, 0x4e, 0xb5, 0x6e},
    {0x07, 0x43, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x4e, 0xb5, 0x6e},
    {0x01, 0x06, 0x4c, 0xf5, 0x7e},
    {0x02, 0x02, 0x4e, 0xb5, 0x6e},
    {0x05, 0x45, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x4e, 0xb5, 0x6e},
    {0x04, 0x06, 0x4c, 0xf5, 0x7e},
    {0x02, 0x07, 0x4e, 0xb5, 0x6e},
    {0x52, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x45, 0xb5, 0x9d},
    {0x01, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x17, 0x45, 0xb5, 0x9d},
    {0x06, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x43, 0x01, 0x6e},
    {0x04, 0x14, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x43, 0x01, 0x6e},
    {0x09, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x1b, 0x45, 0xb5, 0x9d},
    {0x01, 0x82, 0x41, 0xf5, 0xee},
    {0x02, 0x1b, 0x45, 0xb5, 0x9d},
    {0x05, 0x4c, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x43, 0x01, 0x6e},
    {0x04, 0x82, 0x41, 0xf5, 0xee},
    {0x02, 0x05, 0x43, 0x01, 0x6e},
    {0x0b, 0x4d, 0x42, 0xf5, 0xdf},
    {0x03, 0x27, 0x44, 0xb5, 0xad},
    {0x01, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x27, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x10, 0x47, 0xb5, 0x8d},
    {0x04, 0x18, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x47, 0xb5, 0x8d},
    {0x07, 0x4b, 0x04, 0xf5, 0xad},
    {0x03, 0x89, 0x42, 0xb5, 0xee},
    {0x01, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x89, 0x42, 0xb5, 0xee},
    {0x05, 0x49, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x43, 0x01, 0x6e},
    {0x04, 0x0e, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x01, 0x6e},
    {0x51, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x45, 0xb5, 0x9d},
    {0x01, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x13, 0x45, 0xb5, 0x9d},
    {0x06, 0xda, 0x02, 0xb5, 0xee},
    {0x03, 0x08, 0x4c, 0xb5, 0x7e},
    {0x04, 0x1c, 0x44, 0xf5, 0xad},
    {0x02, 0x08, 0x4c, 0xb5, 0x7e},
    {0x08, 0x43, 0x44, 0xb5, 0xad},
    {0x03, 0x37, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x4c, 0xf5, 0x7e},
    {0x02, 0x37, 0x44, 0xb5, 0xad},
    {0x05, 0xda, 0x02, 0xb5, 0xee},
    {0x03, 0x81, 0x4d, 0x02, 0xdf},
    {0x04, 0x04, 0x4c, 0xf5, 0x7e},
    {0x02, 0x81, 0x4d, 0x02, 0xdf},
    {0x0c, 0x4d, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x4c, 0xb5, 0x7e},
    {0x01, 0x02, 0x4c, 0xf5, 0x7e},
    {0x02, 0x0a, 0x4c, 0xb5, 0x7e},
    {0x06, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x43, 0x01, 0x6e},
    {0x04, 0x02, 0x4c, 0xf5, 0x7e},
    {0x02, 0x04, 0x43, 0x01, 0x6e},
    {0x07, 0x45, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x43, 0x01, 0x6e},
    {0x01, 0x07, 0x4c, 0xf5, 0x7e},
    {0x02, 0x02, 0x43, 0x01, 0x6e},
    {0x05, 0x46, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x43, 0x01, 0x6e},
    {0x04, 0x07, 0x4c, 0xf5, 0x7e},
    {0x02, 0x07, 0x43, 0x01, 0x6e},
    {0xdc, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x2d, 0x44, 0xb5, 0xad},
    {0x01, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x2d, 0x44, 0xb5, 0xad},
    {0x06, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x41, 0x0a, 0x6e},
    {0x04, 0x17, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x41, 0x0a, 0x6e},
    {0x09, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x43, 0x0a, 0x7e},
    {0x01, 0x03, 0x43, 0x4a, 0x7e},
    {0x02, 0x0b, 0x43, 0x0a, 0x7e},
    {0x05, 0x54, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x41, 0x0a, 0x6e},
    {0x04, 0x03, 0x43, 0x4a, 0x7e},
    {0x02, 0x05, 0x41, 0x0a, 0x6e},
    {0x0a, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x35, 0x44, 0xb5, 0xad},
    {0x01, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x35, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0x0a, 0xb5, 0xee},
    {0x03, 0x09, 0x43, 0x0a, 0x7e},
    {0x04, 0x1b, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x43, 0x0a, 0x7e},
    {0x07, 0x4c, 0x02, 0xf5, 0xbd},
    {0x03, 0x87, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x4a, 0x7e},
    {0x02, 0x87, 0x42, 0xb5, 0xee},
    {0x05, 0xc2, 0x0a, 0xb5, 0xee},
    {0x03, 0x06, 0x41, 0x0a, 0x6e},
    {0x04, 0x05, 0x43, 0x4a, 0x7e},
    {0x02, 0x06, 0x41, 0x0a, 0x6e},
    {0x57, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x23, 0x44, 0xb5, 0xad},
    {0x01, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x44, 0xb5, 0xad},
    {0x06, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x43, 0x02, 0xbd},
    {0x04, 0x27, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x43, 0x02, 0xbd},
    {0x08, 0x4b, 0x42, 0xb5, 0xbd},
    {0x03, 0x33, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x33, 0x44, 0xb5, 0xad},
    {0x05, 0x58, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x47, 0xb5, 0x8d},
    {0x04, 0x10, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x47, 0xb5, 0x8d},
    {0x54, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x3f, 0x44, 0xb5, 0xad},
    {0x01, 0x89, 0x47, 0xf5, 0xff},
    {0x02, 0x3f, 0x44, 0xb5, 0xad},
    {0x06, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x0a, 0x6e},
    {0x04, 0x89, 0x47, 0xf5, 0xff},
    {0x02, 0x04, 0x41, 0x0a, 0x6e},
    {0x07, 0x49, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x41, 0x0a, 0x6e},
    {0x01, 0x06, 0x43, 0x4a, 0x7e},
    {0x02, 0x02, 0x41, 0x0a, 0x6e},
    {0x05, 0x4e, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x0a, 0x6e},
    {0x04, 0x06, 0x43, 0x4a, 0x7e},
    {0x02, 0x07, 0x41, 0x0a, 0x6e},
    {0x59, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x0d, 0x47, 0xb5, 0x8d},
    {0x01, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x0d, 0x47, 0xb5, 0x8d},
    {0x06, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x42, 0x01, 0x6e},
    {0x04, 0x13, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x42, 0x01, 0x6e},
    {0x09, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x97, 0x47, 0xb5, 0xff},
    {0x01, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x97, 0x47, 0xb5, 0xff},
    {0x05, 0x5c, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x42, 0x01, 0x6e},
    {0x04, 0x08, 0x47, 0xf5, 0x8d},
    {0x02, 0x05, 0x42, 0x01, 0x6e},
    {0x0b, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x2b, 0x44, 0xb5, 0xad},
    {0x01, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x11, 0x47, 0xb5, 0x8d},
    {0x04, 0x37, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x47, 0xb5, 0x8d},
    {0x07, 0xda, 0x07, 0xf5, 0xff},
    {0x03, 0x93, 0x47, 0xb5, 0xff},
    {0x01, 0x81, 0x41, 0xf5, 0xee},
    {0x02, 0x93, 0x47, 0xb5, 0xff},
    {0x05, 0x44, 0x07, 0xb5, 0x8d},
    {0x03, 0x06, 0x42, 0x01, 0x6e},
    {0x04, 0x81, 0x41, 0xf5, 0xee},
    {0x02, 0x06, 0x42, 0x01, 0x6e},
    {0x4e, 0x01, 0xb5, 0x00, 0xee},
    {0x03, 0x01, 0x47, 0xb5, 0x8d},
    {0x01, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x01, 0x47, 0xb5, 0x8d},
    {0x06, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x08, 0x43, 0x0a, 0x7e},
    {0x04, 0x0a, 0x47, 0xf5, 0x8d},
    {0x02, 0x08, 0x43, 0x0a, 0x7e},
    {0x08, 0x45, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0x41, 0xb5, 0xee},
    {0x01, 0x04, 0x43, 0x4a, 0x7e},
    {0x02, 0x83, 0x41, 0xb5, 0xee},
    {0x05, 0x42, 0x07, 0xb5, 0x8d},
    {0x03, 0x81, 0x43, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0x4a, 0x7e},
    {0x02, 0x81, 0x43, 0x02, 0xbd},
    {0x0c, 0x43, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x0a, 0x7e},
    {0x01, 0x02, 0x43, 0x4a, 0x7e},
    {0x02, 0x0a, 0x43, 0x0a, 0x7e},
    {0x06, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x04, 0x42, 0x01, 0x6e},
    {0x04, 0x02, 0x43, 0x4a, 0x7e},
    {0x02, 0x04, 0x42, 0x01, 0x6e},
    {0x07, 0x46, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x01, 0x6e},
    {0x01, 0x07, 0x43, 0x4a, 0x7e},
    {0x02, 0x02, 0x42, 0x01, 0x6e},
    {0x05, 0x47, 0x07, 0xb5, 0x8d},
    {0x03, 0x07, 0x42, 0x01, 0x6e},
    {0x04, 0x07, 0x43, 0x4a, 0x7e},
    {0x02, 0x07, 0x42, 0x01, 0x6e},
    {0xf4, 0x4a, 0xf5, 0x00, 0x0e},
    {0x03, 0x1d, 0x44, 0xb5, 0xad},
    {0x01, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x44, 0xb5, 0xad},
    {0x06, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x46, 0x02, 0x6e},
    {0x04, 0x2d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x02, 0x6e},
    {0x09, 0x5a, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x41, 0x02, 0x7e},
    {0x01, 0x03, 0x41, 0x42, 0x7e},
    {0x02, 0x0b, 0x41, 0x02, 0x7e},
    {0x05, 0x57, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x46, 0x02, 0x6e},
    {0x04, 0x03, 0x41, 0x42, 0x7e},
    {0x02, 0x05, 0x46, 0x02, 0x6e},
    {0x0a, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x43, 0x02, 0x8e},
    {0x01, 0x0b, 0x43, 0x42, 0x8e},
    {0x02, 0x0c, 0x43, 0x02, 0x8e},
    {0x06, 0x43, 0x03, 0x02, 0x8e},
    {0x03, 0x09, 0x41, 0x02, 0x7e},
    {0x04, 0x0b, 0x43, 0x42, 0x8e},
    {0x02, 0x09, 0x41, 0x02, 0x7e},
    {0x07, 0x62, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x48, 0x02, 0xdf},
    {0x01, 0x05, 0x41, 0x42, 0x7e},
    {0x02, 0x9a, 0x48, 0x02, 0xdf},
    {0x05, 0x43, 0x03, 0x02, 0x8e},
    {0x03, 0x06, 0x46, 0x02, 0x6e},
    {0x04, 0x05, 0x41, 0x42, 0x7e},
    {0x02, 0x06, 0x46, 0x02, 0x6e},
    {0x4d, 0x08, 0x02, 0xb5, 0xdf},
    {0x03, 0x21, 0x44, 0xb5, 0xad},
    {0x01, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x44, 0xb5, 0xad},
    {0x06, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x52, 0xb5, 0xee},
    {0x04, 0x35, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x52, 0xb5, 0xee},
    {0x08, 0x5a, 0x42, 0xb5, 0xdf},
    {0x03, 0x31, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x43, 0x42, 0x8e},
    {0x02, 0x31, 0x44, 0xb5, 0xad},
    {0x05, 0x5b, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x43, 0x02, 0x8e},
    {0x04, 0x09, 0x43, 0x42, 0x8e},
    {0x02, 0x0e, 0x43, 0x02, 0x8e},
    {0xc3, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x3d, 0x44, 0xb5, 0xad},
    {0x01, 0x87, 0x47, 0xf5, 0xff},
    {0x02, 0x3d, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x46, 0x02, 0x6e},
    {0x04, 0x87, 0x47, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x02, 0x6e},
    {0x07, 0xc2, 0x02, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x02, 0x6e},
    {0x01, 0x06, 0x41, 0x42, 0x7e},
    {0x02, 0x02, 0x46, 0x02, 0x6e},
    {0x05, 0x45, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x46, 0x02, 0x6e},
    {0x04, 0x06, 0x41, 0x42, 0x7e},
    {0x02, 0x07, 0x46, 0x02, 0x6e},
    {0xd5, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x2f, 0x44, 0xb5, 0xad},
    {0x01, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x44, 0xb5, 0xad},
    {0x06, 0x68, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x08, 0x6d},
    {0x04, 0x23, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x08, 0x6d},
    {0x09, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x3b, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0x48, 0x42, 0xdf},
    {0x02, 0x3b, 0x44, 0xb5, 0xad},
    {0x05, 0x68, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x08, 0x6d},
    {0x04, 0x82, 0x48, 0x42, 0xdf},
    {0x02, 0x05, 0x43, 0x08, 0x6d},
    {0x0b, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x29, 0x44, 0xb5, 0xad},
    {0x01, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x44, 0xb5, 0xad},
    {0x06, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x43, 0x02, 0x8e},
    {0x04, 0x33, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x02, 0x8e},
    {0x07, 0x72, 0x02, 0xf5, 0xdf},
    {0x03, 0x8f, 0x47, 0xb5, 0xff},
    {0x01, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x8f, 0x47, 0xb5, 0xff},
    {0x05, 0x50, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x08, 0x6d},
    {0x04, 0x0f, 0x45, 0xf5, 0x9d},
    {0x02, 0x06, 0x43, 0x08, 0x6d},
    {0x5f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x44, 0xb5, 0xad},
    {0x01, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x44, 0xb5, 0xad},
    {0x06, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x02, 0x7e},
    {0x04, 0x3f, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x02, 0x7e},
    {0x08, 0x49, 0x42, 0xb5, 0xbd},
    {0x03, 0x39, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x41, 0x42, 0x7e},
    {0x02, 0x39, 0x44, 0xb5, 0xad},
    {0x05, 0xce, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0x52, 0xb5, 0xee},
    {0x04, 0x04, 0x41, 0x42, 0x7e},
    {0x02, 0x81, 0x52, 0xb5, 0xee},
    {0x0c, 0x52, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x41, 0x02, 0x7e},
    {0x01, 0x02, 0x41, 0x42, 0x7e},
    {0x02, 0x0a, 0x41, 0x02, 0x7e},
    {0x06, 0x46, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x43, 0x08, 0x6d},
    {0x04, 0x02, 0x41, 0x42, 0x7e},
    {0x02, 0x04, 0x43, 0x08, 0x6d},
    {0x07, 0x4e, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x08, 0x6d},
    {0x01, 0x07, 0x41, 0x42, 0x7e},
    {0x02, 0x02, 0x43, 0x08, 0x6d},
    {0x05, 0x46, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x43, 0x08, 0x6d},
    {0x04, 0x07, 0x41, 0x42, 0x7e},
    {0x02, 0x07, 0x43, 0x08, 0x6d},
    {0xdd, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x45, 0xb5, 0x9d},
    {0x01, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x16, 0x45, 0xb5, 0x9d},
    {0x06, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x44, 0x0a, 0x6e},
    {0x04, 0x0d, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x44, 0x0a, 0x6e},
    {0x09, 0xca, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x42, 0x0a, 0x7e},
    {0x01, 0x03, 0x42, 0x4a, 0x7e},
    {0x02, 0x0b, 0x42, 0x0a, 0x7e},
    {0x05, 0x53, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x44, 0x0a, 0x6e},
    {0x04, 0x03, 0x42, 0x4a, 0x7e},
    {0x02, 0x05, 0x44, 0x0a, 0x6e},
    {0x0a, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x45, 0xb5, 0x9d},
    {0x01, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x45, 0xb5, 0x9d},
    {0x06, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x09, 0x42, 0x0a, 0x7e},
    {0x04, 0x98, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x0a, 0x7e},
    {0x07, 0x7e, 0x02, 0xf5, 0xdf},
    {0x03, 0x8b, 0x47, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x4a, 0x7e},
    {0x02, 0x8b, 0x47, 0xb5, 0xff},
    {0x05, 0x48, 0x05, 0xb5, 0x9d},
    {0x03, 0x06, 0x44, 0x0a, 0x6e},
    {0x04, 0x05, 0x42, 0x4a, 0x7e},
    {0x02, 0x06, 0x44, 0x0a, 0x6e},
    {0x7a, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x25, 0x44, 0xb5, 0xad},
    {0x01, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x44, 0xb5, 0xad},
    {0x06, 0x78, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x45, 0x02, 0xbd},
    {0x04, 0x2b, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x45, 0x02, 0xbd},
    {0x08, 0xca, 0xf5, 0x00, 0x0e},
    {0x03, 0x19, 0x45, 0xb5, 0x9d},
    {0x01, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x19, 0x45, 0xb5, 0x9d},
    {0x05, 0x78, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x02, 0x8e},
    {0x04, 0x11, 0x45, 0xf5, 0x9d},
    {0x02, 0x0f, 0x43, 0x02, 0x8e},
    {0x55, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x85, 0x42, 0xb5, 0xee},
    {0x01, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x42, 0xb5, 0xee},
    {0x06, 0xc1, 0x0a, 0xb5, 0xee},
    {0x03, 0x04, 0x44, 0x0a, 0x6e},
    {0x04, 0x94, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x0a, 0x6e},
    {0x07, 0x44, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x44, 0x0a, 0x6e},
    {0x01, 0x06, 0x42, 0x4a, 0x7e},
    {0x02, 0x02, 0x44, 0x0a, 0x6e},
    {0x05, 0xc1, 0x0a, 0xb5, 0xee},
    {0x03, 0x07, 0x44, 0x0a, 0x6e},
    {0x04, 0x06, 0x42, 0x4a, 0x7e},
    {0x02, 0x07, 0x44, 0x0a, 0x6e},
    {0xcf, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x02, 0x8e},
    {0x01, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x0d, 0x43, 0x02, 0x8e},
    {0x06, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x03, 0x42, 0x08, 0x6d},
    {0x04, 0x01, 0x45, 0xf5, 0x9d},
    {0x02, 0x03, 0x42, 0x08, 0x6d},
    {0x09, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x45, 0xb5, 0x9d},
    {0x01, 0x08, 0x43, 0x42, 0x8e},
    {0x02, 0x12, 0x45, 0xb5, 0x9d},
    {0x05, 0x4a, 0x05, 0xb5, 0x9d},
    {0x03, 0x05, 0x42, 0x08, 0x6d},
    {0x04, 0x08, 0x43, 0x42, 0x8e},
    {0x02, 0x05, 0x42, 0x08, 0x6d},
    {0x0b, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x45, 0xb5, 0x9d},
    {0x01, 0x83, 0x4a, 0xf5, 0xee},
    {0x02, 0x15, 0x45, 0xb5, 0x9d},
    {0x06, 0x44, 0x03, 0x02, 0x8e},
    {0x03, 0x11, 0x43, 0x02, 0x8e},
    {0x04, 0x83, 0x4a, 0xf5, 0xee},
    {0x02, 0x11, 0x43, 0x02, 0x8e},
    {0x07, 0x42, 0x05, 0xf5, 0x9d},
    {0x03, 0x84, 0x4a, 0xb5, 0xee},
    {0x01, 0x81, 0x48, 0x42, 0xdf},
    {0x02, 0x84, 0x4a, 0xb5, 0xee},
    {0x05, 0x44, 0x03, 0x02, 0x8e},
    {0x03, 0x06, 0x42, 0x08, 0x6d},
    {0x04, 0x81, 0x48, 0x42, 0xdf},
    {0x02, 0x06, 0x42, 0x08, 0x6d},
    {0x4e, 0x08, 0x02, 0xb5, 0xdf},
    {0x03, 0x01, 0x43, 0x02, 0x8e},
    {0x01, 0x0a, 0x43, 0x42, 0x8e},
    {0x02, 0x01, 0x43, 0x02, 0x8e},
    {0x06, 0x42, 0x03, 0x02, 0x8e},
    {0x03, 0x08, 0x42, 0x0a, 0x7e},
    {0x04, 0x0a, 0x43, 0x42, 0x8e},
    {0x02, 0x08, 0x42, 0x0a, 0x7e},
    {0x08, 0x46, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0x48, 0x02, 0xdf},
    {0x01, 0x04, 0x42, 0x4a, 0x7e},
    {0x02, 0x83, 0x48, 0x02, 0xdf},
    {0x05, 0x42, 0x03, 0x02, 0x8e},
    {0x03, 0x81, 0x45, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x4a, 0x7e},
    {0x02, 0x81, 0x45, 0x02, 0xbd},
    {0x0c, 0x45, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x0a, 0x7e},
    {0x01, 0x02, 0x42, 0x4a, 0x7e},
    {0x02, 0x0a, 0x42, 0x0a, 0x7e},
    {0x06, 0x47, 0x03, 0x02, 0x8e},
    {0x03, 0x04, 0x42, 0x08, 0x6d},
    {0x04, 0x02, 0x42, 0x4a, 0x7e},
    {0x02, 0x04, 0x42, 0x08, 0x6d},
    {0x07, 0x47, 0x05, 0xf5, 0x9d},
    {0x03, 0x02, 0x42, 0x08, 0x6d},
    {0x01, 0x07, 0x42, 0x4a, 0x7e},
    {0x02, 0x02, 0x42, 0x08, 0x6d},
    {0x05, 0x47, 0x03, 0x02, 0x8e},
    {0x03, 0x07, 0x42, 0x08, 0x6d},
    {0x04, 0x07, 0x42, 0x4a, 0x7e},
    {0x02, 0x07, 0x42, 0x08, 0x6d},
    {0xf4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0xa4, 0xf5, 0x00, 0x0e},
    {0x01, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0xa4, 0xf5, 0x00, 0x0e},
    {0x06, 0x6e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x48, 0xb5, 0x6c},
    {0x04, 0x1d, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x48, 0xb5, 0x6c},
    {0x09, 0x66, 0xf5, 0x00, 0xee},
    {0x03, 0x0b, 0x46, 0x07, 0x7f},
    {0x01, 0x03, 0x46, 0x47, 0x7f},
    {0x02, 0x0b, 0x46, 0x07, 0x7f},
    {0x05, 0x6e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x48, 0xb5, 0x6c},
    {0x04, 0x03, 0x46, 0x47, 0x7f},
    {0x02, 0x05, 0x48, 0xb5, 0x6c},
    {0x0a, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x0c, 0x41, 0x07, 0x8f},
    {0x01, 0x0b, 0x41, 0x47, 0x8f},
    {0x02, 0x0c, 0x41, 0x07, 0x8f},
    {0x06, 0x43, 0x01, 0x07, 0x8f},
    {0x03, 0x09, 0x46, 0x07, 0x7f},
    {0x04, 0x0b, 0x41, 0x47, 0x8f},
    {0x02, 0x09, 0x46, 0x07, 0x7f},
    {0x07, 0x70, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc3, 0xb5, 0x0e},
    {0x01, 0x05, 0x46, 0x47, 0x7f},
    {0x02, 0x9a, 0xc3, 0xb5, 0x0e},
    {0x05, 0x43, 0x01, 0x07, 0x8f},
    {0x03, 0x06, 0x48, 0xb5, 0x6c},
    {0x04, 0x05, 0x46, 0x47, 0x7f},
    {0x02, 0x06, 0x48, 0xb5, 0x6c},
    {0x4d, 0x83, 0xb5, 0x00, 0x0e},
    {0x03, 0x14, 0x43, 0x07, 0x9f},
    {0x01, 0x0c, 0x43, 0x47, 0x9f},
    {0x02, 0x14, 0x43, 0x07, 0x9f},
    {0x06, 0x4b, 0x03, 0x07, 0x9f},
    {0x03, 0x82, 0x55, 0xb5, 0xee},
    {0x04, 0x0c, 0x43, 0x47, 0x9f},
    {0x02, 0x82, 0x55, 0xb5, 0xee},
    {0x08, 0x66, 0xf5, 0x00, 0xee},
    {0x03, 0x18, 0x43, 0x07, 0x9f},
    {0x01, 0x09, 0x41, 0x47, 0x8f},
    {0x02, 0x18, 0x43, 0x07, 0x9f},
    {0x05, 0x4b, 0x03, 0x07, 0x9f},
    {0x03, 0x0e, 0x41, 0x07, 0x8f},
    {0x04, 0x09, 0x41, 0x47, 0x8f},
    {0x02, 0x0e, 0x41, 0x07, 0x8f},
    {0x4f, 0x04, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x43, 0x07, 0x9f},
    {0x01, 0x9a, 0x44, 0x42, 0xdf},
    {0x02, 0x1c, 0x43, 0x07, 0x9f},
    {0x06, 0x45, 0x01, 0x07, 0x8f},
    {0x03, 0x04, 0x48, 0xb5, 0x6c},
    {0x04, 0x9a, 0x44, 0x42, 0xdf},
    {0x02, 0x04, 0x48, 0xb5, 0x6c},
    {0x07, 0x43, 0x03, 0x47, 0x9f},
    {0x03, 0x02, 0x48, 0xb5, 0x6c},
    {0x01, 0x06, 0x46, 0x47, 0x7f},
    {0x02, 0x02, 0x48, 0xb5, 0x6c},
    {0x05, 0x45, 0x01, 0x07, 0x8f},
    {0x03, 0x07, 0x48, 0xb5, 0x6c},
    {0x04, 0x06, 0x46, 0x47, 0x7f},
    {0x02, 0x07, 0x48, 0xb5, 0x6c},
    {0xcb, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x17, 0x43, 0x07, 0x9f},
    {0x01, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x43, 0x07, 0x9f},
    {0x06, 0x76, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x83, 0x6e},
    {0x04, 0x21, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x83, 0x6e},
    {0x09, 0xc2, 0x47, 0xb5, 0xff},
    {0x03, 0x1b, 0x43, 0x07, 0x9f},
    {0x01, 0x82, 0xc3, 0xf5, 0x0e},
    {0x02, 0x1b, 0x43, 0x07, 0x9f},
    {0x05, 0x76, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x83, 0x6e},
    {0x04, 0x82, 0xc3, 0xf5, 0x0e},
    {0x02, 0x05, 0x43, 0x83, 0x6e},
    {0x0b, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x28, 0x44, 0xb5, 0xad},
    {0x01, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x44, 0xb5, 0xad},
    {0x06, 0x49, 0x03, 0x07, 0x9f},
    {0x03, 0x10, 0x41, 0x07, 0x8f},
    {0x04, 0x31, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x41, 0x07, 0x8f},
    {0x07, 0x7c, 0x02, 0xf5, 0xdf},
    {0x03, 0x8d, 0x47, 0xb5, 0xff},
    {0x01, 0x0e, 0x43, 0x47, 0x9f},
    {0x02, 0x8d, 0x47, 0xb5, 0xff},
    {0x05, 0x49, 0x03, 0x07, 0x9f},
    {0x03, 0x06, 0x43, 0x83, 0x6e},
    {0x04, 0x0e, 0x43, 0x47, 0x9f},
    {0x02, 0x06, 0x43, 0x83, 0x6e},
    {0x71, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x43, 0x07, 0x9f},
    {0x01, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x43, 0x07, 0x9f},
    {0x06, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x46, 0x07, 0x7f},
    {0x04, 0x3d, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x46, 0x07, 0x7f},
    {0x08, 0xc2, 0x47, 0xb5, 0xff},
    {0x03, 0x38, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x46, 0x47, 0x7f},
    {0x02, 0x38, 0x44, 0xb5, 0xad},
    {0x05, 0xc8, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x55, 0xb5, 0xee},
    {0x04, 0x04, 0x46, 0x47, 0x7f},
    {0x02, 0x81, 0x55, 0xb5, 0xee},
    {0x0c, 0x55, 0xf5, 0x40, 0xee},
    {0x03, 0x0a, 0x46, 0x07, 0x7f},
    {0x01, 0x02, 0x46, 0x47, 0x7f},
    {0x02, 0x0a, 0x46, 0x07, 0x7f},
    {0x06, 0x46, 0x01, 0x07, 0x8f},
    {0x03, 0x04, 0x43, 0x83, 0x6e},
    {0x04, 0x02, 0x46, 0x47, 0x7f},
    {0x02, 0x04, 0x43, 0x83, 0x6e},
    {0x07, 0x45, 0x03, 0x47, 0x9f},
    {0x03, 0x02, 0x43, 0x83, 0x6e},
    {0x01, 0x07, 0x46, 0x47, 0x7f},
    {0x02, 0x02, 0x43, 0x83, 0x6e},
    {0x05, 0x46, 0x01, 0x07, 0x8f},
    {0x03, 0x07, 0x43, 0x83, 0x6e},
    {0x04, 0x07, 0x46, 0x47, 0x7f},
    {0x02, 0x07, 0x43, 0x83, 0x6e},
    {0xe2, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x44, 0xb5, 0xad},
    {0x01, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x44, 0xb5, 0xad},
    {0x06, 0x64, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x04, 0x6d},
    {0x04, 0x2f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x04, 0x6d},
    {0x09, 0x59, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x04, 0x7d},
    {0x01, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x0b, 0x43, 0x04, 0x7d},
    {0x05, 0x64, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x04, 0x6d},
    {0x04, 0x03, 0x43, 0x44, 0x7d},
    {0x02, 0x05, 0x41, 0x04, 0x6d},
    {0x0a, 0x51, 0x42, 0xf5, 0xdf},
    {0x03, 0x36, 0x44, 0xb5, 0xad},
    {0x01, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x44, 0xb5, 0xad},
    {0x06, 0xc2, 0x04, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x04, 0x7d},
    {0x04, 0x3b, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x04, 0x7d},
    {0x07, 0x6a, 0x02, 0xf5, 0xdf},
    {0x03, 0x88, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x88, 0x42, 0xb5, 0xee},
    {0x05, 0xc2, 0x04, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x04, 0x6d},
    {0x04, 0x05, 0x43, 0x44, 0x7d},
    {0x02, 0x06, 0x41, 0x04, 0x6d},
    {0x6d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x44, 0xb5, 0xad},
    {0x01, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x44, 0xb5, 0xad},
    {0x06, 0x74, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x51, 0x02, 0xdf},
    {0x04, 0x29, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x51, 0x02, 0xdf},
    {0x08, 0x59, 0x42, 0xb5, 0xdf},
    {0x03, 0x34, 0x44, 0xb5, 0xad},
    {0x01, 0x10, 0x43, 0x47, 0x9f},
    {0x02, 0x34, 0x44, 0xb5, 0xad},
    {0x05, 0x74, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x41, 0x07, 0x8f},
    {0x04, 0x10, 0x43, 0x47, 0x9f},
    {0x02, 0x0f, 0x41, 0x07, 0x8f},
    {0x65, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x44, 0xb5, 0xad},
    {0x01, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x44, 0xb5, 0xad},
    {0x06, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x04, 0x41, 0x04, 0x6d},
    {0x04, 0x90, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x04, 0x6d},
    {0x07, 0x50, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x04, 0x6d},
    {0x01, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x41, 0x04, 0x6d},
    {0x05, 0x4f, 0x04, 0xb5, 0xad},
    {0x03, 0x07, 0x41, 0x04, 0x6d},
    {0x04, 0x06, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x41, 0x04, 0x6d},
    {0xc7, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x41, 0x07, 0x8f},
    {0x01, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x41, 0x07, 0x8f},
    {0x06, 0x40, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x83, 0x6e},
    {0x04, 0x1f, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x83, 0x6e},
    {0x09, 0x4f, 0x42, 0xb5, 0xce},
    {0x03, 0x99, 0x47, 0xb5, 0xff},
    {0x01, 0x08, 0x41, 0x47, 0x8f},
    {0x02, 0x99, 0x47, 0xb5, 0xff},
    {0x05, 0x40, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x83, 0x6e},
    {0x04, 0x08, 0x41, 0x47, 0x8f},
    {0x02, 0x05, 0x42, 0x83, 0x6e},
    {0x0b, 0x51, 0x42, 0xf5, 0xdf},
    {0x03, 0x2c, 0x44, 0xb5, 0xad},
    {0x01, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x44, 0xb5, 0xad},
    {0x06, 0x44, 0x01, 0x07, 0x8f},
    {0x03, 0x11, 0x41, 0x07, 0x8f},
    {0x04, 0x39, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x41, 0x07, 0x8f},
    {0x07, 0xd2, 0xb5, 0x40, 0x0e},
    {0x03, 0x95, 0x47, 0xb5, 0xff},
    {0x01, 0x81, 0xc3, 0xf5, 0x0e},
    {0x02, 0x95, 0x47, 0xb5, 0xff},
    {0x05, 0x44, 0x01, 0x07, 0x8f},
    {0x03, 0x06, 0x42, 0x83, 0x6e},
    {0x04, 0x81, 0xc3, 0xf5, 0x0e},
    {0x02, 0x06, 0x42, 0x83, 0x6e},
    {0x4e, 0x83, 0xb5, 0x00, 0x0e},
    {0x03, 0x01, 0x41, 0x07, 0x8f},
    {0x01, 0x0a, 0x41, 0x47, 0x8f},
    {0x02, 0x01, 0x41, 0x07, 0x8f},
    {0x06, 0x42, 0x01, 0x07, 0x8f},
    {0x03, 0x08, 0x43, 0x04, 0x7d},
    {0x04, 0x0a, 0x41, 0x47, 0x8f},
    {0x02, 0x08, 0x43, 0x04, 0x7d},
    {0x08, 0x4f, 0x42, 0xb5, 0xce},
    {0x03, 0x83, 0xc3, 0xb5, 0x0e},
    {0x01, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x83, 0xc3, 0xb5, 0x0e},
    {0x05, 0x42, 0x01, 0x07, 0x8f},
    {0x03, 0x81, 0x51, 0x02, 0xdf},
    {0x04, 0x04, 0x43, 0x44, 0x7d},
    {0x02, 0x81, 0x51, 0x02, 0xdf},
    {0x0c, 0x51, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x43, 0x04, 0x7d},
    {0x01, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x0a, 0x43, 0x04, 0x7d},
    {0x06, 0x47, 0x01, 0x07, 0x8f},
    {0x03, 0x04, 0x42, 0x83, 0x6e},
    {0x04, 0x02, 0x43, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0x83, 0x6e},
    {0x07, 0x46, 0x03, 0x47, 0x9f},
    {0x03, 0x02, 0x42, 0x83, 0x6e},
    {0x01, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0x83, 0x6e},
    {0x05, 0x47, 0x01, 0x07, 0x8f},
    {0x03, 0x07, 0x42, 0x83, 0x6e},
    {0x04, 0x07, 0x43, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0x83, 0x6e},
    {0xf4, 0x44, 0x02, 0xf5, 0xff},
    {0x03, 0x1e, 0x44, 0xb5, 0xad},
    {0x01, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x1e, 0x44, 0xb5, 0xad},
    {0x06, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x45, 0x02, 0x6e},
    {0x04, 0x16, 0x44, 0xf5, 0xad},
    {0x02, 0x03, 0x45, 0x02, 0x6e},
    {0x09, 0xc6, 0xf5, 0x00, 0x0e},
    {0x03, 0x0b, 0x44, 0x02, 0x7e},
    {0x01, 0x03, 0x44, 0x42, 0x7e},
    {0x02, 0x0b, 0x44, 0x02, 0x7e},
    {0x05, 0x4d, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x45, 0x02, 0x6e},
    {0x04, 0x03, 0x44, 0x42, 0x7e},
    {0x02, 0x05, 0x45, 0x02, 0x6e},
    {0x0a, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x0c, 0x42, 0x02, 0x8e},
    {0x01, 0x0b, 0x42, 0x42, 0x8e},
    {0x02, 0x0c, 0x42, 0x02, 0x8e},
    {0x06, 0x43, 0x02, 0x02, 0x8e},
    {0x03, 0x09, 0x44, 0x02, 0x7e},
    {0x04, 0x0b, 0x42, 0x42, 0x8e},
    {0x02, 0x09, 0x44, 0x02, 0x7e},
    {0x07, 0x60, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x01, 0x05, 0x44, 0x42, 0x7e},
    {0x02, 0x9a, 0xc1, 0xb5, 0x0d},
    {0x05, 0x43, 0x02, 0x02, 0x8e},
    {0x03, 0x06, 0x45, 0x02, 0x6e},
    {0x04, 0x05, 0x44, 0x42, 0x7e},
    {0x02, 0x06, 0x45, 0x02, 0x6e},
    {0x4d, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x22, 0x44, 0xb5, 0xad},
    {0x01, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x22, 0x44, 0xb5, 0xad},
    {0x06, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x82, 0xc4, 0xb5, 0x0e},
    {0x04, 0x1a, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0xc4, 0xb5, 0x0e},
    {0x08, 0xc6, 0xf5, 0x00, 0x0e},
    {0x03, 0x32, 0x44, 0xb5, 0xad},
    {0x01, 0x09, 0x42, 0x42, 0x8e},
    {0x02, 0x32, 0x44, 0xb5, 0xad},
    {0x05, 0xdb, 0xb5, 0x00, 0x0d},
    {0x03, 0x0e, 0x42, 0x02, 0x8e},
    {0x04, 0x09, 0x42, 0x42, 0x8e},
    {0x02, 0x0e, 0x42, 0x02, 0x8e},
    {0x5d, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3e, 0x44, 0xb5, 0xad},
    {0x01, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x3e, 0x44, 0xb5, 0xad},
    {0x06, 0x45, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x45, 0x02, 0x6e},
    {0x04, 0x8c, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x45, 0x02, 0x6e},
    {0x07, 0x48, 0x04, 0xf5, 0xad},
    {0x03, 0x02, 0x45, 0x02, 0x6e},
    {0x01, 0x06, 0x44, 0x42, 0x7e},
    {0x02, 0x02, 0x45, 0x02, 0x6e},
    {0x05, 0x45, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x45, 0x02, 0x6e},
    {0x04, 0x06, 0x44, 0x42, 0x7e},
    {0x02, 0x07, 0x45, 0x02, 0x6e},
    {0xd9, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x30, 0x44, 0xb5, 0xad},
    {0x01, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x44, 0xb5, 0xad},
    {0x06, 0x6c, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x81, 0x6d},
    {0x04, 0x25, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x81, 0x6d},
    {0x09, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3c, 0x44, 0xb5, 0xad},
    {0x01, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x3c, 0x44, 0xb5, 0xad},
    {0x05, 0x6c, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x81, 0x6d},
    {0x04, 0x82, 0xc1, 0xf5, 0x0d},
    {0x02, 0x05, 0x43, 0x81, 0x6d},
    {0x0b, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x2a, 0x44, 0xb5, 0xad},
    {0x01, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x2a, 0x44, 0xb5, 0xad},
    {0x06, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x10, 0x42, 0x02, 0x8e},
    {0x04, 0x19, 0x44, 0xf5, 0xad},
    {0x02, 0x10, 0x42, 0x02, 0x8e},
    {0x07, 0x7a, 0x02, 0xf5, 0xdf},
    {0x03, 0x91, 0x47, 0xb5, 0xff},
    {0x01, 0x0f, 0x43, 0x47, 0x9f},
    {0x02, 0x91, 0x47, 0xb5, 0xff},
    {0x05, 0x51, 0x04, 0xb5, 0xad},
    {0x03, 0x06, 0x43, 0x81, 0x6d},
    {0x04, 0x0f, 0x43, 0x47, 0x9f},
    {0x02, 0x06, 0x43, 0x81, 0x6d},
    {0x69, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x20, 0x44, 0xb5, 0xad},
    {0x01, 0x85, 0x47, 0xf5, 0xff},
    {0x02, 0x20, 0x44, 0xb5, 0xad},
    {0x06, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x44, 0x02, 0x7e},
    {0x04, 0x85, 0x47, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x02, 0x7e},
    {0x08, 0x44, 0x44, 0xb5, 0xad},
    {0x03, 0x3a, 0x44, 0xb5, 0xad},
    {0x01, 0x04, 0x44, 0x42, 0x7e},
    {0x02, 0x3a, 0x44, 0xb5, 0xad},
    {0x05, 0xd6, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc4, 0xb5, 0x0e},
    {0x04, 0x04, 0x44, 0x42, 0x7e},
    {0x02, 0x81, 0xc4, 0xb5, 0x0e},
    {0x0c, 0xc4, 0xf5, 0x40, 0x0e},
    {0x03, 0x0a, 0x44, 0x02, 0x7e},
    {0x01, 0x02, 0x44, 0x42, 0x7e},
    {0x02, 0x0a, 0x44, 0x02, 0x7e},
    {0x06, 0x46, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x43, 0x81, 0x6d},
    {0x04, 0x02, 0x44, 0x42, 0x7e},
    {0x02, 0x04, 0x43, 0x81, 0x6d},
    {0x07, 0xc1, 0x02, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x81, 0x6d},
    {0x01, 0x07, 0x44, 0x42, 0x7e},
    {0x02, 0x02, 0x43, 0x81, 0x6d},
    {0x05, 0x46, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x43, 0x81, 0x6d},
    {0x04, 0x07, 0x44, 0x42, 0x7e},
    {0x02, 0x07, 0x43, 0x81, 0x6d},
    {0xe6, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x43, 0x07, 0x9f},
    {0x01, 0x0d, 0x43, 0x47, 0x9f},
    {0x02, 0x16, 0x43, 0x07, 0x9f},
    {0x06, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x03, 0x44, 0x04, 0x6d},
    {0x04, 0x0d, 0x43, 0x47, 0x9f},
    {0x02, 0x03, 0x44, 0x04, 0x6d},
    {0x09, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x0b, 0x42, 0x04, 0x7d},
    {0x01, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x0b, 0x42, 0x04, 0x7d},
    {0x05, 0x41, 0x04, 0xb5, 0xad},
    {0x03, 0x05, 0x44, 0x04, 0x6d},
    {0x04, 0x03, 0x42, 0x44, 0x7d},
    {0x02, 0x05, 0x44, 0x04, 0x6d},
    {0x0a, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x43, 0x07, 0x9f},
    {0x01, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x1a, 0x43, 0x07, 0x9f},
    {0x06, 0x48, 0x03, 0x07, 0x9f},
    {0x03, 0x09, 0x42, 0x04, 0x7d},
    {0x04, 0x12, 0x44, 0xf5, 0xad},
    {0x02, 0x09, 0x42, 0x04, 0x7d},
    {0x07, 0x4a, 0x04, 0xf5, 0xad},
    {0x03, 0x8a, 0x42, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x8a, 0x42, 0xb5, 0xee},
    {0x05, 0x48, 0x03, 0x07, 0x9f},
    {0x03, 0x06, 0x44, 0x04, 0x6d},
    {0x04, 0x05, 0x42, 0x44, 0x7d},
    {0x02, 0x06, 0x44, 0x04, 0x6d},
    {0x50, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x44, 0xb5, 0xad},
    {0x01, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x26, 0x44, 0xb5, 0xad},
    {0x06, 0xc3, 0x02, 0xb5, 0xee},
    {0x03, 0x82, 0x46, 0x02, 0xbd},
    {0x04, 0x15, 0x44, 0xf5, 0xad},
    {0x02, 0x82, 0x46, 0x02, 0xbd},
    {0x08, 0x42, 0x44, 0xb5, 0xad},
    {0x03, 0x19, 0x43, 0x07, 0x9f},
    {0x01, 0x11, 0x43, 0x47, 0x9f},
    {0x02, 0x19, 0x43, 0x07, 0x9f},
    {0x05, 0xc3, 0x02, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x02, 0x8e},
    {0x04, 0x11, 0x43, 0x47, 0x9f},
    {0x02, 0x0f, 0x42, 0x02, 0x8e},
    {0x40, 0x02, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x42, 0xb5, 0xee},
    {0x01, 0x84, 0x42, 0xf5, 0xee},
    {0x02, 0x86, 0x42, 0xb5, 0xee},
    {0x06, 0xc1, 0x04, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x04, 0x6d},
    {0x04, 0x84, 0x42, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x04, 0x6d},
    {0x07, 0x44, 0x03, 0x47, 0x9f},
    {0x03, 0x02, 0x44, 0x04, 0x6d},
    {0x01, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x44, 0x04, 0x6d},
    {0x05, 0xc1, 0x04, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x04, 0x6d},
    {0x04, 0x06, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x44, 0x04, 0x6d},
    {0xc1, 0x44, 0xb5, 0x40, 0x0d},
    {0x03, 0x0d, 0x42, 0x02, 0x8e},
    {0x01, 0x01, 0x43, 0x47, 0x9f},
    {0x02, 0x0d, 0x42, 0x02, 0x8e},
    {0x06, 0x4a, 0x03, 0x07, 0x9f},
    {0x03, 0x03, 0x42, 0x81, 0x6d},
    {0x04, 0x01, 0x43, 0x47, 0x9f},
    {0x02, 0x03, 0x42, 0x81, 0x6d},
    {0x09, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x12, 0x43, 0x07, 0x9f},
    {0x01, 0x08, 0x42, 0x42, 0x8e},
    {0x02, 0x12, 0x43, 0x07, 0x9f},
    {0x05, 0x4a, 0x03, 0x07, 0x9f},
    {0x03, 0x05, 0x42, 0x81, 0x6d},
    {0x04, 0x08, 0x42, 0x42, 0x8e},
    {0x02, 0x05, 0x42, 0x81, 0x6d},
    {0x0b, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x43, 0x07, 0x9f},
    {0x01, 0x83, 0x44, 0x42, 0xdf},
    {0x02, 0x15, 0x43, 0x07, 0x9f},
    {0x06, 0x44, 0x02, 0x02, 0x8e},
    {0x03, 0x11, 0x42, 0x02, 0x8e},
    {0x04, 0x83, 0x44, 0x42, 0xdf},
    {0x02, 0x11, 0x42, 0x02, 0x8e},
    {0x07, 0x42, 0x03, 0x47, 0x9f},
    {0x03, 0x84, 0x44, 0x02, 0xdf},
    {0x01, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x84, 0x44, 0x02, 0xdf},
    {0x05, 0x44, 0x02, 0x02, 0x8e},
    {0x03, 0x06, 0x42, 0x81, 0x6d},
    {0x04, 0x81, 0xc1, 0xf5, 0x0d},
    {0x02, 0x06, 0x42, 0x81, 0x6d},
    {0x4e, 0x81, 0xb5, 0x00, 0x0d},
    {0x03, 0x01, 0x42, 0x02, 0x8e},
    {0x01, 0x0a, 0x42, 0x42, 0x8e},
    {0x02, 0x01, 0x42, 0x02, 0x8e},
    {0x06, 0x42, 0x02, 0x02, 0x8e},
    {0x03, 0x08, 0x42, 0x04, 0x7d},
    {0x04, 0x0a, 0x42, 0x42, 0x8e},
    {0x02, 0x08, 0x42, 0x04, 0x7d},
    {0x08, 0x47, 0x44, 0xb5, 0xad},
    {0x03, 0x83, 0xc1, 0xb5, 0x0d},
    {0x01, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x83, 0xc1, 0xb5, 0x0d},
    {0x05, 0x42, 0x02, 0x02, 0x8e},
    {0x03, 0x81, 0x46, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x44, 0x7d},
    {0x02, 0x81, 0x46, 0x02, 0xbd},
    {0x0c, 0x46, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x04, 0x7d},
    {0x01, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x0a, 0x42, 0x04, 0x7d},
    {0x06, 0x47, 0x02, 0x02, 0x8e},
    {0x03, 0x04, 0x42, 0x81, 0x6d},
    {0x04, 0x02, 0x42, 0x44, 0x7d},
    {0x02, 0x04, 0x42, 0x81, 0x6d},
    {0x07, 0x47, 0x03, 0x47, 0x9f},
    {0x03, 0x02, 0x42, 0x81, 0x6d},
    {0x01, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x02, 0x42, 0x81, 0x6d},
    {0x05, 0x47, 0x02, 0x02, 0x8e},
    {0x03, 0x07, 0x42, 0x81, 0x6d},
    {0x04, 0x07, 0x42, 0x44, 0x7d},
    {0x02, 0x07, 0x42, 0x81, 0x6d},
    {0xf4, 0x47, 0xf5, 0x40, 0x0f},
    {0x03, 0xb4, 0x47, 0xb5, 0xff},
    {0x01, 0xa8, 0xf5, 0x40, 0x0f},
    {0x02, 0xb4, 0x47, 0xb5, 0xff},
    {0x06, 0x5e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x4c, 0xb5, 0x6d},
    {0x04, 0xa8, 0xf5, 0x40, 0x0f},
    {0x02, 0x03, 0x4c, 0xb5, 0x6d},
    {0x09, 0x4d, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x47, 0xb5, 0x7c},
    {0x01, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x0b, 0x47, 0xb5, 0x7c},
    {0x05, 0x5e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x4c, 0xb5, 0x6d},
    {0x04, 0x03, 0x47, 0xf5, 0x7c},
    {0x02, 0x05, 0x4c, 0xb5, 0x6d},
    {0x0a, 0x41, 0x42, 0xf5, 0xdf},
    {0x03, 0x0c, 0x45, 0xb5, 0x8c},
    {0x01, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x0c, 0x45, 0xb5, 0x8c},
    {0x06, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x09, 0x47, 0xb5, 0x7c},
    {0x04, 0x0b, 0x45, 0xf5, 0x8c},
    {0x02, 0x09, 0x47, 0xb5, 0x7c},
    {0x07, 0x56, 0x02, 0xf5, 0xce},
    {0x03, 0x9a, 0x4a, 0x02, 0xdf},
    {0x01, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x9a, 0x4a, 0x02, 0xdf},
    {0x05, 0x43, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x4c, 0xb5, 0x6d},
    {0x04, 0x05, 0x47, 0xf5, 0x7c},
    {0x02, 0x06, 0x4c, 0xb5, 0x6d},
    {0x4d, 0x0a, 0x02, 0xb5, 0xdf},
    {0x03, 0x14, 0x44, 0xb5, 0x9c},
    {0x01, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x14, 0x44, 0xb5, 0x9c},
    {0x06, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x82, 0x41, 0x02, 0xdf},
    {0x04, 0x0c, 0x44, 0xf5, 0x9c},
    {0x02, 0x82, 0x41, 0x02, 0xdf},
    {0x08, 0x4d, 0x42, 0xb5, 0xce},
    {0x03, 0x18, 0x44, 0xb5, 0x9c},
    {0x01, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x18, 0x44, 0xb5, 0x9c},
    {0x05, 0x4b, 0x04, 0xb5, 0x9c},
    {0x03, 0x0e, 0x45, 0xb5, 0x8c},
    {0x04, 0x09, 0x45, 0xf5, 0x8c},
    {0x02, 0x0e, 0x45, 0xb5, 0x8c},
    {0x4f, 0x02, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x44, 0xb5, 0x9c},
    {0x01, 0x9a, 0x42, 0x42, 0xdf},
    {0x02, 0x1c, 0x44, 0xb5, 0x9c},
    {0x06, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x4c, 0xb5, 0x6d},
    {0x04, 0x9a, 0x42, 0x42, 0xdf},
    {0x02, 0x04, 0x4c, 0xb5, 0x6d},
    {0x07, 0x43, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x4c, 0xb5, 0x6d},
    {0x01, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x4c, 0xb5, 0x6d},
    {0x05, 0x45, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x4c, 0xb5, 0x6d},
    {0x04, 0x06, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x4c, 0xb5, 0x6d},
    {0x52, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x17, 0x44, 0xb5, 0x9c},
    {0x01, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x17, 0x44, 0xb5, 0x9c},
    {0x06, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x43, 0x0a, 0x6d},
    {0x04, 0x14, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x43, 0x0a, 0x6d},
    {0x09, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x1b, 0x44, 0xb5, 0x9c},
    {0x01, 0x82, 0x4a, 0x42, 0xdf},
    {0x02, 0x1b, 0x44, 0xb5, 0x9c},
    {0x05, 0x4c, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x43, 0x0a, 0x6d},
    {0x04, 0x82, 0x4a, 0x42, 0xdf},
    {0x02, 0x05, 0x43, 0x0a, 0x6d},
    {0x0b, 0x41, 0x42, 0xf5, 0xdf},
    {0x03, 0x27, 0x42, 0xb5, 0xac},
    {0x01, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x27, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x10, 0x45, 0xb5, 0x8c},
    {0x04, 0x18, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x45, 0xb5, 0x8c},
    {0x07, 0x4b, 0x02, 0xf5, 0xac},
    {0x03, 0x89, 0x47, 0xb5, 0xee},
    {0x01, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x89, 0x47, 0xb5, 0xee},
    {0x05, 0x49, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x43, 0x0a, 0x6d},
    {0x04, 0x0e, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x0a, 0x6d},
    {0x51, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x13, 0x44, 0xb5, 0x9c},
    {0x01, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x13, 0x44, 0xb5, 0x9c},
    {0x06, 0xda, 0x07, 0xb5, 0xee},
    {0x03, 0x08, 0x47, 0xb5, 0x7c},
    {0x04, 0x1c, 0x42, 0xf5, 0xac},
    {0x02, 0x08, 0x47, 0xb5, 0x7c},
    {0x08, 0x43, 0x42, 0xb5, 0xac},
    {0x03, 0x37, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x37, 0x42, 0xb5, 0xac},
    {0x05, 0xda, 0x07, 0xb5, 0xee},
    {0x03, 0x81, 0x41, 0x02, 0xdf},
    {0x04, 0x04, 0x47, 0xf5, 0x7c},
    {0x02, 0x81, 0x41, 0x02, 0xdf},
    {0x0c, 0x41, 0x42, 0xf5, 0xdf},
    {0x03, 0x0a, 0x47, 0xb5, 0x7c},
    {0x01, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x0a, 0x47, 0xb5, 0x7c},
    {0x06, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x43, 0x0a, 0x6d},
    {0x04, 0x02, 0x47, 0xf5, 0x7c},
    {0x02, 0x04, 0x43, 0x0a, 0x6d},
    {0x07, 0x45, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x43, 0x0a, 0x6d},
    {0x01, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x02, 0x43, 0x0a, 0x6d},
    {0x05, 0x46, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x43, 0x0a, 0x6d},
    {0x04, 0x07, 0x47, 0xf5, 0x7c},
    {0x02, 0x07, 0x43, 0x0a, 0x6d},
    {0xe0, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2d, 0x42, 0xb5, 0xac},
    {0x01, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x2d, 0x42, 0xb5, 0xac},
    {0x06, 0x62, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x02, 0x6d},
    {0x04, 0x17, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x41, 0x02, 0x6d},
    {0x09, 0x52, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x43, 0x02, 0x7d},
    {0x01, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x0b, 0x43, 0x02, 0x7d},
    {0x05, 0x62, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x02, 0x6d},
    {0x04, 0x03, 0x43, 0x42, 0x7d},
    {0x02, 0x05, 0x41, 0x02, 0x6d},
    {0x0a, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x35, 0x42, 0xb5, 0xac},
    {0x01, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x35, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x02, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x02, 0x7d},
    {0x04, 0x1b, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x43, 0x02, 0x7d},
    {0x07, 0x5a, 0x02, 0xf5, 0xce},
    {0x03, 0x87, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x87, 0x47, 0xb5, 0xee},
    {0x05, 0xc2, 0x02, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x02, 0x6d},
    {0x04, 0x05, 0x43, 0x42, 0x7d},
    {0x02, 0x06, 0x41, 0x02, 0x6d},
    {0x73, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x23, 0x42, 0xb5, 0xac},
    {0x01, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x23, 0x42, 0xb5, 0xac},
    {0x06, 0x72, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0x48, 0x02, 0xce},
    {0x04, 0x28, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x48, 0x02, 0xce},
    {0x08, 0x52, 0x42, 0xb5, 0xdf},
    {0x03, 0x33, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x33, 0x42, 0xb5, 0xac},
    {0x05, 0x72, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x45, 0xb5, 0x8c},
    {0x04, 0x10, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x45, 0xb5, 0x8c},
    {0x63, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3f, 0x42, 0xb5, 0xac},
    {0x01, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x3f, 0x42, 0xb5, 0xac},
    {0x06, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x02, 0x6d},
    {0x04, 0x8e, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x02, 0x6d},
    {0x07, 0x49, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x41, 0x02, 0x6d},
    {0x01, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x41, 0x02, 0x6d},
    {0x05, 0x4e, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x02, 0x6d},
    {0x04, 0x06, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x41, 0x02, 0x6d},
    {0xc5, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x0d, 0x45, 0xb5, 0x8c},
    {0x01, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x0d, 0x45, 0xb5, 0x8c},
    {0x06, 0x7e, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x42, 0x0a, 0x6d},
    {0x04, 0x13, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x42, 0x0a, 0x6d},
    {0x09, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x98, 0x47, 0xb5, 0xff},
    {0x01, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x98, 0x47, 0xb5, 0xff},
    {0x05, 0x7e, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x42, 0x0a, 0x6d},
    {0x04, 0x08, 0x45, 0xf5, 0x8c},
    {0x02, 0x05, 0x42, 0x0a, 0x6d},
    {0x0b, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x2b, 0x42, 0xb5, 0xac},
    {0x01, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x2b, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x11, 0x45, 0xb5, 0x8c},
    {0x04, 0x38, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x45, 0xb5, 0x8c},
    {0x07, 0xca, 0xb5, 0x40, 0x0d},
    {0x03, 0x94, 0x47, 0xb5, 0xff},
    {0x01, 0x81, 0x4a, 0x42, 0xdf},
    {0x02, 0x94, 0x47, 0xb5, 0xff},
    {0x05, 0x44, 0x05, 0xb5, 0x8c},
    {0x03, 0x06, 0x42, 0x0a, 0x6d},
    {0x04, 0x81, 0x4a, 0x42, 0xdf},
    {0x02, 0x06, 0x42, 0x0a, 0x6d},
    {0x4e, 0x0a, 0x02, 0xb5, 0xdf},
    {0x03, 0x01, 0x45, 0xb5, 0x8c},
    {0x01, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x01, 0x45, 0xb5, 0x8c},
    {0x06, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x08, 0x43, 0x02, 0x7d},
    {0x04, 0x0a, 0x45, 0xf5, 0x8c},
    {0x02, 0x08, 0x43, 0x02, 0x7d},
    {0x08, 0x45, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x4a, 0x02, 0xdf},
    {0x01, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x83, 0x4a, 0x02, 0xdf},
    {0x05, 0x42, 0x05, 0xb5, 0x8c},
    {0x03, 0x81, 0x48, 0x02, 0xce},
    {0x04, 0x04, 0x43, 0x42, 0x7d},
    {0x02, 0x81, 0x48, 0x02, 0xce},
    {0x0c, 0x48, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x43, 0x02, 0x7d},
    {0x01, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x0a, 0x43, 0x02, 0x7d},
    {0x06, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x04, 0x42, 0x0a, 0x6d},
    {0x04, 0x02, 0x43, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x0a, 0x6d},
    {0x07, 0x46, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x0a, 0x6d},
    {0x01, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x0a, 0x6d},
    {0x05, 0x47, 0x05, 0xb5, 0x8c},
    {0x03, 0x07, 0x42, 0x0a, 0x6d},
    {0x04, 0x07, 0x43, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x0a, 0x6d},
    {0xf4, 0x42, 0x02, 0xf5, 0xff},
    {0x03, 0x1d, 0x42, 0xb5, 0xac},
    {0x01, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x1d, 0x42, 0xb5, 0xac},
    {0x06, 0x70, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x46, 0x07, 0x6e},
    {0x04, 0x2e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x46, 0x07, 0x6e},
    {0x09, 0x55, 0x42, 0xb5, 0xdf},
    {0x03, 0x0b, 0x41, 0x07, 0x7e},
    {0x01, 0x03, 0x41, 0x47, 0x7e},
    {0x02, 0x0b, 0x41, 0x07, 0x7e},
    {0x05, 0x70, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x46, 0x07, 0x6e},
    {0x04, 0x03, 0x41, 0x47, 0x7e},
    {0x02, 0x05, 0x46, 0x07, 0x6e},
    {0x0a, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0c, 0x43, 0x07, 0x8e},
    {0x01, 0x0b, 0x43, 0x47, 0x8e},
    {0x02, 0x0c, 0x43, 0x07, 0x8e},
    {0x06, 0x43, 0x03, 0x07, 0x8e},
    {0x03, 0x09, 0x41, 0x07, 0x7e},
    {0x04, 0x0b, 0x43, 0x47, 0x8e},
    {0x02, 0x09, 0x41, 0x07, 0x7e},
    {0x07, 0x66, 0x02, 0xf5, 0xdf},
    {0x03, 0x9a, 0x44, 0x02, 0xce},
    {0x01, 0x05, 0x41, 0x47, 0x7e},
    {0x02, 0x9a, 0x44, 0x02, 0xce},
    {0x05, 0x43, 0x03, 0x07, 0x8e},
    {0x03, 0x06, 0x46, 0x07, 0x6e},
    {0x04, 0x05, 0x41, 0x47, 0x7e},
    {0x02, 0x06, 0x46, 0x07, 0x6e},
    {0x4d, 0x04, 0x02, 0xb5, 0xce},
    {0x03, 0x21, 0x42, 0xb5, 0xac},
    {0x01, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x21, 0x42, 0xb5, 0xac},
    {0x06, 0x7c, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc3, 0xb5, 0x0d},
    {0x04, 0x36, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc3, 0xb5, 0x0d},
    {0x08, 0x55, 0x42, 0xb5, 0xdf},
    {0x03, 0x31, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x43, 0x47, 0x8e},
    {0x02, 0x31, 0x42, 0xb5, 0xac},
    {0x05, 0x7c, 0x02, 0xb5, 0xce},
    {0x03, 0x0e, 0x43, 0x07, 0x8e},
    {0x04, 0x09, 0x43, 0x47, 0x8e},
    {0x02, 0x0e, 0x43, 0x07, 0x8e},
    {0x5b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x3d, 0x42, 0xb5, 0xac},
    {0x01, 0x88, 0x47, 0xf5, 0xff},
    {0x02, 0x3d, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x46, 0x07, 0x6e},
    {0x04, 0x88, 0x47, 0xf5, 0xff},
    {0x02, 0x04, 0x46, 0x07, 0x6e},
    {0x07, 0xc2, 0x07, 0xf5, 0xee},
    {0x03, 0x02, 0x46, 0x07, 0x6e},
    {0x01, 0x06, 0x41, 0x47, 0x7e},
    {0x02, 0x02, 0x46, 0x07, 0x6e},
    {0x05, 0x45, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x46, 0x07, 0x6e},
    {0x04, 0x06, 0x41, 0x47, 0x7e},
    {0x02, 0x07, 0x46, 0x07, 0x6e},
    {0x7b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x2f, 0x42, 0xb5, 0xac},
    {0x01, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x2f, 0x42, 0xb5, 0xac},
    {0x06, 0x6a, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x43, 0x04, 0x6c},
    {0x04, 0x24, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x04, 0x6c},
    {0x09, 0x51, 0x42, 0xb5, 0xce},
    {0x03, 0x3b, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x44, 0x42, 0xce},
    {0x02, 0x3b, 0x42, 0xb5, 0xac},
    {0x05, 0x6a, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x43, 0x04, 0x6c},
    {0x04, 0x82, 0x44, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x04, 0x6c},
    {0x0b, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x29, 0x42, 0xb5, 0xac},
    {0x01, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x29, 0x42, 0xb5, 0xac},
    {0x06, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x43, 0x07, 0x8e},
    {0x04, 0x34, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x43, 0x07, 0x8e},
    {0x07, 0x59, 0x02, 0xf5, 0xce},
    {0x03, 0x90, 0x47, 0xb5, 0xff},
    {0x01, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x90, 0x47, 0xb5, 0xff},
    {0x05, 0x50, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x04, 0x6c},
    {0x04, 0x0f, 0x44, 0xf5, 0x9c},
    {0x02, 0x06, 0x43, 0x04, 0x6c},
    {0x61, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x1f, 0x42, 0xb5, 0xac},
    {0x01, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x1f, 0x42, 0xb5, 0xac},
    {0x06, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x08, 0x41, 0x07, 0x7e},
    {0x04, 0x00, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x41, 0x07, 0x7e},
    {0x08, 0x51, 0x42, 0xb5, 0xce},
    {0x03, 0x39, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x41, 0x47, 0x7e},
    {0x02, 0x39, 0x42, 0xb5, 0xac},
    {0x05, 0xd2, 0xb5, 0x00, 0x0d},
    {0x03, 0x81, 0xc3, 0xb5, 0x0d},
    {0x04, 0x04, 0x41, 0x47, 0x7e},
    {0x02, 0x81, 0xc3, 0xb5, 0x0d},
    {0x0c, 0xc3, 0xf5, 0x40, 0x0d},
    {0x03, 0x0a, 0x41, 0x07, 0x7e},
    {0x01, 0x02, 0x41, 0x47, 0x7e},
    {0x02, 0x0a, 0x41, 0x07, 0x7e},
    {0x06, 0x46, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x43, 0x04, 0x6c},
    {0x04, 0x02, 0x41, 0x47, 0x7e},
    {0x02, 0x04, 0x43, 0x04, 0x6c},
    {0x07, 0x4f, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x43, 0x04, 0x6c},
    {0x01, 0x07, 0x41, 0x47, 0x7e},
    {0x02, 0x02, 0x43, 0x04, 0x6c},
    {0x05, 0x46, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x43, 0x04, 0x6c},
    {0x04, 0x07, 0x41, 0x47, 0x7e},
    {0x02, 0x07, 0x43, 0x04, 0x6c},
    {0xde, 0x42, 0xb5, 0x40, 0x0d},
    {0x03, 0x16, 0x44, 0xb5, 0x9c},
    {0x01, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x16, 0x44, 0xb5, 0x9c},
    {0x06, 0x60, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x44, 0x02, 0x6d},
    {0x04, 0x0d, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x44, 0x02, 0x6d},
    {0x09, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x0b, 0x42, 0x02, 0x7d},
    {0x01, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x0b, 0x42, 0x02, 0x7d},
    {0x05, 0x60, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x44, 0x02, 0x6d},
    {0x04, 0x03, 0x42, 0x42, 0x7d},
    {0x02, 0x05, 0x44, 0x02, 0x6d},
    {0x0a, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x1a, 0x44, 0xb5, 0x9c},
    {0x01, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x1a, 0x44, 0xb5, 0x9c},
    {0x06, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x09, 0x42, 0x02, 0x7d},
    {0x04, 0x9b, 0xf5, 0x40, 0x0c},
    {0x02, 0x09, 0x42, 0x02, 0x7d},
    {0x07, 0xc6, 0xb5, 0x40, 0x0d},
    {0x03, 0x8c, 0x47, 0xb5, 0xff},
    {0x01, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x8c, 0x47, 0xb5, 0xff},
    {0x05, 0x48, 0x04, 0xb5, 0x9c},
    {0x03, 0x06, 0x44, 0x02, 0x6d},
    {0x04, 0x05, 0x42, 0x42, 0x7d},
    {0x02, 0x06, 0x44, 0x02, 0x6d},
    {0xc4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x25, 0x42, 0xb5, 0xac},
    {0x01, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x25, 0x42, 0xb5, 0xac},
    {0x06, 0x7a, 0x02, 0xb5, 0xce},
    {0x03, 0x82, 0xc1, 0xb5, 0x0c},
    {0x04, 0x2c, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0xc1, 0xb5, 0x0c},
    {0x08, 0xc4, 0xf5, 0x00, 0x0d},
    {0x03, 0x19, 0x44, 0xb5, 0x9c},
    {0x01, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x19, 0x44, 0xb5, 0x9c},
    {0x05, 0x7a, 0x02, 0xb5, 0xce},
    {0x03, 0x0f, 0x43, 0x07, 0x8e},
    {0x04, 0x11, 0x44, 0xf5, 0x9c},
    {0x02, 0x0f, 0x43, 0x07, 0x8e},
    {0x6b, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x85, 0x47, 0xb5, 0xee},
    {0x01, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x85, 0x47, 0xb5, 0xee},
    {0x06, 0xc1, 0x02, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x02, 0x6d},
    {0x04, 0x96, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x44, 0x02, 0x6d},
    {0x07, 0x44, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x44, 0x02, 0x6d},
    {0x01, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x44, 0x02, 0x6d},
    {0x05, 0xc1, 0x02, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x02, 0x6d},
    {0x04, 0x06, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x44, 0x02, 0x6d},
    {0xd3, 0x42, 0xf5, 0x40, 0x0f},
    {0x03, 0x0d, 0x43, 0x07, 0x8e},
    {0x01, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x0d, 0x43, 0x07, 0x8e},
    {0x06, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x03, 0x42, 0x04, 0x6c},
    {0x04, 0x01, 0x44, 0xf5, 0x9c},
    {0x02, 0x03, 0x42, 0x04, 0x6c},
    {0x09, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x44, 0xb5, 0x9c},
    {0x01, 0x08, 0x43, 0x47, 0x8e},
    {0x02, 0x12, 0x44, 0xb5, 0x9c},
    {0x05, 0x4a, 0x04, 0xb5, 0x9c},
    {0x03, 0x05, 0x42, 0x04, 0x6c},
    {0x04, 0x08, 0x43, 0x47, 0x8e},
    {0x02, 0x05, 0x42, 0x04, 0x6c},
    {0x0b, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x15, 0x44, 0xb5, 0x9c},
    {0x01, 0x83, 0x42, 0x42, 0xdf},
    {0x02, 0x15, 0x44, 0xb5, 0x9c},
    {0x06, 0x44, 0x03, 0x07, 0x8e},
    {0x03, 0x11, 0x43, 0x07, 0x8e},
    {0x04, 0x83, 0x42, 0x42, 0xdf},
    {0x02, 0x11, 0x43, 0x07, 0x8e},
    {0x07, 0x42, 0x04, 0xf5, 0x9c},
    {0x03, 0x84, 0x42, 0x02, 0xdf},
    {0x01, 0x81, 0x44, 0x42, 0xce},
    {0x02, 0x84, 0x42, 0x02, 0xdf},
    {0x05, 0x44, 0x03, 0x07, 0x8e},
    {0x03, 0x06, 0x42, 0x04, 0x6c},
    {0x04, 0x81, 0x44, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x04, 0x6c},
    {0x4e, 0x04, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x43, 0x07, 0x8e},
    {0x01, 0x0a, 0x43, 0x47, 0x8e},
    {0x02, 0x01, 0x43, 0x07, 0x8e},
    {0x06, 0x42, 0x03, 0x07, 0x8e},
    {0x03, 0x08, 0x42, 0x02, 0x7d},
    {0x04, 0x0a, 0x43, 0x47, 0x8e},
    {0x02, 0x08, 0x42, 0x02, 0x7d},
    {0x08, 0x46, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x44, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x83, 0x44, 0x02, 0xce},
    {0x05, 0x42, 0x03, 0x07, 0x8e},
    {0x03, 0x81, 0xc1, 0xb5, 0x0c},
    {0x04, 0x04, 0x42, 0x42, 0x7d},
    {0x02, 0x81, 0xc1, 0xb5, 0x0c},
    {0x0c, 0xc1, 0xf5, 0x40, 0x0c},
    {0x03, 0x0a, 0x42, 0x02, 0x7d},
    {0x01, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x0a, 0x42, 0x02, 0x7d},
    {0x06, 0x47, 0x03, 0x07, 0x8e},
    {0x03, 0x04, 0x42, 0x04, 0x6c},
    {0x04, 0x02, 0x42, 0x42, 0x7d},
    {0x02, 0x04, 0x42, 0x04, 0x6c},
    {0x07, 0x47, 0x04, 0xf5, 0x9c},
    {0x03, 0x02, 0x42, 0x04, 0x6c},
    {0x01, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x02, 0x42, 0x04, 0x6c},
    {0x05, 0x47, 0x03, 0x07, 0x8e},
    {0x03, 0x07, 0x42, 0x04, 0x6c},
    {0x04, 0x07, 0x42, 0x42, 0x7d},
    {0x02, 0x07, 0x42, 0x04, 0x6c},
    {0xf4, 0x47, 0xf5, 0x00, 0x0e},
    {0x03, 0xa8, 0xf5, 0x00, 0x0e},
    {0x01, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0xa8, 0xf5, 0x00, 0x0e},
    {0x06, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x47, 0x07, 0x6f},
    {0x04, 0x1e, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x47, 0x07, 0x6f},
    {0x09, 0x41, 0x42, 0xb5, 0xce},
    {0x03, 0x0b, 0x45, 0x07, 0x7f},
    {0x01, 0x03, 0x45, 0x47, 0x7f},
    {0x02, 0x0b, 0x45, 0x07, 0x7f},
    {0x05, 0x56, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x47, 0x07, 0x6f},
    {0x04, 0x03, 0x45, 0x47, 0x7f},
    {0x02, 0x05, 0x47, 0x07, 0x6f},
    {0x0a, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x0c, 0x44, 0x07, 0x8f},
    {0x01, 0x0b, 0x44, 0x47, 0x8f},
    {0x02, 0x0c, 0x44, 0x07, 0x8f},
    {0x06, 0x43, 0x04, 0x07, 0x8f},
    {0x03, 0x09, 0x45, 0x07, 0x7f},
    {0x04, 0x0b, 0x44, 0x47, 0x8f},
    {0x02, 0x09, 0x45, 0x07, 0x7f},
    {0x07, 0x4d, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x42, 0x02, 0xce},
    {0x01, 0x05, 0x45, 0x47, 0x7f},
    {0x02, 0x9a, 0x42, 0x02, 0xce},
    {0x05, 0x43, 0x04, 0x07, 0x8f},
    {0x03, 0x06, 0x47, 0x07, 0x6f},
    {0x04, 0x05, 0x45, 0x47, 0x7f},
    {0x02, 0x06, 0x47, 0x07, 0x6f},
    {0x4d, 0x02, 0x02, 0xb5, 0xce},
    {0x03, 0x14, 0x42, 0x07, 0x9f},
    {0x01, 0x0c, 0x42, 0x47, 0x9f},
    {0x02, 0x14, 0x42, 0x07, 0x9f},
    {0x06, 0x4b, 0x02, 0x07, 0x9f},
    {0x03, 0x82, 0x4a, 0x02, 0xce},
    {0x04, 0x0c, 0x42, 0x47, 0x9f},
    {0x02, 0x82, 0x4a, 0x02, 0xce},
    {0x08, 0x41, 0x42, 0xb5, 0xce},
    {0x03, 0x18, 0x42, 0x07, 0x9f},
    {0x01, 0x09, 0x44, 0x47, 0x8f},
    {0x02, 0x18, 0x42, 0x07, 0x9f},
    {0x05, 0x4b, 0x02, 0x07, 0x9f},
    {0x03, 0x0e, 0x44, 0x07, 0x8f},
    {0x04, 0x09, 0x44, 0x47, 0x8f},
    {0x02, 0x0e, 0x44, 0x07, 0x8f},
    {0x4f, 0x07, 0x02, 0xf5, 0xdf},
    {0x03, 0x1c, 0x42, 0x07, 0x9f},
    {0x01, 0x9a, 0x47, 0x42, 0xdf},
    {0x02, 0x1c, 0x42, 0x07, 0x9f},
    {0x06, 0x45, 0x04, 0x07, 0x8f},
    {0x03, 0x04, 0x47, 0x07, 0x6f},
    {0x04, 0x9a, 0x47, 0x42, 0xdf},
    {0x02, 0x04, 0x47, 0x07, 0x6f},
    {0x07, 0x43, 0x02, 0x47, 0x9f},
    {0x03, 0x02, 0x47, 0x07, 0x6f},
    {0x01, 0x06, 0x45, 0x47, 0x7f},
    {0x02, 0x02, 0x47, 0x07, 0x6f},
    {0x05, 0x45, 0x04, 0x07, 0x8f},
    {0x03, 0x07, 0x47, 0x07, 0x6f},
    {0x04, 0x06, 0x45, 0x47, 0x7f},
    {0x02, 0x07, 0x47, 0x07, 0x6f},
    {0x77, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x17, 0x42, 0x07, 0x9f},
    {0x01, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x17, 0x42, 0x07, 0x9f},
    {0x06, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x02, 0x6c},
    {0x04, 0x22, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x02, 0x6c},
    {0x09, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x1b, 0x42, 0x07, 0x9f},
    {0x01, 0x82, 0x42, 0x42, 0xce},
    {0x02, 0x1b, 0x42, 0x07, 0x9f},
    {0x05, 0x5a, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x02, 0x6c},
    {0x04, 0x82, 0x42, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x02, 0x6c},
    {0x0b, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x28, 0x42, 0xb5, 0xac},
    {0x01, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x28, 0x42, 0xb5, 0xac},
    {0x06, 0x49, 0x02, 0x07, 0x9f},
    {0x03, 0x10, 0x44, 0x07, 0x8f},
    {0x04, 0x32, 0x42, 0xf5, 0xbd},
    {0x02, 0x10, 0x44, 0x07, 0x8f},
    {0x07, 0x52, 0x02, 0xf5, 0xce},
    {0x03, 0x8e, 0x47, 0xb5, 0xff},
    {0x01, 0x0e, 0x42, 0x47, 0x9f},
    {0x02, 0x8e, 0x47, 0xb5, 0xff},
    {0x05, 0x49, 0x02, 0x07, 0x9f},
    {0x03, 0x06, 0x43, 0x02, 0x6c},
    {0x04, 0x0e, 0x42, 0x47, 0x9f},
    {0x02, 0x06, 0x43, 0x02, 0x6c},
    {0x7f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x13, 0x42, 0x07, 0x9f},
    {0x01, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x13, 0x42, 0x07, 0x9f},
    {0x06, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x08, 0x45, 0x07, 0x7f},
    {0x04, 0x3e, 0x42, 0xf5, 0xbd},
    {0x02, 0x08, 0x45, 0x07, 0x7f},
    {0x08, 0x48, 0x42, 0xb5, 0xbd},
    {0x03, 0x38, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x45, 0x47, 0x7f},
    {0x02, 0x38, 0x42, 0xb5, 0xac},
    {0x05, 0xca, 0xb5, 0x00, 0x0c},
    {0x03, 0x81, 0x4a, 0x02, 0xce},
    {0x04, 0x04, 0x45, 0x47, 0x7f},
    {0x02, 0x81, 0x4a, 0x02, 0xce},
    {0x0c, 0x4a, 0x42, 0xf5, 0xce},
    {0x03, 0x0a, 0x45, 0x07, 0x7f},
    {0x01, 0x02, 0x45, 0x47, 0x7f},
    {0x02, 0x0a, 0x45, 0x07, 0x7f},
    {0x06, 0x46, 0x04, 0x07, 0x8f},
    {0x03, 0x04, 0x43, 0x02, 0x6c},
    {0x04, 0x02, 0x45, 0x47, 0x7f},
    {0x02, 0x04, 0x43, 0x02, 0x6c},
    {0x07, 0x45, 0x02, 0x47, 0x9f},
    {0x03, 0x02, 0x43, 0x02, 0x6c},
    {0x01, 0x07, 0x45, 0x47, 0x7f},
    {0x02, 0x02, 0x43, 0x02, 0x6c},
    {0x05, 0x46, 0x04, 0x07, 0x8f},
    {0x03, 0x07, 0x43, 0x02, 0x6c},
    {0x04, 0x07, 0x45, 0x47, 0x7f},
    {0x02, 0x07, 0x43, 0x02, 0x6c},
    {0xe4, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x2e, 0x42, 0xb5, 0xac},
    {0x01, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x2e, 0x42, 0xb5, 0xac},
    {0x06, 0x66, 0x02, 0xb5, 0xce},
    {0x03, 0x03, 0x41, 0x07, 0x6d},
    {0x04, 0x30, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x41, 0x07, 0x6d},
    {0x09, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x0b, 0x43, 0x07, 0x7d},
    {0x01, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x0b, 0x43, 0x07, 0x7d},
    {0x05, 0x66, 0x02, 0xb5, 0xce},
    {0x03, 0x05, 0x41, 0x07, 0x6d},
    {0x04, 0x03, 0x43, 0x47, 0x7d},
    {0x02, 0x05, 0x41, 0x07, 0x6d},
    {0x0a, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x36, 0x42, 0xb5, 0xac},
    {0x01, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x36, 0x42, 0xb5, 0xac},
    {0x06, 0xc2, 0x07, 0x02, 0xdf},
    {0x03, 0x09, 0x43, 0x07, 0x7d},
    {0x04, 0x3c, 0x42, 0xf5, 0xbd},
    {0x02, 0x09, 0x43, 0x07, 0x7d},
    {0x07, 0x55, 0x02, 0xf5, 0xce},
    {0x03, 0x88, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x88, 0x47, 0xb5, 0xee},
    {0x05, 0xc2, 0x07, 0x02, 0xdf},
    {0x03, 0x06, 0x41, 0x07, 0x6d},
    {0x04, 0x05, 0x43, 0x47, 0x7d},
    {0x02, 0x06, 0x41, 0x07, 0x6d},
    {0x6f, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x24, 0x42, 0xb5, 0xac},
    {0x01, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x24, 0x42, 0xb5, 0xac},
    {0x06, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x44, 0x02, 0xbd},
    {0x04, 0x2a, 0x42, 0xf5, 0xbd},
    {0x02, 0x82, 0x44, 0x02, 0xbd},
    {0x08, 0xc3, 0xf5, 0x00, 0x0c},
    {0x03, 0x34, 0x42, 0xb5, 0xac},
    {0x01, 0x10, 0x42, 0x47, 0x9f},
    {0x02, 0x34, 0x42, 0xb5, 0xac},
    {0x05, 0x59, 0x02, 0xb5, 0xbd},
    {0x03, 0x0f, 0x44, 0x07, 0x8f},
    {0x04, 0x10, 0x42, 0x47, 0x9f},
    {0x02, 0x0f, 0x44, 0x07, 0x8f},
    {0x67, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x00, 0x42, 0xb5, 0xac},
    {0x01, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x00, 0x42, 0xb5, 0xac},
    {0x06, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x04, 0x41, 0x07, 0x6d},
    {0x04, 0x92, 0xf5, 0x40, 0x0c},
    {0x02, 0x04, 0x41, 0x07, 0x6d},
    {0x07, 0x51, 0x02, 0xf5, 0xbd},
    {0x03, 0x02, 0x41, 0x07, 0x6d},
    {0x01, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x41, 0x07, 0x6d},
    {0x05, 0x4f, 0x02, 0xb5, 0xac},
    {0x03, 0x07, 0x41, 0x07, 0x6d},
    {0x04, 0x06, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x41, 0x07, 0x6d},
    {0x75, 0xf5, 0x00, 0x00, 0x0c},
    {0x03, 0x0d, 0x44, 0x07, 0x8f},
    {0x01, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x0d, 0x44, 0x07, 0x8f},
    {0x06, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x03, 0x42, 0x02, 0x6c},
    {0x04, 0x20, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x42, 0x02, 0x6c},
    {0x09, 0xc1, 0x47, 0xb5, 0xff},
    {0x03, 0x9b, 0x47, 0xb5, 0xff},
    {0x01, 0x08, 0x44, 0x47, 0x8f},
    {0x02, 0x9b, 0x47, 0xb5, 0xff},
    {0x05, 0xc6, 0xb5, 0x00, 0x0c},
    {0x03, 0x05, 0x42, 0x02, 0x6c},
    {0x04, 0x08, 0x44, 0x47, 0x8f},
    {0x02, 0x05, 0x42, 0x02, 0x6c},
    {0x0b, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x2c, 0x42, 0xb5, 0xac},
    {0x01, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x2c, 0x42, 0xb5, 0xac},
    {0x06, 0x44, 0x04, 0x07, 0x8f},
    {0x03, 0x11, 0x44, 0x07, 0x8f},
    {0x04, 0x3a, 0x42, 0xf5, 0xbd},
    {0x02, 0x11, 0x44, 0x07, 0x8f},
    {0x07, 0xc4, 0xb5, 0x40, 0x0c},
    {0x03, 0x96, 0x47, 0xb5, 0xff},
    {0x01, 0x81, 0x42, 0x42, 0xce},
    {0x02, 0x96, 0x47, 0xb5, 0xff},
    {0x05, 0x44, 0x04, 0x07, 0x8f},
    {0x03, 0x06, 0x42, 0x02, 0x6c},
    {0x04, 0x81, 0x42, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x02, 0x6c},
    {0x4e, 0x02, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x44, 0x07, 0x8f},
    {0x01, 0x0a, 0x44, 0x47, 0x8f},
    {0x02, 0x01, 0x44, 0x07, 0x8f},
    {0x06, 0x42, 0x04, 0x07, 0x8f},
    {0x03, 0x08, 0x43, 0x07, 0x7d},
    {0x04, 0x0a, 0x44, 0x47, 0x8f},
    {0x02, 0x08, 0x43, 0x07, 0x7d},
    {0x08, 0xc1, 0x47, 0xb5, 0xff},
    {0x03, 0x83, 0x42, 0x02, 0xce},
    {0x01, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x83, 0x42, 0x02, 0xce},
    {0x05, 0x42, 0x04, 0x07, 0x8f},
    {0x03, 0x81, 0x44, 0x02, 0xbd},
    {0x04, 0x04, 0x43, 0x47, 0x7d},
    {0x02, 0x81, 0x44, 0x02, 0xbd},
    {0x0c, 0x44, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x43, 0x07, 0x7d},
    {0x01, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x0a, 0x43, 0x07, 0x7d},
    {0x06, 0x47, 0x04, 0x07, 0x8f},
    {0x03, 0x04, 0x42, 0x02, 0x6c},
    {0x04, 0x02, 0x43, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x02, 0x6c},
    {0x07, 0x46, 0x02, 0x47, 0x9f},
    {0x03, 0x02, 0x42, 0x02, 0x6c},
    {0x01, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x02, 0x6c},
    {0x05, 0x47, 0x04, 0x07, 0x8f},
    {0x03, 0x07, 0x42, 0x02, 0x6c},
    {0x04, 0x07, 0x43, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x02, 0x6c},
    {0xf4, 0x47, 0x02, 0xf5, 0xff},
    {0x03, 0x1e, 0x42, 0xb5, 0xac},
    {0x01, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x1e, 0x42, 0xb5, 0xac},
    {0x06, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x45, 0x07, 0x6e},
    {0x04, 0x16, 0x42, 0xf5, 0xac},
    {0x02, 0x03, 0x45, 0x07, 0x6e},
    {0x09, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x0b, 0x44, 0x07, 0x7e},
    {0x01, 0x03, 0x44, 0x47, 0x7e},
    {0x02, 0x0b, 0x44, 0x07, 0x7e},
    {0x05, 0x4d, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x45, 0x07, 0x6e},
    {0x04, 0x03, 0x44, 0x47, 0x7e},
    {0x02, 0x05, 0x45, 0x07, 0x6e},
    {0x0a, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0c, 0x42, 0x07, 0x8e},
    {0x01, 0x0b, 0x42, 0x47, 0x8e},
    {0x02, 0x0c, 0x42, 0x07, 0x8e},
    {0x06, 0x43, 0x02, 0x07, 0x8e},
    {0x03, 0x09, 0x44, 0x07, 0x7e},
    {0x04, 0x0b, 0x42, 0x47, 0x8e},
    {0x02, 0x09, 0x44, 0x07, 0x7e},
    {0x07, 0x41, 0x02, 0xf5, 0xbd},
    {0x03, 0x9a, 0x47, 0x02, 0xce},
    {0x01, 0x05, 0x44, 0x47, 0x7e},
    {0x02, 0x9a, 0x47, 0x02, 0xce},
    {0x05, 0x43, 0x02, 0x07, 0x8e},
    {0x03, 0x06, 0x45, 0x07, 0x6e},
    {0x04, 0x05, 0x44, 0x47, 0x7e},
    {0x02, 0x06, 0x45, 0x07, 0x6e},
    {0x4d, 0x07, 0x02, 0xb5, 0xce},
    {0x03, 0x22, 0x42, 0xb5, 0xac},
    {0x01, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x22, 0x42, 0xb5, 0xac},
    {0x06, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x82, 0x42, 0x02, 0xbd},
    {0x04, 0x1a, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x42, 0x02, 0xbd},
    {0x08, 0x4a, 0x42, 0xb5, 0xbd},
    {0x03, 0x32, 0x42, 0xb5, 0xac},
    {0x01, 0x09, 0x42, 0x47, 0x8e},
    {0x02, 0x32, 0x42, 0xb5, 0xac},
    {0x05, 0x52, 0x02, 0xb5, 0xbd},
    {0x03, 0x0e, 0x42, 0x07, 0x8e},
    {0x04, 0x09, 0x42, 0x47, 0x8e},
    {0x02, 0x0e, 0x42, 0x07, 0x8e},
    {0x53, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x3e, 0x42, 0xb5, 0xac},
    {0x01, 0x8a, 0x47, 0xf5, 0xff},
    {0x02, 0x3e, 0x42, 0xb5, 0xac},
    {0x06, 0x45, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x45, 0x07, 0x6e},
    {0x04, 0x8a, 0x47, 0xf5, 0xff},
    {0x02, 0x04, 0x45, 0x07, 0x6e},
    {0x07, 0x48, 0x02, 0xf5, 0xac},
    {0x03, 0x02, 0x45, 0x07, 0x6e},
    {0x01, 0x06, 0x44, 0x47, 0x7e},
    {0x02, 0x02, 0x45, 0x07, 0x6e},
    {0x05, 0x45, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x45, 0x07, 0x6e},
    {0x04, 0x06, 0x44, 0x47, 0x7e},
    {0x02, 0x07, 0x45, 0x07, 0x6e},
    {0x58, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x30, 0x42, 0xb5, 0xac},
    {0x01, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x30, 0x42, 0xb5, 0xac},
    {0x06, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x03, 0x43, 0x07, 0x6c},
    {0x04, 0x26, 0x42, 0xf5, 0xbd},
    {0x02, 0x03, 0x43, 0x07, 0x6c},
    {0x09, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3c, 0x42, 0xb5, 0xac},
    {0x01, 0x82, 0x47, 0x42, 0xce},
    {0x02, 0x3c, 0x42, 0xb5, 0xac},
    {0x05, 0x55, 0x02, 0xb5, 0xbd},
    {0x03, 0x05, 0x43, 0x07, 0x6c},
    {0x04, 0x82, 0x47, 0x42, 0xce},
    {0x02, 0x05, 0x43, 0x07, 0x6c},
    {0x0b, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x2a, 0x42, 0xb5, 0xac},
    {0x01, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x2a, 0x42, 0xb5, 0xac},
    {0x06, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x10, 0x42, 0x07, 0x8e},
    {0x04, 0x19, 0x42, 0xf5, 0xac},
    {0x02, 0x10, 0x42, 0x07, 0x8e},
    {0x07, 0xc3, 0x07, 0xf5, 0xff},
    {0x03, 0x92, 0x47, 0xb5, 0xff},
    {0x01, 0x0f, 0x42, 0x47, 0x9f},
    {0x02, 0x92, 0x47, 0xb5, 0xff},
    {0x05, 0x51, 0x02, 0xb5, 0xac},
    {0x03, 0x06, 0x43, 0x07, 0x6c},
    {0x04, 0x0f, 0x42, 0x47, 0x9f},
    {0x02, 0x06, 0x43, 0x07, 0x6c},
    {0x56, 0x07, 0xf5, 0x40, 0xff},
    {0x03, 0x20, 0x42, 0xb5, 0xac},
    {0x01, 0x86, 0x47, 0xf5, 0xff},
    {0x02, 0x20, 0x42, 0xb5, 0xac},
    {0x06, 0xc4, 0x07, 0xb5, 0xff},
    {0x03, 0x08, 0x44, 0x07, 0x7e},
    {0x04, 0x86, 0x47, 0xf5, 0xff},
    {0x02, 0x08, 0x44, 0x07, 0x7e},
    {0x08, 0x44, 0x42, 0xb5, 0xac},
    {0x03, 0x3a, 0x42, 0xb5, 0xac},
    {0x01, 0x04, 0x44, 0x47, 0x7e},
    {0x02, 0x3a, 0x42, 0xb5, 0xac},
    {0x05, 0xc4, 0x07, 0xb5, 0xff},
    {0x03, 0x81, 0x42, 0x02, 0xbd},
    {0x04, 0x04, 0x44, 0x47, 0x7e},
    {0x02, 0x81, 0x42, 0x02, 0xbd},
    {0x0c, 0x42, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x44, 0x07, 0x7e},
    {0x01, 0x02, 0x44, 0x47, 0x7e},
    {0x02, 0x0a, 0x44, 0x07, 0x7e},
    {0x06, 0x46, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x43, 0x07, 0x6c},
    {0x04, 0x02, 0x44, 0x47, 0x7e},
    {0x02, 0x04, 0x43, 0x07, 0x6c},
    {0x07, 0xc1, 0x07, 0xf5, 0xee},
    {0x03, 0x02, 0x43, 0x07, 0x6c},
    {0x01, 0x07, 0x44, 0x47, 0x7e},
    {0x02, 0x02, 0x43, 0x07, 0x6c},
    {0x05, 0x46, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x43, 0x07, 0x6c},
    {0x04, 0x07, 0x44, 0x47, 0x7e},
    {0x02, 0x07, 0x43, 0x07, 0x6c},
    {0xe8, 0x42, 0xf5, 0x00, 0x0e},
    {0x03, 0x16, 0x42, 0x07, 0x9f},
    {0x01, 0x0d, 0x42, 0x47, 0x9f},
    {0x02, 0x16, 0x42, 0x07, 0x9f},
    {0x06, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x03, 0x44, 0x07, 0x6d},
    {0x04, 0x0d, 0x42, 0x47, 0x9f},
    {0x02, 0x03, 0x44, 0x07, 0x6d},
    {0x09, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x0b, 0x42, 0x07, 0x7d},
    {0x01, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x0b, 0x42, 0x07, 0x7d},
    {0x05, 0x41, 0x02, 0xb5, 0xac},
    {0x03, 0x05, 0x44, 0x07, 0x6d},
    {0x04, 0x03, 0x42, 0x47, 0x7d},
    {0x02, 0x05, 0x44, 0x07, 0x6d},
    {0x0a, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x1a, 0x42, 0x07, 0x9f},
    {0x01, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x1a, 0x42, 0x07, 0x9f},
    {0x06, 0x48, 0x02, 0x07, 0x9f},
    {0x03, 0x09, 0x42, 0x07, 0x7d},
    {0x04, 0x12, 0x42, 0xf5, 0xac},
    {0x02, 0x09, 0x42, 0x07, 0x7d},
    {0x07, 0x4a, 0x02, 0xf5, 0xac},
    {0x03, 0x8a, 0x47, 0xb5, 0xee},
    {0x01, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x8a, 0x47, 0xb5, 0xee},
    {0x05, 0x48, 0x02, 0x07, 0x9f},
    {0x03, 0x06, 0x44, 0x07, 0x6d},
    {0x04, 0x05, 0x42, 0x47, 0x7d},
    {0x02, 0x06, 0x44, 0x07, 0x6d},
    {0x50, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x26, 0x42, 0xb5, 0xac},
    {0x01, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x26, 0x42, 0xb5, 0xac},
    {0x06, 0xc3, 0x07, 0xb5, 0xee},
    {0x03, 0x82, 0x47, 0x02, 0xbd},
    {0x04, 0x15, 0x42, 0xf5, 0xac},
    {0x02, 0x82, 0x47, 0x02, 0xbd},
    {0x08, 0x42, 0x42, 0xb5, 0xac},
    {0x03, 0x19, 0x42, 0x07, 0x9f},
    {0x01, 0x11, 0x42, 0x47, 0x9f},
    {0x02, 0x19, 0x42, 0x07, 0x9f},
    {0x05, 0xc3, 0x07, 0xb5, 0xee},
    {0x03, 0x0f, 0x42, 0x07, 0x8e},
    {0x04, 0x11, 0x42, 0x47, 0x9f},
    {0x02, 0x0f, 0x42, 0x07, 0x8e},
    {0x40, 0x07, 0xf5, 0x00, 0xee},
    {0x03, 0x86, 0x47, 0xb5, 0xee},
    {0x01, 0x84, 0x47, 0xf5, 0xee},
    {0x02, 0x86, 0x47, 0xb5, 0xee},
    {0x06, 0xc1, 0x07, 0x02, 0xdf},
    {0x03, 0x04, 0x44, 0x07, 0x6d},
    {0x04, 0x84, 0x47, 0xf5, 0xee},
    {0x02, 0x04, 0x44, 0x07, 0x6d},
    {0x07, 0x44, 0x02, 0x47, 0x9f},
    {0x03, 0x02, 0x44, 0x07, 0x6d},
    {0x01, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x44, 0x07, 0x6d},
    {0x05, 0xc1, 0x07, 0x02, 0xdf},
    {0x03, 0x07, 0x44, 0x07, 0x6d},
    {0x04, 0x06, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x44, 0x07, 0x6d},
    {0xc1, 0x42, 0xb5, 0x00, 0x0c},
    {0x03, 0x0d, 0x42, 0x07, 0x8e},
    {0x01, 0x01, 0x42, 0x47, 0x9f},
    {0x02, 0x0d, 0x42, 0x07, 0x8e},
    {0x06, 0x4a, 0x02, 0x07, 0x9f},
    {0x03, 0x03, 0x42, 0x07, 0x6c},
    {0x04, 0x01, 0x42, 0x47, 0x9f},
    {0x02, 0x03, 0x42, 0x07, 0x6c},
    {0x09, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x12, 0x42, 0x07, 0x9f},
    {0x01, 0x08, 0x42, 0x47, 0x8e},
    {0x02, 0x12, 0x42, 0x07, 0x9f},
    {0x05, 0x4a, 0x02, 0x07, 0x9f},
    {0x03, 0x05, 0x42, 0x07, 0x6c},
    {0x04, 0x08, 0x42, 0x47, 0x8e},
    {0x02, 0x05, 0x42, 0x07, 0x6c},
    {0x0b, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x15, 0x42, 0x07, 0x9f},
    {0x01, 0x83, 0x47, 0x42, 0xdf},
    {0x02, 0x15, 0x42, 0x07, 0x9f},
    {0x06, 0x44, 0x02, 0x07, 0x8e},
    {0x03, 0x11, 0x42, 0x07, 0x8e},
    {0x04, 0x83, 0x47, 0x42, 0xdf},
    {0x02, 0x11, 0x42, 0x07, 0x8e},
    {0x07, 0x42, 0x02, 0x47, 0x9f},
    {0x03, 0x84, 0x47, 0x02, 0xdf},
    {0x01, 0x81, 0x47, 0x42, 0xce},
    {0x02, 0x84, 0x47, 0x02, 0xdf},
    {0x05, 0x44, 0x02, 0x07, 0x8e},
    {0x03, 0x06, 0x42, 0x07, 0x6c},
    {0x04, 0x81, 0x47, 0x42, 0xce},
    {0x02, 0x06, 0x42, 0x07, 0x6c},
    {0x4e, 0x07, 0x02, 0xb5, 0xce},
    {0x03, 0x01, 0x42, 0x07, 0x8e},
    {0x01, 0x0a, 0x42, 0x47, 0x8e},
    {0x02, 0x01, 0x42, 0x07, 0x8e},
    {0x06, 0x42, 0x02, 0x07, 0x8e},
    {0x03, 0x08, 0x42, 0x07, 0x7d},
    {0x04, 0x0a, 0x42, 0x47, 0x8e},
    {0x02, 0x08, 0x42, 0x07, 0x7d},
    {0x08, 0x47, 0x42, 0xb5, 0xac},
    {0x03, 0x83, 0x47, 0x02, 0xce},
    {0x01, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x83, 0x47, 0x02, 0xce},
    {0x05, 0x42, 0x02, 0x07, 0x8e},
    {0x03, 0x81, 0x47, 0x02, 0xbd},
    {0x04, 0x04, 0x42, 0x47, 0x7d},
    {0x02, 0x81, 0x47, 0x02, 0xbd},
    {0x0c, 0x47, 0x42, 0xf5, 0xbd},
    {0x03, 0x0a, 0x42, 0x07, 0x7d},
    {0x01, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x0a, 0x42, 0x07, 0x7d},
    {0x06, 0x47, 0x02, 0x07, 0x8e},
    {0x03, 0x04, 0x42, 0x07, 0x6c},
    {0x04, 0x02, 0x42, 0x47, 0x7d},
    {0x02, 0x04, 0x42, 0x07, 0x6c},
    {0x07, 0x47, 0x02, 0x47, 0x9f},
    {0x03, 0x02, 0x42, 0x07, 0x6c},
    {0x01, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x02, 0x42, 0x07, 0x6c},
    {0x05, 0x47, 0x02, 0x07, 0x8e},
    {0x03, 0x07, 0x42, 0x07, 0x6c},
    {0x04, 0x07, 0x42, 0x47, 0x7d},
    {0x02, 0x07, 0x42, 0x07, 0x6c}
};

CONST BYTE gc_AlignEolTable[32] = 
{   0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x17, 0x17, 0x17, 
    0x17, 0x17, 0x17, 0x17, 0x17, 0x1f, 0x1f, 0x1f,
    0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f
};

CONST PREF_BYTE gc_PrefTable[128] = 
{
    {0, 6}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {6,-2}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0},
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {7,-3}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0},
    {6, 2}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {0, 7}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0},
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {6,-2}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0},
    {7, 3}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}, 
    {6, 2}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0},
    {4, 5}, {1, 0}, {3,-1}, {1, 0}, {3, 4}, {1, 0}, {3, 1}, {1, 0}
};

#pragma data_seg()

#endif // _TIFF_TABLES_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\apiutil.cpp ===
#include <faxutil.h>


//*********************************************************************************
//*                         Personal Profile Functions
//*********************************************************************************

//*********************************************************************************
//* Name:   CopyPersonalProfile()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a new copy of a FAX_PERSONAL_PROFILEW structure.
//*     It duplicates all the strings.
//*
//* PARAMETERS:
//*     [IN]    PFAX_PERSONAL_PROFILE lpDstProfile
//*                 A pointer to destination personal profile structure.
//*
//*     [OUT]   LPCFAX_PERSONAL_PROFILE lpcSrcProfile.
//*                 A pointer to the source personal profile to copy.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed.
//*********************************************************************************
BOOL CopyPersonalProfile(
    PFAX_PERSONAL_PROFILE lpDstProfile,
    LPCFAX_PERSONAL_PROFILE lpcSrcProfile
    )
{
    STRING_PAIR pairs[] =
    {
        { lpcSrcProfile->lptstrName, &lpDstProfile->lptstrName},
        { lpcSrcProfile->lptstrFaxNumber, &lpDstProfile->lptstrFaxNumber},
        { lpcSrcProfile->lptstrCompany, &lpDstProfile->lptstrCompany},
        { lpcSrcProfile->lptstrStreetAddress, &lpDstProfile->lptstrStreetAddress},
        { lpcSrcProfile->lptstrCity, &lpDstProfile->lptstrCity},
        { lpcSrcProfile->lptstrState, &lpDstProfile->lptstrState},
        { lpcSrcProfile->lptstrZip, &lpDstProfile->lptstrZip},
        { lpcSrcProfile->lptstrCountry, &lpDstProfile->lptstrCountry},
        { lpcSrcProfile->lptstrTitle, &lpDstProfile->lptstrTitle},
        { lpcSrcProfile->lptstrDepartment, &lpDstProfile->lptstrDepartment},
        { lpcSrcProfile->lptstrOfficeLocation, &lpDstProfile->lptstrOfficeLocation},
        { lpcSrcProfile->lptstrHomePhone, &lpDstProfile->lptstrHomePhone},
        { lpcSrcProfile->lptstrOfficePhone, &lpDstProfile->lptstrOfficePhone},
        { lpcSrcProfile->lptstrEmail, &lpDstProfile->lptstrEmail},
        { lpcSrcProfile->lptstrBillingCode, &lpDstProfile->lptstrBillingCode},
        { lpcSrcProfile->lptstrTSID,    &lpDstProfile->lptstrTSID}
    };

    int nRes;


    DEBUG_FUNCTION_NAME(TEXT("CopyPersonalProfile"));
    Assert(lpDstProfile);
    Assert(lpcSrcProfile);

    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"),nRes-1);
        return FALSE;
    }

    lpDstProfile->dwSizeOfStruct=lpcSrcProfile->dwSizeOfStruct;
    return TRUE;
}


//*********************************************************************************
//* Name:   FreePersonalProfile()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the contents of a FAX_PERSONAL_PROFILEW structure.
//*     Deallocates the strucutre itself if required.
//* PARAMETERS:
//*     [IN]    PFAX_PERSONAL_PROFILE  lpProfile
//*                 The structure whose content is to be freed.
//*
//*     [IN]    BOOL bDestroy
//*                 If this parameter is TRUE the function will
//*                 deallocate the structure itself.
//*
//* RETURN VALUE:
//*     VOID
//*********************************************************************************
void FreePersonalProfile (
    PFAX_PERSONAL_PROFILE  lpProfile,
    BOOL bDestroy
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FreePersonalProfile"));
    Assert(lpProfile);

    MemFree(lpProfile->lptstrName);
    MemFree(lpProfile->lptstrFaxNumber);
    MemFree(lpProfile->lptstrCompany);
    MemFree(lpProfile->lptstrStreetAddress);
    MemFree(lpProfile->lptstrCity);
    MemFree(lpProfile->lptstrState);
    MemFree(lpProfile->lptstrZip);
    MemFree(lpProfile->lptstrCountry);
    MemFree(lpProfile->lptstrTitle);
    MemFree(lpProfile->lptstrDepartment);
    MemFree(lpProfile->lptstrOfficeLocation);
    MemFree(lpProfile->lptstrHomePhone);
    MemFree(lpProfile->lptstrOfficePhone);
    MemFree(lpProfile->lptstrEmail);
    MemFree(lpProfile->lptstrBillingCode);
    MemFree(lpProfile->lptstrTSID);
    if (bDestroy) {
        MemFree(lpProfile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\mapmsassocmethods.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MapMSAssocMethods.cpp

Abstract:

    This module contains all the code to map to and from the COM associated routing methods
    and the Microsoft routing extension masks configuration

Author:

    Eran Yariv (EranY)  June-1999

Revision History:

--*/

#include "fxsapip.h"
#include "faxutil.h"
#pragma hdrstop
#define ATLASSERT   Assert
#define ASSERT      Assert
#include <smartptr.h>
#include <atlbase.h>
#include "DSInterface.h"
#include <FaxReg.h>


HRESULT 
GetMicrosoftFaxRoutingProperties ( 
    IFaxAssociatedRoutingMethods *pRoutMethods,
    LPWSTR     *pPrinter,
    LPWSTR     *pDir,
    LPWSTR     *pProfile)
/*++

Routine name : GetMicrosoftFaxRoutingProperties

Routine description:

	Scans the collection of the Fax device associated routing methods
    and looks for Microsoft routing methods.
    For each MS routing method found, updates the proper configuration
    string (printer, dir, or profile) accordingly.

    Configuration strings for non-found MS methods are set to NULL.

Author:

	Eran Yariv (EranY),	Jun, 1999

Arguments:

	*pRoutMethods			[in]  - Collection of routing methods
	*pPrinter			    [out] - Configuration for print method or NULL if no such method
	*pDir			        [out] - Configuration for store method or NULL if no such method
	*pProfile			    [out] - Configuration for inbox method or NULL if no such method

Return Value:

    HRESULT

--*/
{
	DEBUG_FUNCTION_NAME(TEXT("GetMicrosoftFaxRoutingProperties()"));

    Assert (pRoutMethods);
    Assert (pPrinter);
    Assert (pDir);
    Assert (pProfile);

    *pPrinter = NULL;
    *pDir = NULL;
    *pProfile = NULL;
    long lCount;
    //
    // Get size of collection
    //
    HRESULT hr = pRoutMethods->get_Count (&lCount);
    if (FAILED(hr))
    {
        DebugPrintEx (DEBUG_ERR, L"Can't get collection size (ec: %08x)", hr);  
        return hr;
    }
    //
    // Iterate list
    //
    for (long l = 1; l <= lCount; l++)
    {
        //
        // Get single IFaxAssociatedRoutingMethod
        //
        VARIANT vIndex;
        AR<IFaxAssociatedRoutingMethod> pIAssocMethod;
        //
        // Get next item
        //
        vIndex.lVal = l;
        vIndex.vt = VT_I4;
        hr = pRoutMethods->Item (vIndex, &pIAssocMethod);
        if (FAILED (hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't get IFaxAssociatedRoutingMethod (ec: %08x)", hr);  
            return hr;
        }
       //
        // Get GUID of this method
        //
        CComBSTR bstr;

        hr = pIAssocMethod->get_MethodGUID (&bstr);
        if (FAILED(hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't get IFaxAssociatedRoutingMethod GUID (ec: %08x)", hr);  
            return hr;
        }
        LPWSTR *pMethodInfo = NULL;
        if (!lstrcmp (bstr, REGVAL_RM_PRINTING_GUID))
        {
            //
            // It's a Microsoft extension print guid
            //
            pMethodInfo = pPrinter;
        }
        else if (!lstrcmp (bstr, REGVAL_RM_FOLDER_GUID))
        {
            //
            // It's a Microsoft extension store guid
            //
            pMethodInfo = pDir;
        }
        else if (!lstrcmp (bstr, REGVAL_RM_INBOX_GUID))
        {
            //
            // It's a Microsoft extension profile guid
            //
            pMethodInfo = pProfile;
        }
        if (NULL != pMethodInfo)
        {
            //
            // A known method was found - store the information
            //
            hr = pIAssocMethod->get_ConfigurationDescription(&bstr);
            if (FAILED(hr))
            {
                DebugPrintEx (DEBUG_ERR, L"Can't get method configuration (ec: %08x)", hr);  
                return hr;
            }
            *pMethodInfo = StringDup (bstr);
        }
    }   // End of methods loop
    return NOERROR;
}   // GetMicrosoftFaxRoutingProperties

HRESULT 
SetMicrosoftFaxRoutingProperties ( 
    IFaxAssociatedRoutingMethods *pIAssocMethods,
    DWORD        dwMask,
    LPCWSTR      wszPrinter,
    LPCWSTR      wszDir,
    LPCWSTR      wszProfile
)
/*++

Routine name : SetMicrosoftFaxRoutingProperties

Routine description:

	Updates the collection of a fax device associated routing methods.
    Accepts a mask specifying which of the MS routing methods are active.
    Scans the collection and removes non-active MS routing methods,
    updates active MS routing methods with the current configuration
    string and adds (if needed) new Ms routing methods with their 
    current configuration string.

Author:

	Eran Yariv (EranY),	Jun, 1999

Arguments:

	*pIAssocMethods			[in] - Collection of routing methods
	dwMask			        [in] - Bit mask of active MS routing methods
	wszPrinter			    [in] - Current configuration string for the print method
	wszDir			        [in] - Current configuration string for the store method
	wszProfile			    [in] - Current configuration string for the inbox method

Return Value:

    HRESULT

--*/
{
	DEBUG_FUNCTION_NAME(TEXT("SetMicrosoftFaxRoutingProperties()"));

    Assert (pIAssocMethods);
    Assert (wszPrinter);
    Assert (wszDir);
    Assert (wszProfile);

    //
    // Get list of associated routing methods
    //
    long lCount;
    //
    // Get size of collection
    //
    HRESULT hr = pIAssocMethods->get_Count (&lCount);
    if (FAILED(hr))
    {
        DebugPrintEx (DEBUG_ERR, L"Can't get collection size (ec: %08x)", hr);  
        return hr;
    }
    //
    // Iterate list - We deliberately iterate in a reverse order so that
    //                if we remove an item during iteration, we don't screw up
    //                the remaining indices.
    //
    for (long l = lCount; l >= 1; l--)
    {
        //
        // Get single IFaxAssociatedRoutingMethod
        //
        AR<IFaxAssociatedRoutingMethod> pIAssocMethod;
        VARIANT vIndex;
        //
        // Get next item
        //
        vIndex.lVal = l;
        vIndex.vt = VT_I4;
        hr = pIAssocMethods->Item (vIndex, &pIAssocMethod);
        if (FAILED (hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't get IFaxAssociatedRoutingMethod (ec: %08x)", hr);  
            return hr;
        }
        //
        // Get GUID of this method
        //
        CComBSTR bstr;

        hr = pIAssocMethod->get_MethodGUID (&bstr);
        if (FAILED(hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't get IFaxAssociatedRoutingMethod GUID (ec: %08x)", hr);  
            return hr;
        }
        LPCWSTR pMethodInfo = NULL;
        DWORD  dwMethodBit = 0;
        if (!lstrcmp (bstr, REGVAL_RM_PRINTING_GUID))
        {
            //
            // It's a Microsoft extension print guid
            //
            pMethodInfo = wszPrinter;
            dwMethodBit = LR_PRINT;
        }
        else if (!lstrcmp (bstr, REGVAL_RM_FOLDER_GUID))
        {
            //
            // It's a Microsoft extension store guid
            //
            pMethodInfo = wszDir;
            dwMethodBit = LR_STORE;
        }
        else if (!lstrcmp (bstr, REGVAL_RM_INBOX_GUID))
        {
            //
            // It's a Microsoft extension profile guid
            //
            pMethodInfo = wszProfile;
            dwMethodBit = LR_INBOX;

        }
        if (!pMethodInfo)
        {
            //
            // This is not a Microsoft extension method association
            //
            continue;
        }
        if (!(dwMask & dwMethodBit))
        {
            //
            // This is a Microsoft extension method association and the method shoud be removed
            //
            pIAssocMethod->Release ();
            pIAssocMethod.Detach();
            hr = pIAssocMethods->Remove (vIndex);
            if (FAILED(hr))
            {
                DebugPrintEx (DEBUG_ERR, L"Can't remove assoc. method (ec: %08x)", hr);  
                return hr;
            }
        }
        else 
        {
            //
            // This is a Microsoft extension method association and the method configuration
            // should be updated.
            //
            CComBSTR bstrParam (pMethodInfo);

            hr = pIAssocMethod->put_ConfigurationDescription(bstrParam);
            if (FAILED(hr))
            {
                DebugPrintEx (DEBUG_ERR, L"Can't update method information (ec: %08x)", hr);  
                return hr;
            }
            //
            // Turn off the bit mask for this method so we don't add it at the end
            //
            dwMask &= (~dwMethodBit);
        }
    }   // End of methods loop
    //
    // Now, let's look at the bit flags that remain set, and add new methods accordingly.
    //
    while (0 != dwMask)
    {
        //
        // We need to add at least one method
        //
        AR<IFaxAssociatedRoutingMethod> pIAssocMethod;
        CComBSTR bstrGuid;
        CComBSTR bstrParams;
        if (dwMask & LR_PRINT)
        {
            //
            // Add a print association
            //
            bstrGuid = REGVAL_RM_PRINTING_GUID;
            bstrParams = wszPrinter;
            dwMask &= (~LR_PRINT);
        }
        else if (dwMask & LR_STORE)
        {
            //
            // Add a store association
            //
            bstrGuid = REGVAL_RM_FOLDER_GUID;
            bstrParams = wszDir;
            dwMask &= (~LR_STORE);
        }
        else if (dwMask & LR_INBOX)
        {
            //
            // Add an Inbox association
            //
            bstrGuid = REGVAL_RM_INBOX_GUID;
            bstrParams = wszProfile;
            dwMask &= (~LR_INBOX);
        }
        else
        {
            Assert (FALSE);
        }

        hr = pIAssocMethods->Add (bstrGuid, &pIAssocMethod);
        if (FAILED (hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't add assoc. method (ec: %08x)", hr);  
            return hr;
        }
        hr = pIAssocMethod->put_ConfigurationDescription (bstrParams);
        if (FAILED(hr))
        {
            DebugPrintEx (DEBUG_ERR, L"Can't update method information (ec: %08x)", hr);  
            return hr;
        }
    }   // End of while loop
    hr = pIAssocMethods->Save ();
    if (FAILED (hr))
    {
        DebugPrintEx (DEBUG_ERR, L"Can't Save (ec: %08x)", hr);  
        return hr;
    }
    return NOERROR;
}   // SetMicrosoftFaxRoutingProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\faxmodem.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxmodem.c

Abstract:

    This module contains code to read the adaptive
    answer modem list from the faxsetup.inf file.

Author:

    Wesley Witt (wesw) 22-Sep-1997


Revision History:

--*/

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <tapi.h>

#include "faxreg.h"
#include "faxutil.h"

#ifdef __cplusplus
extern "C" {
#endif


VOID 
CALLBACK 
lineCallbackFunc(
  DWORD     hDevice,             
  DWORD     dwMsg,               
  DWORD_PTR dwCallbackInstance,  
  DWORD_PTR dwParam1,            
  DWORD_PTR dwParam2,            
  DWORD_PTR dwParam3             
)
{
    UNREFERENCED_PARAMETER (hDevice);
    UNREFERENCED_PARAMETER (dwMsg);
    UNREFERENCED_PARAMETER (dwCallbackInstance);
    UNREFERENCED_PARAMETER (dwParam1);
    UNREFERENCED_PARAMETER (dwParam2);
    UNREFERENCED_PARAMETER (dwParam3);
}   // lineCallbackFunc


LPLINEDEVCAPS
SmartLineGetDevCaps(
    HLINEAPP hLineApp,
    DWORD    dwDeviceId,
    DWORD    dwAPIVersion
    )
/*++

Routine name : SmartLineGetDevCaps

Routine description:

	Gets the line capabilities for a TAPI line

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	hLineApp                      [in]     - Handle to TAPI
	dwDeviceId                    [in]     - Line id
	dwAPIVersion                  [in]     - Negotiated TAPI API version

Return Value:

    Pointer to allocated lide device capabilities data

--*/
{
    DWORD dwLineDevCapsSize;
    LPLINEDEVCAPS lpLineDevCaps = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("SmartLineGetDevCaps"))
    //
    // Allocate the initial linedevcaps structure
    //
    dwLineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    lpLineDevCaps = (LPLINEDEVCAPS) MemAlloc( dwLineDevCapsSize );
    if (!lpLineDevCaps) 
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't allocate %ld bytes for LINEDEVCAPS"),
            dwLineDevCapsSize);
        return NULL;
    }

    lpLineDevCaps->dwTotalSize = dwLineDevCapsSize;

    dwRes = lineGetDevCaps(
        hLineApp,
        dwDeviceId,
        dwAPIVersion,
        0,  // Always refer to address 0
        lpLineDevCaps
        );

    if ((ERROR_SUCCESS != dwRes) && (LINEERR_STRUCTURETOOSMALL != dwRes)) 
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineGetDevCaps failed with 0x%08x"),
            dwRes);
        goto exit;
    }

    if (lpLineDevCaps->dwNeededSize > lpLineDevCaps->dwTotalSize) 
    {
        //
        // Re-allocate the linedevcaps structure
        //
        dwLineDevCapsSize = lpLineDevCaps->dwNeededSize;
        MemFree( lpLineDevCaps );
        lpLineDevCaps = (LPLINEDEVCAPS) MemAlloc( dwLineDevCapsSize );
        if (!lpLineDevCaps) 
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't allocate %ld bytes for LINEDEVCAPS"),
                dwLineDevCapsSize);
            return NULL;
        }
        lpLineDevCaps->dwTotalSize = dwLineDevCapsSize;
        dwRes = lineGetDevCaps(
            hLineApp,
            dwDeviceId,
            dwAPIVersion,
            0,  // Always refer to address 0
            lpLineDevCaps
            );
        if (ERROR_SUCCESS != dwRes) 
        {
            //
            // lineGetDevCaps() can fail with error code 0x8000004b
            // if a device has been deleted and tapi has not been
            // cycled.  this is caused by the fact that tapi leaves
            // a phantom device in it's device list.  the error is
            // benign and the device can safely be ignored.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lineGetDevCaps failed with 0x%08x"),
                dwRes);
            goto exit;
        }
    }

exit:
    if (dwRes != ERROR_SUCCESS) 
    {
        MemFree( lpLineDevCaps );
        lpLineDevCaps = NULL;
        SetLastError(dwRes);
    }
    return lpLineDevCaps;
}   // SmartLineGetDevCaps

BOOL
IsDeviceModem (
    LPLINEDEVCAPS lpLineCaps,
    LPCTSTR       lpctstrUnimodemTspName
)
/*++

Routine name : IsDeviceModem

Routine description:

	Is a TAPI line a modem?

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	lpLineCaps              [in]     - Line capabilities buffer
    lpctstrUnimodemTspName  [in]     - Full name of the Unimodem TSP

Return Value:

    TRUE if a TAPI line is a modem, FALSE otherwise.

--*/
{
    LPTSTR lptstrDeviceClassList;
    BOOL bRes = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("IsDeviceModem"))

    if (lpLineCaps->dwDeviceClassesSize && lpLineCaps->dwDeviceClassesOffset) 
    {
        //
        // Scan multi-string for modem class
        //
        lptstrDeviceClassList = (LPTSTR)((LPBYTE) lpLineCaps + lpLineCaps->dwDeviceClassesOffset);
        while (*lptstrDeviceClassList) 
        {
            if (_tcscmp(lptstrDeviceClassList,TEXT("comm/datamodem")) == 0) 
            {
                bRes = TRUE;
                break;
            }
            lptstrDeviceClassList += (_tcslen(lptstrDeviceClassList) + 1);
        }
    }

    if ((!(lpLineCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
        (!(lpLineCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) 
    {
        //
        // Unacceptable modem device type
        //
        bRes = FALSE;
    }
    if (lpLineCaps->dwProviderInfoSize && lpLineCaps->dwProviderInfoOffset) 
    {
        //
        // Provider (TSP) name is there
        //
        if (_tcscmp((LPTSTR)((LPBYTE) lpLineCaps + lpLineCaps->dwProviderInfoOffset),
                    lpctstrUnimodemTspName) != 0)
        {
            //
            // Our T30 modem FSP only works with Unimodem TSP
            //
            bRes = FALSE;
        }
    }
    return bRes;
}   // IsDeviceModem

DWORD
GetFaxCapableTapiLinesCount (
    LPDWORD lpdwCount,
    LPCTSTR lpctstrUnimodemTspName
    )
/*++

Routine name : GetFaxCapableTapiLinesCount

Routine description:

	Counter the number of Fax-capable TAPI lines in the system

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	lpdwCount               [out]    - Pointer to count of fax-capable Tapi lines
    lpctstrUnimodemTspName  [in]     - Full name of the Unimodem TSP

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    LINEINITIALIZEEXPARAMS LineInitializeExParams = {sizeof (LINEINITIALIZEEXPARAMS), 0, 0, 0, 0, 0};
    HLINEAPP hLineApp = NULL;
    DWORD    dwTapiDevices;
    DWORD    dwLocalTapiApiVersion = 0x00020000;
    DWORD    dwCount = 0;
    DWORD    dwIndex;
    DEBUG_FUNCTION_NAME(TEXT("GetFaxCapableTapiLinesCount"))

    dwRes = lineInitializeEx(
        &hLineApp,
        GetModuleHandle(NULL),
        lineCallbackFunc,
        FAX_SERVICE_DISPLAY_NAME,
        &dwTapiDevices,
        &dwLocalTapiApiVersion,
        &LineInitializeExParams
        );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineInitializeEx failed with %ld"),
            dwRes);
        goto exit;
    }
    for (dwIndex = 0; dwIndex < dwTapiDevices; dwIndex++)
    {
        //
        // For each device, get it's caps
        //
        LPLINEDEVCAPS lpLineCaps = SmartLineGetDevCaps (hLineApp, dwIndex, dwLocalTapiApiVersion);
        if (!lpLineCaps)
        {
            //
            // Couldn't get the device capabilities
            //
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SmartLineGetDevCaps failed with %ld"),
                dwRes);
            continue;
        }
        if ((
             (lpLineCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM) && 
             IsDeviceModem(lpLineCaps, lpctstrUnimodemTspName)
            ) 
            ||
            (lpLineCaps->dwMediaModes & LINEMEDIAMODE_G3FAX)
           )
        {
            //
            // This is a fax-capable device
            //
            dwCount++;
        }
        MemFree (lpLineCaps);
    }
    dwRes = ERROR_SUCCESS;

exit:
    if (hLineApp)
    {
        lineShutdown (hLineApp);
    }
    if (ERROR_SUCCESS == dwRes)
    {
        *lpdwCount = dwCount;
    }
    return dwRes;
}   // GetFaxCapableTapiLinesCount

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\file.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file implements file functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <Accctrl.h>
#include <Aclapi.h>

#include "faxutil.h"
#include "faxreg.h"
#include "FaxUIConstants.h"


VOID
DeleteTempPreviewFiles (
    LPTSTR lptstrDirectory,
    BOOL   bConsole
)
/*++

Routine name : DeleteTempPreviewFiles

Routine description:

    Deletes all the temporary fax preview TIFF files from a given folder.

    Deletes files: "<lptstrDirectory>\<PREVIEW_TIFF_PREFIX>*.<FAX_TIF_FILE_EXT>".

Author:

    Eran Yariv (EranY), Apr, 2001

Arguments:

    lptstrDirectory     [in] - Folder.
                               Optional - if NULL, the current user's temp dir is used.

    bConsole            [in] - If TRUE, called from the client console. Otherwise, from the Fax Send Wizard.

Return Value:

    None.

--*/
{
    TCHAR szTempPath[MAX_PATH * 2];
    TCHAR szSearch[MAX_PATH * 3];
    WIN32_FIND_DATA W32FindData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    TCHAR* pLast = NULL;

    DEBUG_FUNCTION_NAME(TEXT("DeleteTempPreviewFiles"));

    if (!lptstrDirectory)
    {
        GetTempPath( ARR_SIZE(szTempPath), szTempPath );
        lptstrDirectory = szTempPath;
    }

    pLast = _tcsrchr(lptstrDirectory,TEXT('\\'));
    if(pLast && (*_tcsinc(pLast)) == '\0')
    {
        //
        // the last character is a backslash, truncate it...
        //
        _tcsnset(pLast,'\0',1);
    }

    if (_sntprintf(
        szSearch,
        ARR_SIZE(szSearch),
        TEXT("%s\\%s%08x*.%s"),
        lptstrDirectory,
        bConsole ? CONSOLE_PREVIEW_TIFF_PREFIX : WIZARD_PREVIEW_TIFF_PREFIX,
        GetCurrentProcessId(),
        FAX_TIF_FILE_EXT
        ) < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Insufficient FileName buffer"));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return;
    }

    hFind = FindFirstFile (szSearch, &W32FindData);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FindFirstFile failed with %ld"), GetLastError ());
        return;
    }
    for (;;)
    {
        TCHAR szFile[MAX_PATH * 3];

        //
        // Compose full path to file
        //
        if (_sntprintf(
            szFile,
            ARR_SIZE(szFile),
            TEXT("%s\\%s"),
            lptstrDirectory,
            W32FindData.cFileName
            ) >= 0)
        {
            //
            // Delete the currently found file
            //
            if (!DeleteFile (szFile))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("DeleteFile(%s) failed with %ld"), szFile, GetLastError ());
            }
            else
            {
                DebugPrintEx(DEBUG_MSG, TEXT("%s deleted"), szFile);
            }
        }
        //
        // Find next file
        //
        if(!FindNextFile(hFind, &W32FindData))
        {
            if(ERROR_NO_MORE_FILES != GetLastError ())
            {
                DebugPrintEx(DEBUG_ERR, TEXT("FindNextFile failed with %ld"), GetLastError ());
            }
            else
            {
                //
                // End of files - no error
                //
            }
            break;
        }
    }
    FindClose (hFind);
}   // DeleteTempPreviewFiles

DWORDLONG
GenerateUniqueFileNameWithPrefix(
    BOOL   bUseProcessId,
    LPTSTR lptstrDirectory,
    LPTSTR lptstrPrefix,
    LPTSTR lptstrExtension,
    LPTSTR lptstrFileName,
    DWORD  dwFileNameSize
    )
/*++

Routine name : GenerateUniqueFileNameWithPrefix

Routine description:

    Generates a unique file name

Author:

    Eran Yariv (EranY), Apr, 2001

Arguments:

    bUseProcessId       [in]     - If TRUE, the process id is appended after the prefix

    lptstrDirectory     [in]     - Directory where file should be created.
                                   Optional - if NULL, the current user's temp dir is used.

    lptstrPrefix        [in]     - File prefix.
                                   Optional - if NULL, no prefix is used.

    lptstrExtension     [in]     - File extension.
                                   Optional - if NULL, FAX_TIF_FILE_EXT is used.

    lptstrFileName      [out]    - File name.

    dwFileNameSize      [in]     - Size of file name (in characters)

Return Value:

    Unique file identifier.
    Returns 0 in case of error (sets last error).

--*/
{
    DWORD i;
    TCHAR szTempPath[MAX_PATH * 2];
    TCHAR szProcessId[20] = {0};
    DWORDLONG dwlUniqueId = 0;

    DEBUG_FUNCTION_NAME(TEXT("GenerateUniqueFileNameWithPrefix"));

    if (!lptstrDirectory)
    {
        GetTempPath( ARR_SIZE(szTempPath), szTempPath );
        lptstrDirectory = szTempPath;
    }

    TCHAR* pLast = NULL;
    pLast = _tcsrchr(lptstrDirectory,TEXT('\\'));
    if(pLast && (*_tcsinc(pLast)) == '\0')
    {
        //
        // the last character is a backslash, truncate it...
        //
        _tcsnset(pLast,'\0',1);
    }

    if (!lptstrExtension)
    {
        lptstrExtension = FAX_TIF_FILE_EXT;
    }
    if (!lptstrPrefix)
    {
        lptstrPrefix = TEXT("");
    }
    if (bUseProcessId)
    {
        _stprintf (szProcessId, TEXT("%08x"), GetCurrentProcessId());
    }

    for (i=0; i<256; i++)
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        FILETIME FileTime;
        SYSTEMTIME SystemTime;

        GetSystemTime( &SystemTime ); // returns VOID
        if (!SystemTimeToFileTime( &SystemTime, &FileTime ))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("SystemTimeToFileTime() failed (ec: %ld)"), GetLastError());
            return 0;
        }

        dwlUniqueId = MAKELONGLONG(FileTime.dwLowDateTime, FileTime.dwHighDateTime);
        //
        // dwlUniqueId holds the number of 100 nanosecond units since 1.1.1601.
        // This occuipies most of the 64 bits.We we need some space to add extra
        // information (job type for example) to the job id.
        // Thus we give up the precision (1/10000000 of a second is too much for us anyhow)
        // to free up 8 MSB bits.
        // We shift right the time 8 bits to the right. This divides it by 256 which gives
        // us time resolution better than 1/10000 of a sec which is more than enough.
        //
        dwlUniqueId = dwlUniqueId >> 8;

        if (_sntprintf(
            lptstrFileName,
            dwFileNameSize - 1,
            TEXT("%s\\%s%s%I64X.%s"),
            lptstrDirectory,
            lptstrPrefix,
            szProcessId,
            dwlUniqueId,
            lptstrExtension
            ) < 0)
        {
            DebugPrintEx( DEBUG_ERR, TEXT("Insufficient FileName buffer"));
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return 0;
        }

        hFile = CreateFile(
            lptstrFileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwError = GetLastError();

            if (dwError == ERROR_ALREADY_EXISTS || dwError == ERROR_FILE_EXISTS)
            {
                continue;
            }
            else
            {
                //
                // Real error
                //
                DebugPrintEx(DEBUG_ERR,
                             TEXT("CreateFile() for [%s] failed. (ec: %ld)"),
                             lptstrFileName,
                             GetLastError());
                return 0;
            }
        }
        else
        {
            //
            // Success
            //
            CloseHandle (hFile);
            break;
        }
    }

    if (i == 256)
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("Failed to generate a unique file name after %d attempts. \n")
                        TEXT("Last attempted UniqueIdValue value is: 0x%I64X \n")
                        TEXT("Last attempted file name is : [%s]"),
                        i,
                        dwlUniqueId,
                        lptstrFileName);
        SetLastError( ERROR_TOO_MANY_OPEN_FILES );
        return 0;
    }
    return dwlUniqueId;
}   // GenerateUniqueFileNameWithPrefix


//*********************************************************************************
//* Name:   GenerateUniqueFileName()
//* Author:
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Generates a unique file in the queue directory.
//*     returns a UNIQUE id for the file.
//* PARAMETERS:
//*     [IN]    LPTSTR Directory
//*         The path where the file is to be created.
//*     [OUT]   LPTSTR Extension
//*         The file extension that the generated file should have.
//*     [IN]    LPTSTR FileName
//*         The buffer where the resulting file name (including path) will be
//*         placed, must be MAX_PATH.
//*     [IN]    DWORD  FileNameSize
//*         The size of the file name buffer.
//* RETURN VALUE:
//*      If successful the function returns A DWORDLONG with the unique id for the file.
//*      On failure it returns 0.
//* REMARKS:
//*     The generated unique id the 64 bit value of the system time.
//*     The generated file name is a string containing the hex representation of
//*     the 64 bit system time value.
//*********************************************************************************
DWORDLONG
GenerateUniqueFileName(
    LPTSTR Directory,
    LPTSTR Extension,
    LPTSTR FileName,
    DWORD  FileNameSize
    )
{
    return GenerateUniqueFileNameWithPrefix (FALSE, Directory, NULL, Extension, FileName, FileNameSize);
}   // GenerateUniqueFileName



BOOL
MapFileOpen(
    LPCTSTR FileName,
    BOOL ReadOnly,
    DWORD ExtendBytes,
    PFILE_MAPPING FileMapping
    )
{
    FileMapping->hFile = NULL;
    FileMapping->hMap = NULL;
    FileMapping->fPtr = NULL;

    FileMapping->hFile = CreateFile(
        FileName,
        ReadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
        ReadOnly ? FILE_SHARE_READ : 0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (FileMapping->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FileMapping->fSize = GetFileSize( FileMapping->hFile, NULL );

    FileMapping->hMap = CreateFileMapping(
        FileMapping->hFile,
        NULL,
        ReadOnly ? PAGE_READONLY : PAGE_READWRITE,
        0,
        FileMapping->fSize + ExtendBytes,
        NULL
        );
    if (FileMapping->hMap == NULL) {
        CloseHandle( FileMapping->hFile );
        return FALSE;
    }

    FileMapping->fPtr = (LPBYTE)MapViewOfFileEx(
        FileMapping->hMap,
        ReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
        0,
        0,
        0,
        NULL
        );
    if (FileMapping->fPtr == NULL) {
        CloseHandle( FileMapping->hFile );
        CloseHandle( FileMapping->hMap );
        return FALSE;
    }

    return TRUE;
}


VOID
MapFileClose(
    PFILE_MAPPING FileMapping,
    DWORD TrimOffset
    )
{
    UnmapViewOfFile( FileMapping->fPtr );
    CloseHandle( FileMapping->hMap );
    if (TrimOffset) {
        SetFilePointer( FileMapping->hFile, TrimOffset, NULL, FILE_BEGIN );
        SetEndOfFile( FileMapping->hFile );
    }
    CloseHandle( FileMapping->hFile );
}



//
// Function:    MultiFileCopy
// Description: Copies multiple files from one directory to another.
//              In case of failure, return FALSE without any clean-up.
//              Validate that the path names and file names are not sum to be larger than MAX_PATH
// Args:
//
//              dwNumberOfFiles     : Number of file names to copy
//              fileList            : Array of strings: file names
//              lpctstrSrcDirectory : Source directory (with or without '\' at the end
//              lpctstrDestDirectory: Destination directory (with or without '\' at the end
//
// Author:      AsafS



BOOL
MultiFileCopy(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrSrcDirectory,
    LPCTSTR  lpctstrDestDirerctory
    )
{
    DEBUG_FUNCTION_NAME(TEXT("MultiFileCopy"))
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];

    DWORD dwLengthOfDestDirectory = _tcslen(lpctstrDestDirerctory);
    DWORD dwLengthOfSrcDirectory  = _tcslen(lpctstrSrcDirectory);

    // Make sure that all the file name lengths are not too big

    DWORD dwMaxPathLen = 1 + max((dwLengthOfDestDirectory),(dwLengthOfSrcDirectory));
    DWORD dwBufferLen  = (sizeof(szSrcPath)/sizeof(TCHAR)) - 1;

    DWORD i=0;
    Assert (dwNumberOfFiles);
    for (i=0 ; i < dwNumberOfFiles ; i++)
    {
        if ( (_tcslen(fileList[i]) + dwMaxPathLen) > dwBufferLen )
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("The file/path names are too long")
                 );
            SetLastError( ERROR_BUFFER_OVERFLOW );
            return (FALSE);
        }
    }


    _tcscpy(szSrcPath , lpctstrSrcDirectory);
    _tcscpy(szDestPath , lpctstrDestDirerctory);

    //
    // Verify that directories end with '\\'.
    //
    TCHAR* pLast = NULL;
    pLast = _tcsrchr(szSrcPath,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(szSrcPath, TEXT("\\"));
    }

    pLast = _tcsrchr(szDestPath,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(szDestPath, TEXT("\\"));
    }

    // Do the copy now

    for (i=0 ; i < dwNumberOfFiles ; i++)
    {
        TCHAR szSrcFile[MAX_PATH];
        TCHAR szDestFile[MAX_PATH];

        _tcscpy(szSrcFile , szSrcPath);
        _tcscpy(szDestFile , szDestPath);

        _tcscat(szSrcFile , fileList[i]);
        _tcscat(szDestFile, fileList[i]);

        if (!CopyFile(szSrcFile, szDestFile, FALSE))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("CopyFile(%s, %s) failed: %d."),
                 szSrcFile,
                 szDestFile,
                 GetLastError()
                 );
            return(FALSE);
        }
        DebugPrintEx(
                 DEBUG_MSG,
                 TEXT("CopyFile(%s, %s) succeeded."),
                 szSrcFile,
                 szDestFile
                 );
    }

    return TRUE;
}





//
// Function:    MultiFileDelete
// Description: Deletes multiple files from given directory.
//              In case of failure, continue with the rest of the files and returns FALSE. Call to
//              GetLastError() to get the reason for the last failure that occured
//              If all DeleteFile calls were successful - return TRUE
//              Validate that the path name and file names are not sum to be larger than MAX_PATH
// Args:
//
//              dwNumberOfFiles         : Number of file names to copy
//              fileList                : Array of strings: file names
//              lpctstrFilesDirectory   : Directory of the files (with or without '\' at the end
//
// Author:      AsafS



BOOL
MultiFileDelete(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrFilesDirectory
    )
{
    DEBUG_FUNCTION_NAME(TEXT("MultiFileDelete"))
    BOOL  retVal = TRUE;
    DWORD dwLastError = 0;
    TCHAR szFullPath[MAX_PATH];


    DWORD dwLengthOfDirectoryName = _tcslen(lpctstrFilesDirectory);

    // Make sure that all the file name lengths are not too big
    DWORD dwBufferLen  = (sizeof(szFullPath)/sizeof(TCHAR)) - 1;
    DWORD i;
    Assert (dwNumberOfFiles);
    for (i=0 ; i < dwNumberOfFiles ; i++)
    {
        if ( (_tcslen(fileList[i]) + dwLengthOfDirectoryName + 1) > dwBufferLen )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("The file/path names are too long")
                );
            SetLastError( ERROR_BUFFER_OVERFLOW );
            return (FALSE);
        }
    }



    _tcscpy(szFullPath , lpctstrFilesDirectory);
    dwLengthOfDirectoryName = _tcslen(lpctstrFilesDirectory);

    //
    // Verify that directory end with '\\' to the end of the path.
    //
    TCHAR* pLast = NULL;
    pLast = _tcsrchr(szFullPath,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(szFullPath, TEXT("\\"));
    }

    for(i=0 ; i < dwNumberOfFiles ; i++)
    {
        TCHAR szFileName[MAX_PATH];

        _tcscpy(szFileName, szFullPath);

        _tcscat(szFileName, fileList[i]);

        if (!DeleteFile(szFileName))
        {
            dwLastError = GetLastError();
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Delete (%s) failed: %d."),
                 szFileName,
                 dwLastError
                 );
            retVal = FALSE; // Continue with the list
        }
        else
        {
            DebugPrintEx(
                 DEBUG_MSG,
                 TEXT("Delete (%s) succeeded."),
                 szFileName
                 );
        }
    }

    if (!retVal) // In case there was a failure to delete any file
    {
        SetLastError(dwLastError);
        DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Delete files from (%s) failed: %d."),
                 szFullPath,
                 dwLastError
                 );

    }

    return retVal;
}


BOOL
ValidateCoverpage(
    LPCTSTR  CoverPageName,
    LPCTSTR  ServerName,
    BOOL     ServerCoverpage,
    LPTSTR   ResolvedName
    )
/*++

Routine Description:

    This routine tries to validate that that coverpage specified by the user actually exists where
    they say it does, and that it is indeed a coverpage (or a resolvable link to one)

    Please see the SDK for documentation on the rules for how server coverpages work, etc.
Arguments:

    CoverpageName   - contains name of coverpage
    ServerName      - name of the server, if any (can be null)
    ServerCoverpage - indicates if this coverpage is on the server, or in the server location for
                      coverpages locally
    ResolvedName    - a pointer to buffer (should be MAX_PATH large at least) to receive the
                      resolved coverpage name.  If NULL, then this param is ignored


Return Value:

    TRUE if coverpage can be used.
    FALSE if the coverpage is invalid or cannot be used.

--*/

{
    LPTSTR p;
    DWORD ec = ERROR_SUCCESS;
    TCHAR CpDir[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    TCHAR tszExt[_MAX_EXT] = {0};

    DEBUG_FUNCTION_NAME(TEXT("ValidateCoverpage"));

    if (!CoverPageName)
    {
        ec = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    _tcsncpy(CpDir,CoverPageName,MAX_PATH-1);
    CpDir[MAX_PATH-1] = _T('\0');   // append terminating 0


    p = _tcschr(CpDir, FAX_PATH_SEPARATOR_CHR );
    if (p)
    {
        //
        // the coverpage file name contains a path so just use it.
        //
        if (GetFileAttributes( CpDir ) == 0xffffffff)
        {
            ec = ERROR_FILE_NOT_FOUND;
            DebugPrintEx(DEBUG_ERR,
                _T("GetFileAttributes failed for %ws. ec = %ld"),
                CpDir,
                ec);
            goto exit;
        }

    }
    else
    {
        //
        // the coverpage file name does not contain
        // a path so we must construct a full path name
        //
        if (ServerCoverpage)
        {
            if (!ServerName || ServerName[0] == 0)
            {
                if (!GetServerCpDir( NULL, CpDir, sizeof(CpDir) / sizeof(CpDir[0]) ))
                {
                    ec = GetLastError ();
                    DebugPrintEx(DEBUG_ERR,
                                 _T("GetServerCpDir failed . ec = %ld"),
                                 GetLastError());
                }
            }
            else
            {
                if (!GetServerCpDir( ServerName, CpDir, sizeof(CpDir) / sizeof(CpDir[0]) ))
                {
                    ec = GetLastError ();
                    DebugPrintEx(DEBUG_ERR,
                                 _T("GetServerCpDir failed . ec = %ld"),
                                 GetLastError());
                }
            }
        }
        else
        {
            if (!GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0])))
            {
                ec = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                             _T("GetClientCpDir failed . ec = %ld"),
                             GetLastError());
            }
        }

        if (ERROR_SUCCESS != ec)
        {
            ec = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        ConcatenatePaths(CpDir, CoverPageName);

        _tsplitpath(CpDir, NULL, NULL, NULL, tszExt);
        if (!_tcslen(tszExt))
        {
            _tcscat( CpDir, FAX_COVER_PAGE_FILENAME_EXT );
        }

        if (GetFileAttributes( CpDir ) == 0xffffffff)
        {
            p = _tcschr( CpDir, '.' );
            if (p)
            {
                _tcscpy( p, CP_SHORTCUT_EXT );
                if (GetFileAttributes( CpDir ) == 0xffffffff)
                {
                    ec = ERROR_FILE_NOT_FOUND;
                    goto exit;
                }
            }
            else
            {
                ec = ERROR_FILE_NOT_FOUND;
                goto exit;
            }
        }
    }

    //
    // if the file is really a shortcut, then resolve it
    //

    if (IsCoverPageShortcut( CpDir ))
    {
        if (!ResolveShortcut( CpDir, Buffer ))
        {
            DebugPrint(( TEXT("Cover page file is really a link, but resolution is not possible") ));
            ec = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        else
        {
            if (ResolvedName)
            {
                _tcscpy(ResolvedName,Buffer);
            }
        }
    }
    else
    {
        if (ResolvedName)
        {
            _tcscpy( ResolvedName, CpDir );
        }
    }

exit:
    if (ec)
    {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
} // ValidateCoverpage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\mail.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mail.cpp

Abstract:

    Implementation of mail related utility functions

Author:

    Eran Yariv (EranY)  Feb, 2000

Revision History:

--*/

#include <faxutil.h>

#pragma warning (disable:4146)  // unary minus operator applied to unsigned type, result still unsigned
#include "msado15.tlh"
#include "cdosys.tlh"
#include <cdosysstr.h>  // String constants in this file
#include <cdosyserr.h>  // Error constants in this file
#pragma warning (default:4146)  // unary minus operator applied to unsigned type, result still unsigned

#define SMTP_CONN_TIMEOUT   (long)10        // Time out (sec) of SMTP connection

HRESULT
SendMail (
    LPCTSTR         lpctstrFrom,
    LPCTSTR         lpctstrTo,
    LPCTSTR         lpctstrSubject,
    LPCTSTR         lpctstrBody,
    LPCTSTR         lpctstrAttachmentPath,
    LPCTSTR         lpctstrAttachmentMailFileName,
    LPCTSTR         lpctstrServer,
    DWORD           dwPort,             // = 25
    CDO_AUTH_TYPE   AuthType,           // = CDO_AUTH_ANONYMOUS
    LPCTSTR         lpctstrUser,        // = NULL
    LPCTSTR         lpctstrPassword,    // = NULL
    HANDLE          hLoggedOnUserToken  // = NULL
)
/*++

Routine name : SendMail

Routine description:

    Sends a mail message using SMTP over CDO2.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpctstrFrom                     [in] - From address (mandatory)
                                           e.g: erany@microsoft.com
    lpctstrTo                       [in] - To address (mandatory)
                                           e.g: erany@microsoft.com
    lpctstrSubject                  [in] - Subject (optional)
    lpctstrBody                     [in] - Body text of message (optional).
                                           Since the body is encoded using text/plain - 7bit,
                                           UNICODE symbols may not appear correctly in the message.
                                           If NULL, the message will not have a body.
    lpctstrAttachmentPath           [in] - Full path to file to attach (optional)
                                           If NULL, the message will not include attachments.
    lpctstrAttachmentMailFileName   [in] - The file name of the attachment as is will appear in the mail message.
    lpctstrServer                   [in] - SMTP server to connect to (mandatory)
                                           e.g: hai-msg-01
    dwPort                          [in] - SMTP port (optional, default = 25)
    AuthType                        [in] - Type of SMTP authentication.
                                           Valid values are CDO_AUTH_ANONYMOUS, CDO_AUTH_BASIC,
                                           and CDO_AUTH_NTLM.
    lpctstrUser                     [in] - User to authenticate
                                           In use only if AuthType is CDO_AUTH_BASIC or CDO_AUTH_NTLM.
    lpctstrPassword                 [in] - Password to authenticate
                                           In use only if AuthType is CDO_AUTH_BASIC or CDO_AUTH_NTLM.
    hLoggedOnUserToken              [in] - Handle to  alogged on user token.
                                           In use only if AuthType is CDO_AUTH_NTLM.

Return Value:

    Standard HRESULT code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SendMail"))

    Assert (lpctstrFrom && lpctstrTo && lpctstrServer);
    HRESULT hr = NOERROR;
    Assert ((CDO_AUTH_ANONYMOUS == AuthType) ||
            (CDO_AUTH_BASIC     == AuthType) ||
            (CDO_AUTH_NTLM      == AuthType));
    BOOL bImpersonated = FALSE;


    hr = CoInitialize(NULL);
    if (S_FALSE == hr)
    {
        //
        // Thread's COM already initialized.
        // This is not an error and we still have to call CoUninitialize at the end.
        //
        hr = NOERROR;
    }
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CoInitialize failed. (hr: 0x%08x)"),
            hr);
        return hr;
    }
    try
    {
        //
        // The following code is in a seperate block so that the auto pointers dtors
        // get called before CoUninitialize
        //

        //
        // Create a new message instance (can throw exception)
        //
        IMessagePtr iMsg(__uuidof(Message));
        //
        // Create a new CDO2 configuration instance (can throw exception)
        IConfigurationPtr iConf(__uuidof(Configuration));
        //
        // Access configuration fields collection
        //
        FieldsPtr Flds;
        Flds = iConf->Fields;
        //
        // Send the message using the network. (SMTP protocol over the network)
        //
        Flds->Item[cdoSendUsingMethod]->Value       = _variant_t((long)cdoSendUsingPort);
        //
        // Define SMTP server
        //
        Flds->Item[cdoSMTPServer]->Value            = _variant_t(lpctstrServer);
        //
        // Define SMTP port
        //
        Flds->Item[cdoSMTPServerPort]->Value        = _variant_t((long)dwPort);
        //
        // Define SMTP connection timeout (in seconds)
        //
        Flds->Item[cdoSMTPConnectionTimeout]->Value = _variant_t(SMTP_CONN_TIMEOUT);
        //
        // Make sure we don't used cached info for attachments
        //
        Flds->Item[cdoURLGetLatestVersion]->Value   = _variant_t(VARIANT_TRUE);
        //
        // Choose authentication method
        //
        switch (AuthType)
        {
            case CDO_AUTH_ANONYMOUS:
                Flds->Item[cdoSMTPAuthenticate]->Value      = _variant_t((long)cdoAnonymous);
                break;

            case CDO_AUTH_BASIC:
                Flds->Item[cdoSMTPAuthenticate]->Value      = _variant_t((long)cdoBasic);
                Flds->Item[cdoSendUserName]->Value          = _variant_t(lpctstrUser);
                Flds->Item[cdoSendPassword]->Value          = _variant_t(lpctstrPassword);
                break;

            case CDO_AUTH_NTLM:
                //
                // NTLM authentication required the calling client (that's us)
                // to impersonate the user
                //
                Flds->Item[cdoSMTPAuthenticate]->Value = _variant_t((long)cdoNTLM);
                break;

            default:
                ASSERT_FALSE;
        }
        //
        // Update configuration from the fields
        //
        Flds->Update();
        //
        // Store configuration in the message
        //
        iMsg->Configuration = iConf;
        //
        // Set recipient
        //
        iMsg->To        = lpctstrTo;
        //
        // Set sender
        //
        iMsg->From      = lpctstrFrom;
        //
        // Set subject
        //
        iMsg->Subject   = lpctstrSubject;
        //
        // Set message format to MIME
        //
        iMsg->MimeFormatted = _variant_t(VARIANT_TRUE);
        //
        // Set charset to Unicode (UTF-8)
        //
        iMsg->BodyPart->Charset = "utf-8";
        iMsg->BodyPart->ContentTransferEncoding = "base64";

        IBodyPartPtr iBp;
        //
        // Get message body root
        //
        iBp = iMsg;
        //
        // Set content type fo mixed to support both body and attachment
        //
        iBp->ContentMediaType = "multipart/mixed; charset=""utf-8""";
        if (lpctstrBody)
        {
            //
            // Add body text
            //
            IBodyPartPtr iBp2;
            _StreamPtr   Stm;
            //
            // Add text body under root
            //
            iBp2 = iBp->AddBodyPart(-1);
            //
            // Use text format
            //
            iBp2->ContentMediaType        = "text/plain";
            //
            // Set charset to Unicode (UTF-8)
            //
            iBp2->Charset = "utf-8";
            iBp2->ContentTransferEncoding = "base64";
            //
            // Get body text stream
            //
            Stm = iBp2->GetDecodedContentStream();
            //
            // Write stream text
            //
            Stm->WriteText(lpctstrBody, adWriteChar);
            Stm->Flush();
        }
        if (lpctstrAttachmentPath)
        {
            //
            // Add attachment
            //
            IBodyPartPtr iBpAttachment;
            iBpAttachment = iMsg->AddAttachment(lpctstrAttachmentPath, TEXT(""), TEXT(""));
            if (lpctstrAttachmentMailFileName)
            {
                //
                // User wishes to rename attachment in the mail message
                //
                FieldsPtr Flds = iBpAttachment->Fields;
                _bstr_t bstrContentType = iBpAttachment->ContentMediaType       +
                                          TEXT("; name=\"")                     +
                                          lpctstrAttachmentMailFileName         +
                                          TEXT("\"");
                Flds->Item[cdoContentType]->Value = _variant_t(bstrContentType);
                Flds->Update();
                Flds->Resync(adResyncAllValues);
            }
        }
        if (CDO_AUTH_NTLM == AuthType)
        {
            //
            // We impersonate the user in the NTLM authentication mode.
            // This is the last thing we do just before sending the message.
            //
            Assert (hLoggedOnUserToken);

            if (!ImpersonateLoggedOnUser (hLoggedOnUserToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("ImpersonateLoggedOnUser failed. (hr: 0x%08x)"),
                    hr);
                goto exit;
            }

            bImpersonated = TRUE;
        }
        //
        // Finally - send the message
        //
        iMsg->Send();
    }
    catch (_com_error &er)
    {
        //
        // Error in CDO2
        //
        hr = er.Error ();
        DebugPrintEx(
             DEBUG_ERR,
             TEXT("CDO2 Error 0x%08x: to:%s, subject:%s")
#ifdef UNICODE
             TEXT(" Description:%s")
#endif
             ,hr,
             lpctstrTo,
             lpctstrSubject
#ifdef UNICODE
             ,(LPCTSTR)er.Description()
#endif
        );
    }

exit:
    CoUninitialize();
    if (bImpersonated)
    {
        if (!RevertToSelf ())
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RevertToSelf failed. (hr: 0x%08x)"),
                hr);
        }
    }
    return hr;
}   // SendMail
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\language.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxutil.h"

DWORD SetLTRWindowLayout(HWND hWnd);
DWORD SetLTREditBox(HWND hEdit);


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsRTLUILanguage
//
//  Purpose:        
//                  Determine User Default UI Language layout
//
//  Return Value:
//                  TRUE if the User Default UI Language has Right-to-Left layout
//                  FALSE otherwise 
///////////////////////////////////////////////////////////////////////////////////////
BOOL
IsRTLUILanguage()
{

#if(WINVER >= 0x0500)

    LANGID  langID;     // language identifier for the current user language
    WORD    primLangID; // primary language identifier 

    DEBUG_FUNCTION_NAME(TEXT("IsRTLUILanguage"));

    langID = GetUserDefaultUILanguage();
    if(langID == 0)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("GetUserDefaultUILanguage failed."));
        return TRUE;
    }

    primLangID = PRIMARYLANGID(langID);

    if(LANG_ARABIC == primLangID || 
       LANG_HEBREW == primLangID)
    {
        //
        // If the UI Language is Arabic or Hebrew the layout is Right-to-Left
        //
        return TRUE;
    }

#endif /* WINVER >= 0x0500 */

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsWindowRTL
//
//  Purpose:        
//                  Determine if the window has RTL layout
//
//  Params:
//                  hWnd      - window handle
//  Return Value:
//                  TRUE if the window has RTL layout
//                  FALSE otherwise 
///////////////////////////////////////////////////////////////////////////////////////
BOOL
IsWindowRTL(
    HWND    hWnd
)
{
    BOOL bRes = FALSE;

#if(WINVER >= 0x0500)

    LONG_PTR style;

    style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);

    if(WS_EX_LAYOUTRTL == (style & WS_EX_LAYOUTRTL))
    {
        bRes = TRUE;
    }

#endif /* WINVER >= 0x0500 */

    return bRes;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetLTRControlLayout
//
//  Purpose:        
//                  Set left-to-right layout for a dialog control
//                  if the user default UI has RTL layout
//
//  Params:
//                  hDlg      - Dialog handle
//                  dwCtrlID  - control ID
//
//  Return Value:
//                  standard error code
///////////////////////////////////////////////////////////////////////////////////////
DWORD
SetLTRControlLayout(
    HWND    hDlg,
    DWORD   dwCtrlID
)
{
    DWORD    dwRes = ERROR_SUCCESS;

#if(WINVER >= 0x0500)

    HWND     hCtrl;

    DEBUG_FUNCTION_NAME(TEXT("SetLTRControlLayout"));

    if(!hDlg || !dwCtrlID)
    {
        Assert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if(!IsWindowRTL(hDlg))
    {
        //
        // The dialog is not RTL
        // So, no need to revert control
        //
        return dwRes;
    }

    //
    // Get Control box handle
    //
    hCtrl = GetDlgItem(hDlg, dwCtrlID);
    if(!hCtrl)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetDlgItem failed with %ld."),dwRes);
        return dwRes;
    }

    dwRes = SetLTRWindowLayout(hCtrl);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SetLTRWindowLayout failed with %ld."),dwRes);
    }

#endif /* WINVER >= 0x0500 */

    return dwRes;

} // SetLTRControlLayout

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetLTREditDirection
//
//  Purpose:        
//                  Set left aligment for an dialog edit box 
//                  if the user default UI has RTL layout
//
//  Params:
//                  hDlg      - Dialog handle
//                  dwEditID  - Edit box control ID
//
//  Return Value:
//                  standard error code
///////////////////////////////////////////////////////////////////////////////////////
DWORD
SetLTREditDirection(
    HWND    hDlg,
    DWORD   dwEditID
)
{
    DWORD    dwRes = ERROR_SUCCESS;

#if(WINVER >= 0x0500)

    HWND     hCtrl;

    DEBUG_FUNCTION_NAME(TEXT("SetLtrEditDirection"));

    if(!hDlg || !dwEditID)
    {
        Assert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if(!IsWindowRTL(hDlg))
    {
        //
        // The dialog is not RTL
        // So, no need to revert control
        //
        return dwRes;
    }

    //
    // Get Edit box handle
    //
    hCtrl = GetDlgItem(hDlg, dwEditID);
    if(!hCtrl)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetDlgItem failed with %ld."),dwRes);
        return dwRes;
    }

    dwRes = SetLTREditBox(hCtrl);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SetLTREditBox failed with %ld."),dwRes);
    }

#endif /* WINVER >= 0x0500 */

    return dwRes;

} // SetLTREditDirection

//////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetLTRWindowLayout
//
//  Purpose:        
//                  Set left-to-right layout for a window
//                  if the user default UI has RTL layout
//
//  Params:
//                  hWnd    - Window handle
//
//  Return Value:
//                  standard error code
//////////////////////////////////////////////////////////////////////////////////////
DWORD
SetLTRWindowLayout(
    HWND    hWnd
)
{
    DWORD    dwRes = ERROR_SUCCESS;

#if(WINVER >= 0x0500)

    LONG_PTR style;

    DEBUG_FUNCTION_NAME(TEXT("SetLTRWindowLayout"));

    if(!hWnd)
    {
        Assert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remove RTL and add LTR to ExStyle
    //
    style = GetWindowLongPtr(hWnd, GWL_EXSTYLE);

    style &= ~(WS_EX_LAYOUTRTL | WS_EX_RIGHT | WS_EX_RTLREADING);
    style |= WS_EX_LEFT | WS_EX_LTRREADING;

    SetWindowLongPtr(hWnd, GWL_EXSTYLE, style);

    //
    // Refresh the window
    //
    if(!SetWindowPos(hWnd, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("SetWindowPos failed with %ld."),dwRes);
    }

#endif /* WINVER >= 0x0500 */

    return dwRes;

} // SetLTRWindowLayout


//////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetLTREditBox
//
//  Purpose:        
//                  Set left aligment for an dialog edit box 
//                  if the user default UI has RTL layout
//
//  Params:
//                  hEdit      - edit box handle
//
//  Return Value:
//                  standard error code
//////////////////////////////////////////////////////////////////////////////////////
DWORD
SetLTREditBox(
    HWND    hEdit
)
{
    DWORD    dwRes = ERROR_SUCCESS;

#if(WINVER >= 0x0500)

    LONG_PTR style;

    DEBUG_FUNCTION_NAME(TEXT("SetLTREditBox"));

    if(!hEdit)
    {
        Assert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remove RTL and add LTR to Style
    //
    style = GetWindowLongPtr(hEdit, GWL_STYLE);

    style &= ~ES_RIGHT;
    style |= ES_LEFT;

    SetWindowLongPtr(hEdit, GWL_STYLE, style);

    dwRes = SetLTRWindowLayout(hEdit);
    if(ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SetLTRWindowLayout failed with %ld."),dwRes);
    }

#endif /* WINVER >= 0x0500 */

    return dwRes;

} // SetLTREditBox

//////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SetLTRComboBox
//
//  Purpose:        
//                  Set left aligment for an dialog combo box 
//                  if the user default UI has RTL layout
//
//  Params:
//                  hDlg      - Dialog handle
//                  dwCtrlID  - combo box control ID
//
//  Return Value:
//                  standard error code
//////////////////////////////////////////////////////////////////////////////////////
DWORD
SetLTRComboBox(
    HWND    hDlg,
    DWORD   dwCtrlID
)
{
    DWORD    dwRes = ERROR_SUCCESS;

#if(WINVER >= 0x0500)

    HWND            hCtrl;
    COMBOBOXINFO    comboBoxInfo = {0};

    DEBUG_FUNCTION_NAME(TEXT("SetLTRComboBox"));

    if(!hDlg || !dwCtrlID)
    {
        Assert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if(!IsWindowRTL(hDlg))
    {
        //
        // The dialog is not RTL
        // So, no need to revert control
        //
        return dwRes;
    }

    //
    // Get combo box handle
    //
    hCtrl = GetDlgItem(hDlg, dwCtrlID);
    if(!hCtrl)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetDlgItem failed with %ld."),dwRes);
        return dwRes;
    }

    comboBoxInfo.cbSize = sizeof(comboBoxInfo);
    if(GetComboBoxInfo(hCtrl, &comboBoxInfo))
    {
        SetLTREditBox(comboBoxInfo.hwndItem);
        SetLTRWindowLayout(comboBoxInfo.hwndCombo);
        SetLTRWindowLayout(comboBoxInfo.hwndList);
    }
    else
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetComboBoxInfo failed with %ld."),dwRes);
        return dwRes;
    }


#endif /* WINVER >= 0x0500 */

    return dwRes;

} // SetLTRComboBox


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  StrHasRTLChar
//
//  Purpose:        
//                  Determine if the string has RTL characters
//                  
//  Params:
//                  pStr - string to analize
//                  
//  Return Value:
//                  TRUE if the string has RTL characters
//                  FALSE otherwise
///////////////////////////////////////////////////////////////////////////////////////
BOOL
StrHasRTLChar(
    LCID    Locale,
    LPCTSTR pStr 
)
{
    BOOL  bRTL = FALSE;
    DWORD dw;
    WORD* pwStrData = NULL;
    DWORD dwStrLen = 0; 

    DEBUG_FUNCTION_NAME(TEXT("StrHasRTLChar"));

    if(!pStr)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("pStr is NULL"));
        return bRTL;
    }

    dwStrLen = _tcslen(pStr);

    pwStrData = (WORD*)MemAlloc(sizeof(WORD) * dwStrLen);
    if(!pwStrData)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc"));
        return bRTL;
    }

    if (!GetStringTypeEx(Locale,
                         CT_CTYPE2,
                         pStr,
                         dwStrLen,
                         pwStrData))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetStringTypeEx() failed : %ld"), GetLastError());
        goto exit;
    }

    //
    //  Looking for a character with RIGHT_TO_LEFT orientation
    //
    for (dw=0; dw < dwStrLen; ++dw)
    {
        if (C2_RIGHTTOLEFT == pwStrData[dw])
        {
            bRTL = TRUE;
            break;
        }
    }

exit:

    MemFree(pwStrData);

    return bRTL;

} // StrHasRTLChar


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  AlignedMessageBox
//
//  Purpose:        
//                  Display message box with correct reading order and alignment
//                  
//  Params:
//                  pStr - string to analize
//                  
//  Return Value:
//                  MessageBox() return value
//                  
///////////////////////////////////////////////////////////////////////////////////////
int 
AlignedMessageBox(
  HWND    hWnd,       // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT    uType       // message box style
)
{
    int nRes = 0;

    if(IsRTLUILanguage())
    {
        uType |= MB_RTLREADING | MB_RIGHT;
    }

    nRes = MessageBox(hWnd, lpText, lpCaption, uType);

    return nRes;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  FaxTimeFormat
//
//  Purpose:        
//                  Format time string with correct reading order
//                  
//  Params:
//                  see GetTimeFormat() parameters
//                  
//  Return Value:
//                  GetTimeFormat() return value
//                  
///////////////////////////////////////////////////////////////////////////////////////
int 
FaxTimeFormat(
  LCID    Locale,             // locale
  DWORD   dwFlags,            // options
  CONST   SYSTEMTIME *lpTime, // time
  LPCTSTR lpFormat,           // time format string
  LPTSTR  lpTimeStr,          // formatted string buffer
  int     cchTime             // size of string buffer
)
{
    int nRes = 0;
    TCHAR szTime[MAX_PATH];

    nRes = GetTimeFormat(Locale, dwFlags, lpTime, lpFormat, szTime, min(cchTime, MAX_PATH));
    if(0 == nRes)
    {
        return nRes;
    }

    if(0 == cchTime)
    {
        return ++nRes;
    }

    if(IsRTLLanguageInstalled())
    {
        if(StrHasRTLChar(Locale, szTime))
        {
            _sntprintf(lpTimeStr, cchTime, TEXT("%c%s"), UNICODE_RLM, szTime);
        }
        else
        {
            _sntprintf(lpTimeStr, cchTime, TEXT("%c%s"), UNICODE_LRM, szTime);
        }
    }
    else
    {
        _tcsncpy(lpTimeStr, szTime, cchTime);
    }

    return nRes;

} // FaxTimeFormat


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsRTLLanguageInstalled
//
//  Purpose:        
//                  Determine if RTL Language Group is Installed
//
//  Return Value:
//                  TRUE if RTL Language Group is Installed
//                  FALSE otherwise 
///////////////////////////////////////////////////////////////////////////////////////
BOOL
IsRTLLanguageInstalled()
{

#if(WINVER >= 0x0500)

    if(IsValidLanguageGroup(LGRPID_ARABIC, LGRPID_INSTALLED) ||
       IsValidLanguageGroup(LGRPID_HEBREW, LGRPID_INSTALLED))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }	

#endif /* WINVER >= 0x0500 */

    return FALSE;
} // IsRTLLanguageInstalled
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\debug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file implements the debug code for the
    fax project.  All components that require
    debug prints, asserts, etc.

Author:

    Wesley Witt (wesw) 22-Dec-1995

History:
    1-Sep-1999 yossg  add ArielK additions, activate DebugLogPrint
                      only while Setup g_fIsSetupLogFileMode
.
.

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>

#include "faxreg.h"
#include "faxutil.h"

BOOL        ConsoleDebugOutput    = FALSE;
INT         FaxDebugLevel         = -1;
DWORD       FaxDebugLevelEx       =  -1;
DWORD       FaxFormatLevelEx      =  -1;
DWORD       FaxContextLevelEx     =  -1;

FILE *      g_pLogFile            = NULL;
static BOOL g_fIsSetupLogFileMode = FALSE;

HANDLE      g_hLogFile            = INVALID_HANDLE_VALUE;
LONG        g_iLogFileRefCount    = 0;

BOOL debugOutputFileString(LPCTSTR szMsg);


VOID
StartDebugLog(LPTSTR lpszSetupLogFile)
{
   g_fIsSetupLogFileMode = TRUE;
   if (!g_pLogFile)
   {
      g_pLogFile = _tfopen(lpszSetupLogFile, TEXT("w"));
   }
}

VOID
CloseDebugLog()
{
   g_fIsSetupLogFileMode = FALSE;
   if (!g_pLogFile)
   {
      fclose(g_pLogFile);
   }
}


VOID
DebugLogPrint(
    LPCTSTR buf
    )
{
   if (g_pLogFile)
    {
       _fputts(TEXT("FAX Server Setup Log: "), g_pLogFile);
       _fputts( buf, g_pLogFile);
       fflush(g_pLogFile);
    }
}

//*****************************************************************************
//* Name:   debugOpenLogFile
//* Author: Mooly Beery (MoolyB), May, 2000
//*****************************************************************************
//* DESCRIPTION:
//*     Creates a log file which accepts the debug output
//*     FormatLevelEx should be set in the registry to include DBG_PRNT_TO_FILE
//*
//* PARAMETERS:
//*     [IN] LPCTSTR lpctstrFilename:
//*         the filename which will be created in the temporary folder
//*
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*         this function should be used together with CloseLogFile()
//*****************************************************************************
BOOL debugOpenLogFile(LPCTSTR lpctstrFilename)
{
    TCHAR szFilename[MAX_PATH]      = {0};
    TCHAR szTempFolder[MAX_PATH]    = {0};
    TCHAR szPathToFile[MAX_PATH]    = {0};

    if (g_hLogFile!=INVALID_HANDLE_VALUE)
    {
        InterlockedIncrement(&g_iLogFileRefCount);
        return TRUE;
    }

    if (!lpctstrFilename)
    {
        return FALSE;
    }

     // first expand the filename
    if (ExpandEnvironmentStrings(lpctstrFilename,szFilename,MAX_PATH)==0)
    {
        return FALSE;
    }
    // is this is a file description or a complete path to file
    if (_tcschr(szFilename,_T('\\'))==NULL)
    {
        // this is just the file's name, need to add the temp folder to it.
        if (GetTempPath(MAX_PATH,szTempFolder)==0)
        {
            return FALSE;
        }

        _tcsncpy(szPathToFile,szTempFolder,MAX_PATH-1);
        _tcsncat(szPathToFile,szFilename,MAX_PATH-_tcslen(szPathToFile)-1);
    }
    else
    {
        // this is the full path to the log file, use it.
        _tcsncpy(szPathToFile,szFilename,MAX_PATH-1);
    }

    g_hLogFile = ::CreateFile(  szPathToFile,
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if (g_hLogFile==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    DWORD dwFilePointer = ::SetFilePointer(g_hLogFile,0,NULL,FILE_END);
    if (dwFilePointer==INVALID_SET_FILE_POINTER)
    {
        ::CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    InterlockedExchange(&g_iLogFileRefCount,1);
    return TRUE;
}

//*****************************************************************************
//* Name:   CloseLogFile
//* Author: Mooly Beery (MoolyB), May, 2000
//*****************************************************************************
//* DESCRIPTION:
//*     Closes the log file which accepts the debug output
//*
//* PARAMETERS:
//*
//* RETURN VALUE:
//*
//* Comments:
//*         this function should be used together with OpenLogFile()
//*****************************************************************************
void debugCloseLogFile()
{
    InterlockedDecrement(&g_iLogFileRefCount);
    if (g_iLogFileRefCount==0)
    {
        if (g_hLogFile!=INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(g_hLogFile);
            g_hLogFile = INVALID_HANDLE_VALUE;
        }
    }
}

DWORD
GetDebugLevel(
    VOID
    )
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_FAXSERVER,
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBGLEVEL,
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}


DWORD
GetDebugLevelEx(
    VOID
    )
{
    DWORD RetVal = 0;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    // first let's set the defaults

    FaxDebugLevelEx       =  0;  // Default get no debug output
    FaxFormatLevelEx      =  DBG_PRNT_ALL_TO_STD;
    FaxContextLevelEx     =  DEBUG_CONTEXT_ALL;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_FAXSERVER,
                     &hkey);

    if (err != ERROR_SUCCESS)
        return RetVal;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBGLEVEL_EX,
                          0,
                          &type,
                          (LPBYTE)&RetVal,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
        RetVal = 0;
    }

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBGFORMAT_EX,
                          0,
                          &type,
                          (LPBYTE)&FaxFormatLevelEx,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
        FaxFormatLevelEx = DBG_PRNT_ALL_TO_STD;
    }

    err = RegQueryValueEx(hkey,
                          REGVAL_DBGCONTEXT_EX,
                          0,
                          &type,
                          (LPBYTE)&FaxContextLevelEx,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
        FaxContextLevelEx = DEBUG_CONTEXT_ALL;
    }

    RegCloseKey(hkey);
    return RetVal;
}

void dprintfex
(
    DEBUG_MESSAGE_CONTEXT nMessageContext,
    DEBUG_MESSAGE_TYPE nMessageType,
    LPCTSTR lpctstrDbgFunctionName,
    LPCTSTR lpctstrFile,
    DWORD   dwLine,
    LPCTSTR lpctstrFormat,
    ...
)
{
    TCHAR buf[2048];
    DWORD len;
    va_list arg_ptr;
    TCHAR szExtFormat[2048];
    LPTSTR lptstrMsgPrefix;
    TCHAR szTimeBuff[10];
    TCHAR szDateBuff[10];
    DWORD dwInd = 0;
    TCHAR bufLocalFile[MAX_PATH];
    LPTSTR lptstrShortFile = NULL;
    LPTSTR lptstrProject = NULL;

    DWORD dwLastError = GetLastError();

    static BOOL bChecked = FALSE;

    if (!bChecked)
    {
        if (FaxDebugLevelEx==-1)
            FaxDebugLevelEx = GetDebugLevelEx();
        bChecked = TRUE;
    }

    if (FaxDebugLevelEx == 0)
    {
        goto exit;
    }

    if (!(nMessageType & FaxDebugLevelEx))
    {
        goto exit;
    }

    if (!(nMessageContext & FaxContextLevelEx))
    {
        goto exit;
    }

    switch (nMessageType)
    {
        case DEBUG_VER_MSG:
            lptstrMsgPrefix=TEXT("   ");
            break;
        case DEBUG_WRN_MSG:
            lptstrMsgPrefix=TEXT("WRN");
            break;
        case DEBUG_ERR_MSG:
            lptstrMsgPrefix=TEXT("ERR");
            break;
        default:
            _ASSERT(FALSE);
            lptstrMsgPrefix=TEXT("   ");
            break;
    }

    // Date & Time stamps
    if( FaxFormatLevelEx & DBG_PRNT_TIME_STAMP )
    {
        dwInd += _stprintf(&szExtFormat[dwInd],
                          TEXT("[%-8s %-8s]"),
                          _tstrdate(szDateBuff),
                          _tstrtime(szTimeBuff));
    }
    // Tick Count
    if( FaxFormatLevelEx & DBG_PRNT_TICK_COUNT )
    {
        dwInd += _stprintf(&szExtFormat[dwInd],
                          TEXT("[%09d]"),
                          GetTickCount());
    }
    // Thread ID
    if( FaxFormatLevelEx & DBG_PRNT_THREAD_ID )
    {
        dwInd += _stprintf(&szExtFormat[dwInd],
                          TEXT("[0x%05x]"),
                          GetCurrentThreadId());
    }
    // Message type
    if( FaxFormatLevelEx & DBG_PRNT_MSG_TYPE )
    {
        dwInd += _stprintf(&szExtFormat[dwInd],
                          TEXT("[%s]"),
                          lptstrMsgPrefix);
    }
    // filename & line number
    if( FaxFormatLevelEx & DBG_PRNT_FILE_LINE )
    {
        _tcsncpy(bufLocalFile,lpctstrFile,MAX_PATH);
        bufLocalFile[MAX_PATH-1] = _T('\0');
        lptstrShortFile = _tcsrchr(bufLocalFile,_T('\\'));
        if (lptstrShortFile)
        {
            (*lptstrShortFile) = _T('\0');
            lptstrProject = _tcsrchr(bufLocalFile,_T('\\'));
            (*lptstrShortFile) = _T('\\');
            if (lptstrProject)
                lptstrProject = _tcsinc(lptstrProject);
        }

        dwInd += _stprintf( &szExtFormat[dwInd],
                            TEXT("[%-20s][%-4ld]"),
                            lptstrProject,
                            dwLine);
    }
    // Module name
    if( FaxFormatLevelEx & DBG_PRNT_MOD_NAME )
    {
        dwInd += _stprintf(&szExtFormat[dwInd],
                          TEXT("[%-20s]"),
                          lpctstrDbgFunctionName);
    }
    // Now comes the actual message
    va_start(arg_ptr, lpctstrFormat);
    _vsntprintf(buf, sizeof(buf)/sizeof(TCHAR), lpctstrFormat, arg_ptr);
    len = _tcslen( buf );
    dwInd += _stprintf( &szExtFormat[dwInd],
                        TEXT("%s"),
                        buf);

    _stprintf( &szExtFormat[dwInd],TEXT("\r\n"));

    if( FaxFormatLevelEx & DBG_PRNT_TO_STD )
    {
        OutputDebugString( szExtFormat);
    }

    if ( FaxFormatLevelEx & DBG_PRNT_TO_FILE )
    {
        if (g_hLogFile!=INVALID_HANDLE_VALUE)
        {
            debugOutputFileString(szExtFormat);
        }
    }

exit:
    SetLastError (dwLastError);   // dprintfex will not change LastError
    return;
}

BOOL debugOutputFileString(LPCTSTR szMsg)
{
    BOOL bRes = FALSE;
    //
    // Attempt to add the line to a log file
    //
#ifdef UNICODE
    char sFileMsg[2000];

    int Count = WideCharToMultiByte(
        CP_ACP,
        0,
        szMsg,
        -1,
        sFileMsg,
        sizeof(sFileMsg)/sizeof(sFileMsg[0]),
        NULL,
        NULL
        );

    if (Count==0)
    {
        return bRes;
    }
#else
    const char* sFileMsg = szMsg;
#endif

    DWORD dwNumBytesWritten = 0;
    DWORD dwNumOfBytesToWrite = strlen(sFileMsg);
    if (!::WriteFile(g_hLogFile,sFileMsg,dwNumOfBytesToWrite,&dwNumBytesWritten,NULL))
    {
        return bRes;
    }

    if (dwNumBytesWritten!=dwNumOfBytesToWrite)
    {
        return bRes;
    }

    //    ::FlushFileBuffers(g_hLogFile);

    bRes = TRUE;
    return bRes;
}

void
fax_dprintf(
    LPCTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    DWORD len;
    va_list arg_ptr;
    static BOOL bChecked = FALSE;

    if (!bChecked) {
        FaxDebugLevel = (INT) GetDebugLevel();
        bChecked = TRUE;
    }

    if (!g_fIsSetupLogFileMode)
    {
        if (FaxDebugLevel <= 0)
        {
            return;
        }
    }

    va_start(arg_ptr, Format);

    _vsntprintf(buf, sizeof(buf)/sizeof(TCHAR), Format, arg_ptr);


    len = _tcslen( buf );
    if (buf[len-1] != TEXT('\n')) {
        buf[len]   =  TEXT('\r');
        buf[len+1] =  TEXT('\n');
        buf[len+2] =  0;
    }

    OutputDebugString( buf );
    if (g_fIsSetupLogFileMode)
    {
        DebugLogPrint(buf);
    }
}


VOID
AssertError(
    LPCTSTR Expression,
    LPCTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    fax_dprintf(
        TEXT("Assertion error: [%s]  %s @ %d\n"),
        Expression,
        File,
        LineNumber
        );

#ifdef _DEBUG
    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
#endif // _DEBUG
}

void debugSetProperties(DWORD dwLevel,DWORD dwFormat,DWORD dwContext)
{
    FaxDebugLevelEx       =  dwLevel;
    FaxFormatLevelEx      =  dwFormat;
    FaxContextLevelEx     =  dwContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\print.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This file implements basic printer functionality

Author:

    Asaf Shaar (asafs) 28-Nov-1999

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <WinSpool.h>

#include <faxutil.h>
#include <faxreg.h>
#include <shlobj.h>
/*++

Routine Description:

    Wrapper function for EnumPrinters API

Arguments:

    pServerName - Server name (NULL for current server)
    dwLevel       - Specifies PRINTER_INFO level to be returned
    pcPrinters  - Returns the number of printers found
    dwFlags       - Specifies the type of printer objects to be enumerated

    level -
    pCount -

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   dwLevel,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    )
{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cb = 0;
    DWORD   Error = ERROR_SUCCESS;

    if (!dwFlags)
    {
        dwFlags = PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS;
    }

    if (!EnumPrinters(dwFlags, pServerName, dwLevel, NULL, 0, &cb, pcPrinters))
    {
        Error = GetLastError();

        if ( Error == ERROR_INSUFFICIENT_BUFFER && (pPrinterInfo = (PBYTE) MemAlloc(cb)) != NULL)
        {
            if (EnumPrinters(dwFlags, pServerName, dwLevel, pPrinterInfo, cb, &cb, pcPrinters))
            {
                return pPrinterInfo;
            }
            Error = GetLastError();
        }
    }

    MemFree(pPrinterInfo);
    SetLastError(Error);
    return NULL;
}

/*++

Routine Description:

    Returns the name of the first LOCAL Fax printer on the local machine

Arguments:

    OUT lptstrPrinterName - A buffer to hold the returned printer name.
    IN dwPrintNameInChars - The size of the buffer in characters (including the space for terminating null)
Return Value:
    TRUE if the function succeeded and found a fax printer.
    FALSE if the function failed or did not find a fax printer.
    If a printer was not found then GetLastError() will report ERROR_PRINTER_NOT_FOUND.

--*/
BOOL
GetFirstLocalFaxPrinterName(
    OUT LPTSTR lptstrPrinterName,
    IN DWORD dwMaxLenInChars)
{
    PPRINTER_INFO_2 pPrinterInfo = NULL;
    DWORD dwNumPrinters;
    DWORD dwPrinter;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("GetFirstLocalFaxPrinterName"));

    SetLastError (ERROR_SUCCESS);
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_LOCAL
                                                    );
    if (!pPrinterInfo)
    {
        //
        // Either error on no local printers
        //
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            //
            // Not an error - no local printers
            //
            SetLastError (ERROR_PRINTER_NOT_FOUND);
            return FALSE;
        }
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MyEnumPrinters() failed (ec: %ld)"),
            ec);
        goto Error;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        if (!_tcscmp(pPrinterInfo[dwPrinter].pDriverName,FAX_DRIVER_NAME))
        {
            memset(lptstrPrinterName,0,dwMaxLenInChars*sizeof(TCHAR));
            _tcsncpy(lptstrPrinterName,pPrinterInfo[dwPrinter].pPrinterName,dwMaxLenInChars-1);
            goto Exit;
        }
    }

    ec = ERROR_PRINTER_NOT_FOUND;
    goto Error;


Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    MemFree(pPrinterInfo);
    pPrinterInfo = NULL;
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
        return FALSE;
    }
   return (ERROR_SUCCESS == ec);

}


PVOID
MyEnumDrivers3(
    LPTSTR pEnvironment,
    PDWORD pcDrivers
    )
{
    LPBYTE   pDriverInfo = NULL;
    DWORD   cb = 0;


    if (!EnumPrinterDrivers(NULL, pEnvironment, 3, NULL , NULL , &cb, pcDrivers ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = (LPBYTE) MemAlloc(cb)) &&
        EnumPrinterDrivers(NULL, pEnvironment, 3, pDriverInfo, cb, &cb, pcDrivers ))
    {
        return pDriverInfo;
    }

    MemFree(pDriverInfo);
    return NULL;
}



//
//
// Function:    GetPrinterInfo
// Description: Returns a pointer to PRINTER_INFO_2 of the specified printer name.
//              If the printer was not found or there was an error than the function
//              return NULL. To get extended error information, call GetLastError().
//
// Remarks:     The caller must release the allocated memory with MemFree()
//
// Args:        LPTSTR lptstrPrinterName : The name of the printer.
//
// Author:      AsafS



PPRINTER_INFO_2
GetFaxPrinterInfo(
    LPCTSTR lptstrPrinterName
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetPrinterInfo"))
    DWORD ec = ERROR_SUCCESS;

    PPRINTER_INFO_2 pPrinterInfo = NULL;
    DWORD dwNeededSize = 0;
    BOOL result = FALSE;

    HANDLE hPrinter = NULL;

    if (!OpenPrinter(
        (LPTSTR) lptstrPrinterName,
        &hPrinter,
        NULL))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("A printer with %s name was not found (ec: %ld)."),
            lptstrPrinterName,
            GetLastError()
            );
        goto Exit;
    }


    result = GetPrinter(
        hPrinter,
        2,
        NULL,
        0,
        &dwNeededSize
        );

    if (!result)
    {
        if ( (ec = GetLastError()) != ERROR_INSUFFICIENT_BUFFER )
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetPrinter return an unexpected result or error (ec: %ld)."),
            ec
            );
            goto Exit;
        }
    }

    pPrinterInfo = (PPRINTER_INFO_2) MemAlloc(dwNeededSize);
    if (!pPrinterInfo)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    result = GetPrinter(
        hPrinter,
        2,
        (LPBYTE) pPrinterInfo,
        dwNeededSize,
        &dwNeededSize
    );

    if (!result)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetPrinter failed in second call (ec: %ld)."),
            ec
            );
        MemFree(pPrinterInfo);
        pPrinterInfo = NULL;
            goto Exit;
    }

Exit:
    SetLastError(ec);

    if (hPrinter)
    {
        if (!ClosePrinter(hPrinter))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ClosePrinter failed with %ld"),
                GetLastError ()
                );
        }
    }
    return pPrinterInfo;
}   // GetFaxPrinterInfo




PVOID
MyEnumMonitors(
    PDWORD  pcMonitors
    )
{
    PBYTE   pMonitorInfo = NULL;
    DWORD   cb;


    if (!EnumMonitors(NULL, 2, 0, 0, &cb, pcMonitors ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pMonitorInfo = (PBYTE) MemAlloc(cb)) &&
        EnumMonitors(NULL, 2, pMonitorInfo, cb, &cb, pcMonitors ))
    {
        return (PVOID) pMonitorInfo;
    }

    MemFree(pMonitorInfo);
    return NULL;
}

BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    )
{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    DWORD Size;
    DWORD Rval = FALSE;
    LPDRIVER_INFO_2 DriverInfo = NULL;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( _T("OpenPrinter() failed, ec=%d"), GetLastError() ));
        return FALSE;

    }

    Size = 4096;
    DriverInfo = (LPDRIVER_INFO_2) MemAlloc( Size );
    if (!DriverInfo) {
        DebugPrint(( _T("Memory allocation failed, size=%d"), Size ));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    Rval = GetPrinterDriver(
        hPrinter,
        NULL,
        2,
        (LPBYTE) DriverInfo,
        Size,
        &Size
        );
    if (!Rval) {
        DebugPrint(( _T("GetPrinterDriver() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    if (_tcscmp( DriverInfo->pName, FAX_DRIVER_NAME ) == 0) {
        Rval = TRUE;
    } else {
        Rval = FALSE;
    }

exit:

    MemFree( DriverInfo );
    ClosePrinter( hPrinter );
    return Rval;
}


DWORD
IsLocalFaxPrinterInstalled(
    LPBOOL lpbLocalFaxPrinterInstalled
    )
/*++

Routine name : IsLocalFaxPrinterInstalled

Routine description:

    Checks if a local fax printer is installed and not marked for deletion.

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpbLocalFaxPrinterInstalled   [out]    - Result flag

Return Value:

    Standard Win32 error code

--*/
{
    TCHAR tszPrinterName[MAX_PATH * 3] = TEXT("\0");
    DWORD dwErr;
    PPRINTER_INFO_2 pi2 = NULL;
    DEBUG_FUNCTION_NAME(TEXT("IsLocalFaxPrinterInstalled"))

    if (!GetFirstLocalFaxPrinterName (tszPrinterName, sizeof (tszPrinterName) / sizeof (tszPrinterName[0])))
    {
        dwErr = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFirstLocalFaxPrinterName failed with %ld."),
            dwErr);
        if (ERROR_PRINTER_NOT_FOUND == dwErr)
        {
            //
            // Local fax printer is not installed
            //
            *lpbLocalFaxPrinterInstalled = FALSE;
            return ERROR_SUCCESS;
        }
        Assert (ERROR_SUCCESS != dwErr);
        return dwErr;
    }
    //
    // Local fax printer is installed
    // Let's see if it is PRINTER_STATUS_PENDING_DELETION.
    // If so, let's return FALSE because the printer will be gone soon.
    // If someone will call AddPrinter because we return FALSE, it's OK. See AddPrinter() remarks.
    //
    Assert (lstrlen (tszPrinterName));
    pi2 = GetFaxPrinterInfo (tszPrinterName);
    if (!pi2)
    {
        dwErr = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxPrinterInfo failed with %ld."),
            dwErr);
        //
        // Printer is installed but somehow I can't get it's info - weird
        //
        Assert (ERROR_SUCCESS != dwErr);
        return dwErr;
    }
    if ((pi2->Status) & PRINTER_STATUS_PENDING_DELETION)
    {
        //
        // Printer is there but is marked for deletion
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Printer %s is installed but marked for deletion. Reported as non-existant"),
            tszPrinterName);
        *lpbLocalFaxPrinterInstalled = FALSE;
    }
    else
    {
        *lpbLocalFaxPrinterInstalled = TRUE;
    }
    MemFree (pi2);
    return ERROR_SUCCESS;
}   // IsLocalFaxPrinterInstalled


DWORD
IsLocalFaxPrinterShared (
    LPBOOL lpbShared
    )
/*++

Routine name : IsLocalFaxPrinterShared

Routine description:

    Detects if the local fax printer is shared

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpbShared      [out]    - Sharing flag

Return Value:

    Standard Win32 error code

--*/
{
    TCHAR tszPrinterName[MAX_PATH * 3];
    DWORD dwErr;
    PPRINTER_INFO_2 pInfo2;
    DEBUG_FUNCTION_NAME(TEXT("IsLocalFaxPrinterShared"))

    if (!GetFirstLocalFaxPrinterName (tszPrinterName, sizeof (tszPrinterName) / sizeof (tszPrinterName[0])))
    {
        dwErr = GetLastError ();
        if (ERROR_PRINTER_NOT_FOUND == dwErr)
        {
            //
            // Local fax printer is not installed
            //
            *lpbShared = FALSE;
            return ERROR_SUCCESS;
        }
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFirstLocalFaxPrinterName failed with %ld."),
            dwErr);
        return dwErr;
    }
    pInfo2 = GetFaxPrinterInfo (tszPrinterName);
    if (!pInfo2)
    {
        dwErr = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxPrinterInfo failed with %ld."),
            dwErr);
        return dwErr;
    }
    *lpbShared = ((pInfo2->Attributes) & PRINTER_ATTRIBUTE_SHARED) ? TRUE : FALSE;
    MemFree (pInfo2);
    return ERROR_SUCCESS;
}   // IsLocalFaxPrinterShared

DWORD
AddLocalFaxPrinter (
    LPCTSTR lpctstrPrinterName,
    LPCTSTR lpctstrPrinterDescription
)
/*++

Routine name : AddLocalFaxPrinter

Routine description:

    Adds a local fax printer

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpctstrPrinterName            [in]     - Printer name
    lpctstrPrinterDescription     [in]     - Printer comments (description)

Return Value:

    Standard Win32 error code

Remarks:

    This function should not be called if a local fax printer is installed.

--*/
{
    DWORD           ec = ERROR_SUCCESS;
    HANDLE          hPrinter = NULL;
    PRINTER_INFO_2  PrinterInfo2 = {0};
    BOOL            bLocalPrinterInstalled;
    DWORD           dwAttributes = PRINTER_ATTRIBUTE_LOCAL | PRINTER_ATTRIBUTE_FAX;
    LPCTSTR         lpctstrShareName = NULL;

    DEBUG_FUNCTION_NAME(TEXT("AddLocalFaxPrinter"))

    ec = IsLocalFaxPrinterInstalled (&bLocalPrinterInstalled);
    if (ERROR_SUCCESS == ec && bLocalPrinterInstalled)
    {
        //
        // Local fax printer already installed
        //
        ASSERT_FALSE;
        return ec;
    }


    // check if this is Windows XP Personnal or Professional
    // if it is do not share printer
    if (!IsDesktopSKU())
    {
        dwAttributes |= PRINTER_ATTRIBUTE_SHARED;
        lpctstrShareName = lpctstrPrinterName;
    }

    PrinterInfo2.pServerName        = NULL;
    PrinterInfo2.pPrinterName       = (LPTSTR) lpctstrPrinterName;
    PrinterInfo2.pPortName          = FAX_MONITOR_PORT_NAME;
    PrinterInfo2.pDriverName        = FAX_DRIVER_NAME;
    PrinterInfo2.pPrintProcessor    = TEXT("WinPrint");
    PrinterInfo2.pDatatype          = TEXT("RAW");
    PrinterInfo2.Attributes         = dwAttributes;
    PrinterInfo2.pShareName         = (LPTSTR) lpctstrShareName;
    PrinterInfo2.pComment           = (LPTSTR) lpctstrPrinterDescription;

    hPrinter = AddPrinter(NULL,
                          2,
                          (LPBYTE)&PrinterInfo2);

    if (hPrinter == NULL)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AddPrinter failed with %ld."),
            ec);
    }
    else
    {
        if (!ClosePrinter(hPrinter))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ClosePrinter failed with %ld."),
                GetLastError ());
        }
        hPrinter = NULL;
        RefreshPrintersAndFaxesFolder();
    }
    return ec;
}   // AddLocalFaxPrinter


//*********************************************************************************
//* Name:   ParamTagsToString()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Writes a collection of tag parameters and values in the format of a parameter
//*     string into a caller provided buffer.
//      Reports the size of the tagged string.
//* PARAMETERS:
//*     lpTagMap
//*         A pointer to an array of FAX_TAG_MAP_ENTRY structures that contain the
//*         tag names and values.
//*     dwTagCount
//*         The number of entries in the tag map array.
//*     lpTargetBuf
//*         A pointer to a buffer where the tag value string will be placed.
//*         The size of this buffer must be big enough to hold the resulting string
//          including a terminating NULL char.
//*         If this parameter is NULL the function will not generate the tag value
//*         string and only report its size in *lpdwSize;
//*     lpdwSize
//*         A pointer to a DWORD that will accept the size of the resulting
//*         tagged string in BYTES. The size DOES NOT INCLUDE the terminating NULL char.
//* RETURN VALUE:
//*     NONE
//* REMARKS:
//*     The format of the resulting string is:
//*         Tag1Value1Tag2Value2....TagNValueN'\0'
//*********************************************************************************
void
ParamTagsToString(
    FAX_TAG_MAP_ENTRY * lpTagMap,
    DWORD dwTagCount,
    LPTSTR lpTargetBuf,
    LPDWORD lpdwSize)
{
    DWORD index;
    LPTSTR p;

    DWORD   dwSize = 0;

    //
    // Calculate string size WITHOUT termianting NULL
    //
    for (index=0; index <dwTagCount; index++)
    {
         if (lpTagMap[index].lptstrValue && !IsEmptyString(lpTagMap[index].lptstrValue))
         {
            dwSize += _tcslen(lpTagMap[index].lptstrTagName)*sizeof(TCHAR) + _tcslen(lpTagMap[index].lptstrValue)*sizeof(TCHAR);
        }
    }

    if  (lpTargetBuf)
    {
        //
        //  Check that size of the Target Buffer is not smaller then the calculated size
        //
        Assert(dwSize <= *lpdwSize);
        //
        // Assemble fax job parameters into a single tagged string at the target buffer
        // there is a terminating NULL at the end of the string !!!
        //
        p=lpTargetBuf;

        for (index=0; index < dwTagCount; index++)
        {
            if (lpTagMap[index].lptstrValue && !IsEmptyString(lpTagMap[index].lptstrValue))
            {
                _tcscpy(p, lpTagMap[index].lptstrTagName);
                p += _tcslen(p); // The value string runs over the NULL char of the tag string
                _tcscpy(p, lpTagMap[index].lptstrValue);
                p += _tcslen(p);
            }
        }
    }
    //
    //  Return the size of the string
    //
    *lpdwSize = dwSize;
}

HRESULT
RefreshPrintersAndFaxesFolder ()
/*++

Routine name : RefreshPrintersAndFaxesFolder

Routine description:

    Notifies the 'Printers and Faxes' shell folder to refresh itself

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:


Return Value:

    Standard HRESULT

--*/
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlPF = NULL;
    LPMALLOC pShellMalloc = NULL;
    DEBUG_FUNCTION_NAME(TEXT("RefreshPrintersAndFaxesFolder"));

    //
    // First obtail the shell alloctaor
    //
    hr = SHGetMalloc (&pShellMalloc);
    if (SUCCEEDED(hr))
    {
        //
        // Get the printer's folder PIDL
        //
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_PRINTERS, &pidlPF);

        if (SUCCEEDED(hr))
        {
            //
            // Requets refresh
            //
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, pidlPF, NULL);
            //
            // Release the returned PIDL by using the shell allocator
            //
            pShellMalloc->Free(pidlPF);
        }
        //
        // Release the shell allocator
        //
        pShellMalloc->Release();
    }
    return hr;
}   // RefreshPrintersAndFaxesFolder

#ifdef UNICODE

PPRINTER_NAMES
CollectPrinterNames (
    LPDWORD lpdwNumPrinters,
    BOOL    bFilterOutFaxPrinters
)
/*++

Routine name : CollectPrinterNames

Routine description:

    Creates a list of printer names for all visible local and remote printers

Author:

    Eran Yariv (EranY), Apr, 2001

Arguments:

    lpdwNumPrinters       [out]    - Number of elements in the list
    bFilterOutFaxPrinters [in]     - If TRUE, fax printers are not returned in the list

Return Value:

    Allocated list of printers names. If NULL, an error has occurred - check LastError.
    Use ReleasePrinterNames() to release allocated value.

--*/
{
    DWORD dwPrinter;
    DWORD dwNumPrinters;
    DWORD dwIndex = 0;
    BOOL  bSuccess = FALSE;
    PPRINTER_INFO_2 pPrinterInfo = NULL;
    PPRINTER_NAMES pRes = NULL;
    DEBUG_FUNCTION_NAME(TEXT("ReleasePrinterNames"));

    SetLastError (ERROR_SUCCESS);
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,               // Local machine
                                                    2,                  // Level 2
                                                    &dwNumPrinters,     // [out] Number of printers found
                                                    0                   // Both local and remote
                                                    );
    if (!pPrinterInfo)
    {
        //
        // Either error on no printers
        //
        DWORD ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            //
            // Not an error - no printers
            //
            SetLastError (ERROR_PRINTER_NOT_FOUND);
            return NULL;
        }
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MyEnumPrinters() failed (ec: %ld)"),
            ec);
        return NULL;
    }

    Assert (dwNumPrinters > 0);

    if (bFilterOutFaxPrinters)
    {
        //
        // Counter number of printers w/out the fax printer(s)
        //
        DWORD dwNewPrintersCount = 0;
        for (dwPrinter = 0; dwPrinter < dwNumPrinters; dwPrinter++)
        {
            if (_tcscmp(pPrinterInfo[dwPrinter].pDriverName,FAX_DRIVER_NAME))
            {
                //
                // Not a fax printer
                //
                dwNewPrintersCount++;
            }
        }
        if (!dwNewPrintersCount)
        {
            //
            // Only fax printers - return NULL
            //
            SetLastError (ERROR_PRINTER_NOT_FOUND);
            goto exit;
        }
        *lpdwNumPrinters = dwNewPrintersCount;
    }
    else
    {
        *lpdwNumPrinters = dwNumPrinters;
    }
    pRes = (PPRINTER_NAMES)MemAlloc (sizeof (PRINTER_NAMES) * (*lpdwNumPrinters));
    if (!pRes)
    {
        goto exit;
    }
    memset (pRes, 0, sizeof (PRINTER_NAMES) * (*lpdwNumPrinters));

    for (dwPrinter = 0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        if (bFilterOutFaxPrinters && !_tcscmp(pPrinterInfo[dwPrinter].pDriverName,FAX_DRIVER_NAME))
        {
            //
            // This is a fax printer and filtering is on - skip it
            //
            continue;
        }

        pRes[dwIndex].lpcwstrDisplayName = StringDup (pPrinterInfo[dwPrinter].pPrinterName);
        if (!pRes[dwIndex].lpcwstrDisplayName)
        {
            goto exit;
        }
        if (pPrinterInfo[dwPrinter].pServerName)
        {
            //
            // Remote printer
            //
            WCHAR wszShare[MAX_PATH];
            //
            // Server name must begin with '\\'
            //
            Assert (lstrlen (pPrinterInfo[dwPrinter].pServerName) > 2)
            Assert ((TEXT('\\') == pPrinterInfo[dwPrinter].pServerName[0]) &&
                    (TEXT('\\') == pPrinterInfo[dwPrinter].pServerName[1]));
            //
            // Share name cannot be NULL or empty string
            //
            Assert (pPrinterInfo[dwPrinter].pShareName && lstrlen(pPrinterInfo[dwPrinter].pShareName));
            //
            // Compose UNC path to print share
            //
            if (0 > _snwprintf (wszShare,
                                ARR_SIZE(wszShare),
                                TEXT("%s\\%s"),
                                pPrinterInfo[dwPrinter].pServerName,
                                pPrinterInfo[dwPrinter].pShareName))
            {
                //
                // Buffer too small
                //
                SetLastError (ERROR_GEN_FAILURE);
                goto exit;
            }
            pRes[dwIndex].lpcwstrPath = StringDup (wszShare);
        }
        else
        {
            //
            // Local printer
            //
            pRes[dwIndex].lpcwstrPath = StringDup (pPrinterInfo[dwPrinter].pPrinterName);
        }
        if (!pRes[dwIndex].lpcwstrPath)
        {
            goto exit;
        }
        dwIndex++;
    }
    Assert (dwIndex == *lpdwNumPrinters);
    bSuccess = TRUE;

exit:
    MemFree (pPrinterInfo);
    if (!bSuccess)
    {
        //
        // Free data and return NULL
        //
        if (pRes)
        {
            ReleasePrinterNames (pRes, *lpdwNumPrinters);
            pRes = NULL;
        }
    }
    return pRes;
}   // CollectPrinterNames

VOID
ReleasePrinterNames (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters
)
/*++

Routine name : ReleasePrinterNames

Routine description:

    Releases the list of printer names returned by CollectPrinterNames().

Author:

    Eran Yariv (EranY), Apr, 2001

Arguments:

    pNames         [in]     - List of printer names
    dwNumPrinters  [in]     - Number of elements in the list

Return Value:

    None.

--*/
{
    DWORD dw;
    DEBUG_FUNCTION_NAME(TEXT("ReleasePrinterNames"));

    if (!dwNumPrinters)
    {
        return;
    }
    Assert (pNames);
    for (dw = 0; dw < dwNumPrinters; dw++)
    {
        MemFree ((PVOID)(pNames[dw].lpcwstrDisplayName));
        pNames[dw].lpcwstrDisplayName = NULL;
        MemFree ((PVOID)(pNames[dw].lpcwstrPath));
        pNames[dw].lpcwstrPath = NULL;
    }
    MemFree ((PVOID)pNames);
}   // ReleasePrinterNames

LPCWSTR
FindPrinterNameFromPath (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrPath
)
{
    DWORD dw;
    DEBUG_FUNCTION_NAME(TEXT("FindPrinterNameFromPath"));

    if (!pNames || !dwNumPrinters)
    {
        return NULL;
    }
    if (!lpcwstrPath)
    {
        return NULL;
    }
    for (dw = 0; dw < dwNumPrinters; dw++)
    {
        if (!lstrcmpi (pNames[dw].lpcwstrPath, lpcwstrPath))
        {
            return pNames[dw].lpcwstrDisplayName;
        }
    }
    return NULL;
}   // FindPrinterNameFromPath

LPCWSTR
FindPrinterPathFromName (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrName
)
{
    DWORD dw;
    DEBUG_FUNCTION_NAME(TEXT("FindPrinterPathFromName"));

    if (!pNames || !dwNumPrinters)
    {
        return NULL;
    }
    if (!lpcwstrName)
    {
        return NULL;
    }
    for (dw = 0; dw < dwNumPrinters; dw++)
    {
        if (!lstrcmpi (pNames[dw].lpcwstrDisplayName, lpcwstrName))
        {
            return pNames[dw].lpcwstrPath;
        }
    }
    return NULL;
}   // FindPrinterPathFromName

#endif // UNICODE

BOOL
VerifyPrinterIsOnline (
    LPCTSTR lpctstrPrinterName
)
/*++

Routine name : VerifyPrinterIsOnline

Routine description:

	Verifies a printer is online and shared

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:

	lpctstrPrinterName   [in]     - Printer name

Return Value:

    TRUE if printer is online and shared, FALSE otherwise.

--*/
{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS pd = {0};
    DEBUG_FUNCTION_NAME(TEXT("VerifyPrinterIsOnline"));

    Assert (lpctstrPrinterName);
    //
    // According to Mark Lawrence (NT PRINT), only by opening the printer in admistrator mode, we actually hit the wire.
    //
    pd.DesiredAccess = PRINTER_ACCESS_ADMINISTER;
    if (!OpenPrinter ((LPTSTR)lpctstrPrinterName, 
                      &hPrinter,
                      &pd))
    {
        DWORD dwRes = GetLastError ();
        if (ERROR_ACCESS_DENIED == dwRes)
        {
            //
            // Printer is there - we just can't admin it.
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("OpenPrinter(%s) failed with ERROR_ACCESS_DENIED - Printer is there - we just can't admin it"),
                lpctstrPrinterName);
            return TRUE;
        }
        if (ERROR_INVALID_PRINTER_NAME  == dwRes)
        {
            //
            // Printer is deleted
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenPrinter(%s) failed with ERROR_INVALID_PRINTER_NAME - Printer is deleted"),
                lpctstrPrinterName);
            return FALSE;
        }
        if (RPC_S_SERVER_UNAVAILABLE == dwRes)
        {
            //
            // Printer is not shared / server is unreachable
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenPrinter(%s) failed with RPC_SERVER_UNAVAILABLE - Printer is not shared / server is unreachable"),
                lpctstrPrinterName);
            return FALSE;
        }
        else
        {
            //
            // Any other error - assume printer is not valid
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenPrinter(%s) failed with %ld - assuming printer is not valid"),
                lpctstrPrinterName,
                dwRes);
            return FALSE;
        }
    }
    //
    // Printer succesfully opened - it's online
    //
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("OpenPrinter(%s) succeeded - Printer is there"),
        lpctstrPrinterName);
    ClosePrinter (hPrinter);
    return TRUE;
}   // VerifyPrinterIsOnline


VOID
FaxPrinterProperty(DWORD dwPage)
/*++

Routine name : FaxPrinterProperty

Routine description:

	Opens fax printer properties sheet

Arguments:

	dwPage   [in] - Initial page number

Return Value:

    none

--*/
{
    HWND hWndFaxMon = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxPrinterProperty"));

    hWndFaxMon = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        SetForegroundWindow(hWndFaxMon);
        SendMessage(hWndFaxMon, WM_FAXSTAT_PRINTER_PROPERTY, dwPage, 0);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FindWindow(FAXSTAT_WINCLASS) failed with %d"), GetLastError());
    }
} // FaxPrinterProperty

DWORD
SetLocalFaxPrinterSharing (
    BOOL bShared
    )
/*++

Routine name : SetLocalFaxPrinterSharing

Routine description:

	Shares or un-shares the local fax printer

Author:

	Eran Yariv (EranY),	Jul, 2001

Arguments:

	bShared      [in]     - Share the printer?

Return Value:

    Standard Win32 error code

--*/
{
    TCHAR tszFaxPrinterName[MAX_PATH *3];
    HANDLE hPrinter = NULL;
    BYTE  aBuf[4096];
    PRINTER_INFO_2 *pInfo = (PRINTER_INFO_2 *)aBuf;
    PRINTER_DEFAULTS pd = {0};
    DWORD dwRequiredSize;
    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("SetLocalFaxPrinterSharing"));

    if (!GetFirstLocalFaxPrinterName (tszFaxPrinterName, ARR_SIZE(tszFaxPrinterName)))
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, TEXT("GetFirstLocalFaxPrinterName failed with %d"), dwRes);
        return dwRes;
    }
    pd.DesiredAccess = PRINTER_ALL_ACCESS;
    if (!OpenPrinter (tszFaxPrinterName, &hPrinter, &pd))
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, TEXT("OpenPrinter failed with %d"), dwRes);
        return dwRes;
    }
    if (!GetPrinter (hPrinter,
                     2,
                     (LPBYTE)pInfo,
                     sizeof (aBuf),
                     &dwRequiredSize))
    {
        dwRes = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwRes)
        {
            //
            // Real error
            //
            DebugPrintEx(DEBUG_ERR, TEXT("GetPrinter failed with %d"), dwRes);
            goto exit;
        }
        pInfo = (PRINTER_INFO_2 *)MemAlloc (dwRequiredSize);
        if (!pInfo)
        {
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR, TEXT("Failed to allocate %d bytes"), dwRequiredSize);
            goto exit;
        }
        if (!GetPrinter (hPrinter,
                         2,
                         (LPBYTE)pInfo,
                         dwRequiredSize,
                         &dwRequiredSize))
        {
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR, TEXT("GetPrinter failed with %d"), dwRes);
            goto exit;
        }
    }
    dwRes = ERROR_SUCCESS;
    if (bShared)
    {
        if (pInfo->Attributes & PRINTER_ATTRIBUTE_SHARED)
        {
            //
            // Printer already shared
            //
            goto exit;
        }
        //
        // Set the sharing bit
        //
        pInfo->Attributes |= PRINTER_ATTRIBUTE_SHARED;
    }
    else
    {
        if (!(pInfo->Attributes & PRINTER_ATTRIBUTE_SHARED))
        {
            //
            // Printer already un-shared
            //
            goto exit;
        }
        //
        // Clear the sharing bit
        //
        pInfo->Attributes &= ~PRINTER_ATTRIBUTE_SHARED;
    }
    if (!SetPrinter (hPrinter,
                     2,
                     (LPBYTE)pInfo,
                     0))
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, TEXT("SetPrinter failed with %d"), dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:

    if (hPrinter)
    {
        ClosePrinter (hPrinter);
    }
    if ((LPBYTE)pInfo != aBuf)
    {
        MemFree (pInfo);
    }
    return dwRes;
}   // SetLocalFaxPrinterSharing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\mem.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    This file implements memory allocation functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <faxutil.h>

static HANDLE gs_hHeap = NULL;
static DWORD  gs_dwHeapFlags;

PMEMALLOC pMemAllocUser;
PMEMREALLOC pMemReAllocUser;
PMEMFREE pMemFreeUser;


#ifdef FAX_HEAP_DEBUG
LIST_ENTRY HeapHeader;
SIZE_T TotalMemory;
SIZE_T MaxTotalMemory;
ULONG MaxTotalAllocs;
VOID PrintAllocations(VOID);
ULONG TotalAllocs;
CRITICAL_SECTION CsHeap;
#endif

#if _CHICAGO_ == 200
    // The code is supposed to run on win9x and win2k
    #define WIN9X
#endif


BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    )
{
    Assert (NULL == gs_hHeap);

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    __try
    {
        InitializeCriticalSection (&CsHeap);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
#endif

    if (!hExistHeap)
    {
        return FALSE;
    }
    else
    {
        gs_hHeap = hExistHeap;
        return TRUE;
    }

}


HANDLE
HeapInitialize(
    HANDLE hHeapUser,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    DWORD Flags
    )
{
    Assert (NULL == gs_hHeap);

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    __try
    {
        InitializeCriticalSection (&CsHeap);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }
    fax_dprintf(TEXT("in HeapInitialize()"));
#endif

    gs_dwHeapFlags = Flags | HEAPINIT_NO_STRINGS;

    if (pMemAlloc && pMemFree)
    {
        pMemAllocUser = pMemAlloc;
        pMemFreeUser = pMemFree;
        gs_hHeap = NULL;
    }
    else
    {
        if (hHeapUser)
        {
            gs_hHeap = hHeapUser;
        }
        else
        {
            gs_hHeap = HeapCreate( 0, HEAP_SIZE, 0 );
        }
        if (!gs_hHeap)
        {
            return NULL;
        }
    }

    return gs_hHeap;
}

BOOL
HeapCleanup(
    VOID
    )
{
#ifdef FAX_HEAP_DEBUG
    PrintAllocations();
#endif
    if (gs_hHeap)
    {
        Assert (gs_hHeap != GetProcessHeap());
        HeapDestroy( gs_hHeap );
#ifdef FAX_HEAP_DEBUG
        DeleteCriticalSection(&CsHeap);
#endif
        gs_hHeap = NULL;
    }
    return TRUE;
}

#ifdef FAX_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
#ifndef WIN9X
    return HeapValidate( gs_hHeap, 0, MemPtr );
#else
    return TRUE;
#endif
}
#endif

PVOID
pMemAlloc(
    SIZE_T AllocSize
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
    PVOID MemPtr;
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
#ifdef UNICODE
    TCHAR fname[MAX_PATH];
#endif
    LPTSTR p = NULL;
    if (pMemAllocUser)
    {
        hb = (PHEAP_BLOCK) pMemAllocUser( AllocSize + sizeof(HEAP_BLOCK) );
    }
    else
    {
        if (gs_hHeap == NULL)
        {
            if (!HeapExistingInitialize(GetProcessHeap()))
            {
                return NULL;
            }
        }

#ifdef FAX_HEAP_DEBUG
        // In win9X this call will return TRUE
        if (!CheckHeap(NULL))
        {
            fax_dprintf((TEXT("HeapValidate() failed")));
            DebugBreak();
        }
#endif

        hb = (PHEAP_BLOCK) HeapAlloc( gs_hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    }
    if (hb)
    {
        TotalAllocs += 1;
        TotalMemory += AllocSize;
        if (TotalMemory > MaxTotalMemory)
        {
            MaxTotalMemory = TotalMemory;
        }
        if (TotalAllocs > MaxTotalAllocs)
        {
            MaxTotalAllocs = TotalAllocs;
        }
        EnterCriticalSection( &CsHeap );
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
#ifdef UNICODE
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            File,
            -1,
            fname,
            sizeof(fname)/sizeof(WCHAR)
            );
        p = wcsrchr( fname, L'\\' );
        if (p)
        {
            wcscpy( hb->File, p+1 );
        }
#else
        p = _tcsrchr( File, TEXT('\\') );
        if (p)
        {
            _tcscpy( hb->File, _tcsinc(p) );
        }
#endif
        MemPtr = (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        LeaveCriticalSection( &CsHeap );
    }
    else
    {
        MemPtr = NULL;
    }
#else
    if (pMemAllocUser)
    {
        MemPtr = (PVOID) pMemAllocUser( AllocSize );
    }
    else
    {
        if (gs_hHeap == NULL)
        {
            if (!HeapExistingInitialize(GetProcessHeap()))
            {
                return NULL;
            }
        }
        MemPtr = (PVOID) HeapAlloc( gs_hHeap, HEAP_ZERO_MEMORY, AllocSize );
    }
#endif

    if (!MemPtr)
    {
        DebugPrint(( TEXT("MemAlloc() failed, size=%d"), AllocSize ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return MemPtr;
}

PVOID
pMemReAlloc(
    PVOID Src,
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
    PVOID MemPtr;
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
#ifdef UNICODE
    TCHAR fname[MAX_PATH];
#endif
    LPTSTR p = NULL;

    EnterCriticalSection( &CsHeap );
    hb = (PHEAP_BLOCK) ((LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK));
    RemoveEntryList( &hb->ListEntry );
    TotalMemory -= hb->Size;
    LeaveCriticalSection( &CsHeap );

    if (pMemReAllocUser)
    {
        hb = (PHEAP_BLOCK) pMemReAllocUser( (LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK),
                                            AllocSize + sizeof(HEAP_BLOCK) );
    }
    else
    {
        if (gs_hHeap == NULL)
        {
            if (!HeapExistingInitialize(GetProcessHeap()))
            {
                return NULL;
            }

        }

        //
        // we have to back up a bit since the actual pointer passed in points to the data after the heap block.
        //
        hb = (PHEAP_BLOCK) HeapReAlloc( gs_hHeap,
                                        HEAP_ZERO_MEMORY,
                                        (LPBYTE)Src-(ULONG_PTR)sizeof(HEAP_BLOCK),
                                        AllocSize + sizeof(HEAP_BLOCK)
                                       );
    }
    if (hb)
    {
        TotalMemory += AllocSize;
        if (TotalMemory > MaxTotalMemory)
        {
            MaxTotalMemory = TotalMemory;
        }

        EnterCriticalSection( &CsHeap );
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;

#ifdef UNICODE
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            File,
            -1,
            fname,
            sizeof(fname)/sizeof(WCHAR)
            );
        p = wcsrchr( fname, L'\\' );
        if (p)
        {
            wcscpy( hb->File, p+1 );
        }
#else
        p = _tcsrchr( File, TEXT('\\') );
        if (p)
        {
            _tcscpy( hb->File, _tcsinc(p) );
        }
#endif
        MemPtr = (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        LeaveCriticalSection( &CsHeap );
    }
    else
    {
        MemPtr = NULL;
    }
#else
    if (pMemReAllocUser)
    {
        MemPtr = (PVOID) pMemReAllocUser( Src, AllocSize );
    }
    else
    {
        if (gs_hHeap == NULL)
        {
            if (!HeapExistingInitialize(GetProcessHeap()))
            {
                return NULL;
            }
        }
        MemPtr = (PVOID) HeapReAlloc( gs_hHeap, HEAP_ZERO_MEMORY, Src, AllocSize );
    }
#endif

    if (!MemPtr)
    {
        DebugPrint(( TEXT("MemReAlloc() failed, src=%x, size=%d"), (ULONG_PTR)Src, AllocSize ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return MemPtr;
}

VOID
pMemFreeForHeap(
    HANDLE gs_hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr)
    {
        return;
    }

    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));

    if (hb->Signature == HEAP_SIG)
    {
        EnterCriticalSection( &CsHeap );
        RemoveEntryList( &hb->ListEntry );
        TotalMemory -= hb->Size;
        TotalAllocs -= 1;
        LeaveCriticalSection( &CsHeap );
    }
    else
    {
        if (gs_dwHeapFlags & HEAPINIT_NO_VALIDATION)
        {
            hb = (PHEAP_BLOCK) MemPtr;
        }
        else
        {
            fax_dprintf( TEXT("MemFree(): Corrupt heap block") );
            PrintAllocations();
            __try
            {
                DebugBreak();
            }
            __except (UnhandledExceptionFilter(GetExceptionInformation()))
            {
            // Nothing to do in here.
            }
        }
    }

    if (pMemFreeUser)
    {
        pMemFreeUser( (PVOID) hb );
    } else
    {
        HeapFree( gs_hHeap, 0, (PVOID) hb );
    }

#else
    if (!MemPtr)
    {
        return;
    }
    if (pMemFreeUser)
    {
        pMemFreeUser( (PVOID) MemPtr );
    }
    else
    {
        HeapFree( gs_hHeap, 0, (PVOID) MemPtr );
    }
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    pMemFreeForHeap( gs_hHeap, MemPtr, Line, File );
#else
    pMemFreeForHeap( gs_hHeap, MemPtr );
#endif
}


#ifdef FAX_HEAP_DEBUG
VOID
PrintAllocations()
/*++

Routine name : PrintAllocations

Routine description:

    Prints the current list of allocations for a given heap

Author:

    Eran Yariv (EranY), Nov, 2000

Arguments:

Return Value:

    None.

--*/
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    LPTSTR                      s;

    DEBUG_FUNCTION_NAME(TEXT("PrintAllocations"));

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("-------------------------------------------------------------------------------------------------------") );
    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Memory Allocations for Heap 0x%08x, Allocs=%d, MaxAllocs=%d, TotalMem=%d, MaxTotalMem=%d"),
            gs_hHeap,
            TotalAllocs,
            MaxTotalAllocs,
            TotalMemory,
            MaxTotalMemory );
    DebugPrintEx(
            DEBUG_MSG,
            TEXT("-------------------------------------------------------------------------------------------------------") );

    EnterCriticalSection( &CsHeap );

    Next = HeapHeader.Flink;
    if (Next == NULL)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Memory allocation list is corrupted !!!"));
        LeaveCriticalSection( &CsHeap );
        return;
    }
    if ((ULONG_PTR)Next == (ULONG_PTR)&HeapHeader)
    {
        DebugPrintEx(
                DEBUG_MSG,
                TEXT("All allocated memory blocks are now free. Good work."));
        LeaveCriticalSection( &CsHeap );
        return;
    }
    while ((ULONG_PTR)Next != (ULONG_PTR)&HeapHeader)
    {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        s = (LPTSTR) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        DebugPrintEx(
                DEBUG_MSG,
                TEXT("%8d %16s @ %5d    0x%08x"),
                hb->Size,
                hb->File,
                hb->Line,
                s );
        if (!(gs_dwHeapFlags & HEAPINIT_NO_STRINGS))
        {
            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT(" \"%s\""),
                    s );
        }
    }

    LeaveCriticalSection( &CsHeap );
}   // PrintAllocations

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\net.c ===
#include <windows.h>
#include <lm.h>         // for NetGetJoinInformation
#include <Lmjoin.h>
#include <safeboot.h>   // SAFEBOOT_* flags

#include "faxutil.h"

// Copy from: shell\shlwapi\apithk.c
//
// checks to see if this machine is a member of a domain or not 
// NOTE: this will always return FALSE for older that win XP!
BOOL 
IsMachineDomainMember()
{
    static BOOL s_bIsDomainMember = FALSE;
    static BOOL s_bDomainCached = FALSE;

    if (IsWinXPOS() && !s_bDomainCached)
    {
        LPWSTR pwszDomain;
        NETSETUP_JOIN_STATUS njs;
        NET_API_STATUS nas;

        nas = NetGetJoinInformation(NULL, &pwszDomain, &njs);
        if (nas == NERR_Success)
        {
            if (pwszDomain)
            {
                NetApiBufferFree(pwszDomain);
            }

            if (njs == NetSetupDomainName)
            {
                // we are joined to a domain!
                s_bIsDomainMember = TRUE;
            }
        }
        
        s_bDomainCached = TRUE;
    }
    
    return s_bIsDomainMember;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//  Copy from:  shell\osshell\security\rshx32\util.cpp
//----------------------------------------------------------------------------

BOOL
IsSafeMode(void)
{
    BOOL    fIsSafeMode = FALSE;
    LONG    ec;
    HKEY    hkey;

    ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        DWORD dwValue;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
                             TEXT("OptionValue"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

        if (ec == NO_ERROR)
        {
            fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey(hkey);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsGuestAccessMode
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//  Copy from:  shell\osshell\security\rshx32\util.cpp
//----------------------------------------------------------------------------

BOOL
IsGuestAccessMode(void)
{
    BOOL fIsGuestAccessMode = FALSE;
	PRODUCT_SKU_TYPE skuType = GetProductSKU();

    if (PRODUCT_SKU_PERSONAL == skuType)
    {
        // Guest mode is always on for Personal
        fIsGuestAccessMode = TRUE;
    }
    else if (
		((PRODUCT_SKU_PROFESSIONAL == skuType) || (PRODUCT_SKU_DESKTOP_EMBEDDED == skuType)) && 
		!IsMachineDomainMember()
		)
    {
        LONG    ec;
        HKEY    hkey;

        // Professional, not in a domain. Check the ForceGuest value.

        ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR && 1 == dwValue)
            {
                fIsGuestAccessMode = TRUE;
            }

            RegCloseKey(hkey);
        }
    }

    return fIsGuestAccessMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//  Copy from:  shell\osshell\security\rshx32\util.cpp
//----------------------------------------------------------------------------

BOOL
IsSimpleUI()
{
    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    // The CTRL key can be used to turn off simple UI in cases where
    // it would otherwise be on, but there is no way to turn simple UI
    // on in cases where it is off.

    return (GetAsyncKeyState(VK_CONTROL) >= 0 && // Ctrl NOT pressed
            !IsSafeMode() &&                     // NOT safe mode
            IsGuestAccessMode());                // Guest mode
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\service.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	Service.cpp

Abstract:

	General fax server service utility functions

Author:

	Eran Yariv (EranY)	Dec, 2000

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <Accctrl.h>
#include <Aclapi.h>

#include "faxutil.h"
#include "faxreg.h"
#include "FaxUIConstants.h"

DWORD 
FaxOpenService (
    LPCTSTR    lpctstrMachine,
    LPCTSTR    lpctstrService,
    SC_HANDLE *phSCM,
    SC_HANDLE *phSvc,
    DWORD      dwSCMDesiredAccess,
    DWORD      dwSvcDesiredAccess,
    LPDWORD    lpdwStatus
);

DWORD
FaxCloseService (
    SC_HANDLE hScm,
    SC_HANDLE hSvc
);    

DWORD 
StartServiceEx (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    DWORD   dwNumArgs,
    LPCTSTR*lppctstrCommandLineArgs,
    DWORD   dwMaxWait
);

DWORD 
WaitForServiceStopOrStart (
    SC_HANDLE hSvc,
    BOOL      bStop,
    DWORD     dwMaxWait
);


DWORD 
FaxOpenService (
    LPCTSTR    lpctstrMachine,
    LPCTSTR    lpctstrService,
    SC_HANDLE *phSCM,
    SC_HANDLE *phSvc,
    DWORD      dwSCMDesiredAccess,
    DWORD      dwSvcDesiredAccess,
    LPDWORD    lpdwStatus
)
/*++

Routine name : FaxOpenService

Routine description:

	Opens a handle to a service and optionally queries its status

Author:

	Eran Yariv (EranY),	Oct, 2001

Arguments:

    lpctstrMachine     [in]  - Machine on which the service handle should be obtained
    
    lpctstrService     [in]  - Service name
    
	phSCM              [out] - Handle to the service control manager.
	                            
	phSvc              [out] - Handle to the service

    dwSCMDesiredAccess [in]  - Specifies the access to the service control manager
    
    dwSvcDesiredAccess [in]  - Specifies the access to the service

    lpdwStatus         [out] - Optional. If not NULL, point to a DWORD which we receive the current
                               status of the service.
                            
Return Value:

    Standard Win32 error code
    
Remarks:

    If the function succeeds, the caller should call FaxCloseService to free resources.

--*/
{
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxOpenService"))

    hSvcMgr = OpenSCManager(
        lpctstrMachine,
        NULL,
        dwSCMDesiredAccess
        );
    if (!hSvcMgr) 
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenSCManager failed with %ld"),
            dwRes);
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        lpctstrService,
        dwSvcDesiredAccess
        );
    if (!hService) 
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenService failed with %ld"),
            dwRes);
        goto exit;
    }
    if (lpdwStatus)
    {
        SERVICE_STATUS Status;
        //
        // Caller wants to know the service status
        //
        if (!QueryServiceStatus( hService, &Status )) 
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("QueryServiceStatus failed with %ld"),
                dwRes);
            goto exit;
        }
        *lpdwStatus = Status.dwCurrentState;
    }        

    *phSCM = hSvcMgr;
    *phSvc = hService;
    
    Assert (ERROR_SUCCESS == dwRes);
    
exit:
    
    if (ERROR_SUCCESS != dwRes)
    {
        FaxCloseService (hSvcMgr, hService);
    }
    return dwRes;
}   // FaxOpenService

DWORD
FaxCloseService (
    SC_HANDLE hScm,
    SC_HANDLE hSvc
)
/*++

Routine name : FaxCloseService

Routine description:

	Closes all handles to the service obtained by a call to FaxOpenService

Author:

	Eran Yariv (EranY),	Oct, 2001

Arguments:

	hScm              [in] - Handle to the service control manager
	                            
	hSvc              [in] - Handle to the service
                            
Return Value:

    Standard Win32 error code
    
--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxCloseService"))

    if (hSvc) 
    {
        if (!CloseServiceHandle(hSvc))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseServiceHandle failed with %ld"),
                dwRes);
        }
    }
    if (hScm) 
    {
        if (!CloseServiceHandle(hScm))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseServiceHandle failed with %ld"),
                dwRes);
        }
    }
    return dwRes;
}   // FaxCloseService


HANDLE 
OpenSvcStartEvent()
/*++

Routine name : OpenSvcStartEvent

Routine description:

	Opens (or creates) the global named-event which signals a fax server service startup

Author:

	Eran Yariv (EranY),	Dec, 2000

Arguments:


Return Value:

    Handle to the event or NULL on error (sets last error).

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("OpenSvcStartEvent"));

    HANDLE hEvent = NULL;

    //
    // First, try to open the event, asking for synchronization only.
    //
    hEvent = OpenEvent(SYNCHRONIZE, FALSE, FAX_SERVER_EVENT_NAME);
    if (hEvent)
    {
        //
        // Good! return now.
        //
        return hEvent;
    }
    //
    // Houston, we've got a problem...
    //
    if (ERROR_FILE_NOT_FOUND != GetLastError())
    {
        //
        // The event is there, we just can't open it.
        //
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("OpenEvent(FAX_SERVER_EVENT_NAME) failed (ec: %ld)"), 
                     GetLastError());
        return NULL;
    }
    //
    // The event does not exist yet.
    //
    SECURITY_ATTRIBUTES* pSA = NULL;
    //
    // We create the event, giving everyone SYNCHRONIZE access only.
    // Notice that the current process and the local system account (underwhich the service is running)
    // get full access.
    //
    pSA = CreateSecurityAttributesWithThreadAsOwner (SYNCHRONIZE);
    if(!pSA)
    {
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("CreateSecurityAttributesWithThreadAsOwner failed (ec: %ld)"), 
                     GetLastError());
        return NULL;
    }
    hEvent = CreateEvent(pSA, TRUE, FALSE, FAX_SERVER_EVENT_NAME);
    DWORD dwRes = ERROR_SUCCESS;
    if (!hEvent) 
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, 
                     TEXT("CreateEvent(FAX_SERVER_EVENT_NAME) failed (ec: %ld)"), 
                     dwRes);
    }
    DestroySecurityAttributes (pSA);
    if (!hEvent)
    {
        SetLastError (dwRes);
    }
    return hEvent;
}   // OpenSvcStartEvent

BOOL
EnsureFaxServiceIsStarted(
    LPCTSTR lpctstrMachineName
    )
/*++

Routine name : EnsureFaxServiceIsStarted

Routine description:

	If the fax service is not running, attempts to start the service and waits for it to run

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	lpctstrMachineName            [in]     - Machine name (NULL for local)

Return Value:

    TRUE if service is successfully runnig, FALSE otherwise.
    Use GetLastError() to retrieve errors.

--*/
{
    LPCTSTR lpctstrDelaySuicide = SERVICE_DELAY_SUICIDE;  // Service command line parameter
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("EnsureFaxServiceIsStarted"))

    dwRes = StartServiceEx (lpctstrMachineName,
                            FAX_SERVICE_NAME,
                            1,
                            &lpctstrDelaySuicide,
                            10 * 60 * 1000);	// Give up after ten minutes
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    return TRUE;
}   // EnsureFaxServiceIsStarted

BOOL
StopService (
    LPCTSTR lpctstrMachineName,
    LPCTSTR lpctstrServiceName,
    BOOL    bStopDependents
    )
/*++

Routine name : StopService

Routine description:

	Stops a service

Author:

	Eran Yariv (EranY),	Aug, 2000

Arguments:

	lpctstrMachineName    [in]     - The machine name when the service should stop. NULL for local machine
    lpctstrServiceName    [in]     - The service name
    bStopDependents       [in]     - Stop dependent services too?

Return Value:

    TRUE if successful, FALSE otherwise.
    Sets thread last error in case of failure.

--*/
{
	BOOL                    bRes = FALSE;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    DWORD                   dwCnt;
    SERVICE_STATUS          serviceStatus = {0};
    LPENUM_SERVICE_STATUS   lpEnumSS = NULL;

	DEBUG_FUNCTION_NAME(TEXT("StopService"));

    hSvcMgr = OpenSCManager(lpctstrMachineName, NULL, SC_MANAGER_ALL_ACCESS);
	if(!hSvcMgr)
	{
		DebugPrintEx(DEBUG_ERR, TEXT("OpenSCManager failed: error=%d"), GetLastError());
		goto exit;
	}

    hService = OpenService(hSvcMgr, 
                           lpctstrServiceName, 
                           SERVICE_QUERY_STATUS | SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS);
	if(!hService)
	{
		DebugPrintEx(DEBUG_ERR, TEXT("OpenService(%s) failed: error=%d"), lpctstrServiceName, GetLastError());
		goto exit;
	}

    if(!QueryServiceStatus(hService, &serviceStatus))
	{
		DebugPrintEx(DEBUG_ERR, TEXT("QueryServiceStatus failed: error=%d"), GetLastError());
		goto exit;
	}

	if(SERVICE_STOPPED == serviceStatus.dwCurrentState)
	{
        //
        // Service already stopped
        //
		DebugPrintEx(DEBUG_MSG, TEXT("Service is already stopped."));
        bRes = TRUE;
		goto exit;
	}
    if (bStopDependents)
    {
        //
        // Look for dependent services first
        //
        DWORD dwNumDependents = 0;
        DWORD dwBufSize = 0;
        DWORD dwCnt;

        if (!EnumDependentServices (hService,
                                    SERVICE_ACTIVE,
                                    NULL,
                                    0,
                                    &dwBufSize,
                                    &dwNumDependents))
        {
            DWORD dwRes = GetLastError ();
            if (ERROR_MORE_DATA != dwRes)
            {
                //
                // Real error
                //
        		DebugPrintEx(DEBUG_MSG, TEXT("EnumDependentServices failed with %ld"), dwRes);
                goto exit;
            }
            //
            // Allocate buffer
            //
            if (!dwBufSize)
            {
                //
                // No services
                //
                goto StopOurService;
            }
            lpEnumSS = (LPENUM_SERVICE_STATUS)MemAlloc (dwBufSize);
            if (!lpEnumSS)
            {
        		DebugPrintEx(DEBUG_MSG, TEXT("MemAlloc(%ld) failed with %ld"), dwBufSize, dwRes);
                goto exit;
            }
        }
        //
        // 2nd call
        //
        if (!EnumDependentServices (hService,
                                    SERVICE_ACTIVE,
                                    lpEnumSS,
                                    dwBufSize,
                                    &dwBufSize,
                                    &dwNumDependents))
        {
      		DebugPrintEx(DEBUG_MSG, TEXT("EnumDependentServices failed with %ld"), GetLastError());
            goto exit;
        }
        //
        // Walk the services and stop each one
        //
        for (dwCnt = 0; dwCnt < dwNumDependents; dwCnt++)
        {
            if (!StopService (lpctstrMachineName, lpEnumSS[dwCnt].lpServiceName, FALSE))
            {
                goto exit;
            }
        }
    }

StopOurService:
	//
	// Stop the service
	//
	if(!ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus))
	{
		DebugPrintEx(DEBUG_ERR, TEXT("ControlService(STOP) failed: error=%d"), GetLastError());
		goto exit;
	}
    //
    // Wait till the service is really stopped
    //
    for (dwCnt=0; dwCnt < FXS_STARTSTOP_MAX_WAIT; dwCnt += FXS_STARTSTOP_MAX_SLEEP )
    {
        if(!QueryServiceStatus(hService, &serviceStatus))
	    {
		    DebugPrintEx(DEBUG_ERR, TEXT("QueryServiceStatus failed: error=%d"), GetLastError());
		    goto exit;
	    }
        if ( SERVICE_STOP_PENDING == serviceStatus.dwCurrentState )
        {
            //
            // The service is taking its time shutting down
            //
            Sleep( FXS_STARTSTOP_MAX_SLEEP );
        }
        else
        {
            break;
        }
    }
    //
    // Check loop outage condition
    //
    if (serviceStatus.dwCurrentState != SERVICE_STOPPED)
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Service was not stopped after %ld seconds wait."), 
            dwCnt/1000);
        if (ERROR_SUCCESS == GetLastError())
        {
            //
            // Timeout - no real error yet
            //
            SetLastError (WAIT_TIMEOUT);
        }
    }
    else 
    {
        //
        // Service is really stopped now
        //
        bRes = TRUE;
    }

exit:

    MemFree (lpEnumSS);
    if (hService)
    {
        if (!CloseServiceHandle(hService))
        {
		    DebugPrintEx(DEBUG_ERR, TEXT("CloseServiceHandle failed: error=%d"), GetLastError());
        }
    }

    if (hSvcMgr)
    {
        if (!CloseServiceHandle(hSvcMgr))
        {
		    DebugPrintEx(DEBUG_ERR, TEXT("CloseServiceHandle failed: error=%d"), GetLastError());
        }
    }
	return bRes;
}   // StopService

BOOL
WaitForServiceRPCServer (
    DWORD dwTimeOut
)
/*++

Routine name : WaitForServiceRPCServer

Routine description:

	Waits until the service RPC server is up and running (or timeouts)

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	dwTimeOut    [in]     - Wait timeout (in millisecs). Can be INFINITE.

Return Value:

    TRUE if the service RPC server is up and running, FALSE otherwise.

--*/
{
    DWORD dwRes;
    HANDLE  hFaxServerEvent;
    DEBUG_FUNCTION_NAME(TEXT("WaitForServiceRPCServer"))

    hFaxServerEvent = OpenSvcStartEvent();
    if (!hFaxServerEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenEvent failed with %ld"),
            GetLastError ());
        return FALSE;
    }
    //
    // Wait for the fax service to complete its initialization
    //
    dwRes = WaitForSingleObject(hFaxServerEvent, dwTimeOut);
    switch (dwRes)
    {
        case WAIT_FAILED:
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WaitForSingleObject failed with %ld"),
                dwRes);
            break;

        case WAIT_OBJECT_0:
            dwRes = ERROR_SUCCESS;
            break;

        case WAIT_TIMEOUT:
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Service did not signal the event - timeout"));
            break;
            
        default:
            ASSERT_FALSE;
            break;
    }
    if (!CloseHandle (hFaxServerEvent))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CloseHandle failed with %ld"),
            GetLastError ());
    }
        
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    return TRUE;                            
}   // WaitForServiceRPCServer

DWORD
IsFaxServiceRunningUnderLocalSystemAccount (
    LPCTSTR lpctstrMachineName,
    LPBOOL lbpResultFlag
    )
/*++

Routine name : IsFaxServiceRunningUnderLocalSystemAccount

Routine description:

	Checks if the fax service is running under the local system account

Author:

	Eran Yariv (EranY),	Jul, 2000

Arguments:

	lpctstrMachineName            [in]     - Machine name of the fax service
	lbpResultFlag                 [out]    - Result buffer

Return Value:

    Standard Win32 error code

--*/
{
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    DWORD dwRes;
    DWORD dwNeededSize;
    QUERY_SERVICE_CONFIG qsc = {0};
    LPQUERY_SERVICE_CONFIG lpSvcCfg = &qsc;
    DEBUG_FUNCTION_NAME(TEXT("IsFaxServiceRunningUnderLocalSystemAccount"))

    hSvcMgr = OpenSCManager(
        lpctstrMachineName,
        NULL,
        SC_MANAGER_CONNECT
        );
    if (!hSvcMgr) 
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenSCManager failed with %ld"),
            dwRes);
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        SERVICE_QUERY_CONFIG
        );
    if (!hService) 
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenService failed with %ld"),
            dwRes);
        goto exit;
    }

    if (!QueryServiceConfig( hService, lpSvcCfg, sizeof (qsc), &dwNeededSize))
    {
        dwRes = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwRes)
        {
            //
            // Real error here
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("QueryServiceStatus failed with %ld"),
                dwRes);
            goto exit;
        }
        //
        // Allocate buffer
        //
        lpSvcCfg = (LPQUERY_SERVICE_CONFIG) MemAlloc (dwNeededSize);
        if (!lpSvcCfg)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't allocate %ld bytes for QUERY_SERVICE_CONFIG structure"),
                dwNeededSize);
            goto exit;
        }
        //
        // Call with good buffer size now
        //
        if (!QueryServiceConfig( hService, lpSvcCfg, dwNeededSize, &dwNeededSize))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("QueryServiceStatus failed with %ld"),
                dwRes);
            goto exit;
        }
    }
    if (!lpSvcCfg->lpServiceStartName ||
        !lstrcmp (TEXT("LocalSystem"), lpSvcCfg->lpServiceStartName))
    {
        *lbpResultFlag = TRUE;
    }
    else
    {
        *lbpResultFlag = FALSE;
    }           
    dwRes = ERROR_SUCCESS;

exit:
    if (hService) 
    {
        if (!CloseServiceHandle( hService ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseServiceHandle failed with %ld"),
                GetLastError ());
        }
    }
    if (hSvcMgr) 
    {
        if (!CloseServiceHandle( hSvcMgr ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseServiceHandle failed with %ld"),
                GetLastError ());
        }
    }
    if (lpSvcCfg != &qsc)
    {
        //
        // We allocated a buffer becuase the buffer on the stack was too small
        //
        MemFree (lpSvcCfg);
    }

    return dwRes;
}   // IsFaxServiceRunningUnderLocalSystemAccount



PSID 
GetCurrentThreadSID ()
/*++

Routine name : GetCurrentThreadSID

Routine description:

	Returns the SID of the user running the current thread.
    Supports impersonated threads.

Author:

	Eran Yariv (EranY),	Aug, 2000

Arguments:


Return Value:

    PSID or NULL on error (call GetLastError()).
    Call MemFree() on return value.

--*/
{
    HANDLE hToken = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize;
    PSID pUserSid;
    DWORD dwReqSize;
    LPBYTE lpbTokenUser = NULL;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("GetCurrentThreadSID"));

    //
    // Open the thread token.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        ec = GetLastError();
        if (ERROR_NO_TOKEN == ec)
        {
            //
            // This thread is not impersonated and has no SID.
            // Try to open process token instead
            //
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("OpenProcessToken failed. (ec: %ld)"),
                    ec);
                goto exit;
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenThreadToken failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }
    //
    // Get the user's SID.
    //
    if (!GetTokenInformation(hToken,
                             TokenUser,
                             NULL,
                             0,
                             &dwReqSize))
    {
        ec = GetLastError();
        if( ec != ERROR_INSUFFICIENT_BUFFER )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetTokenInformation failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        ec = ERROR_SUCCESS;
    }
    lpbTokenUser = (LPBYTE) MemAlloc( dwReqSize );
    if (lpbTokenUser == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer (%ld bytes)"),
            dwReqSize
            );
        ec = GetLastError();
        goto exit;
    }
    if (!GetTokenInformation(hToken,
                             TokenUser,
                             (LPVOID)lpbTokenUser,
                             dwReqSize,
                             &dwReqSize))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetTokenInformation failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    pUserSid = ((TOKEN_USER *)lpbTokenUser)->User.Sid;
    Assert (pUserSid);

    if (!IsValidSid(pUserSid))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Not a valid SID")
            );
        ec = ERROR_INVALID_SID;
        goto exit;
    }
    dwSidSize = GetLengthSid( pUserSid );
    //
    // Allocate return buffer
    //
    pSid = (PSID) MemAlloc( dwSidSize );
    if (pSid == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer (%ld bytes)"),
            dwSidSize
            );
        ec = ERROR_OUTOFMEMORY;
        goto exit;
    }
    //
    // Copy thread's SID to return buffer
    //
    if (!CopySid(dwSidSize, pSid, pUserSid))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopySid Failed, Error : %ld"),
            ec
            );
        goto exit;
    }

    Assert (ec == ERROR_SUCCESS);

exit:
    MemFree (lpbTokenUser);
    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (ec != ERROR_SUCCESS)
    {
        MemFree (pSid);
        pSid = NULL;
        SetLastError (ec);
    }
    return pSid;
}   // GetCurrentThreadSID      

SECURITY_ATTRIBUTES *
CreateSecurityAttributesWithThreadAsOwner (
    DWORD dwAuthUsersAccessRights
)
/*++

Routine name : CreateSecurityAttributesWithThreadAsOwner

Routine description:

    Create a security attribute structure with current thread's SID as owner.
    Gives all access rights to current thread sid and LocalSystem account.
    Can also grant specific rights to authenticated users.

Author:

    Eran Yariv (EranY), Aug, 2000

Arguments:

    dwAuthUsersAccessRights  [in] - Access rights to grant to authenticated users.
                                    If zero, authenticated users are denied access.

Return Value:

    Allocated security attributes or NULL on failure.
    Call DestroySecurityAttributes to free returned buffer.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateSecurityAttributesWithThreadAsOwner"))

    SECURITY_ATTRIBUTES *pSA = NULL;
    SECURITY_DESCRIPTOR *pSD = NULL;
    PSID                 pSidCurThread = NULL;
    PSID                 pSidAuthUsers = NULL;
    PSID                 pSidLocalSystem = NULL;
    PACL                 pACL = NULL;
    EXPLICIT_ACCESS      ea[3] = {0};
                            // Entry 0 - Give GENERIC_ALL + WRITE_OWNER + WRITE_DAC to current thread's SID.
                            // Entry 1 - Give GENERIC_ALL + WRITE_OWNER + WRITE_DAC to LocalSystem account.
                            // Entry 2 (optional) - give dwAuthUsersAccessRights to authenticated users group.
    DWORD                rc;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Allocate return SECURITY_ATTRIBUTES buffer
    //
    pSA = (SECURITY_ATTRIBUTES *)MemAlloc (sizeof (SECURITY_ATTRIBUTES));
    if (!pSA)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not allocate %ld bytes for SECURITY_ATTRIBUTES"),
            sizeof (SECURITY_ATTRIBUTES));
        return NULL;
    }
    //
    // Allocate SECURITY_DESCRIPTOR for the return SECURITY_ATTRIBUTES buffer
    //
    pSD = (SECURITY_DESCRIPTOR *)MemAlloc (sizeof (SECURITY_DESCRIPTOR));
    if (!pSD)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not allocate %ld bytes for SECURITY_DESCRIPTOR"),
            sizeof (SECURITY_DESCRIPTOR));
        goto err_exit;
    }
    pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSA->bInheritHandle = TRUE;
    pSA->lpSecurityDescriptor = pSD;
    //
    // Init the security descriptor
    //
    if (!InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeSecurityDescriptor failed with %ld"),
            GetLastError());
        goto err_exit;
    }
    //
    // Get SID of current thread
    //
    pSidCurThread = GetCurrentThreadSID ();
    if (!pSidCurThread)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetCurrentThreadSID failed with %ld"),
            GetLastError());
        goto err_exit;
    }
    //
    // Set the current thread's SID as SD owner (giving full access to the object)
    //
    if (!SetSecurityDescriptorOwner (pSD, pSidCurThread, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorOwner failed with %ld"),
            GetLastError());
        goto err_exit;
    }
    //
    // Set the current thread's SID as SD group (giving full access to the object)
    //
    if (!SetSecurityDescriptorGroup (pSD, pSidCurThread, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorGroup failed with %ld"),
            GetLastError());
        goto err_exit;
    }

    //
    // Get the local system account sid
    //
    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,            // 1 sub-authority
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0,0,0,0,0,0,0,
                                  &pSidLocalSystem))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AllocateAndInitializeSid(SECURITY_LOCAL_SYSTEM_RID) failed with %ld"),
            GetLastError());
        goto err_exit;
    }
    Assert (pSidLocalSystem);

    if (dwAuthUsersAccessRights)
    {
        //
        // We should also grant some rights to authenticated users
        // Get 'Authenticated users' SID
        //
        if (!AllocateAndInitializeSid(&NtAuthority,
                                      1,            // 1 sub-authority
                                      SECURITY_AUTHENTICATED_USER_RID,
                                      0,0,0,0,0,0,0,
                                      &pSidAuthUsers))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AllocateAndInitializeSid(SECURITY_AUTHENTICATED_USER_RID) failed with %ld"),
                GetLastError());
            goto err_exit;
        }
        Assert (pSidAuthUsers);

        ea[2].grfAccessPermissions = dwAuthUsersAccessRights;
        ea[2].grfAccessMode = SET_ACCESS;
        ea[2].grfInheritance= NO_INHERITANCE;
        ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[2].Trustee.ptstrName  = (LPTSTR) pSidAuthUsers;
    }
    ea[0].grfAccessPermissions = GENERIC_ALL | WRITE_DAC | WRITE_OWNER;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pSidCurThread;

    ea[1].grfAccessPermissions = GENERIC_ALL | WRITE_DAC | WRITE_OWNER;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance= NO_INHERITANCE;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[1].Trustee.ptstrName  = (LPTSTR) pSidLocalSystem;

    //
    // Create a new ACL that contains the new ACE.
    //
    rc = SetEntriesInAcl(dwAuthUsersAccessRights ? 3 : 2,
                         // If we don't set rigths to authenticated users group, then just add 2 ACEs (entry 0, 1).
                         // Otherwise, add 3 ACEs (entries 0 + 1 + 2).
                         ea,
                         NULL,
                         &pACL);
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetEntriesInAcl() failed (ec: %ld)"),
            rc);
        SetLastError (rc);
        goto err_exit;
    }
    Assert (pACL);
    //
    // The ACL we just got contains a copy of the pSidAuthUsers, so we can discard pSidAuthUsers and pSidLocalSystem
    //
    if (pSidAuthUsers)
    {
        FreeSid (pSidAuthUsers);
        pSidAuthUsers = NULL;
    }

    if (pSidLocalSystem)
    {
        FreeSid (pSidLocalSystem);
        pSidLocalSystem = NULL;
    }

    //
    // Add the ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorDacl() failed (ec: %ld)"),
            GetLastError());
        goto err_exit;
    }
    //
    // All is fine, return the SA.
    //
    return pSA;

err_exit:

    MemFree (pSA);
    MemFree (pSD);
    MemFree (pSidCurThread);
    if (pSidAuthUsers)
    {
        FreeSid (pSidAuthUsers);
    }
    if (pSidLocalSystem)
    {
        FreeSid (pSidLocalSystem);
    }
    if (pACL)
    {
        LocalFree (pACL);
    }
    return NULL;
}   // CreateSecurityAttributesWithThreadAsOwner

VOID
DestroySecurityAttributes (
    SECURITY_ATTRIBUTES *pSA
)
/*++

Routine name : DestroySecurityAttributes

Routine description:

	Frees data allocated by call to CreateSecurityAttributesWithThreadAsOwner

Author:

	Eran Yariv (EranY),	Aug, 2000

Arguments:

	pSA     [in]     - Return value from CreateSecurityAttributesWithThreadAsOwner

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("DestroySecurityAttributes"))
    BOOL bDefaulted;
    BOOL bPresent;
    PSID pSid;
    PACL pACL;
    PSECURITY_DESCRIPTOR pSD;

    Assert (pSA);
    pSD = pSA->lpSecurityDescriptor;
    Assert (pSD);
    if (!GetSecurityDescriptorOwner (pSD, &pSid, &bDefaulted))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSecurityDescriptorOwner() failed (ec: %ld)"),
            GetLastError());
        ASSERT_FALSE;
    }
    else
    {
        //
        // Free current thread's SID (SD owner)
        //
        MemFree (pSid);
    }
    if (!GetSecurityDescriptorDacl (pSD, &bPresent, &pACL, &bDefaulted))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSecurityDescriptorDacl() failed (ec: %ld)"),
            GetLastError());
        ASSERT_FALSE
    }
    else
    {
        //
        // Free ACL
        //
        LocalFree (pACL);
    }    
    MemFree (pSA);
    MemFree (pSD);
}   // DestroySecurityAttributes

DWORD 
WaitForServiceStopOrStart (
    SC_HANDLE hSvc,
    BOOL      bStop,
    DWORD     dwMaxWait
)
/*++

Routine name : WaitForServiceStopOrStart

Routine description:

	Waits for a service to stop or start

Author:

	Eran Yariv (EranY),	Jan, 2002

Arguments:

	hSvc      [in] - Open service handle.
	bStop     [in] - TRUE if service was just stopped. FALSE if service was just started
	dwMaxWait [in] - Max wait time (in millisecs).

Return Value:

    Standard Win32 error code

--*/
{
    SERVICE_STATUS Status;
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwOldCheckPoint = 0;
    DWORD dwStartTick;
    DWORD dwOldCheckPointTime;
    DEBUG_FUNCTION_NAME(TEXT("WaitForServiceStopOrStart"))

    if (!QueryServiceStatus(hSvc, &Status)) 
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("QueryServiceStatus failed with %ld"),
            dwRes);
        return dwRes;
    }
    if (bStop)
    {
        if (SERVICE_STOPPED == Status.dwCurrentState)
        {
            //
            // Service is already stopped
            //
            return dwRes;
        }
    }
    else
    {
        if (SERVICE_RUNNING == Status.dwCurrentState)
        {
            //
            // Service is already running
            //
            return dwRes;
        }
    }
    //
    // Let's wait for the service to start / stop
    //
    dwOldCheckPointTime = dwStartTick = GetTickCount ();
    for (;;)
    {
        DWORD dwWait;
        if (!QueryServiceStatus(hSvc, &Status)) 
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("QueryServiceStatus failed with %ld"),
                dwRes);
            return dwRes;
        }
        //
        // Let's see if all is ok now
        //
        if (bStop)
        {
            if (SERVICE_STOPPED == Status.dwCurrentState)
            {
                //
                // Service is now stopped
                //
                return dwRes;
            }
        }
        else
        {
            if (SERVICE_RUNNING == Status.dwCurrentState)
            {
                //
                // Service is now running
                //
                return dwRes;
            }
        }
        //
        // Let's see if it's pending
        //
        if ((bStop  && SERVICE_STOP_PENDING  != Status.dwCurrentState) ||
            (!bStop && SERVICE_START_PENDING != Status.dwCurrentState))
        {
            //
            // Something is wrong
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Service cannot be started / stopped. Current state is %ld"),
                Status.dwCurrentState);
            return ERROR_SERVICE_NOT_ACTIVE;
        }
        //
        // Service is pending to stop / start
        //
        if (GetTickCount() - dwStartTick > dwMaxWait)
        {
            //
            // We've waited too long (globally).
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("We've waited too long (globally)"));
            return ERROR_TIMEOUT;
        }            
        Assert (dwOldCheckPoint <= Status.dwCheckPoint);
        if (dwOldCheckPoint >= Status.dwCheckPoint)
        {
            //
            // Check point did not advance
            //
            if (GetTickCount() - dwOldCheckPointTime >= Status.dwWaitHint)
            {
                //
                // We've been waiting on the same checkpoint for more than the recommended hint.
                // Something is wrong.
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("We've been waiting on the same checkpoint for more than the recommend hint"));
                return ERROR_TIMEOUT;
            }
        }
        else
        {
            //
            // Check point advanced
            //
            dwOldCheckPoint = Status.dwCheckPoint;
            dwOldCheckPointTime = GetTickCount();
        }
        //
        // Never sleep longer than 5 seconds
        //
        dwWait = min (Status.dwWaitHint / 2, 1000 * 5);
        Sleep (dwWait);
    }
    return ERROR_SUCCESS;        
} // WaitForServiceStopOrStart

DWORD 
StartServiceEx (
    LPCTSTR lpctstrMachine,
    LPCTSTR lpctstrService,
    DWORD   dwNumArgs,
    LPCTSTR*lppctstrCommandLineArgs,
    DWORD   dwMaxWait
)
/*++

Routine name : StartServiceEx

Routine description:

	Starts a service

Author:

	Eran Yariv (EranY),	Jan, 2002

Arguments:

	lpctstrMachine          [in] - Machine where service is installed
	lpctstrService          [in] - Service name
	dwNumArgs               [in] - Number of service command line arguments
	lppctstrCommandLineArgs [in] - Command line strings.
	dwMaxWait               [in] - Max time to wait for service to start (millisecs)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hScm = NULL;
    SC_HANDLE hSvc = NULL;
    DWORD dwStatus;
    
    DEBUG_FUNCTION_NAME(TEXT("StartServiceEx"))

    dwRes = FaxOpenService(lpctstrMachine, 
                           lpctstrService, 
                           &hScm, 
                           &hSvc, 
                           SC_MANAGER_CONNECT, 
                           SERVICE_QUERY_STATUS | SERVICE_START, 
                           &dwStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    if (SERVICE_RUNNING == dwStatus)
    {
        //
        // Service is already running
        //
        goto exit;
    }
    //
    // Start the sevice
    //
    if (!StartService(hSvc, dwNumArgs, lppctstrCommandLineArgs)) 
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartService failed with %ld"),
            GetLastError ());
        goto exit;
    }
    if (dwMaxWait > 0)
    {
        //
        // User wants us to wait for the service to stop.
        //
        dwRes = WaitForServiceStopOrStart (hSvc, FALSE, dwMaxWait);
    }        

exit:
    FaxCloseService (hScm, hSvc);
    return dwRes;
}   // StartServiceEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\routemapi.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    routemapi.cpp

Abstract:

    This module provides the implemantation of registry manipulations to 
    route MAPI calls to the Microsoft Outlook mail client

Author:

    Mooly Beery (moolyb) 5-Nov-2000


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <debugex.h>
// cause the module to export its methods   
//#define EXPORT_MAPI_ROUTE_CALLS
#include <routemapi.h>

#include "winfax.h"
#include "faxreg.h"
#include "faxutil.h"

#define MS_OUTLOOK              _T("Microsoft Outlook")

#define REG_KEY_POP_UP          _T("PreFirstRun")
#define REG_KEY_POP_UP_OLD      _T("{F779C4BF-4C94-4442-8844-633F0298ED0B}")
#define REG_KEY_MAPI_APPS_OLD   _T("{A5159994-A7F8-4C11-8F86-B9877CE02303}")
#define REG_KEY_CLIENTS_MAIL    _T("SOFTWARE\\Clients\\Mail")
#define REG_KEY_MAPI_APPS       _T("SOFTWARE\\Microsoft\\Windows Messaging Subsystem\\MSMapiApps")

CRouteMAPICalls::CRouteMAPICalls()
:   m_ptProcessName(NULL),
    m_bMSOutlookInstalled(false),
    m_bMSOutlookIsDefault(false),
    m_bProcessIsRouted(false),
    m_bProcessIsRoutedToMsOutlook(false)

{
}

// Function:    CRouteMAPICalls::~CRouteMAPICalls
// 
// Description: restores the registry to its initial state after 
//              SetRegistryForSetupMAPICalls was called
//              if Microsoft Outlook is installed
//              if it's not restore pop-ups which might result from MAPI calls
//              if it is check if Microsoft Outlook is the default mail client
//              if it is do nothing
//              if it's not remove current process from routing all MAPI calls to Micosoft Outlook
//
// author:  
//          MoolyB (05-NOV-00)
//
CRouteMAPICalls::~CRouteMAPICalls()
{
    DWORD   rc                  = ERROR_SUCCESS;
    TCHAR*  ptPreFirstRun       = NULL;
    TCHAR*  ptPreRouteProcess   = NULL;
    HKEY    hMailKey            = NULL;
    HKEY    hMapiApps           = NULL;

    DBG_ENTER(_T("CRouteMAPICalls::~CRouteMAPICalls"));

    rc = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        REG_KEY_CLIENTS_MAIL,
                        0,
                        KEY_ALL_ACCESS,
                        &hMailKey);
    if (rc!=ERROR_SUCCESS)
    {
        // no mail clients instlled on this machine? this is strange
        // anyway, no work needs to be done, since no one will pop-up
        // any message and our transport provider is not added anywhere.
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx HKLM\\SOFTWARE\\Clients\\Mail"), rc);
        rc = ERROR_SUCCESS;
        goto exit;
    }
    
    if (m_bMSOutlookInstalled)
    {
        VERBOSE(DBG_MSG,_T("Microsoft Outlook Client was installed"));
        // Microsoft Outlook was installed, check if we did some changes
        if (m_bMSOutlookIsDefault)
        {
            VERBOSE(DBG_MSG,_T("Microsoft Outlook Client was the default mail client, nothing to resotre"));
            goto exit;
        }
        else
        {
            VERBOSE(DBG_MSG,_T("Microsoft Outlook Client was not the default mail client"));
            rc = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                REG_KEY_MAPI_APPS,
                                0,
                                KEY_ALL_ACCESS,
                                &hMapiApps);
            if (rc!=ERROR_SUCCESS)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx SOFTWARE\\Microsoft\\Windows Messaging Subsystem\\MSMapiApps"), rc);
                goto exit;
            }
            if (m_bProcessIsRouted)
            {
                if (m_bProcessIsRoutedToMsOutlook)
                {
                    VERBOSE(DBG_MSG,_T("The process was routed before to MS Outlook, do nothing"));
                    goto exit;
                }
                else
                {
                    VERBOSE(DBG_MSG,_T("The process was routed before, restore key..."));

                    // get old one
                    ptPreRouteProcess = GetRegistryString(hMapiApps,REG_KEY_MAPI_APPS_OLD,NULL);
                    if (ptPreRouteProcess==NULL)
                    {
                        // we failed to read the previously stored _szProcessName
                        // fail the recovery attemp, but delete ourselves anyhow.
                        CALL_FAIL (GENERAL_ERR, TEXT("GetRegistryString"), rc);
                        rc = RegDeleteValue(hMapiApps,m_ptProcessName);
                        if (rc!=ERROR_SUCCESS)
                        {
                            CALL_FAIL (GENERAL_ERR, TEXT("RegDeleteValue m_ptProcessName"), rc);
                        }
                        goto exit;
                    }

                    // delete backup
                    rc = RegDeleteValue(hMapiApps,REG_KEY_MAPI_APPS_OLD);
                    if (rc!=ERROR_SUCCESS)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT("RegDeleteValue m_ptProcessName"), rc);
                    }

                    // set the old registry back
                    if (!SetRegistryString(hMapiApps,m_ptProcessName,ptPreRouteProcess))
                    {
                        rc = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString"), rc);
                        goto exit;
                    }

                    goto exit;
                }
            }
            else
            {
                VERBOSE(DBG_MSG,_T("The process was not routed before, delete key..."));
                rc = RegDeleteValue(hMapiApps,m_ptProcessName);
                if (rc!=ERROR_SUCCESS)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("RegDeleteValue REG_KEY_MAPI_APPS_OLD"), rc);
                    goto exit;
                }
            }
        }
    }
    else
    {
        // Microsoft Outlook was not installed, so we suppressed the pop-up
        // need to restore the pop-up to its original state
        VERBOSE(DBG_MSG,_T("Microsoft Mail Client was not installed - restore pop-up"));
        // I restore the pop-up by renaming the REG_SZ _PreFirstRun
        // under HKLM\\SOFTWARE\\Clients\\Mail
        // to PreFirstRun,
        ptPreFirstRun = GetRegistryString(hMailKey,REG_KEY_POP_UP_OLD,NULL);
        if (ptPreFirstRun==NULL)
        {
            rc = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("GetRegistryString _PreFirstRun"), rc);
            goto exit;
        }
        
        rc = RegDeleteValue(hMailKey,REG_KEY_POP_UP_OLD);
        if (rc!=ERROR_SUCCESS)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString _PreFirstRun"), rc);
        }

        if (!SetRegistryString(hMailKey,REG_KEY_POP_UP,ptPreFirstRun))
        {
            rc = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString PreFirstRun"), rc);
            goto exit;
        }
    }

exit:
    if (hMailKey)
    {
        RegCloseKey(hMailKey);
    }
    if (hMapiApps)
    {
        RegCloseKey(hMapiApps);
    }
    if (ptPreFirstRun)
    {
        MemFree(ptPreFirstRun);
    }
    if (ptPreRouteProcess)
    {
        MemFree(ptPreRouteProcess);
    }
    if (m_ptProcessName)
    {
        MemFree(m_ptProcessName);
    }

    if (rc!=ERROR_SUCCESS)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CRouteMAPICalls::~CRouteMAPICalls"), rc);
    }
}

// Function:    CRouteMAPICalls::Init
// 
// Description: check if Microsoft Outlook is installed
//              if it's not supress any pop-ups which might result from MAPI calls
//              if it is check if Microsoft Outlook is the default mail client
//              if it is do nothing
//              if it's not set current process to route all MAPI calls to Micosoft Outlook
//
// author:  
//          MoolyB (05-NOV-00)
//
DWORD CRouteMAPICalls::Init(LPCTSTR lpctstrProcessName)
{
    DWORD   rc                  = ERROR_SUCCESS;
    HKEY    hMailKey            = NULL;
    HKEY    hMsOutlookKey       = NULL;
    HKEY    hMapiApps           = NULL;
    TCHAR*  ptPreFirstRun       = NULL;
    TCHAR*  ptPreRouteProcess   = NULL;
    TCHAR*  ptDefaultMailClient = NULL;
    TCHAR*  ptProcessName       = NULL;

    DBG_ENTER(_T("CRouteMAPICalls::Init"), rc);

    int iSize = _tcslen(lpctstrProcessName);
    if (iSize==0)
    {
        VERBOSE(GENERAL_ERR,_T("invalid process name"));
        goto exit;
    }
    m_ptProcessName = (TCHAR*)MemAlloc((iSize+1)*sizeof(TCHAR));
    if (m_ptProcessName==NULL)
    {
        VERBOSE(GENERAL_ERR,_T("failure to allocate memory"));
        goto exit;
    }

    _tcscpy(m_ptProcessName,lpctstrProcessName);

    rc = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                        REG_KEY_CLIENTS_MAIL,
                        0,
                        KEY_ALL_ACCESS,
                        &hMailKey);
    if (rc!=ERROR_SUCCESS)
    {
        // no mail clients instlled on this machine? this is strange
        // anyway, no work needs to be done, since no one will pop-up
        // any message and our transport provider is not added anywhere.
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx HKLM\\SOFTWARE\\Clients\\Mail"), rc);
        rc = ERROR_SUCCESS;
        goto exit;
    }
    else
    {
        // there are a few mail clients
        // check if a key called 'Microsoft Outlook' exists.
        rc = RegOpenKeyEx(  hMailKey,
                            MS_OUTLOOK,
                            0,
                            KEY_READ,
                            &hMsOutlookKey);
        if (rc!=ERROR_SUCCESS)
        {
            // Microsoft Outlook is not installed
            CALL_FAIL(GENERAL_ERR,_T("RegOpenKeyEx HKLM\\SOFTWARE\\Clients\\Mail\\Microsoft Outlook"),rc);
            if (rc==ERROR_FILE_NOT_FOUND)
            {
                // suppress pop-up message
                VERBOSE(DBG_MSG,_T("Microsoft Mail Client is not installed - suppress pop-up"));
                // I suppress the pop-up by renaming the REG_SZ PreFirstRun
                // under HKLM\\SOFTWARE\\Clients\\Mail
                // to _PreFirstRun, later, we'll restore this
                ptPreFirstRun = GetRegistryString(hMailKey,REG_KEY_POP_UP,NULL);
                if (ptPreFirstRun==NULL)
                {
                    rc = GetLastError();
                    CALL_FAIL (GENERAL_ERR, TEXT("GetRegistryString PreFirstRun"), rc);
                    goto exit;
                }
                
                if (!SetRegistryString(hMailKey,REG_KEY_POP_UP_OLD,ptPreFirstRun))
                {
                    rc = GetLastError();
                    CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString _PreFirstRun"), rc);
                    goto exit;
                }

                rc = RegDeleteValue(hMailKey,REG_KEY_POP_UP);
                if (rc!=ERROR_SUCCESS)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString PreFirstRun"), rc);
                    // try to cleanup, even though this is bad
                    RegDeleteValue(hMailKey,REG_KEY_POP_UP_OLD);
                    goto exit;
                }
            }
            else
            {
                // this is a true error in trying to open the key
                // HKLM\\SOFTWARE\\Clients\\Mail\\Microsoft Outlook
                goto exit;
            }
        }
        else
        {
            // Microsoft Outlook is installed
            m_bMSOutlookInstalled = true;
            // check if it is the deafult mail client
            ptDefaultMailClient = GetRegistryString(hMailKey,NULL,NULL);
            if ((ptDefaultMailClient==NULL) || (_tcscmp(ptDefaultMailClient,MS_OUTLOOK)))
            {
                // either there's no default mail client or GetRegistryString failed
                // or there is a default mail client and it's not Microsoft Outlook
                // in both cases I treat as Microsoft Outlook is not the default mail client

                // open HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Messaging Subsystem\MSMapiApps
                // and add a REG_SZ called according to szProcessName, set it to "Microsoft Outlook"
                rc = RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                    REG_KEY_MAPI_APPS,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hMapiApps);
                if (rc!=ERROR_SUCCESS)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx SOFTWARE\\Microsoft\\Windows Messaging Subsystem\\MSMapiApps"), rc);
                    goto exit;
                }

                ptProcessName = GetRegistryString(hMapiApps,m_ptProcessName,NULL);
                if (ptProcessName==NULL)
                {
                    // this is the 'good' case, no one wants to route MAPI calls from a process with
                    // the same name as our own
                    if (!SetRegistryString(hMapiApps,m_ptProcessName,MS_OUTLOOK))
                    {
                        rc = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString"), rc);
                        goto exit;
                    }
                }
                else
                {
                    m_bProcessIsRouted = true;
                    // this it bad, someone is routing MAPI calls from a process with the same name to 
                    // another app
                    // check if it's routed to Microsoft Outlook, and if not, rename it and add ourselves
                    if (_tcscmp(ptProcessName,MS_OUTLOOK)==0)
                    {
                        m_bProcessIsRoutedToMsOutlook = true;
                        VERBOSE(DBG_MSG,_T("MAPI calls are already routed to Microsoft Outlook"));
                        goto exit;
                    }
                    else
                    {
                        // set old one to _ prefix
                        ptPreRouteProcess = GetRegistryString(hMapiApps,m_ptProcessName,NULL);
                        if (ptPreRouteProcess==NULL)
                        {
                            // we failed to read the previously stored _szProcessName
                            // fail the recovery attemp, but delete ourselves anyhow.
                            CALL_FAIL (GENERAL_ERR, TEXT("GetRegistryString"), rc);
                            goto exit;
                        }
                        if (!SetRegistryString(hMapiApps,REG_KEY_MAPI_APPS_OLD,ptPreRouteProcess))
                        {
                            rc = GetLastError();
                            CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString"), rc);
                            goto exit;
                        }

                        // set ourselves
                        if (!SetRegistryString(hMapiApps,m_ptProcessName,MS_OUTLOOK))
                        {
                            rc = GetLastError();
                            CALL_FAIL (GENERAL_ERR, TEXT("SetRegistryString"), rc);
                            goto exit;
                        }
                    }
                }
            }
            else
            {
                // Microsoft Outlook is the default mail client
                m_bMSOutlookIsDefault = true;
                goto exit;
            }
        }
    }

exit:
    if (hMailKey)
    {
        RegCloseKey(hMailKey);
    }
    if (hMsOutlookKey)
    {
        RegCloseKey(hMsOutlookKey);
    }
    if (hMapiApps)
    {
        RegCloseKey(hMapiApps);
    }
    if (ptPreFirstRun)
    {
        MemFree(ptPreFirstRun);
    }
    if (ptDefaultMailClient)
    {
        MemFree(ptDefaultMailClient);
    }
    if (ptProcessName)
    {
        MemFree(ptProcessName);
    }
    if (ptPreRouteProcess)
    {
        MemFree(ptPreFirstRun);
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\product.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    product.c

Abstract:

    This file implements product type api for fax.

Author:

    Wesley Witt (wesw) 12-Feb-1997

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"


BOOL
ValidateProductSuite(
    WORD SuiteMask
    )
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        DebugPrint(( TEXT("Couldn't GetVersionEx(), ec = %d\n"), GetLastError() ));
        return FALSE;
    }

    return ((OsVersionInfo.wSuiteMask & SuiteMask) != 0) ; 
    
}


DWORD
GetProductType(
    VOID
    )
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        DebugPrint(( TEXT("Couldn't GetVersionEx(), ec = %d\n"), GetLastError() ));
        return 0;
    }

    if  (OsVersionInfo.wProductType == VER_NT_WORKSTATION) {
        return PRODUCT_TYPE_WINNT;            
    }

    return PRODUCT_TYPE_SERVER;
    
}

BOOL
IsWinXPOS()
{
    DWORD dwVersion, dwMajorWinVer, dwMinorWinVer;

    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));
    
    return (dwMajorWinVer == 5 && dwMinorWinVer >= 1);
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  GetProductSKU
//
//  Purpose:        
//                  Checks what's the product SKU we're running on
//
//  Params:
//                  None
//
//  Return Value:
//                  one of PRODUCT_SKU_TYPE - declared in faxreg.h
//                  PRODUCT_SKU_UNKNOWN - in case of failure
//
//  Author:
//                  Mooly Beery (MoolyB) 02-JAN-2000
///////////////////////////////////////////////////////////////////////////////////////
PRODUCT_SKU_TYPE GetProductSKU()
{
#ifdef DEBUG
    HKEY  hKey;
    DWORD dwRes;
    DWORD dwDebugSKU = 0;
#endif

    OSVERSIONINFOEX osv;

    DEBUG_FUNCTION_NAME(TEXT("GetProductSKU"))

#ifdef DEBUG

    //
    // For DEBUG version try to read SKU type from the registry
    //
    dwRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, 0, KEY_READ, &hKey);
    if (dwRes == ERROR_SUCCESS) 
    {
        GetRegistryDwordEx(hKey, REGVAL_DBG_SKU, &dwDebugSKU);
        RegCloseKey(hKey);

        if(PRODUCT_SKU_PERSONAL         == dwDebugSKU ||
           PRODUCT_SKU_PROFESSIONAL     == dwDebugSKU ||
           PRODUCT_SKU_SERVER           == dwDebugSKU ||
           PRODUCT_SKU_ADVANCED_SERVER  == dwDebugSKU ||
           PRODUCT_SKU_DATA_CENTER      == dwDebugSKU ||
		   PRODUCT_SKU_DESKTOP_EMBEDDED == dwDebugSKU ||
		   PRODUCT_SKU_SERVER_EMBEDDED  == dwDebugSKU)
        {
            return (PRODUCT_SKU_TYPE)dwDebugSKU;
        }
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,TEXT("RegOpenKeyEx(REGKEY_FAXSERVER) failed with %ld."),dwRes);
    }

#endif

    ZeroMemory(&osv, sizeof(OSVERSIONINFOEX));
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (!GetVersionEx(((OSVERSIONINFO*)&osv)))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("GetVersionEx failed with %ld."),GetLastError());
        return PRODUCT_SKU_UNKNOWN;
    }

    if (osv.dwPlatformId!=VER_PLATFORM_WIN32_NT)
    {
        DebugPrintEx(DEBUG_WRN,TEXT("Can't tell SKU for W9X Platforms"));
        return PRODUCT_SKU_UNKNOWN;
    }

    if (osv.dwMajorVersion<5)
    {
        DebugPrintEx(DEBUG_WRN,TEXT("Can't tell SKU for NT4 Platform"));
        return PRODUCT_SKU_UNKNOWN;
    }

    // This is the matching between the different SKUs and the constants returned by GetVersionEx
    // Personal 		VER_SUITE_PERSONAL
    // Professional		VER_NT_WORKSTATION
    // Server			VER_NT_SERVER
    // Advanced Server	VER_SUITE_ENTERPRISE
    // DataCanter		VER_SUITE_DATACENTER


	// First, lets see if this is embedded system
	if (osv.wSuiteMask&VER_SUITE_EMBEDDEDNT)
	{
		if (osv.wSuiteMask&VER_NT_WORKSTATION)
		{
			return PRODUCT_SKU_DESKTOP_EMBEDDED;
		}	
		if (osv.wProductType==VER_NT_SERVER)
		{
			return PRODUCT_SKU_SERVER_EMBEDDED;
		}
	}

    if (osv.wSuiteMask&VER_SUITE_PERSONAL)
    {
        return PRODUCT_SKU_PERSONAL;
    }
    if (osv.wSuiteMask&VER_SUITE_ENTERPRISE)
    {
        return PRODUCT_SKU_ADVANCED_SERVER;
    }
    if (osv.wSuiteMask&VER_SUITE_DATACENTER)
    {
        return PRODUCT_SKU_DATA_CENTER;
    }
    if (osv.wProductType==VER_NT_WORKSTATION)
    {
        return PRODUCT_SKU_PROFESSIONAL;
    }
    if (osv.wProductType==VER_NT_SERVER)
    {
        return PRODUCT_SKU_SERVER;
    }

    return PRODUCT_SKU_UNKNOWN;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsDesktopSKU
//
//  Purpose:        
//                  Checks if we're running on PERSONAL or PROFESSIONAL SKUs
//
//  Params:
//                  None
//
//  Return Value:
//                  TRUE - current SKU is PER/PRO
//                  FALSE - different SKU
//
//  Author:
//                  Mooly Beery (MoolyB) 07-JAN-2000
///////////////////////////////////////////////////////////////////////////////////////
BOOL IsDesktopSKU()
{
    PRODUCT_SKU_TYPE pst = GetProductSKU();
    return (
		(pst==PRODUCT_SKU_PERSONAL) || 
		(pst==PRODUCT_SKU_PROFESSIONAL) ||
		(pst==PRODUCT_SKU_DESKTOP_EMBEDDED)
		);
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  GetDeviceLimit
//
//  Purpose:        
//                  Get maximum number of the fax devices for the current Windows version
//
//  Params:
//                  None
//
//  Return Value:
//                  maximum number of the fax devices
///////////////////////////////////////////////////////////////////////////////////////
DWORD
GetDeviceLimit()
{
    DWORD            dwDeviceLimit = 0;
    PRODUCT_SKU_TYPE typeSKU = GetProductSKU();

    switch(typeSKU)
    {
    case PRODUCT_SKU_PERSONAL:
    case PRODUCT_SKU_PROFESSIONAL:
        dwDeviceLimit = 1;
        break;
    case PRODUCT_SKU_SERVER:
        dwDeviceLimit = 4;
        break;
    case PRODUCT_SKU_ADVANCED_SERVER:
    case PRODUCT_SKU_DATA_CENTER:
        dwDeviceLimit = INFINITE;
        break;
    }

    return dwDeviceLimit;
}


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsFaxComponentInstalled
//
//  Purpose:        
//                  Check if specific fax component is installed
//
//  Params:
//                  Fax component ID
//
//  Return Value:
//                  TRUE if the fax component is installed
//                  FALSE otherwize 
///////////////////////////////////////////////////////////////////////////////////////
BOOL
IsFaxComponentInstalled(
    FAX_COMPONENT_TYPE component
)
{
    HKEY  hKey;
    DWORD dwRes;
    DWORD dwComponent = 0;
    BOOL  bComponentInstalled = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("IsFaxComponentInstalled"))

	PRODUCT_SKU_TYPE skuType = GetProductSKU();
	if (
		(skuType == PRODUCT_SKU_DESKTOP_EMBEDDED) ||
		(skuType == PRODUCT_SKU_SERVER_EMBEDDED)
		)
	{
		// In case this is an embedded system we have to check in the registry
		// what are the installed components
		dwRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, 0, KEY_READ, &hKey);
		if (dwRes == ERROR_SUCCESS) 
		{
			dwRes = GetRegistryDwordEx(hKey, REGVAL_INSTALLED_COMPONENTS, &dwComponent);
			if (dwRes != ERROR_SUCCESS) 
			{
				DebugPrintEx(DEBUG_ERR,TEXT("GetRegistryDwordEx failed with %ld."), dwRes);
			}
			RegCloseKey(hKey);
		}
		else
		{
			DebugPrintEx(DEBUG_ERR,TEXT("RegOpenKeyEx failed with %ld."), dwRes);
		}
		bComponentInstalled = (dwComponent & component);
	}
	else
	{
		// the system is not embedded
		// 
		if (IsDesktopSKU())
		{
			// DESKTOP skus -> Admin and Admin help is not installed
			if (
				(component != FAX_COMPONENT_ADMIN) &&
				(component != FAX_COMPONENT_HELP_ADMIN_HLP) &&
				(component != FAX_COMPONENT_HELP_ADMIN_CHM)
				)
			{
				bComponentInstalled  = TRUE;
			}
		}
		else
		{
			// SERVER skus -> all components are installed
			bComponentInstalled  = TRUE;
		}
	}
	
	return bComponentInstalled;		
} // IsFaxComponentInstalled
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\security.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	Security.cpp

Abstract:

	General fax server security utility functions

Author:

	Eran Yariv (EranY)	Feb, 2001

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <Accctrl.h>
#include <Aclapi.h>

#include "faxutil.h"
#include "faxreg.h"
#include "FaxUIConstants.h"


HANDLE 
EnablePrivilege (
    LPCTSTR lpctstrPrivName
)
/*++

Routine name : EnablePrivilege

Routine description:

	Enables a specific privilege in the current thread (or process) access token

Author:

	Eran Yariv (EranY),	Feb, 2001

Arguments:

	lpctstrPrivName   [in]  - Privilege to enable (e.g. SE_TAKE_OWNERSHIP_NAME)

Return Value:

    INVALID_HANDLE_VALUE on failure (call GetLastError to get error code).
    On success, returns the handle which holds the thread/process priviledges before the change.

    If the return value != NULL, the caller must call ReleasePrivilege() to restore the 
    access token state and release the handle.

--*/
{
    BOOL                fResult;
    HANDLE              hToken = INVALID_HANDLE_VALUE;
    HANDLE              hOriginalThreadToken = INVALID_HANDLE_VALUE;
    LUID                luidPriv;
    TOKEN_PRIVILEGES    tp = {0};

    DEBUG_FUNCTION_NAME( TEXT("EnablePrivileges"));

    Assert (lpctstrPrivName);
    //
    // Get the LUID of the privilege.
    //
    if (!LookupPrivilegeValue(NULL,
                              lpctstrPrivName,
                              &luidPriv))
    {
        DebugPrintEx(
			DEBUG_ERR,
			_T("Failed to LookupPrivilegeValue. (ec: %ld)"), 
			GetLastError ());
        return INVALID_HANDLE_VALUE;
    }

    //
    // Initialize the Privileges Structure
    //
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    tp.Privileges[0].Luid = luidPriv;
    //
    // Open the Token
    //
    fResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken);
    if (fResult)
    {
        //
        // Remember the thread token
        //
        hOriginalThreadToken = hToken;  
    }
    else
    {
        fResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
    }
    if (fResult)
    {
        HANDLE hNewToken;
        //
        // Duplicate that Token
        //
        fResult = DuplicateTokenEx(hToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   NULL,                                // PSECURITY_ATTRIBUTES
                                   SecurityImpersonation,               // SECURITY_IMPERSONATION_LEVEL
                                   TokenImpersonation,                  // TokenType
                                   &hNewToken);                         // Duplicate token
        if (fResult)
        {
            //
            // Add new privileges
            //
            fResult = AdjustTokenPrivileges(hNewToken,  // TokenHandle
                                            FALSE,      // DisableAllPrivileges
                                            &tp,        // NewState
                                            0,          // BufferLength
                                            NULL,       // PreviousState
                                            NULL);      // ReturnLength
            if (fResult)
            {
                //
                // Begin impersonating with the new token
                //
                fResult = SetThreadToken(NULL, hNewToken);
            }
            CloseHandle(hNewToken);
        }
    }
    //
    // If something failed, don't return a token
    //
    if (!fResult)
    {
        hOriginalThreadToken = INVALID_HANDLE_VALUE;
    }
    if (INVALID_HANDLE_VALUE == hOriginalThreadToken)
    {
        //
        // Using the process token
        //
        if (INVALID_HANDLE_VALUE != hToken)
        {
            //
            // Close the original token if we aren't returning it
            //
            CloseHandle(hToken);
        }
        if (fResult)
        {
            //
            // If we succeeded, but there was no original thread token,
            // return NULL to indicate we need to do SetThreadToken(NULL, NULL) to release privs.
            //
            hOriginalThreadToken = NULL;
        }
    }
    return hOriginalThreadToken;
}   // EnablePrivilege


void 
ReleasePrivilege(
    HANDLE hToken
)
/*++

Routine name : ReleasePrivilege

Routine description:

	Resets privileges to the state prior to the corresponding EnablePrivilege() call

Author:

	Eran Yariv (EranY),	Feb, 2001

Arguments:

	hToken  [IN]    - Return value from the corresponding EnablePrivilege() call

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME( TEXT("ReleasePrivilege"));
    if (INVALID_HANDLE_VALUE != hToken)
    {
        SetThreadToken(NULL, hToken);
        if (hToken)
        {
            CloseHandle(hToken);
        }
    }
}   // ReleasePrivilege


DWORD
FaxGetAbsoluteSD(
    PSECURITY_DESCRIPTOR pSelfRelativeSD,
    PSECURITY_DESCRIPTOR* ppAbsoluteSD
    )
/*++

Routine name : FaxGetAbsoluteSD

Routine description:

    Converts a self relative security descriptor to an absolute one.
    The caller must call LoclaFree on each component of the descriptor and on the descriptor, to free the allocated memory.
    The caller can use FaxFreeAbsoluteSD() to free the allocated memory.

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    pSelfRelativeSD         [in    ] - Pointer to a self relative SD
    ppAbsoluteSD            [out   ] - Address of a pointer to an absolute SD.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    BOOL bRet;
    DWORD AbsSdSize = 0;
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD OwnerSize = 0;
    DWORD GroupSize = 0;
    PACL pAbsDacl = NULL;
    PACL pAbsSacl = NULL;
    PSID pAbsOwner = NULL;
    PSID pAbsGroup = NULL;
    PSECURITY_DESCRIPTOR pAbsSD = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetAbsoluteSD"));

    Assert (pSelfRelativeSD && ppAbsoluteSD);

    if (!IsValidSecurityDescriptor(pSelfRelativeSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    if (!GetSecurityDescriptorControl( pSelfRelativeSD, &Control, &dwRevision))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSecurityDescriptorControl() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    Assert (SE_SELF_RELATIVE & Control &&
            SECURITY_DESCRIPTOR_REVISION == dwRevision);

    //
    // the security descriptor needs to be converted to absolute format.
    //
    bRet = MakeAbsoluteSD( pSelfRelativeSD,
                           NULL,
                           &AbsSdSize,
                           NULL,
                           &DaclSize,
                           NULL,
                           &SaclSize,
                           NULL,
                           &OwnerSize,
                           NULL,
                           &GroupSize
                         );
    Assert(FALSE == bRet);  // We succeeded with NULL buffers !?#
    rc = GetLastError();

    if (ERROR_INSUFFICIENT_BUFFER != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MakeAbsoluteSD() failed (ec: %ld)"),
            rc);
        goto exit;
    }
    rc = ERROR_SUCCESS;

    Assert (AbsSdSize);
    pAbsSD = LocalAlloc(LPTR, AbsSdSize);

    if (DaclSize)
    {
        pAbsDacl = (PACL)LocalAlloc(LPTR, DaclSize);
    }

    if (SaclSize)
    {
        pAbsSacl = (PACL)LocalAlloc(LPTR, SaclSize);
    }

    if (OwnerSize)
    {
        pAbsOwner = LocalAlloc(LPTR, OwnerSize);
    }

    if (GroupSize)
    {
        pAbsGroup = LocalAlloc(LPTR, GroupSize);
    }

    if ( NULL == pAbsSD ||
        (NULL == pAbsDacl && DaclSize) ||
        (NULL == pAbsSacl && SaclSize) ||
        (NULL == pAbsOwner && OwnerSize) ||
        (NULL == pAbsGroup && GroupSize)
       )
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate absolute security descriptor"));
        goto exit;
    }

    if (!MakeAbsoluteSD( pSelfRelativeSD,
                         pAbsSD,
                         &AbsSdSize,
                         pAbsDacl,
                         &DaclSize,
                         pAbsSacl,
                         &SaclSize,
                         pAbsOwner,
                         &OwnerSize,
                         pAbsGroup,
                         &GroupSize
                       ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MakeAbsoluteSD() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    if (!IsValidSecurityDescriptor(pAbsSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    *ppAbsoluteSD = pAbsSD;

    Assert (ERROR_SUCCESS == rc);

exit:
    if (ERROR_SUCCESS != rc)
    {
        if (pAbsDacl)
        {
            LocalFree( pAbsDacl );
        }

        if (pAbsSacl)
        {
            LocalFree( pAbsSacl );
        }

        if (pAbsOwner)
        {
            LocalFree( pAbsOwner );
        }

        if (pAbsGroup)
        {
            LocalFree( pAbsGroup );
        }

        if (pAbsSD)
        {
            LocalFree( pAbsSD );
        }
    }
    return rc;
}   // FaxGetAbsoluteSD

void
FaxFreeAbsoluteSD (
    PSECURITY_DESCRIPTOR pAbsoluteSD,
    BOOL bFreeOwner,
    BOOL bFreeGroup,
    BOOL bFreeDacl,
    BOOL bFreeSacl,
    BOOL bFreeDescriptor
    )
/*++

Routine name : FaxFreeAbsoluteSD

Routine description:

    Frees the memory allocated by an absolute SD returned from a call to GetAbsoluteSD()

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    pAbsoluteSD         [in] - Pointer to theSD to be freed.
    bFreeOwner          [in] - Flag that indicates to free the owner.
    bFreeGroup          [in] - Flag that indicates to free the group.
    bFreeDacl           [in] - Flag that indicates to free the dacl.
    bFreeSacl           [in] - Flag that indicates to free the sacl.
    bFreeDescriptor     [in] - Flag that indicates to free the descriptor.

Return Value:

    None.

--*/
{
    PSID pSidToFree = NULL;
    PACL pAclToFree = NULL;
    BOOL bDefault;
    BOOL bAaclPresent;
    DEBUG_FUNCTION_NAME(TEXT("FaxFreeAbsoluteSD"));

    Assert (pAbsoluteSD);

    if (TRUE == bFreeGroup)
    {
        if (!GetSecurityDescriptorGroup( pAbsoluteSD, &pSidToFree, &bDefault))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSecurityDescriptorGroup failed with (%ld), Not freeing descriptor's primary group"),
                GetLastError());
        }
        else
        {
            if (pSidToFree)
            {
                LocalFree (pSidToFree);
                pSidToFree = NULL;
            }
        }
    }

    if (TRUE == bFreeOwner)
    {
        if (!GetSecurityDescriptorOwner( pAbsoluteSD, &pSidToFree, &bDefault))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSecurityDescriptorOwner failed with (%ld), Not freeing descriptor's owner"),
                GetLastError());
        }
        else
        {
            if (pSidToFree)
            {
                LocalFree (pSidToFree);
                pSidToFree = NULL;
            }
        }
    }

    if (TRUE == bFreeDacl)
    {
        if (!GetSecurityDescriptorDacl( pAbsoluteSD,
                                        &bAaclPresent,
                                        &pAclToFree,
                                        &bDefault))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSecurityDescriptorDacl failed with (%ld), Not freeing descriptor's DAcl"),
                GetLastError());
        }
        else
        {
            if (bAaclPresent && pAclToFree)
            {
                LocalFree (pAclToFree);
                pAclToFree = NULL;
            }
        }
    }

    if (TRUE == bFreeSacl)
    {
        if (!GetSecurityDescriptorSacl( pAbsoluteSD,
                                        &bAaclPresent,
                                        &pAclToFree,
                                        &bDefault))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSecurityDescriptorSacl failed with (%ld), Not freeing descriptor's Sacl"),
                GetLastError());
        }
        else
        {
            if (bAaclPresent && pAclToFree)
            {
                LocalFree (pAclToFree);
                pAclToFree = NULL;
            }
        }
    }

    if (TRUE == bFreeDescriptor)
    {
        LocalFree (pAbsoluteSD);
    }
    return;
}   // FaxFreeAbsoluteSD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module provides a generic table driven access
    to the registry.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "fxsapip.h"
#include "faxutil.h"
#include "faxreg.h"



HKEY
OpenRegistryKey(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    )
{
    LONG    Rslt;
    HKEY    hKeyNew = NULL;
    DWORD   Disposition;


    if (CreateNewKey) {
        Rslt = RegCreateKeyEx(
            hKey,
            KeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            NULL,
            &hKeyNew,
            &Disposition
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            DebugPrint(( TEXT("RegCreateKeyEx() failed, ec=%d"), Rslt ));
            SetLastError (Rslt);
            return NULL;
        }

        if (Disposition == REG_CREATED_NEW_KEY) {
            DebugPrint(( TEXT("Created new fax registry key, ec=%d"), Rslt ));
        }
    } else {
        Rslt = RegOpenKeyEx(
            hKey,
            KeyName,
            0,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            &hKeyNew
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            DebugPrint(( TEXT("RegOpenKeyEx() failed, ec=%d"), Rslt ));
            SetLastError (Rslt);
            return NULL;
        }
    }

    Assert (hKeyNew);
    SetLastError (ERROR_SUCCESS);
    return hKeyNew;
}

LPTSTR
GetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    )
{
    BOOL    Success = FALSE;
    DWORD   Size;
    LONG    Rslt;
    DWORD   Type;
    LPBYTE  Buffer = NULL;
    LPBYTE  ExpandBuffer = NULL;
    LPTSTR  ReturnBuff = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        if (Rslt == ERROR_FILE_NOT_FOUND)
        {
            if (DefaultValue)
            {
                Size = (RegType==REG_MULTI_SZ) ? MultiStringSize(DefaultValue) : StringSize( DefaultValue );
            }
            else
            {
                DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d - and no default value was specified"), Rslt ));
                goto exit;
            }
        }
        else
        {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
    }
    else
    {
        if (Type != RegType)
        {
            return NULL;
        }
    }

    if (Size == 0)
    {
        Size = 32;
    }

    Buffer = (LPBYTE) MemAlloc( Size );
    if (!Buffer)
    {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        if (Rslt != ERROR_FILE_NOT_FOUND)
        {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        if (DefaultValue)
        {
            if ( RegType == REG_MULTI_SZ )
                CopyMultiString( (LPTSTR) Buffer, DefaultValue );
            else
                _tcscpy( (LPTSTR) Buffer, DefaultValue );
        }
        else
        {
            DebugPrint((TEXT("Can't create DefaultValue since it's NULL")));
            goto exit;
        }

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            RegType,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS)
        {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            goto exit;
        }
    }
    if (RegType == REG_EXPAND_SZ)
    {
        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, NULL, 0 );
        if (!Rslt)
        {
            goto exit;
        }

        Size = (Rslt + 1) * sizeof(WCHAR);
        ExpandBuffer = (LPBYTE) MemAlloc( Size );
        if (!ExpandBuffer) {
            goto exit;
        }

        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, (LPTSTR) ExpandBuffer, Rslt );
        if (Rslt == 0) {
            MemFree( ExpandBuffer );
            ExpandBuffer = NULL;
            DebugPrint(( TEXT("ExpandEnvironmentStrings() failed, ec=%d"), GetLastError() ));
            goto exit;
        }
        MemFree( Buffer );
        Buffer = ExpandBuffer;
    }

    Success = TRUE;
    if (StringSize)
    {
        *StringSize = Size;
    }

exit:
    if (!Success)
    {
        MemFree( Buffer );

        if (StringSize)
        {
            *StringSize = 0;
        }

        if (DefaultValue)
        {
            Size = (RegType==REG_MULTI_SZ) ? MultiStringSize(DefaultValue) : StringSize( DefaultValue );
            
            ReturnBuff = (LPTSTR) MemAlloc( Size );
            
            if ( !ReturnBuff )
                return NULL;

            if ( RegType == REG_MULTI_SZ )
                CopyMultiString( ReturnBuff, DefaultValue );
            else
                _tcscpy( ReturnBuff, DefaultValue );

            
            if (StringSize)
            {
                *StringSize = Size;
            }
            
            return ReturnBuff;
        }
        else
        {
            return NULL;
        }
    }
    
    return (LPTSTR) Buffer;
}



LPTSTR
GetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_SZ, ValueName, DefaultValue, NULL );
}


LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, DefaultValue, NULL );
}

LPTSTR
GetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    )
{
    return GetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, DefaultValue, StringSize );
}


DWORD
GetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName
    )
{
    DWORD   Size = sizeof(DWORD);
    LONG    Rslt;
    DWORD   Type;
    DWORD   Value = 0;

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // create the value since it doesn't exist
        //
        Value = 0;

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Value,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            Value = 0;
        }
    }
    return Value;
}


LPBYTE
GetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD DataSize
    )
{
    BOOL    Success = FALSE;
    DWORD   Size = 0;
    LONG    Rslt;
    DWORD   Type = REG_BINARY;
    LPBYTE  Buffer = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == ERROR_FILE_NOT_FOUND) {
            Size = 1;
        } else {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
    } else {
        if (Type != REG_BINARY) {
            return NULL;
        }
    }

    if (Size == 0) {
        Size = 1;
    }

    Buffer = (LPBYTE) MemAlloc( Size );
    if (!Buffer) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt != ERROR_FILE_NOT_FOUND) {
            DebugPrint(( TEXT("RegQueryValueEx() failed, ec=%d"), Rslt ));
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_BINARY,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
            goto exit;
        }
    }
    Success = TRUE;
    if (DataSize) {
        *DataSize = Size;
    }

exit:
    if (!Success) {
        MemFree( Buffer );
        return NULL;
    }

    return Buffer;
}


DWORD
GetSubKeyCount(
    HKEY hKey
    )
{
    DWORD KeyCount = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, &KeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return KeyCount;
}


DWORD
GetMaxSubKeyLen(
    HKEY hKey
    )
{
    DWORD MaxSubKeyLen = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, &MaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return MaxSubKeyLen;
}


BOOL
SetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName,
    DWORD Value
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_DWORD,
        (LPBYTE) &Value,
        sizeof(DWORD)
        );
    if (Rslt != ERROR_SUCCESS)
    {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        SetLastError (Rslt);
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    const LPBYTE Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_BINARY,
        (LPBYTE) Value,
        Length
        );
    if (Rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPCTSTR ValueName,
    LPCTSTR Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        RegType,
        (LPBYTE) Value,
        Length == -1 ? StringSize( Value ) : Length
        );
    if (Rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("RegSetValueEx() failed[%s], ec=%d"), ValueName, Rslt ));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value,
    DWORD Length
    )
{
    return SetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, Value, Length );
}


DWORD
EnumerateRegistryKeys(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL ChangeValues,
    PREGENUMCALLBACK EnumCallback,
    LPVOID ContextData
    )
{
    LONG    Rslt;
    HKEY    hSubKey = NULL;
    HKEY    hKeyEnum = NULL;
    DWORD   Index = 0;
    DWORD   MaxSubKeyLen;
    DWORD   SubKeyCount;
    LPTSTR  SubKeyName = NULL;



    hSubKey = OpenRegistryKey( hKey, KeyName, ChangeValues, ChangeValues ? KEY_ALL_ACCESS : KEY_READ );
    if (!hSubKey) {
        goto exit;
    }

    Rslt = RegQueryInfoKey(
        hSubKey,
        NULL,
        NULL,
        NULL,
        &SubKeyCount,
        &MaxSubKeyLen,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // could not open the registry key
        //
        DebugPrint(( TEXT("RegQueryInfoKey() failed, ec=%d"), Rslt ));
        goto exit;
    }

    if (!EnumCallback( hSubKey, NULL, SubKeyCount, ContextData )) {
        goto exit;
    }

    MaxSubKeyLen += 4;

    SubKeyName = (LPTSTR) MemAlloc( (MaxSubKeyLen+1) * sizeof(WCHAR) );
    if (!SubKeyName) {
        goto exit;
    }

    while( TRUE ) {
        Rslt = RegEnumKey(
            hSubKey,
            Index,
            (LPTSTR) SubKeyName,
            MaxSubKeyLen
            );
        if (Rslt != ERROR_SUCCESS) {
            if (Rslt == ERROR_NO_MORE_ITEMS) {
                break;
            }
            DebugPrint(( TEXT("RegEnumKey() failed, ec=%d"), Rslt ));
            goto exit;
        }

        hKeyEnum = OpenRegistryKey( hSubKey, SubKeyName, ChangeValues, ChangeValues ? KEY_ALL_ACCESS : KEY_READ );
        if (!hKeyEnum) {
            continue;
        }

        if (!EnumCallback( hKeyEnum, SubKeyName, Index, ContextData )) {
            RegCloseKey( hKeyEnum );
            break;
        }

        RegCloseKey( hKeyEnum );
        Index += 1;
    }

exit:
    if (hSubKey) {
        RegCloseKey( hSubKey );
    }
    MemFree( SubKeyName );

    return Index;
}

BOOL
DeleteRegistryKey(
    HKEY hKey,
    LPCTSTR SubKey
    )
{
    HKEY  hKeyCurrent=NULL;
    TCHAR szName[MAX_PATH];
    DWORD dwName;
    long lResult;
    DEBUG_FUNCTION_NAME(TEXT("DeleteRegistryKey"));

    lResult = RegOpenKey(hKey,SubKey,&hKeyCurrent);
    if (lResult != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegOpenKey failed with %ld"),
            lResult);
        SetLastError (lResult);
        return FALSE;
    }

    

    for (;;)
    {
        dwName = sizeof(szName)/sizeof(TCHAR);

        lResult = RegEnumKeyEx(hKeyCurrent, 0, szName, &dwName, NULL, NULL, NULL, NULL);

        if (lResult == ERROR_SUCCESS)
        {
            if (!DeleteRegistryKey(hKeyCurrent,szName))
            {
                //
                // Some sons a NOT deleted. You can stop trying to remove stuff now.
                //
                return FALSE;
            }
        }
        else if (lResult == ERROR_NO_MORE_ITEMS)
        {
            //
            // No more sons, can delete father key
            //
            break;
        }
        else
        {
            //
            // other error
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegEnumKeyExKey failed with %ld"),
                lResult);
            RegCloseKey(hKeyCurrent);
            SetLastError (lResult);
            return FALSE;
        }
    }

    RegCloseKey(hKeyCurrent);
    lResult = RegDeleteKey(hKey, SubKey);
    if (ERROR_SUCCESS != lResult)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegDeleteKey failed with %ld"),
            lResult);
        SetLastError (lResult);
        return FALSE;
    }
    return TRUE;
}


DWORD
GetRegistryDwordEx(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD lpdwValue
    )
/*++

Routine name : GetRegistryDwordEx

Routine description:

    Retrieves a dword from the registry.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hKey            [in    ] - Handle to the open key
    ValueName           [in    ] - The value name
    lpdwValue           [out   ] - Pointer to a DWORD to recieve the value

Return Value:

    Standard win 32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwType= REG_DWORD;
    DWORD dwSize=0;
    DEBUG_FUNCTION_NAME(TEXT("GetRegistryDwordEx"));
    Assert (ValueName && lpdwValue);

    dwRes = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx failed with %ld"),
            dwRes);
        goto exit;
    }

    if (REG_DWORD != dwType)
    {
        // We expect only DWORD data here
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error not a DWORD type"));
        dwRes = ERROR_BADDB;    // The configuration registry database is corrupt.
        goto exit;
    }

    dwRes = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &dwType,
        (LPBYTE)lpdwValue,
        &dwSize
        );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx failed with %ld"),
            dwRes);
        goto exit;
    }
    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}


/*++

Routine name : DeleteDeviceEntry

Routine description:

    Delete service device entry from devices.

Author:

    Caliv Nir (t-nicali),    Apr, 2001

Arguments:

    serverPermanentID   [in] -  service device ID to be deleted

Return Value:
    
    Win32 error code
--*/
DWORD
DeleteDeviceEntry(DWORD serverPermanentID)
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.
    HKEY    hKeyDevices;
    TCHAR   DevicesKeyName[MAX_PATH];
    
    DEBUG_FUNCTION_NAME(TEXT("DeleteDeviceEntry"));
    //
    //  open - "fax\Devices\serverPermanentID" Registry Key
    //
    _stprintf( DevicesKeyName, TEXT("%s\\%010lu"), REGKEY_FAX_DEVICES, serverPermanentID );
    hKeyDevices = OpenRegistryKey( HKEY_LOCAL_MACHINE, DevicesKeyName, FALSE, KEY_ALL_ACCESS );
    if (!hKeyDevices)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("OpenRegistryKey failed with [%ld] the device entry might be missing."),
            ec
            );  
        return  ec;
    }

    //
    //  delete our servers data (under GUID and "Permanent Lineid" value)
    //
    if (!DeleteRegistryKey( hKeyDevices, REGKEY_FAXSVC_DEVICE_GUID))
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("DeleteRegistryKey failed, the device GUID might be missing.")
            );  
    }
    if (ERROR_SUCCESS != RegDeleteValue( hKeyDevices, REGVAL_PERMANENT_LINEID))
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("RegDeleteValue failed, the device \"PermanentLineID\" might be missing.")
            );  
    }

    //
    // check to see wheter the key is now empty
    //
    DWORD dwcSubKeys = 0;
    DWORD dwcValues = 0;

    ec=RegQueryInfoKey(
         hKeyDevices,            // handle to key
         NULL,
         NULL,
         NULL,
         &dwcSubKeys,            // number of subkeys
         NULL,
         NULL,
         &dwcValues,             // number of value entries
         NULL,
         NULL,
         NULL,
         NULL
    );

    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("RegQueryInfoKey Abort deleteion.")
            );  
        RegCloseKey(hKeyDevices);
        return ec;
    }
    
    RegCloseKey(hKeyDevices);
    
    if ( (0 == dwcSubKeys) && (0 == dwcValues) )
    {
        //
        // key is empty delete it
        //
        hKeyDevices = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, FALSE, KEY_ALL_ACCESS );
        if (!hKeyDevices)
        {
            ec = GetLastError();
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed with [%lu], Can't delete key."),
            ec
            );  
                    
            return ec;
        }
        
        DWORD dwLen = _tcslen( REGKEY_FAX_DEVICES ) + 1;
        
        Assert((DevicesKeyName + dwLen));
        Assert(*(DevicesKeyName + dwLen));
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Deleting Device entry %s"),
            (DevicesKeyName + dwLen)
            );  

        ec = RegDeleteKey( hKeyDevices, (DevicesKeyName + dwLen));
        if ( ERROR_SUCCESS != ec )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegDeleteKey failed, Can't delete key.")
            );
        }

        RegCloseKey(hKeyDevices);

    }
    
    return ec;
}



/*++

Routine name : DeleteCacheEntry

Routine description:

    Delete cache entry for a given Tapi ID

Author:

    Caliv Nir (t-nicali),    Apr, 2001

Arguments:

    dwTapiPermanentLineID       [in]    -   device Tapi permament ID

    
Return Value:

    Win32 Error code (ERROR_SUCCESS on success)

--*/
DWORD
DeleteCacheEntry(DWORD dwTapiPermanentLineID)
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.
    HKEY    hKey;
    TCHAR   strTapiPermanentLineID[10];
        
    DEBUG_FUNCTION_NAME(TEXT("DeleteCacheEntry"));

    //
    //  open - "fax\Device Cache" Registry Key
    //
    
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES_CACHE, FALSE, KEY_ALL_ACCESS );
    if (!hKey)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed, Can't delete key.")
            );  
        
        return ec;
    }

    _stprintf( strTapiPermanentLineID, TEXT("%08lx"),dwTapiPermanentLineID );
    
    if (!DeleteRegistryKey(hKey, strTapiPermanentLineID))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteRegistryKey failed with (%ld), Can't delete key."),
            ec);    
    }
    
    RegCloseKey(hKey);

    return ec;
}


/*++

Routine name : DeleteTapiEntry

Routine description:

    Delete Tapi entry when caching from TapiDevices, for a give Tapi ID

Author:

    Caliv Nir (t-nicali),    Apr, 2001

Arguments:

    dwTapiPermanentLineID       [in]    -   device Tapi permament ID

    
Return Value:

    Win32 Error code (ERROR_SUCCESS on success)

--*/
DWORD
DeleteTapiEntry(DWORD dwTapiPermanentLineID)
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.
    HKEY    hKey;
    TCHAR   strTapiPermanentLineID[10];
        
    DEBUG_FUNCTION_NAME(TEXT("DeleteTapiEntry"));

    //
    //  open - "fax\TAPIDevices" Registry Key
    //
    
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_TAPIDEVICES, FALSE, KEY_ALL_ACCESS );
    if (!hKey)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed, Can't delete key.")
            );  
        
        return ERROR_OPEN_FAILED;
    }

    _stprintf( strTapiPermanentLineID, TEXT("%08lx"),dwTapiPermanentLineID );
    
    if (!DeleteRegistryKey(hKey, strTapiPermanentLineID))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteRegistryKey failed with (%ld), Can't delete key."),
            ec);    
    }
    
    RegCloseKey(hKey);

    return ec;
}



/*++

Routine name : CopyRegistrySubkeysByHandle

Routine description:

    Copy a content of one registry key into another

Author:

    Caliv Nir (t-nicali),    Apr, 2001

Arguments:

    hkeyDest    [in]    - handle for destination registry key
    hkeySrc     [in]    - handle for source registry key

Return Value:

    Win32 Error code

--*/
DWORD
CopyRegistrySubkeysByHandle(
    HKEY    hkeyDest,
    HKEY    hkeySrc
    )
{

    LPTSTR  TempPath = NULL;
    DWORD   dwTempPathLength = 0;
    LPCTSTR strFileName = TEXT("tempCacheFile");
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.
    DEBUG_FUNCTION_NAME(TEXT("CopyRegistrySubkeysByHandle"));

    dwTempPathLength = GetTempPath(0,NULL) + 1;     // find out temp path size
    dwTempPathLength += _tcslen( strFileName ) + 1;     // add the length of file name
    dwTempPathLength += 2;                              // just to be sure

    TempPath = (LPTSTR) MemAlloc( dwTempPathLength * sizeof(TCHAR) );
    if (!TempPath )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MemAlloc failed. Can't continue")
            );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    if (!GetTempPath( dwTempPathLength, TempPath ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetTempPath failed with [%ld]. Can't continue"),
            ec);
        goto Exit;
    }

    _tcscat(TempPath,strFileName);

    //
    //  store hKeySrc in a file
    //
    HANDLE hOldPrivilege = EnablePrivilege(SE_BACKUP_NAME);
    if (INVALID_HANDLE_VALUE != hOldPrivilege)  // set proper previlege 
    {
        ec = RegSaveKey(
            hkeySrc,        // handle to key
            TempPath,       // data file
            NULL);
        if (ec != ERROR_SUCCESS)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegSaveKey failed with [%lu]. Can't continue"),
                ec
                );
            
            if (hOldPrivilege != NULL)
            {
                ReleasePrivilege(hOldPrivilege);
            }
            goto Exit;
        }


        if ( hOldPrivilege != NULL )
        {
            ReleasePrivilege(hOldPrivilege);
        }

    }
    else
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnablePrivilege(SE_BACKUP_NAME) failed with [%lu]. Can't continue"),
            ec
            );
        goto Exit;
    }

    //
    //  restore the registry values from the file into hkeyDest
    //
    hOldPrivilege = EnablePrivilege(SE_RESTORE_NAME);
    if (INVALID_HANDLE_VALUE != hOldPrivilege)  // set proper previlege
    {
        ec = RegRestoreKey(
            hkeyDest,       // handle to key where restore begins
            TempPath,       // registry file
            0);             // options
        if ( ec != ERROR_SUCCESS)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegRestoreKey failed. Can't continue")
                );
            if (hOldPrivilege != NULL)
            {
                ReleasePrivilege(hOldPrivilege);
            }
            goto Exit;
        }

        if ( hOldPrivilege != NULL )
        {
            ReleasePrivilege(hOldPrivilege);
        }
        
    }
    else
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnablePrivilege(SE_RESTORE_NAME) failed with [%lu]. Can't continue")
            );
        goto Exit;
    }



Exit:
    if (TempPath)
    {
        if (!DeleteFile(TempPath))
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("DeleteFile failed. file: %s. (ec=%ld)"),
                          TempPath,
                          GetLastError());
        }
        MemFree(TempPath);
    }
    return ec;
}


/*++

Routine name : CopyRegistrySubkeys

Routine description:

    Copy a content of one registry key into another

Author:

    Caliv Nir (t-nicali),    Apr, 2001

Arguments:

    strDest     [in]    -   string of destination registry key name
    strSrc      [in]    -   string of source registry key name

Return Value:

  Win32 Error Code

--*/
DWORD
CopyRegistrySubkeys(
    LPCTSTR strDest,
    LPCTSTR strSrc
    )
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function. 
    
    HKEY hKeyDest;
    HKEY hKeySrc;
    
    DEBUG_FUNCTION_NAME(TEXT("CopyRegistrySubkeys"));
    
    //
    //  open source Key
    //
    hKeySrc = OpenRegistryKey( HKEY_LOCAL_MACHINE, strSrc, FALSE, KEY_READ );
    if (!hKeySrc)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed with [%lu], Can't copy keys."),
            ec
            );  
        return  ec;
    }

    //
    //  open destination Key
    //
    hKeyDest = OpenRegistryKey( HKEY_LOCAL_MACHINE, strDest, TRUE, KEY_ALL_ACCESS);
    if (!hKeyDest)
    {
        ec = GetLastError();
        RegCloseKey (hKeySrc);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed [%lu], Can't copy keys."),
            ec
            );  
        return  ec;
    }

    //
    //  copy the keys using the registry Keys
    //
    ec = CopyRegistrySubkeysByHandle(hKeyDest,hKeySrc);
    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopyRegistrySubkeysHkey failed with [%lu], Can't copy keys."),
            ec
            );  
    }

    RegCloseKey (hKeyDest); 
    RegCloseKey (hKeySrc);
    
    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\debugex\debugex.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Debugex.cpp

Abstract:

    Implementation of the CDebug class.

Author:

    Eran Yariv (EranY)  Jul, 1999

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include "debugex.h"

#include <faxreg.h>     // We're reading the default mask from HKLM\REGKEY_FAXSERVER\REGVAL_DBGLEVEL_EX
#include <faxutil.h>    // For the DEBUG_VER_MSG, DEBUG_WRN_MSG, and DEBUG_ERR_MSG constants

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef ENABLE_FRE_LOGGING
#define ENABLE_LOGGING
#endif

#ifdef DEBUG 
#define ENABLE_LOGGING
#endif

#ifdef ENABLE_LOGGING
//////////////////////////////////////////////////////////////////////
// Static variables
//////////////////////////////////////////////////////////////////////

HANDLE  CDebug::m_shLogFile =           INVALID_HANDLE_VALUE;
LONG    CDebug::m_sdwIndent =           0;
DWORD   CDebug::m_sDbgMask =            DEFAULT_DEBUG_MASK;
DWORD   CDebug::m_sFmtMask =            DEFAULT_FORMAT_MASK;
BOOL    CDebug::m_sbMaskReadFromReg =   FALSE;
BOOL    CDebug::m_sbRegistryExist =     FALSE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDebug::~CDebug()
/*++

Routine name : CDebug::~CDebug

Routine description:

    Destructor

Author:

    Eran Yariv (EranY), Jul, 1999

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD dwLastError = GetLastError ();
    Unindent ();
    switch (m_ReturnType)
    {
        case DBG_FUNC_RET_UNKNOWN:
            DbgPrint (FUNC_TRACE, NULL, 0, TEXT("}"));
            break;

        case DBG_FUNC_RET_HR:
            //
            // We have the return HRESULT
            //
            if (NOERROR == *m_phr)
            {
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (NOERROR)"));
            }
            else if (S_FALSE == *m_phr)
            {
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (S_FALSE)"));
            }
            else
            {    
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (0x%08X)"), *m_phr);
            }
            break;

        case DBG_FUNC_RET_DWORD:
            //
            // We have the return DWORD
            //
            if (ERROR_SUCCESS == *m_pDword)
            {
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (ERROR_SUCCESS)"));
            }
            else
            {    
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (%ld)"), *m_pDword);
            }
            break;

        case DBG_FUNC_RET_BOOL:
            //
            // We have the return BOOL
            //
            if (*m_pBool)
            {
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (TRUE)"));
            }
            else
            {    
                DbgPrint (FUNC_TRACE, NULL, 0, TEXT("} (FALSE)"));
            }
            break;
        default:
            DbgPrint  (ASSERTION_FAILED, 
                       TEXT(__FILE__), 
                       __LINE__, 
                       TEXT("ASSERTION FAILURE!!!"));
            
            DebugBreak();

            break;
    }
    SetLastError (dwLastError);
}

//////////////////////////////////////////////////////////////////////
// Implementation
//////////////////////////////////////////////////////////////////////

void
CDebug::EnterModuleWithParams (
    LPCTSTR lpctstrModule, 
    LPCTSTR lpctstrFormat,
    va_list arg_ptr
)
{
    DWORD dwLastError = GetLastError ();
    if (!m_sbMaskReadFromReg)
    {
        ReadMaskFromReg ();
    }
    lstrcpyn (m_tszModuleName, 
              lpctstrModule, 
              sizeof (m_tszModuleName) / sizeof (m_tszModuleName[0]));
    TCHAR szArgs[1024];
    _vsntprintf(szArgs, sizeof(szArgs)/sizeof(szArgs[0]), lpctstrFormat, arg_ptr);

    TCHAR szBuf[1024];
    wsprintf (szBuf, TEXT("%s (%s)"), m_tszModuleName, szArgs);
    DbgPrint (FUNC_TRACE, NULL, 0, szBuf);
    DbgPrint (FUNC_TRACE, NULL, 0, TEXT("{"));
    Indent ();
    SetLastError (dwLastError);
}

void
CDebug::EnterModule (
    LPCTSTR lpctstrModule
)
{
    DWORD dwLastError = GetLastError ();
    if (!m_sbMaskReadFromReg)
    {
        ReadMaskFromReg ();
    }
    lstrcpyn (m_tszModuleName, 
              lpctstrModule, 
              sizeof (m_tszModuleName) / sizeof (m_tszModuleName[0]));
    DbgPrint (FUNC_TRACE, NULL, 0, m_tszModuleName);
    DbgPrint (FUNC_TRACE, NULL, 0, TEXT("{"));
    Indent ();
    SetLastError (dwLastError);
}

//*****************************************************************************
//* Name:   OpenLogFile
//* Author: Mooly Beery (MoolyB), May, 2000
//*****************************************************************************
//* DESCRIPTION:
//*     Creates a log file which accepts the debug output
//*     
//* PARAMETERS:
//*     [IN] LPCTSTR lpctstrFilename:
//*         the filename which will be created in the temporary folder
//*         
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*         this function should be used together with CloseLogFile()
//*****************************************************************************
BOOL CDebug::OpenLogFile(LPCTSTR lpctstrFilename)
{
    TCHAR szFilename[MAX_PATH]      = {0};
    TCHAR szTempFolder[MAX_PATH]    = {0};
    TCHAR szPathToFile[MAX_PATH]    = {0};

    if (!lpctstrFilename)
    {
        DbgPrint (ASSERTION_FAILED, 
                  TEXT(__FILE__), 
                  __LINE__, 
                  TEXT("Internat error - bad Filename"));
    
        DebugBreak();
        return FALSE;
    }

    // first expand the filename
    if (ExpandEnvironmentStrings(lpctstrFilename,szFilename,MAX_PATH)==0)
    {
        return FALSE;
    }
    // is this is a file description or a complete path to file
    if (_tcschr(szFilename,_T('\\'))==NULL)
    {
        // this is just the file's name, need to add the temp folder to it.
        if (GetTempPath(MAX_PATH,szTempFolder)==0)
        {
            return FALSE;
        }

        _tcsncpy(szPathToFile,szTempFolder,MAX_PATH-1);
        _tcsncat(szPathToFile,szFilename,MAX_PATH-_tcslen(szPathToFile)-1);
    }
    else
    {
        // this is the full path to the log file, use it.
        _tcsncpy(szPathToFile,szFilename,MAX_PATH-1);
    }

    m_shLogFile = ::CreateFile( szPathToFile,
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                                NULL);

    if (m_shLogFile==INVALID_HANDLE_VALUE)  
    {
        return FALSE;
    }

    SetLogFile(m_shLogFile);
    // no sense to open the file and not enable printing to it.
    m_sFmtMask |= DBG_PRNT_TO_FILE;
    return TRUE;
}

//*****************************************************************************
//* Name:   CloseLogFile
//* Author: Mooly Beery (MoolyB), May, 2000
//*****************************************************************************
//* DESCRIPTION:
//*     Closes the log file which accepts the debug output
//*     
//* PARAMETERS:
//*     
//* RETURN VALUE:
//*         
//* Comments:
//*         this function should be used together with OpenLogFile()
//*****************************************************************************
void CDebug::CloseLogFile()
{
    if (m_shLogFile!=INVALID_HANDLE_VALUE)  
    {
        ::CloseHandle(m_shLogFile);
        m_shLogFile = INVALID_HANDLE_VALUE;
    }
}

//*****************************************************************************
//* Name:   SetLogFile
//* Author: Mooly Beery (MoolyB), May, 2000
//*****************************************************************************
//* DESCRIPTION:
//*     redirects the debug output to the file whose handle is given
//*     
//* PARAMETERS:
//*     [IN] HANDLE hFile:
//*         the handle of the file which will accept the debug output
//*         
//* RETURN VALUE:
//*         the previous handle
//*         
//* Comments:
//*         this function should be used only in cases the OpenLogFile is
//*         insufficient and a different file location/type is required
//*         otherwise, don't manipulate the handle yourself, just use the
//*         pair OpenLogFile / CloseLogFile
//*****************************************************************************
HANDLE CDebug::SetLogFile(HANDLE hFile)
{ 
    HANDLE OldHandle = m_shLogFile; 
    m_shLogFile = hFile; 
    return OldHandle; 
}

void CDebug::DbgPrint ( 
    DbgMsgType type,
    LPCTSTR    lpctstrFileName,
    DWORD      dwLine,
    LPCTSTR    lpctstrFormat,
    ...
)
/*++

Routine name : CDebug::DbgPrint

Routine description:

    Print to debug (with file and line number)

Author:

    Eran Yariv (EranY), Jul, 1999

Arguments:

    type            [in] - Type of message
    lpctstrFileName [in] - Location of caller
    dwLine          [in] - Line of caller
    lpctstrFormat   [in] - printf format string
    ...             [in] - optional parameters

Return Value:

    None.

--*/
{
    va_list arg_ptr;
    va_start(arg_ptr, lpctstrFormat);
    Print (type, lpctstrFileName, dwLine, lpctstrFormat, arg_ptr);
    va_end (arg_ptr);
}


void CDebug::Trace (
    DbgMsgType type,
    LPCTSTR    lpctstrFormat,
    ...
)
/*++

Routine name : CDebug::DbgPrint

Routine description:

    Trace to debug

Author:

    Eran Yariv (EranY), Jul, 1999

Arguments:

    type            [in] - Type of message
    lpctstrFormat   [in] - printf format string
    ...             [in] - optional parameters

Return Value:

    None.

--*/
{
    va_list arg_ptr;
    va_start(arg_ptr, lpctstrFormat);
    Print (type, NULL, 0, lpctstrFormat, arg_ptr);
    va_end (arg_ptr);
}

void CDebug::Print (
    DbgMsgType  type,
    LPCTSTR     lpctstrFileName,
    DWORD       dwLine,
    LPCTSTR     lpctstrFormat,
    va_list     arg_ptr
)
/*++

Routine name : CDebug::Print

Routine description:

    Print to debug

Author:

    Eran Yariv (EranY), Jul, 1999
    Mooly Beery (MoolyB), Jun, 2000

Arguments:

    type            [in] - Type of message
    lpctstrFileName [in] - Location of caller
    dwLine          [in] - Line of caller
    lpctstrFormat   [in] - printf format string
    arg_ptr         [in] - optional parameters list

Return Value:

    None.

--*/
{
    if (!(type & m_sDbgMask))
    {
        //
        // This type of debug message is masked out
        //
        return;
    }

    TCHAR szMsg [2000];
    TCHAR szBuf [1000];
    TCHAR szTimeBuff[10];
    TCHAR szDateBuff[10];

    DWORD dwLastError = GetLastError();

    DWORD dwInd = 0;
    // Time stamps
    if (m_sFmtMask & DBG_PRNT_TIME_STAMP)
    {
        dwInd += _stprintf(&szMsg[dwInd], 
                          TEXT("[%-8s %-8s] "), 
                          _tstrdate(szDateBuff),
                          _tstrtime(szTimeBuff));
    }
    // Thread ID
    if (m_sFmtMask & DBG_PRNT_THREAD_ID)
    {
        dwInd += _stprintf(&szMsg[dwInd], 
                          TEXT("[0x%04x] "),
                          GetCurrentThreadId());
    }
    // Message type
    if (m_sFmtMask & DBG_PRNT_MSG_TYPE)
    {
        dwInd += _stprintf(&szMsg[dwInd], 
                          TEXT("[%s] "),
                          GetMsgTypeString(type));
    }

    // Now comes the actual message
    _vsntprintf(szBuf, sizeof(szBuf)/sizeof(TCHAR), lpctstrFormat, arg_ptr);
    DWORD dwlen = lstrlen(szBuf);
    dwInd += _stprintf( &szMsg[dwInd],
                        TEXT("%*c%s "),
                        m_sdwIndent * _DEBUG_INDENT_SIZE, 
                        TEXT(' '),
                        szBuf);

    // filename & line number
    if (m_sFmtMask & DBG_PRNT_FILE_LINE)
    {
        if (lpctstrFileName && dwLine)
        {
            dwInd += _stprintf( &szMsg[dwInd],
                                TEXT("(%s %ld)"),
                                lpctstrFileName,
                                dwLine);
        }
    }

    _stprintf( &szMsg[dwInd],TEXT("\n"));

    // standard output?
    if (m_sFmtMask & DBG_PRNT_TO_STD)
    {
        OutputDebugString(szMsg);
    }

    // file output?
    if (m_sFmtMask & DBG_PRNT_TO_FILE)
    {
        if (m_shLogFile!=INVALID_HANDLE_VALUE)
        {
            OutputFileString(szMsg);
        }
    }
    SetLastError (dwLastError);
}   // CDebug::Print
   
void  
CDebug::Unindent()                 
/*++

Routine name : CDebug::Unindent

Routine description:

    Move indention one step backwards

Author:

    Eran Yariv (EranY), Jul, 1999

Arguments:


Return Value:

    None.

--*/
{ 
    if (InterlockedDecrement(&m_sdwIndent)<0)
    {
        DbgPrint (ASSERTION_FAILED, 
                  TEXT(__FILE__), 
                  __LINE__, 
                  TEXT("Internat error - bad indent"));
        
        DebugBreak();
    }
}   // CDebug::Unindent

void CDebug::SetDebugMask(DWORD dwMask)
{ 
    m_sbMaskReadFromReg = TRUE;
    m_sDbgMask = dwMask; 
}

void CDebug::SetFormatMask(DWORD dwMask)
{ 
    m_sbMaskReadFromReg = TRUE;
    m_sFmtMask = dwMask; 
}

DWORD CDebug::ModifyDebugMask(DWORD dwAdd,DWORD dwRemove)
{
    if (!m_sbMaskReadFromReg)
    {
        // first let's read the requested debug mask & format
        ReadMaskFromReg();
    }
    m_sDbgMask |= dwAdd;
    m_sDbgMask &= ~dwRemove;

    return m_sDbgMask;
}

DWORD CDebug::ModifyFormatMask(DWORD dwAdd,DWORD dwRemove)
{
    if (!m_sbMaskReadFromReg)
    {
        // first let's read the requested debug mask & format
        ReadMaskFromReg();
    }
    m_sFmtMask |= dwAdd;
    m_sFmtMask &= ~dwRemove;

    return m_sFmtMask;
}

BOOL CDebug::DebugFromRegistry()
{ 
    if (!m_sbMaskReadFromReg)
    {
        // first let's read the requested debug mask & format
        ReadMaskFromReg();
    }
    return m_sbRegistryExist; 
}

BOOL CDebug::ReadMaskFromReg()
{
    BOOL  bRes = FALSE;
    HKEY  hkey = NULL;
    DWORD dwRegValue;
    DWORD dwRegType;
    DWORD dwRes;
    DWORD dwRegSize = sizeof (dwRegValue);
    if (m_sbMaskReadFromReg)
    {
        //
        // Debug & Format mask already read.
        //
        goto end;
    }
    m_sbMaskReadFromReg = TRUE;
    m_sDbgMask = DEFAULT_DEBUG_MASK;
    m_sFmtMask = DEFAULT_FORMAT_MASK;

    dwRes = RegOpenKey (HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, &hkey);
    if (ERROR_SUCCESS != dwRes)
    {
        goto end;
    }
    dwRes = RegQueryValueEx (hkey,
                             REGVAL_DBGLEVEL_EX,
                             NULL,
                             &dwRegType,
                             (LPBYTE)&dwRegValue,
                             &dwRegSize);
    if (ERROR_SUCCESS != dwRes)
    {
        goto end;
    }
    if (REG_DWORD != dwRegType)
    {
        //
        // Expecting only a DWORD value
        //
        goto end;
    }
    //
    // Convert DEBUG_VER_MSG, DEBUG_WRN_MSG, and DEBUG_ERR_MSG to our constant flags.
    //
    m_sDbgMask = ASSERTION_FAILED;
    if (dwRegValue & DEBUG_VER_MSG)
    {
        m_sDbgMask |= (DBG_MSG | FUNC_TRACE);
    }
    if (dwRegValue & DEBUG_WRN_MSG)
    {
        m_sDbgMask |= DBG_WARNING;
    }
    if (dwRegValue & DEBUG_ERR_MSG)
    {
        m_sDbgMask |= (DBG_ALL & ~(DBG_WARNING | DBG_MSG | FUNC_TRACE));
    }
    
    dwRes = RegQueryValueEx (hkey,
                             REGVAL_DBGFORMAT_EX,
                             NULL,
                             &dwRegType,
                             (LPBYTE)&dwRegValue,
                             &dwRegSize);
    if (ERROR_SUCCESS != dwRes)
    {
        goto end;
    }
    if (REG_DWORD != dwRegType)
    {
        //
        // Expecting only a DWORD value
        //
        goto end;
    }

    m_sFmtMask = dwRegValue;

    bRes = TRUE;
    m_sbRegistryExist = TRUE;

end:
    if (hkey)
    {
        RegCloseKey (hkey);
    }
    return bRes;
}   // CDebug::ReadMaskFromReg

BOOL CDebug::OutputFileString(LPCTSTR szMsg)
{
    BOOL bRes = FALSE;
    //
    // Attempt to add the line to a log file
    //
#ifdef UNICODE
    char sFileMsg[2000];

    int Count = WideCharToMultiByte(
        CP_ACP,
        0,
        szMsg,
        -1,
        sFileMsg,
        sizeof(sFileMsg)/sizeof(sFileMsg[0]),
        NULL,
        NULL
        );

    if (Count==0)
    {
        return bRes;
    }
#else
    const char* sFileMsg = szMsg;
#endif
    DWORD dwFilePointer = ::SetFilePointer(m_shLogFile,0,NULL,FILE_END);
    if (dwFilePointer==INVALID_SET_FILE_POINTER)
    {
        return bRes;
    }

    DWORD dwNumBytesWritten = 0;
    DWORD dwNumOfBytesToWrite = strlen(sFileMsg);
    if (!::WriteFile(m_shLogFile,sFileMsg,dwNumOfBytesToWrite,&dwNumBytesWritten,NULL))
    {
        return bRes;
    }

    if (dwNumBytesWritten!=dwNumOfBytesToWrite)
    {
        return bRes;
    }

    if (!::FlushFileBuffers(m_shLogFile))
    {
        return bRes;
    }

    bRes = TRUE;
    return bRes;
}


LPCTSTR CDebug::GetMsgTypeString(DWORD dwMask)
{
    switch (dwMask)
    {
    case ASSERTION_FAILED:  return _T("ERR");
    case DBG_MSG:          
    case FUNC_TRACE:        return _T("   ");
    case DBG_WARNING:       return _T("WRN");
    case MEM_ERR:
    case COM_ERR:
    case RESOURCE_ERR:
    case STARTUP_ERR:
    case GENERAL_ERR:
    case EXCEPTION_ERR:
    case RPC_ERR:
    case WINDOW_ERR:
    case FILE_ERR:
    case SECURITY_ERR:
    case REGISTRY_ERR:
    case PRINT_ERR:
    case SETUP_ERR:
    case NET_ERR:           return _T("ERR");
    default:                return _T("???");
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\tapi.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This file implements common TAPI functionality

Author:

    Mooly Beery (moolyb) 04-Jan-2001

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <WinSpool.h>

#include <faxutil.h>
#include <faxreg.h>

BOOL
GetCallerIDFromCall(
    HCALL hCall,
    LPTSTR lptstrCallerID,
    DWORD dwCallerIDSize
    )
/*++

Routine Description:
    This function will attempt to retrieve Caller ID data
    from the specified call handle.

Arguments:
    hCall           - TAPI call handle
    lptstrCallerID  - pointer to buffer for Caller ID string
    dwCallerIDSize  - size of the buffer pointed to by lptstrCallerID (bytes)

Return Values:
    TRUE for success
    FALSE for failure
--*/
{
    BOOL success = FALSE;
    LONG tapiStatus;
    DWORD dwCallInfoSize = sizeof(LINECALLINFO) + 2048;
    LINECALLINFO *pci = NULL;
    DEBUG_FUNCTION_NAME(TEXT("GetCallerIDFromCall"));

Retry:
    pci = (LINECALLINFO *)MemAlloc(dwCallInfoSize);
    if(pci == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("faled to allocate LINECALLINFO structure"));
        goto Cleanup;
    }

    ZeroMemory(pci, dwCallInfoSize);
    pci->dwTotalSize = dwCallInfoSize;

    tapiStatus = lineGetCallInfo(hCall, pci);

    if(tapiStatus == LINEERR_STRUCTURETOOSMALL)
    {
        dwCallInfoSize = pci->dwNeededSize;
		MemFree(pci);
        goto Retry;
    }

    if(tapiStatus != 0)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineGetCallInfo() failed for offered call (error %x)"),
            tapiStatus);
        goto Cleanup;
    };

    // make sure we have enough space for caller ID and terminator
    if(pci->dwCallerIDSize + sizeof(TCHAR) > dwCallerIDSize)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto Cleanup;
    }

    if(pci->dwCallerIDSize != 0)
    {
        memcpy((BYTE *)lptstrCallerID, (BYTE *)pci + pci->dwCallerIDOffset, pci->dwCallerIDSize);
    }

    // make sure it is zero terminated
    lptstrCallerID[(pci->dwCallerIDSize / sizeof(TCHAR))] = TEXT('\0');

    success = TRUE;


Cleanup:
    if(pci)
    {
        MemFree(pci);
    }

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\debugex\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=debugex
TARGETPATH=obj
TARGETTYPE=LIBRARY

USE_LIBCMT=1
USE_NATIVE_EH=1

INCLUDES=$(BASEDIR)\public\sdk\inc;                 \
         ..\..\..\inc;

C_DEFINES= $(C_DEFINES) -DWIN32 -DENABLE_FRE_LOGGING

SOURCES=\
	debugex.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\debugex\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <shellapi.h>
#include <commctrl.h>

extern CComModule _Module;

#include <atlcom.h>
#include <atlhost.h>
#include <atlwin.h>

#include <atldlgs.h>
#include <atlctl.h>
#include <atlctrls.h>

#include "resource.h"

#include <icomponentimpl.h>
#include <isetup.h>
#include <propguid.h>


extern const IID LIBID_MpLib;
extern const CLSID CLSID_ComMpComponent;
extern const ModuleID CartmanMpComponentID;
extern const VersionID MpVersionID;

#endif	// _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\wiaseld.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIASELD.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        2/27/1999
 *
 *  DESCRIPTION: Device selection dialog
 *
 *******************************************************************************/
#ifndef __WIASELD_H_INCLUDED
#define __WIASELD_H_INCLUDED

#if defined(__cplusplus)
extern "C" {
#endif

#include "wia.h"

typedef struct _SELECTDEVICEDLG
{
    DWORD        cbSize;
    HWND         hwndParent;
    LPWSTR       pwszInitialDeviceId;
    IWiaItem   **ppWiaItemRoot;
    LONG         nFlags;
    LONG         nDeviceType;
    BSTR         *pbstrDeviceID;
} SELECTDEVICEDLG, *LPSELECTDEVICEDLG, *PSELECTDEVICEDLG;

HRESULT WINAPI SelectDeviceDlg( PSELECTDEVICEDLG pSelectDeviceDlg );

typedef HRESULT (WINAPI *SELECTDEVICEDLGFUNCTION)( PSELECTDEVICEDLG );

#if defined(__cplusplus)
};
#endif

#endif // __WIASELD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\wiadevdp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADEVDP.H
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/15/1999
 *
 *  DESCRIPTION: Private Device Dialog Declarations
 *
 *******************************************************************************/
#ifndef _WIADEVDP_H_INCLUDED
#define _WIADEVDP_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

//
// Private flags for WIA enumeration
//
//      DEV_MAN_ENUM_TYPE_REMOTE    Will enumerate local AND remote
//      DEV_MAN_ENUM_TYPE_VOL       Will enumerate our volume devices
//      DEV_MAN_ENUM_TYPE_INACTIVE  Will enumerate inactive devices (e.g. USB 
//                                  device thaat is unplugged)
//      DEV_MAN_ENUM_TYPE_STI       Will enumerate STI only devices too
//      DEV_MAN_ENUM_TYPE_ALL       Will enumerate all devices
//
#define DEV_MAN_ENUM_TYPE_REMOTE    0x00000001
#define DEV_MAN_ENUM_TYPE_VOL       0x00000002
#define DEV_MAN_ENUM_TYPE_INACTIVE  0x00000004
#define DEV_MAN_ENUM_TYPE_STI       0x00000008
#define DEV_MAN_ENUM_TYPE_ALL       0x0000000F

DEFINE_GUID( CLSID_WiaDefaultUi, 0xD1621129, 0x45C4, 0x41AD, 0xA1, 0xD1, 0xAF, 0x7E, 0xAF, 0xAB, 0xEE, 0xDC );

//
// {F1ABE2B5-C073-4dba-B6EB-FD7A5111DD8F}
//
DEFINE_GUID( CLSID_WiaAutoPlayDropTarget, 0xf1abe2b5, 0xc073, 0x4dba, 0xb6, 0xeb, 0xfd, 0x7a, 0x51, 0x11, 0xdd, 0x8f );

//
// Private interface used to call system ui
//
#undef  INTERFACE
#define INTERFACE IWiaGetImageDlg
DECLARE_INTERFACE_(IWiaGetImageDlg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaGetImageDlg methods ***
    STDMETHOD(SelectDeviceDlg) (THIS_
        HWND         hwndParent,
        BSTR         bstrInitialDeviceId,
        LONG         lDeviceType,
        LONG         lFlags,
        BSTR        *pbstrDeviceID,
        IWiaItem   **ppWiaItemRoot );

    STDMETHOD(GetImageDlg)( THIS_
        IWiaDevMgr  *pWiaDevMgr,
        HWND         hwndParent,
        LONG         lDeviceType,
        LONG         lFlags,
        LONG         lIntent,
        IWiaItem    *pItemRoot,
        BSTR         bstrFilename,
        GUID        *pguidFormat );
};

DEFINE_GUID( IID_IWiaGetImageDlg, 0x4F67AD3C, 0x19EA, 0x4CE9, 0x80, 0xE2, 0x3A, 0xDE, 0x50, 0xD5, 0x02, 0xA2 );

//
// Hide various controls
//
#define WIA_PROGRESSDLG_NO_PROGRESS              0x00000001
#define WIA_PROGRESSDLG_NO_CANCEL                0x00000002
#define WIA_PROGRESSDLG_NO_ANIM                  0x00000004
#define WIA_PROGRESSDLG_NO_TITLE                 0x00000008

//
// Animation flags
//
#define WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE 0x00010000
#define WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE  0x00020000
#define WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE   0x00040000
#define WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE     0x00080000
#define WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE      0x00100000
#define WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE       0x00200000
#define WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE 0x00400000

#undef  INTERFACE
#define INTERFACE IWiaProgressDialog
DECLARE_INTERFACE_(IWiaProgressDialog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IWiaProgressDialog methods ***
    STDMETHOD(Create)(THIS_ HWND hwndParent, LONG lFlags );
    STDMETHOD(Show)(THIS);
    STDMETHOD(Hide)(THIS);
    STDMETHOD(Cancelled)( THIS_ BOOL *pbCancelled );
    STDMETHOD(SetTitle)( THIS_ LPCWSTR pszMessage );
    STDMETHOD(SetMessage)( THIS_ LPCWSTR pszTitle );
    STDMETHOD(SetPercentComplete)( THIS_ UINT nPercent );
    STDMETHOD(Destroy)(THIS);
};

// {F740718A-E460-4b05-83E8-C5D221C772E5}
DEFINE_GUID( IID_IWiaProgressDialog, 0xF740718A, 0xE460, 0x4B05, 0x83, 0xE8, 0xC5, 0xD2, 0x21, 0xC7, 0x72, 0xE5 );


// {8144B6F5-20A8-444a-B8EE-19DF0BB84BDB}
DEFINE_GUID( CLSID_StiEventHandler, 0x8144b6f5, 0x20a8, 0x444a, 0xb8, 0xee, 0x19, 0xdf, 0xb, 0xb8, 0x4b, 0xdb );


#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVDP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\shortcut.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    shortcut.c

Abstract:

    This module contains code to manipulate shortcuts.

Author:

    Wesley Witt (wesw) 24-Jul-1997


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <winspool.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"
#include "prtcovpg.h"
#include <shfolder.h>

//
// Cover page filename extension and link filename extension
//

#define FILENAME_EXT        TEXT('.')
#define MAX_FILENAME_EXT    4

//
// Whether not we've done OLE initialization
//

static BOOL oleInitialized = FALSE;

//
// Find the filename portion given a filename:
//  return a pointer to the '.' character if successful
//  NULL if there is no extension
//

#define FindFilenameExtension(pFilename) _tcsrchr(pFilename, FILENAME_EXT)


VOID
InitOle(
    VOID
    )

/*++

Routine Description:

    Perform OLE initialization if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (!oleInitialized) {

        HRESULT hResult = CoInitialize(NULL);

        if (hResult == S_OK || hResult == S_FALSE) {
            oleInitialized = TRUE;
        } else {
            DebugPrint(( TEXT("OLE initialization failed: %d\n"), hResult ));
        }
    }
}


VOID
DeinitOle(
    VOID
    )

/*++

Routine Description:

    Perform OLE deinitialization if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (oleInitialized) {
        CoUninitialize();
    }
}


BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    )

/*++

Routine Description:

    Resolve a shortcut to find the destination file

Arguments:

    pLinkName - Specifies the name of a link file
    pFileName - Points to a buffer for storing the destination filename

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    LPTSTR          pExtension;
    HRESULT         hResult;
    IShellLink      *pShellLink;
    IPersistFile    *pPersistFile = NULL;
#ifndef UNICODE
    LPWSTR          pLinkNameW;
#endif

    //
    // Default to empty string in case of an error
    //

    *pFileName = 0;

    if (!oleInitialized) {
        InitOle();
        if (!oleInitialized) {
            DebugPrint(( TEXT("OLE wasn't initialized successfully\n") ));
            return FALSE;
        }
    }

    //
    // Make sure the filename has the .LNK extension
    //

    if ((pExtension = FindFilenameExtension(pLinkName)) == NULL ||
        _tcsicmp(pExtension, FAX_LNK_FILE_EXT) != 0)
    {
        return FALSE;
    }

    //
    // Get a pointer to IShellLink interface
    //

    hResult = CoCreateInstance(CLSID_ShellLink,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IShellLink,
                               (void**)&pShellLink);

    if (SUCCEEDED(hResult)) {

        //
        // Get a pointer to IPersistFile interface
        //

        hResult = pShellLink->QueryInterface(IID_IPersistFile,
                                             (void**)&pPersistFile);

        if (SUCCEEDED(hResult)) {

            //
            // Now resolve the link to find the actually file it refers to
            //

#ifdef UNICODE
            hResult = pPersistFile->Load(pLinkName, STGM_READ);
#else
            pLinkNameW = AnsiStringToUnicodeString( pLinkName );
            hResult = pPersistFile->Load(pLinkNameW, STGM_READ);
            MemFree( pLinkNameW );
#endif

            if (SUCCEEDED(hResult)) {

                hResult = pShellLink->Resolve(NULL, SLR_NO_UI | 0x00010000);

                if (SUCCEEDED(hResult))
                    pShellLink->GetPath(pFileName, MAX_PATH, NULL, 0);
            }

            pPersistFile->Release();
        }

        pShellLink->Release();
    }

    return SUCCEEDED(hResult);
}


BOOL
CreateShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    )

/*++

Routine Description:

    Create a shortcut from pLinkName to pFileName

Arguments:

    pLinkName - Name of the link file
    pFileName - Name of the destination file

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HRESULT         hResult;
    IShellLink      *pShellLink;
    IPersistFile    *pPersistFile;
#ifndef UNICODE
    LPWSTR          pLinkNameW;
#endif


    if (!oleInitialized) {
        InitOle();
        if (!oleInitialized) {
            DebugPrint(( TEXT("OLE wasn't initialized successfully\n") ));
            return FALSE;
        }
    }

    hResult = CoCreateInstance(CLSID_ShellLink,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IShellLink,
                               (void**)&pShellLink);

    if (SUCCEEDED(hResult)) {

        hResult = pShellLink->QueryInterface(IID_IPersistFile,
                                             (void**)&pPersistFile);

        if (SUCCEEDED(hResult)) {

            pShellLink->SetPath(pFileName);
#ifdef UNICODE
            hResult = pPersistFile->Save(pLinkName, STGM_READ);
#else
            pLinkNameW = AnsiStringToUnicodeString( pLinkName );
            hResult = pPersistFile->Save(pLinkNameW, STGM_READ);
            MemFree( pLinkNameW );
#endif
            pPersistFile->Release();
        }

        pShellLink->Release();
    }

    return SUCCEEDED(hResult);
}


BOOL
IsCoverPageShortcut(
    LPCTSTR  pLinkName
    )

/*++

Routine Description:

    Check if a link is a shortcut to some cover page file

Arguments:

    pLinkName - Specifies the name of a link file

Return Value:

    TRUE if the link file is a shortcut to a cover page file
    FALSE otherwise

--*/

{
    LPTSTR  pExtension;
    TCHAR   filename[MAX_PATH];

    //
    // Resolve the link if necessary and check if the final filename has
    // the properly extension.
    //

    return ResolveShortcut((LPTSTR)pLinkName, filename) &&
           (pExtension = FindFilenameExtension(filename)) &&
           _tcsicmp(pExtension, FAX_COVER_PAGE_FILENAME_EXT) == 0;
}

BOOL
IsValidCoverPage(
    LPCTSTR  pFileName
)
/*++

Routine Description:

    Check if pFileName is a valid cover page file

Arguments:

    pFileName   - [in] file name

Return Value:

    TRUE if pFileName is a valid cover page file
    FALSE otherwise

--*/
{
    TCHAR    tszFileName[MAX_PATH];
    HANDLE   hFile;
    DWORD    dwBytesRead;
    BYTE     CpHeaderSignature[20]= {0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};
    COMPOSITEFILEHEADER  fileHeader = {0};


    if(ResolveShortcut((LPTSTR)pFileName, tszFileName))
    {
        pFileName = tszFileName;
    }

    hFile = CreateFile(pFileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        DebugPrint(( TEXT("CreateFile failed: %d\n"), GetLastError()));
        return FALSE;
    }

    if(!ReadFile(hFile, 
                &fileHeader, 
                sizeof(fileHeader), 
                &dwBytesRead, 
                NULL))
    {
        DebugPrint(( TEXT("ReadFile failed: %d\n"), GetLastError()));
        CloseHandle(hFile);
        return FALSE;
    }
        
    //
    // Check the 20-byte signature in the header
    //
    if ((sizeof(fileHeader) != dwBytesRead) ||
        memcmp(CpHeaderSignature, fileHeader.Signature, 20 ))
    {
        CloseHandle(hFile);
        return FALSE;
    }

    CloseHandle(hFile);
    return TRUE;
}


BOOL GetSpecialPath(
   int nFolder,
   LPTSTR lptstrPath
   )
/*++

Routine Description:

    Get a path from a CSIDL constant

Arguments:

    nFolder     - CSIDL_ constant
    lptstrPath  - Buffer to receive the path, assume this buffer is at least MAX_PATH chars large

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HMODULE hMod = NULL;
    PFNSHGETFOLDERPATH pSHGetFolderPath = NULL;
    HRESULT hr;
    BOOL fSuccess = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetSpecialPath"))

    // Load SHFolder.dll 
    hMod = LoadLibrary(_T("SHFolder.dll"));
    if (hMod==NULL)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadLibrary"),GetLastError());
        goto exit;
    }

    // Obtain a pointer to the SHGetFolderPath function
#ifdef UNICODE
    pSHGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hMod,"SHGetFolderPathW");
#else
    pSHGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hMod,"SHGetFolderPathA");
#endif
    if (pSHGetFolderPath==NULL)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetProcAddress"),GetLastError());
        goto exit;
    }

    hr = pSHGetFolderPath(NULL,nFolder,NULL,SHGFP_TYPE_CURRENT,lptstrPath);
    if (FAILED(hr))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SHGetFolderPath"),hr);
        SetLastError(hr);
        goto exit;
    }

    fSuccess = TRUE;

exit:
    if (hMod)
    {
        if (!FreeLibrary(hMod))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("FreeLibrary"),GetLastError());
        }
    }

    return fSuccess;
}


BOOL
GetClientCpDir(
    LPTSTR CpDir,
    DWORD CpDirSize
    )

/*++

Routine Description:

    Gets the client coverpage directory. The cover page path will return with '\'
    at the end: CSIDL_PERSONAL\Fax\Personal CoverPages\

Arguments:

    CpDir       - buffer to hold the coverpage dir
    CpDirSize   - size in TCHARs of CpDir

Return Value:

    Pointer to the client coverpage direcory.

--*/

{
    TCHAR  szPath[MAX_PATH+1] = {0};
	TCHAR  szSuffix[MAX_PATH+1] = {0};
	DWORD  dwSuffixSize = sizeof(szSuffix);
	DWORD  dwType;
    DWORD  dwNeededSize = 0;
	LONG   lRes;


	if(!CpDir)
	{
		Assert(CpDir);
		return FALSE;
	}

	CpDir[0] = 0;

    //
	// get the suffix from the registry
	//
    HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER, 
                                REGKEY_FAX_SETUP, 
                                TRUE, 
                                KEY_ALL_ACCESS);
	if(NULL == hKey)
    {
        return FALSE;
    }
	
	lRes = RegQueryValueEx(hKey, 
		                   REGVAL_CP_LOCATION, 
						   NULL, 
						   &dwType, 
						   (LPBYTE)szSuffix, 
						   &dwSuffixSize);

    RegCloseKey(hKey);

	if(ERROR_SUCCESS != lRes || REG_SZ != dwType)
    {
        return FALSE;
    }
    
	//
	// get personal folder location
	//
	if (!GetSpecialPath(CSIDL_PERSONAL, szPath))
    {
        DebugPrint(( TEXT("GetSpecialPath failed err=%ld"), GetLastError()));
	    return FALSE;
    }

    dwNeededSize = (_tcslen(szPath) + _tcslen(szSuffix) + 1);

    if ( dwNeededSize >= CpDirSize)
    {
        DebugPrint(( TEXT("Buffer too small") ));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    _tcscpy(CpDir,szPath);
    _tcscat(CpDir,szSuffix);

    MakeDirectory(CpDir);
    return TRUE;
}

BOOL
SetClientCpDir(
    LPTSTR CpDir
)
/*++

Routine Description:

    Sets the client coverpage directory.

Arguments:

    CpDir       - pointer to the coverpage dir

Return Value:

    TRUE if success

--*/
{
    HKEY hKey = OpenRegistryKey(HKEY_CURRENT_USER, 
                                REGKEY_FAX_SETUP, 
                                TRUE, 
                                KEY_ALL_ACCESS);
	if(NULL == hKey)
    {
        return FALSE;
    }
	
    if(!SetRegistryString(hKey, 
                          REGVAL_CP_LOCATION, 
                          CpDir))
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}



BOOL
GetServerCpDir(
    LPCTSTR lpctstrServerName,
    LPTSTR  lptstrCpDir,
    DWORD   dwCpDirSize
    )

/*++

Routine Description:

    Gets the server's coverpage directory.

Arguments:

    lpctstrServerName  - [in]  server name or NULL
    lptstrCpDir        - [out] buffer to hold the coverpage dir
    dwCpDirSize        - [in]  size in chars of lptstrCpDir

Return Value:

    TRUE        - If success
    FALSE       - Otherwise (see thread's last error)

--*/

{
    TCHAR szComputerName[(MAX_COMPUTERNAME_LENGTH + 1)] = {0};
    DWORD dwSizeOfComputerName = sizeof(szComputerName)/sizeof(TCHAR);

    DEBUG_FUNCTION_NAME(TEXT("GetServerCpDir"))

    if ((!lptstrCpDir) || (!dwCpDirSize)) 
    {
        ASSERT_FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(IsLocalMachineName(lpctstrServerName))
    {
        //
        // Local machine case
        //
        TCHAR szCommonAppData [MAX_PATH + 1];
        LPCTSTR lpctstrServerCPDirSuffix = NULL;
        HKEY hKey;

        if (!GetSpecialPath(CSIDL_COMMON_APPDATA, szCommonAppData )) 
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSpecialPath (CSIDL_COMMON_APPDATA) failed with %ld"),
                GetLastError());
            return FALSE;
        }
        hKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                REGKEY_FAX_SETUP,
                                FALSE,
                                KEY_QUERY_VALUE);
        if (!hKey)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey (%s) failed with %ld"),
                REGKEY_FAX_SETUP,
                GetLastError());
            return FALSE;
        }
        lpctstrServerCPDirSuffix = GetRegistryString (hKey,
                                                      REGVAL_SERVER_CP_LOCATION,
                                                      TEXT(""));
        if (!lpctstrServerCPDirSuffix)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetRegistryString (%s) failed with %ld"),
                REGVAL_SERVER_CP_LOCATION,
                GetLastError());
            RegCloseKey (hKey);    
            return FALSE;
        }
        RegCloseKey (hKey);
        if (!lstrlen (lpctstrServerCPDirSuffix))
        {
            SetLastError (ERROR_REGISTRY_CORRUPT);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Value at %s is empty"),
                REGVAL_SERVER_CP_LOCATION);
            MemFree ((LPVOID)lpctstrServerCPDirSuffix);
            return FALSE;
        }
        if (0 > _sntprintf(lptstrCpDir, 
                           dwCpDirSize - 1,
                           TEXT("%s\\%s"),
                           szCommonAppData,
                           lpctstrServerCPDirSuffix))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Return buffer size (%ld bytes) is smaller than required size (%ld bytes)"),
                dwCpDirSize,
                _tcslen(szCommonAppData) + 1 + _tcslen(lpctstrServerCPDirSuffix) + 1);
            SetLastError (ERROR_BUFFER_OVERFLOW);
            MemFree ((LPVOID)lpctstrServerCPDirSuffix);
            return FALSE;
        }
        MemFree ((LPVOID)lpctstrServerCPDirSuffix);
        return TRUE;
    }

    else
    {
        //
        // Remote server case
        //
        if (0 > _sntprintf(lptstrCpDir, 
                           dwCpDirSize - 1,
                           TEXT("\\\\%s\\") FAX_COVER_PAGES_SHARE_NAME,
                           lpctstrServerName))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Return buffer size (%ld bytes) is smaller than required size (%ld bytes)"),
                dwCpDirSize,
                2 + _tcslen(lpctstrServerName) + 1 + _tcslen(FAX_COVER_PAGES_SHARE_NAME) + 1);
            SetLastError (ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }
        return TRUE;
    }
}   // GetServerCpDir

DWORD 
WinHelpContextPopup(
    ULONG_PTR dwHelpId, 
    HWND  hWnd
)
/*++

Routine name : WinHelpContextPopup

Routine description:

	open context sensetive help popup with WinHelp

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	dwHelpId                      [in]     - help ID
	hWnd                          [in]     - parent window handler

Return Value:

    None.

--*/
{
    DWORD dwExpRes;
    DWORD dwRes = ERROR_SUCCESS;
    TCHAR tszHelpFile[MAX_PATH+1];

    if (0 == dwHelpId)
    {
        return dwRes;
    }

    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CLIENT_HLP))
    {
        //
        // The help file is not installed
        //
        return dwRes;
    }
    
    //
    // get help file name
    //
    dwExpRes = ExpandEnvironmentStrings(FAX_CONTEXT_HELP_FILE, tszHelpFile, MAX_PATH);
    if(0 == dwExpRes)
    {
        dwRes = GetLastError();
        DebugPrint(( TEXT("ExpandEnvironmentStrings failed: %d\n"), dwRes ));
        return dwRes;
    }

    WinHelp(hWnd, 
            tszHelpFile, 
            HELP_CONTEXTPOPUP, 
            dwHelpId
           );

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\util\string.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file implements string functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <ObjBase.h>
#include "faxutil.h"
#include "fxsapip.h"
#define  SECURITY_WIN32         // needed by security.h
#include <Security.h>
#include "faxreg.h"
#include "FaxUIConstants.h"

LPTSTR
AllocateAndLoadString(
                      HINSTANCE     hInstance,
                      UINT          uID
                      )
/*++

Routine Description:

    Calls LoadString for given HINSTANCE and ID of the string.
    Allocates memory in loop to find enough memory.
    Returns the given string.
    The caller must free the string.

Arguments:

    hInstance               -   module instance
    uID                     -   ID of the string to bring

Return Value:

    the allocated string, NULL if error.
    Call GetLastError() for the details.

Author:

    Iv Garber, 22-Oct-2000

--*/
{
    LPTSTR  lptstrResult = NULL;
    DWORD   dwNumCopiedChars = 0;
    DWORD   dwSize = 100;

    do
    {
        //
        //  There is not enough place for all the string
        //
        dwSize = dwSize * 3;
        MemFree(lptstrResult);

        //
        //  Allocate memory for the string
        //
        lptstrResult = LPTSTR(MemAlloc(dwSize * sizeof(TCHAR)));
        if (!lptstrResult)
        {
            return NULL;
        }

        //
        //  Bring the string from the resource file
        //
        dwNumCopiedChars = LoadString(hInstance, uID, lptstrResult, dwSize);
        if (!dwNumCopiedChars)
        {
            //
            //  the string does not exist in the resource file
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            MemFree(lptstrResult);
            return NULL;
        }

    } while(dwNumCopiedChars == (dwSize - 1));

    return lptstrResult;
}


LPTSTR
StringDup(
    LPCTSTR String
    )
{
    LPTSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPTSTR) MemAlloc( (_tcslen( String ) + 1) * sizeof(TCHAR) );
    if (!NewString) {
        return NULL;
    }

    _tcscpy( NewString, String );

    return NewString;
}


LPWSTR
StringDupW(
    LPCWSTR String
    )
{
    LPWSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPWSTR) MemAlloc( (wcslen( String ) + 1) * sizeof(WCHAR) );
    if (!NewString) {
        return NULL;
    }

    wcscpy( NewString, String );

    return NewString;
}

int MultiStringDup(PSTRING_PAIR lpPairs, int nPairCount)
{
    int i,j;

    Assert(lpPairs);

    for (i=0;i<nPairCount;i++) {
        if (lpPairs[i].lptstrSrc) {
                 *(lpPairs[i].lpptstrDst)=StringDup(lpPairs[i].lptstrSrc);
                 if (!*(lpPairs[i].lpptstrDst)) {
                     // Cleanup the strings we did copy so far.
                     for (j=0;j<i;j++) {
                         MemFree(*(lpPairs[j].lpptstrDst));
                         *(lpPairs[j].lpptstrDst) = NULL;
                     }
                     // return the index in which we failed + 1 (0 is success so we can not use it).
                     return i+1;
                 }
        }
    }
    return 0;
}


VOID
FreeString(
    LPVOID String
    )
{
    MemFree( String );
}


LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    if (!AnsiString)
        return NULL;
    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) MemAlloc( Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}


LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;

    if (!UnicodeString)
        return NULL;

    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) MemAlloc( Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}


BOOL
MakeDirectory(
    LPCTSTR Dir
    )

/*++

Routine Description:

    Attempt to create all of the directories in the given path.

Arguments:

    Dir                     - Directory path to create

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p, NewDir;
    DWORD ec = ERROR_SUCCESS;
    DWORD dwFileAtt;
    DEBUG_FUNCTION_NAME(TEXT("MakeDirectory"));

    NewDir = p = ExpandEnvironmentString( Dir );
    if (!NewDir)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ExpandEnvironmentString (private function) failed. (ec: %ld)"),
            ec);
        goto Exit;
    }

    dwFileAtt = GetFileAttributes( NewDir );
    if (-1 != dwFileAtt && (dwFileAtt & FILE_ATTRIBUTE_DIRECTORY))
    {
        //
        // The directory exists
        //
        ec = ERROR_SUCCESS;
        goto Exit;
    }

    __try
    {
        if ( (_tcsclen(p) > 2) && (_tcsncmp(p,TEXT("\\\\"),2) == 0) )
        {
            //
            // Path name start with UNC (\\)
            // Skip first double backslash (\\)
            //
            p = _tcsninc(p,2);
            //
            // Scan until the end of the server name
            //
            if( p = _tcschr(p,TEXT('\\')) )
            {
                //
                // Skip the server name
                //
                p = _tcsinc(p);

                //
                // Scan until the end of the share name
                //
                if( p = _tcschr(p,TEXT('\\')) )
                {
                    //
                    // Skip the share name
                    //
                    p = _tcsinc(p);
                }
            }
        }
        else if ( (_tcsclen(p) > 1) && (_tcsncmp(p,TEXT("\\"),1) == 0) )
        {
            //
            // Path name starts with root directory (e.g. : "\blah\blah2") - skip it
            //
            p = _tcsinc(p);
        }
        else if ( (_tcsclen(p) > 3) &&
                  _istalpha(p[0]) &&
                  (_tcsncmp(_tcsinc(p),TEXT(":\\"),2) == 0) )
        {
            //
            // Path name starts with drive and root directory (e.g. : "c:\blah\blah2") - skip it
            //
            p = _tcsninc(p,3);
        }

        if (NULL == p)
        {
            //
            // Reached EOSTR
            //
            if (!CreateDirectory( NewDir, NULL ))
            {
                //
                // Check if we failed because the dir already existed.
                // If so this is not an error.
                //
                ec = GetLastError();
                if (ERROR_ALREADY_EXISTS != ec)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateDirectory [%s] failed (ec: %ld)"),
                        NewDir,
                        ec);
                }
                else
                {
                    ec = ERROR_SUCCESS;
                }
                goto Exit;
            }
        }

        while( *(p = _tcsinc(p)) )
        {
            p = _tcschr(p,TEXT('\\'));
            if( !p )
            {
                //
                // Reached EOSTR
                //
                if (!CreateDirectory( NewDir, NULL ))
                {
                    //
                    // Check if we failed because the dir already existed.
                    // If so this is not an error.
                    //
                    if (ERROR_ALREADY_EXISTS != GetLastError())
                    {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateDirectory [%s] failed (ec: %ld)"),
                            NewDir,
                            ec);
                    }
                }
                break; // success case
            }
            //
            // Place NULL instead of backslash
            //
            p[0] = TEXT('\0');
            if (!CreateDirectory( NewDir, NULL ))
            {
                //
                // Check if we failed because the dir already existed.
                // If so this is not an error.
                //
                if (ERROR_ALREADY_EXISTS != GetLastError())
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateDirectory [%s] failed (ec: %ld)"),
                        NewDir,
                        ec);

                    break;
                }
            }
            //
            // Restore backslash
            //
            p[0] = TEXT('\\');
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        ec = GetExceptionCode ();
    }

Exit:
    MemFree( NewDir );
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}

VOID
HideDirectory(
   LPTSTR Dir
   )
/*++

Routine Description:

    Hide the specified directory

Arguments:

    Dir                     - Directory path to hide

Return Value:

    none.

--*/
{
   DWORD attrib;

   //
   // make sure it exists
   //
   if (!Dir) {
      return;
   }

   MakeDirectory( Dir );

   attrib  = GetFileAttributes(Dir);

   if (attrib == 0xFFFFFFFF) {
      return;
   }

   attrib |= FILE_ATTRIBUTE_HIDDEN;

   SetFileAttributes( Dir, attrib );

   return;


}


VOID
DeleteDirectory(
    LPTSTR Dir
    )

/*++

Routine Description:

    Attempt to delete all of the directories in the given path.

Arguments:

    Dir                     - Directory path to delete

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR p;

    __try
    {
        while (true)
        {
            if (!RemoveDirectory( Dir ))
            {
                return;
            }
            // get a pointer to the end of Dir
            p = _tcschr(Dir,TEXT('\0'));
            p = _tcsdec(Dir,p);

            //
            //  If p is equal to ( or less then ) Dir, _tscdec returns NULL
            //
            if (!p)
            {
                return;
            }

            while ( _tcsncmp(p,TEXT("\\"),1) && p != Dir )
            {
                p = _tcsdec(Dir,p);
            }

            if (p == Dir)
            {
                return;
            }

            _tcsnset(p,TEXT('\0'),1);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
    }
}


int
FormatElapsedTimeStr(
    FILETIME *ElapsedTime,
    LPTSTR TimeStr,
    DWORD StringSize
    )
/*++

Routine Description:

    Convert ElapsedTime to a string.

Arguments:

    ElaspedTime                     - the elapsed time
    TimeStr                         - buffer to store the string into
    StringSize                      - size of the buffer in bytes

Return Value:

    The return value of GetTimeFormat()

--*/

{
    SYSTEMTIME  SystemTime;
    FileTimeToSystemTime( ElapsedTime, &SystemTime );
    return FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        LOCALE_NOUSEROVERRIDE | TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER,
        &SystemTime,
        NULL,
        TimeStr,
        StringSize/sizeof(TCHAR)
        );
}


LPTSTR
ExpandEnvironmentString(
    LPCTSTR EnvString
    )
{
    DWORD dwRes;
    DWORD Size;
    LPTSTR String;

    DEBUG_FUNCTION_NAME(TEXT("ExpandEnvironmentString"));

    if(!_tcschr(EnvString, '%'))
    {
        //
        // On Win95 ExpandEnvironmentStrings fails if sting
        // doesn't contain environment variable.
        //
        String = StringDup(EnvString);
        if(!String)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
            return NULL;
        }
        else
        {
            return String;
        }
    }

    Size = ExpandEnvironmentStrings( EnvString, NULL, 0 );
    if (Size == 0)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("ExpandEnvironmentStrings failed: 0x%08X)"), dwRes);
        return NULL;
    }

    ++Size;

    String = (LPTSTR) MemAlloc( Size * sizeof(TCHAR) );
    if (String == NULL)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc failed"));
        return NULL;
    }

    if (ExpandEnvironmentStrings( EnvString, String, Size ) == 0)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("ExpandEnvironmentStrings failed: 0x%08X)"), dwRes);

        MemFree( String );
        return NULL;
    }

    return String;
}


LPTSTR
GetEnvVariable(
    LPCTSTR EnvString
    )
{
    DWORD Size;
    LPTSTR EnvVar;


    Size = GetEnvironmentVariable( EnvString, NULL, 0 );
    if (!Size) {
        return NULL;
    }

    EnvVar = (LPTSTR) MemAlloc( Size * sizeof(TCHAR) );
    if (EnvVar == NULL) {
        return NULL;
    }

    Size = GetEnvironmentVariable( EnvString, EnvVar, Size );
    if (!Size) {
        MemFree( EnvVar );
        return NULL;
    }

    return EnvVar;
}

LPTSTR
ConcatenatePaths(
    LPTSTR BasePath,
    LPCTSTR AppendPath
    )
{
    TCHAR* pLast = NULL;
    pLast = _tcsrchr(BasePath,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(BasePath, TEXT("\\"));
    }

    _tcscat(BasePath, AppendPath);

    return BasePath;

}



//*********************************************************************************
//* Name:   SafeTcsLen()
//* Author: Ronen Barenboim
//* Date:   June 20, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Calculates the length of a string using tcslen() while protecting against
//*     exceptions.
//* PARAMETERS:
//*     [IN ]   LPCTSTR lpctstrString
//*         The string to caluclate the length for.
//*     [OUT ]   LPDWORD lpdwLen
//*         The calculated lenght of the string. This parameter
//*         is valid only if the function did not report an error.
//* RETURN VALUE:
//*     TRUE
//*         If no error or exception occured.
//*     FALSE
//*         If an error or exception occured while calculating the length.
//*         In this case GetLastError() will return ERROR_INVALID_DATA.
//*********************************************************************************
BOOL SafeTcsLen(LPCTSTR lpctstrString, LPDWORD lpdwLen)
{

    DEBUG_FUNCTION_NAME(TEXT("SafeLen"));

    Assert(lpctstrString);
    Assert(lpdwLen);

    __try
    {
        (*lpdwLen) =  _tcslen(lpctstrString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("_tcslen * CRASHED * (Exception: 0x%08X)"),
            GetExceptionCode());
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    return TRUE;
}


int 
GetY2KCompliantDate (
    LCID                Locale,
    DWORD               dwFlags,
    CONST SYSTEMTIME   *lpDate,
    LPTSTR              lpDateStr,
    int                 cchDate
)
{
    int     iRes;

    DEBUG_FUNCTION_NAME(TEXT("GetY2KCompliantDate()"));

    iRes = GetDateFormat(Locale,
        dwFlags,
        lpDate,
        NULL,
        lpDateStr,
        cchDate);

    if (!iRes)
    {
        //
        //  If failed, no need to care about the formatted date string
        //
        return iRes;
    }

    if (0 == cchDate)
    {
        //
        // User only wants to know the output string size.
        //
        // We return a bigger size than GetDateFormat() returns,
        // because the DATE_LTRREADING flag we sometimes add later,
        // might enlarge the result string.
        // Although we don't always use the DATE_LTRREADING flag (only used in Win2K and only
        // if the string has right-to-left characters), we always return a bigger required
        // buffer size - just to make the code simpler.
        //
        return iRes * 2;
    }

#if (WINVER >= 0x0500)
#ifdef UNICODE


    //
    //  If the formatted date string contains right-to-left characters
    //      for example, in Hebrew, Arabic etc. languages
    //      then the system fails to write it correctly.
    //
    //  So, we want to enforce right-to-left direction in this case
    //
    //  This is possible only for WINVER>=0x0500
    //  For any other OS nothing can be done.
    //
    if ( (dwFlags & DATE_RTLREADING) || (dwFlags & DATE_LTRREADING) )
    {
        //
        //  the caller defined a direction, nothing needs to be added
        //
        return iRes;
    }

    OSVERSIONINFO   osVerInfo;
    osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
    if (!GetVersionEx(&osVerInfo))
    {
        DebugPrintEx(DEBUG_ERR, _T("GetVersionEx() failed : %ld"), GetLastError());
        return 0;
    }

    if ( (osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osVerInfo.dwMajorVersion >= 5) )
    {
        //
        //  Get direction information about the characters in the formatted date string
        //
        if (StrHasRTLChar(Locale, lpDateStr))
        {
            //
            //  There is at least one Right-To-Left character
            //  So, we need to add Right-To-Left marks to the whole string
            //
            iRes = GetDateFormat(Locale,
                                 dwFlags | DATE_RTLREADING,
                                 lpDate,
                                 NULL,
                                 lpDateStr,
                                 cchDate);
        }
    }

#endif // UNICODE
#endif // (WINVER >= 0x0500)

    return iRes;

}   // GetY2KCompliantDate

DWORD
IsValidGUID (
    LPCWSTR lpcwstrGUID
)
/*++

Routine name : IsValidGUID

Routine description:

    Checks validity of a GUID string

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    lpcwstrGUID    [in ] - GUID string to check for validity

Return Value:

    ERROR_SUCCESS if valid GUID string.
    Win32 error otherwise.

--*/
{
    GUID guid;
    HRESULT hr;
    DEBUG_FUNCTION_NAME(TEXT("IsValidGUID"));

    hr = CLSIDFromString((LPOLESTR)lpcwstrGUID, &guid);
    if (FAILED(hr) && hr != REGDB_E_WRITEREGDB )
    {
        if (CO_E_CLASSSTRING == hr)
        {
            //
            // Invalid GUID
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GUID [%s] is invalid"),
                lpcwstrGUID);
            return ERROR_WMI_GUID_NOT_FOUND;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CLSIDFromString for GUID [%s] has failed (hr: 0x%08X)"),
                lpcwstrGUID,
                hr);
            return ERROR_GEN_FAILURE;
        }
    }
    return ERROR_SUCCESS;
}   // IsValidGUID



//*****************************************************************************
//* Name:   StoreString
//* Author:
//*****************************************************************************
//* DESCRIPTION:
//* Copies a string to an offset within a buffer and updates the offset
//* to refelect the length of the copied string. Used for filling out
//* pointerless buffers (i.e. using offset to start of buffer instead of
//* pointers to memory locations).
//* PARAMETERS:
//*     [IN]    String:
//*         The string to be copied.
//*     [OUT]   DestString:
//*         Points to a variable that should be assigned the offset
//*         at which the string was copied.
//*     [IN]    Buffer
//*         A pointer to the buffer into which the string should be copied.
//*     [IN]    Offset
//*         A pointer to a variable that holds the offset from the start
//*         of the buffer where the string is to be copied (0 based).
//*         On successful return the value of this variable is increased
//*         by the length of the string (not including null).
//*         The new offset can be used to copy the next string just after
//*         the terminatng null of the last copied string.
//* RETURN VALUE:
//*         None.
//* Comments:
//*         None.
//*****************************************************************************
VOID
StoreString(
    LPCTSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    )
{

    if (String) {
        if (Buffer) {
            _tcscpy( (LPTSTR) (Buffer+*Offset), String );
            *DestString = *Offset;
        }
        *Offset += StringSize( String );
    } else {
        if (Buffer){
            *DestString = 0;
        }
    }

}

VOID
StoreStringW(
    LPCWSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    )
{

    if (String) {
        if (Buffer) {
            wcscpy( (LPWSTR) (Buffer+*Offset), String );
            *DestString = *Offset;
        }
        *Offset += StringSizeW( String );
    } else {
        if (Buffer){
            *DestString = 0;
        }
    }

}


DWORD
IsCanonicalAddress(
    LPCTSTR lpctstrAddress,
    BOOL* lpbRslt,
    LPDWORD lpdwCountryCode,
    LPDWORD lpdwAreaCode,
    LPCTSTR* lppctstrSubNumber
    )
/*++

Routine name : IsCanonicalAddress

Routine description:

    Checks if an address is canonical. 
    Returns the country code, area code, and the rest of the number. 
    If it is succsfull the caller must free the rest the subscriber number (if requested).

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpctstrAddress          [in ] - Pointer to a null terminated string containing the address.
    lpbRslt                 [out] - Pointer to a BOOL to recieve whether the address is canonical.
                                    Valid only if the function did not fail.
    lpdwCountryCode         [out] - Pointer to a DWORD to recieve the country code (Can be NULL). 
                                    Return value is valid only if lpbRslt is TRUE.
    lpdwAreaCode            [out] - Pointer to a DWORD to recieve the area code (Can be NULL). 
                                    Return value is valid only if lpbRslt is TRUE.
    lppctstrSubNumber       [out] - Pointer to a LPCTSTR to recieve the subsriber number (Can be NULL).
                                    If it is not NULL, and the return value is TRUE, Call MemFree to deallocate memory.

Return Value:

    Standard win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    LPTSTR lptstrSubNumber = NULL;
    DWORD dwStringSize, dwScanedArg, dwCountryCode, dwAreaCode;
    BOOL bFreeSubNumber = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("IsCanonicalAddress"));

    dwStringSize = (_tcslen(lpctstrAddress + 1)) * sizeof(TCHAR);
    lptstrSubNumber = (LPTSTR)MemAlloc (dwStringSize);
    if (NULL == lptstrSubNumber)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("failed to allocate memory"));
        return ERROR_OUTOFMEMORY;
    }

    if (NULL == _tcschr(lpctstrAddress, TEXT('(')))
    {
        dwScanedArg = _stscanf (lpctstrAddress,
                                TEXT("+%lu%*1[' ']%[^'\0']"),
                                &dwCountryCode,
                                lptstrSubNumber);
        if (2 != dwScanedArg)
        {
            *lpbRslt = FALSE;
            goto exit;
        }
        dwAreaCode = ROUTING_RULE_AREA_CODE_ANY;
    }
    else
    {
        dwScanedArg = _stscanf (lpctstrAddress,
                                TEXT("+%lu%*1[' '](%lu)%[^'\0']"),
                                &dwCountryCode,
                                &dwAreaCode,
                                lptstrSubNumber);
        if (3 != dwScanedArg)
        {
            *lpbRslt = FALSE;
            goto exit;
        }
    }

    if (NULL != _tcschr(lptstrSubNumber, TEXT('(')))
    {
        *lpbRslt = FALSE;
        goto exit;
    }

    if (NULL != lpdwCountryCode)
    {
        *lpdwCountryCode = dwCountryCode;
    }

    if (NULL != lpdwAreaCode)
    {
        *lpdwAreaCode = dwAreaCode;
    }

    if (NULL != lppctstrSubNumber)
    {
        *lppctstrSubNumber = lptstrSubNumber;
        bFreeSubNumber = FALSE;
    }

    *lpbRslt = TRUE;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (TRUE == bFreeSubNumber)
    {
        MemFree (lptstrSubNumber);
    }
    return dwRes;
}   // IsCanonicalAddress

BOOL
IsValidFaxAddress (
    LPCTSTR lpctstrFaxAddress,
    BOOL    bAllowCanonicalFormat
)
/*++

Routine name : IsValidFaxAddress

Routine description:

	Checks if a given string is a valid fax address

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:

	lpctstrFaxAddress       [in]     - String to check
	bAllowCanonicalFormat   [in]     - Allow string to be of canonical format.
                                       If string is in a canonical format, only the sub-address is checked.

Return Value:

    TRUE if string is a valid fax address, FALSE otherwise.

--*/
{
    BOOL bCanonical;
    BOOL bRes = FALSE;
    LPCTSTR lpctstrSubAddress = lpctstrFaxAddress;

    DEBUG_FUNCTION_NAME(TEXT("IsValidFaxAddress"));
    if (bAllowCanonicalFormat)
    {
        //
        // Check an see if the address is canonical
        //
        if (ERROR_SUCCESS != IsCanonicalAddress (lpctstrFaxAddress, &bCanonical, NULL, NULL, &lpctstrSubAddress))
        {
            //
            // Can't detect canonical state - return invalid address
            //
            return FALSE;
        }
        if (!bCanonical)
        {
            //
            // Analyse entire string
            //
            lpctstrSubAddress = lpctstrFaxAddress;
        }
    }
    //
    // Scan for occurance of characters NOT in valid set
    //
    if (NULL == _tcsspnp (lpctstrSubAddress, FAX_ADDERSS_VALID_CHARACTERS))
    {
        //
        // Address string contains only valid characters
        //
        bRes = TRUE;
        goto exit;
    }
    //
    // Found an illegal character - return FALSE
    //
exit:
    if (lpctstrSubAddress && lpctstrSubAddress != lpctstrFaxAddress)
    {
        MemFree ((LPVOID)lpctstrSubAddress);
    }
    return bRes;
}   // IsValidFaxAddress


BOOL
IsLocalMachineNameA (
    LPCSTR lpcstrMachineName
    )
/*++

Routine name : IsLocalMachineNameA

Routine description:

    Checks if a given string points to the local machine.
    ANSII version.

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpcstrMachineName             [in]     - String input

Return Value:

    TRUE if given string points to the local machine, FALSE otherwise.

--*/
{
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwBufLen = MAX_COMPUTERNAME_LENGTH + 1;
    DEBUG_FUNCTION_NAME(TEXT("IsLocalMachineNameA"));

    if (!lpcstrMachineName)
    {
        //
        // NULL is local
        //
        return TRUE;
    }
    if (!strlen(lpcstrMachineName))
    {
        //
        // Empty string is local
        //
        return TRUE;
    }
    if (!strcmp (".", lpcstrMachineName))
    {
        //
        // "." is local
        //
        return TRUE;
    }
    if (!GetComputerNameA (szComputerName, &dwBufLen))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetComputerNameA failed with %ld"),
            GetLastError());
        return FALSE;
    }
    if (!_stricmp (szComputerName, lpcstrMachineName))
    {
        //
        // Same string as computer name
        //
        return TRUE;
    }
    return FALSE;
}   // IsLocalMachineNameA

BOOL
IsLocalMachineNameW (
    LPCWSTR lpcwstrMachineName
    )
/*++

Routine name : IsLocalMachineNameW

Routine description:

    Checks if a given string points to the local machine.
    UNICODE version.

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpcwstrMachineName             [in]     - String input

Return Value:

    TRUE if given string points to the local machine, FALSE otherwise.

--*/
{
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwBufLen = MAX_COMPUTERNAME_LENGTH + 1;
    DEBUG_FUNCTION_NAME(TEXT("IsLocalMachineNameW"));

    if (!lpcwstrMachineName)
    {
        //
        // NULL is local
        //
        return TRUE;
    }
    if (!wcslen(lpcwstrMachineName))
    {
        //
        // Empty string is local
        //
        return TRUE;
    }
    if (!wcscmp (L".", lpcwstrMachineName))
    {
        //
        // "." is local
        //
        return TRUE;
    }
    if (!GetComputerNameW (wszComputerName, &dwBufLen))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetComputerNameA failed with %ld"),
            GetLastError());
        return FALSE;
    }
    if (!_wcsicmp (wszComputerName, lpcwstrMachineName))
    {
        //
        // Same string as computer name
        //
        return TRUE;
    }
    return FALSE;
}   // IsLocalMachineNameW


//+--------------------------------------------------------------------------
//
//  Function:   GetSecondsFreeTimeFormat (former UpdateTimeFormat)
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    After 11-18-1996   DavidMun   UpdateTimeFormat
//
//
//---------------------------------------------------------------------------
void
GetSecondsFreeTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    DEBUG_FUNCTION_NAME( _T("GetSecondsFreeTimeFormat"));

    DWORD ec = ERROR_SUCCESS;

    ULONG cch = 0;
    TCHAR tszScratch[100];
    BOOL  fAmPm;
    BOOL  fAmPmPrefixes;
    BOOL  fLeadingZero;

    TCHAR tszDefaultTimeFormat[] = { TEXT("hh:mm tt") };

    //
    // 1) GetLocal info
    //

    //
    // AM/PM (0) or 24H (1)
    //
    if (0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_ITIME,
                            tszScratch,
                            sizeof(tszScratch)/sizeof(tszScratch[0])))
    {
        ec = GetLastError();

        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetLocaleInfo for LOCALE_ITIME. (ec: %ld)"),
            ec);


        if (ERROR_INSUFFICIENT_BUFFER == ec)
        {
            Assert(FALSE);
        }

        goto Error;
    }

    fAmPm = (*tszScratch == TEXT('0'));

    if (fAmPm)
    {
        //
        // AM/PM as suffix (0) as prefix (1)
        //
        if (0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                                LOCALE_ITIMEMARKPOSN,
                                tszScratch,
                                sizeof(tszScratch)/sizeof(tszScratch[0])))
        {
            ec = GetLastError();

            DebugPrintEx(
                DEBUG_ERR,
                _T("Failed to GetLocaleInfo for LOCALE_ITIMEMARKPOSN. (ec: %ld)"),
                ec);


            if (ERROR_INSUFFICIENT_BUFFER == ec)
            {
                Assert(FALSE);
            }

            goto Error;
        }
        fAmPmPrefixes = (*tszScratch == TEXT('1'));
    }

    //
    // Leading zeros for hours: no (0) yes (1)
    //
    if (0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_ITLZERO,
                            tszScratch,
                            sizeof(tszScratch)/sizeof(tszScratch[0])))
    {
        ec = GetLastError();

        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetLocaleInfo for LOCALE_ITLZERO. (ec: %ld)"),
            ec);


        if (ERROR_INSUFFICIENT_BUFFER == ec)
        {
            Assert(FALSE);
        }

        goto Error;
    }
    fLeadingZero = (*tszScratch == TEXT('1'));

    //
    // Get Charcter(s) for time seperator
    //
    if (0 == GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_STIME,
                            tszScratch,
                            sizeof(tszScratch)/sizeof(tszScratch[0])))
    {
        ec = GetLastError();

        DebugPrintEx(
            DEBUG_ERR,
            _T("Failed to GetLocaleInfo for LOCALE_STIME. (ec: %ld)"),
            ec);


        if (ERROR_INSUFFICIENT_BUFFER == ec)
        {
            Assert(FALSE);
        }

        goto Error;
    }

    //
    // See if there's enough room in destination string
    //

    cch = 1                     +  // terminating nul
          1                     +  // first hour digit specifier "h"
          2                     +  // minutes specifier "mm"
          (fLeadingZero != 0)   +  // leading hour digit specifier "h"
          lstrlen(tszScratch)   +  // separator string
          (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

    if (cch > cchTimeFormat)
    {
        cch = 0; // signal error

        DebugPrintEx(
            DEBUG_ERR,
            _T("Time format too long."));

        goto Error;
    }

    Assert(cch);

    //
    // 2) Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            lstrcpy(tszTimeFormat, TEXT("tt "));
        }

        lstrcat(tszTimeFormat, TEXT("h"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("h"));
        }
    }
    else
    {
        lstrcat(tszTimeFormat, TEXT("H"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("H"));
        }
    }

    lstrcat(tszTimeFormat, tszScratch); // separator
    lstrcat(tszTimeFormat, TEXT("mm"));

    if (fAmPm && !fAmPmPrefixes)
    {
        lstrcat(tszTimeFormat, TEXT(" tt"));
    }
    return;

Error:
    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    Assert (!cch);

    lstrcpy(tszTimeFormat, tszDefaultTimeFormat);

    DebugPrintEx(
        DEBUG_ERR,
        _T("Failed to GET_LOCALE_INFO set tszDefaultTimeFormat."));

    return;
}

/*++

Routine name : MultiStringSize


Description:

    Helper function to find Multi-String size (UNICODE or ANSI)
    
    MultiString (as in registry REG_MULTY_SZ type) is stored as a series of zero-terminated string,
    with two zero charcters terminating the final string in the series.

    Multi-String have to be at least 2 characters long!!!

Author:

    Caliv Nir, FEB , 2001

Arguments:

    psz     -   [IN]    - input multi-string (must be leggal multi-string otherwise result are undefined)

Return Value:

    string length including the terminating zero !!!

--*/

size_t MultiStringLength(LPCTSTR psz)
{
  LPCTSTR pszT = psz;

  Assert ( psz );

  if ( !psz[0] ) psz+=1;    // empty string as a first string skip it


  while (*psz)
      psz += lstrlen(psz) + 1;

  return psz - pszT + 1;      // one additional zero-terminator
}


/*++

Routine name : CopyMultiString


Description:

    Helper function to copy Multi-Strings (UNICODE or ANSI)
    
    MultiString (as in registry REG_MULTY_SZ type) is stored as a series of zero-terminated string,
    with two zero charcters terminating the final string in the series.

    this function copy the source multi-string into the destenation multi-string.

    strDestination buffer size must be >= then strSource buffer size !!!!!!!!!!!!!
    You can find out multi-string size by using MultiStringLength( )

Author:

    Caliv Nir, FEB , 2001

Arguments:

    strDestination      -   [IN/OUT]    - Destination multi-string buffer
    strSource           -   [IN]        - Source multi-string

Return Value:

    strDestination

--*/

LPTSTR CopyMultiString (LPTSTR strDestination, LPCTSTR strSource )
{
    LPTSTR pszT= strDestination;
    size_t strSize;

    while(*strSource)
    {
        lstrcpy(pszT,strSource);
        
        strSize = lstrlen(strSource) + 1;
        strSource += strSize;
        pszT += strSize;
    }

    *pszT = _T('\0');   // append terminating zero

    return strDestination;
}

LPCTSTR 
GetRegisteredOrganization ()
/*++

Routine name : GetRegisteredOrganization

Routine description:

	Retrieves the system's registered company name (organization)

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    Allocated result string

--*/
{
    DEBUG_FUNCTION_NAME( _T("GetRegisteredOrganization"));

    LPTSTR lptstrRes = NULL;
    HKEY hKey = NULL;
    hKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                            REGKEY_INSTALLLOCATION,
                            FALSE,
                            KEY_QUERY_VALUE);
    if (!hKey)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed with %ld"),
            GetLastError());
        return StringDup(TEXT(""));
    }
    lptstrRes = GetRegistryString (hKey,
                                   TEXT("RegisteredOrganization"),
                                   TEXT(""));
    RegCloseKey (hKey);
    return lptstrRes;
}   // GetRegisteredOrganization

LPCTSTR 
GetCurrentUserName ()
/*++

Routine name : GetCurrentUserName

Routine description:

	Retrieves display name of the current user

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    Allocated result string

--*/
{
    DEBUG_FUNCTION_NAME( _T("GetCurrentUserName"));
    TCHAR tszName[MAX_PATH] = TEXT("");
    DWORD dwSize = ARR_SIZE(tszName);

    typedef BOOLEAN (SEC_ENTRY * PFNGETUSERNAMEXA)(EXTENDED_NAME_FORMAT, LPSTR, PULONG);
    typedef BOOLEAN (SEC_ENTRY * PFNGETUSERNAMEXW)(EXTENDED_NAME_FORMAT, LPWSTR, PULONG);

    HMODULE hMod = LoadLibrary (TEXT("Secur32.dll"));
    if (hMod)
    {
#ifdef UNICODE
        PFNGETUSERNAMEXW pfnGetUserNameEx = (PFNGETUSERNAMEXW)GetProcAddress (hMod, "GetUserNameExW");
#else
        PFNGETUSERNAMEXA pfnGetUserNameEx = (PFNGETUSERNAMEXA)GetProcAddress (hMod, "GetUserNameExA");
#endif
        if (pfnGetUserNameEx)
        {
            if (!pfnGetUserNameEx(NameDisplay, tszName, &dwSize)) 
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetUserNameEx failed with %ld"),
                    GetLastError());
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetProcAddress failed with %ld"),
                GetLastError());
        }
        FreeLibrary (hMod);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadLibrary(secur32.dll) failed with %ld"),
            GetLastError());
    }
    return StringDup(tszName);
}   // GetCurrentUserName

BOOL
IsValidSubscriberIdW (
    LPCWSTR lpcwstrSubscriberId
)
{
    DEBUG_FUNCTION_NAME(TEXT("IsValidSubscriberIdW"));

    CHAR szAnsiiSID[FXS_TSID_CSID_MAX_LENGTH + 1];
    CHAR cDefaultChar = 19;

    Assert (lpcwstrSubscriberId);

    if(wcslen (lpcwstrSubscriberId) > FXS_TSID_CSID_MAX_LENGTH)
    {
        return FALSE;   
    }

    if (!WideCharToMultiByte (CP_ACP,
                              0,
                              lpcwstrSubscriberId,
                              -1,
                              szAnsiiSID,
                              sizeof (szAnsiiSID),
                              &cDefaultChar,
                              NULL))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("WideCharToMultiByte failed with %ld"),
            GetLastError());
        return FALSE;
    }
    return IsValidSubscriberIdA(szAnsiiSID);
}   // IsValidSubscriberIdW

BOOL
IsValidSubscriberIdA (
    LPCSTR lpcstrSubscriberId
)
{
    DWORD dwLen;
    DWORD dw;
    DEBUG_FUNCTION_NAME(TEXT("IsValidSubscriberIdA"));


    Assert (lpcstrSubscriberId);
        
    dwLen = strlen (lpcstrSubscriberId);

    if(dwLen > FXS_TSID_CSID_MAX_LENGTH)
    {
        return FALSE;   
    }

    for (dw = 0; dw < dwLen; dw++)
    {
        if (!isprint (lpcstrSubscriberId[dw]))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("%s contains invalid characters"),
                lpcstrSubscriberId);
            return FALSE;
        }   
    }             
    return TRUE;
}   // IsValidSubscriberIdA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\coredefs.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       coredefs.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: core definitions
 *
 *****************************************************************************/

#ifndef _COREDEFS_H_
#define _COREDEFS_H_

////////////////////////////////////////////////////
//  win64 conversion macros
//
#define INT2PTR(i, ptrType)     (reinterpret_cast<ptrType>(static_cast<INT_PTR>(i)))
#define PTR2INT(ptr)            (static_cast<INT>(reinterpret_cast<INT_PTR>(ptr)))
#define UINT2PTR(u, ptrType)    (reinterpret_cast<ptrType>(static_cast<UINT_PTR>(u)))
#define PTR2UINT(ptr)           (static_cast<UINT>(reinterpret_cast<UINT_PTR>(ptr)))
#define LONG2PTR(l, ptrType)    (reinterpret_cast<ptrType>(static_cast<LONG_PTR>(l)))
#define PTR2LONG(ptr)           (static_cast<LONG>(reinterpret_cast<LONG_PTR>(ptr)))
#define DWORD2PTR(dw, ptrType)  (reinterpret_cast<ptrType>(static_cast<DWORD_PTR>(dw)))
#define PTR2DWORD(ptr)          (static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(ptr)))

////////////////////////////////////////////////////
// check to define some useful debugging macros
//

#define BREAK_ON_FALSE(expr)                \
    do                                      \
    {                                       \
        if (!(expr))                        \
        {                                   \
            if (IsDebuggerPresent())        \
            {                               \
                DebugBreak();               \
            }                               \
            else                            \
            {                               \
                int *p = NULL;              \
                *p = 42;                    \
            }                               \
        }                                   \
    }                                       \
    while (false);                          \

#if DBG

// ***************** ASSERT *****************
#ifndef ASSERT
    #if defined(SPLASSERT) 
        // use SPLASSERT
        #define ASSERT(expr) SPLASSERT(expr) 
    #else
        #if defined(WIA_ASSERT)
            // use WIA_ASSERT
            #define ASSERT(expr) WIA_ASSERT(expr) 
        #else
            // ASSERT is not defined -- define a simple version
            #define ASSERT(expr) BREAK_ON_FALSE(expr)
        #endif // WIA_ASSERT
    #endif // SPLASSERT
#endif // ASSERT

// ***************** CHECK *****************
#ifndef CHECK
    #if defined(DBGMSG) && defined(DBG_INFO) 
        // use the printui trace macros
        #define CHECK(expr) \
            do \
            { \
                if(!(expr)) \
                { \
                    DBGMSG(DBG_INFO, ("Failed: "TSTR", File: "TSTR", Line: %d\n", #expr, __FILE__, __LINE__)); \
                } \
            } \
            while(FALSE) 
    #else 
        // nothing special
        #define CHECK(expr)  (expr) 
    #endif // DBGMSG && DBG_INFO
#endif // CHECK

// ***************** VERIFY *****************
#ifndef VERIFY
    #if defined(ASSERT) 
        #define VERIFY(expr) ASSERT(expr)
    #else
        #define VERIFY(expr) (expr)
    #endif // ASSERT
#endif // VERIFY

// ***************** RIP *****************
#ifndef RIP
    #if defined(ASSERT) 
        #define RIP(expr) ASSERT(expr)
    #else
        #define RIP(expr) BREAK_ON_FALSE(expr)
    #endif // ASSERT
#endif // RIP

#else // DBG

#undef ASSERT
#undef VERIFY
#undef CHECK
#undef RIP

#define ASSERT(expr)
#define VERIFY(expr)    (expr)
#define CHECK(expr)     (expr)
#define RIP(expr)       BREAK_ON_FALSE(expr)

#endif // DBG

////////////////////////////////////////////////
// some other helpful macros
//

#ifndef COUNTOF
#define COUNTOF(x) (sizeof(x)/sizeof(x[0]))
#endif // COUNTOF

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif // ARRAYSIZE

#endif // endif _COREDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\cntutils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       cntutils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Containers and algorithms utility templates
 *
 *****************************************************************************/

#ifndef _CNTUTILS_H
#define _CNTUTILS_H

// the generic smart pointers & handles
#include "gensph.h"

////////////////////////////////////////////////
// Algorithms
//
namespace Alg
{

///////////////////////////////////////////////////////////////
// CDefaultAdaptor<T,K> - default adaptor class.
//
// T - type
// K - key for sorting
//
template <class T, class K = T>
class CDefaultAdaptor
{
public:
    // assumes the key is the item itself
    static const K& Key(const T &i) { return (const K&)i; }
    // assumes K has less operator defined
    static int Compare(const K &k1, const K &k2) { return (k2 < k1) - (k1 < k2); }
    // assumes assignment operator defined
    static T& Assign(T &i1, const T &i2) { return (i1 = i2); }
};

//////////////////////////////////////////////////////////
// _LowerBound<T,K,A> - lowerbound search alg.
// assumes the array is sorted.
//
// returns the position where this key (item) should be inserted. 
// all the items before that position will be less or equal to the input key
//
// T - type
// K - key for sorting
// A - adaptor
//
template <class T, class K, class A>
int _LowerBound(const K &k, const T *base, int lo, int hi)
{
    while( lo <= hi )
    {
        if( lo == hi )
        {
            // boundary case
            if( A::Compare(k, A::Key(base[lo])) >= 0 )
            {
                // k >= lo
                lo++;
            }
            break;
        }
        else
        {
            // divide & conquer
            int mid = (lo+hi)/2;

            if( A::Compare(k, A::Key(base[mid])) < 0 )
            {
                // k < mid
                hi = mid;
            }
            else
            {
                // k >= mid
                lo = mid+1;
            }
        }
    }
    return lo;
}

///////////////////////////////////////////////////////////////
// CSearchAlgorithms<T,K,A> - search alg.
//
// T - type
// K - key for sorting
// A - adaptor
//
// default template arguments are allowed only on classes
template <class T, class K = T, class A = CDefaultAdaptor<T,K> >
class CSearchAlgorithms
{
public:
    // lower bound
    static int LowerBound(const K &k, const T *base, int count)
    {
        return _LowerBound<T,K,A>(k, base, 0, count-1);
    }

    // binary search
    static bool Find(const K &k, const T *base, int count, int *pi)
    {
        int iPos = _LowerBound<T,K,A>(k, base, 0, count-1)-1;
        bool bFound = (0 <= iPos && iPos < count && 0 == A::Compare(k, A::Key(base[iPos])));
        if( bFound && pi ) *pi = iPos;
        return bFound;
    };
};

} // namespace Alg

////////////////////////////////////////////////
//
// class CSimpleArray
//
// a simple array implementation based on 
// shell DSA_* stuff (not MT safe)
//

// turn off debugging new for a while
#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#undef new
#endif

template <class T>
class CSimpleArray
{
    // in-place construct/destruct wrapper
    class CWrapper
    {
    public:
        // proper copy semantics
        CWrapper() { }
        CWrapper(const T &t): m_t(t) { }
        T& operator = (const T &t) { m_t = t; return t; }

        // placed new & delete

        void *operator new(size_t, CWrapper *p) { ASSERT(p); return p; }
        void  operator delete(void *p) { }
        T m_t;
    };
public:
    enum { DEFAULT_GROW = 32 };
    typedef int (*PFN_COMPARE)(const T &i1, const T &i2);

    CSimpleArray(int iGrow = DEFAULT_GROW) { Create(iGrow); }
    ~CSimpleArray() { Destroy(); }

    HRESULT Create(int iGrow = DEFAULT_GROW)
    {
        m_shDSA = DSA_Create(sizeof(CWrapper), iGrow);
        return m_shDSA ? S_OK : E_OUTOFMEMORY;
    }

    HRESULT Destroy()
    {
        if( m_shDSA )
        {
            DeleteAll();
            m_shDSA = NULL;
        }
        return S_OK;
    }

    // the array interface
    int Count() const
    {
        ASSERT(m_shDSA);
        return _DSA_GetItemCount(m_shDSA);
    }

    const T& operator [] (int i) const
    {
        return _GetWrapperAt(i)->m_t;
    }

    T& operator [] (int i)
    {
        return _GetWrapperAt(i)->m_t;
    }

    // returns true if created/initialized
    operator bool () const
    {
        return m_shDSA;
    }

    // returns -1 if failed to grow - i.e. out of memory
    int Append(const T &item)
    {
        ASSERT(m_shDSA);

        int i = DSA_InsertItem(m_shDSA, DA_LAST, (void *)_GetZeroMemWrapper()); // allocate
        if( -1 != i ) 
        {
            new (_GetWrapperAt(i)) CWrapper(item); // construct
        }

        return i;
    }

    // returns -1 if failed to grow - i.e. out of memory
    int Insert(int i, const T &item)
    {
        ASSERT(m_shDSA && 0 <= i && i <= _DSA_GetItemCount(m_shDSA));

        i = DSA_InsertItem(m_shDSA, i, (void *)_GetZeroMemWrapper()); // allocate
        if( -1 != i ) 
        {
            new (_GetWrapperAt(i)) CWrapper(item); // construct
        }

        return i;
    }

    BOOL Delete(int i)
    {
        ASSERT(m_shDSA && 0 <= i && i < _DSA_GetItemCount(m_shDSA));
        delete _GetWrapperAt(i); // destruct
        return DSA_DeleteItem(m_shDSA, i); // free
    }

    void DeleteAll()
    {
        ASSERT(m_shDSA);

        // destruct all
        if( Count() )
        {
            int i, iCount = Count();
            CWrapper *p = _GetWrapperAt(0);
            for( i=0; i<iCount; i++ )
            {
                delete (p+i);
            }
        }

        // free all
        DSA_DeleteAllItems(m_shDSA);
    }

    HRESULT Sort(PFN_COMPARE pfnCompare)
    {
        // would be nice to have it
        return E_NOTIMPL;
    }

private:
    static CWrapper* _GetZeroMemWrapper()
    { 
        // returns zero initialized memory of size - sizeof(CWrapper)
        static BYTE buffer[sizeof(CWrapper)]; 
        return reinterpret_cast<CWrapper*>(buffer);
    }
    CWrapper* _GetWrapperAt(int i) const
    {
        ASSERT(m_shDSA && 0 <= i && i < _DSA_GetItemCount(m_shDSA));
        return reinterpret_cast<CWrapper*>(DSA_GetItemPtr(m_shDSA, i));
    }
    int _DSA_GetItemCount(HDSA hdsa) const
    {
        // DSA_GetItemCount is a macro, which is casting to int* (somewhat illegal),
        // so we need to do a static cast here, so our casting operator gets invoked
        return DSA_GetItemCount(static_cast<HDSA>(m_shDSA));
    }

    CAutoHandleHDSA m_shDSA; // shell dynamic structure array
};

// turn back on debugging new
#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

////////////////////////////////////////////////
//
// class CSortedArray<T,K,A>
//
// a sorted array implementation based on DSA_*
// (not MT safe)
//
// T - type
// K - key for sorting
// A - adaptor
//
template <class T, class K = T, class A = Alg::CDefaultAdaptor<T,K> >
class CSortedArray: public CSimpleArray<T>
{
public:
    CSortedArray() { }
    CSortedArray(int iGrow): CSimpleArray<T>(iGrow) { }
    ~CSortedArray() { }

    // returns -1 if failed to grow - i.e. out of memory
    int SortedInsert(const T &item)
    { 
        return CSimpleArray<T>::Insert(
            Count() ? Alg::CSearchAlgorithms<T,K,A>::LowerBound(A::Key(item), &operator[](0), Count()) : 0, 
            item);
    }

    // true if found and false otherwise
    bool FindItem(const K &k, int *pi) const
    { 
        return Count() ? Alg::CSearchAlgorithms<T,K,A>::Find(k, &operator[](0), Count(), pi) : false;
    }

private:
    // those APIs shouldn't be visible, so make them private.
    int Append(const T &item)               { CSimpleArray<T>::Append(item);        }
    int Insert(int i, const T &item)        { CSimpleArray<T>::Insert(i, item);     }
    HRESULT Sort(PFN_COMPARE pfnCompare)    { CSimpleArray<T>::Sort(pfnCompare);    }
};

////////////////////////////////////////////////
//
// class CFastHeap<T>
//
// fast cached heap for fixed chunks 
// of memory (MT safe)
//
template <class T>
class CFastHeap
{
public:
    enum { DEFAULT_CACHE_SIZE = 32 };

    // construction/destruction
    CFastHeap(int iCacheSize = DEFAULT_CACHE_SIZE);
    ~CFastHeap();

    // the fast heap interface
    HRESULT Alloc(const T &data, HANDLE *ph);
    HRESULT Free(HANDLE h);
    HRESULT GetItem(HANDLE h, T **ppData);

#if DBG
    int m_iPhysicalAllocs;
    int m_iLogicalAllocs;
#else
private:
#endif

    // private stuff/impl.
    struct HeapItem
    {
        HeapItem *pNext;
        T data;
    };

    CCSLock m_csLock;
    HeapItem *m_pFreeList;
    int m_iCacheSize;
    int m_iCached;
};

// include the implementation of the template classes here
#include "cntutils.inl"

#endif // endif _CNTUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\comutils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       comutils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: COM templates & utilities
 *
 *****************************************************************************/

#ifndef _COMUTILS_H
#define _COMUTILS_H

// the generic smart pointers & handles
#include "gensph.h"

////////////////////////////////////////////////
// template class CUnknownMT<pQITable>
//
// milti-thread impl. of IUnknown
// with interlocking for the ref-counting.
//
template <const QITAB* pQITable>
class CUnknownMT
{
public:
    CUnknownMT(): m_cRefs(1) {}
    virtual ~CUnknownMT()   {}

    //////////////////
    // IUnknown
    //
    STDMETHODIMP Handle_QueryInterface(REFIID riid, void **ppv)
    {
        return QISearch(this, pQITable, riid, ppv);
    }
    STDMETHODIMP_(ULONG) Handle_AddRef()
    {
        return InterlockedIncrement(&m_cRefs);
    }
    STDMETHODIMP_(ULONG) Handle_Release()
    {
        ULONG cRefs = InterlockedDecrement(&m_cRefs);
        if( 0 == cRefs )
        {
            delete this;
        }
        return cRefs;
    }
private:
    LONG m_cRefs;
};

////////////////////////////////////////////////
// template class CUnknownST<pQITable>
//
// single-thread impl. of IUnknown
// no interlocking for the ref-counting.
//
template <const QITAB* pQITable>
class CUnknownST
{
public:
    CUnknownST(): m_cRefs(1) {}
    virtual ~CUnknownST()   {}

    //////////////////
    // IUnknown
    //
    STDMETHODIMP Handle_QueryInterface(REFIID riid, void **ppv)
    {
        return QISearch(this, pQITable, riid, ppv);
    }
    STDMETHODIMP_(ULONG) Handle_AddRef()
    {
        return m_cRefs++;
    }
    STDMETHODIMP_(ULONG) Handle_Release()
    {
        if( 0 == --m_cRefs )
        {
            delete this;
            return 0;
        }
        return m_cRefs;
    }
private:
    LONG m_cRefs;
};

#define QITABLE_DECLARE(className)  \
    class className##_QITable       \
    {                               \
    public:                         \
        static const QITAB qit[];   \
    };                              \


#define QITABLE_GET(className)      \
    className##_QITable::qit        \

#define QITABLE_BEGIN(className)                    \
    const QITAB className##_QITable::qit[] =        \
    {                                               \

#define QITABLE_END()                               \
        { 0 },                                      \
    };                                              \

#define IMPLEMENT_IUNKNOWN()                                \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)    \
    { return Handle_QueryInterface(riid, ppv); }            \
    STDMETHODIMP_(ULONG) AddRef()                           \
    { return Handle_AddRef(); }                             \
    STDMETHODIMP_(ULONG) Release()                          \
    { return Handle_Release(); }                            \

#if FALSE
////////////////////////////////////////////////
// template class CEnumFormatEtc
//
// implementation for an IDataObject which
// supports SetData to different formats.
// - not implemented yet.
//
class CEnumFormatEtc: public IEnumFORMATETC
{
public:
    CEnumFormatEtc(IUnknown *pUnkOuter, const FORMATETC *pfetc, UINT uSize);
    ~CEnumFormatEtc();

    //////////////////
    // IUnknown 
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //////////////////
    // IEnumFORMATETC 
    //
    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ FORMATETC *rgelt,
        /* [out] */ ULONG *pceltFetched) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumFORMATETC **ppenum) = 0;

private:
    ULONG           m_cRefs;
    IUnknown       *m_pUnkOuter;
    LPFORMATETC     m_prgfe;
    ULONG           m_iCur;
    ULONG           m_cItems;
};
#endif // #if FALSE

////////////////////////////////////////////////
// template class CDataObj<MAX_FORMATS>
//
// implementation for an IDataObject which
// supports SetData to different formats.
//
template <int MAX_FORMATS = 32>
class CDataObj: public IDataObject
{
public:
    // construction/destruction
    CDataObj();
    ~CDataObj();

    //////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //////////////////
    // IDataObject
    //
    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE GetData(
        /* [unique][in] */ FORMATETC *pformatetcIn,
        /* [out] */ STGMEDIUM *pmedium);

    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
        /* [unique][in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);

    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
        /* [unique][in] */ FORMATETC *pformatetc);

    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
        /* [unique][in] */ FORMATETC *pformatectIn,
        /* [out] */ FORMATETC *pformatetcOut);

    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE SetData(
        /* [unique][in] */ FORMATETC *pformatetc,
        /* [unique][in] */ STGMEDIUM *pmedium,
        /* [in] */ BOOL fRelease);

    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
        /* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);

    virtual HRESULT STDMETHODCALLTYPE DAdvise(
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
        /* [unique][in] */ IAdviseSink *pAdvSink,
        /* [out] */ DWORD *pdwConnection);

    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
        /* [in] */ DWORD dwConnection);

    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
        /* [out] */ IEnumSTATDATA **ppenumAdvise);

private:
    LONG m_cRefs;
    FORMATETC m_fmte[MAX_FORMATS];
    STGMEDIUM m_medium[MAX_FORMATS];
};


////////////////////////////////////////////////
// template class CSimpleDataObjImpl<T>
//
// simple implementation for an IDataObject
// and IDropSource which lives in memory.
//
template <class T>
class CSimpleDataObjImpl: public IDataObject,
                          public IDropSource
{
public:
    // construction/destruction
    CSimpleDataObjImpl(const T &data, CLIPFORMAT cfDataType, IDataObject *pDataObj = NULL);
    ~CSimpleDataObjImpl();

    //////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //////////////////
    // IDataObject
    //
    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE GetData(
        /* [unique][in] */ FORMATETC *pformatetcIn,
        /* [out] */ STGMEDIUM *pmedium);

    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE GetDataHere(
        /* [unique][in] */ FORMATETC *pformatetc,
        /* [out][in] */ STGMEDIUM *pmedium);

    virtual HRESULT STDMETHODCALLTYPE QueryGetData(
        /* [unique][in] */ FORMATETC *pformatetc);

    virtual HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
        /* [unique][in] */ FORMATETC *pformatectIn,
        /* [out] */ FORMATETC *pformatetcOut);

    /* [local] */ 
    virtual HRESULT STDMETHODCALLTYPE SetData(
        /* [unique][in] */ FORMATETC *pformatetc,
        /* [unique][in] */ STGMEDIUM *pmedium,
        /* [in] */ BOOL fRelease);

    virtual HRESULT STDMETHODCALLTYPE EnumFormatEtc(
        /* [in] */ DWORD dwDirection,
        /* [out] */ IEnumFORMATETC **ppenumFormatEtc);

    virtual HRESULT STDMETHODCALLTYPE DAdvise(
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ DWORD advf,
        /* [unique][in] */ IAdviseSink *pAdvSink,
        /* [out] */ DWORD *pdwConnection);

    virtual HRESULT STDMETHODCALLTYPE DUnadvise(
        /* [in] */ DWORD dwConnection);

    virtual HRESULT STDMETHODCALLTYPE EnumDAdvise(
        /* [out] */ IEnumSTATDATA **ppenumAdvise);

    //////////////////
    // IDropSource
    //
    virtual HRESULT STDMETHODCALLTYPE QueryContinueDrag(
        /* [in] */ BOOL fEscapePressed,
        /* [in] */ DWORD grfKeyState);

    virtual HRESULT STDMETHODCALLTYPE GiveFeedback(
        /* [in] */ DWORD dwEffect);

private:
    LONG        m_cRefs;
    T           m_data;
    CLIPFORMAT  m_cfDataType;
    CRefPtrCOM<IDataObject> m_spDataObj;
};

// this namespace is a placeholder to put COM related helpers here
namespace comhelpers
{

BOOL AreObjectsIdentical(IUnknown *punk1, IUnknown *punk2);

}

// include the implementation of the template classes here
#include "comutils.inl"

#endif // endif _COMUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\fusutils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       fusutils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/

#ifndef _FUSUTILS_H
#define _FUSUTILS_H

// open C code brace
#ifdef __cplusplus
extern "C" {
#endif

//
// CreateActivationContextFromExecutableEx:
//
// check the passed in executable name for a manifest (if any)
// and creates an activation context from it.
//
HRESULT CreateActivationContextFromExecutableEx(
    LPCTSTR lpszExecutableName, 
    UINT uResourceID, 
    BOOL bMakeProcessDefault, 
    HANDLE *phActCtx);

//
// CreateActivationContextFromExecutable:
//
// check the passed in executable name for a manifest (if any)
// and creates an activation context from it using the defaults
// (i.e. bMakeProcessDefault=FALSE & uResourceID=123)
//
HRESULT CreateActivationContextFromExecutable(
    LPCTSTR lpszExecutableName, 
    HANDLE *phActCtx);

// close C code brace
#ifdef __cplusplus
}
#endif

#endif // endif _FUSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\cntutils.inl ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       cntutils.inl
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Containers and algorithms utility templates (Impl.)
 *
 *****************************************************************************/

////////////////////////////////////////////////
//
// class CFastHeap<T>
//
// fast cached heap for fixed chunks 
// of memory (MT safe)
//

template <class T>
CFastHeap<T>::CFastHeap<T>(int iCacheSize): 
#if DBG
    m_iPhysicalAllocs(0),
    m_iLogicalAllocs(0),
#endif
    m_pFreeList(NULL),
    m_iCacheSize(iCacheSize),
    m_iCached(0)
{
    // nothing
}

template <class T>
CFastHeap<T>::~CFastHeap<T>()
{
    // delete the cache
    while( m_pFreeList )
    {
        HeapItem *pItem = m_pFreeList;
        m_pFreeList = m_pFreeList->pNext;
        delete pItem;
#if DBG
        m_iPhysicalAllocs--;
#endif
    }

#if DBG
    ASSERT(0 == m_iPhysicalAllocs);
    ASSERT(0 == m_iLogicalAllocs);
#endif
}

template <class T>
HRESULT CFastHeap<T>::Alloc(const T &data, HANDLE *ph)
{
    CCSLock::Locker lock(m_csLock);
    HRESULT hr = E_INVALIDARG;

    if( ph )
    {
        *ph = NULL;
        HeapItem *pi = NULL;

        if( m_pFreeList )
        {
            // we have an item in the cache, just use it
            pi = m_pFreeList;
            m_pFreeList = m_pFreeList->pNext;
            m_iCached--;
            ASSERT(m_iCached >= 0);
        }
        else
        {
            // no items in the cache, allocate new one
            pi = new HeapItem;
#if DBG
            m_iPhysicalAllocs++;
#endif
        }

        if( pi )
        {
            pi->data = data;
            *ph = reinterpret_cast<HANDLE>(pi);
#if DBG
            m_iLogicalAllocs++;
#endif
        }   

        hr = (*ph) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

template <class T>
HRESULT CFastHeap<T>::Free(HANDLE h)
{
    CCSLock::Locker lock(m_csLock);
    HRESULT hr = E_INVALIDARG;

    if( h )
    {
#if DBG
        m_iLogicalAllocs--;
#endif
        ASSERT(m_iCached >= 0);
        HeapItem *pi = reinterpret_cast<HeapItem*>(h);
        if( m_iCached < m_iCacheSize )
        {
            // the number of cached items is less than the
            // cache size, so we put this item in the cache
            pi->pNext = m_pFreeList;
            m_pFreeList = pi;
            m_iCached++;
        }
        else
        {
            // enough items cached, delete this one
            delete pi;
#if DBG
            m_iPhysicalAllocs--;
#endif
        }
        hr = S_OK;
    }

    return hr;
}

template <class T>
HRESULT CFastHeap<T>::GetItem(HANDLE h, T **ppData)
{
    // just return the item ptr. no need to aquire the CS as this is
    // readonly function and Alloc/Free cannot invalidate the item.
    *ppData = &(reinterpret_cast<HeapItem*>(h)->data);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\comutils.inl ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       comutils.inl
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: COM templates & utilities (Impl.)
 *
 *****************************************************************************/

////////////////////////////////////////////////
// template class CDataObj<MAX_FORMATS>
//
// implementation for an IDataObject which
// supports SetData to different formats.
//

// construction/destruction
template <int MAX_FORMATS>
CDataObj<MAX_FORMATS>::CDataObj<MAX_FORMATS>()
    : m_cRefs(1)
{
    memset(m_fmte, 0, sizeof(m_fmte));
    memset(m_medium, 0, sizeof(m_medium));
}

template <int MAX_FORMATS>
CDataObj<MAX_FORMATS>::~CDataObj<MAX_FORMATS>()
{
    // release the data we keep
    for( int i = 0; i < MAX_FORMATS; i++ )
    {
        if( m_medium[i].hGlobal )
        {
            ReleaseStgMedium(&m_medium[i]);
        }
    }
}

///////////////////////////////
// IUnknown impl. - standard
//
template <int MAX_FORMATS>
STDMETHODIMP CDataObj<MAX_FORMATS>::QueryInterface(REFIID riid, void **ppv)
{
    // standard implementation
    if( !ppv )
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject) )
    {
        *ppv = static_cast<IDataObject*>(this);
    } 
    else 
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

template <int MAX_FORMATS>
STDMETHODIMP_(ULONG) CDataObj<MAX_FORMATS>::AddRef()
{
    // standard implementation
    return InterlockedIncrement(&m_cRefs);
}

template <int MAX_FORMATS>
STDMETHODIMP_(ULONG) CDataObj<MAX_FORMATS>::Release()
{
    // standard implementation
    ULONG cRefs = InterlockedDecrement(&m_cRefs);
    if( 0 == cRefs )
    {
        delete this;
    }
    return cRefs;
}

//////////////////
// IDataObject
//
template <int MAX_FORMATS>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::GetData(
    /* [unique][in] */ FORMATETC *pformatetcIn,
    /* [out] */ STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    pmedium->hGlobal = NULL;
    pmedium->pUnkForRelease = NULL;

    for( int i = 0; i < MAX_FORMATS; i++ )
    {
        if( (m_fmte[i].cfFormat == pformatetcIn->cfFormat) &&
            (m_fmte[i].tymed & pformatetcIn->tymed) &&
            (m_fmte[i].dwAspect == pformatetcIn->dwAspect) )
        {
            *pmedium = m_medium[i];

            if( pmedium->hGlobal )
            {
                // indicate that the caller should not release hmem.
                if( pmedium->tymed == TYMED_HGLOBAL )
                {
                    pmedium->pUnkForRelease = static_cast<IDataObject*>(this);
                    AddRef();
                    return S_OK;
                }

                // if the type is stream  then clone the stream.
                if( pmedium->tymed == TYMED_ISTREAM )
                {
                    hr = CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm);

                    if( SUCCEEDED(hr) )
                    {
                        STATSTG stat;

                         // Get the Current Stream size
                         hr = m_medium[i].pstm->Stat(&stat, STATFLAG_NONAME);

                         if( SUCCEEDED(hr) )
                         {
                            const LARGE_INTEGER g_li0 = {0};

                            // Seek the source stream to  the beginning.
                            m_medium[i].pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // Copy the entire source into the destination. Since the destination stream is created using 
                            // CreateStreamOnHGlobal, it seek pointer is at the beginning.
                            hr = m_medium[i].pstm->CopyTo(pmedium->pstm, stat.cbSize, NULL,NULL );
                        
                            // Before returning Set the destination seek pointer back at the beginning.
                            pmedium->pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                            // If this medium has a punk for release, make sure to add ref that...
                            pmedium->pUnkForRelease = m_medium[i].pUnkForRelease;

                            if( pmedium->pUnkForRelease )
                            {
                                pmedium->pUnkForRelease->AddRef();
                            }

                         }
                         else
                         {
                             hr = E_OUTOFMEMORY;
                         }
                    }
                }
            }
        }
    }

    return hr;
}

template <int MAX_FORMATS>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::GetDataHere(
    /* [unique][in] */ FORMATETC *pformatetc,
    /* [out][in] */ STGMEDIUM *pmedium)
{
    // we don't implement this. 
    return E_NOTIMPL;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::QueryGetData(
    /* [unique][in] */ FORMATETC *pformatetc)
{
    HRESULT hr = E_UNEXPECTED;

    for( int i = 0; i < MAX_FORMATS; i++ )
    {
        if( (m_fmte[i].cfFormat == pformatetc->cfFormat) &&
            (m_fmte[i].tymed & pformatetc->tymed) &&
            (m_fmte[i].dwAspect == pformatetc->dwAspect) )
        {
            hr = S_OK;
        }
    }

    return hr;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::GetCanonicalFormatEtc(
    /* [unique][in] */ FORMATETC *pformatectIn,
    /* [out] */ FORMATETC *pformatetcOut)
{
    // always return the data in the same format
    return DATA_S_SAMEFORMATETC;
}

template <int MAX_FORMATS>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::SetData(
    /* [unique][in] */ FORMATETC *pformatetc,
    /* [unique][in] */ STGMEDIUM *pmedium,
    /* [in] */ BOOL fRelease)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT(pformatetc->tymed == pmedium->tymed);

    if( fRelease )
    {
        int i;

        // first add it if that format is already present
        // on a NULL medium (render on demand)
        for( i = 0; i < MAX_FORMATS; i++ )
        {
            if( (m_fmte[i].cfFormat == pformatetc->cfFormat) &&
                (m_fmte[i].tymed    == pformatetc->tymed) &&
                (m_fmte[i].dwAspect == pformatetc->dwAspect) )
            {
                // we are simply adding a format, ignore.
                if( pmedium->hGlobal == NULL )
                {
                    return S_OK;
                }

                // if we are set twice on the same object
                if( m_medium[i].hGlobal )
                {
                    ReleaseStgMedium(&m_medium[i]);
                }

                m_medium[i] = *pmedium;
                return S_OK;
            }
        }

        //  this is a new clipboard format. look for a free slot.
        for( i = 0; i < MAX_FORMATS; i++ )
        {
            if( m_fmte[i].cfFormat == 0 )
            {
                // found a free slot
                m_medium[i] = *pmedium;
                m_fmte[i] = *pformatetc;
                return S_OK;
            }
        }

        // overflow of our fixed size table
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::EnumFormatEtc(
    /* [in] */ DWORD dwDirection,
    /* [out] */ IEnumFORMATETC **ppenumFormatEtc)
{
    // we don't implement this. 
    return E_NOTIMPL;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::DAdvise(
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink *pAdvSink,
    /* [out] */ DWORD *pdwConnection)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::DUnadvise(
    /* [in] */ DWORD dwConnection)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

template <int MAX_FORMATS>
HRESULT STDMETHODCALLTYPE CDataObj<MAX_FORMATS>::EnumDAdvise(
    /* [out] */ IEnumSTATDATA **ppenumAdvise)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

////////////////////////////////////////////////
// template class CSimpleDataObjImpl<T>
//
// simple implementation for an IDataObject
// and IDropSource which lives in memory.
//

// construction/destruction
template <class T>
CSimpleDataObjImpl<T>::CSimpleDataObjImpl<T>(const T &data, CLIPFORMAT cfDataType, IDataObject *pDataObj)
    : m_cRefs(1), 
      m_cfDataType(cfDataType)
{
    m_data = data;
    m_spDataObj.CopyFrom(pDataObj);
}

template <class T>
CSimpleDataObjImpl<T>::~CSimpleDataObjImpl<T>()
{
    // nothing special
}

///////////////////////////////
// IUnknown impl. - standard
//
template <class T>
STDMETHODIMP CSimpleDataObjImpl<T>::QueryInterface(REFIID riid, void **ppv)
{
    // standard implementation
    if( !ppv )
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDataObject) )
    {
        *ppv = static_cast<IDataObject*>(this);
    } 
    else if( IsEqualIID(riid, IID_IDropSource) )
    {
        *ppv = static_cast<IDropSource*>(this);
    }
    else 
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

template <class T>
STDMETHODIMP_(ULONG) CSimpleDataObjImpl<T>::AddRef()
{
    // standard implementation
    return InterlockedIncrement(&m_cRefs);
}

template <class T>
STDMETHODIMP_(ULONG) CSimpleDataObjImpl<T>::Release()
{
    // standard implementation
    ULONG cRefs = InterlockedDecrement(&m_cRefs);
    if( 0 == cRefs )
    {
        delete this;
    }
    return cRefs;
}

//////////////////
// IDataObject
//
template <class T>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::GetData(
    /* [unique][in] */ FORMATETC *pformatetcIn,
    /* [out] */ STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    // try our data obejct first
    if( m_spDataObj )
    {
        hr = m_spDataObj->GetData(pformatetcIn, pmedium);
    }

    if( FAILED(hr) )
    {
        pmedium->hGlobal = NULL;
        pmedium->pUnkForRelease = NULL;
        pmedium->tymed = TYMED_HGLOBAL;

        hr = QueryGetData(pformatetcIn);

        if( SUCCEEDED(hr) && FAILED(m_spDataObj->QueryGetData(pformatetcIn)) )
        {
            pmedium->hGlobal = GlobalAlloc(GPTR, sizeof(T));

            if( pmedium->hGlobal )
            {
                *((T *)pmedium->hGlobal) = m_data;
                hr = S_OK; // success
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

template <class T>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::GetDataHere(
    /* [unique][in] */ FORMATETC *pformatetc,
    /* [out][in] */ STGMEDIUM *pmedium)
{
    // we don't implement this. 
    return E_NOTIMPL;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::QueryGetData(
    /* [unique][in] */ FORMATETC *pformatetc)
{
    HRESULT hr = E_UNEXPECTED;

    // try our data obejct first
    if( m_spDataObj )
    {
        hr = m_spDataObj->QueryGetData(pformatetc);
    }

    if( FAILED(hr) )
    {
        if( m_cfDataType == pformatetc->cfFormat )
        {
            if( TYMED_HGLOBAL & pformatetc->tymed )
            {
                // success
                hr = S_OK;
            }
            else
            {
                // invalid tymed
                hr = DV_E_TYMED;
            }
        }
        else
        {
            // invalid clipboard format
            hr = DV_E_CLIPFORMAT;
        }
    }

    return hr;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::GetCanonicalFormatEtc(
    /* [unique][in] */ FORMATETC *pformatectIn,
    /* [out] */ FORMATETC *pformatetcOut)
{
    // always return the data in the same format
    return DATA_S_SAMEFORMATETC;
}

template <class T>
/* [local] */ 
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::SetData(
    /* [unique][in] */ FORMATETC *pformatetc,
    /* [unique][in] */ STGMEDIUM *pmedium,
    /* [in] */ BOOL fRelease)
{
    HRESULT hr = E_INVALIDARG;

    // try our data obejct first
    if( m_spDataObj )
    {
        hr = m_spDataObj->SetData(pformatetc, pmedium, fRelease);
    }

    if( FAILED(hr) )
    {
        hr = QueryGetData(pformatetc);

        if( SUCCEEDED(hr) && FAILED(m_spDataObj->QueryGetData(pformatetc)) )
        {
            if( pmedium->hGlobal )
            {
                m_data = *((T *)pmedium->hGlobal);
                hr = S_OK; // success
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }

    return hr;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::EnumFormatEtc(
    /* [in] */ DWORD dwDirection,
    /* [out] */ IEnumFORMATETC **ppenumFormatEtc)
{
    // we don't implement this. 
    return E_NOTIMPL;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::DAdvise(
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ DWORD advf,
    /* [unique][in] */ IAdviseSink *pAdvSink,
    /* [out] */ DWORD *pdwConnection)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::DUnadvise(
    /* [in] */ DWORD dwConnection)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::EnumDAdvise(
    /* [out] */ IEnumSTATDATA **ppenumAdvise)
{
    // we don't implement this. 
    return OLE_E_ADVISENOTSUPPORTED;
}

//////////////////
// IDropSource
//
template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::QueryContinueDrag(
    /* [in] */ BOOL fEscapePressed,
    /* [in] */ DWORD grfKeyState)
{
    // standard implementation
    HRESULT hr = S_OK;

    if( fEscapePressed )
    {
        hr = DRAGDROP_S_CANCEL;
    }

    if( !(grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)) )
    {
        hr = DRAGDROP_S_DROP;
    }

    return hr;
}

template <class T>
HRESULT STDMETHODCALLTYPE CSimpleDataObjImpl<T>::GiveFeedback(
    /* [in] */ DWORD dwEffect)
{
    // standard implementation
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

// this namespace is a placeholder to put COM related helpers here
namespace comhelpers
{

inline    
BOOL AreObjectsIdentical(IUnknown *punk1, IUnknown *punk2)
{
    BOOL bRet = FALSE;
    if (NULL == punk1 && NULL == punk2)
    {
        // if both are NULL then we assume they are identical
        bRet = TRUE;
    }
    else
    {
        // one of them isn't NULL - we compare using the COM identity rules
        if (punk1 && punk2)
        {
            CRefPtrCOM<IUnknown> spUnk1, spUnk2;
            if (SUCCEEDED(punk1->QueryInterface(IID_IUnknown, (void**)&spUnk1)) &&
                SUCCEEDED(punk2->QueryInterface(IID_IUnknown, (void**)&spUnk2)))
            {
                bRet = (spUnk1 == spUnk2);
            }
        }
    }
    return bRet;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\gensph.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       gensph.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: generic smart pointers & smart handles templates
 *
 *****************************************************************************/

#ifndef _GENSPH_H_
#define _GENSPH_H_

// include the core definitions first
#include "coredefs.h"

////////////////////////////////////////////////
//
// class CGenericSP
//
// a generic smart pointer
// everything starts here -:)
//
template < class   T, 
           class   inheritorClass,
           class   pType           = T*,
           INT_PTR null            = 0,
           class   pCType          = const T* >

class CGenericSP
{
public:
    // construction/destruction
    CGenericSP(): m_p(GetNull()) {}
    CGenericSP(pType p): m_p(GetNull()) { _Attach(p); }
    ~CGenericSP() { Reset(); }

    // follows common smart pointer impl. - 
    // operators & methods

    void Reset()
    {
        if( GetNull() != m_p )
        {
            _Delete(m_p);
            m_p = GetNull();
        }
    }

    void Attach(pType p)
    {
        Reset();
        m_p = (p ? p : GetNull());
    }

    pType Detach()
    {
        pType p = GetNull();
        if( GetNull() != m_p )
        {
            p = m_p;
            m_p = GetNull();
        }
        return p;
    }

    template <class AS_TYPE>
    AS_TYPE GetPtrAs() const
    {
        return (GetNull() == m_p) ? reinterpret_cast<AS_TYPE>(NULL) : reinterpret_cast<AS_TYPE>(m_p);
    }

    pType GetPtr() const
    {
        return GetPtrAs<pType>();
    }

    pType* GetPPT()
    {
        return static_cast<pType*>(&m_p);
    }

    pCType* GetPPCT()
    {
        return const_cast<pCType*>(&m_p);
    }

    void** GetPPV()
    {
        return reinterpret_cast<void**>(&m_p);
    }

    operator pType() const
    {
        return GetPtr();
    }

    T& operator*() const
    {
        ASSERT(GetNull() != m_p);
        return *m_p;
    }

    pType* operator&()
    {
        ASSERT(GetNull() == m_p);
        return GetPPT();
    }

    pType operator->() const
    {
        ASSERT(GetNull() != m_p);
        return (pType)m_p;
    }

    pType operator=(pType p)
    {
        _Attach(p);
        return m_p;
    }

    pType operator=(const int i)
    {
        // this operator is only for NULL assignment
        ASSERT(INT2PTR(i, pType) == NULL || INT2PTR(i, pType) == GetNull());
        Attach(INT2PTR(i, pType));
        return m_p;
    }

    bool operator!() const
    {
        return (GetNull() == m_p);
    }

    bool operator<(pType p) const
    {
        return (m_p < p);
    }

    bool operator==(pType p) const
    {
        return (m_p == p);
    }

protected:
    pType m_p;

    // those will be declared protected, so people won't use them directly
    CGenericSP(CGenericSP<T, inheritorClass, pType, null, pCType> &sp): m_p(GetNull()) 
    { 
        _Attach(sp); 
    }

    void Attach(CGenericSP<T, inheritorClass, pType, null, pCType> &sp)
    {
        static_cast<inheritorClass*>(this)->Attach(static_cast<pType>(sp));
        sp.Detach();
    }

    pType operator=(CGenericSP<T, inheritorClass, pType, null, pCType> &sp)
    {
        _Attach(sp);
        return m_p;
    }

    // NULL support, use these to check for/assign NULL in inheritors
    pType   GetNull()           const { return reinterpret_cast<pType>(null); }
    bool    IsNull(pType p)     const { return GetNull() == p;  }
    bool    IsntNull(pType p)   const { return GetNull() != p;  }

private:
    void _Attach(pType p)
    {
        // give a chance to inheritors to override the attach
        static_cast<inheritorClass*>(this)->Attach(p);
    }

    void _Attach(CGenericSP<T, inheritorClass, pType, null, pCType> &sp)
    {
        // give a chance to inheritors to override the attach
        static_cast<inheritorClass*>(this)->Attach(sp);
    }

    void _Delete(pType  p)
    { 
        // the inheritor class defines static member called Delete(pType p)
        // to destroy the object.
        if( GetNull() != p )
        {
            inheritorClass::Delete(p); 
        }
    }
};

// declares standard default contructor, copy constructor, attach 
// contructor and assignment operators (they can't be inherited as constructors can't) 
// for the CGenericSP class in an inheritor class.
#define DECLARE_GENERICSMARTPTR_CONSTRUCT(T, className)                             \
    private:                                                                        \
    className(className &sp): CGenericSP< T, className >(sp) { }                    \
    T* operator=(className &sp)                                                     \
    { return CGenericSP< T, className >::operator =(sp); }                          \
    public:                                                                         \
    className() { }                                                                 \
    className(T *p): CGenericSP< T, className >(p) { }                              \
    T* operator=(T *p)                                                              \
    { return CGenericSP< T, className >::operator =(p); }                           \
    T* operator=(const int i)                                                       \
    { return CGenericSP< T, className >::operator =(i); }                           \

#define DECLARE_GENERICSMARTPTR_CONSTRUCT1(T, className, pType)                     \
    private:                                                                        \
    className(className &sp): CGenericSP<T, className, pType>(sp) { }               \
    pType operator=(className &sp)                                                  \
    { return CGenericSP<T, className, pType>::operator =(sp); }                     \
    public:                                                                         \
    className() { }                                                                 \
    className(pType p): CGenericSP<T, className, pType>(p) { }                      \
    pType operator=(pType p)                                                        \
    { return CGenericSP<T, className, pType>::operator =(p); }                      \
    pType operator=(const int i)                                                    \
    { return CGenericSP<T, className, pType>::operator =(i); }                      \

#define DECLARE_GENERICSMARTPTR_CONSTRUCT2(T, className, pType, null)               \
    private:                                                                        \
    className(className &sp): CGenericSP<T, className, pType, null>(sp) { }         \
    pType operator=(className &sp)                                                  \
    { return CGenericSP<T, className, pType, null>::operator =(sp); }               \
    public:                                                                         \
    className() { }                                                                 \
    className(pType p): CGenericSP<T, className, pType, null>(p) { }                \
    pType operator=(pType p)                                                        \
    { return CGenericSP<T, className, pType, null>::operator =(p); }                \
    pType operator=(const int i)                                                    \
    { return CGenericSP<T, className, pType, null>::operator =(i); }                \

////////////////////////////////////////////////
////////// AUTO POINTERS ///////////////////////
////////////////////////////////////////////////

////////////////////////////////////////////////
//
// class CAutoPtr
//
// simple auto-pointer
// uses delete operator to free memory
//
template <class T>
class CAutoPtr: public CGenericSP< T, CAutoPtr<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtr<T>)
    static void Delete(T *p) { delete p; }
};

////////////////////////////////////////////////
//
// class CAutoPtrArray
//
// simple auto-pointer allocated as array
// uses delete[] operator to free memory
//
template <class T>
class CAutoPtrArray: public CGenericSP< T, CAutoPtrArray<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtrArray<T>)
    static void Delete(T *p) { delete[] p; }
};

////////////////////////////////////////////////
//
// class CAutoPtrCRT
//
// simple CRT auto-pointer - allocated with malloc/calloc
// uses free to free the memory
//
template <class T>
class CAutoPtrCRT: public CGenericSP< T, CAutoPtrCRT<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtrCRT<T>)
    static void Delete(T *p) { free(p); }
};

////////////////////////////////////////////////
//
// class CAutoPtrSpl
//
// simple spooler auto-pointer -
// uses FreeMem to free memory
//
template <class T>
class CAutoPtrSpl: public CGenericSP< T, CAutoPtrSpl<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtrSpl<T>)
    static void Delete(T *p) { FreeMem(p); }
};

////////////////////////////////////////////////
//
// class CAutoPtrBSTR
//
// simple BSTR auto-pointer -
// SysAllocString/SysFreeString
//
class CAutoPtrBSTR: public CGenericSP<BSTR, CAutoPtrBSTR, BSTR>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(BSTR, CAutoPtrBSTR, BSTR)
    static void Delete(BSTR p) { SysFreeString(p); }
};

////////////////////////////////////////////////
//
// class CAutoPtrCOM
//
// simple smart COM pointer
//
template <class T>
class CAutoPtrCOM: public CGenericSP< T, CAutoPtrCOM<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtrCOM<T>)
    static void Delete(T *p) { p->Release(); } 
};

////////////////////////////////////////////////
//
// class CRefPtrCOM
//
// referenced smart COM pointer (ATL style)
// with improvements for robustness
//
template <class T>
class CRefPtrCOM: public CGenericSP< T, CRefPtrCOM<T> >
{
    void _AddRefAttach(T *p);
public:
    // special case all these
    CRefPtrCOM() { }
    CRefPtrCOM(const CGenericSP< T, CRefPtrCOM<T> > &sp): CGenericSP< T, CRefPtrCOM<T> >(sp) { }
    T* operator=(const CRefPtrCOM<T> &sp) { return CGenericSP< T, CRefPtrCOM<T> >::operator =(sp); }
    T* operator=(const int i) { return CGenericSP< T, CRefPtrCOM<T> >::operator =(i); }

    // overloaded stuff
    void Attach(const CRefPtrCOM<T> &sp) { _AddRefAttach(static_cast<T*>(sp)); }
    static void Delete(T *p) { p->Release(); } 

    // use these functions instead of operators (more clear)
    HRESULT CopyFrom(T *p);             // AddRef p  and assign to this
    HRESULT CopyTo(T **ppObj);          // AddRef this and assign to ppObj
    HRESULT TransferTo(T **ppObj);      // assign this to ppObj and assign NULL to this
    HRESULT Adopt(T *p);                // take ownership of p

private:
    // disable contruction, assignment operator & attach from
    // a raw pointer - it's not clear what exactly you want:
    // to copy (AddRef) the object or to take ownership - use
    // the functions above to make clear
    void Attach(T* p);
    CRefPtrCOM(T *p);
    T* operator=(T *p);
};


////////////////////////////////////////////////
//
// class CAutoPtrShell
//
// smart shell auto pointer - 
// uses shell IMalloc to free memory
//
template <class T>
class CAutoPtrShell: public CGenericSP< T, CAutoPtrShell<T> >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(T, CAutoPtrShell<T>)
    static void Delete(T *p)
    {
        CAutoPtrCOM<IMalloc> spShellMalloc;
        if( SUCCEEDED(SHGetMalloc(&spShellMalloc)) )
        {
            spShellMalloc->Free(p);
        }
    }
};

////////////////////////////////////////////////
//
// class CAutoPtrPIDL
//
// smart shell ID list ptr - LPCITEMIDLIST, LPITEMIDLIST.
//
typedef CAutoPtrShell<ITEMIDLIST> CAutoPtrPIDL;

////////////////////////////////////////////////
////////// AUTO HANDLES ////////////////////////
////////////////////////////////////////////////

////////////////////////////////////////////////
//
// class CAutoHandleNT
//
// NT kernel object handle (closed with CloseHandle)
//
class CAutoHandleNT: public CGenericSP<HANDLE, CAutoHandleNT, HANDLE>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HANDLE, CAutoHandleNT, HANDLE)
    static void Delete(HANDLE h) { VERIFY(CloseHandle(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleHLOCAL
//
// NT local heap handle (closed with LocalFree)
//
class CAutoHandleHLOCAL: public CGenericSP<HLOCAL, CAutoHandleHLOCAL, HLOCAL>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HLOCAL, CAutoHandleHLOCAL, HLOCAL)
    static void Delete(HLOCAL h) { VERIFY(NULL == LocalFree(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleHGLOBAL
//
// NT global heap handle (closed with GlobalFree)
//
class CAutoHandleHGLOBAL: public CGenericSP<HGLOBAL, CAutoHandleHGLOBAL, HGLOBAL>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HGLOBAL, CAutoHandleHGLOBAL, HGLOBAL)
    static void Delete(HGLOBAL h) { VERIFY(NULL == GlobalFree(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandlePrinter
//
// auto printer handle
//
class CAutoHandlePrinter: public CGenericSP<HANDLE, CAutoHandlePrinter, HANDLE>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HANDLE, CAutoHandlePrinter, HANDLE)
    static void Delete(HANDLE h) { CHECK(ClosePrinter(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandlePrinterNotify
//
// printer notifications handle - 
// Find[Firse/Next/Close]PrinterChangeNotification()
//
class CAutoHandlePrinterNotify: public CGenericSP<HANDLE, CAutoHandlePrinterNotify, HANDLE, -1>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT2(HANDLE, CAutoHandlePrinterNotify, HANDLE, -1)
    static void Delete(HANDLE h) { CHECK(FindClosePrinterChangeNotification(h)); }
};

////////////////////////////////////////////////
//
// class CAutoPtrPrinterNotify
//
// printer notifications memory - spooler should free it.
// Find[Firse/Next/Close]PrinterChangeNotification()
//
class CAutoPtrPrinterNotify: public CGenericSP<PRINTER_NOTIFY_INFO, CAutoPtrPrinterNotify>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT(PRINTER_NOTIFY_INFO, CAutoPtrPrinterNotify)
    static void Delete(PRINTER_NOTIFY_INFO *p) { CHECK(FreePrinterNotifyInfo(p)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleGDI
//
// GDI auto handle (WindowsNT GDI handle wrapper)
//
template <class T>
class CAutoHandleGDI: public CGenericSP< T, CAutoHandleGDI<T>, T >
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(T, CAutoHandleGDI<T>, T)
    static void Delete(T hGDIObj) { VERIFY(DeleteObject(hGDIObj)); }
};

// GDI auto handles
typedef CAutoHandleGDI<HPEN>        CAutoHandlePen;
typedef CAutoHandleGDI<HBRUSH>      CAutoHandleBrush;
typedef CAutoHandleGDI<HFONT>       CAutoHandleFont;
typedef CAutoHandleGDI<HBITMAP>     CAutoHandleBitmap;
// etc...

////////////////////////////////////////////////
//
// class CAutoHandleCursor
//
// auto handle for HCURSOR
//
class CAutoHandleCursor: public CGenericSP<HCURSOR, CAutoHandleCursor, HCURSOR>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HCURSOR, CAutoHandleCursor, HCURSOR)
    static void Delete(HCURSOR h) { VERIFY(DestroyCursor(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleIcon
//
// auto handle for HICON
//
class CAutoHandleIcon: public CGenericSP<HICON, CAutoHandleIcon, HICON>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HICON, CAutoHandleIcon, HICON)
    static void Delete(HICON h) { VERIFY(DestroyIcon(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleMenu
//
// auto handle for HMENU
//
class CAutoHandleMenu: public CGenericSP<HMENU, CAutoHandleMenu, HMENU>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HMENU, CAutoHandleMenu, HMENU)
    static void Delete(HMENU h) { VERIFY(DestroyMenu(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleAccel
//
// auto handle for HACCEL
//
class CAutoHandleAccel: public CGenericSP<HACCEL, CAutoHandleAccel, HACCEL>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HACCEL, CAutoHandleAccel, HACCEL)
    static void Delete(HACCEL h) { DestroyAcceleratorTable(h); }
};

#ifdef _INC_COMCTRLP
////////////////////////////////////////////////
//
// class CAutoHandleHDSA
//
// auto handle for shell HDSA
// (dynamic structure arrays)
//
class CAutoHandleHDSA: public CGenericSP<HDSA, CAutoHandleHDSA, HDSA>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HDSA, CAutoHandleHDSA, HDSA)
    static void Delete(HDSA h) { VERIFY(DSA_Destroy(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleMRU
//
// auto handle for MRU (shell common controls)
// CreateMRUList/FreeMRUList
//
class CAutoHandleMRU: public CGenericSP<HANDLE, CAutoHandleMRU, HANDLE>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HANDLE, CAutoHandleMRU, HANDLE)
    static void Delete(HANDLE h) { FreeMRUList(h); }
};
#endif // _INC_COMCTRLP

////////////////////////////////////////////////
//
// class CAutoHandleHKEY
//
// auto handle for a Windows registry key (HKEY)
// RegCreateKeyEx/RegOpenKeyEx/RegCloseKey
//
class CAutoHandleHKEY: public CGenericSP<HKEY, CAutoHandleHKEY, HKEY>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HKEY, CAutoHandleHKEY, HKEY)
    static void Delete(HKEY h) { VERIFY(ERROR_SUCCESS == RegCloseKey(h)); }
};

////////////////////////////////////////////////
//
// class CAutoHandleHMODULE
//
// auto handle for a HMODULE
// LoadLibrary/FreeLibrary
//
class CAutoHandleHMODULE: public CGenericSP<HMODULE, CAutoHandleHMODULE, HMODULE>
{
public:
    DECLARE_GENERICSMARTPTR_CONSTRUCT1(HMODULE, CAutoHandleHMODULE, HMODULE)
    static void Delete(HMODULE h) { VERIFY(FreeLibrary(h)); }
};

// include the implementation of the template classes here
#include "gensph.inl"

#endif // endif _GENSPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\gensph.inl ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       gensph.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: generic smart pointers & smart handles templates
 *
 *****************************************************************************/

////////////////////////////////////////////////
//
// class CRefPtrCOM
//
// referenced smart COM pointer (ATL style)
//

template <class T>
inline void CRefPtrCOM<T>::_AddRefAttach(T *p)
{
    if( IsntNull(p) )
    {
        p->AddRef();
    }

    Reset();
    m_p = (p ? p : GetNull());
}

template <class T>
inline HRESULT CRefPtrCOM<T>::CopyFrom(T *p)
{ 
    _AddRefAttach(p);
    return S_OK;
}

template <class T>
inline HRESULT CRefPtrCOM<T>::CopyTo(T **ppObj)
{ 
    HRESULT hr = E_INVALIDARG;
    if( ppObj )
    {
        *ppObj = m_p;
        if( IsntNull(*ppObj) )
        {
            (*ppObj)->AddRef();
        }
        hr = S_OK;
    }
    return hr;
}

template <class T>
inline HRESULT CRefPtrCOM<T>::TransferTo(T **ppObj)
{
    HRESULT hr = E_INVALIDARG;
    if( ppObj )
    {
        *ppObj = m_p;
        m_p = GetNull();
        hr = S_OK;
    }
    return hr;
}

template <class T>
inline HRESULT CRefPtrCOM<T>::Adopt(T *p)
{
    Reset();
    m_p = (p ? p : GetNull());
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simcrack.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SIMCRACK.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        5/11/1998
*
*  DESCRIPTION: Simple Message-crackers
*
*******************************************************************************/
#ifndef ___SIMCRACK_H_INCLUDED
#define ___SIMCRACK_H_INCLUDED

// Define these if we're compiling on pre-sundown prepared compiler
#if !defined(GWLP_USERDATA)
#define GWLP_USERDATA    GWL_USERDATA
#define GWLP_WNDPROC     GWL_WNDPROC
#define DWLP_USER        DWL_USER
#define DWLP_MSGRESULT   DWL_MSGRESULT
#define SetWindowLongPtr SetWindowLong
#define GetWindowLongPtr GetWindowLong
#define INT_PTR          LONG
#endif



#if (0) // Examples

/****************************************

 EXAMPLE USAGE

 ****************************************/
// Normal message handlers for normal windows
LRESULT CALLBACK CMyWindow::WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
   SC_BEGIN_MESSAGE_HANDLERS(CMyWindow)
   {
       SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
       SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );
       SC_FORWARD_MESSAGE( WM_CLOSE, hWnd );
   }
   SC_HANDLE_REGISTERED_MESSAGE(MyMessage,MyMessageHandler);
   SC_END_MESSAGE_HANDLERS();
}

// For use in dialog boxes (handles DWLP_MSGRESULT, etc)
BOOL CALLBACK CMyDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CMyDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( MyMessage, MyMessageHandler );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}

// WM_NOTIFY message cracker usage:
LRESULT CMyWindow::OnNotify( WPARAM wParam, LPARAM lParam )
{
   SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
   {
       SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
       SC_HANDLE_NOTIFY_MESSAGE_CONTROL(LVN_DBLCLK,IDC_LIST,OnListDblClk);
   }
   SC_END_NOTIFY_MESSAGE_HANDLERS();
}

// WM_COMMAND message cracker usage:
LRESULT CMyWindow::OnCommand( WPARAM wParam, LPARAM lParam )
{
   SC_BEGIN_COMMAND_HANDLERS()
   {
       SC_HANDLE_COMMAND_NOTIFY(EN_CHANGE,IDC_EDIT,OnEditChange);
       SC_HANDLE_COMMAND(IDOK,OnOK);
   }
   SC_END_COMMAND_HANDLERS();
}

/*
For an example of a complete class structured to use this method of window encapsulation,
look at the bottom of the file.
*/

#endif // Examples

/****************************************

 IMPLEMENTATION

 ****************************************/


/****************************************
Normal message handlers for normal windows
****************************************/
#define SC_BEGIN_MESSAGE_HANDLERS(className) \
    className *This = (className*)GetWindowLongPtr(hWnd,GWLP_USERDATA);\
    if (WM_CREATE == uMsg)\
    {\
        This = new className(hWnd);\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(INT_PTR)This);\
    }\
    else if (WM_NCDESTROY == uMsg)\
    {\
        delete This;\
        This = NULL;\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,0);\
    }\
    switch (uMsg)

#define SC_HANDLE_MESSAGE(msg,handler) \
    case (msg):\
        {\
            if (This)\
                return This->handler( wParam, lParam );\
        }\
        break

#define SC_FORWARD_MESSAGE(msg,hwndForward)\
    case (msg):\
        {\
            return SendMessage( hwndForward, msg, wParam, lParam );\
        }\
        break

#define SC_END_MESSAGE_HANDLERS() \
    return (DefWindowProc(hWnd,uMsg,wParam,lParam))


#define SC_HANDLE_REGISTERED_MESSAGE(msg,handler)\
    if (This && uMsg == This->msg)\
    {\
        return This->handler( wParam, lParam );\
    }


/****************************************
Normal message handlers for reference counted windows
****************************************/
#define SC_BEGIN_REFCOUNTED_MESSAGE_HANDLERS(className) \
    className *This = (className*)GetWindowLongPtr(hWnd,GWLP_USERDATA);\
    if (WM_CREATE == uMsg)\
    {\
        This = new className(hWnd);\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(INT_PTR)This);\
    }\
    else if (WM_NCDESTROY == uMsg)\
    {\
        if (This)\
        {\
            This->Release();\
            This = NULL;\
        }\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,0);\
    }\
    switch (uMsg)

#define SC_HANDLE_MESSAGE(msg,handler) \
    case (msg):\
        {\
            if (This)\
                return This->handler( wParam, lParam );\
        }\
        break

#define SC_FORWARD_MESSAGE(msg,hwndForward)\
    case (msg):\
        {\
            return SendMessage( hwndForward, msg, wParam, lParam );\
        }\
        break

#define SC_END_MESSAGE_HANDLERS() \
    return (DefWindowProc(hWnd,uMsg,wParam,lParam))


#define SC_HANDLE_REGISTERED_MESSAGE(msg,handler)\
    if (This && uMsg == This->msg)\
    {\
        return This->handler( wParam, lParam );\
    }


/****************************************
Dialog box message crackers
****************************************/
#define SC_BEGIN_DIALOG_MESSAGE_HANDLERS(className) \
    UINT_PTR bRes = FALSE;\
    className *This = (className *)GetWindowLongPtr(hWnd,DWLP_USER);\
    if (WM_INITDIALOG == uMsg)\
    {\
        This = new className( hWnd );\
        SetWindowLongPtr(hWnd,DWLP_USER,(INT_PTR)This);\
    }\
    else if (WM_NCDESTROY == uMsg)\
    {\
        if (This)\
            delete This;\
        This = NULL;\
        SetWindowLongPtr(hWnd,DWLP_USER,(INT_PTR)This);\
    }\
    switch (uMsg)

#define SC_HANDLE_DIALOG_MESSAGE(msg,handler) \
case (msg):\
    {\
        if (This)\
        {\
            LRESULT lRes = This->handler( wParam, lParam );\
            if (WM_INITDIALOG==msg)\
            {\
                bRes = (UINT_PTR)(!lRes);\
            }\
            else if (WM_CTLCOLORBTN==msg || WM_CTLCOLORDLG==msg || WM_CTLCOLOREDIT==msg || WM_CTLCOLORLISTBOX==msg || WM_CTLCOLORMSGBOX==msg || WM_CTLCOLORSCROLLBAR==msg || WM_CTLCOLORSTATIC==msg)\
            {\
                bRes = (UINT_PTR)(lRes);\
            }\
            else bRes = true;\
            SetWindowLongPtr( hWnd, DWLP_MSGRESULT, (INT_PTR)lRes );\
        }\
    }\
    break

#define SC_HANDLE_REGISTERED_DIALOG_MESSAGE(msg,handler)\
        if (This && uMsg == This->msg)\
        {\
            LRESULT lRes = This->handler( wParam, lParam );\
            SetWindowLongPtr( hWnd, DWLP_MSGRESULT, (INT_PTR)lRes );\
            bRes = true;\
        }

#define SC_END_DIALOG_MESSAGE_HANDLERS() \
    return (bRes)

/****************************************
WM_NOTIFY message crackers
****************************************/
#define SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()

#define SC_HANDLE_NOTIFY_MESSAGE_CODE(_code,proc)\
    if ((_code) == ((LPNMHDR)lParam)->code)\
        return proc( wParam, lParam )

#define SC_HANDLE_NOTIFY_MESSAGE_CONTROL(_code,id,proc)\
    if ((_code) == ((LPNMHDR)lParam)->code && (id) == (int)wParam)\
        return proc( wParam, lParam )

#define SC_END_NOTIFY_MESSAGE_HANDLERS()\
    return 0;


/****************************************
WM_COMMAND message crackers
****************************************/
#define SC_BEGIN_COMMAND_HANDLERS()

#define SC_HANDLE_COMMAND_NOTIFY(nCode,nIdCtl,handler)\
    if (nCode==(int)HIWORD(wParam) && nIdCtl==(int)LOWORD(wParam))\
    {\
        handler( wParam, lParam );\
        return (0);\
    }

#define SC_HANDLE_COMMAND(nIdCtl,handler)\
    if (nIdCtl==(int)LOWORD(wParam))\
    {\
        handler( wParam, lParam );\
        return (0);\
    }

#define SC_END_COMMAND_HANDLERS()\
    return (0)

#if (0) // More examples

class CMyWindow
{
private:
    HWND m_hWnd;

private:
    explicit CHideWindow( HWND hWnd )
        : m_hWnd(hWnd)
    {
    }

public:
    ~CMyWindow(void)
    {
    }

    // Standard Windows Message Handlers
    LRESULT OnCreate( WPARAM wParam, LPARAM lParam )
    {
        return 0;
    }

    // WM_COMMAND Handlers
    void OnEditChange( WPARAM wParam, LPARAM lParam )
    {
    }

    void OnOK( WPARAM wParam, LPARAM lParam )
    {
    }

    // WM_NOTIFY Handlers
    LRESULT OnSetActive( WPARAM wParam, LPARAM lParam )
    {
        return 0;
    }

    LRESULT OnListDblClk( WPARAM wParam, LPARAM lParam )
    {
        return 0;
    }


    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
        {
            SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
            SC_HANDLE_NOTIFY_MESSAGE_CONTROL(LVN_DBLCLK,IDC_LIST,OnListDblClk);
        }
        SC_END_NOTIFY_MESSAGE_HANDLERS();
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND_NOTIFY(EN_CHANGE,IDC_EDIT,OnEditChange);
           SC_HANDLE_COMMAND(IDOK,OnOK);
       }
       SC_END_COMMAND_HANDLERS();
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CMyWindow)
        {
            SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
        }
        SC_END_MESSAGE_HANDLERS();
    }
};

#endif // More examples

#endif // ___SIMCRACK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simbstr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMBSTR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Simple CBSTR class
 *
 *******************************************************************************/
#ifndef _SIMBSTR_H_INCLUDED
#define _SIMBSTR_H_INCLUDED

#include <windows.h>
#include "simstr.h"

class CSimpleBStr
{
private:
    BSTR m_BStr;
public:
    CSimpleBStr( void )
    : m_BStr(NULL)
    {

    }
    CSimpleBStr( LPCWSTR pwstrString )
    : m_BStr(NULL)
    {
        AllocString(pwstrString);
    }
    CSimpleBStr( const CSimpleString &str )
    : m_BStr(NULL)
    {
        AllocString(CSimpleStringConvert::WideString(str).String());
    }
    CSimpleBStr( const CSimpleBStr &other )
    : m_BStr(NULL)
    {
        AllocString(other.WideString().String());
    }
    void AllocString( LPCWSTR pwstrString )
    {
        FreeString();
        if (pwstrString)
        {
            m_BStr = SysAllocString(pwstrString);
        }
    }
    void FreeString(void)
    {
        if (m_BStr)
        {
            SysFreeString(m_BStr);
            m_BStr = NULL;
        }
    }
    virtual ~CSimpleBStr(void)
    {
        FreeString();
    }
    CSimpleBStr &operator=( const CSimpleBStr &other )
    {
        AllocString(other.WideString().String());
        return *this;
    }
    CSimpleBStr &operator=( LPCWSTR lpwstrString )
    {
        AllocString(lpwstrString);
        return *this;
    }
    BSTR BString(void) const
    {
        return m_BStr;
    }
    operator BSTR(void) const
    {
        return m_BStr;
    }
    CSimpleStringWide WideString(void) const
    {
        return CSimpleStringConvert::WideString(CSimpleStringWide(m_BStr));
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\psnew.h ===
#ifndef __IINEW_H_INCLUDED
#define __IINEW_H_INCLUDED

#if defined(__cplusplus)

#include "wiadebug.h"

inline void * __cdecl operator new(size_t size)
{
    if (0 == size)
    {
        WIA_TRACE((TEXT("size == 0 in operator new")));
        return NULL;
    }
    PBYTE pBuf = size ? (PBYTE)LocalAlloc(LPTR, size) : NULL;
    WIA_ASSERT(pBuf != NULL);
    return (void *)pBuf;
}

inline void __cdecl operator delete(void *ptr)
{
    if (ptr)
        LocalFree(ptr);
}

extern "C" inline __cdecl _purecall(void)
{
    return 0;
}

#endif  // __cplusplus

#endif // __IINEW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simcrit.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMCRIT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/6/1999
 *
 *  DESCRIPTION: Simple critical section implementation.  Note the hideous hack
 *  to get around the fact that many of our components don't use the CRT (so global
 *  and static classes don't have their constructors called.  Ever.
 *  The solution is to link to MSVCRT.LIB and set _DllMainCRTStartup as the entry
 *  point in your DLL, instead of DllMain.  The way this is coded is not thread safe.
 *  Two threads could call InitializeCriticalSection at the same time.  If you setup
 *  your build as discussed above, this won't be a problem.  Note that this hack only
 *  affects the use of this class when you have a GLOBAL or STATIC instance of a
 *  critical section.
 *
 *******************************************************************************/
#ifndef __SIMCRIT_H_INCLUDED
#define __SIMCRIT_H_INCLUDED

#include <windows.h>

class CSimpleCriticalSection
{
private:
    CRITICAL_SECTION m_CriticalSection;
    bool             m_bInitCalled;

private:
    //
    // No implementation
    //
    CSimpleCriticalSection( const CSimpleCriticalSection & );
    CSimpleCriticalSection &operator=( const CSimpleCriticalSection & );

public:
    CSimpleCriticalSection(void)
        : m_bInitCalled(false)
    {
        Initialize();
    }
    ~CSimpleCriticalSection(void)
    {
        if (m_bInitCalled)
        {
            DeleteCriticalSection(&m_CriticalSection);
        }
    }
    void Initialize(void)
    {
        if (!m_bInitCalled)
        {
            _try
            {
                InitializeCriticalSection(&m_CriticalSection);
                m_bInitCalled = true;
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
#if defined(DBG)
                OutputDebugString(TEXT("CSimpleCriticalSection::Initialize(), InitializeCriticalSection failed\n"));
                DebugBreak();
#endif
                m_bInitCalled = false;
            }
        }
    }
    void Enter(void)
    {
        if (!m_bInitCalled)
        {
            Initialize();
        }
        if (m_bInitCalled)
        {
            EnterCriticalSection(&m_CriticalSection);
        }
    }
    void Leave(void)
    {
        if (m_bInitCalled)
        {
            LeaveCriticalSection(&m_CriticalSection);
        }
    }
    CRITICAL_SECTION &cs(void)
    {
        return m_CriticalSection;
    }
};

class CAutoCriticalSection
{
private:
    PVOID m_pvCriticalSection;
    bool m_bUsingPlainCriticalSection;

private:
    // No implementation
    CAutoCriticalSection(void);
    CAutoCriticalSection( const CAutoCriticalSection & );
    CAutoCriticalSection &operator=( const CAutoCriticalSection & );

public:
    CAutoCriticalSection( CSimpleCriticalSection &criticalSection )
      : m_pvCriticalSection(&criticalSection),
        m_bUsingPlainCriticalSection(false)
    {
        reinterpret_cast<CSimpleCriticalSection*>(m_pvCriticalSection)->Enter();
    }
    CAutoCriticalSection( CRITICAL_SECTION &criticalSection )
      : m_pvCriticalSection(&criticalSection),
        m_bUsingPlainCriticalSection(true)
    {
        EnterCriticalSection(reinterpret_cast<CRITICAL_SECTION*>(m_pvCriticalSection));
    }
    ~CAutoCriticalSection(void)
    {
        if (m_bUsingPlainCriticalSection)
        {
            LeaveCriticalSection(reinterpret_cast<CRITICAL_SECTION*>(m_pvCriticalSection));
        }
        else
        {
            reinterpret_cast<CSimpleCriticalSection*>(m_pvCriticalSection)->Leave();
        }
        m_pvCriticalSection = NULL;
    }
};


#endif //__SIMCRIT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simlist.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMLIST.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        2/25/1999
 *
 *  DESCRIPTION: Simple singly linked list template class.
 *
 *******************************************************************************/

#ifndef __SIMLIST_H_INCLUDED
#define __SIMLIST_H_INCLUDED

template <class T>
class CSimpleLinkedList
{
private:

    class CLinkedListNode
    {
    private:
        CLinkedListNode *m_pNext;
        T                m_Data;
    public:
        CLinkedListNode( const T &data )
        : m_pNext(NULL), m_Data(data)
        {
        }
        const CLinkedListNode *Next(void) const
        {
            return (m_pNext);
        }
        CLinkedListNode *Next(void)
        {
            return (m_pNext);
        }
        void Next( CLinkedListNode *pNext )
        {
            m_pNext = pNext;
        }
        const T &Data(void) const
        {
            return (m_Data);
        }
        T &Data(void)
        {
            return (m_Data);
        }
    };

private:
    CLinkedListNode *m_pHead;
    CLinkedListNode *m_pTail;
    int              m_nItemCount;

public:
    CSimpleLinkedList( const CSimpleLinkedList &other )
      : m_pHead(NULL),
        m_pTail(NULL),
        m_nItemCount(0)
    {
        for (Iterator i(other);i != other.End();i++)
        {
            Append(*i);
        }
    }
    CSimpleLinkedList(void)
      : m_pHead(NULL),
        m_pTail(NULL),
        m_nItemCount(0)
    {
    }
    CSimpleLinkedList &operator=( const CSimpleLinkedList &other )
    {
        //
        // Make sure we aren't the same object
        //
        if (this != &other)
        {
            //
            // Free our list
            //
            Destroy();

            //
            // Loop through the other list, copying nodes to our list
            //
            for (Iterator i(other);i != other.End();i++)
            {
                Append(*i);
            }
        }
        return *this;
    }
    virtual ~CSimpleLinkedList(void)
    {
        Destroy();
    }
    void Destroy(void)
    {
        //
        // Loop through each item, deleting it
        //
        while (m_pHead)
        {
            //
            // Save the head pointer
            //
            CLinkedListNode *pCurr = m_pHead;

            //
            // Point the head to the next item
            //
            m_pHead = m_pHead->Next();

            //
            // Delete this item
            //
            delete pCurr;
        }

        //
        // Reinitialize all the variables to their empty state
        //
        m_pHead = m_pTail = NULL;
        m_nItemCount = 0;
    }
    void Remove( const T &data )
    {
        //
        // Loop until we find this item, and save the previous item before incrementing
        //
        CLinkedListNode *pPrev = NULL, *pCurr = m_pHead;
        while (pCurr && pCurr->Data() != data)
        {
            pPrev = pCurr;
            pCurr = pCurr->Next();
        }
        
        //
        // If we didn't find the item, return
        //
        if (!pCurr)
        {
            return;
        }

        //
        // If this is the last item, point the tail pointer at the previous item (which could be NULL)
        //
        if (pCurr == m_pTail)
        {
            m_pTail = pPrev;
        }

        //
        // If this is the first item, point the head at the next item
        //
        if (pCurr == m_pHead)
        {
            m_pHead = pCurr->Next();
        }
        
        //
        // Point the previous item's next pointer at our next pointer
        //
        if (pPrev)
        {
            pPrev->Next(pCurr->Next());
        }
        
        //
        // Delete this item
        //
        delete pCurr;

        //
        // Decrement the item count
        //
        m_nItemCount--;
    }
    void Append( const CSimpleLinkedList &other )
    {
        //
        // Loop through the other list, copying nodes to our list
        //
        for (Iterator i(other);i != other.End();i++)
        {
            Append(*i);
        }
    }

    int Count(void) const
    {
        return m_nItemCount;
    }

    class Iterator;
    friend class Iterator;
    class Iterator
    {
    private:
        CLinkedListNode *m_pCurr;
    public:
        Iterator( CLinkedListNode *pNode )
          : m_pCurr(pNode)
        {
        }
        Iterator( const CSimpleLinkedList &list )
          : m_pCurr(list.m_pHead)
        {
        }
        Iterator(void)
          : m_pCurr(NULL)
        {
        }
        Iterator &Next(void)
        {
            if (m_pCurr)
            {
                m_pCurr = m_pCurr->Next();
            }
            return (*this);
        }
        Iterator &Begin(const CSimpleLinkedList &list)
        {
            m_pCurr = list.m_pHead;
            return (*this);
        }
        Iterator &operator=( const Iterator &other )
        {
            m_pCurr = other.m_pCurr;
            return (*this);
        }
        bool End(void) const
        {
            return(m_pCurr == NULL);
        }
        T &operator*(void)
        {
            return (m_pCurr->Data());
        }
        const T &operator*(void) const
        {
            return (m_pCurr->Data());
        }
        Iterator &operator++(void)
        {
            Next();
            return (*this);
        }
        Iterator operator++(int)
        {
            Iterator tmp(*this);
            Next();
            return (tmp);
        }
        bool operator!=( const Iterator &other ) const
        {
            return (m_pCurr != other.m_pCurr);
        }
        bool operator==( const Iterator &other ) const
        {
            return (m_pCurr == other.m_pCurr);
        }
    };
    Iterator Begin(void) const
    {
        return Iterator(*this);
    }
    Iterator End(void) const
    {
        return Iterator();
    }
    Iterator Begin(void)
    {
        return Iterator(*this);
    }
    Iterator End(void)
    {
        return Iterator();
    }
    Iterator Find( const T &data )
    {
        for (Iterator i=Begin();i != End();++i)
        {
            if (*i == data)
            {
                return i;
            }
        }
        return End();
    }
    Iterator Prepend( const T &data )
    {
        //
        // Allocate a new item to hold this data
        //
        CLinkedListNode *pNewItem = new CLinkedListNode(data);
        if (pNewItem)
        {
            //
            // If the list is empty, point everything at this item
            //
            if (Empty())
            {
                m_pHead = m_pTail = pNewItem;
            }
            
            //
            // Point our next pointer to the current, then point the head at us
            //
            else
            {
                pNewItem->Next(m_pHead);
                m_pHead = pNewItem;
            }
            
            //
            // Increment the item count
            //
            m_nItemCount++;
        }
        
        //
        // Return an iterator that points to the new item
        //
        return Iterator(pNewItem);
    }
    Iterator Append( const T &data )
    {
        //
        // Allocate a new item to hold this data
        //
        CLinkedListNode *pNewItem = new CLinkedListNode(data);
        if (pNewItem)
        {
            //
            // If the list is empty, point everything at this item
            //
            if (Empty())
            {
                m_pHead = m_pTail = pNewItem;
            }

            //
            // Point the tail's next pointer to us, then point the tail at us
            //
            else
            {
                m_pTail->Next(pNewItem);
                m_pTail = pNewItem;
            }
            
            //
            // Increment the item count
            //
            m_nItemCount++;
        }

        //
        // Return an iterator that points to the new item
        //
        return Iterator(pNewItem);
    }
    
    bool Empty(void) const
    {
        return (m_pHead == NULL);
    }
};

template <class T>
class CSimpleStack : public CSimpleLinkedList<T>
{
private:
    CSimpleStack( const CSimpleStack &other );
    CSimpleStack &operator=( const CSimpleStack &other );
public:
    CSimpleStack(void)
    {
    }
    virtual ~CSimpleStack(void)
    {
    }
    void Push( const T &data )
    {
        Prepend(data);
    }
    bool Pop( T &data )
    {
        if (Empty())
            return false;
        Iterator iter(*this);
        data = *iter;
        Remove(*iter);
        return true;
    }
};


template <class T>
class CSimpleQueue : public CSimpleLinkedList<T>
{
private:
    CSimpleQueue( const CSimpleQueue &other );
    CSimpleQueue &operator=( const CSimpleQueue &other );
public:
    CSimpleQueue(void)
    {
    }
    virtual ~CSimpleQueue(void)
    {
    }
    void Enqueue( const T &data )
    {
        Append(data);
    }
    bool Dequeue( T &data )
    {
        if (Empty())
            return false;
        Iterator iter(*this);
        data = *iter;
        Remove(*iter);
        return true;
    }
};

#endif __SIMLIST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simarray.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMARRAY.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Dynamic array template class
 *
 *******************************************************************************/
#ifndef __SIMARRAY_H_INCLUDED
#define __SIMARRAY_H_INCLUDED

template<class T>
class CSimpleDynamicArray
{
private:
    int m_nSize;
    int m_nMaxSize;
    int m_nGrowSize;
    T *m_pArray;
    enum
    {
        eGrowSize = 10  // The number of items to add each time the array grows.
    };
public:
    CSimpleDynamicArray(void)
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(eGrowSize),
        m_pArray(NULL)
    {
    }
    CSimpleDynamicArray( int nInitialSize, int nGrowSize=0 )
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(nGrowSize ? nGrowSize : eGrowSize),
        m_pArray(NULL)
    {
        GrowTo(nInitialSize);
    }
    CSimpleDynamicArray( const CSimpleDynamicArray<T> &other )
      : m_nSize(0),
        m_nMaxSize(0),
        m_nGrowSize(eGrowSize),
        m_pArray(NULL)
    {
        Append(other);
    }
    virtual ~CSimpleDynamicArray(void)
    {
        Destroy();
    }
    CSimpleDynamicArray &operator=( const CSimpleDynamicArray &other )
    {
        if (this != &other)
        {
            Destroy();
            Append(other);
        }
        return *this;
    }
    void Destroy(void)
    {
        if (m_pArray)
        {
            delete[] m_pArray;
            m_pArray = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    void Append( const CSimpleDynamicArray &other )
    {
        if (GrowTo( m_nSize + other.Size() ))
        {
            for (int i=0;i<other.Size();i++)
            {
                Append(other[i]);
            }
        }
    }
    int Append( const T &element )
    {
        if (GrowTo( m_nSize + 1 ))
        {
            m_pArray[m_nSize] = element;
            int nResult = m_nSize;
            m_nSize++;
            return nResult;
        }
        else return -1;
    }
    int Insert( const T &element, int nIndex )
    {
        //
        // Make sure we can accomodate this new item
        //
        if (GrowTo( m_nSize + 1 ))
        {
            //
            // Make sure the item is within the range we've allocated
            //
            if (nIndex >= 0 && nIndex <= m_nSize)
            {
                //
                // Make room for the new item by moving all items above up by one slot
                //
                for (int i=Size();i>nIndex;i--)
                {
                    m_pArray[i] = m_pArray[i-1];
                }

                //
                // Save the new item
                //
                m_pArray[nIndex] = element;

                //
                // We're now one larger
                //
                m_nSize++;

                //
                // Return the index of the slot we used
                //
                return nIndex;
            }
        }

        //
        // Return an error
        //
        return -1;
    }
    void Delete( int nItem )
    {
        if (nItem >= 0 && nItem < m_nSize && m_pArray)
        {
            T *pTmpArray = new T[m_nMaxSize];
            if (pTmpArray)
            {
                T *pSrc, *pTgt;
                pSrc = m_pArray;
                pTgt = pTmpArray;
                for (int i=0;i<m_nSize;i++)
                {
                    if (i != nItem)
                    {
                        *pTgt = *pSrc;
                        pTgt++;
                    }
                    pSrc++;
                }
                delete[] m_pArray;
                m_pArray = pTmpArray;
                m_nSize--;
            }
        }
    }
    bool GrowTo( int nSize )
    {
        //
        // If the array is already large enough, just return true
        //
        if (nSize < m_nMaxSize)
        {
            return true;
        }

        //
        // Save old size, in case we can't allocate a new array
        //
        int nOldMaxSize = m_nMaxSize;

        //
        // Find the correct size to grow to
        //
        while (m_nMaxSize < nSize)
        {
            m_nMaxSize += m_nGrowSize;
        }

        //
        // Allocate the array
        //
        T *pTmpArray = new T[m_nMaxSize];
        if (pTmpArray)
        {
            //
            // Copy the old array over
            //
            for (int i=0;i<m_nSize;i++)
            {
                pTmpArray[i] = m_pArray[i];
            }

            //
            // Delete the old array
            //
            if (m_pArray)
            {
                delete[] m_pArray;
            }

            //
            // Assign the new array to the old one and return true
            //
            m_pArray = pTmpArray;
            return true;
        }
        else
        {
            //
            // If we couldn't allocate the new array, restore the maximum size
            // and return false
            //
            m_nMaxSize = nOldMaxSize;
            return false;
        }
    }
    int Find( const T& element )
    {
        for (int i=0;i<m_nSize;i++)
            if (m_pArray[i] == element)
                return i;
        return -1;
    }
    bool operator==( const CSimpleDynamicArray &other )
    {
        if (Size() != other.Size())
            return false;
        for (int i=0;i<Size();i++)
            if (!(m_pArray[i] == other[i]))
                return false;
        return true;
    }
    bool Contains( const T& element )     { return(Find(element) >= 0);}
    void Size( int nSize )                { m_nSize = nSize;}
    void MaxSize( int nMaxSize )          { m_nMaxSize = nMaxSize;}
    void GrowSize( int nGrowSize )        { m_nGrowSize = nGrowSize;}
    int Size(void) const                  { return m_nSize;}
    int MaxSize(void) const               { return m_nMaxSize;}
    int GrowSize(void) const              { return m_nGrowSize;}
    const T *Array(void) const            { return m_pArray;}
    const T &operator[](int nIndex) const { return m_pArray[nIndex];}
    T &operator[](int nIndex)             { return m_pArray[nIndex];}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\psutil.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PSUTIL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/
#ifndef __PSUTIL_H_INCLUDED
#define __PSUTIL_H_INCLUDED

#include <windows.h>
#include <simstr.h>

#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif

#if !defined(SETFormatEtc)
#define SETFormatEtc(fe, cf, asp, td, med, li)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=asp;\
    (fe).ptd=td;\
    (fe).tymed=med;\
    (fe).lindex=li;\
    };
#endif

#if !defined(SETDefFormatEtc)
#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };
#endif


namespace PrintScanUtil
{
    template <class T>
    T Absolute( const T &m )
    {
        return((m < 0) ? -m : m);
    }

    template <class T>
    T Max( const T &m, const T &n )
    {
        return((m > n) ? m : n);
    }

    template <class T>
    T Min( const T &m, const T &n )
    {
        return((m < n) ? m : n);
    }

    template <class T>
    T GetMinimum( const T& nDesired, const T& nMin, const T& nStep )
    {
        T nResult = Max<T>( nMin, nDesired );
        if (nStep)
            nResult = nResult + (nResult - nMin) % nStep;
        return nResult;
    }

    inline bool ScreenToClient( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ClientToScreen( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( hwnd, NULL, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return ScreenToClient( hwnd, &rc );
    }

    inline bool ClientToScreen( HWND hwnd, RECT &rc )
    {
        return ClientToScreen( hwnd, &rc );
    }

    inline int RectWidth( const RECT &rc )
    {
        return (rc.right - rc.left);
    }

    inline int RectHeight( const RECT &rc )
    {
        return (rc.bottom - rc.top);
    }

    inline LONGLONG PowerOfTwo( int nCount )
    {
        return(LONGLONG)1 << nCount;
    }

    inline int MulDivNoRound( int nNumber, int nNumerator, int nDenominator )
    {
        return(int)(((LONGLONG)nNumber * nNumerator) / nDenominator);
    }

    inline SIZE ScalePreserveAspectRatio( int nAvailX, int nAvailY, int nItemX, int nItemY )
    {
        SIZE sizeResult = { nAvailX, nAvailY };
        if (nItemX && nItemY)
        {
            //
            // Width is greater than height.  X is the constraining factor
            //
            if (nAvailY*nItemX > nAvailX*nItemY)
            {
                sizeResult.cy = MulDivNoRound(nItemY,nAvailX,nItemX);
            }

            //
            // Height is greater than width.  Y is the constraining factor
            //
            else
            {
                sizeResult.cx = MulDivNoRound(nItemX,nAvailY,nItemY);
            }
        }
        return sizeResult;
    }

    inline bool GetBitmapSize( HBITMAP hBitmap, SIZE &sizeBitmap )
    {
        bool bResult = false;
        BITMAP Bitmap = {0};
        if (GetObject(hBitmap,sizeof(Bitmap),&Bitmap))
        {
            sizeBitmap.cx = Bitmap.bmWidth;
            sizeBitmap.cy = Bitmap.bmHeight;
            bResult = true;
        }

        return bResult;
    }

    //
    // Get the size of an icon
    //
    inline bool GetIconSize( HICON hIcon, SIZE &sizeIcon )
    {
        //
        // Assume failure
        //
        bool bResult = false;

        //
        // Get the icon information
        //
        ICONINFO IconInfo = {0};
        if (GetIconInfo( hIcon, &IconInfo ))
        {
            //
            // Get one of the bitmaps
            //
            BITMAP bm;
            if (GetObject( IconInfo.hbmColor, sizeof(bm), &bm ))
            {
                //
                // Save the size of the icon
                //
                sizeIcon.cx = bm.bmWidth;
                sizeIcon.cy = bm.bmHeight;

                //
                // Everything worked
                //
                bResult = true;
            }

            //
            // Free the bitmaps
            //
            if (IconInfo.hbmMask)
            {
                DeleteObject(IconInfo.hbmMask);
            }
            if (IconInfo.hbmColor)
            {
                DeleteObject(IconInfo.hbmColor);
            }
        }

        return bResult;
    }

    inline void Enable( HWND hWnd, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            if (!IsWindowEnabled(hWnd) && bEnable)
            {
                ::EnableWindow( hWnd, TRUE );
            }
            else if (IsWindowEnabled(hWnd) && !bEnable)
            {
                ::EnableWindow( hWnd, FALSE );
            }

        }
    }

    inline void Enable( HWND hWnd, int nChildId, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            Enable(GetDlgItem(hWnd,nChildId),bEnable);
        }
    }

    inline int CalculateImageListColorDepth(void)
    {
        //
        // Let's assume worst case
        //
        int nColorDepth = 4;
        HDC hDC = GetDC( NULL );
        if (hDC)
        {
            //
            // Calculate the color depth for the display
            //
            nColorDepth = GetDeviceCaps( hDC, BITSPIXEL ) * GetDeviceCaps( hDC, PLANES );
            ReleaseDC( NULL, hDC );
        }

        //
        // Get the correct image list color depth
        //
        int nImageListColorDepth;
        switch (nColorDepth)
        {
        case 4:
        case 8:
            nImageListColorDepth = ILC_COLOR4;
            break;

        case 16:
            nImageListColorDepth = ILC_COLOR16;
            break;

        case 24:
            nImageListColorDepth = ILC_COLOR24;
            break;

        case 32:
            nImageListColorDepth = ILC_COLOR32;
            break;
        
        default:
            nImageListColorDepth = ILC_COLOR;
        }

        return nImageListColorDepth;
    }
}


#endif // __PSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\gphelper.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GPHELPER.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/11/1999
 *
 *  DESCRIPTION: Encapsulation of common GDI plus operationss
 *
 *******************************************************************************/
#ifndef __GPHELPER_H_INCLUDED
#define __GPHELPER_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <gdiplus.h>
#include <simarray.h>


#include <gdiplusinit.h>

class CGdiPlusInit
{
    ULONG_PTR m_pGdiplusToken;
public:
    CGdiPlusInit();
    ~CGdiPlusInit();
};

class CGdiPlusHelper
{
private:
    CGdiPlusInit              m_Init;
    Gdiplus::ImageCodecInfo  *m_pImageEncoderInfo;
    UINT                      m_nImageEncoderCount;

    Gdiplus::ImageCodecInfo  *m_pImageDecoderInfo;
    UINT                      m_nImageDecoderCount;

private:
    CGdiPlusHelper( const CGdiPlusHelper & );
    CGdiPlusHelper &operator=( const CGdiPlusHelper & );

public:
    CGdiPlusHelper(void);
    ~CGdiPlusHelper(void);

protected:
    HRESULT Initialize(void);
    static HRESULT ConstructCodecExtensionSearchStrings( CSimpleString &strExtensions, Gdiplus::ImageCodecInfo *pImageCodecInfo, UINT nImageCodecCount );
    void Destroy(void);

public:
    bool IsValid(void) const;

    HRESULT ConstructDecoderExtensionSearchStrings( CSimpleString &strExtensions );
    HRESULT ConstructEncoderExtensionSearchStrings( CSimpleString &strExtensions );
    HRESULT GetClsidOfEncoder( const GUID &guidFormatId, CLSID &clsidFormat ) const;
    HRESULT GetClsidOfDecoder( const GUID &guidFormatId, CLSID &clsidFormat ) const;
    HRESULT Convert( LPCWSTR pszInputFilename, LPCWSTR pszOutputFilename, const CLSID &guidOutputFormat ) const;
    HRESULT Rotate( LPCWSTR pszInputFilename, LPCWSTR pszOutputFilename, int nRotationAngle, const CLSID &guidOutputFormat ) const;
    HRESULT Rotate( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, int nRotation ) const;
    HRESULT LoadAndScale( HBITMAP &hTargetBitmap, LPCTSTR pszFilename, UINT nMaxWidth=0, UINT nMaxHeight=0, bool bStretchSmallImages=false );
    HRESULT LoadAndScale( HBITMAP &hTargetBitmap, IStream *pStream, UINT nMaxWidth=0, UINT nMaxHeight=0, bool bStretchSmallImages=false );
    HRESULT SaveMultipleImagesAsMultiPage( const CSimpleDynamicArray<CSimpleStringWide> &Filenames, const CSimpleStringWide &strFilename, const CLSID &guidOutputFormat );
    HRESULT SetBrightnessAndContrast( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, BYTE nBrightness, BYTE nContrast );
    HRESULT SetThreshold( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, BYTE nThreshold );

    static Gdiplus::EncoderParameters *AppendEncoderParameter( Gdiplus::EncoderParameters *pEncoderParameters, const GUID &guidProp, ULONG nType, PVOID pVoid );
    
    static inline GDISTATUS_TO_HRESULT(Gdiplus::Status status)
    {
        //
        // Default to turning GDI+ errors into generic failures
        // 
        HRESULT hr = E_FAIL;
    
        switch( status )
        {
            case Gdiplus::Ok:
                hr = S_OK;
                break;
    
            case Gdiplus::InvalidParameter:
                hr = E_INVALIDARG;
                break;
    
            case Gdiplus::OutOfMemory:
                hr = E_OUTOFMEMORY;
                break;
    
            case Gdiplus::InsufficientBuffer:
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                break;
    
            case Gdiplus::Aborted:
                hr = E_ABORT;
                break;
    
            case Gdiplus::ObjectBusy:
                hr = E_PENDING;
                break;
    
            case Gdiplus::FileNotFound:
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                break;
    
            case Gdiplus::AccessDenied:
                hr = E_ACCESSDENIED;
                break;
    
            case Gdiplus::UnknownImageFormat:
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PIXEL_FORMAT);
                break;
    
            case Gdiplus::NotImplemented:
                hr = E_NOTIMPL;
                break;
    
            case Gdiplus::Win32Error:
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
    
            case Gdiplus::ValueOverflow:
            case Gdiplus::FontFamilyNotFound:
            case Gdiplus::FontStyleNotFound:
            case Gdiplus::NotTrueTypeFont:
            case Gdiplus::UnsupportedGdiplusVersion:
            case Gdiplus::GdiplusNotInitialized:
            case Gdiplus::WrongState:
                break;
        }
        return hr;
    }
};


class CImageFileFormatVerifier
{
private:
    //
    // Internal class used to store the file signatures
    //
    class CImageFileFormatVerifierItem
    {
    private:
        PBYTE  m_pSignature;
        PBYTE  m_pMask;
        int    m_nLength;
        GUID   m_guidFormat;
        CLSID  m_clsidDecoder;

    public:
        //
        // Constructors, assignment operator and destructor
        //
        CImageFileFormatVerifierItem(void);
        CImageFileFormatVerifierItem( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &guidDecoder );
        CImageFileFormatVerifierItem( const CImageFileFormatVerifierItem &other );
        CImageFileFormatVerifierItem &operator=( const CImageFileFormatVerifierItem &other );
        CImageFileFormatVerifierItem &Assign( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &Format, const CLSID &guidDecoder );
        ~CImageFileFormatVerifierItem(void);

    protected:
        void Destroy(void);

    public:
        //
        // Accessor functions
        //
        PBYTE Signature(void) const;
        PBYTE Mask(void) const;
        int Length(void) const;
        GUID Format(void) const;
        CLSID Decoder(void) const;

        //
        // Does this stream of bytes match this format?
        //
        bool Match( PBYTE pBytes, int nLen ) const;
    };


private:
    CSimpleDynamicArray<CImageFileFormatVerifierItem> m_FileFormatVerifierList;
    int   m_nMaxSignatureLength;
    PBYTE m_pSignatureBuffer;

private:
    CImageFileFormatVerifier( const CImageFileFormatVerifier & );
    CImageFileFormatVerifier &operator=( const CImageFileFormatVerifier & );

public:
    CImageFileFormatVerifier(void);
    ~CImageFileFormatVerifier(void);
    void Destroy(void);
    bool IsValid(void) const;
    bool IsImageFile( LPCTSTR pszFilename );
    bool IsSupportedImageFromStream( IStream * pStream, GUID * pGuidOfFormat = NULL );
    GUID GetImageType( IStream * pStream );

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\tmplutil.inl ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       tmplutil.inl
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        10-Mar-2000
 *
 *  DESCRIPTION: Placeholder for common utility templates & functions (Impl.)
 *
 *****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\tmplutil.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       tmplutil.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        10-Mar-2000
 *
 *  DESCRIPTION: Placeholder for common utility templates & functions
 *
 *****************************************************************************/

#ifndef _TMPLUTIL_H
#define _TMPLUTIL_H

////////////////////////////////////////////////////////////////////////////////
// ****************************  INCLUDE ALL **************************** 
//
#include "gensph.h"         // generic smart pointers & handles
#include "comutils.h"       // COM utility classes & templates
#include "w32utils.h"       // Win32 utility classes & templates
#include "cntutils.h"       // Containers & Algorithms utility templates

// max path limits
#define SERVER_MAX_PATH     (INTERNET_MAX_HOST_NAME_LENGTH + 1 + 2)
#define PRINTER_MAX_PATH    (SERVER_MAX_PATH + MAX_PATH + 1)

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)  // CRT mem debugging
////////////////////////////////////////////////////
// CRT debug flags - infowise
//
// _CRTDBG_ALLOC_MEM_DF
// _CRTDBG_DELAY_FREE_MEM_DF
// _CRTDBG_CHECK_ALWAYS_DF
// _CRTDBG_CHECK_CRT_DF
// _CRTDBG_LEAK_CHECK_DF
//

#define  CRT_DEBUG_SET_FLAG(a)              _CrtSetDbgFlag( (a) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))
#define  CRT_DEBUG_CLR_FLAG(a)              _CrtSetDbgFlag(~(a) & _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))

// sends all reports to stdout
#define  CRT_DEBUG_REPORT_TO_STDOUT()                   \
   _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);     \
   _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);   \
   _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);    \
   _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);  \
   _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);   \
   _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT)  \

// redefine new to be debug new
#undef  new 
#define new new(_NORMAL_BLOCK, __FILE__, __LINE__)

#else
#define  CRT_DEBUG_SET_FLAG(a)              ((void) 0)
#define  CRT_DEBUG_CLR_FLAG(a)              ((void) 0)
#define  CRT_DEBUG_REPORT_TO_STDOUT()       ((void) 0)
#endif

////////////////////////////////////////////////
// shell related services
namespace ShellServices
{
    // creates a PIDL to a printer in the local printers folder.
    // args:
    //  [in]    hwnd - window handle (in case we need to show UI - message box)
    //  [in]    pszPrinterName - full printer name.
    //  [out]   ppLocalPrnFolder - the printers folder (optional - may be NULL)
    //  [out]   ppidlPrinter - the PIDL of the printer pointed by pszPrinterName (optional - may be NULL) 
    //
    // remarks:
    //  pszPrinterName should be fully qualified printer name, i.e. if printer connection it should be
    //  like "\\server\printer", if local printer just the printer name.
    //  
    // returns:
    //  S_OK on success, or OLE2 error otherwise
    HRESULT CreatePrinterPIDL(HWND hwnd, LPCTSTR pszPrinterName, IShellFolder **ppLocalPrnFolder, LPITEMIDLIST *ppidlPrinter);

    // loads a popup menu
    HMENU LoadPopupMenu(HINSTANCE hInstance, UINT id, UINT uSubOffset = 0);

    // initializes enum printer's autocomplete
    HRESULT InitPrintersAutoComplete(HWND hwndEdit);

    // helpers for the Enum* idioms
    enum { ENUM_MAX_RETRY = 5 };
    HRESULT EnumPrintersWrap(DWORD dwFlags, DWORD dwLevel, LPCTSTR pszName, BYTE **ppBuffer, DWORD *pcReturned);
    HRESULT GetJobWrap(HANDLE hPrinter, DWORD JobId, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned);

    // enumerates the shared resources on a server, for more info see SDK for NetShareEnum API.
    HRESULT NetAPI_EnumShares(LPCTSTR pszServer, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned);
}

// utility functions
HRESULT LoadXMLDOMDoc(LPCTSTR pszURL, IXMLDOMDocument **ppXMLDoc);
HRESULT CreateStreamFromURL(LPCTSTR pszURL, IStream **pps);
HRESULT CreateStreamFromResource(LPCTSTR pszModule, LPCTSTR pszResType, LPCTSTR pszResName, IStream **pps);
HRESULT GetCurrentThreadLastPopup(HWND *phwnd);
HRESULT PrinterSplitFullName(LPCTSTR pszFullName, TCHAR szBuffer[], int nMaxLength, LPCTSTR *ppszServer,LPCTSTR *ppszPrinter);

// generate proper HRESULT from Win32 last error
inline HRESULT CreateHRFromWin32()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

LONG COMObjects_GetCount();

#ifdef _GDIPLUS_H
// gdiplus utility functions
HRESULT Gdiplus2HRESULT(Gdiplus::Status status);
HRESULT LoadAndScaleBmp(LPCTSTR pszURL, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp);
HRESULT LoadAndScaleBmp(IStream *pStream, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp);
#endif // endif _GDIPLUS_H

// include the implementation of the template classes here
#include "tmplutil.inl"

#endif // endif _TMPLUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\fusutils.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       fusutils.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "fusutils.h"
#include "coredefs.h"

// open C code brace
#ifdef __cplusplus
extern "C" {
#endif

//
// Win32Error2HRESULT: converts Win32 error to HRESULT
// 
inline HRESULT Win32Error2HRESULT(DWORD dwError = GetLastError())
{
    return (ERROR_SUCCESS == dwError) ? E_FAIL : HRESULT_FROM_WIN32(dwError);
}

//
// SearchExecutableWrap: HRESULT wrapper around SearchPath
//
// searches for an executable and returns its full path in lpBuffer.
// returns E_INVALIDARG if the executable cannot be found and 
// Win32Error2HRESULT(ERROR_INSUFFICIENT_BUFFER) if the
// passed in buffer is too small to hold the full path.
//
inline HRESULT SearchExecutableWrap(LPCTSTR lpszExecutableName, UINT nBufferLength, LPTSTR lpBuffer, LPTSTR *lppFilePart)
{
    DWORD cch = SearchPath(NULL, lpszExecutableName, NULL, nBufferLength, lpBuffer, lppFilePart);

    return (0 == cch) ? Win32Error2HRESULT() :
        (cch >= nBufferLength) ? Win32Error2HRESULT(ERROR_INSUFFICIENT_BUFFER) : S_OK;
}

//
// GetExecutableNameWrap: HRESULT wrapper around GetModuleFileName
//
// 
// returns the full path of the current process executable (EXE)
// or Win32Error2HRESULT(ERROR_INSUFFICIENT_BUFFER) if the
// passed in buffer is too small to hold the full path.
//
inline HRESULT GetExecutableNameWrap(HMODULE hModule, UINT nBufferLength, LPTSTR lpBuffer)
{
    DWORD cch = GetModuleFileName(hModule, lpBuffer, nBufferLength);

    return (0 == cch) ? Win32Error2HRESULT() :
        (cch >= nBufferLength) ? Win32Error2HRESULT(ERROR_INSUFFICIENT_BUFFER) : S_OK;
}

//
// FileExists: checks if the passed in file name exists.
// 
inline HRESULT FileExists(LPCTSTR pszFileName, BOOL *pbExists)
{
    HRESULT hr = E_INVALIDARG;
    if (pszFileName && pbExists)
    {
        hr = S_OK;
        *pbExists = FALSE;

        WIN32_FIND_DATA findFileData;
        HANDLE hFind = FindFirstFile(pszFileName, &findFileData);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            *pbExists = TRUE;
            FindClose(hFind);
        }
    }
    return hr;
}

static TCHAR g_szManifestExt[] = TEXT(".manifest");

//
// CreateActivationContextFromExecutableEx:
//
// check the passed in executable name for a manifest (if any)
// and creates an activation context from it.
//
HRESULT CreateActivationContextFromExecutableEx(LPCTSTR lpszExecutableName, UINT uResourceID, BOOL bMakeProcessDefault, HANDLE *phActCtx)
{
    HRESULT hr = E_INVALIDARG;

    if (phActCtx)
    {
        TCHAR szModule[MAX_PATH];
        TCHAR szManifest[MAX_PATH];
        BOOL bManifestFileFound = FALSE;

        // let's try to figure out whether this executable has a manifest file or not
        if (lpszExecutableName)
        {
            // search the passed in name in the path
            hr = SearchExecutableWrap(lpszExecutableName, ARRAYSIZE(szModule), szModule, NULL);
        }
        else
        {
            // if lpszExecutableName is NULL we assume the current module name
            hr = GetExecutableNameWrap(GetModuleHandle(NULL), ARRAYSIZE(szModule), szModule);
        }

        if (SUCCEEDED(hr))
        {
            if ((lstrlen(szModule) + lstrlen(g_szManifestExt)) < ARRAYSIZE(szManifest))
            {
                // create the manifest file name by appending ".manifest" to the executable name
                lstrcpy(szManifest, szModule);
                lstrcat(szManifest, g_szManifestExt);
            }
            else
            {
                // buffer is too small to hold the manifest file name
                hr = Win32Error2HRESULT(ERROR_BUFFER_OVERFLOW);
            }

            if (SUCCEEDED(hr))
            {
                BOOL bFileExists = FALSE;
                hr = FileExists(szManifest, &bFileExists);

                if (SUCCEEDED(hr) && bFileExists)
                {
                    // an external manifest file found!
                    bManifestFileFound = TRUE;
                }
            }
        }

        // now let's try to create an activation context 
        ACTCTX act;
        ::ZeroMemory(&act, sizeof(act));
        act.cbSize = sizeof(act);

        if (bManifestFileFound)
        {
            // the executable has an external manifest file
            act.lpSource = szManifest;
        }
        else
        {
            // if the executable doesn't have an external  manifest file, 
            // so we assume that the it may have a manifest in its resources.
            act.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
            act.lpResourceName = MAKEINTRESOURCE(uResourceID);
            act.lpSource = szModule;
        }

        if (bMakeProcessDefault)
        {
            // the caller has requested to set this activation context as 
            // sefault for the current process. watch out!
            act.dwFlags |= ACTCTX_FLAG_SET_PROCESS_DEFAULT;
        }

        // now let's ask kernel32 to create an activation context
        HANDLE hActCtx = CreateActCtx(&act);

        if (INVALID_HANDLE_VALUE == hActCtx)
        {
            // something failed. create proper HRESULT to return.
            hr = Win32Error2HRESULT();
        }
        else
        {
            // wow, success!
            *phActCtx = hActCtx;
            hr = S_OK;
        }
    }

    return hr;
}

//
// CreateActivationContextFromExecutable:
//
// check the passed in executable name for a manifest (if any)
// and creates an activation context from it using the defaults
// (i.e. bMakeProcessDefault=FALSE & uResourceID=123)
//
HRESULT CreateActivationContextFromExecutable(LPCTSTR lpszExecutableName, HANDLE *phActCtx)
{
    return CreateActivationContextFromExecutableEx(lpszExecutableName, 123, FALSE, phActCtx);
}

// close C code brace
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simstr.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SIMSTR.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        5/12/1998
*
*  DESCRIPTION: Simple string classes
*
*******************************************************************************/
#ifndef _SIMSTR_H_INCLUDED
#define _SIMSTR_H_INCLUDED

/*
 * Simple string class.
 *
 * Template class:
 *   CSimpleStringBase<T>
 * Implementations:
 *   CSimpleStringBase<wchar_t> CSimpleStringWide
 *   CSimpleStringBase<char> CSimpleStringAnsi
 *   CSimpleString = CSimpleString[Ansi|Wide] depending on UNICODE macro
 * Inline functions:
 *   CSimpleStringAnsi CSimpleStringConvert::AnsiString(T n)
 *   CSimpleStringWide CSimpleStringConvert::WideString(T n)
 *   CSimpleString     CSimpleStringConvert::NaturalString(T n)
 * Macros:
 *   IS_CHAR(T)
 *   IS_WCHAR(T)
 */

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <tchar.h>

#define IS_CHAR(x)     (sizeof(x)==sizeof(char))
#define IS_WCHAR(x)    (sizeof(x)==sizeof(wchar_t))

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x) / sizeof(x[0]))
#endif

template <class T>
class CSimpleStringBase
{
private:
    enum
    {
        m_nDefaultGranularity  = 16,   // Default number of extra characters to allocate when we have to grow
        m_nMaxLoadStringBuffer = 1024, // Maximum length of .RC string
        m_nMaxAutoDataLength   = 128   // Length of non-dynamically allocated string
    };

private:
    T   *m_pstrData;
    T    m_pstrAutoData[m_nMaxAutoDataLength];
    UINT m_nMaxSize;
    UINT m_nGranularity;

private:
    static int Min( int a, int b )
    {
        return((a < b) ? a : b);
    }

public:
    // Replacements (in some cases just wrappers) for strlen, strcpy, ...
    static inline T   *GenericCopy( T *pstrTgtStr, const T *pstrSrcStr );
    static inline T   *GenericCopyLength( T *pstrTgtStr, const T *pstrSrcStr, UINT nSize );
    static inline UINT GenericLength( const T *pstrStr );
    static inline T   *GenericConcatenate( T *pstrTgtStr, const T *pstrSrcStr );
    static inline int  GenericCompare( const T *pstrTgtStr, const T *pstrSrcStr );
    static inline int  GenericCompareNoCase( const T *pstrStrA, const T *pstrStrB );
    static inline int  GenericCompareLength( const T *pstrTgtStr, const T *pstrSrcStr, UINT nLength );
    static inline T   *GenericCharNext( const T *pszStr );

public:
    // Constructors and destructor
    CSimpleStringBase( void );
    CSimpleStringBase( const CSimpleStringBase & );
    CSimpleStringBase( const T *szStr );
    CSimpleStringBase( T ch );
    CSimpleStringBase( UINT nResId, HMODULE hModule );
    virtual ~CSimpleStringBase(void);

    bool EnsureLength( UINT nMaxSize );
    UINT Length(void) const;
    void Concat( const CSimpleStringBase &other );
    int Resize(void);
    UINT Truncate( UINT nLen );
    bool Assign( const T *szStr );
    bool Assign( const CSimpleStringBase & );
    void DeleteStorage(void);
    static inline T *CreateStorage( UINT nCount );
    void Destroy(void);

    CSimpleStringBase &Format( const T *strFmt, ... );
    CSimpleStringBase &Format( int nResId, HINSTANCE hInst, ... );

    // Handy Win32 wrappers
    CSimpleStringBase &GetWindowText( HWND hWnd );
    bool SetWindowText( HWND hWnd );
    bool LoadString( UINT nResId, HMODULE hModule );
    bool Load( HKEY hRegKey, const T *pszValueName, const T *pszDefault=NULL );
    bool Store( HKEY hRegKey, const T *pszValueName, DWORD nType = REG_SZ );
    void SetAt( UINT nIndex, T chValue );
    CSimpleStringBase &operator=( const CSimpleStringBase &other );
    CSimpleStringBase &operator=( const T *other );
    CSimpleStringBase &operator+=( const CSimpleStringBase &other );
    CSimpleStringBase operator+( const CSimpleStringBase &other ) const;
    T &operator[](int index);
    const T &operator[](int index) const;

    CSimpleStringBase ToUpper(void) const;
    CSimpleStringBase ToLower(void) const;

    CSimpleStringBase &MakeUpper(void);
    CSimpleStringBase &MakeLower(void);
    CSimpleStringBase &TrimRight(void);
    CSimpleStringBase &TrimLeft(void);
    CSimpleStringBase &Trim(void);
    CSimpleStringBase &Reverse(void);

    int Find( T cChar ) const;
    int Find( const CSimpleStringBase &other, UINT nStart=0 ) const;
    int ReverseFind( T cChar ) const;
    int ReverseFind( const CSimpleStringBase &other ) const;

    CSimpleStringBase SubStr( int nStart, int nCount=-1 ) const;
    int CompareNoCase( const CSimpleStringBase &other, int nLength=-1 ) const;
    int Compare( const CSimpleStringBase &other, int nLength=-1 ) const;
    bool MatchLastCharacter( T cChar ) const;

    // Some useful inlines
    UINT Granularity( UINT nGranularity )                       { if (nGranularity>0) m_nGranularity = nGranularity;return m_nGranularity;}
    UINT Granularity( void )                          const     { return m_nGranularity;}
    CSimpleStringBase Left( int nCount )              const     { return SubStr( 0, nCount );}
    CSimpleStringBase Right( int nCount )             const     { return SubStr( max(0,(int)Length()-nCount), -1 );}
    bool operator<( const CSimpleStringBase &other )  const     { return(Compare(other) <  0);}
    bool operator<=( const CSimpleStringBase &other ) const     { return(Compare(other) <= 0);}
    bool operator==( const CSimpleStringBase &other ) const     { return(Compare(other) == 0);}
    bool operator!=( const CSimpleStringBase &other ) const     { return(Compare(other) != 0);}
    bool operator>=( const CSimpleStringBase &other ) const     { return(Compare(other) >= 0);}
    bool operator>( const CSimpleStringBase &other )  const     { return(Compare(other) >  0);}
    const T *String(void)                             const     { return m_pstrData;}
    operator const T *(void)                          const     { return String();}
    bool IsValid(void)                                const     { return(NULL != m_pstrData);}
};


template <class T>
inline T *CSimpleStringBase<T>::GenericCopy( T *pszDest, const T *pszSource )
{
    T *pCurr = pszDest;
    while (*pCurr++ = *pszSource++)
        ;
    return(pszDest);
}

template <class T>
inline T *CSimpleStringBase<T>::GenericCharNext( const T *pszStr )
{
    if (IS_CHAR(*pszStr))
        return (T*)CharNextA((LPCSTR)pszStr);
    else if (!*pszStr)
        return (T*)pszStr;
    else return (T*)((LPWSTR)pszStr + 1);
}

template <class T>
inline T *CSimpleStringBase<T>::GenericCopyLength( T *pszDest, const T *source, UINT count )
{
    T *start = pszDest;
    while (count && (*pszDest++ = *source++))
        count--;
    if (count)
        while (--count)
            *pszDest++ = 0;
    return(start);
}

template <class T>
inline UINT CSimpleStringBase<T>::GenericLength( const T *pszString )
{
    const T *eos = pszString;

    while (*eos++)
        ;
    return((UINT)(eos - pszString - 1));
}

template <class T>
inline T*CSimpleStringBase<T>::GenericConcatenate( T *pszDest, const T *pszSource )
{
    T *pCurr = pszDest;

    while (*pCurr)
        pCurr++;

    while (*pCurr++ = *pszSource++)
        ;

    return( pszDest );
}

template <class T>
inline int CSimpleStringBase<T>::GenericCompare( const T *pszSource, const T *pszDest )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    int nRes = IS_CHAR(*pszSource) ?
               CompareStringA( LOCALE_USER_DEFAULT, 0, (LPCSTR)pszSource, -1, (LPCSTR)pszDest, -1 ) :
               CompareStringW( LOCALE_USER_DEFAULT, 0, (LPCWSTR)pszSource, -1, (LPCWSTR)pszDest, -1 );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}


template <class T>
inline int CSimpleStringBase<T>::GenericCompareNoCase( const T *pszSource, const T *pszDest )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    int nRes = IS_CHAR(*pszSource) ?
               CompareStringA( LOCALE_USER_DEFAULT, NORM_IGNORECASE, (LPCSTR)pszSource, -1, (LPCSTR)pszDest, -1 ) :
               CompareStringW( LOCALE_USER_DEFAULT, NORM_IGNORECASE, (LPCWSTR)pszSource, -1, (LPCWSTR)pszDest, -1 );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}

template <class T>
inline int CSimpleStringBase<T>::GenericCompareLength( const T *pszStringA, const T *pszStringB, UINT nLength )
{
#if defined(DBG) && !defined(UNICODE) && !defined(_UNICODE)
    if (sizeof(T) == sizeof(wchar_t))
    {
        OutputDebugString(TEXT("CompareStringW is not supported under win9x, so this call is going to fail!"));
    }
#endif
    if (!nLength)
        return(0);
    int nRes = IS_CHAR(*pszStringA) ?
               CompareStringA( LOCALE_USER_DEFAULT, 0, (LPCSTR)pszStringA, Min(nLength,CSimpleStringBase<CHAR>::GenericLength((LPCSTR)pszStringA)), (LPCSTR)pszStringB, Min(nLength,CSimpleStringBase<CHAR>::GenericLength((LPCSTR)pszStringB)) ) :
               CompareStringW( LOCALE_USER_DEFAULT, 0, (LPWSTR)pszStringA, Min(nLength,CSimpleStringBase<WCHAR>::GenericLength((LPCWSTR)pszStringA)), (LPCWSTR)pszStringB, Min(nLength,CSimpleStringBase<WCHAR>::GenericLength((LPCWSTR)pszStringB)) );
    switch (nRes)
    {
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    default:
        return 0;
    }
}

template <class T>
bool CSimpleStringBase<T>::EnsureLength( UINT nMaxSize )
{
    //
    // If the string is already long enough, just return true
    //
    if (m_nMaxSize >= nMaxSize)
    {
        return true;
    }

    //
    // Save the old max size
    //
    UINT nOldMaxSize = m_nMaxSize;

    //
    // Get the new size
    //
    UINT nNewMaxSize = nMaxSize + m_nGranularity;

    //
    // Allocate the new buffer
    //
    T *pszTmp = CreateStorage(nNewMaxSize);

    //
    // Make sure the allocation succeded
    //
    if (pszTmp)
    {
        //
        // If we have an existing string, copy it and delete it
        //
        if (m_pstrData)
        {
            GenericCopy(pszTmp,m_pstrData);
            DeleteStorage();
        }

        //
        // Save the new max size
        //
        m_nMaxSize = nNewMaxSize;
        
        //
        // Save this new string
        //
        m_pstrData = pszTmp;

        //
        // Return success
        //
        return true;
    }
    
    //
    // Couldn't allocate memory
    //
    return false;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::GetWindowText( HWND hWnd )
{
    Destroy();
    // Assume it didn't work
    bool bSuccess = false;
    int nLen = ::GetWindowTextLength(hWnd);
    if (nLen)
    {
        if (EnsureLength(nLen+1))
        {
            if (::GetWindowText( hWnd, m_pstrData, (nLen+1) ))
            {
                bSuccess = true;
            }
        }
    }
    if (!bSuccess)
        Destroy();
    return *this;
}

template <class T>
bool CSimpleStringBase<T>::SetWindowText( HWND hWnd )
{
    return(::SetWindowText( hWnd, String() ) != FALSE);
}

template <class T>
UINT CSimpleStringBase<T>::Truncate( UINT nLen )
{
    if (Length() < nLen)
        return Length();
    if (!nLen)
        return 0;
    m_pstrData[nLen-1] = 0;
    Resize();
    return Length();
}

template <class T>
int CSimpleStringBase<T>::Resize(void)
{
    m_nMaxSize = m_pstrData ? GenericLength(m_pstrData) : 0;
    ++m_nMaxSize;
    T *pszTmp = CreateStorage(m_nMaxSize);
    if (pszTmp)
    {
        if (m_pstrData)
        {
            GenericCopy(pszTmp,m_pstrData);
            DeleteStorage();
        }
        else *pszTmp = 0;
        m_pstrData = pszTmp;
    }
    return Length();
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase(void)
: m_pstrData(m_pstrAutoData),m_nMaxSize(ARRAYSIZE(m_pstrAutoData)),m_nGranularity(m_nDefaultGranularity)
{
    m_pstrAutoData[0] = 0;
    T szTmp[1] = { 0};
    Assign(szTmp);
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( const CSimpleStringBase &other )
: m_pstrData(m_pstrAutoData),m_nMaxSize(ARRAYSIZE(m_pstrAutoData)),m_nGranularity(m_nDefaultGranularity)
{
    m_pstrAutoData[0] = 0;
    Assign(other.String());
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( const T *szStr )
: m_pstrData(m_pstrAutoData),m_nMaxSize(ARRAYSIZE(m_pstrAutoData)),m_nGranularity(m_nDefaultGranularity)
{
    m_pstrAutoData[0] = 0;
    Assign(szStr);
}

template <class T>
CSimpleStringBase<T>::CSimpleStringBase( T ch )
: m_pstrData(m_pstrAutoData),m_nMaxSize(ARRAYSIZE(m_pstrAutoData)),m_nGranularity(m_nDefaultGranularity)
{
    m_pstrAutoData[0] = 0;
    T szTmp[2];
    szTmp[0] = ch;
    szTmp[1] = 0;
    Assign(szTmp);
}


template <class T>
CSimpleStringBase<T>::CSimpleStringBase( UINT nResId, HMODULE hModule )
: m_pstrData(m_pstrAutoData),m_nMaxSize(ARRAYSIZE(m_pstrAutoData)),m_nGranularity(m_nDefaultGranularity)
{
    m_pstrAutoData[0] = 0;
    LoadString( nResId, hModule );
}


template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Format( const T *strFmt, ... )
{
    T szTmp[1024];
    va_list arglist;

    va_start(arglist, strFmt);
    int nRet = IS_CHAR(*m_pstrData) ?
               _vsnprintf((LPSTR)szTmp, ARRAYSIZE(szTmp), (LPCSTR)strFmt, arglist) :
               _vsnwprintf((LPWSTR)szTmp, ARRAYSIZE(szTmp), (LPCWSTR)strFmt, arglist);
    va_end(arglist);
    Assign(szTmp);
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Format( int nResId, HINSTANCE hInst, ... )
{
    CSimpleStringBase<T> strFmt;
    va_list arglist;
    if (strFmt.LoadString(nResId,hInst))
    {
        T szTmp[1024];
        va_start(arglist, hInst);
        int nRet = IS_CHAR(*m_pstrData) ?
                   _vsnprintf((LPSTR)szTmp, ARRAYSIZE(szTmp), (LPCSTR)strFmt.String(), arglist) :
                   _vsnwprintf((LPWSTR)szTmp, ARRAYSIZE(szTmp), (LPCWSTR)strFmt.String(), arglist);
        va_end(arglist);
        Assign(szTmp);
    }
    else Assign(NULL);
    return *this;
}

template <class T>
bool CSimpleStringBase<T>::LoadString( UINT nResId, HMODULE hModule )
{
    if (!hModule)
        hModule = GetModuleHandle(NULL);
    T szTmp[m_nMaxLoadStringBuffer];
    int nRet = IS_CHAR(*m_pstrData) ?
               ::LoadStringA( hModule, nResId, (LPSTR)szTmp, ARRAYSIZE(szTmp)) :
               ::LoadStringW( hModule, nResId, (LPWSTR)szTmp, ARRAYSIZE(szTmp));
    if (nRet)
        return Assign(szTmp);
    else return Assign(NULL);
}


template <class T>
CSimpleStringBase<T>::~CSimpleStringBase(void)
{
    Destroy();
}

template <class T>
void CSimpleStringBase<T>::DeleteStorage(void)
{
    //
    // Only delete the string if it is non-NULL and not pointing to our non-dynamically allocated buffer
    //
    if (m_pstrData && m_pstrData != m_pstrAutoData)
    {
        delete[] m_pstrData;
    }
    m_pstrData = NULL;
}

template <class T>
T *CSimpleStringBase<T>::CreateStorage( UINT nCount )
{
    return new T[nCount];
}

template <class T>
void CSimpleStringBase<T>::Destroy(void)
{
    DeleteStorage();
    m_nMaxSize = 0;
}

template <class T>
UINT CSimpleStringBase<T>::Length(void) const
{
    return(m_pstrData ? GenericLength(m_pstrData) : 0);
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator=( const CSimpleStringBase &other )
{
    if (&other != this)
    {
        Assign(other.String());
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator=( const T *other )
{
    if (other != String())
    {
        Assign(other);
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::operator+=( const CSimpleStringBase &other )
{
    Concat(other.String());
    return *this;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::operator+( const CSimpleStringBase &other ) const
{
    CSimpleStringBase tmp(*this);
    tmp.Concat(other);
    return tmp;
}

template <class T>
bool CSimpleStringBase<T>::Assign( const T *szStr )
{
    if (szStr && EnsureLength(GenericLength(szStr)+1))
    {
        GenericCopy(m_pstrData,szStr);
    }
    else if (EnsureLength(1))
    {
        *m_pstrData = 0;
    }
    else Destroy();
    return(NULL != m_pstrData);
}

template <class T>
bool CSimpleStringBase<T>::Assign( const CSimpleStringBase &other )
{
    return Assign( other.String() );
}

template <class T>
void CSimpleStringBase<T>::SetAt( UINT nIndex, T chValue )
{
    //
    // Make sure we don't go off the end of the string or overwrite the '\0'
    //
    if (m_pstrData && Length() > nIndex)
    {
        m_pstrData[nIndex] = chValue;
    }
}


template <class T>
void CSimpleStringBase<T>::Concat( const CSimpleStringBase &other )
{
    if (EnsureLength( Length() + other.Length() + 1 ))
    {
        GenericConcatenate(m_pstrData,other.String());
    }
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::MakeUpper(void)
{
    //
    // Make sure the string is not NULL
    //
    if (m_pstrData)
    {
        IS_CHAR(*m_pstrData) ? CharUpperBuffA( (LPSTR)m_pstrData, Length() ) : CharUpperBuffW( (LPWSTR)m_pstrData, Length() );
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::MakeLower(void)
{
    //
    // Make sure the string is not NULL
    //
    if (m_pstrData)
    {
        IS_CHAR(*m_pstrData) ? CharLowerBuffA( (LPSTR)m_pstrData, Length() ) : CharLowerBuffW( (LPWSTR)m_pstrData, Length() );
    }
    return *this;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::ToUpper(void) const
{
    CSimpleStringBase str(*this);
    str.MakeUpper();
    return str;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::ToLower(void) const
{
    CSimpleStringBase str(*this);
    str.MakeLower();
    return str;
}

template <class T>
T &CSimpleStringBase<T>::operator[](int nIndex)
{
    return m_pstrData[nIndex];
}

template <class T>
const T &CSimpleStringBase<T>::operator[](int index) const
{
    return m_pstrData[index];
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::TrimRight(void)
{
    T *pFirstWhitespaceCharacterInSequence = NULL;
    bool bInWhiteSpace = false;
    T *pszPtr = m_pstrData;
    while (pszPtr && *pszPtr)
    {
        if (*pszPtr == L' ' || *pszPtr == L'\t' || *pszPtr == L'\n' || *pszPtr == L'\r')
        {
            if (!bInWhiteSpace)
            {
                pFirstWhitespaceCharacterInSequence = pszPtr;
                bInWhiteSpace = true;
            }
        }
        else
        {
            bInWhiteSpace = false;
        }
        pszPtr = GenericCharNext(pszPtr);
    }
    if (pFirstWhitespaceCharacterInSequence && bInWhiteSpace)
        *pFirstWhitespaceCharacterInSequence = 0;
    return *this;
}

template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::TrimLeft(void)
{
    T *pszPtr = m_pstrData;
    while (pszPtr && *pszPtr)
    {
        if (*pszPtr == L' ' || *pszPtr == L'\t' || *pszPtr == L'\n' || *pszPtr == L'\r')
        {
            pszPtr = GenericCharNext(pszPtr);
        }
        else break;
    }
    Assign(CSimpleStringBase<T>(pszPtr).String());
    return *this;
}

template <class T>
inline CSimpleStringBase<T> &CSimpleStringBase<T>::Trim(void)
{
    TrimLeft();
    TrimRight();
    return *this;
}

//
// Note that this function WILL NOT WORK CORRECTLY for multi-byte characters in ANSI strings
//
template <class T>
CSimpleStringBase<T> &CSimpleStringBase<T>::Reverse(void)
{
    UINT nLen = Length();
    for (UINT i = 0;i<nLen/2;i++)
    {
        T tmp = m_pstrData[i];
        m_pstrData[i] = m_pstrData[nLen-i-1];
        m_pstrData[nLen-i-1] = tmp;
    }
    return *this;
}

template <class T>
int CSimpleStringBase<T>::Find( T cChar ) const
{
    T strTemp[2] = { cChar, 0};
    return Find(strTemp);
}


template <class T>
int CSimpleStringBase<T>::Find( const CSimpleStringBase &other, UINT nStart ) const
{
    if (!m_pstrData)
        return -1;
    if (nStart > Length())
        return -1;
    T *pstrCurr = m_pstrData+nStart, *pstrSrc, *pstrSubStr;
    while (*pstrCurr)
    {
        pstrSrc = pstrCurr;
        pstrSubStr = (T *)other.String();
        while (*pstrSrc && *pstrSubStr && *pstrSrc == *pstrSubStr)
        {
            pstrSrc = GenericCharNext(pstrSrc);
            pstrSubStr = GenericCharNext(pstrSubStr);
        }
        if (!*pstrSubStr)
            return static_cast<int>(pstrCurr-m_pstrData);
        pstrCurr = GenericCharNext(pstrCurr);
    }
    return -1;
}

template <class T>
int CSimpleStringBase<T>::ReverseFind( T cChar ) const
{
    T strTemp[2] = { cChar, 0};
    return ReverseFind(strTemp);
}

template <class T>
int CSimpleStringBase<T>::ReverseFind( const CSimpleStringBase &srcStr ) const
{
    int nLastFind = -1, nFind=0;
    while ((nFind = Find( srcStr, nFind )) >= 0)
    {
        nLastFind = nFind;
        ++nFind;
    }
    return nLastFind;
}

template <class T>
CSimpleStringBase<T> CSimpleStringBase<T>::SubStr( int nStart, int nCount ) const
{
    if (nStart >= (int)Length() || nStart < 0)
        return CSimpleStringBase<T>();
    if (nCount < 0)
        nCount = Length() - nStart;
    CSimpleStringBase<T> strTmp;
    T *pszTmp = CreateStorage(nCount+1);
    if (pszTmp)
    {
        GenericCopyLength( pszTmp, m_pstrData+nStart, nCount+1 );
        pszTmp[nCount] = 0;
        strTmp = pszTmp;
        delete[] pszTmp;
    }
    return strTmp;
}



template <class T>
int CSimpleStringBase<T>::CompareNoCase( const CSimpleStringBase &other, int nLength ) const
{
    if (nLength < 0)
    {
        //
        // Make sure both strings are non-NULL
        //
        if (!String() && !other.String())
        {
            return 0;
        }
        else if (!String())
        {
            return -1;
        }
        else if (!other.String())
        {
            return 1;
        }
        else return GenericCompareNoCase(m_pstrData,other.String());
    }
    CSimpleStringBase<T> strSrc(*this);
    CSimpleStringBase<T> strTgt(other);
    strSrc.MakeUpper();
    strTgt.MakeUpper();
    //
    // Make sure both strings are non-NULL
    //
    if (!strSrc.String() && !strTgt.String())
    {
        return 0;
    }
    else if (!strSrc.String())
    {
        return -1;
    }
    else if (!strTgt.String())
    {
        return 1;
    }
    else return GenericCompareLength(strSrc.String(),strTgt.String(),nLength);
}


template <class T>
int CSimpleStringBase<T>::Compare( const CSimpleStringBase &other, int nLength ) const
{
    //
    // Make sure both strings are non-NULL
    //
    if (!String() && !other.String())
    {
        return 0;
    }
    else if (!String())
    {
        return -1;
    }
    else if (!other.String())
    {
        return 1;
    }

    if (nLength < 0)
    {
        return GenericCompare(String(),other.String());
    }
    return GenericCompareLength(String(),other.String(),nLength);
}

template <class T>
bool CSimpleStringBase<T>::MatchLastCharacter( T cChar ) const
{
    int nFind = ReverseFind(cChar);
    if (nFind < 0)
        return false;
    if (nFind == (int)Length()-1)
        return true;
    else return false;
}

template <class T>
bool CSimpleStringBase<T>::Load( HKEY hRegKey, const T *pszValueName, const T *pszDefault )
{
    bool bResult = false;
    Assign(pszDefault);
    DWORD nType=0;
    DWORD nSize=0;
    LONG nRet;
    if (IS_CHAR(*m_pstrData))
        nRet = RegQueryValueExA( hRegKey, (LPCSTR)pszValueName, NULL, &nType, NULL, &nSize);
    else nRet = RegQueryValueExW( hRegKey, (LPCWSTR)pszValueName, NULL, &nType, NULL, &nSize);
    if (ERROR_SUCCESS == nRet)
    {
        if ((nType == REG_SZ) || (nType == REG_EXPAND_SZ))
        {
            // Round up to the nearest 2
            nSize = ((nSize + 1) & 0xFFFFFFFE);
            T *pstrTemp = CreateStorage(nSize / sizeof(T));
            if (pstrTemp)
            {
                if (IS_CHAR(*m_pstrData))
                    nRet = RegQueryValueExA( hRegKey, (LPCSTR)pszValueName, NULL, &nType, (PBYTE)pstrTemp, &nSize);
                else nRet = RegQueryValueExW( hRegKey, (LPCWSTR)pszValueName, NULL, &nType, (PBYTE)pstrTemp, &nSize);
                if (ERROR_SUCCESS == nRet)
                {
                    Assign(pstrTemp);
                    bResult = true;
                }
                delete pstrTemp;
            }
        }
    }
    return bResult;
}

template <class T>
bool CSimpleStringBase<T>::Store( HKEY hRegKey, const T *pszValueName, DWORD nType )
{
    bool bResult = false;
    long nRet;
    if (Length())
    {
        if (IS_CHAR(*m_pstrData))
            nRet = RegSetValueExA( hRegKey, (LPCSTR)pszValueName, 0, nType, (PBYTE)m_pstrData, sizeof(*m_pstrData)*(Length()+1) );
        else nRet = RegSetValueExW( hRegKey, (LPCWSTR)pszValueName, 0, nType, (PBYTE)m_pstrData, sizeof(*m_pstrData)*(Length()+1) );
    }
    else
    {
        T strBlank = 0;
        if (IS_CHAR(*m_pstrData))
            nRet = RegSetValueExA( hRegKey, (LPCSTR)pszValueName, 0, nType, (PBYTE)&strBlank, sizeof(T) );
        else nRet = RegSetValueExW( hRegKey, (LPCWSTR)pszValueName, 0, nType, (PBYTE)&strBlank, sizeof(T) );
    }
    return(ERROR_SUCCESS == nRet);
}


typedef CSimpleStringBase<char>     CSimpleStringAnsi;
typedef CSimpleStringBase<wchar_t>  CSimpleStringWide;

#if defined(UNICODE) || defined(_UNICODE)
#define CSimpleString CSimpleStringWide
#else
#define CSimpleString CSimpleStringAnsi
#endif

namespace CSimpleStringConvert
{
    template <class T>
    CSimpleStringWide WideString(const T &str)
    {
        if (IS_WCHAR(str[0]))
            return CSimpleStringWide((LPCWSTR)str.String());
        else
        {
            if (!str.Length())
                return CSimpleStringWide(L"");
            int iLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (LPCSTR)str.String(), str.Length()+1, NULL, 0 );
            CSimpleStringWide sswTmp;
            LPWSTR pwszTmp = new WCHAR[iLen];
            if (pwszTmp)
            {
                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (LPCSTR)str.String(), str.Length()+1, pwszTmp, iLen );
                sswTmp = pwszTmp;
                delete[] pwszTmp;
            }
            return sswTmp;
        }
    }

    template <class T>
    CSimpleStringAnsi AnsiString(const T &str)
    {
        if (IS_CHAR(str[0]))
            return CSimpleStringAnsi((LPCSTR)str.String());
        else
        {
            if (!str.Length())
                return CSimpleStringAnsi("");
            int iLen = WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)str.String(), str.Length()+1, NULL, 0, NULL, NULL );
            CSimpleStringAnsi ssaTmp;
            LPSTR pszTmp = new CHAR[iLen];
            if (pszTmp)
            {
                WideCharToMultiByte( CP_ACP, 0, (LPCWSTR)str.String(), str.Length()+1, pszTmp, iLen, NULL, NULL );
                ssaTmp = pszTmp;
                delete[] pszTmp;
            }
            return ssaTmp;
        }
    }

#if defined(_UNICODE) || defined(UNICODE)
    template <class T>
    CSimpleStringWide NaturalString(const T &str)
    {
        return WideString(str);
    }
#else
    template <class T>
    CSimpleStringAnsi NaturalString(const T &str)
    {
        return AnsiString(str);
    }
#endif

    inline CSimpleString NumberToString( int nNumber, LCID Locale=LOCALE_USER_DEFAULT )
    {
        TCHAR szTmp[MAX_PATH]=TEXT("");
        TCHAR szNumberStr[MAX_PATH]=TEXT("");
        TCHAR szDigitGrouping[32]=TEXT("");
        TCHAR szThousandsSeparator[32]=TEXT("");
        TCHAR szDecimalSeparator[32]=TEXT("");

        // Initialize the number format
        NUMBERFMT NumberFormat;
        NumberFormat.NumDigits = 0;
        NumberFormat.LeadingZero = 0;
        NumberFormat.NegativeOrder = 0;
        // This turns a string into a number, like so: 3;2;0=32 or 3;0 = 3 or 1;2;3;4;5;6;0 = 123456.  Got it?
        GetLocaleInfo( Locale, LOCALE_SGROUPING, szDigitGrouping, ARRAYSIZE(szDigitGrouping));
        NumberFormat.Grouping = 0;
        LPTSTR pszCurr = szDigitGrouping;
        while (*pszCurr && *pszCurr >= TEXT('1') && *pszCurr <= TEXT('9'))
        {
            NumberFormat.Grouping *= 10;
            NumberFormat.Grouping += (*pszCurr - TEXT('0'));
            pszCurr += 2;
        }
        GetLocaleInfo( Locale, LOCALE_STHOUSAND, szThousandsSeparator, ARRAYSIZE(szThousandsSeparator));
        NumberFormat.lpThousandSep = szThousandsSeparator;
        GetLocaleInfo( Locale, LOCALE_SDECIMAL, szDecimalSeparator, ARRAYSIZE(szDecimalSeparator));
        NumberFormat.lpDecimalSep = szDecimalSeparator;
        // Create the number string
        _sntprintf( szTmp, ARRAYSIZE(szTmp), TEXT("%d"), nNumber );
        if (GetNumberFormat( Locale, 0, szTmp, &NumberFormat, szNumberStr, ARRAYSIZE(szNumberStr)))
            return szNumberStr;
        else return TEXT("");
    }
}  // End CSimpleStringConvert namespace

#endif  // ifndef _SIMSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\w32utils.inl ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       w32utils.inl
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Win32 templates & utilities (Impl.)
 *
 *****************************************************************************/

////////////////////////////////////////////////
//
// class CSimpleWndSubclass
//
// class implementing simple window subclassing
// (Windows specific classes)
//

template <class inheritorClass>
inline BOOL CSimpleWndSubclass<inheritorClass>::IsAttached() const 
{ 
    return (NULL != m_hwnd); 
}

template <class inheritorClass>
BOOL CSimpleWndSubclass<inheritorClass>::Attach(HWND hwnd)
{
    if( hwnd )
    {
        // make sure we are not attached and nobody is using
        // GWLP_USERDATA for something else already.
        ASSERT(NULL == m_hwnd);
        ASSERT(NULL == m_wndDefProc);
        ASSERT(NULL == GetWindowLongPtr(hwnd, GWLP_USERDATA));

        // attach to this window
        m_hwnd = hwnd;
        m_wndDefProc = reinterpret_cast<WNDPROC>(GetWindowLongPtr(m_hwnd, GWLP_WNDPROC));

        // thunk the window proc
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
        SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,  reinterpret_cast<LONG_PTR>(_ThunkWndProc));

        return TRUE;
    }
    return FALSE;
}

template <class inheritorClass>
BOOL CSimpleWndSubclass<inheritorClass>::Detach()
{
    if( m_hwnd )
    {
        // unthunk the window proc
        SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,  reinterpret_cast<LONG_PTR>(m_wndDefProc));
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);

        // clear out our data
        m_wndDefProc = NULL;
        m_hwnd = NULL;

        return TRUE;
    }
    return FALSE;
}

template <class inheritorClass>
LRESULT CALLBACK CSimpleWndSubclass<inheritorClass>::_ThunkWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // get the pThis ptr from GWLP_USERDATA
    CSimpleWndSubclass<inheritorClass> *pThis = 
        reinterpret_cast<CSimpleWndSubclass<inheritorClass>*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    // must be attached
    ASSERT(pThis->IsAttached());

    // static cast pThis to inheritorClass
    inheritorClass *pTarget = static_cast<inheritorClass*>(pThis);

    // messsage processing is here
    if( WM_NCDESTROY == uMsg )
    {
        // this window is about to go away - detach.
        LRESULT lResult = pTarget->WindowProc(hwnd, uMsg, wParam, lParam);
        pThis->Detach();
        return lResult;
    }
    else
    {
        // invoke the inheritorClass WindowProc (should be defined)
        return pTarget->WindowProc(hwnd, uMsg, wParam, lParam);
    }
}

template <class inheritorClass>
inline LRESULT CSimpleWndSubclass<inheritorClass>::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

template <class inheritorClass>
inline LRESULT CSimpleWndSubclass<inheritorClass>::DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if( m_wndDefProc )
    {
        return CallWindowProc(m_wndDefProc, hwnd, uMsg, wParam, lParam);
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

template <class inheritorClass>
inline LRESULT CSimpleWndSubclass<inheritorClass>::DefDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if( m_wndDefProc )
    {
        return CallWindowProc(m_wndDefProc, hwnd, uMsg, wParam, lParam);
    }
    return ::DefDlgProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\w32utils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       w32utils.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        23-Dec-2000
 *
 *  DESCRIPTION: Win32 templates & utilities
 *
 *****************************************************************************/

#ifndef _W32UTILS_H
#define _W32UTILS_H

// the generic smart pointers & handles
#include "gensph.h"

////////////////////////////////////////////////
//
// class CSimpleWndSubclass
//
// class implementing simple window subclassing
// (Windows specific classes)
//
typedef LRESULT type_WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
template <class inheritorClass>
class CSimpleWndSubclass
{
    WNDPROC m_wndDefProc;
    static LRESULT CALLBACK _ThunkWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
public:
    CSimpleWndSubclass(): m_hwnd(NULL), m_wndDefProc(NULL) { }
    CSimpleWndSubclass(HWND hwnd): m_hwnd(NULL), m_wndDefProc(NULL) { Attach(hwnd); }
    ~CSimpleWndSubclass() { Detach(); }

    // attach/detach
    BOOL IsAttached() const;
    BOOL Attach(HWND hwnd);
    BOOL Detach();

    // default subclass proc
    LRESULT WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // default proc(s)
    LRESULT DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT DefDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND m_hwnd;
};

////////////////////////////////////////////////
//
// class COleComInitializer
//
// smart OLE2, COM initializer - just declare 
// an instance wherever need to use COM, OLE2
//
class COleComInitializer
{
public:
    COleComInitializer(BOOL bOleInit = FALSE);
    ~COleComInitializer();
    operator BOOL () const;

private:
    HRESULT m_hr;
    BOOL m_bOleInit;
};

////////////////////////////////////////////////
//
// class CDllLoader
//
// smart DLL loader - calls LoadLibrary
// FreeLibrary for you.
//
class CDllLoader
{
public:
    CDllLoader(LPCTSTR pszDllName);
    ~CDllLoader();
    operator BOOL () const;
    FARPROC GetProcAddress( LPCSTR lpProcName );
    FARPROC GetProcAddress( WORD wProcOrd );

private:
    HMODULE m_hLib;
};

////////////////////////////////////////////////
// class CCookiesHolder
//
// this a utility class which allows us to pass more 
// than one pointer through a single cookie (pointer).
//
class CCookiesHolder
{
public:
    // construction/destruction
    CCookiesHolder();
    CCookiesHolder(UINT nCount);
    ~CCookiesHolder();

    // sets the count
    BOOL SetCount(UINT uCount);

    // returns the number of cookies here
    UINT GetCount() const
    { return m_uCount; } 

    // returns the cookie at this position
    template <class pType>
    pType GetCookie(UINT iIndex) const
    { 
        ASSERT(iIndex < m_uCount);
        return reinterpret_cast<pType>(m_pCookies[iIndex]);
    }

    // returns the previous cookie at this position
    template <class pType>
    pType SetCookie(UINT iIndex, pType pCookie)
    { 
        ASSERT(iIndex < m_uCount);
        pType pReturn = reinterpret_cast<pType>(m_pCookies[iIndex]);
        m_pCookies[iIndex] = reinterpret_cast<LPVOID>(pCookie);
        return pReturn;
    }

    // const & non-const operators [] 
    LPVOID  operator [] (UINT iIndex) const
    {
        ASSERT(iIndex < m_uCount);
        return m_pCookies[iIndex];
    }
    LPVOID& operator [] (UINT iIndex)
    {
        ASSERT(iIndex < m_uCount);
        return m_pCookies[iIndex];
    }

private:
    UINT m_uCount;
    LPVOID *m_pCookies;
};

////////////////////////////////////////////////
//
// template class CScopeLocker<TLOCK>
//
template <class TLOCK>
class CScopeLocker
{
public:
    CScopeLocker(TLOCK &lock): 
        m_Lock(lock), m_bLocked(false) 
    { m_bLocked = (m_Lock && m_Lock.Lock()); }

    ~CScopeLocker() 
    { if (m_bLocked) m_Lock.Unlock(); }

    operator bool () const 
    { return m_bLocked; }

private:
    bool m_bLocked;
    TLOCK &m_Lock;
};

////////////////////////////////////////////////
//
// class CCSLock - win32 critical section lock.
//
class CCSLock
{
public:
    // CCSLock::Locker should be used as locker class.
    typedef CScopeLocker<CCSLock> Locker;
   
    CCSLock(): m_bInitialized(false)
    { 
        for (;;)
        {
            __try 
            { 
                // InitializeCriticalSection may rise STATUS_NO_MEMORY exception 
                // in low memory conditions (according the SDK)
                InitializeCriticalSection(&m_CS); 
                m_bInitialized = true; 
                return;
            } 
            __except(EXCEPTION_EXECUTE_HANDLER) {}
            Sleep(100);
        }
    }

    ~CCSLock()    
    { 
        if (m_bInitialized) 
        {
            // delete the critical section only if initialized successfully
            DeleteCriticalSection(&m_CS); 
        }
    }

    operator bool () const
    { 
        return m_bInitialized; 
    }

    bool Lock()
    { 
        for (;;)
        {
            __try 
            { 
                // EnterCriticalSection may rise STATUS_NO_MEMORY exception 
                // in low memory conditions (this may happen if there is contention
                // and ntdll can't allocate the wait semaphore)
                EnterCriticalSection(&m_CS); 
                return true; 
            } 
            __except(EXCEPTION_EXECUTE_HANDLER) {}
            Sleep(100);
        }

        // we should never end up here either way
        return false;
    }

    void Unlock() 
    {
        // Unlock() should be called *ONLY* if the corresponding 
        // Lock() call has succeeded.
        LeaveCriticalSection(&m_CS); 
    }

#if DBG
    // debug code...
    bool bInside()  const
    { 
        return (m_bInitialized && m_CS.OwningThread == DWORD2PTR(GetCurrentThreadId(), HANDLE)); 
    }
    bool bOutside() const 
    { 
        return (m_bInitialized && m_CS.OwningThread != DWORD2PTR(GetCurrentThreadId(), HANDLE)); 
    }
#endif

private:
    bool m_bInitialized;
    CRITICAL_SECTION m_CS;
};

////////////////////////////////////////////////
//
// class CSemaphoreLock -  simple semaphore lock.
//
class CSemaphoreLock
{
public:
    typedef CScopeLocker<CSemaphoreLock> Locker;

    CSemaphoreLock()  { }
    ~CSemaphoreLock() { }

    void Lock()   { ASSERT(m_shSemaphore); WaitForSingleObject(m_shSemaphore, INFINITE); }
    void Unlock() { ASSERT(m_shSemaphore); ReleaseSemaphore(m_shSemaphore, 1, NULL); }

    HRESULT Create(
        LONG lInitialCount,                                     // initial count
        LONG lMaximumCount,                                     // maximum count
        LPCTSTR lpName = NULL,                                  // object name
        LPSECURITY_ATTRIBUTES lpSemaphoreAttributes = NULL      // SD
        )
    {
        m_shSemaphore = CreateSemaphore(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        return m_shSemaphore ? S_OK : E_OUTOFMEMORY;
    }

private:
    CAutoHandleNT m_shSemaphore;
};

// include the implementation of the template classes here
#include "w32utils.inl"

#endif // endif _W32UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\wiadebug.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADEBUG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/6/1999
 *
 *  DESCRIPTION: Declarations for the debugging functions, macros and classes
 *
 *******************************************************************************/
#ifndef __WIADEBUG_H_INCLUDED
#define __WIADEBUG_H_INCLUDED

#include <windows.h>
#include "simcrit.h"

#if !defined(__cplusplus)
#error This library can only be used in c++ programs.
#endif

//
// Severity levels
//
enum
{
    WiaDebugSeverityNormal  = 0,
    WiaDebugSeverityWarning = 1,
    WiaDebugSeverityError   = 2
};


//
// Make sure these haven't already been defined.  This shouldn't normally be a problem.
//
#ifdef WIA_DEBUG_CREATE
#undef WIA_DEBUG_CREATE
#endif
#ifdef WIA_DEBUG_DESTROY
#undef WIA_DEBUG_DESTROY
#endif
#ifdef WIA_SET_TRACE_MASK
#undef WIA_SET_TRACE_MASK
#endif
#ifdef WIA_PUSHFUNCTION
#undef WIA_PUSHFUNCTION
#endif
#ifdef WIA_PUSH_FUNCTION
#undef WIA_PUSH_FUNCTION
#endif
#ifdef WIA_PUSHFUNCTION_MASK
#undef WIA_PUSHFUNCTION_MASK
#endif
#ifdef WIA_PUSH_FUNCTION_MASK
#undef WIA_PUSH_FUNCTION_MASK
#endif
#ifdef WIA_TRACE
#undef WIA_TRACE
#endif
#ifdef WIA_WARNING
#undef WIA_WARNING
#endif
#ifdef WIA_ERROR
#undef WIA_ERROR
#endif
#ifdef WIA_PRINTHRESULT
#undef WIA_PRINTHRESULT
#endif
#ifdef WIA_PRINTGUID
#undef WIA_PRINTGUID
#endif
#ifdef WIA_PRINTWINDOWMESSAGE
#undef WIA_PRINTWINDOWMESSAGE
#endif
#ifdef WIA_ASSERT
#undef WIA_ASSERT
#endif
#ifdef WIA_CHECK_HR
#undef WIA_CHECK_HR
#endif
#ifdef WIA_RETURN_HR
#undef WIA_RETURN_HR
#endif

//
// Turn of name mangling for exported/imported functions
//
extern "C"
{

//
// Exported functions
//
int      WINAPI IncrementDebugIndentLevel(void);
int      WINAPI DecrementDebugIndentLevel(void);
BOOL     WINAPI PrintDebugMessageW( DWORD dwSeverity, DWORD dwModuleMask, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCWSTR pszModuleName, LPCWSTR pszMsg );
BOOL     WINAPI PrintDebugMessageA( DWORD dwSeverity, DWORD dwModuleMask, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCSTR pszModuleName, LPCSTR pszMsg );
DWORD    WINAPI GetDebugMask(void);
DWORD    WINAPI SetDebugMask( DWORD dwNewMask );
COLORREF WINAPI AllocateDebugColor(void);
BOOL     WINAPI GetStringFromGuidA( const IID *pGuid, LPSTR pszString, int nMaxLen );
BOOL     WINAPI GetStringFromGuidW( const IID *pGuid, LPWSTR pszString, int nMaxLen );
VOID     WINAPI DoRecordAllocation( LPVOID pv, size_t Size );
VOID     WINAPI DoRecordFree( LPVOID pv );
BOOL     WINAPI GetStringFromMsgA( UINT uMsg, LPSTR pszString, int nMaxLen );
BOOL     WINAPI GetStringFromMsgW( UINT uMsg, LPWSTR pszString, int nMaxLen );

//
// Exported function typedefs
//
typedef int      (WINAPI *IncrementDebugIndentLevelProc)(void);
typedef int      (WINAPI *DecrementDebugIndentLevelProc)(void);
typedef BOOL     (WINAPI *PrintDebugMessageWProc)( DWORD, DWORD, COLORREF, COLORREF, LPCWSTR, LPCWSTR );
typedef BOOL     (WINAPI *PrintDebugMessageAProc)( DWORD, DWORD, COLORREF, COLORREF, LPCSTR, LPCSTR );
typedef DWORD    (WINAPI *GetDebugMaskProc)(void);
typedef DWORD    (WINAPI *SetDebugMaskProc)( DWORD );
typedef COLORREF (WINAPI *AllocateDebugColorProc)(void);
typedef BOOL     (WINAPI *GetStringFromGuidAProc)( const IID*, LPSTR, int );
typedef BOOL     (WINAPI *GetStringFromGuidWProc)( const IID*, LPWSTR, int );
typedef VOID     (WINAPI *DoRecordAllocationProc)( LPVOID pv, size_t Size );
typedef VOID     (WINAPI *DoRecordFreeProc)( LPVOID pv );
typedef VOID     (WINAPI *DoReportLeaksProc)( LPTSTR );
typedef BOOL     (WINAPI *GetStringFromMsgAProc)( UINT uMsg, LPSTR pszString, int nMaxLen );
typedef BOOL     (WINAPI *GetStringFromMsgWProc)( UINT uMsg, LPWSTR pszString, int nMaxLen );

} // extern "C"


//
// Names of exported functions
//
#define INCREMENT_DEBUG_INDENT_LEVEL_NAME  "IncrementDebugIndentLevel"
#define DECREMENT_DEBUG_INDENT_LEVEL_NAME  "DecrementDebugIndentLevel"
#define PRINT_DEBUG_MESSAGE_NAMEW          "PrintDebugMessageW"
#define PRINT_DEBUG_MESSAGE_NAMEA          "PrintDebugMessageA"
#define GET_DEBUG_MASK_NAME                "GetDebugMask"
#define SET_DEBUG_MASK_NAME                "SetDebugMask"
#define ALLOCATE_DEBUG_COLOR_NAME          "AllocateDebugColor"
#define GET_STRING_FROM_GUID_NAMEA         "GetStringFromGuidA"
#define GET_STRING_FROM_GUID_NAMEW         "GetStringFromGuidW"
#define DO_RECORD_ALLOCATION               "DoRecordAllocation"
#define DO_RECORD_FREE                     "DoRecordFree"
#define DO_REPORT_LEAKS                    "DoReportLeaks"
#define GET_STRING_FROM_MSGA               "GetStringFromMsgA"
#define GET_STRING_FROM_MSGW               "GetStringFromMsgW"

//
// Forced error stuff
//
#define REGSTR_FORCEERR_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WIA\\ForceError")
#define REGSTR_ERROR_POINT  TEXT("ErrorPoint")
#define REGSTR_ERROR_VALUE  TEXT("ErrorValue")
#define HKEY_FORCEERROR     HKEY_CURRENT_USER


//
// Name of DLL
//
#define DEBUG_DLL_NAMEW                   L"wiadebug.dll"
#define DEBUG_DLL_NAMEA                    "wiadebug.dll"

//
// Path to the section of the registry in which all debug data is stored
//
#define DEBUG_REGISTRY_PATHA               "Software\\Microsoft\\Wia\\WiaDebugUi"
#define DEBUG_REGISTRY_PATHW              L"Software\\Microsoft\\Wia\\WiaDebugUi"

//
// Path to the section of the registry in which the module flags are stored
//
#define DEBUG_REGISTRY_PATH_FLAGSA         "Software\\Microsoft\\Wia\\WiaDebugUi\\ModuleFlags"
#define DEBUG_REGISTRY_PATH_FLAGSW        L"Software\\Microsoft\\Wia\\WiaDebugUi\\ModuleFlags"

//
// Registry value names
//
#define DEBUG_REGISTRY_ENABLE_DBGA         "EnableTracing"
#define DEBUG_REGISTRY_ENABLE_DBGW        L"EnableTracing"

//
// Name of default value.  This allows us to turn on all debugging.
//
#define DEBUG_REGISTRY_DEFAULT_FLAGSA      "DefaultDebugModuleFlag"
#define DEBUG_REGISTRY_DEFAULT_FLAGSW     L"DefaultDebugModuleFlag"

//
// Unicode/ANSI versions
//
#if defined(UNICODE)

typedef PrintDebugMessageWProc             PrintDebugMessageProc;
typedef GetStringFromGuidWProc             GetStringFromGuidProc;
#define PRINT_DEBUG_MESSAGE_NAME           PRINT_DEBUG_MESSAGE_NAMEW
#define DEBUG_DLL_NAME                     DEBUG_DLL_NAMEW
#define GET_STRING_FROM_GUID_NAME          GET_STRING_FROM_GUID_NAMEW
#define DEBUG_REGISTRY_PATH                DEBUG_REGISTRY_PATHW
#define DEBUG_REGISTRY_PATH_FLAGS          DEBUG_REGISTRY_PATH_FLAGSW
#define DEBUG_REGISTRY_ENABLE_DBG          DEBUG_REGISTRY_ENABLE_DBGW
#define DEBUG_REGISTRY_DEFAULT_FLAGS       DEBUG_REGISTRY_DEFAULT_FLAGSW
#define GET_STRING_FROM_MSG                GET_STRING_FROM_MSGW

#else

typedef PrintDebugMessageAProc             PrintDebugMessageProc;
typedef GetStringFromGuidAProc             GetStringFromGuidProc;
#define PRINT_DEBUG_MESSAGE_NAME           PRINT_DEBUG_MESSAGE_NAMEA
#define DEBUG_DLL_NAME                     DEBUG_DLL_NAMEA
#define GET_STRING_FROM_GUID_NAME          GET_STRING_FROM_GUID_NAMEA
#define DEBUG_REGISTRY_PATH                DEBUG_REGISTRY_PATHA
#define DEBUG_REGISTRY_PATH_FLAGS          DEBUG_REGISTRY_PATH_FLAGSA
#define DEBUG_REGISTRY_ENABLE_DBG          DEBUG_REGISTRY_ENABLE_DBGA
#define DEBUG_REGISTRY_DEFAULT_FLAGS       DEBUG_REGISTRY_DEFAULT_FLAGSA
#define GET_STRING_FROM_MSG                GET_STRING_FROM_MSGA

#endif

//
// Color used to specify use default
//
#define DEFAULT_DEBUG_COLOR                 static_cast<COLORREF>(0xFFFFFFFF)

//
// Default colors
//
#define ERROR_FOREGROUND_COLOR              RGB(0x00,0x00,0x00)
#define ERROR_BACKGROUND_COLOR              RGB(0xFF,0x7F,0x7F)
#define WARNING_FOREGROUND_COLOR            RGB(0x00,0x00,0x00)
#define WARNING_BACKGROUND_COLOR            RGB(0xFF,0xFF,0x7F)

//
// Kernel object names
//
#define WIADEBUG_MEMORYMAPPED_FILENAME      TEXT("WiaDebugMemoryMappedFile")
#define WIADEBUG_MEMORYMAPPED_MUTEXNAME     TEXT("WiaDebugMemoryMappedMutex")
#define WIADEBUG_DEBUGCLIENT_MUTEXNAME      TEXT("WiaDebugDebugClientMutex")

#define NUMBER_OF_DEBUG_COLORS 8

//
// The data stored in the shared memory section
//

//
// Make sure it it is byte aligned
//
#include <pshpack1.h>
struct CSystemGlobalData
{
    //
    // Global debugging switch
    //
    DWORD     nAllowDebugMessages;

    //
    // Registered debug window.  We will cast it to an HWND (which should be safe under Win64)
    //
    DWORD     hwndDebug;

    //
    // Color information
    //
    COLORREF  crDebugColors[NUMBER_OF_DEBUG_COLORS];
    DWORD     nCurrentColor;
};
#include <poppack.h>


//
// Class for safely manipulating the global data
//
class CGlobalDebugState
{
private:
    HANDLE                    m_hSystemDataMutex;
    HANDLE                    m_hMemoryMappedFile;
    CSystemGlobalData        *m_pSystemGlobalData;

private:
    //
    // No implementation
    //
    CGlobalDebugState( const CGlobalDebugState & );
    CGlobalDebugState &operator=( const CGlobalDebugState & );

private:
    CSystemGlobalData *Lock(void);
    void Release(void);

public:
    CGlobalDebugState(void);
    void Destroy(void);
    ~CGlobalDebugState(void);
    bool IsValid(void) const;

    DWORD AllowDebugMessages(void);
    DWORD AllowDebugMessages( DWORD nAllowDebugMessages );

    DWORD AllocateNextColorIndex(void);

    COLORREF GetColorFromIndex( DWORD nIndex );

    bool SendDebugWindowMessage( UINT, WPARAM, LPARAM );
    bool DebugWindow( HWND hWnd );
    HWND DebugWindow(void);
};



//
// The WM_COPYDATA message will have this ID when it is sent with a debug string
//
#define COPYDATA_DEBUG_MESSAGE_ID    0xDEADBEEF

//
// The data stored in the shared memory section
//
//
// Make sure this data is byte aligned
//
#include <pshpack1.h>

struct CDebugStringMessageData
{
    COLORREF crBackground;
    COLORREF crForeground;
    BOOL     bUnicode;
    CHAR     szString[2048];
};

#include <poppack.h>

///////////////////////////////////////////////////////////////////////////////
// Main debug class.  Mostly used though macros.
///////////////////////////////////////////////////////////////////////////////
class CWiaDebugClient
{
public:
    mutable CSimpleCriticalSection m_CriticalSection;

private:
    HINSTANCE                      m_hDebugModule;
    HINSTANCE                      m_hCurrentModuleInstance;

    IncrementDebugIndentLevelProc  m_pfnIncrementDebugIndentLevel;
    DecrementDebugIndentLevelProc  m_pfnDecrementDebugIndentLevel;
    PrintDebugMessageWProc         m_pfnPrintDebugMessageW;
    PrintDebugMessageAProc         m_pfnPrintDebugMessageA;
    GetDebugMaskProc               m_pfnGetDebugMask;
    SetDebugMaskProc               m_pfnSetDebugMask;
    AllocateDebugColorProc         m_pfnAllocateDebugColor;
    GetStringFromGuidAProc         m_pfnGetStringFromGuidA;
    GetStringFromGuidWProc         m_pfnGetStringFromGuidW;
    DoRecordAllocationProc         m_pfnDoRecordAllocation;
    DoRecordFreeProc               m_pfnDoRecordFree;
    DoReportLeaksProc              m_pfnDoReportLeaks;
    GetStringFromMsgAProc          m_pfnGetStringFromMsgA;
    GetStringFromMsgWProc          m_pfnGetStringFromMsgW;

    CHAR                           m_szModuleNameA[MAX_PATH];
    WCHAR                          m_szModuleNameW[MAX_PATH];
    COLORREF                       m_crForegroundColor;
    DWORD                          m_dwModuleDebugMask;

    bool                           m_bHaveModuleInformation;
    bool                           m_bDebugLibLoadAttempted;

public:
    //
    // Actual constructor and destructor
    //
    CWiaDebugClient(void);
    ~CWiaDebugClient(void);

private:
    //
    // No implementation
    //
    CWiaDebugClient( const CWiaDebugClient & );
    CWiaDebugClient &operator=( const CWiaDebugClient & );

private:
    bool LoadWiaDebugExports();
    bool InitializeModuleInfo();
    LPTSTR GetJustTheFileName( LPCTSTR pszPath, LPTSTR pszFileName, int nMaxLen );

public:
    void SetInstance( HINSTANCE hInstance );
    bool Initialize();
    void Destroy();
    bool IsInitialized();

    DWORD SetDebugMask( DWORD dwNewMask );
    DWORD GetDebugMask(void);

    int IncrementIndentLevel();
    int DecrementIndentLevel();

    void RecordAllocation( LPVOID pv, size_t Size );
    void RecordFree( LPVOID pv );
    void ReportLeaks( void );

    inline void * __cdecl operator new(size_t size, UINT uNothing )
    {
        if (0 == size)
        {
            return NULL;
        }

        PBYTE pBuf = size ? (PBYTE)LocalAlloc(LPTR, size) : NULL;
        return (void *)pBuf;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        if (ptr)
        {
            LocalFree(ptr);
        }
    }
    
    //
    // Unicode versions
    //
    void PrintWarningMessage( LPCWSTR pszFmt, ... );
    void PrintErrorMessage( LPCWSTR pszFmt, ... );
    void PrintTraceMessage( LPCWSTR pszFmt, ... );
    void PrintHResult( HRESULT hr, LPCWSTR pszFmt, ... );
    void PrintGuid( const IID &guid, LPCWSTR pszFmt, ... );
    void PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCWSTR pszFmt, ... );
    void PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCWSTR pszMessage=NULL );


    //
    // Ansi versions
    //
    void PrintWarningMessage( LPCSTR pszFmt, ... );
    void PrintErrorMessage( LPCSTR pszFmt, ... );
    void PrintTraceMessage( LPCSTR pszFmt, ... );
    void PrintHResult( HRESULT hr, LPCSTR pszFmt, ... );
    void PrintGuid( const IID &guid, LPCSTR pszFmt, ... );
    void PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCSTR pszFmt, ... );
    void PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCSTR pszMessage=NULL );



    static DWORD GetForceFailurePoint( LPCTSTR pszProgramName );
    static HRESULT GetForceFailureValue( LPCTSTR pszProgramName, bool bPrintWarning=false );
    static void SetForceFailurePoint( LPCTSTR pszProgramName, DWORD dwErrorPoint );
    static void SetForceFailureValue( LPCTSTR pszProgramName, HRESULT hr );
};


///////////////////////////////////////////////////////////////////////////////
// A bunch of useful "auto" classes.  Mostly used though macros.
///////////////////////////////////////////////////////////////////////////////
class CPushTraceMask
{
private:
    DWORD m_dwOldMask;

private:
    // Not implemented
    CPushTraceMask(void);
    CPushTraceMask( const CPushTraceMask & );
    CPushTraceMask &operator=( const CPushTraceMask & );

public:
    CPushTraceMask( DWORD dwTraceMask );
    ~CPushTraceMask(void);
};


class CPushIndentLevel
{
private:
    int m_nIndentLevel;

private:
    //
    // Not implemented
    //
    CPushIndentLevel(void);
    CPushIndentLevel( const CPushIndentLevel & );
    CPushIndentLevel &operator=( const CPushIndentLevel & );

public:
    CPushIndentLevel( LPCTSTR pszFmt, ... );
    ~CPushIndentLevel(void);
};


class CPushTraceMaskAndIndentLevel
{
private:
    int m_nIndentLevel;
    DWORD m_dwOldMask;

private:
    //
    // Not implemented
    //
    CPushTraceMaskAndIndentLevel( const CPushTraceMaskAndIndentLevel & );
    CPushTraceMaskAndIndentLevel &operator=( const CPushTraceMaskAndIndentLevel & );

public:
    CPushTraceMaskAndIndentLevel( DWORD dwTraceMask, LPCTSTR pszFmt, ... );
    ~CPushTraceMaskAndIndentLevel(void);
};

///////////////////////////////////////////////////////////////////////////////
// This is debug-only stuff
///////////////////////////////////////////////////////////////////////////////
#if defined(DBG) || defined(_DEBUG)


extern CWiaDebugClient g_TheDebugClient;


#define WIA_DEBUG_CREATE(hInstance) g_TheDebugClient.SetInstance(hInstance)


#define WIA_DEBUG_DESTROY()


#define WIA_PUSH_TRACE_MASK(__x)    CPushTraceMask __pushTraceMask( __x )

//
// This version does support varargs
//
#define WIA_PUSH_FUNCTION(__x)      CPushIndentLevel __pushIndentLevel __x

//
// This version doesn't support varargs
//
#define WIA_PUSHFUNCTION(__x)       CPushIndentLevel __pushIndentLevel(TEXT("%s"),__x)


#define WIA_PUSH_FUNCTION_MASK(__x) CPushTraceMaskAndIndentLevel __PushTraceMaskAndIndentLevel __x


#define WIA_TRACE(args)\
do\
{\
    g_TheDebugClient.PrintTraceMessage args;\
} while(false)

#define WIA_ERROR(args)\
do\
{\
    g_TheDebugClient.PrintErrorMessage args;\
} while (false)

#define WIA_WARNING(args)\
do\
{\
    g_TheDebugClient.PrintWarningMessage args;\
} while (false)

#define WIA_PRINTHRESULT(args)\
do\
{\
    g_TheDebugClient.PrintHResult args;\
} while (false)

#define WIA_PRINTGUID(args)\
do\
{\
    g_TheDebugClient.PrintGuid args;\
} while (false)

#define WIA_PRINTWINDOWMESSAGE(args)\
do\
{\
    g_TheDebugClient.PrintWindowMessage args;\
} while (false)

#define WIA_ASSERT(x)\
do\
{\
    if (!(x))\
    {\
        WIA_ERROR((TEXT("WIA ASSERTION FAILED: %hs(%d): %hs"),__FILE__,__LINE__,#x));\
        DebugBreak();\
    }\
}\
while (false)

#define WIA_CHECK_HR(hr,fnc)\
if (FAILED(hr))\
{\
    WIA_PRINTHRESULT((hr,"%s failed", fnc));\
}

#define WIA_RETURN_HR(hr)\
if (FAILED(hr))\
{\
    WIA_PRINTHRESULT((hr,"Returning WiaError"));\
}\
return hr


#define WIA_RECORD_ALLOC(pv,size)\
do\
{\
    g_TheDebugClient.RecordAllocation(pv,size);\
} while (false)

#define WIA_RECORD_FREE(pv)\
do\
{\
    g_TheDebugClient.RecordFree(pv);\
} while (false)

#define WIA_REPORT_LEAKS()\
do\
{\
    g_TheDebugClient.ReportLeaks();\
} while (false)


#define WIA_FORCE_ERROR(DbgProgram,ForceFlag,RetailValue) ((CWiaDebugClient::GetForceFailurePoint(DbgProgram) == (ForceFlag)) ? (CWiaDebugClient::GetForceFailureValue(DbgProgram,true)) : (RetailValue))

#else // !defined(DBG) || !defined(_DEBUG)

#define WIA_DEBUG_CREATE(hInstance)
#define WIA_DEBUG_DESTROY()
#define WIA_SET_TRACE_MASK(__x)
#define WIA_PUSHFUNCTION(__x)
#define WIA_PUSH_FUNCTION(__x)
#define WIA_PUSH_FUNCTION_MASK(__x)
#define WIA_TRACE(args)
#define WIA_WARNING(args)
#define WIA_ERROR(args)
#define WIA_PRINTHRESULT(args)
#define WIA_PRINTGUID(args)
#define WIA_PRINTWINDOWMESSAGE(args)
#define WIA_ASSERT(x)
#define WIA_CHECK_HR(hr,fnc)
#define WIA_RETURN_HR(hr)   return hr
#define WIA_RECORD_ALLOC(pv,size)
#define WIA_RECORD_FREE(pv)
#define WIA_REPORT_LEAKS()
#define WIA_FORCE_ERROR(DbgProgram,ForceFlag,RetailValue) (RetailValue)

#endif // defined(DBG) || defined(_DEBUG)

#endif //__WIADEBUG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\inc\psutil\simreg.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMREG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Simple registry access class
 *
 *******************************************************************************/
#ifndef __SIMREG_H_INCLUDED
#define __SIMREG_H_INCLUDED

#include <windows.h>
#include "simstr.h"

class CSimpleReg
{
private:
    CSimpleString         m_strKeyName;
    HKEY                  m_hRootKey;
    HKEY                  m_hKey;
    bool                  m_bCreate;
    LPSECURITY_ATTRIBUTES m_lpsaSecurityAttributes;
    REGSAM                m_samDesiredAccess;

public:
    // Process current node-->recurse
    //             or
    // recurse-->Process current node
    enum
    {
        PreOrder=0,
        PostOrder=1
    };

    // structure passed to key enumeration proc
    struct CKeyEnumInfo
    {
        CSimpleString strName;
        HKEY          hkRoot;
        int           nLevel;
        LPARAM        lParam;
    };

    // structure passed to value enumeration proc
    class CValueEnumInfo
    {
    private:
        // No implementation
        CValueEnumInfo(void);
        CValueEnumInfo &operator=( const CValueEnumInfo & );
        CValueEnumInfo( const CValueEnumInfo & );

    public:
        CValueEnumInfo( CSimpleReg &_reg, const CSimpleString &_strName, DWORD _nType, DWORD _nSize, LPARAM _lParam )
        : reg(_reg), strName(_strName), nType(_nType), nSize(_nSize), lParam(_lParam)
        {
        }
        CSimpleReg    &reg;
        CSimpleString  strName;
        DWORD          nType;
        DWORD          nSize;
        LPARAM         lParam;
    };

    // Enumeration procs
    typedef bool (*SimRegKeyEnumProc)( CKeyEnumInfo &enumInfo );
    typedef bool (*SimRegValueEnumProc)( CValueEnumInfo &enumInfo );

    // Constructors, destructor and assignment operator
    CSimpleReg( HKEY hkRoot, const CSimpleString &strSubKey, bool bCreate=false, REGSAM samDesired=KEY_ALL_ACCESS, LPSECURITY_ATTRIBUTES lpsa=NULL );
    CSimpleReg(void);
    CSimpleReg(const CSimpleReg &other);
    virtual ~CSimpleReg(void);
    CSimpleReg &operator=(const CSimpleReg &other );

    // Open and close
    bool Open(void);
    bool Close(void);
    bool Flush(void);

    // Key and value information
    DWORD Size( const CSimpleString &key ) const;
    DWORD Type( const CSimpleString &key ) const;
    DWORD SubKeyCount(void) const;

    // Query functions
    CSimpleString Query( const CSimpleString &strValueName, const CSimpleString &strDef ) const;
    LPTSTR        Query( const CSimpleString &strValueName, const CSimpleString &strDef, LPTSTR pszBuffer, DWORD nLen ) const;
    DWORD         Query( const CSimpleString &strValueName, DWORD nDef ) const;
    DWORD         QueryBin( const CSimpleString &strValueName, PBYTE pData, DWORD nMaxLen ) const;

    // Set functions
    bool Set( const CSimpleString &strValueName, const CSimpleString &strValue, DWORD nType=REG_SZ ) const;
    bool Set( const CSimpleString &strValueName, DWORD nValue ) const;
    bool SetBin( const CSimpleString &strValueName, const PBYTE pValue, DWORD nLen, DWORD dwType = REG_BINARY ) const;

    // Delete a value
    bool Delete( const CSimpleString &strValue );

    // Some static helpers
    static bool IsStringValue( DWORD nType );
    static HKEY GetHkeyFromName( const CSimpleString &strName );
    static bool Delete( HKEY hkRoot, const CSimpleString &stKeyName );
    static bool DeleteRecursively( HKEY hkRoot, const CSimpleString &strKeyName );

    // Inline accessor functions
    const LPSECURITY_ATTRIBUTES GetSecurityAttributes(void) const
    {
        return(m_lpsaSecurityAttributes);
    }
    CSimpleString GetSubKeyName(void) const
    {
        return(m_strKeyName);
    }
    bool GetCreate(void) const
    {
        return(m_bCreate);
    }
    HKEY GetRootKey(void) const
    {
        return(m_hRootKey);
    }
    HKEY GetKey(void) const
    {
        return(m_hKey);
    }
    REGSAM DesiredAccess(void) const
    {
        return m_samDesiredAccess;
    }

    // Status
    bool OK(void) const
    {
        return(m_hRootKey && m_hKey);
    }
    operator bool(void) const
    {
        return(OK());
    }

    operator HKEY(void) const
    {
        return(GetKey());
    }

    // Enumeration and recursion
    bool EnumValues( SimRegValueEnumProc enumProc, LPARAM lParam = 0 );
    bool RecurseKeys( SimRegKeyEnumProc enumProc, LPARAM lParam = 0, int recurseOrder = CSimpleReg::PostOrder, bool bFailOnOpenError = true ) const;
    bool EnumKeys( SimRegKeyEnumProc enumProc, LPARAM lParam = 0, bool bFailOnOpenError = true ) const;

protected:
    // Recursion and enumeration implementation
    static bool DoRecurseKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, int nLevel, int recurseOrder, bool bFailOnOpenError );
    static bool DoEnumKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, bool bFailOnOpenError );

    // Recursion proc that allows us to recursively nuke a registry tree
    static bool DeleteEnumKeyProc( CSimpleReg::CKeyEnumInfo &enumInfo );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\sources.inc ===
TARGETPATH=$(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)

INCLUDES=   $(INCLUDES);                      \
            $(PROJECT_ROOT)\inc;              \
            $(PROJECT_ROOT)\inc\psutil;       \
            $(BASEDIR)\public\sdk\inc\gdiplus;\
            $(SHELL_INC_PATH);

TARGETNAME=psutil
TARGETTYPE=LIBRARY

USE_STL=1

USE_ATL=1
ATL_VER=30

#
# Necessary for gdiplus
#
C_DEFINES=$(C_DEFINES) \
    -DDCR_USE_NEW_105760 \
    -DDCR_USE_NEW_125467 \
    -DDCR_USE_NEW_127084 \
    -DDCR_USE_NEW_135429 \
    -DDCR_USE_NEW_137252 \
    -DDCR_USE_NEW_140782 \
    -DDCR_USE_NEW_140855 \
    -DDCR_USE_NEW_140857 \
    -DDCR_USE_NEW_140861 \
    -DDCR_USE_NEW_145135 \
    -DDCR_USE_NEW_145138 \
    -DDCR_USE_NEW_145139 \
    -DDCR_USE_NEW_145804 \
    -DDCR_USE_NEW_146933 \
    -DDCR_USE_NEW_152154 \
    -DDCR_USE_NEW_168772 \
    -DDCR_USE_NEW_174340 \
    -DDCR_USE_NEW_175866 \
    -DDCR_USE_NEW_186091 \
    -DDCR_USE_NEW_186151 \
    -DDCR_USE_NEW_186764 \
    -DDCR_USE_NEW_188922 \
    -DDCR_USE_NEW_197819 \
    -DDCR_USE_NEW_202903 \
    -DDCR_USE_NEW_235072 \
    -DDCR_USE_NEW_250932 \
    -DDCR_USE_NEW_284635 \
    -DDCR_USE_NEW_284841 \
    -DDCR_USE_NEW_293849 \
    -DDCR_USE_NEW_299162

SOURCES=..\wiadbgcl.cpp \
        ..\gphelper.cpp \
        ..\tmplutil.cpp \
        ..\simreg.cpp   \
        ..\fusutils.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for common UI library
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <atlbase.h>
#include <propidl.h>

// some common headers
#include <shlobj.h>         // shell OM interfaces
#include <shlwapi.h>        // shell common API
#include <winspool.h>       // spooler
#include <assert.h>         // assert
#include <commctrl.h>       // common controls
#include <lm.h>             // Lan manager (netapi32.dll)
#include <wininet.h>        // inet core - necessary for INTERNET_MAX_HOST_NAME_LENGTH

// some private shell headers
#include <shlwapip.h>       // private shell common API
#include <shpriv.h>         // private shell interfaces
#include <iepriv.h>         // private ie interfaces
#include <comctrlp.h>       // private common controls

// GDI+
#include <gdiplus.h>        // GDI+ headers
#include <gdiplusinit.h>    // GDI+ init headers

// STL
#include <algorithm>        // STL algorithms

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\tmplutil.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       tmplutil.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      LazarI
 *
 *  DATE:        10-Mar-2000
 *
 *  DESCRIPTION: Smart pointers, utility templates, etc...
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*****************************************************************************

    IMPORTANT!
    all those headers should be included in the pch file before including tmplutil.h
    (in the same order!) in order to be able to compile this file.

// some common headers
#include <shlobj.h>         // shell OM interfaces
#include <shlwapi.h>        // shell common API
#include <winspool.h>       // spooler
#include <assert.h>         // assert
#include <commctrl.h>       // common controls
#include <lm.h>             // Lan manager (netapi32.dll)
#include <wininet.h>        // inet core - necessary for INTERNET_MAX_HOST_NAME_LENGTH

// some private shell headers
#include <shlwapip.h>       // private shell common API
#include <shpriv.h>         // private shell interfaces
#include <comctrlp.h>       // private common controls

 *****************************************************************************/

#include "tmplutil.h"

#define gszBackwardSlash        TEXT('\\')
#define gszLeadingSlashes       TEXT("\\\\")

/*****************************************************************************

    COMObjects_GetCount

 *****************************************************************************/

static LONG g_lCOMObjectsCount = 0;

LONG COMObjects_GetCount()
{
    return g_lCOMObjectsCount;
}

HRESULT PinCurrentDLL()
{
    HRESULT hr = S_OK;
    HINSTANCE hModuleSelf = NULL;

    // Let's get the handle of the current module - 
    // the one this function belongs to.
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(reinterpret_cast<LPCVOID>(PinCurrentDLL), &mbi, sizeof(mbi)))
    {
        hModuleSelf = reinterpret_cast<HINSTANCE>(mbi.AllocationBase);
    }
    else
    {
        // VirtualQuery failed.
        hr = CreateHRFromWin32();
    }

    if (SUCCEEDED(hr))
    {
        // Get the module name and call LoadLibrary on it.
        TCHAR szModuleName[MAX_PATH];
        if (GetModuleFileName(hModuleSelf, szModuleName, ARRAYSIZE(szModuleName)))
        {
            if (NULL == LoadLibrary(szModuleName))
            {
                // LoadLibrary failed.
                hr = CreateHRFromWin32();
            }
        }
        else
        {
            // GetModuleFileName failed.
            hr = CreateHRFromWin32();
        }
    }
    
    return hr;
}

/*****************************************************************************

    PrinterSplitFullName

Routine Description:

    splits a fully qualified printer connection name into server and printer name parts.

Arguments:
    pszFullName - full qualifier printer name ('printer' or '\\server\printer')
    pszBuffer   - scratch buffer used to store output strings.
    nMaxLength  - the size of the scratch buffer in characters
    ppszServer  - receives pointer to the server string.  If it is a
                  local printer, empty string is returned.
    ppszPrinter - receives a pointer to the printer string.  OPTIONAL

Return Value:

    returns S_OK on sucess or COM error otherwise

 *****************************************************************************/

HRESULT PrinterSplitFullName(LPCTSTR pszFullName, TCHAR szBuffer[], int nMaxLength, LPCTSTR *ppszServer,LPCTSTR *ppszPrinter)
{
    HRESULT hr = S_OK;
    lstrcpyn(szBuffer, pszFullName, nMaxLength);

    LPTSTR pszPrinter = szBuffer;
    if (pszFullName[0] != TEXT('\\') || pszFullName[1] != TEXT('\\'))
    {
        pszPrinter = szBuffer;
        *ppszServer = TEXT("");
    }
    else
    {
        *ppszServer = szBuffer;
        pszPrinter = _tcschr(*ppszServer + 2, TEXT('\\'));

        if (NULL == pszPrinter)
        {
            //
            // We've encountered a printer called "\\server"
            // (only two backslashes in the string).  We'll treat
            // it as a local printer.  We should never hit this,
            // but the spooler doesn't enforce this.  We won't
            // format the string.  Server is local, so set to szNULL.
            //
            pszPrinter = szBuffer;
            *ppszServer = TEXT("");
        }
        else
        {
            //
            // We found the third backslash; null terminate our
            // copy and set bRemote TRUE to format the string.
            //
            *pszPrinter++ = 0;
        }
    }

    if (ppszPrinter)
    {
        *ppszPrinter = pszPrinter;
    }

    return hr;
}

////////////////////////////////////////////////
//
// class COleComInitializer
//
// smart OLE2, COM initializer - just declare
// an instance wherever need to use COM, OLE2
//
COleComInitializer::COleComInitializer(BOOL bOleInit)
    : m_hr(E_FAIL),
      m_bOleInit(bOleInit)
{
    if( m_bOleInit )
    {
        m_hr = OleInitialize(NULL);
    }
    else
    {
        m_hr = CoInitialize(NULL);
    }
}

COleComInitializer::~COleComInitializer()
{
    if( SUCCEEDED(m_hr) )
    {
        if( m_bOleInit )
        {
            OleUninitialize();
        }
        else
        {
            CoUninitialize();
        }
    }
}

COleComInitializer::operator BOOL () const
{
    if( FAILED(m_hr) )
    {
        return (RPC_E_CHANGED_MODE == m_hr);
    }
    else
    {
        return TRUE;
    }
}

////////////////////////////////////////////////
//
// class CDllLoader
//
// smart DLL loader - calls LoadLibrary
// FreeLibrary for you.
//
CDllLoader::CDllLoader(LPCTSTR pszDllName)
    : m_hLib(NULL)
{
    m_hLib = LoadLibrary(pszDllName);
}

CDllLoader::~CDllLoader()
{
    if( m_hLib )
    {
        FreeLibrary( m_hLib );
        m_hLib = NULL;
    }
}

CDllLoader::operator BOOL () const
{
    return (NULL != m_hLib);
}

FARPROC CDllLoader::GetProcAddress( LPCSTR lpProcName )
{
    if( m_hLib )
    {
        return ::GetProcAddress( m_hLib, lpProcName );
    }
    return NULL;
}

FARPROC CDllLoader::GetProcAddress( WORD wProcOrd )
{
    if( m_hLib )
    {
        return ::GetProcAddress( m_hLib, (LPCSTR)MAKEINTRESOURCE(wProcOrd) );
    }
    return NULL;
}

////////////////////////////////////////////////
// class CCookiesHolder
//
// this a utility class which allows us to pass more
// than one pointer through a single cookie.
//
CCookiesHolder::CCookiesHolder()
    : m_pCookies(NULL),
      m_uCount(0)
{
}

CCookiesHolder::CCookiesHolder(UINT uCount)
    : m_pCookies(NULL),
      m_uCount(0)
{
    SetCount(uCount);
}

CCookiesHolder::~CCookiesHolder()
{
    SetCount(0);
}

BOOL CCookiesHolder::SetCount(UINT uCount)
{
    BOOL bReturn = FALSE;

    if( uCount )
    {
        // reset first
        SetCount(0);

        // attempt to allocate memory for the cookies
        LPVOID *pCookies = new LPVOID[uCount];
        if( pCookies )
        {
            m_uCount = uCount;
            m_pCookies = pCookies;

            bReturn = TRUE;
        }
    }
    else
    {
        // zero means - reset
        if( m_pCookies )
        {
            delete[] m_pCookies;
            m_pCookies = NULL;
            m_uCount = 0;
        }

        bReturn = TRUE;
    }

    return bReturn;
}

////////////////////////////////////////////////
// class CPrintersAutoCompleteSource
//
// printer's autocomplete source impl.
//

QITABLE_DECLARE(CPrintersAutoCompleteSource)
class CPrintersAutoCompleteSource: public CUnknownMT<QITABLE_GET(CPrintersAutoCompleteSource)>, // MT impl. of IUnknown
                                   public IEnumString, // string enumerator
                                   public IACList // autocomplete list generator
{
public:
    CPrintersAutoCompleteSource();
    ~CPrintersAutoCompleteSource();

    //////////////////
    // IUnknown
    //
    IMPLEMENT_IUNKNOWN()

    //////////////////
    // IEnumString
    //
    STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumString **ppenum)    { return E_NOTIMPL; }

    //////////////////
    // IACList
    //
    STDMETHODIMP Expand(LPCOLESTR pszExpand);

private:
    CAutoPtrArray<BYTE> m_spBufferPrinters;
    CAutoPtrArray<BYTE> m_spBufferShares;
    PRINTER_INFO_5 *m_pPI5;
    SHARE_INFO_1 *m_pSI1;
    ULONG m_ulCount;
    ULONG m_ulPos;
    TCHAR m_szServer[PRINTER_MAX_PATH];
    CRefPtrCOM<IEnumString> m_spCustomMRUEnum;

    BOOL _IsServerName(LPCTSTR psz, BOOL *pbPartial);
    static BOOL _IsMasqPrinter(const PRINTER_INFO_5 &pi5);
    static HRESULT _CreateCustomMRU(REFIID riid, void **ppv);
    static HRESULT _AddCustomMRU(LPCTSTR psz);
};

// QueryInterface table
QITABLE_BEGIN(CPrintersAutoCompleteSource)
     QITABENT(CPrintersAutoCompleteSource, IEnumString),        // IID_IEnumString
     QITABENT(CPrintersAutoCompleteSource, IACList),            // IID_IACList
QITABLE_END()

#define SZ_REGKEY_PRNCONNECTMRU         L"Printers\\Settings\\Wizard\\ConnectMRU"

// comctrlp.h defines this as AddMRUStringW preventing us from using the IACLCustomMRU interface
#undef  AddMRUString

HRESULT CPrintersACS_CreateInstance(IUnknown **ppUnk)
{
    HRESULT hr = E_INVALIDARG;

    if( ppUnk )
    {
        hr = PinCurrentDLL();

        if( SUCCEEDED(hr) )
        {
            CPrintersAutoCompleteSource *pObj = new CPrintersAutoCompleteSource();
            hr = pObj ? S_OK : E_OUTOFMEMORY;

            if( SUCCEEDED(hr) )
            {
                hr = pObj->QueryInterface(IID_IUnknown, (void**)ppUnk);
                pObj->Release();
            }
        }
    }

    return hr;
}

CPrintersAutoCompleteSource::CPrintersAutoCompleteSource():
    m_pPI5(NULL),
    m_ulCount(0),
    m_ulPos(0)
{
    InterlockedIncrement(&g_lCOMObjectsCount);
}

CPrintersAutoCompleteSource::~CPrintersAutoCompleteSource()
{
    InterlockedDecrement(&g_lCOMObjectsCount);
}

//////////////////
// IUnknown
//
STDMETHODIMP CPrintersAutoCompleteSource::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    if( pceltFetched )
    {
        *pceltFetched = 0;
    }

    if( m_ulCount && (m_pPI5 || m_pSI1) )
    {
        ULONG cFetched = 0;

        if( m_pPI5 )
        {
            // printers enumerated
            for( ; m_ulPos <  m_ulCount && cFetched < celt; m_ulPos++ )
            {
                // if this is a valid (non-masq) printer just return it
                if( m_pPI5[m_ulPos].pPrinterName[0]  && SUCCEEDED(SHStrDup(m_pPI5[m_ulPos].pPrinterName, &rgelt[cFetched])) )
                {
                    cFetched++;
                }
            }
        }
        else
        {
            // shares enumerated
            TCHAR szBuffer[PRINTER_MAX_PATH];
            for( ; m_ulPos <  m_ulCount && cFetched < celt; m_ulPos++ )
            {
                // if this is a valid printer share name, just return it
                if( m_pSI1[m_ulPos].shi1_netname[0] &&
                    -1 != wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s\\%s"),
                    m_szServer, m_pSI1[m_ulPos].shi1_netname) &&
                    SUCCEEDED(SHStrDup(szBuffer, &rgelt[cFetched])) )
                {
                    cFetched++;
                }
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = cFetched;
        }

        hr = cFetched == celt ? S_OK : S_FALSE;
    }
    else
    {
        // use our custom MRU if any...
        if( m_spCustomMRUEnum )
        {
            hr = m_spCustomMRUEnum->Next(celt, rgelt, pceltFetched);
        }
    }

    return hr;
}

STDMETHODIMP CPrintersAutoCompleteSource::Skip(ULONG celt)
{
    HRESULT hr = S_FALSE;
    if( m_ulCount && (m_pPI5 || m_pSI1) )
    {
        hr = ((m_ulPos + celt) <= m_ulCount) ? S_OK : S_FALSE;
        m_ulPos = min(m_ulPos + celt, m_ulCount);
    }
    else
    {
        // use our custom MRU if any...
        if( m_spCustomMRUEnum )
        {
            hr = m_spCustomMRUEnum->Skip(celt);
        }
    }
    return hr;
}

STDMETHODIMP CPrintersAutoCompleteSource::Reset(void)
{
    HRESULT hr = S_OK;
    if( m_ulCount && (m_pPI5 || m_pSI1) )
    {
        m_ulPos = 0;
    }
    else
    {
        // use our custom MRU if any...
        if( m_spCustomMRUEnum )
        {
            hr = m_spCustomMRUEnum->Reset();
        }
    }
    return hr;
}

typedef bool PI5_less_type(const PRINTER_INFO_5 &i1, const PRINTER_INFO_5 &i2);
static  bool PI5_less(const PRINTER_INFO_5 &i1, const PRINTER_INFO_5 &i2)
{
    return (lstrcmp(i1.pPrinterName, i2.pPrinterName) < 0);
}

typedef bool SI1_less_type(const SHARE_INFO_1 &i1, const SHARE_INFO_1 &i2);
static  bool SI1_less(const SHARE_INFO_1 &i1, const SHARE_INFO_1 &i2)
{
    return (lstrcmp(i1.shi1_netname, i2.shi1_netname) < 0);
}

//////////////////
// IACList
//
STDMETHODIMP CPrintersAutoCompleteSource::Expand(LPCOLESTR pszExpand)
{
    HRESULT hr = E_FAIL;
    DWORD cReturned = 0;
    BOOL bPartial = FALSE;

    // assume this is not a server name, so reset the list first
    m_pPI5 = NULL;
    m_pSI1 = NULL;
    m_spBufferPrinters = NULL;
    m_spBufferShares = NULL;
    m_ulCount = m_ulPos = 0;
    m_szServer[0] = 0;
    m_spCustomMRUEnum = NULL;

    if( _IsServerName(pszExpand, &bPartial) )
    {
        // make a copy of the print buffer & cut off the last slash
        TCHAR szBuffer[PRINTER_MAX_PATH];
        lstrcpyn(szBuffer, pszExpand, ARRAYSIZE(szBuffer));
        szBuffer[lstrlen(szBuffer)-1] = 0;

        // enum the printers on that server
        if( SUCCEEDED(hr = ShellServices::EnumPrintersWrap(PRINTER_ENUM_NAME, 5, szBuffer, &m_spBufferPrinters, &cReturned)) && cReturned )
        {
            m_ulPos = 0;
            m_ulCount = cReturned;
            m_pPI5 = m_spBufferPrinters.GetPtrAs<PRINTER_INFO_5*>();
            lstrcpyn(m_szServer, szBuffer, ARRAYSIZE(m_szServer));

            // successful expand - remember the MRU string
            _AddCustomMRU(szBuffer);

            // traverse to check for masq printers
            for( ULONG ulPos = 0; ulPos < m_ulCount; ulPos++ )
            {
                if( _IsMasqPrinter(m_pPI5[ulPos]) )
                {
                    // we don't really care for masq printer's since they are
                    // an obsolete concept and can't be truly shared/connected to
                    m_pPI5[ulPos].pPrinterName = TEXT("");
                }
            }

            // invoke STL to sort
            std::sort<PRINTER_INFO_5*, PI5_less_type*>(m_pPI5, m_pPI5 + m_ulCount, PI5_less);
        }
        else
        {
            // enumeration of the printers failed, this could be because the remote spooler is down
            // or it is a downlevel print provider (win9x, novell, linux, sun...) in this case we
            // would like to try enumerating the shares as possible connection points.
            if( SUCCEEDED(hr = ShellServices::NetAPI_EnumShares(szBuffer, 1, &m_spBufferShares, &cReturned)) && cReturned )
            {
                m_ulPos = 0;
                m_ulCount = cReturned;
                m_pSI1 = m_spBufferShares.GetPtrAs<SHARE_INFO_1*>();
                lstrcpyn(m_szServer, szBuffer, ARRAYSIZE(m_szServer));

                // successful expand - remember the MRU string
                _AddCustomMRU(szBuffer);

                // traverse to remove the non-printer shares
                for( ULONG ulPos = 0; ulPos < m_ulCount; ulPos++ )
                {
                    if( STYPE_PRINTQ != m_pSI1[ulPos].shi1_type )
                    {
                        // this is a non-printer share, remove
                        m_pSI1[ulPos].shi1_netname[0] = 0;
                    }
                }

                // invoke STL to sort
                std::sort<SHARE_INFO_1*, SI1_less_type*>(m_pSI1, m_pSI1 + m_ulCount, SI1_less);

            }
       }
    }
    else
    {
        if( bPartial )
        {
            // use our custom MRU for autocomplete
            hr = _CreateCustomMRU(IID_IEnumString, m_spCustomMRUEnum.GetPPV());
        }
    }

    return hr;
}

BOOL CPrintersAutoCompleteSource::_IsServerName(LPCTSTR psz, BOOL *pbPartial)
{
    ASSERT(pbPartial);
    BOOL bRet = FALSE;
    int i, iSepCount = 0, iLen = lstrlen(psz);

    for( i=0; i<iLen; i++ )
    {
        if( psz[i] == gszBackwardSlash )
        {
            iSepCount++;
        }
    }

    if( (1 == iSepCount && psz[0] == gszBackwardSlash) ||
        (2 == iSepCount && psz[0] == gszBackwardSlash && psz[1] == gszBackwardSlash) )
    {
        *pbPartial = TRUE;
    }


    if( 3 < iLen &&
        3 == iSepCount &&
        psz[0] == gszBackwardSlash &&
        psz[1] == gszBackwardSlash &&
        psz[iLen-1] == gszBackwardSlash )
    {
        bRet = TRUE;
    }

    return bRet;
}

BOOL CPrintersAutoCompleteSource::_IsMasqPrinter(const PRINTER_INFO_5 &pi5)
{
    // this is a little bit hacky, but there is no other way to tell the masq printer
    // in the remote case. the spooler APIs suffer from some severe design flaws and
    // we have to put up with that.
    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[PRINTER_MAX_PATH];

    // split the full printer name into its components.
    if( SUCCEEDED(PrinterSplitFullName(pi5.pPrinterName,
        szScratch, ARRAYSIZE(szScratch), &pszServer, &pszPrinter)) )
    {
        return (0 == _tcsnicmp(pszPrinter, gszLeadingSlashes, _tcslen(gszLeadingSlashes)));
    }
    else
    {
        return FALSE;
    }
}

HRESULT CPrintersAutoCompleteSource::_CreateCustomMRU(REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    CRefPtrCOM<IACLCustomMRU> spCustomMRU;
    if( ppv &&
        SUCCEEDED(hr = CoCreateInstance(CLSID_ACLCustomMRU, NULL,
        CLSCTX_INPROC_SERVER, IID_IACLCustomMRU, spCustomMRU.GetPPV())) &&
        SUCCEEDED(hr = spCustomMRU->Initialize(SZ_REGKEY_PRNCONNECTMRU, 26)) )

    {
        // query the specified interface
        hr = spCustomMRU->QueryInterface(riid, ppv);
    }
    return hr;
}

HRESULT CPrintersAutoCompleteSource::_AddCustomMRU(LPCTSTR psz)
{
    HRESULT hr = E_INVALIDARG;
    CRefPtrCOM<IACLCustomMRU> spCustomMRU;
    if( psz &&
        SUCCEEDED(hr = _CreateCustomMRU(IID_IACLCustomMRU, spCustomMRU.GetPPV())) )
    {
        // just remember the MRU string
        hr = spCustomMRU->AddMRUString(psz);
    }
    return hr;
}

////////////////////////////////////////////////
// shell related services
namespace ShellServices
{

// creates a PIDL to a printer in the local printers folder by using ParseDisplayName
// see the description of CreatePrinterPIDL below.
HRESULT CreatePrinterPIDL_Parse(HWND hwnd, LPCTSTR pszPrinterName, IShellFolder **ppLocalPrnFolder, LPITEMIDLIST *ppidlPrinter)
{
    HRESULT                   hr = E_UNEXPECTED;
    CRefPtrCOM<IShellFolder>  spDesktopFolder;
    CRefPtrCOM<IShellFolder>  spPrnFolder;
    CAutoPtrPIDL              pidlPrinters;
    CAutoPtrPIDL              pidlPrinter;

    // attempt to get the fully qualified name (for parsing) of the printers folder
    if( SUCCEEDED(hr = SHGetDesktopFolder(&spDesktopFolder)) &&
        SUCCEEDED(hr = SHGetSpecialFolderLocation(NULL, CSIDL_PRINTERS, &pidlPrinters)) &&
        SUCCEEDED(hr = spDesktopFolder->BindToObject(pidlPrinters, 0, IID_IShellFolder, spPrnFolder.GetPPV())) )
    {
        ULONG uEaten = 0;
        ULONG uAttributes = SFGAO_DROPTARGET;

        // attempt parse the printer name into PIDL
        hr = spPrnFolder->ParseDisplayName(hwnd, 0, (LPOLESTR )pszPrinterName,
            &uEaten, &pidlPrinter, &uAttributes);

        if( SUCCEEDED(hr) )
        {
            if( ppLocalPrnFolder )
            {
                // return the local printers folder
                *ppLocalPrnFolder = spPrnFolder.Detach();
            }

            if( ppidlPrinter )
            {
                // return the printer PIDL
                *ppidlPrinter = pidlPrinter.Detach();
            }
        }
    }

    return hr;
}

// creates a PIDL to a printer in the local printers folder by enumerating the printers
// see the description of CreatePrinterPIDL below.
HRESULT CreatePrinterPIDL_Enum(HWND hwnd, LPCTSTR pszPrinterName, IShellFolder **ppLocalPrnFolder, LPITEMIDLIST *ppidlPrinter)
{
    HRESULT                      hr = E_UNEXPECTED;
    CRefPtrCOM<IShellFolder>     spDesktopFolder;
    CRefPtrCOM<IShellFolder>     spPrnFolder;
    CRefPtrCOM<IEnumIDList>      spPrnEnum;
    CAutoPtrPIDL                 pidlPrinters;
    STRRET                       str = {0};

    // attempt to get the fully qualified name (for parsing) of the printers folder
    if( SUCCEEDED(hr = SHGetDesktopFolder(&spDesktopFolder)) &&
        SUCCEEDED(hr = SHGetSpecialFolderLocation(NULL, CSIDL_PRINTERS, &pidlPrinters)) &&
        SUCCEEDED(hr = spDesktopFolder->BindToObject(pidlPrinters, 0, IID_IShellFolder, spPrnFolder.GetPPV())) &&
        SUCCEEDED(hr = spPrnFolder->EnumObjects(hwnd, SHCONTF_NONFOLDERS, &spPrnEnum)) )
    {
        TCHAR szBuffer[PRINTER_MAX_PATH];
        CAutoPtrPIDL pidlPrinter;
        ULONG uFetched = 0;

        for( ;; )
        {
            // get next printer
            hr = spPrnEnum->Next(1, &pidlPrinter, &uFetched);

            if( S_OK != hr )
            {
                // no more printers, or error
                break;
            }

            if( SUCCEEDED(hr = spPrnFolder->GetDisplayNameOf(pidlPrinter, SHGDN_FORPARSING, &str)) &&
                SUCCEEDED(hr = StrRetToBuf(&str, pidlPrinter, szBuffer, COUNTOF(szBuffer))) &&
                !lstrcmp(szBuffer, pszPrinterName) )
            {
                // found!
                if( ppLocalPrnFolder )
                {
                    // return the local printers folder
                    *ppLocalPrnFolder = spPrnFolder.Detach();
                }
                if( ppidlPrinter )
                {
                    // return the printer PIDL
                    *ppidlPrinter = pidlPrinter.Detach();
                }
                break;
            }

            // release the PIDL
            pidlPrinter = NULL;
        }

        if( hr == S_FALSE )
        {
            // printer name not found. setup the correct HRESULT.
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PRINTER_NAME);
        }
    }

    return hr;
}

// creates a PIDL to a printer in the local printers folder.
// args:
//  [in]    hwnd - window handle (in case we need to show UI - message box)
//  [in]    pszPrinterName - full printer name.
//  [out]   ppLocalPrnFolder - the printers folder (optional - may be NULL)
//  [out]   ppidlPrinter - the PIDL of the printer pointed by pszPrinterName (optional - may be NULL)
//
// remarks:
//  pszPrinterName should be fully qualified printer name, i.e. if printer connection it should be
//  like "\\server\printer", if local printer just the printer name.
//
// returns:
//  S_OK on success, or OLE2 error otherwise

HRESULT CreatePrinterPIDL(HWND hwnd, LPCTSTR pszPrinterName, IShellFolder **ppLocalPrnFolder, LPITEMIDLIST *ppidlPrinter)
{
    // attempt to obtain the printer PIDL by parsing first - it's much quicker.
    HRESULT hr = CreatePrinterPIDL_Parse(hwnd, pszPrinterName, ppLocalPrnFolder, ppidlPrinter);

    if( E_NOTIMPL == hr )
    {
        // if parsing is not implemented then go ahead and enum the printers - slower.
        hr = CreatePrinterPIDL_Enum(hwnd, pszPrinterName, ppLocalPrnFolder, ppidlPrinter);
    }

    return hr;
}

// loads a popup menu
HMENU LoadPopupMenu(HINSTANCE hInstance, UINT id, UINT uSubOffset)
{
    HMENU hMenuPopup = NULL;
    CAutoHandleMenu shMenuParent = LoadMenu(hInstance, MAKEINTRESOURCE(id));
    if( shMenuParent && (hMenuPopup = GetSubMenu(shMenuParent, uSubOffset)) )
    {
        // tear off our submenu before destroying the parent
        RemoveMenu(shMenuParent, uSubOffset, MF_BYPOSITION);
    }
    return hMenuPopup;
}

// initializes enum printer's autocomplete
HRESULT InitPrintersAutoComplete(HWND hwndEdit)
{
    HRESULT hr = E_INVALIDARG;

    if( hwndEdit )
    {
        // create an autocomplete object
        CRefPtrCOM<IAutoComplete>   spAC;   // auto complete interface
        CRefPtrCOM<IAutoComplete2>  spAC2;  // auto complete 2 interface
        CRefPtrCOM<IUnknown>        spACS;  // auto complete source (IEnumString & IACList)

        // initialize all the objects & hook them up
        if( SUCCEEDED(hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER,
                IID_IAutoComplete, (void**)&spAC)) &&
            SUCCEEDED(hr = CPrintersACS_CreateInstance(&spACS)) &&
            SUCCEEDED(hr = spAC->Init(hwndEdit, spACS, NULL, NULL)) &&
            SUCCEEDED(hr = spAC->QueryInterface(IID_IAutoComplete2, (void **)&spAC2)) &&
            SUCCEEDED(hr = spAC2->SetOptions(ACO_AUTOSUGGEST)) )
        {
            hr = S_OK;
        }
    }

    return hr;
}

// helpers for the Enum* idioms
HRESULT EnumPrintersWrap(DWORD dwFlags, DWORD dwLevel, LPCTSTR pszName, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        int iTry = -1;
        DWORD cbNeeded = 0;
        DWORD cReturned = 0;
        CAutoPtrArray<BYTE> pData;
        BOOL bStatus = FALSE;

        for( ;; )
        {
            if( iTry++ >= ENUM_MAX_RETRY )
            {
                // max retry count reached. this is also
                // considered out of memory case
                pData = NULL;
                break;
            }

            // call EnumPrinters...
            bStatus = EnumPrinters(dwFlags, const_cast<LPTSTR>(pszName), dwLevel,
                pData, cbNeeded, &cbNeeded, &cReturned);

            if( !bStatus && ERROR_INSUFFICIENT_BUFFER == GetLastError() && cbNeeded )
            {
                // buffer too small case
                pData = new BYTE[cbNeeded];
                continue;
            }

            break;
        }

        // setup the error code properly
        hr = bStatus ? S_OK : GetLastError() != ERROR_SUCCESS ? HRESULT_FROM_WIN32(GetLastError()) :
             !pData ? E_OUTOFMEMORY : E_FAIL;

        // setup the out parameters
        if( SUCCEEDED(hr) )
        {
            *ppBuffer = pData.Detach();
            *pcReturned = cReturned;
        }
        else
        {
            *ppBuffer = NULL;
            *pcReturned = 0;
        }
    }

    return hr;
}

// helpers for the GetJob API - see the SDK for mor information.
HRESULT GetJobWrap(HANDLE hPrinter, DWORD JobId, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        int iTry = -1;
        DWORD cbNeeded = 0;
        CAutoPtrArray<BYTE> pData;
        BOOL bStatus = FALSE;

        for( ;; )
        {
            if( iTry++ >= ENUM_MAX_RETRY )
            {
                // max retry count reached. this is also
                // considered out of memory case
                pData = NULL;
                break;
            }

            // call GetJob...
            bStatus = GetJob(hPrinter, JobId, dwLevel, pData, cbNeeded, &cbNeeded);

            if( !bStatus && ERROR_INSUFFICIENT_BUFFER == GetLastError() && cbNeeded )
            {
                // buffer too small case
                pData = new BYTE[cbNeeded];
                continue;
            }

            break;
        }

        // setup the error code properly
        hr = bStatus ? S_OK : GetLastError() != ERROR_SUCCESS ? HRESULT_FROM_WIN32(GetLastError()) :
             !pData ? E_OUTOFMEMORY : E_FAIL;

        // setup the out parameters
        if( SUCCEEDED(hr) )
        {
            *ppBuffer = pData.Detach();
            *pcReturned = cbNeeded;
        }
        else
        {
            *ppBuffer = NULL;
            *pcReturned = 0;
        }
    }

    return hr;
}

typedef NET_API_STATUS
type_NetAPI_NetShareEnum(
  LPWSTR servername,
  DWORD level,
  LPBYTE *bufptr,
  DWORD prefmaxlen,
  LPDWORD entriesread,
  LPDWORD totalentries,
  LPDWORD resume_handle
);

typedef NET_API_STATUS
type_NetAPI_NetApiBufferFree(
  LPVOID Buffer
);

typedef NET_API_STATUS
type_NetAPI_NetApiBufferSize(
  LPVOID Buffer,
  LPDWORD ByteCount
);

// enumerates the shared resources on a server, for more info see SDK for NetShareEnum API.
HRESULT NetAPI_EnumShares(LPCTSTR pszServer, DWORD dwLevel, BYTE **ppBuffer, DWORD *pcReturned)
{
    HRESULT hr = E_INVALIDARG;

    if( ppBuffer && pcReturned )
    {
        hr = E_FAIL;

        *pcReturned = 0;
        *ppBuffer = NULL;

        LPBYTE pNetBuf = NULL;
        DWORD dwRead, dwTemp;

        CDllLoader dll(TEXT("netapi32.dll"));
        if( dll )
        {
            // netapi32.dll loaded here...
            type_NetAPI_NetShareEnum *pfnNetShareEnum = (type_NetAPI_NetShareEnum *)dll.GetProcAddress("NetShareEnum");
            type_NetAPI_NetApiBufferSize *pfnNetApiBufferSize = (type_NetAPI_NetApiBufferSize *)dll.GetProcAddress("NetApiBufferSize");
            type_NetAPI_NetApiBufferFree *pfnNetApiBufferFree = (type_NetAPI_NetApiBufferFree *)dll.GetProcAddress("NetApiBufferFree");

            if( pfnNetShareEnum && pfnNetApiBufferSize && pfnNetApiBufferFree &&
                NERR_Success == pfnNetShareEnum(const_cast<LPTSTR>(pszServer), dwLevel,
                &pNetBuf, MAX_PREFERRED_LENGTH, &dwRead, &dwTemp, NULL) &&
                dwRead && pNetBuf &&
                NERR_Success == pfnNetApiBufferSize(pNetBuf, &dwTemp) )

            {
                *ppBuffer = new BYTE[dwTemp];
                if( *ppBuffer )
                {
                    // copy the bits first
                    memcpy(*ppBuffer, pNetBuf, dwTemp);

                    // adjust the pointers here - a little bit ugly, but works
                    for( DWORD dw = 0; dw < dwRead; dw++ )
                    {
                        // adjust shi1_netname
                        reinterpret_cast<SHARE_INFO_1*>(*ppBuffer)[dw].shi1_netname =
                            reinterpret_cast<LPWSTR>(
                                (*ppBuffer) +
                                (reinterpret_cast<BYTE*>(
                                    reinterpret_cast<SHARE_INFO_1*>(pNetBuf)[dw].shi1_netname) -
                                    pNetBuf));

                        // adjust shi1_remark
                        reinterpret_cast<SHARE_INFO_1*>(*ppBuffer)[dw].shi1_remark =
                            reinterpret_cast<LPWSTR>(
                                (*ppBuffer) +
                                (reinterpret_cast<BYTE*>(
                                    reinterpret_cast<SHARE_INFO_1*>(pNetBuf)[dw].shi1_remark) -
                                    pNetBuf));
                    }

                    // number of structures returned
                    *pcReturned = dwRead;
                }
                hr = ((*ppBuffer) ? S_OK : E_OUTOFMEMORY);
                CHECK(NERR_Success == pfnNetApiBufferFree(pNetBuf));
            }
        }
    }

    if( E_FAIL == hr && ERROR_SUCCESS != GetLastError() )
    {
        // if failed, let's be more spcific about what the error is...
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

} // namespace ShellServices

// utility functions
HRESULT LoadXMLDOMDoc(LPCTSTR pszURL, IXMLDOMDocument **ppXMLDoc)
{
    HRESULT hr = E_INVALIDARG;
    CRefPtrCOM<IXMLDOMDocument> spXMLDoc;

    if( pszURL && ppXMLDoc )
    {
        *ppXMLDoc = NULL;

        // create an instance of XMLDOM
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)&spXMLDoc);

        if( SUCCEEDED(hr) )
        {
            CComVariant xmlSource(pszURL);
            if( VT_BSTR == xmlSource.vt )
            {
                // just load the XML document here
                VARIANT_BOOL fIsSuccessful = VARIANT_TRUE;
                hr = spXMLDoc->load(xmlSource, &fIsSuccessful);

                if( S_FALSE == hr || VARIANT_FALSE == fIsSuccessful )
                {
                    // this isn't a valid XML file.
                    hr = E_FAIL;
                }
                else
                {
                    // everything looks successful here - just return the XML document
                    *ppXMLDoc = spXMLDoc.Detach();
                }
            }
            else
            {
                // xmlSource failed to allocate the string
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT CreateStreamFromURL(LPCTSTR pszURL, IStream **pps)
{
    HRESULT hr = E_INVALIDARG;
    if( pszURL && pps )
    {
        *pps = NULL;
        TCHAR szBuf[INTERNET_MAX_SCHEME_LENGTH];
        DWORD cch = ARRAYSIZE(szBuf);


        if( SUCCEEDED(hr = CoInternetParseUrl(pszURL, PARSE_SCHEMA, 0, szBuf, cch, &cch, 0)) &&
            0 == lstrcmp(szBuf, TEXT("res")) )
        {
            // check if this is a res:// URL to handle explicitly since
            // this protocol doesn't report filename and therefore can't
            // be used in conditions where caching is required - we can't
            // call URLOpenBlockingStream - use alternatives.

            // not impl. yet...
            ASSERT(FALSE);
        }

        hr = URLOpenBlockingStream(NULL, pszURL, pps, 0, NULL);
    }
    return hr;
}

HRESULT CreateStreamFromResource(LPCTSTR pszModule, LPCTSTR pszResType, LPCTSTR pszResName, IStream **pps)
{
    HRESULT hr = E_INVALIDARG;
    if( pszResType && pszResName )
    {
        hr = E_FAIL;
        *pps = NULL;

        HINSTANCE hModule = NULL;
        if( (NULL == pszModule) || (hModule = LoadLibrary(pszModule)) )
        {
            HRSRC hHint = NULL;
            ULONG uSize = 0;

            if( (hHint = FindResource(hModule, pszResName, pszResType)) &&
                (uSize = SizeofResource(hModule, hHint)) )
            {
                HGLOBAL hResData = LoadResource(hModule, hHint);
                if( hResData )
                {
                    LPVOID lpResData = LockResource(hResData);
                    if( lpResData )
                    {
                        if( (*pps = SHCreateMemStream(reinterpret_cast<LPBYTE>(lpResData), uSize)) )
                        {
                            hr = S_OK;
                        }
                        UnlockResource(lpResData);
                    }
                    FreeResource(hResData);
                }
            }
        }

        if( hModule )
        {
            FreeLibrary(hModule);
        }
    }
    return hr;
}

HRESULT Gdiplus2HRESULT(Gdiplus::Status status)
{
    // can't think of a better way to do this now
    HRESULT hr = E_FAIL;

    switch( status )
    {
        case Gdiplus::Ok:
            hr = S_OK;
            break;

        case Gdiplus::InvalidParameter:
            hr = E_INVALIDARG;
            break;

        case Gdiplus::OutOfMemory:
            hr = E_OUTOFMEMORY;
            break;

        case Gdiplus::InsufficientBuffer:
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            break;

        case Gdiplus::Aborted:
            hr = E_ABORT;
            break;

        case Gdiplus::ObjectBusy:
            hr = E_PENDING;
            break;

        case Gdiplus::FileNotFound:
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            break;

        case Gdiplus::AccessDenied:
            hr = E_ACCESSDENIED;
            break;

        case Gdiplus::UnknownImageFormat:
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PIXEL_FORMAT);
            break;

        case Gdiplus::NotImplemented:
            hr = E_NOTIMPL;
            break;

        case Gdiplus::Win32Error:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        case Gdiplus::ValueOverflow:
        case Gdiplus::FontFamilyNotFound:
        case Gdiplus::FontStyleNotFound:
        case Gdiplus::NotTrueTypeFont:
        case Gdiplus::UnsupportedGdiplusVersion:
        case Gdiplus::GdiplusNotInitialized:
        case Gdiplus::WrongState:
            break;
    }

    return hr;
}

HRESULT LoadAndScaleBmp(LPCTSTR pszURL, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp)
{
    CRefPtrCOM<IStream> spStream;
    HRESULT hr = CreateStreamFromURL(pszURL, &spStream);
    if( SUCCEEDED(hr) )
    {
        hr = LoadAndScaleBmp(spStream, nWidth, nHeight, ppBmp);
    }
    return hr;
}

HRESULT LoadAndScaleBmp(IStream *pStream, UINT nWidth, UINT nHeight, Gdiplus::Bitmap **ppBmp)
{
    HRESULT hr = E_INVALIDARG;
    if( pStream && nWidth && nHeight && ppBmp )
    {
        hr = E_FAIL;
        *ppBmp = NULL;

        Gdiplus::Bitmap bmp(pStream);
        if( SUCCEEDED(hr = Gdiplus2HRESULT(bmp.GetLastStatus())) )
        {
            hr = E_OUTOFMEMORY;
            CAutoPtr<Gdiplus::Bitmap> spBmpNew = new Gdiplus::Bitmap(nWidth, nHeight);

            if( spBmpNew && SUCCEEDED(hr = Gdiplus2HRESULT(spBmpNew->GetLastStatus())) )
            {
                Gdiplus::Graphics g(spBmpNew);
                if( SUCCEEDED(hr = Gdiplus2HRESULT(g.GetLastStatus())) )
                {
                    if( SUCCEEDED(hr = g.DrawImage(&bmp, 0, 0, nWidth, nHeight)) )
                    {
                        *ppBmp = spBmpNew.Detach();
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

//
// This function is trying to get the last active popup of the top
// level owner of the current thread active window.
//
HRESULT GetCurrentThreadLastPopup(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if( phwnd )
    {
        hr = E_FAIL;

        if( NULL == *phwnd )
        {
            // if *phwnd is NULL then get the current thread active window
            GUITHREADINFO ti = {0};
            ti.cbSize = sizeof(ti);
            if( GetGUIThreadInfo(0, &ti) && ti.hwndActive )
            {
                *phwnd = ti.hwndActive;
            }
        }

        if( *phwnd )
        {
            HWND hwndOwner, hwndParent;

            // climb up to the top parent in case it's a child window...
            while( hwndParent = GetParent(*phwnd) )
            {
                *phwnd = hwndParent;
            }

            // get the owner in case the top parent is owned
            hwndOwner = GetWindow(*phwnd, GW_OWNER);
            if( hwndOwner )
            {
                *phwnd = hwndOwner;
            }

            // get the last popup of the owner of the top level parent window
            *phwnd = GetLastActivePopup(*phwnd);
            hr = (*phwnd) ? S_OK : E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\gphelper.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GPHELPER.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/11/1999
 *
 *  DESCRIPTION: Encapsulation of common GDI plus operationss
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "gphelper.h"
#include <wiadebug.h>
#include <psutil.h>

using namespace Gdiplus;

CGdiPlusHelper::CGdiPlusHelper(void)
  : m_pImageEncoderInfo(NULL),
    m_nImageEncoderCount(0),
    m_pImageDecoderInfo(NULL),
    m_nImageDecoderCount(0)

{
    Initialize();
}


CGdiPlusHelper::~CGdiPlusHelper(void)
{
    Destroy();
}


HRESULT CGdiPlusHelper::Initialize(void)
{
    WIA_PUSHFUNCTION(TEXT("CGdiPlusHelper::Initialize"));


    //
    // Get the installed encoders
    //
    UINT cbCodecs = 0;
    HRESULT hr = GDISTATUS_TO_HRESULT(GetImageEncodersSize( &m_nImageEncoderCount, &cbCodecs ));
    if (SUCCEEDED(hr))
    {
        if (cbCodecs)
        {
            m_pImageEncoderInfo = static_cast<ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
            if (m_pImageEncoderInfo)
            {
                hr = GDISTATUS_TO_HRESULT(GetImageEncoders( m_nImageEncoderCount, cbCodecs, m_pImageEncoderInfo ));
                if (FAILED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("GetImageEncoders failed")));
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                WIA_PRINTHRESULT((hr,TEXT("LocalAlloc failed")));
            }
        }
        else
        {
            hr = E_INVALIDARG;
            WIA_PRINTHRESULT((hr,TEXT("GetImageEncodersSize succeeded, but cbCodecs was 0")));
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("GetImageEncodersSize failed")));
    }

    //
    // Get the installed decoders
    //
    if (SUCCEEDED(hr))
    {
        cbCodecs = 0;
        hr = GDISTATUS_TO_HRESULT(GetImageDecodersSize( &m_nImageDecoderCount, &cbCodecs ));
        if (SUCCEEDED(hr))
        {
            if (cbCodecs)
            {
                m_pImageDecoderInfo = static_cast<ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
                if (m_pImageDecoderInfo)
                {
                    hr = GDISTATUS_TO_HRESULT(GetImageDecoders( m_nImageDecoderCount, cbCodecs, m_pImageDecoderInfo ));
                    if (FAILED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("GetImageDecoders failed")));
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    WIA_PRINTHRESULT((hr,TEXT("LocalAlloc failed")));
                }
            }
            else
            {
                hr = E_INVALIDARG;
                WIA_PRINTHRESULT((hr,TEXT("GetImageDecodersSize succeeded, but cbCodecs was 0")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("GetImageDecodersSize failed")));
        }
    }

    //
    // If there was a problem, make sure there are no half-initialized things laying around
    //
    if (!SUCCEEDED(hr))
    {
        Destroy();
    }
    return hr;
}



void CGdiPlusHelper::Destroy(void)
{

#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    //
    // Shut down GDI+
    //
    if (m_bGdiplusInitialized)
    {

    }
#endif

    //
    // Free the lists of Encoders and Decoders
    //
    if (m_pImageEncoderInfo)
    {
        LocalFree(m_pImageEncoderInfo);
        m_pImageEncoderInfo = NULL;
    }
    m_nImageEncoderCount = 0;

    if (m_pImageDecoderInfo)
    {
        LocalFree(m_pImageDecoderInfo);
        m_pImageDecoderInfo = NULL;
    }
    m_nImageDecoderCount = 0;
}


bool CGdiPlusHelper::IsValid(void) const
{
    //
    // Make sure we've been completely created
    //
#if defined(GDIPLUSHELPER_EXPLICIT_INITIALIZATION)
    return(m_bGdiplusInitialized && m_pImageEncoderInfo && m_nImageEncoderCount && m_pImageDecoderInfo && m_nImageDecoderCount);
#else
    return(m_pImageEncoderInfo && m_nImageEncoderCount && m_pImageDecoderInfo && m_nImageDecoderCount);
#endif
}


HRESULT CGdiPlusHelper::GetClsidOfEncoder( const GUID &guidFormatId, CLSID &clsidFormat ) const
{
    //
    // Given an image format, find the clsid for the output type
    //
    if (IsValid())
    {
        for (UINT i=0;i<m_nImageEncoderCount;i++)
        {
            if (m_pImageEncoderInfo[i].FormatID == guidFormatId)
            {
                clsidFormat = m_pImageEncoderInfo[i].Clsid;
                return S_OK;
            }
        }
    }
    return E_FAIL;
}


HRESULT CGdiPlusHelper::GetClsidOfDecoder( const GUID &guidFormatId, CLSID &clsidFormat ) const
{
    //
    // Given an image format, find the clsid for the output type
    //
    if (IsValid())
    {
        for (UINT i=0;i<m_nImageDecoderCount;i++)
        {
            if (m_pImageDecoderInfo[i].FormatID == guidFormatId)
            {
                clsidFormat = m_pImageDecoderInfo[i].Clsid;
                return S_OK;
            }
        }
    }
    return E_FAIL;
}


HRESULT CGdiPlusHelper::Convert( LPCWSTR pszInputFilename, LPCWSTR pszOutputFilename, const CLSID &guidOutputFormat ) const
{
    WIA_PUSH_FUNCTION((TEXT("CGdiPlusHelper::Convert( %ws, %ws )"), pszInputFilename, pszOutputFilename  ));
    WIA_PRINTGUID((guidOutputFormat,TEXT("guidOutputFormat")));

    HRESULT hr;

    if (IsValid())
    {
        //
        // Open the source image
        //
        Image SourceImage(pszInputFilename);

        //
        // Make sure it was valid
        //
        hr = GDISTATUS_TO_HRESULT(SourceImage.GetLastStatus());
        if (SUCCEEDED(hr))
        {
            //
            // Get the correct encoder
            //
            CLSID clsidEncoder;
            hr = GetClsidOfEncoder( guidOutputFormat, clsidEncoder );
            if (SUCCEEDED(hr))
            {
                //
                // Save the image
                //
                hr = GDISTATUS_TO_HRESULT(SourceImage.Save( pszOutputFilename, &clsidEncoder, NULL ));
                if (FAILED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("GetLastError() after Save()")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("GetClsidOfEncoder() failed")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SourceImage.GetLastStatus() failed")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("IsValid() returned false")));
        hr = E_FAIL;
    }
    return hr;
}



HRESULT CGdiPlusHelper::Rotate( LPCWSTR pszInputFilename, LPCWSTR pszOutputFilename, int nRotationAngle, const CLSID &guidOutputFormat ) const
{
    WIA_PUSH_FUNCTION((TEXT("CGdiPlusHelper::Rotate( %ws, %ws, %d )"), pszInputFilename, pszOutputFilename, nRotationAngle  ));

    HRESULT hr = E_FAIL;

    if (IsValid())
    {
        //
        // Open the source image
        //
        Image SourceImage(pszInputFilename);

        //
        // Make sure it was valid
        //
        hr = GDISTATUS_TO_HRESULT(SourceImage.GetLastStatus());
        if (SUCCEEDED(hr))
        {
            //
            // Figure out what the output format should be.  If it is IID_NULL, change it to the same format as the input format
            //
            GUID OutputFormat = guidOutputFormat;
            if (OutputFormat == IID_NULL)
            {
                //
                // Find the input format
                //
                hr = GDISTATUS_TO_HRESULT(SourceImage.GetRawFormat(&OutputFormat));
                if (FAILED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("SourceImage.GetRawFormat() failed")));
                }
            }

            if (SUCCEEDED(hr))
            {
                //
                // Get the encoder for this format
                //
                CLSID clsidEncoder;
                hr = GetClsidOfEncoder( OutputFormat, clsidEncoder );
                if (SUCCEEDED(hr))
                {
                    //
                    // Lossless rotation for JPEGs...
                    //
                    if (ImageFormatJPEG == OutputFormat && (SourceImage.GetWidth() % 8 == 0) && (SourceImage.GetHeight() % 8 == 0))
                    {
                        WIA_TRACE((TEXT("Performing lossless rotation")));
                        LONG nTransform = 0;

                        //
                        // Which transform should we use?
                        //
                        switch (nRotationAngle % 360)
                        {
                        case 90:
                        case -270:
                            nTransform = EncoderValueTransformRotate90;
                            break;

                        case 180:
                        case -180:
                            nTransform = EncoderValueTransformRotate180;
                            break;

                        case 270:
                        case -90:
                            nTransform = EncoderValueTransformRotate270;
                            break;
                        }

                        //
                        // If the transform is zero, an invalid rotation angle was specified
                        //
                        if (nTransform)
                        {
                            //
                            // Fill out the EncoderParameters for lossless JPEG rotation
                            //
                            EncoderParameters EncoderParams = {0};
                            EncoderParams.Parameter[0].Guid = Gdiplus::EncoderTransformation;
                            EncoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
                            EncoderParams.Parameter[0].NumberOfValues = 1;
                            EncoderParams.Parameter[0].Value = &nTransform;
                            EncoderParams.Count = 1;

                            //
                            // Save the image to the target file
                            //
                            hr = GDISTATUS_TO_HRESULT(SourceImage.Save( pszOutputFilename, &clsidEncoder, &EncoderParams ));
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }

                    //
                    // Non-JPEG rotation, or rotation of JPEG files with non-standard sizes
                    //
                    else
                    {
                        WIA_TRACE((TEXT("Performing normal rotation")));

                        //
                        // Figure out which rotation flag to use
                        //
                        RotateFlipType rotateFlipType = RotateNoneFlipNone;
                        switch (nRotationAngle % 360)
                        {
                        case 90:
                        case -270:
                            rotateFlipType = Rotate90FlipNone;
                            break;

                        case 180:
                        case -180:
                            rotateFlipType = Rotate180FlipNone;
                            break;

                        case 270:
                        case -90:
                            rotateFlipType = Rotate270FlipNone;
                            break;
                        }

                        //
                        // Make sure we have a valid rotation angle
                        //
                        if (rotateFlipType)
                        {
                            //
                            // Rotate the image
                            //
                            hr = GDISTATUS_TO_HRESULT(SourceImage.RotateFlip(rotateFlipType));
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Save the image
                                //
                                hr = GDISTATUS_TO_HRESULT(SourceImage.Save( pszOutputFilename, &clsidEncoder, NULL ));
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("Invalid rotation specified (%d)"), nRotationAngle));
                            hr = E_FAIL;
                        }
                    } // End else if non JPEG
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("GetClsidOfEncoder failed")));
                }
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SourceImage.GetLastStatus()")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("IsValid() returned false")));
        hr = E_FAIL;
    }
    
    WIA_PRINTHRESULT((hr,TEXT("Returning")));
    return hr;
}



HRESULT CGdiPlusHelper::Rotate( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, int nRotationAngle ) const
{
    //
    // Initialize the result to NULL
    //
    hTargetBitmap = NULL;

    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Make sure we are in a valid state
    //
    if (IsValid())
    {
        //
        // Make sure we have a valid source bitmap
        //
        if (hSourceBitmap)
        {
            //
            // If we are rotating by 0 degrees, just copy the image
            //
            if (!nRotationAngle)
            {
                hTargetBitmap = reinterpret_cast<HBITMAP>(CopyImage( hSourceBitmap, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));
                if (hTargetBitmap)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    WIA_PRINTHRESULT((hr,TEXT("CopyImage failed")));
                }
            }
            else
            {
                //
                // Create the source bitmap.  No palette required, we assume it will always be a 24bit DIB.
                //
                Bitmap SourceBitmap( hSourceBitmap, NULL );
                hr = GDISTATUS_TO_HRESULT(SourceBitmap.GetLastStatus());
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the image width and height
                    //
                    UINT nSourceWidth = SourceBitmap.GetWidth();
                    UINT nSourceHeight = SourceBitmap.GetHeight();

                    //
                    // Make sure the width and height are non-zero
                    //
                    if (nSourceWidth && nSourceHeight)
                    {
                        //
                        // Assume the target width and height are zero, so we can detect invalid rotation angles
                        //
                        UINT nTargetWidth = 0;
                        UINT nTargetHeight = 0;
                        RotateFlipType rotateFlipType = RotateNoneFlipNone;

                        //
                        // Find the transformation matrix for this rotation
                        //
                        switch (nRotationAngle % 360)
                        {
                        case -270:
                        case 90:
                            rotateFlipType = Rotate90FlipNone;
                            nTargetWidth = nSourceHeight;
                            nTargetHeight = nSourceWidth;
                            break;

                        case -180:
                        case 180:
                            rotateFlipType = Rotate180FlipNone;
                            nTargetWidth = nSourceWidth;
                            nTargetHeight = nSourceHeight;
                            break;

                        case -90:
                        case 270:
                            rotateFlipType = Rotate270FlipNone;
                            nTargetWidth = nSourceHeight;
                            nTargetHeight = nSourceWidth;
                            break;
                        }

                        //
                        // If either of these are zero, that means an invalid rotation was supplied
                        //
                        if (nTargetWidth && nTargetHeight)
                        {
                            //
                            // Rotate the image
                            //
                            hr = GDISTATUS_TO_HRESULT(SourceBitmap.RotateFlip(rotateFlipType));
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Create the target bitmap and make sure it succeeded
                                //
                                Bitmap TargetBitmap( nTargetWidth, nTargetHeight );
                                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetLastStatus());
                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Get a graphics to render to
                                    //
                                    Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                                    if (pGraphics)
                                    {
                                        //
                                        // Make sure it is valid
                                        //
                                        hr = GDISTATUS_TO_HRESULT(pGraphics->GetLastStatus());
                                        if (SUCCEEDED(hr))
                                        {
                                            //
                                            // Draw image rotated to the graphics
                                            //
                                            hr = GDISTATUS_TO_HRESULT(pGraphics->DrawImage(&SourceBitmap,0,0));
                                            if (SUCCEEDED(hr))
                                            {
                                                //
                                                // Get the HBITMAP
                                                //
                                                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap ));
                                                if (SUCCEEDED(hr))
                                                {
                                                    if (!hTargetBitmap)
                                                    {
                                                        WIA_ERROR((TEXT("hTargetBitmap was NULL")));
                                                        hr = E_FAIL;
                                                    }
                                                }
                                            }
                                        }
                                        //
                                        // Clean up our dynamically allocated graphics
                                        //
                                        delete pGraphics;
                                    }
                                    else
                                    {
                                        WIA_ERROR((TEXT("pGraphics was NULL")));
                                        hr = E_FAIL;
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("TargetBitmap.GetLastStatus() failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.RotateFlip() failed")));
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("Invalid Target Bitmap Dimensions")));
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        WIA_ERROR((TEXT("Invalid Source Bitmap Dimensions")));
                        hr = E_FAIL;
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.GetLastStatus() failed")));
                }
            } // end else if nRotationAngle != 0
        }
        else
        {
            WIA_ERROR((TEXT("hSourceBitmap was NULL")));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        WIA_ERROR((TEXT("IsValid() failed")));
    }

    WIA_PRINTHRESULT((hr,TEXT("Returning")));
    return hr;
}


HRESULT CGdiPlusHelper::LoadAndScale( HBITMAP &hTargetBitmap, IStream *pStream, UINT nMaxWidth, UINT nMaxHeight, bool bStretchSmallImages )
{
    HRESULT hr = E_FAIL;

    hTargetBitmap = NULL;
    //
    // Make sure we have a valid filename
    //
    if (pStream)
    {
        Bitmap SourceBitmap( pStream  );
        hr = GDISTATUS_TO_HRESULT(SourceBitmap.GetLastStatus());
        if (SUCCEEDED(hr))
        {
            //
            // Get the image width and height
            //
            UINT nSourceWidth = SourceBitmap.GetWidth();
            UINT nSourceHeight = SourceBitmap.GetHeight();

            //
            // Make sure the width and height are non-zero
            //
            if (nSourceWidth && nSourceHeight)
            {
                //
                //
                // Assume the source dimensions are fine
                //
                UINT nTargetWidth = nSourceWidth;
                UINT nTargetHeight = nSourceHeight;

                //
                // If the height or the width exceed the allowed maximum, scale it down, or if we are allowing stretching
                //
                if (nMaxWidth > 0 && nMaxHeight > 0)
                {
                    if ((nTargetWidth > nMaxWidth) || (nTargetHeight > nMaxHeight) || bStretchSmallImages)
                    {
                        SIZE sizeDesiredImageSize = PrintScanUtil::ScalePreserveAspectRatio( nMaxWidth, nMaxHeight, nTargetWidth, nTargetHeight );
                        nTargetWidth = sizeDesiredImageSize.cx;
                        nTargetHeight = sizeDesiredImageSize.cy;
                    }
                }

                //
                // Make sure we have valid sizes
                //
                if (nTargetWidth && nTargetHeight)
                {
                    //
                    // Create the target bitmap and make sure it succeeded
                    //
                    Bitmap TargetBitmap( nTargetWidth, nTargetHeight );
                    hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetLastStatus());
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get a graphics to render to
                        //
                        Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                        if (pGraphics)
                        {
                            //
                            // Make sure it is valid
                            //
                            hr = GDISTATUS_TO_HRESULT(pGraphics->GetLastStatus());
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Draw scaled image
                                //
                                hr = GDISTATUS_TO_HRESULT(pGraphics->DrawImage(&SourceBitmap, 0, 0, nTargetWidth, nTargetHeight));
                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Get an HBITMAP for this image
                                    //
                                    hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap ));
                                    if (!hTargetBitmap)
                                    {
                                        WIA_ERROR((TEXT("hTargetBitmap was NULL")));
                                        hr = E_FAIL;
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("pGraphics->DrawImage failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("pGraphics->GetLastStatus() failed")));
                            }
                            //
                            // Clean up our dynamically allocated graphics
                            //
                            delete pGraphics;
                        }
                        else
                        {
                            hr = E_FAIL;
                            WIA_ERROR((TEXT("pGraphics was NULL")));
                        }
                    }
                    else
                    {
                        WIA_PRINTHRESULT((hr,TEXT("TargetBitmap.GetLastStatus() is not OK")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("Invalid Target Bitmap Dimensions (%d,%d)"), nTargetWidth, nTargetHeight));
                    hr = E_FAIL;
                }
            }
            else
            {
                WIA_ERROR((TEXT("Invalid Source Bitmap Dimensions")));
                hr = E_FAIL;
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.GetLastStatus() failed")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("pStream was NULL")));
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CGdiPlusHelper::LoadAndScale( HBITMAP &hTargetBitmap, LPCTSTR pszFilename, UINT nMaxWidth, UINT nMaxHeight, bool bStretchSmallImages )
{
    hTargetBitmap = NULL;

    HRESULT hr = E_FAIL;
    //
    // Make sure we have a valid filename
    //
    if (pszFilename && lstrlen(pszFilename))
    {
        Bitmap SourceBitmap( CSimpleStringConvert::WideString(CSimpleString(pszFilename) ) );
        hr = GDISTATUS_TO_HRESULT(SourceBitmap.GetLastStatus());
        if (SUCCEEDED(hr))
        {
            //
            // Get the image width and height
            //
            UINT nSourceWidth = SourceBitmap.GetWidth();
            UINT nSourceHeight = SourceBitmap.GetHeight();

            //
            // Make sure the width and height are non-zero
            //
            if (nSourceWidth && nSourceHeight)
            {
                //
                //
                // Assume the source dimensions are fine
                //
                UINT nTargetWidth = nSourceWidth;
                UINT nTargetHeight = nSourceHeight;

                //
                // If the height or the width exceed the allowed maximum, scale it down, or if we are allowing stretching
                //
                if (nMaxWidth > 0 && nMaxHeight > 0)
                {
                    if ((nTargetWidth > nMaxWidth) || (nTargetHeight > nMaxHeight) || bStretchSmallImages)
                    {
                        SIZE sizeDesiredImageSize = PrintScanUtil::ScalePreserveAspectRatio( nMaxWidth, nMaxHeight, nTargetWidth, nTargetHeight );
                        nTargetWidth = sizeDesiredImageSize.cx;
                        nTargetHeight = sizeDesiredImageSize.cy;
                    }
                }

                //
                // Make sure we have valid sizes
                //
                if (nTargetWidth && nTargetHeight)
                {
                    //
                    // Create the target bitmap and make sure it succeeded
                    //
                    Bitmap TargetBitmap( nTargetWidth, nTargetHeight );
                    hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetLastStatus());
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get a graphics to render to
                        //
                        Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                        if (pGraphics)
                        {
                            //
                            // Make sure it is valid
                            //
                            hr = GDISTATUS_TO_HRESULT(pGraphics->GetLastStatus());
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Draw scaled image
                                //
                                hr = GDISTATUS_TO_HRESULT(pGraphics->DrawImage(&SourceBitmap, 0, 0, nTargetWidth, nTargetHeight));
                                if (SUCCEEDED(hr))
                                {
                                    //
                                    // Get an HBITMAP for this image
                                    //
                                    hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap ));
                                    if (SUCCEEDED(hr))
                                    {
                                        if (!hTargetBitmap)
                                        {
                                            hr = E_FAIL;
                                        }
                                    }
                                    else
                                    {
                                        WIA_ERROR((TEXT("TargetBitmap.GetHBITMAP failed")));
                                    }
                                }
                                else
                                {
                                    WIA_ERROR((TEXT("pGraphics->DrawImage failed")));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("pGraphics->GetLastStatus() failed")));
                            }
                            //
                            // Clean up our dynamically allocated graphics
                            //
                            delete pGraphics;
                        }
                        else
                        {
                            WIA_ERROR((TEXT("pGraphics was NULL")));
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        WIA_PRINTHRESULT((hr,TEXT("TargetBitmap.GetLastStatus() is not OK")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("Invalid Target Bitmap Dimensions (%d,%d)"), nTargetWidth, nTargetHeight));
                    hr = E_FAIL;
                }
            }
            else
            {
                WIA_ERROR((TEXT("Invalid Source Bitmap Dimensions")));
                hr = E_FAIL;
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.GetLastStatus() failed")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("hSourceBitmap was NULL")));
    }

    return hr;
}


//
// Construct a string like this: JPG;BMP;PNG with all supported extensions
//
HRESULT CGdiPlusHelper::ConstructCodecExtensionSearchStrings( CSimpleString &strExtensions, Gdiplus::ImageCodecInfo *pImageCodecInfo, UINT nImageCodecCount )
{
    for (UINT i=0;i<nImageCodecCount;i++)
    {
        if (strExtensions.Length())
        {
            strExtensions += TEXT(";");
        }
        strExtensions += CSimpleStringConvert::NaturalString(CSimpleStringWide(pImageCodecInfo[i].FilenameExtension));
    }
    return (strExtensions.Length() ? S_OK : E_FAIL);
}

HRESULT CGdiPlusHelper::ConstructDecoderExtensionSearchStrings( CSimpleString &strExtensions )
{
    return CGdiPlusHelper::ConstructCodecExtensionSearchStrings( strExtensions, m_pImageDecoderInfo, m_nImageDecoderCount );
}


HRESULT CGdiPlusHelper::ConstructEncoderExtensionSearchStrings( CSimpleString &strExtensions )
{
    return CGdiPlusHelper::ConstructCodecExtensionSearchStrings( strExtensions, m_pImageEncoderInfo, m_nImageEncoderCount );
}


EncoderParameters *CGdiPlusHelper::AppendEncoderParameter( EncoderParameters *pEncoderParameters, const GUID &guidProp, ULONG nType, PVOID pVoid )
{
    if (pEncoderParameters)
    {
        pEncoderParameters->Parameter[pEncoderParameters->Count].Guid = guidProp;
        pEncoderParameters->Parameter[pEncoderParameters->Count].Type = nType;
        pEncoderParameters->Parameter[pEncoderParameters->Count].NumberOfValues = 1;
        pEncoderParameters->Parameter[pEncoderParameters->Count].Value = pVoid;
        pEncoderParameters->Count++;
    }
    return pEncoderParameters;
}

HRESULT CGdiPlusHelper::SaveMultipleImagesAsMultiPage( const CSimpleDynamicArray<CSimpleStringWide> &Filenames, const CSimpleStringWide &strFilename, const GUID &guidOutputFormat )
{
    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Parameters used in the encoder
    //
    ULONG nEncoderValueMultiFrame = EncoderValueMultiFrame;
    ULONG nEncoderValueFrameDimensionPage = EncoderValueFrameDimensionPage;
    ULONG nEncoderValueLastFrame = EncoderValueLastFrame;

    //
    // Make sure we have some files
    //
    if (Filenames.Size())
    {
        //
        // Get the encoder
        //
        CLSID clsidEncoder = IID_NULL;
        hr = GetClsidOfEncoder( guidOutputFormat, clsidEncoder );
        if (SUCCEEDED(hr))
        {
            //
            // Open the first image
            //
            Image SourceImage( Filenames[0] );
            hr = GDISTATUS_TO_HRESULT(SourceImage.GetLastStatus());
            if (SUCCEEDED(hr))
            {

                EncoderParameters encoderParameters = {0};
                if (Filenames.Size() > 1)
                {
                    AppendEncoderParameter( &encoderParameters, EncoderSaveFlag, EncoderParameterValueTypeLong, &nEncoderValueMultiFrame );
                }

                //
                // Save the first page
                //
                hr = GDISTATUS_TO_HRESULT(SourceImage.Save( strFilename, &clsidEncoder, &encoderParameters ));
                if (SUCCEEDED(hr))
                {
                    //
                    // Save each additional page
                    //
                    for (int i=1;i<Filenames.Size() && SUCCEEDED(hr);i++)
                    {
                        //
                        // Create the additional page
                        //
                        Image AdditionalPage(Filenames[i]);

                        //
                        // Make sure it succeeded
                        //
                        hr = GDISTATUS_TO_HRESULT(AdditionalPage.GetLastStatus());
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Prepare the encoder parameters
                            //
                            EncoderParameters encoderParameters[2] = {0};
                            AppendEncoderParameter( encoderParameters, EncoderSaveFlag, EncoderParameterValueTypeLong, &nEncoderValueFrameDimensionPage );

                            //
                            // If this is the last page, append the "last frame" parameter
                            //
                            if (i == Filenames.Size()-1)
                            {
                                AppendEncoderParameter( encoderParameters, EncoderSaveFlag, EncoderParameterValueTypeLong, &nEncoderValueLastFrame );
                            }

                            //
                            // Try to add a page
                            //
                            hr = GDISTATUS_TO_HRESULT(SourceImage.SaveAdd( &AdditionalPage, encoderParameters ));
                            if (FAILED(hr))
                            {
                                WIA_PRINTHRESULT((hr,TEXT("SourceImage.SaveAdd failed!")));
                            }
                        }
                        else
                        {
                            WIA_PRINTHRESULT((hr,TEXT("AdditionalPage.GetLastStatus failed!")));
                        }
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("SourceImage.Save failed!")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("SourceImage.GetLastStatus failed!")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("GetClsidOfEncoder failed!")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("Filenames.Size was 0!")));
        hr = E_INVALIDARG;
    }
    return hr;
}

static void CalculateBrightnessAndContrastParams( BYTE iBrightness, BYTE iContrast, float *scale, float *translate )
{
    //
    // force values to be at least 1, to avoid undesired effects
    //
    if (iBrightness < 1)
    {
        iBrightness = 1;
    }
    if (iContrast < 1)
    {
        iContrast = 1;
    }

    //
    // get current brightness as a percentage of full scale
    //
    float fBrightness = (float)( 100 - iBrightness ) / 100.0f;
    if (fBrightness > 0.95f)
    {
        fBrightness = 0.95f; /* clamp */
    }

    //
    // get current contrast as a percentage of full scale
    //
    float fContrast = (float) iContrast / 100.0f;
    if (fContrast > 1.0f)
    {
        fContrast = 1.0;    /* limit to 1.0    */
    }

    //
    // convert contrast to a scale value
    //
    if (fContrast <= 0.5f)
    {
        *scale = fContrast / 0.5f;    /* 0 -> 0, .5 -> 1.0 */
    }
    else
    {
        if (fContrast == 1.0f)
        {
                fContrast = 0.9999f;
        }
        *scale = 0.5f / (1.0f - fContrast); /* .5 -> 1.0, 1.0 -> inf */
    }

    *translate = 0.5f - *scale * fBrightness;
}


HRESULT CGdiPlusHelper::SetBrightnessAndContrast( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, BYTE nBrightness, BYTE nContrast )
{
    WIA_TRACE((TEXT("nBrightness: %d, nContrast: %d"), nBrightness, nContrast ));
    //
    // Initialize the result to NULL
    //
    hTargetBitmap = NULL;

    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Make sure we are in a valid state
    //
    if (IsValid())
    {
        //
        // Make sure we have a valid source bitmap
        //
        if (hSourceBitmap)
        {
            //
            // Create the source bitmap.  No palette required, we assume it will always be a 24bit DIB.
            //
            Bitmap SourceBitmap( hSourceBitmap, NULL );
            
            hr = GDISTATUS_TO_HRESULT(SourceBitmap.GetLastStatus());
            if (SUCCEEDED(hr))
            {
                //
                // Create the target bitmap and make sure it succeeded
                //
                Bitmap TargetBitmap( SourceBitmap.GetWidth(), SourceBitmap.GetHeight() );
                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetLastStatus());
                if (SUCCEEDED(hr))
                {
                    //
                    // Get a graphics to render to
                    //
                    Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                    if (pGraphics)
                    {
                        //
                        // Make sure it is valid
                        //
                        hr = GDISTATUS_TO_HRESULT(pGraphics->GetLastStatus());
                        if (SUCCEEDED(hr))
                        {
                            ImageAttributes imageAttributes;

                            //
                            // Calculate the values needed for the matrix
                            //
                            REAL scale = 0.0;
                            REAL trans = 0.0;
                            CalculateBrightnessAndContrastParams( nBrightness, nContrast, &scale, &trans );

                            //
                            // Prepare the matrix for brightness and contrast transforms
                            //
                            ColorMatrix brightnessAndContrast = {scale, 0,     0,     0,     0,
                                                                 0,     scale, 0,     0,     0,
                                                                 0,     0,     scale, 0,     0,
                                                                 0,     0,     0,     1,     0,
                                                                 trans, trans, trans, 0,     1};

                            imageAttributes.SetColorMatrix(&brightnessAndContrast);

                            Rect rect( 0, 0, SourceBitmap.GetWidth(), SourceBitmap.GetHeight() );


                            //
                            // Draw the transformed image on the graphics
                            //
                            hr = GDISTATUS_TO_HRESULT(pGraphics->DrawImage(&SourceBitmap,rect,0,0,SourceBitmap.GetWidth(), SourceBitmap.GetHeight(),UnitPixel,&imageAttributes));
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Get the HBITMAP
                                //
                                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap ));
                                if (SUCCEEDED(hr))
                                {
                                    if (!hTargetBitmap)
                                    {
                                        WIA_ERROR((TEXT("hTargetBitmap was NULL")));
                                        hr = E_FAIL;
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("Bitmap::GetHBITMAP failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("pGraphics->DrawImage failed")));
                            }
                        }
                        else
                        {
                            WIA_PRINTHRESULT((hr,TEXT("pGraphics->GetLastStatus() failed")));
                        }
                        //
                        // Clean up our dynamically allocated graphics
                        //
                        delete pGraphics;
                    }
                    else
                    {
                        WIA_ERROR((TEXT("pGraphics was NULL")));
                        hr = E_FAIL;
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("TargetBitmap.GetLastStatus() failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.GetLastStatus() failed")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("hSourceBitmap was NULL")));
            hr = E_FAIL;
        }
    }
    else
    {
        WIA_ERROR((TEXT("IsValid() returned false")));
        hr = E_FAIL;
    }

    WIA_PRINTHRESULT((hr,TEXT("Returning")));
    return hr;
}



HRESULT CGdiPlusHelper::SetThreshold( HBITMAP hSourceBitmap, HBITMAP &hTargetBitmap, BYTE nThreshold )
{
    //
    // Initialize the result to NULL
    //
    hTargetBitmap = NULL;

    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Make sure we are in a valid state
    //
    if (IsValid())
    {
        //
        // Make sure we have a valid source bitmap
        //
        if (hSourceBitmap)
        {
            //
            // Create the source bitmap.  No palette required, we assume it will always be a 24bit DIB.
            //
            Bitmap SourceBitmap( hSourceBitmap, NULL );
            hr = GDISTATUS_TO_HRESULT(SourceBitmap.GetLastStatus());
            if (SUCCEEDED(hr))
            {
                //
                // Create the target bitmap and make sure it succeeded
                //
                Bitmap TargetBitmap( SourceBitmap.GetWidth(), SourceBitmap.GetHeight() );
                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetLastStatus());
                if (SUCCEEDED(hr))
                {
                    //
                    // Get a graphics to render to
                    //
                    Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                    if (pGraphics)
                    {
                        //
                        // Make sure it is valid
                        //
                        hr = GDISTATUS_TO_HRESULT(pGraphics->GetLastStatus());
                        if (SUCCEEDED(hr))
                        {
                            ImageAttributes imageAttributes;
                            imageAttributes.SetThreshold(static_cast<double>(100-nThreshold)/100);

                            Rect rect( 0, 0, SourceBitmap.GetWidth(), SourceBitmap.GetHeight() );


                            //
                            // Draw image rotated to the graphics
                            //
                            hr = GDISTATUS_TO_HRESULT(pGraphics->DrawImage(&SourceBitmap,rect,0,0,SourceBitmap.GetWidth(), SourceBitmap.GetHeight(),UnitPixel,&imageAttributes));
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Get the HBITMAP
                                //
                                hr = GDISTATUS_TO_HRESULT(TargetBitmap.GetHBITMAP( Color::Black, &hTargetBitmap ));
                                if (SUCCEEDED(hr))
                                {
                                    if (!hTargetBitmap)
                                    {
                                        WIA_ERROR((TEXT("hTargetBitmap was NULL")));
                                        hr = E_FAIL;
                                    }
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("Bitmap::GetHBITMAP failed")));
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("pGraphics->DrawImage failed")));
                            }
                        }
                        else
                        {
                            WIA_PRINTHRESULT((hr,TEXT("pGraphics->GetLastStatus() failed")));
                        }
                        //
                        // Clean up our dynamically allocated graphics
                        //
                        delete pGraphics;
                    }
                    else
                    {
                        WIA_ERROR((TEXT("pGraphics was NULL")));
                        hr = E_FAIL;
                    }
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("SourceBitmap.GetLastStatus() failed")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("hSourceBitmap was NULL")));
            hr = E_FAIL;
        }
    }
    WIA_PRINTHRESULT((hr,TEXT("Returning")));
    return hr;
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem(void)
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
}

CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &guidDecoder )
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
    Assign( pSignature, pMask, nLength, guidFormat, guidDecoder );
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::CImageFileFormatVerifierItem( const CImageFileFormatVerifierItem &other )
  : m_pSignature(NULL),
    m_pMask(NULL),
    m_nLength(0),
    m_guidFormat(IID_NULL),
    m_clsidDecoder(IID_NULL)
{
    Assign( other.Signature(), other.Mask(), other.Length(), other.Format(), other.Decoder() );
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem &CImageFileFormatVerifier::CImageFileFormatVerifierItem::operator=( const CImageFileFormatVerifierItem &other )
{
    if (this != &other)
    {
        return Assign( other.Signature(), other.Mask(), other.Length(), other.Format(), other.Decoder() );
    }
    else return *this;
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem &CImageFileFormatVerifier::CImageFileFormatVerifierItem::Assign( const PBYTE pSignature, const PBYTE pMask, int nLength, const GUID &guidFormat, const CLSID &clsidDecoder )
{
    Destroy();
    bool bOK = false;
    m_nLength = nLength;
    m_guidFormat = guidFormat;
    m_clsidDecoder = clsidDecoder;
    if (nLength && pSignature && pMask)
    {
        m_pSignature = new BYTE[nLength];
        m_pMask = new BYTE[nLength];
        if (m_pSignature && m_pMask)
        {
            CopyMemory( m_pSignature, pSignature, nLength );
            CopyMemory( m_pMask, pMask, nLength );
            bOK = true;
        }
    }
    if (!bOK)
        Destroy();
    return *this;
}


void CImageFileFormatVerifier::CImageFileFormatVerifierItem::Destroy(void)
{
    if (m_pSignature)
        delete[] m_pSignature;
    m_pSignature = NULL;
    if (m_pMask)
        delete[] m_pMask;
    m_pMask = NULL;
    m_nLength = 0;
    m_guidFormat = IID_NULL;
    m_clsidDecoder = IID_NULL;
}


CImageFileFormatVerifier::CImageFileFormatVerifierItem::~CImageFileFormatVerifierItem(void)
{
    Destroy();
}


PBYTE CImageFileFormatVerifier::CImageFileFormatVerifierItem::Signature(void) const
{
    return m_pSignature;
}


PBYTE CImageFileFormatVerifier::CImageFileFormatVerifierItem::Mask(void) const
{
    return m_pMask;
}


int CImageFileFormatVerifier::CImageFileFormatVerifierItem::Length(void) const
{
    return m_nLength;
}


GUID CImageFileFormatVerifier::CImageFileFormatVerifierItem::Format(void) const
{
    return m_guidFormat;
}


CLSID CImageFileFormatVerifier::CImageFileFormatVerifierItem::Decoder(void) const
{
    return m_clsidDecoder;
}


bool CImageFileFormatVerifier::CImageFileFormatVerifierItem::Match( PBYTE pBytes, int nLen ) const
{
    WIA_PUSH_FUNCTION((TEXT("CImageFileFormatVerifierItem::Match")));
    WIA_PRINTGUID((m_clsidDecoder,TEXT("Decoder")));
    if (nLen < Length())
    {
        return false;
    }
    for (int i=0;i<Length();i++)
    {
        if (false == ((pBytes[i] & m_pMask[i]) == m_pSignature[i]))
        {
            return false;
        }
    }
    return true;
}



CImageFileFormatVerifier::CImageFileFormatVerifier(void)
  : m_nMaxSignatureLength(0),
    m_pSignatureBuffer(NULL)
{
    //
    // Get the decoder count and size of the decoder info array
    //
    UINT nImageDecoderCount = 0, cbCodecs = 0;
    if (Gdiplus::Ok == Gdiplus::GetImageDecodersSize( &nImageDecoderCount, &cbCodecs ))
    {
        //
        // Make sure we got good sizes back
        //
        if (cbCodecs && nImageDecoderCount)
        {
            //
            // Allocate the array
            //
            Gdiplus::ImageCodecInfo *pImageDecoderInfo = static_cast<Gdiplus::ImageCodecInfo*>(LocalAlloc(LPTR,cbCodecs));
            if (pImageDecoderInfo)
            {
                //
                // Get the actual decoder info
                //
                if (Gdiplus::Ok == Gdiplus::GetImageDecoders( nImageDecoderCount, cbCodecs, pImageDecoderInfo ))
                {
                    //
                    // Add each decoder to the format list
                    //
                    for (UINT i=0;i<nImageDecoderCount;i++)
                    {
                        //
                        // Add each signature to the format list
                        //
                        for (UINT j=0;j<pImageDecoderInfo[i].SigCount;j++)
                        {
#if defined(DBG)
                            CSimpleString strPattern;
                            CSimpleString strMask;
                            for (ULONG x=0;x<pImageDecoderInfo[i].SigSize;x++)
                            {
                                strPattern += CSimpleString().Format( TEXT("%02X"), ((const PBYTE)(pImageDecoderInfo[i].SigPattern+(j*pImageDecoderInfo[i].SigSize)))[x] );
                                strMask += CSimpleString().Format( TEXT("%02X"), ((const PBYTE)(pImageDecoderInfo[i].SigMask+(j*pImageDecoderInfo[i].SigSize)))[x] );
                            }
                            WIA_PRINTGUID((pImageDecoderInfo[i].FormatID,TEXT("FormatID")));
                            WIA_PRINTGUID((pImageDecoderInfo[i].Clsid,TEXT("  Clsid")));
                            WIA_TRACE((TEXT("  strPattern: %s, strMask: %s, SigSize: %d"), strPattern.String(), strMask.String(), pImageDecoderInfo[i].SigSize ));
#endif
                            m_FileFormatVerifierList.Append( CImageFileFormatVerifier::CImageFileFormatVerifierItem( (const PBYTE)(pImageDecoderInfo[i].SigPattern+(j*pImageDecoderInfo[i].SigSize)), (const PBYTE)(pImageDecoderInfo[i].SigMask+(j*pImageDecoderInfo[i].SigSize)), pImageDecoderInfo[i].SigSize, pImageDecoderInfo[i].FormatID, pImageDecoderInfo[i].Clsid ) );
                        }
                    }
                }
                //
                // Free the array
                //
                LocalFree(pImageDecoderInfo);
            }
        }
    }

    //
    // Assume the max length is Zero
    //
    m_nMaxSignatureLength = 0;


    //
    // For each signature, check if it is greater in length than the maximum.
    //
    for (int i=0;i<m_FileFormatVerifierList.Size();i++)
    {
        //
        // If it is the longest, save the length
        //
        if (m_FileFormatVerifierList[i].Length() > m_nMaxSignatureLength)
        {
            m_nMaxSignatureLength = m_FileFormatVerifierList[i].Length();
        }
    }

    //
    // If we have a valid max length, allocate a buffer to hold the file's data
    //
    if (m_nMaxSignatureLength)
    {
        m_pSignatureBuffer = new BYTE[m_nMaxSignatureLength];
    }

    //
    // If anything failed, free everything
    //
    if (!IsValid())
    {
        Destroy();
    }
}


void CImageFileFormatVerifier::Destroy(void)
{
    //
    // Free the file signature buffer
    //
    if (m_pSignatureBuffer)
    {
        delete[] m_pSignatureBuffer;
        m_pSignatureBuffer = NULL;
    }
    m_nMaxSignatureLength = 0;
    m_FileFormatVerifierList.Destroy();
}


bool CImageFileFormatVerifier::IsValid(void) const
{
    return (m_pSignatureBuffer && m_nMaxSignatureLength && m_FileFormatVerifierList.Size());
}

CImageFileFormatVerifier::~CImageFileFormatVerifier(void)
{
    Destroy();
}


GUID CImageFileFormatVerifier::GetImageType( IStream * pStream )
{
    WIA_PUSH_FUNCTION((TEXT("CImageFileFormatVerifier::GetImageType( via IStream )")));
    //
    // Assume we will not find a match
    //
    GUID guidResult = IID_NULL;

    //
    // Make sure we have a valid IStream object...
    //
    if (pStream)
    {
        //
        // Read the maximum signature length number of bytes
        //
        ULONG uBytesRead = 0;
        HRESULT hr = pStream->Read( m_pSignatureBuffer, m_nMaxSignatureLength, &uBytesRead );

        //
        // Make sure we got some bytes
        //
        if (SUCCEEDED(hr) && uBytesRead)
        {
            //
            // Go though the list and try to find a match
            //
            for (int i=0;i<m_FileFormatVerifierList.Size();i++)
            {
                //
                // If we found a match, we are done
                //
                if (m_FileFormatVerifierList[i].Match(m_pSignatureBuffer,uBytesRead))
                {
                    guidResult = m_FileFormatVerifierList[i].Format();
                    break;
                }
            }
        }
        else
        {
            WIA_ERROR((TEXT("pStream->Read() failed w/hr = 0x%x"),hr));
        }
    }
    else
    {
        WIA_ERROR((TEXT("pStream was NULL")));
    }

    //
    // This will contain IID_NULL if no matching image type was found
    //
    return guidResult;

}

bool CImageFileFormatVerifier::IsImageFile( LPCTSTR pszFilename )
{
    WIA_PUSH_FUNCTION((TEXT("CImageFileFormatVerifier::IsImageFile(%s)"),pszFilename));

    GUID guidImageType = IID_NULL;

    //
    // Get a stream object over the file...
    //

    IStream * pStream = NULL;
    HRESULT hr = SHCreateStreamOnFile(pszFilename, STGM_READ | STGM_SHARE_DENY_WRITE, &pStream );

    if (SUCCEEDED(hr) && pStream)
    {
        guidImageType = GetImageType(pStream);
    }

    if (pStream)
    {
        pStream->Release();
    }

    WIA_PRINTGUID((guidImageType,TEXT("guidImageType")));

    //
    // If the image type is IID_NULL, it isn't an image
    //
    return ((IID_NULL != guidImageType) != FALSE);
}


bool CImageFileFormatVerifier::IsSupportedImageFromStream( IStream * pStream, GUID * pGuidOfFormat )
{
    WIA_PUSH_FUNCTION((TEXT("CImageFileFormatVerifier::IsSupportedImageFromStream()")));

    GUID guidImageType = IID_NULL;

    //
    // Get an IStream pointer for this file...
    //

    if (pStream)
    {
        guidImageType = GetImageType(pStream);
    }

    WIA_PRINTGUID((guidImageType,TEXT("guidImageType")));

    if (pGuidOfFormat)
    {
        *pGuidOfFormat = guidImageType;
    }

    //
    // If the image type is IID_NULL, it isn't an image
    //
    return ((IID_NULL != guidImageType) != FALSE);
}

CGdiPlusInit::CGdiPlusInit()
    : m_pGdiplusToken(NULL)
{
    //
    // Make sure GDI+ is initialized
    //
    GdiplusStartupInput StartupInput;
    GdiplusStartup(&m_pGdiplusToken,&StartupInput,NULL);
}

CGdiPlusInit::~CGdiPlusInit()
{
    GdiplusShutdown(m_pGdiplusToken);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\wiadbgcl.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIADBGCL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/4/1999
 *
 *  DESCRIPTION: Debug client.  Linked statically.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include "simreg.h"
#include "wiadebug.h"

#define DOESNT_MATTER_WHAT_THIS_IS ((UINT)7)

//
// Static class data members
//
CWiaDebugClient g_TheDebugClient;


//
// Sole constructor
//
CWiaDebugClient::CWiaDebugClient(void)
  : m_hDebugModule(NULL),
    m_hCurrentModuleInstance(NULL),
    m_pfnIncrementDebugIndentLevel(NULL),
    m_pfnDecrementDebugIndentLevel(NULL),
    m_pfnPrintDebugMessageW(NULL),
    m_pfnPrintDebugMessageA(NULL),
    m_pfnGetDebugMask(NULL),
    m_pfnSetDebugMask(NULL),
    m_pfnAllocateDebugColor(NULL),
    m_pfnGetStringFromGuidA(NULL),
    m_pfnGetStringFromGuidW(NULL),
    m_pfnDoRecordAllocation(NULL),
    m_pfnDoRecordFree(NULL),
    m_pfnDoReportLeaks(NULL),
    m_crForegroundColor(DEFAULT_DEBUG_COLOR),
    m_dwModuleDebugMask(0),
    m_bHaveModuleInformation(false),
    m_bDebugLibLoadAttempted(false),
    m_pfnGetStringFromMsgA(NULL),
    m_pfnGetStringFromMsgW(NULL)
{
    CAutoCriticalSection cs(m_CriticalSection);
    m_szModuleNameW[0] = 0;
    m_szModuleNameA[0] = 0;

    if (LoadWiaDebugExports())
    {
        InitializeModuleInfo();
    }
}


template <class T>
static T GetProc( HINSTANCE hModule, LPCSTR pszFunctionName )
{
    return reinterpret_cast<T>(GetProcAddress( hModule, pszFunctionName ));
}

bool CWiaDebugClient::LoadWiaDebugExports()
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // No need to call this more than once, so return true if the
    // load was successful, false if it was not
    //
    if (m_bDebugLibLoadAttempted)
    {
        return (NULL != m_hDebugModule);
    }

    //
    // Prevent future loading attempts
    //
    m_bDebugLibLoadAttempted = true;

    //
    // Assume failure
    //
    bool bResult = false;

    //
    // Load the library
    //
    m_hDebugModule = LoadLibrary( DEBUG_DLL_NAME );
    if (m_hDebugModule)
    {
        m_pfnIncrementDebugIndentLevel = GetProc<IncrementDebugIndentLevelProc>( m_hDebugModule, INCREMENT_DEBUG_INDENT_LEVEL_NAME );
        m_pfnDecrementDebugIndentLevel = GetProc<DecrementDebugIndentLevelProc>( m_hDebugModule, DECREMENT_DEBUG_INDENT_LEVEL_NAME );
        m_pfnPrintDebugMessageA        = GetProc<PrintDebugMessageAProc>( m_hDebugModule, PRINT_DEBUG_MESSAGE_NAMEA );
        m_pfnPrintDebugMessageW        = GetProc<PrintDebugMessageWProc>( m_hDebugModule, PRINT_DEBUG_MESSAGE_NAMEW );
        m_pfnGetDebugMask              = GetProc<GetDebugMaskProc>( m_hDebugModule, GET_DEBUG_MASK_NAME );
        m_pfnSetDebugMask              = GetProc<SetDebugMaskProc>( m_hDebugModule, SET_DEBUG_MASK_NAME );
        m_pfnAllocateDebugColor        = GetProc<AllocateDebugColorProc>( m_hDebugModule, ALLOCATE_DEBUG_COLOR_NAME );
        m_pfnGetStringFromGuidA        = GetProc<GetStringFromGuidAProc>( m_hDebugModule, GET_STRING_FROM_GUID_NAMEA );
        m_pfnGetStringFromGuidW        = GetProc<GetStringFromGuidWProc>( m_hDebugModule, GET_STRING_FROM_GUID_NAMEW );
        m_pfnDoRecordAllocation        = GetProc<DoRecordAllocationProc>( m_hDebugModule, DO_RECORD_ALLOCATION );
        m_pfnDoRecordFree              = GetProc<DoRecordFreeProc>( m_hDebugModule, DO_RECORD_FREE );
        m_pfnDoReportLeaks             = GetProc<DoReportLeaksProc>( m_hDebugModule, DO_REPORT_LEAKS );
        m_pfnGetStringFromMsgA         = GetProc<GetStringFromMsgAProc>( m_hDebugModule, GET_STRING_FROM_MSGA );
        m_pfnGetStringFromMsgW         = GetProc<GetStringFromMsgWProc>( m_hDebugModule, GET_STRING_FROM_MSGW );

        bResult = (m_pfnIncrementDebugIndentLevel &&
                   m_pfnDecrementDebugIndentLevel &&
                   m_pfnPrintDebugMessageA &&
                   m_pfnPrintDebugMessageW &&
                   m_pfnGetDebugMask &&
                   m_pfnSetDebugMask &&
                   m_pfnAllocateDebugColor &&
                   m_pfnGetStringFromGuidA &&
                   m_pfnGetStringFromGuidW &&
                   m_pfnDoRecordAllocation &&
                   m_pfnDoRecordFree &&
                   m_pfnDoReportLeaks &&
                   m_pfnGetStringFromMsgA &&
                   m_pfnGetStringFromMsgW);
    }
    return bResult;
}

bool CWiaDebugClient::IsInitialized()
{
    bool bResult = false;
    CAutoCriticalSection cs(m_CriticalSection);
    if (LoadWiaDebugExports())
    {
        bResult = InitializeModuleInfo();
    }
    return bResult;
}

LPTSTR CWiaDebugClient::GetJustTheFileName( LPCTSTR pszPath, LPTSTR pszFileName, int nMaxLen )
{
    //
    // Make sure we have valid arguments
    //
    if (!pszPath || !pszFileName || !nMaxLen)
    {
        return NULL;
    }

    //
    // Initialize the return string
    //
    lstrcpy( pszFileName, TEXT("") );

    //
    // Loop through the filename, looking for the last \
    //
    LPCTSTR pszLastBackslash = NULL;
    for (LPCTSTR pszCurr=pszPath;pszCurr && *pszCurr;pszCurr = CharNext(pszCurr))
    {
        if (TEXT('\\') == *pszCurr)
        {
            pszLastBackslash = pszCurr;
        }
    }
    
    //
    // If we found any \'s, point to the next character
    //
    if (pszLastBackslash)
    {
        pszLastBackslash = CharNext(pszLastBackslash);
    }
    
    //
    // Otherwise, we will copy the entire path
    //
    else
    {
        pszLastBackslash = pszPath;
    }
    
    //
    // If we have a valid starting point, copy the string to the target buffer and terminate it
    //
    if (pszLastBackslash)
    {
        lstrcpyn( pszFileName, pszLastBackslash, nMaxLen-1 );
        pszFileName[nMaxLen-1] = TEXT('\0');
    }

    return pszFileName;
}


bool CWiaDebugClient::InitializeModuleInfo()
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // If we've already been initialized, return true
    //
    if (m_bHaveModuleInformation)
    {
        return true;
    }

    //
    // If we haven't got a valid HINSTANCE, return false
    //
    if (!m_hCurrentModuleInstance)
    {
        return false;
    }


    //
    // Make sure we start out with empty module name strings
    //
    m_szModuleNameW[0] = 0;
    m_szModuleNameA[0] = 0;

    //
    // Get default debug setting
    //
    m_dwModuleDebugMask = CSimpleReg( HKEY_LOCAL_MACHINE, DEBUG_REGISTRY_PATH, false, KEY_READ ).Query( DEBUG_REGISTRY_DEFAULT_FLAGS, 0 );

    //
    // Initialize the module name, in case we can't determine it.  It is OK
    // that wsprintfW will return ERROR_NOT_IMPLEMENTED under win9x, since
    // we won't be using this variable at all on this OS
    //
    wsprintfW( m_szModuleNameW, L"0x%08X", GetCurrentProcessId() );
    wsprintfA( m_szModuleNameA, "0x%08X", GetCurrentProcessId() );
    
    //
    // Get the next available color
    //
    m_crForegroundColor = m_pfnAllocateDebugColor();

    //
    // Get the module name
    //
    TCHAR szModulePathName[MAX_PATH] = TEXT("");
    if (GetModuleFileName( m_hCurrentModuleInstance, szModulePathName, ARRAYSIZE(szModulePathName)))
    {
        //
        // Get rid of the path
        //
        TCHAR szFilename[MAX_PATH] = TEXT("");
        GetJustTheFileName( szModulePathName, szFilename, ARRAYSIZE(szFilename) );

        //
        // Make sure we have a valid filename
        //
        if (lstrlen(szFilename))
        {
            m_dwModuleDebugMask = CSimpleReg( HKEY_LOCAL_MACHINE, DEBUG_REGISTRY_PATH_FLAGS, false, KEY_READ ).Query( szFilename, 0 );

            //
            // Save the ANSI and UNICODE versions of the module name
            //
            #ifdef UNICODE
            WideCharToMultiByte( CP_ACP, 0, szFilename, -1, m_szModuleNameA, ARRAYSIZE(m_szModuleNameA), NULL, NULL );
            lstrcpyn( m_szModuleNameW, szFilename, MAX_PATH );
            #else
            MultiByteToWideChar( CP_ACP, 0, szFilename, -1, m_szModuleNameW, ARRAYSIZE(m_szModuleNameW) );
            lstrcpyn( m_szModuleNameA, szFilename, MAX_PATH );
            #endif
            
            //
            // Success!
            //
            m_bHaveModuleInformation = true;
            
            //
            // Tell the debugger we're here.  This way, the user can get the expected module name correct.
            //
            m_pfnPrintDebugMessageA( WiaDebugSeverityNormal, 0xFFFFFFFF, RGB(0xFF,0xFF,0xFF), RGB(0x00,0x00,0x00), m_szModuleNameA, "Created debug client" );
        }
    }

    return m_bHaveModuleInformation;
}


void CWiaDebugClient::Destroy(void)
{
    CAutoCriticalSection cs(m_CriticalSection);

    //
    // NULL out all of the function pointers
    //
    m_pfnIncrementDebugIndentLevel = NULL;
    m_pfnDecrementDebugIndentLevel = NULL;
    m_pfnPrintDebugMessageA = NULL;
    m_pfnPrintDebugMessageW = NULL;
    m_pfnGetDebugMask = NULL;
    m_pfnSetDebugMask = NULL;
    m_pfnAllocateDebugColor = NULL;
    m_pfnGetStringFromGuidW = NULL;
    m_pfnGetStringFromGuidA = NULL;
    m_pfnDoRecordAllocation = NULL;
    m_pfnDoRecordFree       = NULL;
    m_pfnDoReportLeaks      = NULL;
    m_pfnGetStringFromMsgA  = NULL;
    m_pfnGetStringFromMsgW  = NULL;

    //
    // Unload the DLL
    //
    if (m_hDebugModule)
    {
        FreeLibrary( m_hDebugModule );
        m_hDebugModule = NULL;
    }

    m_bHaveModuleInformation = false;
    m_bDebugLibLoadAttempted = false;
}

CWiaDebugClient::~CWiaDebugClient(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    Destroy();
}



DWORD CWiaDebugClient::GetDebugMask(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnGetDebugMask();
    }
    return 0;
}

DWORD CWiaDebugClient::SetDebugMask( DWORD dwNewMask )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnSetDebugMask( dwNewMask );
    }
    return 0;
}


int CWiaDebugClient::IncrementIndentLevel(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnIncrementDebugIndentLevel();
    }
    return 0;
}


int CWiaDebugClient::DecrementIndentLevel(void)
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        return m_pfnDecrementDebugIndentLevel();
    }
    return 0;
}


void CWiaDebugClient::RecordAllocation( LPVOID pv, size_t Size )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        m_pfnDoRecordAllocation( pv, Size );
    }
}

void CWiaDebugClient::RecordFree( LPVOID pv )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        m_pfnDoRecordFree( pv );
    }
}

void CWiaDebugClient::ReportLeaks( VOID )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        #ifdef UNICODE
        m_pfnDoReportLeaks(m_szModuleNameW);
        #else
        m_pfnDoReportLeaks(m_szModuleNameA);
        #endif
    }
}


CPushTraceMask::CPushTraceMask( DWORD dwTraceMask )
: m_dwOldMask(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    g_TheDebugClient.SetDebugMask( dwTraceMask );
}


CPushTraceMask::~CPushTraceMask(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    g_TheDebugClient.SetDebugMask( m_dwOldMask );
}


CPushIndentLevel::CPushIndentLevel( LPCTSTR pszFmt, ... )
: m_nIndentLevel(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );

    m_nIndentLevel = g_TheDebugClient.IncrementIndentLevel();

    TCHAR szMsg[1024];
    va_list arglist;

    va_start( arglist, pszFmt );
    wvsprintf( szMsg, pszFmt, arglist );
    va_end( arglist );

    g_TheDebugClient.PrintTraceMessage( TEXT("Entering function %s [Level %d]"), szMsg, m_nIndentLevel );
}


CPushIndentLevel::~CPushIndentLevel(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    if (m_nIndentLevel)
    {
        g_TheDebugClient.DecrementIndentLevel();
        g_TheDebugClient.PrintTraceMessage( TEXT("") );
    }
}


CPushTraceMaskAndIndentLevel::CPushTraceMaskAndIndentLevel( DWORD dwTraceMask, LPCTSTR pszFmt, ... )
: m_dwOldMask(0), m_nIndentLevel(0)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    
    m_dwOldMask = g_TheDebugClient.SetDebugMask( dwTraceMask );
    m_nIndentLevel = g_TheDebugClient.IncrementIndentLevel();

    TCHAR szMsg[1024];
    va_list arglist;

    va_start( arglist, pszFmt );
    wvsprintf( szMsg, pszFmt, arglist );
    va_end( arglist );

    g_TheDebugClient.PrintTraceMessage( TEXT("Entering function %s [Level %d]"), szMsg, m_nIndentLevel );
}


CPushTraceMaskAndIndentLevel::~CPushTraceMaskAndIndentLevel(void)
{
    CAutoCriticalSection cs( g_TheDebugClient.m_CriticalSection );
    if (m_nIndentLevel)
    {
        g_TheDebugClient.DecrementIndentLevel();
        g_TheDebugClient.PrintTraceMessage( TEXT("") );
        g_TheDebugClient.SetDebugMask( m_dwOldMask );
    }
}

////////////////////////////////////////////////////////////////
// UNICODE Versions of the output functions
////////////////////////////////////////////////////////////////
void CWiaDebugClient::PrintWarningMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityWarning, m_dwModuleDebugMask, WARNING_FOREGROUND_COLOR, WARNING_BACKGROUND_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintErrorMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityError, m_dwModuleDebugMask, ERROR_FOREGROUND_COLOR, ERROR_BACKGROUND_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintTraceMessage( LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( WiaDebugSeverityNormal, m_dwModuleDebugMask, m_crForegroundColor, DEFAULT_DEBUG_COLOR, m_szModuleNameW, szMsg );
    }
}

void CWiaDebugClient::PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageW( dwSeverity, m_dwModuleDebugMask, crForegroundColor, crBackgroundColor, m_szModuleNameW, szMsg );
    }
}


void CWiaDebugClient::PrintHResult( HRESULT hr, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024]=L"";
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        DWORD   dwLen = 0;
        LPTSTR  pMsgBuf = NULL;
        dwLen = ::FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPWSTR)&pMsgBuf, 0, NULL);

        COLORREF crForegroundColor;
        COLORREF crBackgroundColor;
        DWORD    dwSeverity;
        if (FAILED(hr))
        {
            crForegroundColor = ERROR_FOREGROUND_COLOR;
            crBackgroundColor = ERROR_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityError;
        }
        else if (S_OK == hr)
        {
            crForegroundColor = m_crForegroundColor;
            crBackgroundColor = DEFAULT_DEBUG_COLOR;
            dwSeverity        = WiaDebugSeverityNormal;
        }
        else
        {
            crForegroundColor = WARNING_FOREGROUND_COLOR;
            crBackgroundColor = WARNING_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityWarning;
        }
        if (dwLen)
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%ws: [0x%08X] %ws"), szMsg, hr, pMsgBuf );
            LocalFree(pMsgBuf);
        }
        else
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%ws: Unable to format message [0x%08X]"), szMsg, hr );
        }
    }
}


void CWiaDebugClient::PrintGuid( const IID &iid, LPCWSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szMsg[1024]=L"";
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfW( szMsg, pszFmt, arglist );
        va_end( arglist );

        WCHAR szGuid[MAX_PATH]=L"";
        if (m_pfnGetStringFromGuidW( &iid, szGuid, sizeof(szGuid)/sizeof(szGuid[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("%ws: %ws"), szMsg, szGuid );
        }
    }
}

void CWiaDebugClient::PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCWSTR szMessage )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        WCHAR szWindowMessage[MAX_PATH]=L"";
        if (m_pfnGetStringFromMsgW( uMsg, szWindowMessage, sizeof(szWindowMessage)/sizeof(szWindowMessage[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("0x%p, %-30ws, 0x%p, 0x%p%ws%ws"), hWnd, szWindowMessage, wParam, lParam, (szMessage && lstrlenW(szMessage)) ? L" : " : L"", (szMessage && lstrlenW(szMessage)) ? szMessage : L"" );
        }
    }
}

////////////////////////////////////////////////////////////////
// ANSI Versions of the output functions
////////////////////////////////////////////////////////////////
void CWiaDebugClient::PrintWarningMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityWarning, m_dwModuleDebugMask, WARNING_FOREGROUND_COLOR, WARNING_BACKGROUND_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintErrorMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityError, m_dwModuleDebugMask, ERROR_FOREGROUND_COLOR, ERROR_BACKGROUND_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintTraceMessage( LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( WiaDebugSeverityNormal, m_dwModuleDebugMask, m_crForegroundColor, DEFAULT_DEBUG_COLOR, m_szModuleNameA, szMsg );
    }
}

void CWiaDebugClient::PrintMessage( DWORD dwSeverity, COLORREF crForegroundColor, COLORREF crBackgroundColor, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024];
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        m_pfnPrintDebugMessageA( dwSeverity, m_dwModuleDebugMask, crForegroundColor, crBackgroundColor, m_szModuleNameA, szMsg );
    }
}


void CWiaDebugClient::PrintHResult( HRESULT hr, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024]="";
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        DWORD   dwLen = 0;
        LPTSTR  pMsgBuf = NULL;
        dwLen = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPSTR)&pMsgBuf, 0, NULL);

        COLORREF crForegroundColor;
        COLORREF crBackgroundColor;
        DWORD    dwSeverity;
        if (FAILED(hr))
        {
            crForegroundColor = ERROR_FOREGROUND_COLOR;
            crBackgroundColor = ERROR_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityError;
        }
        else if (S_OK == hr)
        {
            crForegroundColor = m_crForegroundColor;
            crBackgroundColor = DEFAULT_DEBUG_COLOR;
            dwSeverity        = WiaDebugSeverityNormal;
        }
        else
        {
            crForegroundColor = WARNING_FOREGROUND_COLOR;
            crBackgroundColor = WARNING_BACKGROUND_COLOR;
            dwSeverity        = WiaDebugSeverityWarning;
        }
        if (dwLen)
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%hs: [0x%08X] %hs"), szMsg, hr, pMsgBuf );
            LocalFree(pMsgBuf);
        }
        else
        {
            PrintMessage( dwSeverity, crForegroundColor, crBackgroundColor, TEXT("%hs: Unable to format message [0x%08X]"), szMsg, hr );
        }
    }
}


void CWiaDebugClient::PrintGuid( const IID &iid, LPCSTR pszFmt, ... )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szMsg[1024]="";
        va_list arglist;

        va_start( arglist, pszFmt );
        ::wvsprintfA( szMsg, pszFmt, arglist );
        va_end( arglist );

        CHAR szGuid[MAX_PATH]="";
        if (m_pfnGetStringFromGuidA( &iid, szGuid, sizeof(szGuid)/sizeof(szGuid[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("%hs: %hs"), szMsg, szGuid );
        }
    }
}

void CWiaDebugClient::PrintWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPCSTR szMessage )
{
    CAutoCriticalSection cs(m_CriticalSection);
    if (IsInitialized())
    {
        CHAR szWindowMessage[MAX_PATH]="";
        if (m_pfnGetStringFromMsgA( uMsg, szWindowMessage, sizeof(szWindowMessage)/sizeof(szWindowMessage[0]) ) )
        {
            PrintMessage( 0, m_crForegroundColor, DEFAULT_DEBUG_COLOR, TEXT("0x%p, %-30hs, 0x%p, 0x%p%hs%hs"), hWnd, szWindowMessage, wParam, lParam, (szMessage && lstrlenA(szMessage)) ? " : " : "", (szMessage && lstrlenA(szMessage)) ? szMessage : "" );
        }
    }
}

void CWiaDebugClient::SetInstance( HINSTANCE hInstance )
{
    m_hCurrentModuleInstance = hInstance;
}


static CSimpleString ForceFailureProgramKey( LPCTSTR pszProgramName )
{
    CSimpleString strAppKey( REGSTR_FORCEERR_KEY );
    strAppKey += TEXT("\\");
    strAppKey += pszProgramName;
    return strAppKey;
}

DWORD CWiaDebugClient::GetForceFailurePoint( LPCTSTR pszProgramName )
{
    return CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName) ).Query( REGSTR_ERROR_POINT, 0 );
}
    
HRESULT CWiaDebugClient::GetForceFailureValue( LPCTSTR pszProgramName, bool bPrintWarning )
{
    HRESULT hr = HRESULT_FROM_WIN32(CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName) ).Query( REGSTR_ERROR_VALUE, 0 ));
    if (bPrintWarning)
    {
        g_TheDebugClient.PrintHResult( hr, TEXT("FORCEERR: Forcing error return for program %s"), pszProgramName );
    }
    return hr;
}

void CWiaDebugClient::SetForceFailurePoint( LPCTSTR pszProgramName, DWORD dwErrorPoint )
{
    CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName), true ).Set( REGSTR_ERROR_POINT, dwErrorPoint );
}

void CWiaDebugClient::SetForceFailureValue( LPCTSTR pszProgramName, HRESULT hr )
{
    CSimpleReg( HKEY_FORCEERROR, ForceFailureProgramKey(pszProgramName), true ).Set( REGSTR_ERROR_VALUE, hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\deviceid.c ===
#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"
#include "deviceid.h"
#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"



#include "usbprint.h"


VOID StringSubst
(
    PUCHAR lpS,
    UCHAR chTargetChar,
    UCHAR chReplacementChar,
    USHORT cbS
)
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}

VOID
FixupDeviceId(
    IN OUT PUCHAR DeviceId
    )
/*++

Routine Description:

    This routine parses the NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PUCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= ' ') || (*p > (UCHAR)0x7F) || (*p == ',') ) {
            *p = '_';
        }
    }
}




NTSTATUS
ParPnpGetId
(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString
)
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS status;
    USHORT          checkSum=0;                     // A 16 bit check sum
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PUCHAR          MFG = NULL;                   // Manufature name
    PUCHAR          MDL = NULL;                   // Model name
    PUCHAR          CLS = NULL;                   // Class name
    PUCHAR          AID = NULL;                   // Hardare ID
    PUCHAR          CID = NULL;                   // Compatible IDs
    PUCHAR          DES = NULL;                   // Device Description

	USBPRINT_KdPrint2 (("'USBPRINT.SYS: Enter ParPnpGetId\n"));
    status = STATUS_SUCCESS;

    switch(Type) {

    case BusQueryDeviceID:
		 USBPRINT_KdPrint3 (("'USBPRINT.SYS: Inside case BusQueryID, DeviceIdString==%s\n",DeviceIdString));
        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        ParPnpFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);
		USBPRINT_KdPrint3 (("'USBPRINT.SYS: After FindDeviceIdKeys\n"));

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
			USBPRINT_KdPrint2 (("'USBPRINT.SYS: STATUS_NOT_FOUND\n"));
            goto ParPnpGetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);
        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen(DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {
        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst ((PUCHAR) resultString, ' ', '_', (USHORT)strlen(resultString));
    }

ParPnpGetId_Cleanup:

    return(status);
}


VOID
ParPnpFindDeviceIdKeys
(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
)
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/

{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    while (lpKey!=NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?

        if (!(lpValue = StringChr(lpKey, ':')) )
        {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON

        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //

        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //

        switch (*lpKey)
        {
            case 'M':
                // Look for MANUFACTURE (MFG) or MODEL (MDL)
                if ((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
                    (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) )
                {
                    *lppMFG = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=NULL)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                         (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) )
                {
                    *lppMDL = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'C':
                // Look for CLASS (CLS)
                if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                    (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) )
                {
                    *lppCLS = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                         (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) )
                {
                    *lppCID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue,';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'D':
                // Look for DESCRIPTION (DES)
                if (RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                    RtlCompareMemory(lpKey, "DES", wKeyLength) )
                {
                    *lppDES = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            case 'A':
                // Look for AUTOMATIC ID (AID)
                if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                    RtlCompareMemory(lpKey, "AID", wKeyLength) )
                {
                    *lppAID = lpValue;
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                else
                {
                    if ((lpKey = StringChr(lpValue, ';'))!=0)
                    {
                        *lpKey = '\0';
                        ++lpKey;
                    }
                }
                break;

            default:
                // The key is uninteresting.  Go to the next Key
                if ((lpKey = StringChr(lpValue, ';'))!=0)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
                break;
        }
    }
}



VOID
GetCheckSum(
    PUCHAR Block,
    USHORT Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = Block[i] ^ (UCHAR)crc;
         crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
    }

    *CheckSum = crc;

}

PUCHAR
StringChr(PCHAR string, CHAR c)
{
    ULONG   i=0;

    if (!string)
        return(NULL);

    while (*string) {
        if (*string==c)
            return(string);
        string++;
        i++;
    }

    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\deviceid.h ===
VOID StringSubst (
    IN OUT  PUCHAR lpS,
    IN      UCHAR chTargetChar,
    IN      UCHAR chReplacementChar,
    IN      USHORT cbS
    );

VOID
FixupDeviceId(
    IN OUT PUCHAR DeviceId
    );

NTSTATUS
ParPnpGetId (
    IN  PUCHAR  DeviceIdString,
    IN  ULONG   Type,
    OUT PUCHAR  resultString
    );

VOID
ParPnpFindDeviceIdKeys (
    OUT PUCHAR   *lppMFG,
    OUT PUCHAR   *lppMDL,
    OUT PUCHAR   *lppCLS,
    OUT PUCHAR   *lppDES,
    OUT PUCHAR   *lppAID,
    OUT PUCHAR   *lppCID,
    IN  PUCHAR   lpDeviceID
    );

VOID
GetCheckSum (
    IN  PUCHAR  Block,
    IN  USHORT  Len,
    OUT PUSHORT CheckSum
    );

PUCHAR
StringChr (
    IN  PCHAR string,
    IN  CHAR c
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\lib\psutil\simreg.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMREG.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Simple registry access class
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <simreg.h>

CSimpleReg::CSimpleReg( HKEY hkRoot, const CSimpleString &strSubKey, bool bCreate, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpsa )
: m_strKeyName(strSubKey),
  m_hRootKey(hkRoot),
  m_hKey(NULL),
  m_bCreate(bCreate),
  m_lpsaSecurityAttributes(lpsa),
  m_samDesiredAccess(samDesired)
{
    Open();
}

CSimpleReg::CSimpleReg(void)
: m_strKeyName(TEXT("")),
  m_hRootKey(NULL),
  m_hKey(NULL),
  m_bCreate(false),
  m_lpsaSecurityAttributes(NULL),
  m_samDesiredAccess(0)
{
}

CSimpleReg::CSimpleReg(const CSimpleReg &other)
: m_strKeyName(other.GetSubKeyName()),
  m_hRootKey(other.GetRootKey()),
  m_hKey(NULL),
  m_bCreate(other.GetCreate()),
  m_lpsaSecurityAttributes(other.GetSecurityAttributes()),
  m_samDesiredAccess(other.DesiredAccess())
{
    Open();
}

CSimpleReg::~CSimpleReg(void)
{
    Close();
    m_hRootKey = NULL;
    m_lpsaSecurityAttributes = NULL;
}

CSimpleReg &CSimpleReg::operator=(const CSimpleReg &other )
{
    if (this != &other)
    {
        Close();
        m_strKeyName = other.GetSubKeyName();
        m_hRootKey = other.GetRootKey();
        m_bCreate = other.GetCreate();
        m_lpsaSecurityAttributes = other.GetSecurityAttributes();
        m_samDesiredAccess = other.DesiredAccess();
        Open();
    }
    return(*this);
}

bool CSimpleReg::Open(void)
{
    HKEY hkKey = NULL;
    LONG nRet;
    DWORD bCreatedNewKey = 0;

    Close();
    if (m_bCreate)
        nRet = RegCreateKeyEx( m_hRootKey, m_strKeyName.String(), 0, TEXT(""), REG_OPTION_NON_VOLATILE, m_samDesiredAccess?m_samDesiredAccess:KEY_ALL_ACCESS, m_lpsaSecurityAttributes, &hkKey, &bCreatedNewKey );
    else nRet = RegOpenKeyEx( m_hRootKey, m_strKeyName.String(), 0, m_samDesiredAccess?m_samDesiredAccess:KEY_ALL_ACCESS, &hkKey );

    if (nRet == ERROR_SUCCESS)
        m_hKey = hkKey;

    return(m_hKey != NULL);
}

bool CSimpleReg::Close(void)
{
    __try  // In case the key was closed by someone else
    {
        if (OK())
            RegCloseKey(m_hKey);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
    }
    m_hKey = NULL;
    return(true);
}

bool CSimpleReg::Flush(void)
{
    if (!OK())
        return(false);
    return(ERROR_SUCCESS == RegFlushKey(m_hKey));
}

bool CSimpleReg::IsStringValue( DWORD nType )
{
    if (nType != REG_SZ && nType != REG_EXPAND_SZ && nType != REG_MULTI_SZ && nType != REG_LINK && nType != REG_RESOURCE_LIST)
        return(false);
    else return(true);
}

// Query functions
DWORD CSimpleReg::Size( const CSimpleString &strValueName ) const
{
    if (!OK())
        return(0);
    DWORD nType;
    DWORD nSize=0;
    LONG Ret = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, NULL, &nSize);
    if (Ret==ERROR_SUCCESS)
    {
        return(nSize);
    }
    else return (0);
}

DWORD CSimpleReg::Type( const CSimpleString &key ) const
{
    if (!OK())
        return(0);
    DWORD dwType;
    DWORD dwSize;
    LONG Ret = RegQueryValueEx( m_hKey, key.String(), NULL, &dwType, NULL, &dwSize);
    if (Ret==ERROR_SUCCESS)
    {
        return(dwType);
    }
    else return(0);
}


CSimpleString CSimpleReg::Query( const CSimpleString &strValueName, const CSimpleString &strDef ) const
{
    // If the key is not open, or if this value is not a string type, return the default
    if (!OK() || !IsStringValue(Type(strValueName)))
        return(strDef);
    DWORD nSize = Size(strValueName) / sizeof(TCHAR);
    LPTSTR lpszTmp = new TCHAR[nSize];
    CSimpleString strTmp;
    if (lpszTmp)
    {
        Query( strValueName, strDef, lpszTmp, nSize );
        strTmp = lpszTmp;
        delete[] lpszTmp;
    }
    return(strTmp);
}

LPTSTR CSimpleReg::Query( const CSimpleString &strValueName, const CSimpleString &strDef, LPTSTR pszBuffer, DWORD nLen ) const
{
    // If the key is not open, or if this value is not a string type, return the default
    if (nLen <= 0 || !OK() || !IsStringValue(Type(strValueName)))
    {
        lstrcpyn( pszBuffer, strDef.String(), nLen );
        pszBuffer[nLen-1] = TEXT('\0');
        return(pszBuffer);
    }
    DWORD nSize = (DWORD)(nLen * sizeof(pszBuffer[0]));
    DWORD nType;
    LONG nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, (PBYTE)pszBuffer, &nSize);
    if (ERROR_SUCCESS != nRet)
    {
        lstrcpyn( pszBuffer, strDef.String(), nLen );
        pszBuffer[nLen-1] = TEXT('\0');
    }
    return(pszBuffer);
}

DWORD CSimpleReg::Query( const CSimpleString &strValueName, DWORD nDef ) const
{
    if (!OK() || (REG_DWORD != Type(strValueName)) || (sizeof(DWORD) != Size(strValueName)))
        return(nDef);
    DWORD nValue;
    DWORD nType;
    DWORD nSize = sizeof(DWORD);
    LONG nRet;
    nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, (PBYTE)&nValue, &nSize);
    if (ERROR_SUCCESS == nRet)
        return(nValue);
    else return(nDef);
}


bool CSimpleReg::Set( const CSimpleString &strValueName, const CSimpleString &strValue, DWORD nType ) const
{  // Set a REG_SZ value for the specified key.
    if (!OK())
        return(false);
    LONG nRet;
    nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, nType, (PBYTE)strValue.String(), sizeof(strValue[0])*(strValue.Length()+1) );
    return(ERROR_SUCCESS==nRet);
}

bool CSimpleReg::Set( const CSimpleString &strValueName, DWORD nValue ) const
{  // Set a REG_SZ value for the specified key.
    if (!OK())
        return(false);
    LONG nRet;
    nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, REG_DWORD, (PBYTE)&nValue, sizeof(DWORD) );
    return(ERROR_SUCCESS==nRet);
}

DWORD CSimpleReg::QueryBin( const CSimpleString &strValueName, PBYTE pData, DWORD nMaxLen ) const
{
    if (!OK())
        return (0);
    if (nMaxLen <= 0)
        return (Size(strValueName.String()));
    DWORD nType;
    DWORD nSize = nMaxLen;
    LONG nRet = RegQueryValueEx( m_hKey, strValueName.String(), NULL, &nType, pData, &nSize );
    if (ERROR_SUCCESS!=nRet)
        return (0);
    return (nSize);
}

bool CSimpleReg::SetBin( const CSimpleString &strValueName, const PBYTE pValue, DWORD nLen, DWORD dwType ) const
{
    if (!OK())
        return(false);
    LONG nRet = RegSetValueEx( m_hKey, strValueName.String(), 0, dwType, (PBYTE)pValue, nLen );
    return(ERROR_SUCCESS==nRet);
}

DWORD CSimpleReg::SubKeyCount(void) const
{
    TCHAR szClass[256]=TEXT("");
    DWORD nClassSize = sizeof(szClass)/sizeof(szClass[0]);
    DWORD nSubKeyCount=0;
    RegQueryInfoKey(m_hKey,szClass,&nClassSize,NULL,&nSubKeyCount,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
    return(nSubKeyCount);
}

HKEY CSimpleReg::GetHkeyFromName( const CSimpleString &strName )
{
    static const struct
    {
        LPCTSTR pszName;
        HKEY hkKey;
    } KeyNames[] =
    {
        { TEXT("HKEY_CLASSES_ROOT"),   HKEY_CLASSES_ROOT},
        { TEXT("HKEY_CURRENT_USER"),   HKEY_CURRENT_USER},
        { TEXT("HKEY_LOCAL_MACHINE"),  HKEY_LOCAL_MACHINE},
        { TEXT("HKEY_USERS"),          HKEY_USERS},
        { TEXT("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG},
        { TEXT("HKEY_DYN_DATA"),       HKEY_DYN_DATA},
        { TEXT("HKCR"),                HKEY_CLASSES_ROOT},
        { TEXT("HKCU"),                HKEY_CURRENT_USER},
        { TEXT("HKLM"),                HKEY_LOCAL_MACHINE},
        { TEXT("HKU"),                 HKEY_USERS},
        { TEXT("HKCC"),                HKEY_CURRENT_CONFIG},
        { TEXT("HKDD"),                HKEY_DYN_DATA},
        { NULL, NULL}
    };
    for (int i=0;KeyNames[i].pszName;i++)
    {
        if (!lstrcmpi(strName.String(),KeyNames[i].pszName))
            return(KeyNames[i].hkKey);
    }
    return(NULL);
}

bool CSimpleReg::Delete( HKEY hkRoot, const CSimpleString &strKeyName )
{
    return(RegDeleteKey(hkRoot, strKeyName.String()) == ERROR_SUCCESS);
}

bool CSimpleReg::Delete( const CSimpleString &strValue )
{
    if (!OK())
        return(false);
    return(RegDeleteValue( m_hKey, strValue.String() ) == ERROR_SUCCESS);
}

bool CSimpleReg::DeleteRecursively( HKEY hkRoot, const CSimpleString &strKeyName )
{
    if (CSimpleReg( hkRoot, strKeyName ).RecurseKeys( DeleteEnumKeyProc, NULL, CSimpleReg::PostOrder ))
        return(CSimpleReg::Delete( hkRoot, strKeyName ));
    else return(false);
}

bool CSimpleReg::EnumValues( SimRegValueEnumProc enumProc, LPARAM lParam )
{
    TCHAR szName[256];
    DWORD nSize;
    DWORD nType;
    bool bResult = true;
    for (int i=0;;i++)
    {
        nSize = sizeof(szName) / sizeof(szName[0]);
        if (RegEnumValue(m_hKey,i,szName,&nSize,NULL,&nType,NULL,NULL) != ERROR_SUCCESS)
            break;
        CValueEnumInfo info(*this,szName,nType,nSize,lParam);
        if (enumProc)
        {
            if (!enumProc(info))
            {
                bResult = false;
                break;
            }
        }
    }
    return(bResult);
}

bool CSimpleReg::RecurseKeys( SimRegKeyEnumProc enumProc, LPARAM lParam, int recurseOrder, bool bFailOnOpenError ) const
{
    return(DoRecurseKeys(m_hKey, TEXT(""), enumProc, lParam, 0, recurseOrder, bFailOnOpenError ));
}

bool CSimpleReg::EnumKeys( SimRegKeyEnumProc enumProc, LPARAM lParam, bool bFailOnOpenError ) const
{
    return(DoEnumKeys(m_hKey, TEXT(""), enumProc, lParam, bFailOnOpenError ));
}

bool CSimpleReg::DoRecurseKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, int nLevel, int recurseOrder, bool bFailOnOpenError )
{
    TCHAR szName[256]=TEXT("");
    DWORD nNameSize;
    TCHAR szClass[256]=TEXT("");
    DWORD nClassSize;
    FILETIME ftFileTime;
    CSimpleReg reg(hkKey,root);
    LONG lRes;
    if (!reg.OK())
        return(bFailOnOpenError ? false : true);
    DWORD nSubKeyCount = reg.SubKeyCount();
    for (DWORD i=nSubKeyCount;i>0;i--)
    {
        nNameSize = sizeof(szName)/sizeof(szName[0]);
        nClassSize = sizeof(szClass)/sizeof(szClass[0]);
        if ((lRes=RegEnumKeyEx(reg.GetKey(),i-1,szName,&nNameSize,NULL,szClass,&nClassSize,&ftFileTime)) != ERROR_SUCCESS)
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.strName = szName;
        EnumInfo.hkRoot = reg.GetKey();
        EnumInfo.nLevel = nLevel;
        EnumInfo.lParam = lParam;
        if (enumProc && recurseOrder==PreOrder)
            if (!enumProc(EnumInfo))
                return(false);
        if (!DoRecurseKeys(reg.GetKey(),szName,enumProc,lParam,nLevel+1,recurseOrder, bFailOnOpenError))
            return(false);
        if (enumProc && recurseOrder==PostOrder)
            if (!enumProc(EnumInfo))
                return(false);
    }
    return(true);
}

bool CSimpleReg::DoEnumKeys( HKEY hkKey, const CSimpleString &root, SimRegKeyEnumProc enumProc, LPARAM lParam, bool bFailOnOpenError )
{
    TCHAR szName[256]=TEXT("");
    DWORD szNameSize;
    TCHAR szClass[256]=TEXT("");
    DWORD szClassSize;
    FILETIME ftFileTime;
    CSimpleReg reg(hkKey,root);
    LONG lRes;
    if (!reg.OK())
        return(bFailOnOpenError ? false : true);
    DWORD nSubKeyCount = reg.SubKeyCount();
    for (DWORD i=nSubKeyCount;i>0;i--)
    {
        szNameSize = sizeof(szName)/sizeof(szName[0]);
        szClassSize = sizeof(szClass)/sizeof(szClass[0]);
        if ((lRes=RegEnumKeyEx(reg.GetKey(),i-1,szName,&szNameSize,NULL,szClass,&szClassSize,&ftFileTime)) != ERROR_SUCCESS)
        {
            break;
        }
        CKeyEnumInfo EnumInfo;
        EnumInfo.strName = szName;
        EnumInfo.hkRoot = reg.GetKey();
        EnumInfo.nLevel = 0;
        EnumInfo.lParam = lParam;
        if (!enumProc(EnumInfo))
            return(false);
    }
    return(true);
}

bool CSimpleReg::DeleteEnumKeyProc( CSimpleReg::CKeyEnumInfo &enumInfo )
{
    return(CSimpleReg::Delete( enumInfo.hkRoot, enumInfo.strName ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\ioctl.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

        

Environment:

    Kernel & user mode

Revision History:


--*/

#define USBPRINT_IOCTL_INDEX  0x0000


// @@BEGIN_DDKSPLIT



#define IOCTL_USBPRINT_GET_PIPE_INFO     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_GET_CONFIG_DESCRIPTOR     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+1,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)
                                                   
#define IOCTL_USBPRINT_SET_PIPE_PARAMETER     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+2,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_STOP_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+3,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_USBPRINT_START_ISO_STREAM     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+4,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   

#define IOCTL_USBPRINT_REGISTER_NOTIFY_EVENT   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+5,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_START_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+6,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_STOP_PERF_TIMER   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+7,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   
                                                   
#define IOCTL_USBPRINT_RETURN_PERF_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+8,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                   

#define IOCTL_USBPRINT_RESET_DEVICE   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+9,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                              
                                                   
#define IOCTL_USBPRINT_CLOCK_MASTER_TEST   CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+10,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)      

#define IOCTL_USBPRINT_RESET_PIPE  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+11,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

// @@END_DDKSPLIT
#define IOCTL_USBPRINT_GET_LPT_STATUS  CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+12,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_GET_1284_ID     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+13,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_SET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+14,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_VENDOR_GET_COMMAND CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+15,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

#define IOCTL_USBPRINT_SOFT_RESET         CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   USBPRINT_IOCTL_INDEX+16,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)                                                           

// @@BEGIN_DDKSPLIT

#include <PSHPACK1.H>

#define BULK      0
#define INTERRUPT 1
#define CONTROL   2
#define ISO       3

typedef struct _USBPRINT_PIPE_PERF_INFO {
    ULONG					BytesPerSecond;
	ULONG					ClockCyclesPerByte;
} USBPRINT_PIPE_PERF_INFO, *PUSBPRINT_PIPE_PERF_INFO;

typedef struct _USBPRINT_PIPE_INFO {
    BOOLEAN					In;
    UCHAR					PipeType;
    UCHAR					EndpointAddress;
    UCHAR					Interval;
    ULONG					MaximumPacketSize;
    ULONG					MaximumTransferSize;
    UCHAR					Name[32];
	USBPRINT_PIPE_PERF_INFO	PerfInfo;
} USBPRINT_PIPE_INFO, *PUSBPRINT_PIPE_INFO;


typedef struct _USBPRINT_INTERFACE_INFO {
    ULONG PipeCount;
    USBPRINT_PIPE_INFO Pipes[0];    
} USBPRINT_INTERFACE_INFO, *PUSBPRINT_INTERFACE_INFO;



#include <POPPACK.H>


// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\print.inc ===
!if 0

Copyright (c) 1996  Microsoft Corporation

Common stuff for all printer drivers

!endif

OEMDRV_ROOT=$(BASEDIR)\printscan\oem\src\print\drivers\usermode\oemdrv

C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE

INCLUDES=$(PRNROOT)\inc


!ifndef SDXROOT
# This block is used to build in Windows 2000 building environment 
# where SDXROOT is not defined
WINDOWS_LIB_PATH=$(SDK_LIB_PATH)
!endif

!if defined(WINNT_40)       # NT4 kernel-mode driver

C_DEFINES=$(C_DEFINES) -DMEMDEBUG -DWINNT_40

!elseif defined(KM_DRIVER)  # NT5 kernel-mode driver

C_DEFINES=$(C_DEFINES) -DMEMDEBUG

!else                       # NT5 user-mode driver

C_DEFINES=$(C_DEFINES) -DUSERMODE_DRIVER

!endif

MSC_WARNING_LEVEL=/W3 /WX

!ifndef FREEBUILD
# Tweak to work with NT4 makefile.def
!ifdef NTDEBUG
FREEBUILD=0
!else
FREEBUILD=1
!endif
!endif
!ifndef AXP64
AXP64=0
!endif


!ifdef DDKBUILD
BUILD_FROM_DDK=1
C_DEFINES=$(C_DEFINES) -DBUILD_FROM_DDK
!endif

!if defined(ADOBE)
C_DEFINES=$(C_DEFINES) -DADOBE
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\ioctl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ioctl.c

Abstract:

    Device driver for USB printers

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"
#include "usbprint.h"

#include "ioctl.h"
#include "usbdlib.h"
#include "ntddpar.h"


int USBPRINT_GetLptStatus(IN PDEVICE_OBJECT DeviceObject);
NTSTATUS HPUsbIOCTLVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS HPUsbIOCTLVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS HPUsbVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PUCHAR buffer,IN ULONG  length);
NTSTATUS HPUsbVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PUCHAR buffer,IN ULONG  length,OUT PULONG pBytesRead);

NTSTATUS USBPRINT_SoftReset(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
  Issues the class specific "Soft reset" command to the printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.


Return Value:

  ntStatus of the URB

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_SoftReset\n"));

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {
        UsbBuildVendorRequest(urb, //urb
                                          URB_FUNCTION_CLASS_INTERFACE, //request target
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                                                          USBD_TRANSFER_DIRECTION_OUT|USBD_SHORT_TRANSFER_OK, //flags
                                                          0, //reserved bits
                                                          2, //request code
                                                          0,  //wValue
                                                          deviceExtension->Interface->InterfaceNumber<<8, //wIndex
                                                          NULL, //return buffer address
                                                          NULL, //mdl
                                                          0, //return length
                                                          NULL); //link param

        timeOut.QuadPart = FAILURE_TIMEOUT;
                ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

        if (NT_SUCCESS(ntStatus)    &&
            urb->UrbControlVendorClassRequest.TransferBufferLength > 2)
        {
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
        }
        else
        {
          USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed"));
        }
        ExFreePool(urb);
        } /*end if URB OK*/
        else
      {
         USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  urb allocation failed"));
         ntStatus=STATUS_NO_MEMORY;
      }
    return ntStatus;
} /*end function Get1284_Id*/



int USBPRINT_Get1284Id(IN PDEVICE_OBJECT DeviceObject,PVOID pIoBuffer,int iLen)
/*++

Routine Description:
  Requests and returns Printer 1284 Device ID

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer device.
        pIoBuffer    - pointer to IO buffer from user mode
        iLen         - Length of *pIoBuffer;




Return Value:

    Success: Length of data written to *pIoBuffer (icluding lenght field in first two bytes of data)
        Failure: -1

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    int iReturn = -1;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_Get1284\n"));

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {
        siz = iLen;
        UsbBuildVendorRequest(urb, //urb

                                          URB_FUNCTION_CLASS_INTERFACE, //request target
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), //request len
                                                          USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK, //flags
                                                          0, //reserved bits
                                                          0, //request code
                                                          0,  //wValue
                                                          deviceExtension->Interface->InterfaceNumber<<8, //wIndex
                                                          pIoBuffer, //return buffer address
                                                          NULL, //mdl
                                                          iLen, //return length
                                                          NULL); //link param

        timeOut.QuadPart = FAILURE_TIMEOUT;
        ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
        USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));

        if (NT_SUCCESS(ntStatus)    &&
            urb->UrbControlVendorClassRequest.TransferBufferLength > 2)
        {
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
            iReturn= *((unsigned char *)pIoBuffer);
            iReturn<<=8;
            iReturn+=*(((unsigned char *)pIoBuffer)+1);
            if ( iReturn > 0 && iReturn < iLen )
            {

                *(((char *)pIoBuffer)+iReturn)='\0';
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: return size ==%d\n",iReturn));
            }
            else
            {
                iReturn = -1;
            }
        }
        else
                {
                        USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed\n"));
                        iReturn=-1;
                }
        ExFreePool(urb);
        } /*end if URB OK*/
        else
        {
                USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  urb allocation failed"));
                iReturn=-1;
        }
    return iReturn;
} /*end function Get1284_Id*/

int USBPRINT_GetLptStatus(IN PDEVICE_OBJECT DeviceObject)
/*++

Routine Description:
  Requests and returns Printer status byte from USB printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the printer   device.


Return Value:

    Success: status value 0-255
        Failure: -1

--*/
{

    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
        unsigned char RETURN_BUFF[1];
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER   timeOut;


    RETURN_BUFF[0] = 0;

    timeOut.QuadPart = FAILURE_TIMEOUT;

        deviceExtension = DeviceObject->DeviceExtension;
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), USBP_TAG);

    if (urb) {


        siz = sizeof(RETURN_BUFF);


        UsbBuildVendorRequest(urb,
                                          URB_FUNCTION_CLASS_INTERFACE,
                                          sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                                                          USBD_TRANSFER_DIRECTION_IN|USBD_SHORT_TRANSFER_OK,
                                                          0, //reserved bits
                                                          1, //request code
                                                          0,
                                                          deviceExtension->Interface->InterfaceNumber,
                                                          RETURN_BUFF, //return buffer address
                                                          NULL, //mdl
                                                          sizeof(RETURN_BUFF), //return length
                                                          NULL); //link param


                ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
                USBPRINT_KdPrint3 (("'USBPRINT.SYS: urb->Hdr.Status=%d\n",((struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *)urb)->Hdr.Status));
                ExFreePool(urb);

        if (NT_SUCCESS(ntStatus))
                {
                        USBPRINT_KdPrint3 (("'USBPRINT.SYS: CallUSBD succeeded\n"));
                        return (int) RETURN_BUFF[0];
                }
                else
                {
                        USBPRINT_KdPrint1(("'USBPRINT.SYS: Error;  CallUSBD failed"));
            return -1;
                }
        } /*end if URB OK*/
    else {
        return -1;
    }

} /*end function GetLptStatus*/



PUSB_CONFIGURATION_DESCRIPTOR
USBPRINT_GetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_GetConfigDescriptor\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), USBP_TAG);

    if (urb) {


        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;

get_config_descriptor_retry2:

        configurationDescriptor = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG);

        if (configurationDescriptor) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,
                                         NULL);

            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);

            USBPRINT_KdPrint3 (("'USBPRINT.SYS: Configuration Descriptor = %x, len %x\n",
                            configurationDescriptor,
                            urb->UrbControlDescriptorRequest.TransferBufferLength));
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus) &&
            (urb->UrbControlDescriptorRequest.TransferBufferLength >=
             sizeof(USB_CONFIGURATION_DESCRIPTOR)) &&
            (configurationDescriptor->wTotalLength >=
             sizeof(USB_CONFIGURATION_DESCRIPTOR)))
        {
            //
            // The Get Config Descriptor request did not return an error
            // AND at least enough data was transferred to fill a Config
            // Descriptor AND the Config Descriptor wLength is at least the
            // size of a Config Descriptor
            //
            if (configurationDescriptor->wTotalLength > siz)
            {
                //
                // The request buffer is not big enough to hold the
                // entire set of descriptors.  Free the current buffer
                // and retry with a buffer which should be big enough.
                //
                siz = configurationDescriptor->wTotalLength;
                ExFreePool(configurationDescriptor);
                configurationDescriptor = NULL;
                goto get_config_descriptor_retry2;
            }
            else if (configurationDescriptor->wTotalLength >
                     urb->UrbControlDescriptorRequest.TransferBufferLength)
            {
                //
                // The request buffer is greater than or equal to the
                // Config Descriptor wLength, but less data was transferred
                // than wLength.  Return NULL to indicate a device error.
                //
                ExFreePool(configurationDescriptor);
                configurationDescriptor = NULL;
            }
            //
            // else  everything is OK with the Config Descriptor, return it.
            //
        }
        else
        {
            //
            // The Get Config Descriptor request returned an error OR
            // not enough data was transferred to fill a Config Descriptor
            // OR the Config Descriptor wLength is less than the size of
            // a Config Descriptor.  Return NULL to indicate a device error.
            //
            ExFreePool(configurationDescriptor);
            configurationDescriptor = NULL;
        }

        ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: exit USBPRINT_GetConfigDescriptor\n"));

    return configurationDescriptor;
}



typedef enum _CLOCKMASTER_OP {
    TakeControl,
    FreeControl,
    ChangeClock,
    GetClock
} CLOCKMASTER_OP;

NTSTATUS
USBPRINT_ClockMaster(
    IN PDEVICE_OBJECT DeviceObject,
    IN CLOCKMASTER_OP Op
    )
/*++

Routine Description:

    modifies the USB SOF clock

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    USHORT siz;
    USHORT func;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: ClockMaster\n"));

    switch(Op) {
    case TakeControl:
        func = URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL;
        siz = sizeof(struct _URB_FRAME_LENGTH_CONTROL);
        break;
    case FreeControl:
        func = URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL;
        siz = sizeof(struct _URB_FRAME_LENGTH_CONTROL);
        break;
    case ChangeClock:
        siz = sizeof(struct _URB_SET_FRAME_LENGTH);
        func = URB_FUNCTION_SET_FRAME_LENGTH;
        break;
    case GetClock:
        siz = sizeof(struct _URB_GET_FRAME_LENGTH);
        func = URB_FUNCTION_GET_FRAME_LENGTH;
        break;
    }

    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST), USBP_TAG);

    if (urb) {

        switch(Op) {
        case TakeControl:
        case FreeControl:
        case GetClock:
            break;
        case ChangeClock:
            urb->UrbSetFrameLength.FrameLengthDelta = 1;
            break;
        }

        urb->UrbHeader.Length = siz;
        urb->UrbHeader.Function = func;

        //
        // Do we need a timeout here?
        //
        ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, NULL);

        switch(Op) {
        case TakeControl:
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: TakeControl\n"));
            break;
        case FreeControl:
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: FreeControl\n"));
            break;
        case GetClock:
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: GetClock %d\n", urb->UrbGetFrameLength.FrameLength));
            break;
        case ChangeClock:
            USBPRINT_KdPrint3 (("'USBPRINT.SYS: ChangeClock\n"));
            break;
        }

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: clock op status = %x urb = %x\n", ntStatus,
            urb->UrbHeader.Status));

        ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBPRINT_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    returns the port status for our device

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_GetPortStatus\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: calling USBD port status api\n"));

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: return from IoCallDriver USBD (in getportstatus)%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

         if (!NT_SUCCESS(ntStatus))
         {
           USBPRINT_KdPrint1 (("'USBPRINT.SYS: Error! IoCallDriver failed\n"));
         }
         else
         {
           USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success! IoCallDriver did not fail\n"));
         }


    USBPRINT_KdPrint3 (("'USBPRINT.SYS: Port status = %x\n", *PortStatus));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: USBPRINT_GetPortStatus (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Reset the our parent port

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: enter USBPRINT_ResetPort\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                deviceExtension->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: calling USBD enable port api\n"));

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: return from IoCallDriver USBD (in reset parent port)%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBPRINT_KdPrint3 (("'USBPRINT.SYS: USBPRINT_ResetPort (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    ULONG ioControlCode;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PUCHAR pch;

    USBPRINT_KdPrint2 (("'USBPRINT.SYS: IRP_MJ_DEVICE_CONTROL\n"));

    USBPRINT_IncrementIoCount(DeviceObject);

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->AcceptingRequests == FALSE) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest (Irp,
                           IO_NO_INCREMENT
                          );

        USBPRINT_DecrementIoCount(DeviceObject);
        return ntStatus;
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    Irp->IoStatus.Information = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // Handle Ioctls from User mode
    //

    switch (ioControlCode) {

    case IOCTL_USBPRINT_SET_PIPE_PARAMETER:

        ntStatus = STATUS_SUCCESS;
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID:
    {
        int iReturn;
        char * pTempBuffer;


        USBPRINT_KdPrint1 (("'USBPRINT.SYS: Enter in PAR_QUERY_DEVICE_ID\n"));

        pTempBuffer=ExAllocatePool(NonPagedPool,outputBufferLength+3); //3 == 2 bytes for the size at the beginning, plus 1 for the null at the end
        if(pTempBuffer==NULL)
        {
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_NO_MEMORY;
        }
        else
        {
                   iReturn=USBPRINT_Get1284Id(DeviceObject,pTempBuffer,outputBufferLength+2);
                   if(iReturn>0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in PAR_QUERY_DEVICE_ID\n"));
                         Irp->IoStatus.Information=iReturn-1;
             *(pTempBuffer+iReturn)='\0';
             RtlCopyBytes(ioBuffer,pTempBuffer+2,iReturn-1); //+2 to step past the size bytes at the beginning, -1 is +1 for null -2 for size bytes
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in PAR_QUERY_DEVICE_ID\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
           ExFreePool(pTempBuffer);
        } /*end else malloc OK*/
        USBPRINT_KdPrint1 (("'USBPRINT.SYS: Exit in PAR_QUERY_DEVICE_ID\n"));
    }
    break;

    case IOCTL_USBPRINT_SOFT_RESET:

        ntStatus=USBPRINT_SoftReset(DeviceObject);

        Irp->IoStatus.Information=0;
    break;



    case IOCTL_USBPRINT_GET_1284_ID:
        {
                 int iReturn;

                 pch = (PUCHAR) ioBuffer;

                 if(outputBufferLength<sizeof(UCHAR))
                 {
                   USBPRINT_KdPrint1 (("'USBPRINT.SYS: Buffer to small in GET_1284_ID\n"));
                   Irp->IoStatus.Information=0;
                   ntStatus=STATUS_BUFFER_TOO_SMALL;
                 }
                 else
                 {
                   iReturn=USBPRINT_Get1284Id(DeviceObject,ioBuffer,outputBufferLength);
                   if(iReturn>=0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in GET_1284_ID\n"));
                         *pch=(UCHAR)iReturn;
                         Irp->IoStatus.Information=iReturn;
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in GET_1284_ID\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
                 } /*end else buffer len OK*/
        }
        break; //end case GET_1284_ID

        case IOCTL_USBPRINT_GET_LPT_STATUS:
        {
                 int iReturn;
                 pch = (PUCHAR) ioBuffer;

                 if(outputBufferLength<sizeof(UCHAR))
                 {
                   USBPRINT_KdPrint1 (("'USBPRINT.SYS: Buffer to small in GET_LPT_STATUS\n"));
                   Irp->IoStatus.Information=0;
                   ntStatus=STATUS_BUFFER_TOO_SMALL;
                 }
                 else
                 {
                   iReturn= USBPRINT_GetLptStatus(DeviceObject);
                   if(iReturn>=0)
                   {
                         USBPRINT_KdPrint3 (("'USBPRINT.SYS: Success in GET_LPT_STATUS\n"));
                         *pch=(UCHAR)iReturn;
                         Irp->IoStatus.Information=1;
                         ntStatus=STATUS_SUCCESS;
                   } /*if success*/
                   else
                   {
                         USBPRINT_KdPrint1 (("'USBPRINT.SYS: Failure in GET_LPT_STATUS\n"));
                         Irp->IoStatus.Information=0;
                         ntStatus=STATUS_DEVICE_DATA_ERROR;
                   } /*else failure*/
                 } /*end else buffer OK*/
        }
        break;


    case IOCTL_USBPRINT_VENDOR_SET_COMMAND:

        ntStatus=HPUsbIOCTLVendorSetCommand(DeviceObject,Irp);

    break;


    case IOCTL_USBPRINT_VENDOR_GET_COMMAND:

        ntStatus=HPUsbIOCTLVendorGetCommand(DeviceObject,Irp);

    break;


    case IOCTL_USBPRINT_RESET_DEVICE:

        {
        ULONG portStatus;

        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Reset Device Test\n"));

        TRAP(); // test this
        //
        // Check the port state, if it is disabled we will need
        // to re-enable it
        //
        ntStatus = USBPRINT_GetPortStatus(DeviceObject, &portStatus);

          if (NT_SUCCESS(ntStatus) && !(portStatus & USBD_PORT_ENABLED) &&portStatus & USBD_PORT_CONNECTED)
                  {
            //
            // port is disabled, attempt reset
            //
            //USBPRINT_EnableParentPort(DeviceObject);
                        USBPRINT_KdPrint2 (("'USBPRINT.SYS: Resetting port\n"));
            USBPRINT_ResetParentPort(DeviceObject);
                  }

        }
        break;

    case IOCTL_USBPRINT_CLOCK_MASTER_TEST:

        {
        USBPRINT_KdPrint3 (("'USBPRINT.SYS: Clock Master Test\n"));

        TRAP(); // test this

        // get the clock
        USBPRINT_ClockMaster(DeviceObject, GetClock);

        // take control to change clock
        //ntStatus = USBPRINT_ClockMaster(DeviceObject, TakeControl);

        //if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBPRINT_ClockMaster(DeviceObject, ChangeClock);
        //}

        USBPRINT_ClockMaster(DeviceObject, FreeControl);

        }
        break;


    default:

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    USBPRINT_DecrementIoCount(DeviceObject);

    return ntStatus;

}







/****************STUFF FROM HP:*************************/

/*-------------------------------------------------------------------------------
 * HPUsbIOCTLVendorSetCommand() - Send a vendor defined SET command
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbIOCTLVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
        // Local Variables
    NTSTATUS                    ntStatus;
    PIO_STACK_LOCATION  currentIrpStack;

        // Set up a local pointer to the Irp stack
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

        // Send the SET command
        ntStatus = HPUsbVendorSetCommand(DeviceObject,
                                         (PUCHAR) Irp->AssociatedIrp.SystemBuffer,
                                                                     currentIrpStack->Parameters.DeviceIoControl.InputBufferLength);

        // Set the Irp information values
        Irp->IoStatus.Status            = ntStatus;
        Irp->IoStatus.Information       = 0;

        // Return
        return ntStatus;
}

/*-------------------------------------------------------------------------------
 * HPUsbIOCTLVendorGetCommand() - Send a vendor defined GET command
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbIOCTLVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
        // Local Variables
    NTSTATUS                    ntStatus;
    PIO_STACK_LOCATION  currentIrpStack;
        ULONG                           bytesRead = 0;

        // Set up a local pointer to the Irp stack
    currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

        // Get the port status
        ntStatus = HPUsbVendorGetCommand(DeviceObject,
                                         (PUCHAR) Irp->AssociatedIrp.SystemBuffer,
                                                                     currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                                                     &bytesRead);

        // Set the Irp information values
        Irp->IoStatus.Status            = ntStatus;
        Irp->IoStatus.Information       = bytesRead;

        // Return
        return ntStatus;
}



/*-------------------------------------------------------------------------------
 * HPUsbVendorSetCommand() - Send a vendor specified SET command
 *
 * Inputs:
 *     buffer[0] - Vendor Request Code (bRequest function code)
 *     buffer[1] - Vendor Request Value Most Significant Byte (wValue MSB)
 *     buffer[2] - Vendor Request Value Least Significant Byte (wValue LSB)
 *     buffer[3...] - Any data to be sent as part of the command
 *
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbVendorSetCommand(IN PDEVICE_OBJECT DeviceObject,
                               IN PUCHAR buffer,
                               IN ULONG  length)
{
        // Local variables
    NTSTATUS                                    ntStatus;
        PDEVICE_EXTENSION               deviceExtension;
        PUSBD_INTERFACE_INFORMATION interface;
    PURB                                                urb;
        ULONG                                           size;
        UCHAR                       bRequest;
        USHORT                      wValue;
        USHORT                                          wIndex;

    if ( buffer == NULL || length < 3 )
        return STATUS_INVALID_PARAMETER;

        // Set up a local pointer to the device extension
        deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // Set up a local pointer to the interface
        interface = deviceExtension->Interface;

        // Determine the size of the URB
        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // Allocate memory for the USB Request Block (URB)
//    urb = (PURB)
//          ExAllocatePoolWithTag(NonPagedPool,size,HPUSB_ALLOC_TAG);
    urb = ExAllocatePoolWithTag(NonPagedPool,size, USBP_TAG);
        // Check for an error
        if (urb == NULL)
                return STATUS_NO_MEMORY;

        // Store the vendor request code
        bRequest = buffer[0];

        // Store the vendor request parameter
        wValue = (buffer[1] << 8) | buffer[2];

        // Create the wIndex value (Interface:Alternate)
        wIndex = (interface->InterfaceNumber << 8) |
                         (interface->AlternateSetting);

    // Use a macro in the standard USB header files to build the URB
        UsbBuildVendorRequest(urb,
                                                  URB_FUNCTION_VENDOR_INTERFACE,
                          (USHORT) size,
                          0,
                          0,
                          bRequest,
                                                  wValue,
                                                  wIndex,
                          buffer,
                          NULL,
                          length,
                          NULL);

    //
    // Timeout cancellation should happen from user mode
    //
    ntStatus = USBPRINT_CallUSBD(DeviceObject,urb, NULL);

        // Free allocated memory
    ExFreePool(urb);

        // Return Success
        return ntStatus;
}

/*-------------------------------------------------------------------------------
 * HPUsbVendorGetCommand() - Send a vendor specified GET command
 *
 * Inputs:
 *     buffer[0] - Vendor Request Code (bRequest function code)
 *     buffer[1] - Vendor Request Value Most Significant Byte (wValue MSB)
 *     buffer[2] - Vendor Request Value Least Significant Byte (wValue LSB)
 * Outputs:
 *     buffer[ ] - Response data
 *
 *-------------------------------------------------------------------------------
 */
NTSTATUS HPUsbVendorGetCommand(IN PDEVICE_OBJECT DeviceObject,
                               IN PUCHAR buffer,
                               IN ULONG  length,
                               OUT PULONG pBytesRead)
{
        // Local variables
    NTSTATUS                                    ntStatus;
        PDEVICE_EXTENSION               deviceExtension;
        PUSBD_INTERFACE_INFORMATION interface;
    PURB                                                urb;
        ULONG                                           size;
        UCHAR                       bRequest;
        USHORT                      wValue;
        USHORT                                          wIndex;

    if ( buffer == NULL || length < 3 )
        return STATUS_INVALID_PARAMETER;

        // Initialize the pBytesRead return value
        *pBytesRead = 0;

        // Set up a local pointer to the device extension
        deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

        // Set up a local pointer to the interface
        interface = deviceExtension->Interface;

        // Determine the size of the URB
        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // Allocate memory for the USB Request Block (URB)
  //  urb = (PURB)
    //      ExAllocatePoolWithTag(NonPagedPool,size,HPUSB_ALLOC_TAG);
    urb = ExAllocatePoolWithTag(NonPagedPool,size, USBP_TAG);

        // Check for an error
        if (urb == NULL)
                return STATUS_NO_MEMORY;

        // Store the vendor request code
        bRequest = buffer[0];

        // Store the vendor request parameter
        wValue = (buffer[1] << 8) | buffer[2];

        // Create the wIndex value (Interface:Alternate)
        wIndex = (interface->InterfaceNumber << 8) |
                         (interface->AlternateSetting);

    // Use a macro in the standard USB header files to build the URB
        UsbBuildVendorRequest(urb,
                                                  URB_FUNCTION_VENDOR_INTERFACE,
                          (USHORT) size,
                          USBD_TRANSFER_DIRECTION_IN |
                          USBD_SHORT_TRANSFER_OK,
                          0,
                          bRequest,
                                                  wValue,
                                                  wIndex,
                          buffer,
                          NULL,
                          length,
                          NULL);

    //
    // Timeout cancellation should happen from user mode
    //
    ntStatus = USBPRINT_CallUSBD(DeviceObject,urb, NULL);

        // Retrieve the number of bytes read
        if (NT_SUCCESS(ntStatus))
                *pBytesRead = urb->UrbControlVendorClassRequest.TransferBufferLength;

        // Free allocated memory
    ExFreePool(urb);

        // Return Success
        return ntStatus;
}

/*
// -----------------------------------------------------------
// Kernel Mode Usage
// -----------------------------------------------------------

        // Create the channel change request
        Buffer[0] = HP_VENDOR_COMMAND_DO_SOMETHING;
        Buffer[1] = HP_PARAMETER_UPPER_BYTE;
        Buffer[2] = HP_PARAMETER_LOWER_BYTE;

    // Send the request
    status = CallDeviceIoControl(
                m_pTargetDeviceObject,                  // the device to send the new irp to
                IOCTL_HPUSB_VENDOR_GET_COMMAND, // the ioctl to send to the driver              ,
                Buffer,                                 // the input buffer for the ioctl
                3,                                              // the length of the input buffer
                Buffer,                         // the output buffer for the ioctl
                1,                                      // the length of the output buffer
                FALSE,                                  // create the irp with IRP_MJ_DEVICE_CONTROL
                NULL);                                  // use the provided completion routine


  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\usbprint.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBPRINT.h

Abstract:


							
Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/


#ifdef DRIVER


extern int iGMessageLevel;
#define BOOL CHAR
#define TRUE 1
#define FALSE 0
#define MAX_ID_SIZE 1024
#define ID_OVERHEAD 15 //this is enough for the 'USBPRINT' at the beginning of the ID, and the crc at the end
#define MAX_NUM_PRINTERS 512


#define USBP_TAG            0x50425355      /* "USBP" */

#define FAILURE_TIMEOUT     -10000 * 5000  // 5 seconds

#define USBPRINT_NAME_MAX  64
#define USB_BASE_NAME L"USB"

#define DEVICE_CAPABILITY_VERSION       1
//
// we support up to 10 pipe handles
//
#define USBPRINT_MAX_PIPES 10

//
// defines used for ISO test
//

#define USBPRINT_MAX_IRP  2
#define USBPRINT_NUM_ISO_PACKETS_PER_REQUEST  32
#define USBPRINT_MAX_STREAM_PACKET 8
#define PORT_NUM_VALUE_NAME L"Port Number"
#define PORT_BASE_NAME L"Base Name"

#define USBPRINT_STREAM_TIMEOUT_INTERVAL  100


// {28D78FAD-5A12-11d1-AE5B-0000F803A8C2}
static const GUID USBPRINT_GUID = 
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };



/*typedef struct _USBPRINT_PIPE {        we don't use this struct anymore.  Just use PUSBD_PIPE_INFORMATION directly
    BOOLEAN Opened;
    UCHAR Pad[3];
    PUSBD_PIPE_INFORMATION PipeInfo;
    WCHAR Name[USBPRINT_NAME_MAX];
	LARGE_INTEGER BytesXfered;
	LARGE_INTEGER ElapsedTime;
	LARGE_INTEGER TimerStart;
	LARGE_INTEGER ElapsedCycles;
	LARGE_INTEGER CyclesStart;
	BOOLEAN           bPerfTimerEnabled; //yy Bunch of perf fields here.  remove them 
} USBPRINT_PIPE, *PUSBPRINT_PIPE; */

typedef struct _USBPRINT_RW_CONTEXT {
    PURB Urb;
    BOOLEAN IsWrite;
    PDEVICE_OBJECT DeviceObject;
} USBPRINT_RW_CONTEXT, *PUSBPRINT_RW_CONTEXT;


#define MAX_INTERFACE 2

// 999 is limit of USBMON's scope due to USB_XXX port name format.
#define MAX_PORT_NUMBER 999
// USB_001 is the lowest port number available.
#define MIN_PORT_NUMBER 1

//
//  Structure representing blocks of unallocated ports.
//
typedef struct _FREE_PORTS
{
	ULONG iBottomOfRange;				// The bottom free port number in this block.
	ULONG iTopOfRange;					// The top free port number in this block.
	struct _FREE_PORTS * pNextBlock;	// Pointer to the next block pf free ports.
} FREE_PORTS, *PFREE_PORTS;

typedef struct _DEVICE_EXTENSION {

	BOOLEAN IsChildDevice;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    PDEVICE_OBJECT PhysicalDeviceObject;

	PDEVICE_OBJECT ChildDevice;
    BOOL bChildDeviceHere;
    UCHAR DeviceIdString[MAX_ID_SIZE];
    BOOLEAN bBadDeviceID;

    KSPIN_LOCK WakeSpinLock;
	BOOLEAN bD0IrpPending;
    DEVICE_POWER_STATE CurrentDevicePowerState;


    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION Interface;

    DEVICE_CAPABILITIES DeviceCapabilities;
    BOOLEAN bReadSupported;

    PIRP PowerIrp;
    KEVENT RemoveEvent;
    ULONG PendingIoCount;

    // Name buffer for our named Functional device object link
    WCHAR DeviceLinkNameBuffer[USBPRINT_NAME_MAX];

    BOOLEAN AcceptingRequests;

    UCHAR Pad[3];

    PUSBD_PIPE_INFORMATION pWritePipe;
	PUSBD_PIPE_INFORMATION pReadPipe;
	BOOL bReadPipeExists;
	UNICODE_STRING DeviceLinkName;
    ULONG ulInstanceNumber;
    ULONG OpenCnt;
	
	HANDLE hInterfaceKey;
    
    LONG ResetWorkItemPending;

	// selective suspend support
    PIRP                    		PendingIdleIrp;
    PUSB_IDLE_CALLBACK_INFO 		IdleCallbackInfo;
    DEVICE_POWER_STATE              DeviceWake;



} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _CHILD_DEVICE_EXTENSION 
{
	BOOLEAN IsChildDevice;

	PDEVICE_OBJECT ParentDeviceObject;
	ULONG ulInstanceNumber;

} CHILD_DEVICE_EXTENSION, *PCHILD_DEVICE_EXTENSION;


typedef struct _USBPRINT_TRANSFER_OBJECT {
    struct _USBPRINT_STREAM_OBJECT *StreamObject;
    PIRP Irp;
    PURB Urb;
    PUCHAR DataBuffer;
} USBPRINT_TRANSFER_OBJECT, *PUSBPRINT_TRANSFER_OBJECT;

typedef struct _USBPRINT_STREAM_OBJECT {
    PDEVICE_OBJECT DeviceObject;
    ULONG PendingIrps;
    PIRP StopIrp;
    PUSBPRINT_TRANSFER_OBJECT TransferObjectList[USBPRINT_MAX_IRP];
    PUSBD_PIPE_INFORMATION PipeInfo;
    KDPC TimeoutDpc;
    KTIMER  TimeoutTimer;

    BOOLEAN EnableTimeoutDPC;
    BOOLEAN StreamError;
} USBPRINT_STREAM_OBJECT, *PUSBPRINT_STREAM_OBJECT;


typedef struct _USBPRINT_WORKITEM_CONTEXT
{
    PIO_WORKITEM ioWorkItem;
    PDEVICE_OBJECT deviceObject;
     PUSBD_PIPE_INFORMATION pPipeInfo;
    PIRP irp;

} USBPRINT_WORKITEM_CONTEXT,*PUSBPRINT_WORKITEM_CONTEXT;


#if DBG

#define USBPRINT_KdPrint_old(_x_) \
{\
DbgPrint _x_ ;\
DbgPrint("Old USBPRINT\n");\
}

#define USBPRINT_KdPrint0(_x_) \
{ \
  if(iGMessageLevel>=0) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint1(_x_) \
{ \
  if(iGMessageLevel>=1) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint2(_x_) \
{ \
  if(iGMessageLevel>=2) \
    DbgPrint _x_; \
}

#define USBPRINT_KdPrint3(_x_) \
{ \
  if(iGMessageLevel>=3) \
    DbgPrint _x_; \
}





#ifdef NTKERN
#define TRAP() _asm {int 3}
#else
#define TRAP() DbgBreakPoint()
#endif

#else

#define USBPRINT_KdPrint_old(_x_)
#define USBPRINT_KdPrint0(_x_)
#define USBPRINT_KdPrint1(_x_)
#define USBPRINT_KdPrint2(_x_)
#define USBPRINT_KdPrint3(_x_)
#define USBPRINT_KdPrint4(_x_)

#define TRAP()

#endif

NTSTATUS
USBPRINT_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
USBPRINT_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
USBPRINT_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_CallUSBD(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout
    );

NTSTATUS
USBPRINT_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
USBPRINT_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
USBPRINT_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_SelectInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

PUSB_CONFIGURATION_DESCRIPTOR
USBPRINT_GetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_BuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBPRINT_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    );

NTSTATUS
USBPRINT_StopIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBPRINT_STREAM_OBJECT StreamObject,
    IN PIRP Irp
    );    

NTSTATUS
USBPRINT_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo,
    IN PIRP Irp
    );    

NTSTATUS
USBPRINT_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
	IN PVOID Context
    );   

VOID
USBPRINT_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
USBPRINT_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );   

NTSTATUS
USBPRINT_ReconfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBPRINT_ProcessPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );    

int
USBPRINT_Get1284Id(
    IN PDEVICE_OBJECT   DeviceObject,
	PVOID pIoBuffer,int iLen
	);


NTSTATUS USBPRINT_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context);
NTSTATUS USBPRINT_AbortPendingRequests(PDEVICE_OBJECT DeviceObject);
NTSTATUS USBPRINT_GetPhysicalUSBPortStatus(PDEVICE_OBJECT DeviceObject,ULONG *PortStatus);



VOID
USBPRINT_FdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt);

NTSTATUS
USBPRINT_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    );

NTSTATUS
USBPRINT_FdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt);

VOID
USBPRINT_FdoRequestWake(IN PDEVICE_EXTENSION DevExt);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\ocrw.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   ocrw.c

Abstract:

   read/write io code for printing

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"
#include "usbprint.h"



//******************************************************************************
//
// USBPRINT_CompletionStop()
//
// IO Completion Routine which just stops further completion of the Irp
//
//******************************************************************************

NTSTATUS
USBPRINT_CompletionStop (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// USBPRINT_GetCurrentFrame()
//
//******************************************************************************

ULONG
USBPRINT_GetCurrentFrame (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          nextStack;
    NTSTATUS                    ntStatus;
    struct _URB_GET_CURRENT_FRAME_NUMBER urb;

    deviceExtension   = DeviceObject->DeviceExtension;

    // Initialize the URB
    //
    urb.Hdr.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
    urb.Hdr.Length   = sizeof(urb);
    urb.FrameNumber = (ULONG)-1;

    // Set the IRP parameters to pass the URB down the stack
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->Parameters.Others.Argument1 = &urb;

    nextStack->Parameters.DeviceIoControl.IoControlCode = 
	IOCTL_INTERNAL_USB_SUBMIT_URB;                    

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    // Since this Irp is borrowed for URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
    // before it is passed down later for the real URB request after this
    // routine returns, set a completion routine which stop further completion
    // of the Irp.
    //
    IoSetCompletionRoutine(
	Irp,
	USBPRINT_CompletionStop,
	NULL,   // Context
	TRUE,   // InvokeOnSuccess
	TRUE,   // InvokeOnError
	TRUE    // InvokeOnCancel
	);

    // Now pass the Irp down the stack
    //
    ntStatus = IoCallDriver(
		   deviceExtension->TopOfStackDeviceObject, 
		   Irp
		   );

    // Don't need to wait for completion because JD guarantees that
    // URB_FUNCTION_GET_CURRENT_FRAME_NUMBER will never return STATUS_PENDING

    return urb.FrameNumber;
}



PURB
USBPRINT_BuildAsyncRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_PIPE_INFORMATION PipeHandle,
    IN BOOLEAN Read
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device extension for this instance of the
		     printer

    Irp -

    PipeHandle -

Return Value:

    initialized async urb.

--*/
{
    ULONG siz;
    ULONG length;
    PURB urb = NULL;

    USBPRINT_KdPrint3 (("USBPRINT.SYS: handle = 0x%x\n", PipeHandle));

    if ( Irp->MdlAddress == NULL )
        return NULL;

    length = MmGetMdlByteCount(Irp->MdlAddress);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: length = 0x%x\n", length));

    siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb = ExAllocatePoolWithTag(NonPagedPool, siz, USBP_TAG);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: siz = 0x%x urb 0x%x\n", siz, urb));

    if (urb) {
	RtlZeroMemory(urb, siz);

	urb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) siz;
	urb->UrbBulkOrInterruptTransfer.Hdr.Function =
		    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.PipeHandle =
		   PipeHandle->PipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferFlags =
	    Read ? USBD_TRANSFER_DIRECTION_IN : 0;

	// short packet is not treated as an error.
	urb->UrbBulkOrInterruptTransfer.TransferFlags |= 
	    USBD_SHORT_TRANSFER_OK;            
		
	//
	// no linkage for now
	//

	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL =
	    Irp->MdlAddress;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
	    length;

	USBPRINT_KdPrint3 (("USBPRINT.SYS: Init async urb Length = 0x%x buf = 0x%x, mdlBuff=0x%x\n",
	    urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
	    urb->UrbBulkOrInterruptTransfer.TransferBuffer,
        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL));
    }

    USBPRINT_KdPrint3 (("USBPRINT.SYS: exit USBPRINT_BuildAsyncRequest\n"));

    return urb;
}



NTSTATUS
USBPRINT_AsyncReadWrite_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the USBPRINT device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PURB                                urb;
    PUSBPRINT_RW_CONTEXT  context = Context;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION           deviceExtension;
    PUSBPRINT_WORKITEM_CONTEXT pResetWorkItemObj;
    LONG ResetPending;
    
    //Always mark irp pending in dispatch routine now
//    if (Irp->PendingReturned) {
//	IoMarkIrpPending(Irp);
//    }

    urb = context->Urb;
    deviceObject = context->DeviceObject;
    deviceExtension=deviceObject->DeviceExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  Async Completion: Length %d, Status 0x%08X\n",
		     urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
		     urb->UrbHeader.Status));


    //ASSERT(urb->UrbHeader.Status==0);

    ntStatus=urb->UrbHeader.Status;

    //
    // set the length based on the TransferBufferLength
    // value in the URB
    //
    Irp->IoStatus.Information =
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength;


    if((!NT_SUCCESS(ntStatus))&&(ntStatus!=STATUS_CANCELLED)&&(ntStatus!=STATUS_DEVICE_NOT_CONNECTED)&&(ntStatus!=STATUS_DELETE_PENDING))
    { //We've got an error, and it's not "not connected" or "cancelled", we need to reset the connection
        ResetPending=InterlockedCompareExchange(&deviceExtension->ResetWorkItemPending, 
                                             1,
                                             0);       //Check to see if ResetWorkItem is 0, if so, set it to 1, and start a Reset
        if(!ResetPending)
        {
            pResetWorkItemObj=ExAllocatePoolWithTag(NonPagedPool,sizeof(USBPRINT_WORKITEM_CONTEXT),USBP_TAG);
            if(pResetWorkItemObj)
            {
                pResetWorkItemObj->ioWorkItem=IoAllocateWorkItem(DeviceObject);
                if(pResetWorkItemObj==NULL)
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: Unable to allocate IoAllocateWorkItem in ReadWrite_Complete\n"));
                    ExFreePool(pResetWorkItemObj);
                    pResetWorkItemObj=NULL;
                }
            } //if ALloc RestWorkItem OK
            else
            {
               USBPRINT_KdPrint1 (("USBPRINT.SYS: Unable to allocate WorkItemObj in ReadWrite_Complete\n"));
            }
            if(pResetWorkItemObj)
            {
               pResetWorkItemObj->irp=Irp;
               pResetWorkItemObj->deviceObject=DeviceObject;
               if(context->IsWrite)
                   pResetWorkItemObj->pPipeInfo=deviceExtension->pWritePipe;
               else
                   pResetWorkItemObj->pPipeInfo=deviceExtension->pReadPipe;

               USBPRINT_IncrementIoCount(deviceObject);
               IoQueueWorkItem(pResetWorkItemObj->ioWorkItem,
                               USBPRINT_ResetWorkItem,
                               DelayedWorkQueue,
                               pResetWorkItemObj);
               ntStatus=STATUS_MORE_PROCESSING_REQUIRED; 
               //Leave the IRP pending until the reset is complete.  This way we won't get flooded with irp's we're not
               //prepaired to deal with.  The Reset WorkItem completes the IRP when it's done.
            } //end if the allocs went OK
        }   //end if ! Reset Pending
    }   //end if we need to reset
    
    USBPRINT_DecrementIoCount(deviceObject); //still +1 on the IO count after this, leaving one for the workitem to decrement                       
    
    ExFreePool(context);
    ExFreePool(urb);        

    return ntStatus;
}


NTSTATUS USBPRINT_ResetWorkItem(IN PDEVICE_OBJECT deviceObject, IN PVOID Context)
{   

    PUSBPRINT_WORKITEM_CONTEXT pResetWorkItemObj;
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS ntStatus;
    ULONG portStatus;
    PDEVICE_OBJECT devObj;


    USBPRINT_KdPrint2(("USBPRINT.SYS: Entering USBPRINT_ResetWorkItem\n"));
    pResetWorkItemObj=(PUSBPRINT_WORKITEM_CONTEXT)Context;
    DeviceExtension=pResetWorkItemObj->deviceObject->DeviceExtension;
    ntStatus=USBPRINT_ResetPipe(pResetWorkItemObj->deviceObject,pResetWorkItemObj->pPipeInfo,FALSE);
    IoCompleteRequest(pResetWorkItemObj->irp,IO_NO_INCREMENT);
    IoFreeWorkItem(pResetWorkItemObj->ioWorkItem);

    // save off work item device object before freeing work item
    devObj = pResetWorkItemObj->deviceObject;
    
    ExFreePool(pResetWorkItemObj);
    InterlockedExchange(&(DeviceExtension->ResetWorkItemPending),0);
    USBPRINT_DecrementIoCount(devObj);
    return ntStatus;
}


NTSTATUS
USBPRINT_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this instance of a printer.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PUSBPRINT_RW_CONTEXT context = NULL;

    USBPRINT_KdPrint3 (("USBPRINT.SYS: /*dd enter USBPRINT_Read\n\n\n\n\n\n"));
    USBPRINT_KdPrint3 (("USBPRINT.SYS: /*dd **************************************************************************\n"));

    USBPRINT_IncrementIoCount(DeviceObject);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->AcceptingRequests == FALSE) {
	ntStatus = STATUS_DELETE_PENDING;
	Irp->IoStatus.Status = ntStatus;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest (Irp,
			   IO_NO_INCREMENT
			  );

	USBPRINT_DecrementIoCount(DeviceObject);                          
	return ntStatus;
    }
    
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;

    pipeHandle =  deviceExtension->pReadPipe;

    if (!pipeHandle) {
       ntStatus = STATUS_INVALID_HANDLE;
       goto USBPRINT_Read_Reject;
    }

    //
    // submit the Read request to USB
    //

    switch (pipeHandle->PipeType) {
    case UsbdPipeTypeInterrupt:
    case UsbdPipeTypeBulk:
	urb = USBPRINT_BuildAsyncRequest(DeviceObject,
				       Irp,
				       pipeHandle,
				       TRUE);
	if (urb) {
	    context = ExAllocatePoolWithTag(NonPagedPool, sizeof(USBPRINT_RW_CONTEXT), USBP_TAG);

        if ( !context )
           ExFreePool(urb);
	}
	
	if (urb && context) {
	    context->Urb = urb;
	    context->DeviceObject = DeviceObject;
        context->IsWrite=FALSE;
	    
	    nextStack = IoGetNextIrpStackLocation(Irp);
	    ASSERT(nextStack != NULL);
	    ASSERT(DeviceObject->StackSize>1);

	    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	    nextStack->Parameters.Others.Argument1 = urb;
	    nextStack->Parameters.DeviceIoControl.IoControlCode =
		IOCTL_INTERNAL_USB_SUBMIT_URB;

	    IoSetCompletionRoutine(Irp,
				   USBPRINT_AsyncReadWrite_Complete,
				   context,
				   TRUE,
				   TRUE,
				   TRUE);

	    USBPRINT_KdPrint3 (("USBPRINT.SYS: IRP = 0x%x current = 0x%x next = 0x%x\n",
		Irp, irpStack, nextStack));

			// start perf timer here if needed
		
        IoMarkIrpPending(Irp);
	    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
				    Irp);
        ntStatus=STATUS_PENDING;
	    goto USBPRINT_Read_Done;
	} 
    else 
    {
	    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
	}

	break;
    default:
	ntStatus = STATUS_INVALID_PARAMETER;
	TRAP();
    }

USBPRINT_Read_Reject:

    USBPRINT_DecrementIoCount(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest (Irp,
		       IO_NO_INCREMENT
		       );

USBPRINT_Read_Done:

    return ntStatus;
}


NTSTATUS
USBPRINT_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function services WRITE requests for this device (probably from the user mode USB port monitor) 

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

  --*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    PURB urb;
    PUSBPRINT_RW_CONTEXT context = NULL;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_Write (foo)\n"));
    
    USBPRINT_IncrementIoCount(DeviceObject);
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    if (deviceExtension->AcceptingRequests == FALSE) 
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failure because AcceptingRequests=FALSE\n"));
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        
        USBPRINT_DecrementIoCount(DeviceObject);
        
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        return ntStatus;
    }
    
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    

    fileObject = irpStack->FileObject;
    
    //    MmProbeAndLockPages(Irp->MdlAddress,
    //                        KernelMode,
    //                        IoReadAccess);
    
    pipeHandle =  deviceExtension->pWritePipe;
    if (!pipeHandle)
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failure because pipe is bad\n"));
        ntStatus = STATUS_INVALID_HANDLE;
        goto USBPRINT_Write_Reject;
    }
    
    //
    // submit the write request to USB
    //
    
    switch (pipeHandle->PipeType) 
    {
    case UsbdPipeTypeInterrupt:
    case UsbdPipeTypeBulk:
        urb = USBPRINT_BuildAsyncRequest(DeviceObject,
            Irp,
            pipeHandle,
            FALSE);
        
        if (urb) 
        {
            context = ExAllocatePoolWithTag(NonPagedPool, sizeof(USBPRINT_RW_CONTEXT), USBP_TAG);

            if(!context)
               ExFreePool(urb);
        
        }

        if (urb && context) 
        {
            context->Urb = urb;
            context->DeviceObject = DeviceObject;                                       
            context->IsWrite=TRUE;
            
            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            ASSERT(DeviceObject->StackSize>1);
            
            nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            nextStack->Parameters.Others.Argument1 = urb;
            nextStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_INTERNAL_USB_SUBMIT_URB;
            
            IoSetCompletionRoutine(Irp,
                USBPRINT_AsyncReadWrite_Complete,
                context,
                TRUE,
                TRUE,
                TRUE);
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: IRP = 0x%x current = 0x%x next = 0x%x\n",Irp, irpStack, nextStack));
            
            IoMarkIrpPending(Irp);
            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,Irp);
            ntStatus=STATUS_PENDING;
            goto USBPRINT_Write_Done;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
        TRAP();
    }
    
USBPRINT_Write_Reject:
    
    USBPRINT_DecrementIoCount(DeviceObject);
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoCompleteRequest (Irp,
        IO_NO_INCREMENT
        );
    
USBPRINT_Write_Done:
    USBPRINT_KdPrint3 (("USBPRINT.SYS: Write Done, status= 0x%08X\n",ntStatus));
    return ntStatus;
}


NTSTATUS
USBPRINT_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    PUSBD_PIPE_INFORMATION pipeHandle = NULL;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering USBPRINT_Close\n"));
    
    USBPRINT_IncrementIoCount(DeviceObject);
    
    deviceExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;
    
    if (fileObject->FsContext) 
    {
        // closing pipe handle
        pipeHandle =  fileObject->FsContext;
        USBPRINT_KdPrint3 (("USBPRINT.SYS: closing pipe %x\n", pipeHandle));
        
    }
   deviceExtension->OpenCnt--;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    
    
    ntStatus = Irp->IoStatus.Status;
    
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    
    USBPRINT_DecrementIoCount(DeviceObject);

    if(!deviceExtension->IsChildDevice)
    {
        USBPRINT_FdoSubmitIdleRequestIrp(deviceExtension);
    }
    
    return ntStatus;
}


NTSTATUS
USBPRINT_Create(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
/*++

Routine Description:

    //
    // Entry point for CreateFile calls
    // user mode apps may open "\\.\USBPRINT-x\"
    // where x is the "USB virtual printer port"  
	//
    // No more exposing the pipe # to usermode

Arguments:

    DeviceObject - pointer to the device object for this printer.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering USBPRINT_Create\n"));
    USBPRINT_IncrementIoCount(DeviceObject);
    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->IsChildDevice==TRUE) {
        ntStatus = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        USBPRINT_DecrementIoCount(DeviceObject);
        return ntStatus;
    }


    if (deviceExtension->AcceptingRequests == FALSE) {
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
        USBPRINT_DecrementIoCount(DeviceObject);                          
        return ntStatus;
    }

    USBPRINT_FdoRequestWake(deviceExtension);

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;
    // fscontext is null for device
    fileObject->FsContext = NULL;
    deviceExtension->OpenCnt++;
    ntStatus = STATUS_SUCCESS;
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp,IO_NO_INCREMENT);
    USBPRINT_DecrementIoCount(DeviceObject);                               
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_Create %x\n", ntStatus));
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\kernelmode\usbprint\usbprint.c ===
/*++                                                   

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    USBPRINT.c

Abstract:

    Device driver for USB printers

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER
//Windows includes
#include "wdm.h"
#include "ntddpar.h"
#include "initguid.h"
#include "wdmguid.h"



NTSTATUS
USBPRINT_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPRINT_SystemControl)
#endif


#include "stdarg.h"
#include "stdio.h"

//USB includes
#include <usb.h>
#include <usbdrivr.h>
#include "usbdlib.h"

//My includes
#include "usbprint.h"
#include "deviceid.h"

//
// Global pointer to Driver Object
//

PDRIVER_OBJECT USBPRINT_DriverObject;

int iGMessageLevel;
PFREE_PORTS pGPortList;
HANDLE GLogHandle;



NTSTATUS QueryDeviceRelations(PDEVICE_OBJECT DeviceObject,PIRP Irp,DEVICE_RELATION_TYPE,BOOL *pbComplete);
NTSTATUS GetPortNumber(HANDLE hInterfaceKey,ULONG *ulPortNumber);
NTSTATUS ProduceQueriedID(PDEVICE_EXTENSION deviceExtension,PIO_STACK_LOCATION irpStack,PIRP Irp,PDEVICE_OBJECT DeviceObject);
int iGetMessageLevel();
NTSTATUS USBPRINT_ProcessChildPowerIrp(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS USBPRINT_ProcessFdoPowerIrp(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);

NTSTATUS InitFreePorts( PFREE_PORTS * pHead );
NTSTATUS bAddPortInUseItem(PFREE_PORTS * pFreePorts,ULONG iPortNumber );
NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName);
void ClearFreePorts(PFREE_PORTS * pHead);
NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName);
void vClaimPortNumber(ULONG ulPortNumber,HANDLE hInterfaceKey,PFREE_PORTS * pPortsUsed);
NTSTATUS GetNewPortNumber(PFREE_PORTS * pFreePorts, ULONG *pulPortNumber);
BOOL bDeleteIfRecyclable(HANDLE hInterfaceKey);
NTSTATUS SetValueToZero(HANDLE hRegKey,PUNICODE_STRING ValueName);
USBPRINT_GetDeviceID(PDEVICE_OBJECT ParentDeviceObject);
void WritePortDescription(PDEVICE_EXTENSION deviceExtension);
void vOpenLogFile(IN HANDLE *pHandle);
void vWriteToLogFile(IN HANDLE *pHandle,IN CHAR *pszString);
void vCloseLogFile(IN HANDLE *pHandle);


NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );




NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
           to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    

    



    USBPRINT_DriverObject = DriverObject;

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = USBPRINT_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = USBPRINT_Close;
    DriverObject->DriverUnload = USBPRINT_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = USBPRINT_ProcessIOCTL;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = USBPRINT_Write;
    DriverObject->MajorFunction[IRP_MJ_READ] = USBPRINT_Read;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = USBPRINT_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = USBPRINT_Dispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = USBPRINT_ProcessPowerIrp;
    DriverObject->DriverExtension->AddDevice = USBPRINT_PnPAddDevice;

    iGMessageLevel=iGetMessageLevel();
    USBPRINT_KdPrint2 (("USBPRINT.SYS: entering (USBPRINT) DriverEntry\n")); 
    USBPRINT_KdPrint2 (("USBPRINT.SYS: MessageLevel=%d\n",iGMessageLevel));
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: About to load ports\n"));
    pGPortList = NULL;
    ntStatus=InitFreePorts(&pGPortList);
    if(NT_SUCCESS(ntStatus) && pGPortList!=NULL)
    {
        ntStatus=LoadPortsUsed((GUID *)&USBPRINT_GUID,&pGPortList,USB_BASE_NAME);
        if(!NT_SUCCESS(ntStatus))
        {
          USBPRINT_KdPrint1 (("USBPRINT.SYS: DriverInit: Unable to load used ports; error=%u\n", ntStatus));
        }
    }
    else
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: exiting (USBPRINT) DriverEntry (%x)\n", ntStatus));
        if(NT_SUCCESS(ntStatus))
        {
            ntStatus=STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    
    



    USBPRINT_KdPrint2 (("USBPRINT.SYS: exiting (USBPRINT) DriverEntry (%x)\n", ntStatus));

    if ( !NT_SUCCESS(ntStatus))
        ClearFreePorts(&pGPortList);

    return ntStatus;
}

/*********************************************
 * Message Levels:
 * 0 == None, except critical, about to crash the machine failures
 * 1 == Error messages only
 * 2 == Informative messages
 * 3 == Verbose informative messages
 ******************************************************/
int iGetMessageLevel()
{
  OBJECT_ATTRIBUTES rObjectAttribs;
  HANDLE hRegHandle;
  UNICODE_STRING KeyName;
  UNICODE_STRING ValueName;
  ULONG ulSizeUsed;
  PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;
  NTSTATUS ntStatus;
  int iReturn;

 

  
  RtlInitUnicodeString(&KeyName,L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\USBPRINT");
  RtlInitUnicodeString(&ValueName,L"DriverMessageLevel");
  InitializeObjectAttributes(&rObjectAttribs,&KeyName,OBJ_CASE_INSENSITIVE,NULL,NULL);
  ntStatus=ZwOpenKey(&hRegHandle,KEY_QUERY_VALUE,&rObjectAttribs); 
  if(NT_SUCCESS(ntStatus))
  {
    ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
    pValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulSizeUsed, USBP_TAG); 
    if(pValueStruct==NULL)
    {
      USBPRINT_KdPrint0(("'USBPRINT.SYS: iGetMessageLevel; Unable to allocate memory\n"));
      ZwClose(hRegHandle);
      return 1;
    }
    ntStatus=ZwQueryValueKey(hRegHandle,&ValueName,KeyValuePartialInformation,pValueStruct,ulSizeUsed,&ulSizeUsed);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint3(("Failed to Query value Key\n"));
      iReturn=1;
    }
    else
    {
      iReturn=(int)*((ULONG *)(pValueStruct->Data));
    }
    ExFreePool(pValueStruct);
    ZwClose(hRegHandle);
  }
  else
  {
     iReturn=1;
  }
  return iReturn;
} /*end iGetMessageLevel*/


NTSTATUS
USBPRINT_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject = Context;
    NTSTATUS ntStatus;

    deviceExtension = deviceObject->DeviceExtension;
    irp = deviceExtension->PowerIrp;
    
    USBPRINT_KdPrint2(("USBPRINT_PoRequestCompletion\n"));
    
    PoStartNextPowerIrp(irp);
    IoCopyCurrentIrpStackLocationToNext(irp);      
    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
         irp);   

    USBPRINT_DecrementIoCount(deviceObject);                 

    return ntStatus;
}


NTSTATUS
USBPRINT_PowerIrp_Complete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;

    USBPRINT_KdPrint2(("USBPRINT.SYS:   enter USBPRINT_PowerIrp_Complete\n"));

    deviceObject = (PDEVICE_OBJECT) Context;

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;


    if (Irp->PendingReturned) {
    IoMarkIrpPending(Irp);
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    deviceExtension->CurrentDevicePowerState = PowerDeviceD0;
    deviceExtension->bD0IrpPending=FALSE;

    
    
 //   if (deviceExtension->Interface) 
 //     ExFreePool(deviceExtension->Interface);
 //   ntStatus=USBPRINT_ConfigureDevice(deviceObject);
 //   ntStatus = USBPRINT_BuildPipeList(deviceObject);
 //   if(!NT_SUCCESS(ntStatus))
 //       USBPRINT_KdPrint1(("USBPRINT.SYS :  Unable to reconfigure device after wakeup.  Error %x\n",ntStatus));

    Irp->IoStatus.Status = ntStatus;

    USBPRINT_DecrementIoCount(deviceObject); 

    return ntStatus;
}


NTSTATUS
USBPRINT_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN HookIt
    )
/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    DeviceState - Device specific power state to set the device in to.

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (DeviceState) {
    case PowerDeviceD3:

    //
    // device will be going OFF, save any state now.
    //

    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD3 (OFF)*******************************/*dd\n"));

    deviceExtension->CurrentDevicePowerState = DeviceState;
    break;

    case PowerDeviceD1:
    case PowerDeviceD2:
    //
    // power states D1,D2 translate to USB suspend

    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD1/D2 (SUSPEND)*******************************/*dd\n"));        

    deviceExtension->CurrentDevicePowerState = DeviceState;
    break;

    case PowerDeviceD0:


    USBPRINT_KdPrint2(("USBPRINT.SYS:  PowerDeviceD0 (ON)*******************************/*dd\n"));

    //
    // finish the rest in the completion routine
    //

    *HookIt = TRUE;

    // pass on to PDO
    break;

    default:
    
    USBPRINT_KdPrint1(("USBPRINT.SYS:  Bogus DeviceState = %x\n", DeviceState));
    }

    return ntStatus;
}


NTSTATUS
USBPRINT_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,1,FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


NTSTATUS
USBPRINT_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
               USBPRINT_DeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    //this is different from the latest version of busdd.doc
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    ntStatus = IoCallDriver(PdoDeviceObject,
                irp);

    USBPRINT_KdPrint3(("USBPRINT.SYS:  ntStatus from IoCallDriver to PCI = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete
       
       
       
       KeWaitForSingleObject(
        &event,
        Suspended,
        KernelMode,
        FALSE,
        NULL);
    }

#if DBG                    
    if (!NT_SUCCESS(ntStatus)) {
    // failed? this is probably a bug
    USBPRINT_KdPrint1(("USBPRINT.SYS:  QueryCapabilities failed, why?\n"));
    }
#endif

    IoFreeIrp(irp);

    return STATUS_SUCCESS;
}




NTSTATUS
USBPRINT_ProcessPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
  PDEVICE_EXTENSION deviceExtension;
  BOOLEAN hookIt = FALSE;
    NTSTATUS ntStatus;

  USBPRINT_KdPrint2(("USBPRINT.SYS:  /*****************************************************************IRP_MJ_POWER\n"));

  deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    if(deviceExtension->IsChildDevice)
        ntStatus=USBPRINT_ProcessChildPowerIrp(DeviceObject,Irp);
  else
        ntStatus=USBPRINT_ProcessFdoPowerIrp(DeviceObject,Irp);
    USBPRINT_KdPrint3(("USBPRINT.SYS:  /*****************************************************************Leaving power IRP_MJ_POWER\n"));
    return ntStatus;    

}  /*end function USBPRINT_ProcessPowerIrp*/


NTSTATUS
USBPRINT_ProcessChildPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
   PIO_STACK_LOCATION irpStack;
   NTSTATUS ntStatus;
   PCHILD_DEVICE_EXTENSION pDeviceExtension;
 

     USBPRINT_KdPrint2(("USBPRINT.SYS: IRP_MJ_POWER for child PDO\n"));

     pDeviceExtension=(PCHILD_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
     irpStack=IoGetCurrentIrpStackLocation(Irp);

     switch(irpStack->MinorFunction)
     {
         case IRP_MN_SET_POWER:
           USBPRINT_KdPrint3(("USBPRINT.SYS: IRP_MJ_POWER, IRP_MN_SET_POWER\n"));
             ntStatus=STATUS_SUCCESS;
         break;


         case IRP_MN_QUERY_POWER:
             USBPRINT_KdPrint3(("USBPRINT.SYS: IRP_MJ_POWER, IRP_MN_QUERY_POWER\n"));
             ntStatus=STATUS_SUCCESS;
         break;

         default:
            ntStatus = Irp->IoStatus.Status;
     } /*end switch irpStack->MinorFunction*/

   PoStartNextPowerIrp(Irp);
   Irp->IoStatus.Status=ntStatus;
     IoCompleteRequest(Irp,IO_NO_INCREMENT);

     return ntStatus;

} /*end function USBPRINT_ProcessChildPowerIrp*/



NTSTATUS
USBPRINT_ProcessFdoPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

    

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    BOOLEAN hookIt = FALSE;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    if(deviceExtension->IsChildDevice)
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS  Is child device inside fdo function.  Error!*/\n"));
    }
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    USBPRINT_IncrementIoCount(DeviceObject);

    switch(irpStack->MinorFunction)
    {
    
    case IRP_MN_SET_POWER:
        {

            switch(irpStack->Parameters.Power.Type)
            {
            case SystemPowerState:
                //
                // find the device power state equivalent to the given system state
                //

                {
                    POWER_STATE powerState;

                    USBPRINT_KdPrint3(("USBPRINT.SYS:  Set Power, SystemPowerState (%d)\n", 
                                       irpStack->Parameters.Power.State.SystemState));                    

                    powerState.DeviceState = deviceExtension->DeviceCapabilities.DeviceState[irpStack->Parameters.Power.State.SystemState];

                    //
                    // are we already in this state?
                    //

                    if(powerState.DeviceState != deviceExtension->CurrentDevicePowerState)
                    {

                        // No,
                        // request that we be put into this state
                        //Don't touch the Irp any more after this.  It could complete at any time
                        deviceExtension->PowerIrp = Irp;
                        IoMarkIrpPending(Irp); 
                        ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                                     IRP_MN_SET_POWER,
                                                     powerState,
                                                     USBPRINT_PoRequestCompletion,
                                                     DeviceObject,
                                                     NULL);
                        hookIt = TRUE;

                    }
                    else
                    {
                        // Yes,
                        // just pass it on
                        PoStartNextPowerIrp(Irp);
                        IoCopyCurrentIrpStackLocationToNext(Irp);
                        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                                                Irp);

                    }

                } 
                break;

            case DevicePowerState:

                ntStatus = USBPRINT_SetDevicePowerState(DeviceObject,
                                                        irpStack->Parameters.Power.State.DeviceState,
                                                        &hookIt);

                PoStartNextPowerIrp(Irp);
                IoCopyCurrentIrpStackLocationToNext(Irp);

                if(hookIt)
                {
                    USBPRINT_KdPrint2(("USBPRINT.SYS:  Set PowerIrp Completion Routine\n"));
                    IoSetCompletionRoutine(Irp,USBPRINT_PowerIrp_Complete,DeviceObject,TRUE,TRUE,TRUE);
                }
                ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,Irp);
                break;
            } /* switch irpStack->Parameters.Power.Type */

        } 
        break; /* IRP_MN_SET_POWER */

    default:

        USBPRINT_KdPrint1(("USBPRINT.SYS:  UNKNOWN POWER MESSAGE (%x)\n", irpStack->MinorFunction));

        //
        // All unahndled PnP messages are passed on to the PDO
        //

        PoStartNextPowerIrp(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                                Irp);

    } /* irpStack->MinorFunction */

    if( !hookIt )
        USBPRINT_DecrementIoCount(DeviceObject);
    return ntStatus;
} /*end function ProcessFdoPowerIrp*/


NTSTATUS
USBPRINT_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
                                         
    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{

    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT stackDeviceObject;
    BOOL bHandled=FALSE;

    //Irp->IoStatus.Status = STATUS_SUCCESS;
    //Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get a pointer to the device extension
    //

    deviceExtension = DeviceObject->DeviceExtension;
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

#ifdef  MYDEBUG
    DbgPrint("USBPRINT_Dispatch entry for pnp event %d\n", irpStack->MinorFunction);
    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
#endif
    
    USBPRINT_IncrementIoCount(DeviceObject);

        switch (irpStack->MinorFunction) 
        {
          case IRP_MN_START_DEVICE:
          {
            if(deviceExtension->IsChildDevice==FALSE)
            {
              KEVENT event;
              USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_START_DEVICE\n"));
              KeInitializeEvent(&event, NotificationEvent, FALSE);
              IoCopyCurrentIrpStackLocationToNext(Irp);  
              IoSetCompletionRoutine(Irp,USBPRINT_DeferIrpCompletion,&event,TRUE,TRUE,TRUE);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
              if (ntStatus == STATUS_PENDING) 
              {
                KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
                ntStatus = Irp->IoStatus.Status;
              }
              if ( NT_SUCCESS(ntStatus) ) {

                //
                // You start the device after everyone below you have started it
                //
                Irp->IoStatus.Status = ntStatus = USBPRINT_StartDevice(DeviceObject);
              }
            } /*end if not child*/
            else
            {
                ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            bHandled = TRUE;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            USBPRINT_DecrementIoCount(DeviceObject);
            
          } //end case IRP_MN_START_DEVICE
          break;

          case IRP_MN_STOP_DEVICE:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
              USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_STOP_DEVICE\n")); 
              
              //
              // You stop the device first and then let everyone below you deal with it
              //
              ntStatus = USBPRINT_StopDevice(DeviceObject);
              ASSERT(NT_SUCCESS(ntStatus));

              //
              // We want to stop the device anyway ..
              //
              Irp->IoStatus.Status = STATUS_SUCCESS;
              IoSkipCurrentIrpStackLocation(Irp);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
            }
            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_SURPRISE_REMOVAL:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
                USBPRINT_KdPrint2(("USBPRINT.SYS:   Surprise Remove")); 
                
                ntStatus = USBPRINT_StopDevice(DeviceObject);
                ASSERT(NT_SUCCESS(ntStatus));
                Irp->IoStatus.Status=STATUS_SUCCESS;  

                deviceExtension->AcceptingRequests=FALSE;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
            } /*end else NOT child device*/

            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_REMOVE_DEVICE:
             
            if(deviceExtension->IsChildDevice==FALSE)
            {
                USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_REMOVE_DEVICE\n")); 
                
                // match the inc at the begining of the dispatch routine
                USBPRINT_DecrementIoCount(DeviceObject);

                ntStatus = USBPRINT_StopDevice(DeviceObject);
                ASSERT(NT_SUCCESS(ntStatus));
                Irp->IoStatus.Status=STATUS_SUCCESS;  

                //
                // ounce this flag is set no irps will be pased 
                // down the stack to lower drivers
                //
                deviceExtension->AcceptingRequests = FALSE;
                if(deviceExtension->bChildDeviceHere)
                {
                  deviceExtension->bChildDeviceHere=FALSE;
                  IoDeleteDevice(deviceExtension->ChildDevice);
                  USBPRINT_KdPrint3(("USBPRINT.SYS: Deleted child device\n"));
                }
              if (NT_SUCCESS(ntStatus)) 
              {
                LONG pendingIoCount;
                USBPRINT_KdPrint3(("USBPRINT.SYS: About to copy current IrpStackLocation\n"));
                IoCopyCurrentIrpStackLocationToNext(Irp);  
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
                

    //          Irp->IoStatus.Information = 0;
                //
                // final decrement will trigger the remove
                //
                pendingIoCount = USBPRINT_DecrementIoCount(DeviceObject);

                {
                  NTSTATUS status;

                  // wait for any io request pending in our driver to
                  // complete for finishing the remove
                  status = KeWaitForSingleObject(&deviceExtension->RemoveEvent,Suspended,KernelMode,FALSE,NULL);
//                    TRAP();
                } /*end of non-controled code block*/
                //
                // Delete the link and FDO we created
                //
                USBPRINT_RemoveDevice(DeviceObject);
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Detaching from %08X\n",deviceExtension->TopOfStackDeviceObject));
                IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Deleting %08X\n",DeviceObject));

                IoDeleteDevice (DeviceObject);
                } /*end if NT_SUCCESS(ntStatus)*/
            } /*end if IsChildDevice==FALSE*/
            else
            {
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            bHandled = TRUE;
          break; //case IRP_MN_REMOVE_DEVICE

          case IRP_MN_QUERY_CAPABILITIES:
          {
            if(deviceExtension->IsChildDevice==FALSE) //if it's the parent, pass down the irp, and set SurpriseRemovalOK on the way back up
            {
              KEVENT event;
              KeInitializeEvent(&event, NotificationEvent, FALSE);
              IoCopyCurrentIrpStackLocationToNext(Irp);  
              IoSetCompletionRoutine(Irp,USBPRINT_DeferIrpCompletion,&event,TRUE,TRUE,TRUE);
              ntStatus = IoCallDriver(stackDeviceObject,Irp);
              if (ntStatus == STATUS_PENDING) 
              {
                KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
                ntStatus = Irp->IoStatus.Status;
              }

              if ( NT_SUCCESS(ntStatus) )
                irpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;

                // get device wake for selective suspend
                deviceExtension->DeviceWake = irpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake;
            }
            else
            {
               irpStack->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE;
               irpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
 
                Irp->IoStatus.Status = STATUS_SUCCESS;

              ntStatus=STATUS_SUCCESS;
            }
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
          
            bHandled = TRUE;
            USBPRINT_DecrementIoCount(DeviceObject);
          }
          break;

          case IRP_MN_QUERY_DEVICE_TEXT:
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_DEVICE_TEXT\n"));
            if(deviceExtension->IsChildDevice==TRUE)
            {
                PCHILD_DEVICE_EXTENSION pChildDeviceExtension=(PCHILD_DEVICE_EXTENSION)deviceExtension;
                PDEVICE_EXTENSION pParentExtension=pChildDeviceExtension->ParentDeviceObject->DeviceExtension;
                USBPRINT_KdPrint2(("USBPRINT.SYS: Is child PDO, will complete locally\n"));
                switch(irpStack->Parameters.QueryDeviceText.DeviceTextType)
                {
                  case DeviceTextDescription:
                  {
                     ANSI_STRING     AnsiTextString;
                     UNICODE_STRING  UnicodeDeviceText;
                     RtlInitAnsiString(&AnsiTextString,pParentExtension->DeviceIdString);
                     ntStatus=RtlAnsiStringToUnicodeString(&UnicodeDeviceText,&AnsiTextString,TRUE);
                     if(NT_SUCCESS(ntStatus))
                         Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceText.Buffer;
                  }
                  break;
                  default:
                    ntStatus=Irp->IoStatus.Status;
                }
                bHandled=TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }


          break;


          case IRP_MN_QUERY_BUS_INFORMATION:

              if(deviceExtension->IsChildDevice==TRUE)
              {
                PPNP_BUS_INFORMATION  pBusInfo = ExAllocatePool( PagedPool, sizeof(PNP_BUS_INFORMATION) );
    
                USBPRINT_KdPrint2(("USBPRINT.SYS: IRP_MN_QUERY_BUS_INFORMATION\n"));
    
                if( pBusInfo )
                {
                    pBusInfo->BusTypeGuid      = GUID_BUS_TYPE_USBPRINT;
                    pBusInfo->LegacyBusType    = PNPBus;
                    pBusInfo->BusNumber        = 0;
                    ntStatus                   = STATUS_SUCCESS;
                    Irp->IoStatus.Information = (ULONG_PTR)pBusInfo;
                }
                else
                {
                    ntStatus = STATUS_NO_MEMORY;
                }
    
                bHandled = TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
              }
          break;






          case IRP_MN_QUERY_ID:
          {  
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_ID\n"));
            if(deviceExtension->IsChildDevice==TRUE)
            {
                USBPRINT_KdPrint2(("USBPRINT.SYS: Is child PDO, will complete locally\n"));
                ntStatus=ProduceQueriedID(deviceExtension,irpStack,Irp,DeviceObject);
                bHandled = TRUE;
                USBPRINT_DecrementIoCount(DeviceObject);
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            } /*end if child PDO*/
          } /*end case QUERY_ID*/
          break;

          case IRP_MN_QUERY_DEVICE_RELATIONS:
            USBPRINT_KdPrint2 (("USBPRINT.SYS: IRP_MN_QUERY_DEVICE_RELATIONS\n"));
            ntStatus=QueryDeviceRelations(DeviceObject,Irp,irpStack->Parameters.QueryDeviceRelations.Type,&bHandled);
            if ( bHandled )
                USBPRINT_DecrementIoCount(DeviceObject);
          break;

          case IRP_MN_QUERY_STOP_DEVICE:
          case IRP_MN_CANCEL_STOP_DEVICE:
          case IRP_MN_QUERY_REMOVE_DEVICE:
          case IRP_MN_CANCEL_REMOVE_DEVICE:
            if(deviceExtension->IsChildDevice)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                ntStatus=STATUS_SUCCESS;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            else
            {
                ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(Irp);
                ntStatus = IoCallDriver(stackDeviceObject,Irp);
            }
            USBPRINT_DecrementIoCount(DeviceObject);
            bHandled = TRUE;
            break;
          
  
        } /* end IRP_MN swich inside IRP_MJ_PNP case */


        if(!bHandled)
        {
          if(deviceExtension->IsChildDevice==TRUE)
          {
            USBPRINT_KdPrint3(("USBPRINT.SYS: unsupported child pnp IRP\n"));
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest (Irp,IO_NO_INCREMENT);
          } /*end if child device*/
          else
          {
            IoSkipCurrentIrpStackLocation(Irp);
            ntStatus = IoCallDriver(stackDeviceObject,Irp);
          }

          USBPRINT_DecrementIoCount(DeviceObject);
        } /*end if !bHandled*/

#ifdef  MYDEBUG
    DbgPrint("Returning %d\n", ntStatus);
#endif
    return ntStatus;
} /*end function USBPRINT_Dispatch*/


NTSTATUS
USBPRINT_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT stackDeviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the device extension
    //
    deviceExtension = DeviceObject->DeviceExtension;
    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;

    USBPRINT_IncrementIoCount(DeviceObject);

    if(deviceExtension->IsChildDevice==TRUE)
    {
        USBPRINT_KdPrint3(("USBPRINT.SYS: unsupported child SystemControl IRP\n"));
        ntStatus = Irp->IoStatus.Status;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
    } /*end if child device*/
    else
    {
        IoSkipCurrentIrpStackLocation(Irp);
        ntStatus = IoCallDriver(stackDeviceObject,Irp);
    }

    USBPRINT_DecrementIoCount(DeviceObject);
    return ntStatus;
}


NTSTATUS QueryDeviceRelations(PDEVICE_OBJECT DeviceObject,PIRP Irp,DEVICE_RELATION_TYPE RelationType,BOOL *pbComplete)
{
        PIO_STACK_LOCATION irpSp;
        NTSTATUS ntStatus;
        PDEVICE_EXTENSION pExtension;
        PDEVICE_RELATIONS pRelations;
        *pbComplete=FALSE;



        pExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
        ntStatus=Irp->IoStatus.Status;
        irpSp=IoGetCurrentIrpStackLocation(Irp);

        if(!pExtension->IsChildDevice)
        {
            USBPRINT_KdPrint2 (("USBPRINT.SYS: Parent QueryDeviceRelations\n"));
                if(RelationType==BusRelations)
                {
                  *pbComplete=TRUE;
                  pRelations=(PDEVICE_RELATIONS)ExAllocatePoolWithTag(NonPagedPool,sizeof(DEVICE_RELATIONS), USBP_TAG);
                  if(pRelations!=NULL)
                  {
                          //Some drivers check for pre-existing children and preserve them.  This would happen if there is a filter driver above us, but we're not REALLY a bus driver

                          pRelations->Objects[0]=pExtension->ChildDevice;
                          pRelations->Count = 1;
                          ObReferenceObject(pExtension->ChildDevice);
                          Irp->IoStatus.Information=(ULONG_PTR)pRelations;
              Irp->IoStatus.Status = STATUS_SUCCESS;

                  IoCopyCurrentIrpStackLocationToNext(Irp);
                  ntStatus = IoCallDriver(pExtension->TopOfStackDeviceObject,Irp);
                  } /*end !NULL*/
                  else
                  {
                         ntStatus=STATUS_NO_MEMORY;
                         Irp->IoStatus.Status = ntStatus;
                         IoCompleteRequest(Irp, IO_NO_INCREMENT);
                  }
                //Port info will be written to the registry in the IRP_MN_QUERY_ID case.  It can't be used before then anyway
                } /*end if BusRelations*/

        } else {

            USBPRINT_KdPrint2 (("USBPRINT.SYS: Child QueryDeviceRelations\n"));
            if(RelationType==TargetDeviceRelation)
                {
                  *pbComplete=TRUE;
                  pRelations=(PDEVICE_RELATIONS)ExAllocatePoolWithTag(NonPagedPool,sizeof(DEVICE_RELATIONS), USBP_TAG);
                  if(pRelations!=NULL)
                  {
                        pRelations->Count = 1;
                          pRelations->Objects[0]=DeviceObject;
                          ObReferenceObject(DeviceObject);
                          Irp->IoStatus.Information=(ULONG_PTR)pRelations;
                          ntStatus = STATUS_SUCCESS;
                          Irp->IoStatus.Status = ntStatus;
                          IoCompleteRequest(Irp, IO_NO_INCREMENT);

                  } /*end !NULL*/
                  else
                  {
                         ntStatus=STATUS_NO_MEMORY;
                         Irp->IoStatus.Status = ntStatus;
                         IoCompleteRequest(Irp, IO_NO_INCREMENT);
                  }
                //Port info will be written to the registry in the IRP_MN_QUERY_ID case.  It can't be used before then anyway
                } /*end if BusRelations*/
        }
    return ntStatus;
}


VOID
USBPRINT_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++    

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  enter USBPRINT_Unload\n"));
    
   if(pGPortList!=NULL)
    {
        ClearFreePorts(&pGPortList);
    }
 
//  if(pPortsUsed!=NULL)
//    ExFreePool(pPortsUsed);



    //
    // Free any global resources allocated
    // in DriverEntry
    //
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  exit USBPRINT_Unload\n"));
}


NTSTATUS
USBPRINT_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB.
    All we do here is get the device descriptor and store it

Arguments:

    DeviceObject - pointer to the device object for this instance of a  printer
                                          

Return Value:

    NT status code
    
      --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    UNICODE_STRING KeyName;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb=NULL;
    ULONG siz;
    ULONG dwVidPid;
    PDEVICE_OBJECT NewDevice;
    LARGE_INTEGER   timeOut;
        
    PCHILD_DEVICE_EXTENSION pChildExtension;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_StartDevice\n")); 
    

    
    deviceExtension = DeviceObject->DeviceExtension;
    
    
    ntStatus = USBPRINT_ConfigureDevice(DeviceObject);
    if(NT_SUCCESS(ntStatus))
    {
      urb = ExAllocatePoolWithTag(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), USBP_TAG);
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS:  USBPRINT_ConfigureDevice Failed\n"));   
        urb=NULL;
    }
    if (urb) 
    {
         siz = sizeof(USB_DEVICE_DESCRIPTOR);
        
        deviceDescriptor = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG); 
        
        if (deviceDescriptor) 
        {
            
            
            UsbBuildGetDescriptorRequest(urb,
                (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                USB_DEVICE_DESCRIPTOR_TYPE,
                0,
                0,
                deviceDescriptor,
                NULL,
                siz,
                NULL);
            
            timeOut.QuadPart = FAILURE_TIMEOUT;
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            
            
            if (NT_SUCCESS(ntStatus)) 
            {
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Device Descriptor = %x, len %x\n",
                    deviceDescriptor,
                    urb->UrbControlDescriptorRequest.TransferBufferLength));
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: USBPRINT Device Descriptor:\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: -------------------------\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bLength %d\n", deviceDescriptor->bLength));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: idVendor 0x%x\n", deviceDescriptor->idVendor));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: idProduct 0x%x\n", deviceDescriptor->idProduct));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iProduct 0x%x\n", deviceDescriptor->iProduct));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
                
                dwVidPid=deviceDescriptor->idVendor;
                dwVidPid<<=16;
                dwVidPid+=deviceDescriptor->idProduct;
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Math OK\n"));
                
            }
            else
            {
              USBPRINT_KdPrint1(("USBPRINT.SYS: Get Device Descriptor failed\n"));
              ntStatus=STATUS_DEVICE_CONFIGURATION_ERROR;
            }
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate device descriptor in StartDevice\n"));
        }
        
        if (NT_SUCCESS(ntStatus)) 
        {
            deviceExtension->DeviceDescriptor = deviceDescriptor;
        } else if (deviceDescriptor) 
        {
            ExFreePool(deviceDescriptor);
        }
        
        ExFreePool(urb);
        
    }
    else 
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate urb in StartDevice\n"));
 
    }
    

    if(deviceExtension->bChildDeviceHere==FALSE)
    {
      if(NT_SUCCESS(ntStatus))
      {
         ntStatus=IoCreateDevice(USBPRINT_DriverObject,
         sizeof(CHILD_DEVICE_EXTENSION),
         NULL,
         FILE_DEVICE_PARALLEL_PORT,
         FILE_AUTOGENERATED_DEVICE_NAME,
         TRUE,
         &NewDevice);    
      
      }
      if(NT_SUCCESS(ntStatus))
      {
   
         USBPRINT_KdPrint3(("USBPRINT.SYS:  IoCreateDevice succeeded for child device\n"));
         NewDevice->Flags|=DO_POWER_PAGABLE;
         pChildExtension=NewDevice->DeviceExtension;
         pChildExtension->ParentDeviceObject=DeviceObject;
         deviceExtension->ChildDevice=NewDevice;
         deviceExtension->bChildDeviceHere=TRUE;
         pChildExtension->IsChildDevice=TRUE;
         pChildExtension->ulInstanceNumber=deviceExtension->ulInstanceNumber;

      
      }
    
      else
      {
           USBPRINT_KdPrint1(("USBPRINT.SYS:  IoCreateDevice failed for child device\n"));
      }
    } /*end if we need to make a child device*/
    if(NT_SUCCESS(ntStatus))
    {
   
        USBPRINT_GetDeviceID(DeviceObject);
        WritePortDescription(deviceExtension);
        ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),TRUE);


    }

    if (NT_SUCCESS(ntStatus)) 
    {
        ntStatus = USBPRINT_BuildPipeList(DeviceObject);

        if(!deviceExtension->IsChildDevice)
        {
            USBPRINT_FdoSubmitIdleRequestIrp(deviceExtension);
        }
    }
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_StartDevice (%x)\n", ntStatus)); 
    
    return ntStatus;
}

void WritePortDescription(PDEVICE_EXTENSION deviceExtension)
{
    UNICODE_STRING ValueName;
    ANSI_STRING     AnsiTextString;
    UNICODE_STRING Description;
    UNICODE_STRING BaseName,BaseValueName;
 



    RtlInitUnicodeString(&ValueName,L"Port Description");
    
    RtlInitAnsiString(&AnsiTextString,deviceExtension->DeviceIdString);
    RtlAnsiStringToUnicodeString(&Description,&AnsiTextString,TRUE);

                                                                                                           
    ZwSetValueKey(deviceExtension->hInterfaceKey,&ValueName,0,REG_SZ,Description.Buffer,Description.Length+2);
    RtlFreeUnicodeString(&Description);


    RtlInitUnicodeString(&BaseName,L"USB");
    RtlInitUnicodeString(&BaseValueName,L"Base Name");
    ZwSetValueKey(deviceExtension->hInterfaceKey,&BaseValueName,0,REG_SZ,BaseName.Buffer,BaseName.Length+2);
}


NTSTATUS
USBPRINT_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of printer

Arguments:

    DeviceObject - pointer to the device object for this instance of the (parent) printer object

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_RemoveDevice\n"));
    

    deviceExtension = DeviceObject->DeviceExtension;


    ZwClose(deviceExtension->hInterfaceKey);
    USBPRINT_KdPrint2(("USBPRINT.SYS:  Closeing interface key in RemoveDevice\n"));  

    ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),FALSE);
    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: ioSetDeviceInterface to false failed\n"));
    }

    RtlFreeUnicodeString(&(deviceExtension->DeviceLinkName));

    

    //
    // Free device descriptor structure
    //

    if (deviceExtension->DeviceDescriptor) {
    ExFreePool(deviceExtension->DeviceDescriptor);
    }

    //
    // Free up any interface structures
    //

    if (deviceExtension->Interface) {
    ExFreePool(deviceExtension->Interface);
    }

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_RemoveDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a printer  on the USB, this is only
    stuff we need to do if the device is still present.

Arguments:

    DeviceObject - pointer to the device object for this printer

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    USBPRINT_KdPrint3 (("USBPRINT.SYS: enter USBPRINT_StopDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);

    urb = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG);

    if (urb) {
    NTSTATUS status;

    UsbBuildSelectConfigurationRequest(urb,
                      (USHORT) siz,
                      NULL);

    status = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);

    USBPRINT_KdPrint3 (("USBPRINT.SYS: Device Configuration Closed status = %x usb status = %x.\n",
            status, urb->UrbHeader.Status));

    ExFreePool(urb);                                                                                   
    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device

Arguments:

    DriverObject - pointer to the driver object for this instance of USBPRINT

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;
    USBD_VERSION_INFORMATION versionInformation;
    ULONG ulPortNumber;
    GUID * pPrinterGuid;
    
    static ULONG instance = 0;
    //UNICODE_STRING deviceLinkUnicodeString;
    HANDLE hInterfaceKey;
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  enter USBPRINT_PnPAddDevice\n"));
    


    //
    // create our funtional device object (FDO)
    //

    ntStatus =
    USBPRINT_CreateDeviceObject(DriverObject, &deviceObject);

    if (NT_SUCCESS(ntStatus)) {
    deviceExtension = deviceObject->DeviceExtension;

    //
    // we support direct io for read/write
    //
    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->Flags |= DO_POWER_PAGABLE;
    

    //** initialize our device extension
    //
    // remember the Physical device Object
    //
    deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

    // init selective suspend stuff
    deviceExtension->PendingIdleIrp 	= NULL;
    deviceExtension->IdleCallbackInfo 	= NULL;
    deviceExtension->OpenCnt=0;
    deviceExtension->bD0IrpPending=FALSE;
    KeInitializeSpinLock(&(deviceExtension->WakeSpinLock));

    //
    // Attach to the PDO
    //

    deviceExtension->TopOfStackDeviceObject=IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if(deviceExtension->TopOfStackDeviceObject==NULL)
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS:  IoAttachDeviceToDeviceStack failed\n"));
    }                                                                                                                                                        
    else
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS:  IoAttachDeviceToDeviceStack worked\n"));
    }

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    USBPRINT_KdPrint3(("'USBPRINT.SYS:  Before ioRegisterDeviceInterface\n"));
    pPrinterGuid=(GUID *)&USBPRINT_GUID;
    ntStatus=IoRegisterDeviceInterface(PhysicalDeviceObject,pPrinterGuid,NULL,&(deviceExtension->DeviceLinkName));
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("'USBPRINT.SYS:  ioRegisterDeviceInterface failed\n"));  
      goto AddDeviceFailure;
    }


    ntStatus=IoOpenDeviceInterfaceRegistryKey(&(deviceExtension->DeviceLinkName),KEY_ALL_ACCESS,&hInterfaceKey);
    USBPRINT_KdPrint2(("USBPRINT.SYS:  Opened Device Interface reg key in AddDevice\n"));  
    // moved to RemoveDevice RtlFreeUnicodeString(&deviceLinkUnicodeString);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: IoOpenDeviceInterfaceRegistryKey failed\n"));
      goto AddDeviceFailure;
    }
    USBPRINT_KdPrint3(("USBPRINT.SYS: IoOpenDeviceInterfaceRegistryKey succeeded\n"));
    deviceExtension->hInterfaceKey=hInterfaceKey;
    
    ntStatus=GetPortNumber(hInterfaceKey,&ulPortNumber);
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber failed\n"));
      goto AddDeviceFailure;
    }
    deviceExtension->ulInstanceNumber=ulPortNumber;
    USBPRINT_KdPrint2(("USBPRINT.SYS:   Allocated port # %u\n",ulPortNumber));
    
/*    ntStatus=IoSetDeviceInterfaceState(&(deviceExtension->DeviceLinkName),TRUE);


    if(NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS:  IoSetDeviceInterfaceState worked\n"));
    }
    else
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS:  IoSetDeviceInterfaceState did not work\n"));
      goto AddDeviceFailure;
    }

  */
    USBPRINT_QueryCapabilities(PhysicalDeviceObject,
                 &deviceExtension->DeviceCapabilities);            

    //
    // display the device  caps
    //
#if DBG
    {
    ULONG i;
    
    USBPRINT_KdPrint3(("USBPRINT.SYS:  >>>>>> DeviceCaps\n"));  
    USBPRINT_KdPrint3(("USBPRINT.SYS:  SystemWake = (%d)\n", 
        deviceExtension->DeviceCapabilities.SystemWake));    
    USBPRINT_KdPrint3(("USBPRINT.SYS:  DeviceWake = (D%d)\n",
        deviceExtension->DeviceCapabilities.DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++) {
        
        USBPRINT_KdPrint3(("USBPRINT.SYS:  Device State Map: sysstate %d = devstate 0x%x\n", i, 
         deviceExtension->DeviceCapabilities.DeviceState[i]));       
    }
    USBPRINT_KdPrint3(("USBPRINT.SYS:  '<<<<<<<<DeviceCaps\n"));
    }
#endif
    //
    // transition to zero signals the event
    //
    USBPRINT_IncrementIoCount(deviceObject);                                 
    }

    USBD_GetUSBDIVersion(&versionInformation);
AddDeviceFailure:
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    Creates a Functional DeviceObject

Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
            created device object.

    Instance - instnace of the device create.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    ULONG instance;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_CreateDeviceObject\n"));

    //
    // This driver supports up to 9 instances
    //



    ntStatus = IoCreateDevice (DriverObject,
                   sizeof (DEVICE_EXTENSION),
                   NULL,
                   FILE_DEVICE_UNKNOWN,
                   0,
                   FALSE,
                   DeviceObject);
    //
    // Initialize our device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

    deviceExtension->IsChildDevice=FALSE;
    deviceExtension->ResetWorkItemPending=0; //init to "no workitem pending"
    deviceExtension->bChildDeviceHere=FALSE;

    deviceExtension->DeviceDescriptor = NULL;
    deviceExtension->Interface = NULL;
    deviceExtension->ConfigurationHandle = NULL;
    deviceExtension->AcceptingRequests = TRUE;
    deviceExtension->PendingIoCount = 0;

    deviceExtension->DeviceCapabilities.Size    = sizeof(DEVICE_CAPABILITIES);
    deviceExtension->DeviceCapabilities.Version = DEVICE_CAPABILITY_VERSION;
    deviceExtension->DeviceCapabilities.Address = (ULONG) -1;
    deviceExtension->DeviceCapabilities.UINumber= (ULONG) -1;

    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemWorking] = PowerDeviceD0;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    deviceExtension->DeviceCapabilities.DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    KeInitializeEvent(&deviceExtension->RemoveEvent, NotificationEvent, FALSE);

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_CallUSBD(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb,
    IN PLARGE_INTEGER   pTimeout 
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this printer

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    KEVENT event;
    PIO_STACK_LOCATION nextStack;



    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_CallUSBD\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if ( (irp = IoAllocateIrp(deviceExtension->TopOfStackDeviceObject->StackSize,
                              FALSE)) == NULL )
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->Parameters.Others.Argument1 = Urb;

    IoSetCompletionRoutine(irp,
               USBPRINT_DeferIrpCompletion,
               &event,
               TRUE,
               TRUE,
               TRUE);
               
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                irp);

    if ( ntStatus == STATUS_PENDING ) 
    {
        status = KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,pTimeout);
        //
        // If the request timed out cancel the request
        // and wait for it to complete
        //
        if ( status == STATUS_TIMEOUT ) {

#ifdef  MYDEBUG
            DbgPrint("Call_USBD: Cancelling IRP %X because of timeout\n", irp);
#endif

            IoCancelIrp(irp);
            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
        }

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_CallUSBD (%x)\n", ntStatus));

    USBPRINT_KdPrint3 (("USBPRINT.SYS: About to return from CallUSBD, status=%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBPRINT_ConfigureDevice(
                         IN  PDEVICE_OBJECT DeviceObject
                         )
/*++
                         
Routine Description:
     Initializes a given instance of the device on the USB and selects the configuration.
                             
Arguments:
     DeviceObject - pointer to the device object for this printer devcice.

 Return Value:  
     NT status code
                                       
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;

    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_ConfigureDevice\n")); 
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    //
    // first configure the device
    //
    
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), USBP_TAG);
    
    if (urb) 
    {
        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR)+256;
        
get_config_descriptor_retry:
        
        configurationDescriptor = ExAllocatePoolWithTag(NonPagedPool,siz, USBP_TAG);
        
        if (configurationDescriptor) 
        {
            
            UsbBuildGetDescriptorRequest(urb,
                (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                USB_CONFIGURATION_DESCRIPTOR_TYPE,
                0,
                0,
                configurationDescriptor,
                NULL,
                siz,
                NULL);
            
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            if(!NT_SUCCESS(ntStatus))
            {
                USBPRINT_KdPrint1 (("USBPRINT.SYS: Get Configuration descriptor failed\n"));
            }
            else
            {
                //
                // if we got some data see if it was enough.
                //
                // NOTE: we may get an error in URB because of buffer overrun
                if (urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&configurationDescriptor->wTotalLength > siz)
                {
                
                    siz = configurationDescriptor->wTotalLength;
                    ExFreePool(configurationDescriptor);
                    configurationDescriptor = NULL;
                    goto get_config_descriptor_retry;
                }
            }
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Configuration Descriptor = %x, len %x\n",
                configurationDescriptor,
                urb->UrbControlDescriptorRequest.TransferBufferLength));
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1(("USBPRINT.SYS: Insufficient resources to allocate configuration descriptor in ConfigureDevice\n"));
        }
                
        ExFreePool(urb);
        
    } 
    else 
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if (configurationDescriptor) 
    {
        
        USBPRINT_KdPrint2(("USBPRINT.SYS: ConfigureDevice, We have a configuration descriptor!\n"));
        //
        // We have the configuration descriptor for the configuration
        // we want.
        //
        // Now we issue the select configuration command to get
        // the  pipes associated with this configuration.
        //
        if(NT_SUCCESS(ntStatus))
        {
          ntStatus = USBPRINT_SelectInterface(DeviceObject,configurationDescriptor);
          
        }
        ExFreePool(configurationDescriptor);
    }
    else
    {
            USBPRINT_KdPrint1(("USBPRINT.SYS: ConfigureDevice, No Configuration descriptor.\n"));
    }
    
    
    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_ConfigureDevice (%x)\n", ntStatus));
    
    return ntStatus;
}


NTSTATUS USBPRINT_SelectInterface(IN PDEVICE_OBJECT DeviceObject,IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor)
/*++

Routine Description:

    Initializes a printer with multiple interfaces

Arguments:

    DeviceObject - pointer to the device object for this printer
            

    ConfigurationDescriptor - pointer to the USB configuration
            descriptor containing the interface and endpoint
            descriptors.

Return Value:

    NT status code

  --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor = NULL;
    PUSBD_INTERFACE_INFORMATION Interface = NULL;
    USBD_INTERFACE_LIST_ENTRY InterfaceList[2];
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;

    
    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_SelectInterface\n"));
    deviceExtension = DeviceObject->DeviceExtension;
    
    //starting at offset 0, search for an alternate interface with protocol code 2;  Ignore InterfaceNumber, AlternateSetting, InterfaceClass, InterfaceSubClass
    interfaceDescriptor=USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,ConfigurationDescriptor,-1,-1,-1,-1,2);
    if(!interfaceDescriptor)
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS:  First ParseConfigurationDescriptorEx failed\n"));
        interfaceDescriptor=USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,ConfigurationDescriptor,-1,-1,-1,-1,1);
        if(!interfaceDescriptor)
        {
            USBPRINT_KdPrint1 (("USBPRINT.SYS:  second ParseConfigurationDescriptorEx failed\n"));
            ntStatus=STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            USBPRINT_KdPrint3 (("USBPRINT.SYS:  second ParseConfigurationDescriptorEx success\n"));
            deviceExtension->bReadSupported=FALSE;
        } /*end second ParseConfigDescriptor worked*/
    }
    else
    {
        deviceExtension->bReadSupported=TRUE;
        USBPRINT_KdPrint3 (("USBPRINT.SYS:  First ParseConfigurationDescriptorEx success\n"));
    }
    if(interfaceDescriptor)
    {
        InterfaceList[0].InterfaceDescriptor=interfaceDescriptor;
        InterfaceList[1].InterfaceDescriptor=NULL;
        urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,InterfaceList);
        if (urb) 
        {
            Interface = InterfaceList[0].Interface;
            ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: CreateConfigurationRequest failed\n"));
        }
    } //end found good interface
    else
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: failed to locate apropriate interface\n"));
    } //end no interface
    
   
    if (NT_SUCCESS(ntStatus)) 
    {
        
        //
        // Save the configuration handle for this device
        //
        
        USBPRINT_KdPrint3 (("USBPRINT.SYS: SelectInterface, Inside good config case\n"));
        deviceExtension->ConfigurationHandle = urb->UrbSelectConfiguration.ConfigurationHandle;
        
        deviceExtension->Interface = ExAllocatePoolWithTag(NonPagedPool,Interface->Length, USBP_TAG);
        
        if (deviceExtension->Interface) 
        {
            ULONG j;
            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory(deviceExtension->Interface, Interface, Interface->Length);
            
            //
            // Dump the interface to the debugger
            //
            USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: NumberOfPipes 0x%x\n", deviceExtension->Interface->NumberOfPipes));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Length 0x%x\n", deviceExtension->Interface->Length));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Alt Setting 0x%x\n", deviceExtension->Interface->AlternateSetting));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Interface Number 0x%x\n", deviceExtension->Interface->InterfaceNumber));
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                deviceExtension->Interface->Class,
                deviceExtension->Interface->SubClass,
                deviceExtension->Interface->Protocol));
            
            // Dump the pipe info
            
            for (j=0; j<Interface->NumberOfPipes; j++) 
            {
                PUSBD_PIPE_INFORMATION pipeInformation;
                
                pipeInformation = &deviceExtension->Interface->Pipes[j];
                
                USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: PipeType 0x%x\n", pipeInformation->PipeType));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Interval 0x%x\n", pipeInformation->Interval));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: Handle 0x%x\n", pipeInformation->PipeHandle));
                USBPRINT_KdPrint3 (("USBPRINT.SYS: MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));
            }
            
            USBPRINT_KdPrint3 (("USBPRINT.SYS: ---------\n"));
        } /*end if interface Alloc OK*/
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Alloc failed in SelectInterface\n"));
        }
    }
    
    if (urb) 
    {
        ExFreePool(urb);
    }
    USBPRINT_KdPrint2 (("USBPRINT.SYS: exit USBPRINT_SelectInterface (%x)\n", ntStatus));
    
    return ntStatus;
}


NTSTATUS
USBPRINT_BuildPipeList(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this printer
            devcice.


Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;
    WCHAR Name[] = L"\\PIPE00";
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;
    BOOL bFoundWritePipe=FALSE,bFoundReadPipe=FALSE,bNeedReadPipe=FALSE;
    

    deviceExtension = DeviceObject->DeviceExtension;
    InterfaceDescriptor = deviceExtension->Interface;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_BuildPipeList\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    if(InterfaceDescriptor->Protocol==2)
        bNeedReadPipe=TRUE;
    else
        bNeedReadPipe=FALSE;


    for (i=0; i<InterfaceDescriptor->NumberOfPipes; i++) {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: about to look at endpoint with address 0x%x)\n",InterfaceDescriptor->Pipes[i].EndpointAddress));
        if(((InterfaceDescriptor->Pipes[i].EndpointAddress)&0x80)==0) //if bit 7 is 0, it's an OUT endpoint
        {
          if(bFoundWritePipe==TRUE)
          {
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  Multiple OUT pipes detected on printer.  Defaulting to first pipe\n"));
          } /*end if we've already found a write pipe*/
          else
          {
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Found write pipe\n"));
            deviceExtension->pWritePipe=&(InterfaceDescriptor->Pipes[i]);
            bFoundWritePipe=TRUE;
          } /*else we haven't seen an OUT endpont before*/
        } /*end if it's an OUT endpoint*/
        else
        {
          if(!bNeedReadPipe)
          {
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  unexpected IN pipe (not specified in protocol field)\n"));
          } /*end if we don't need a read pipe, but we found one*/
          else if(bFoundReadPipe)
          {
              USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  Multiple IN pipes detected on printer.  Defaulting to first pipe\n"));
          } /*end if we've already found a read pipe*/
          else
          {     
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Found read pipe\n"));
            deviceExtension->pReadPipe=&(InterfaceDescriptor->Pipes[i]);
            bFoundReadPipe=TRUE;
          } /*end else we're supposed to have an IN pipe, and this is the first one we've seen*/
        } /*end else it's an IN endpoint*/
    } /*end for*/
    if((bNeedReadPipe==TRUE)&&(bFoundReadPipe==FALSE))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: Warning!!  IN pipe was specified in protocol field, but was not found\n"));
    } /*end if we needed a read pipe, and didn't find one*/
    deviceExtension->bReadPipeExists=bFoundReadPipe;
    return STATUS_SUCCESS;
} /*end function BuildPipeList*/


NTSTATUS
USBPRINT_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    )
/*++

Routine Description:

    Reset a given USB pipe.
    
    NOTES:

    This will reset the host to Data0 and should also reset the device
    to Data0 for Bulk and Interrupt pipes.

    For Iso pipes this will set the virgin state of pipe so that ASAP
    transfers begin with the current bus frame instead of the next frame
    after the last transfer occurred.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    LARGE_INTEGER   timeOut;


    timeOut.QuadPart = FAILURE_TIMEOUT;


    USBPRINT_KdPrint2 (("USBPRINT.SYS: Entering Reset Pipe; pipe # %x\n", Pipe)); 

    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST), USBP_TAG);

    if (urb) {

    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    urb->UrbPipeRequest.PipeHandle =
        Pipe->PipeHandle;

    ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
    
    if(!NT_SUCCESS(ntStatus))
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: CallUSBD failed in ResetPipe\n"));
    }
    else
    {
      USBPRINT_KdPrint3(("USBPRINT.SYS: CallUSBD Succeeded in ResetPipe\n"));
    }

    ExFreePool(urb);

    } else {
    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Memphis RESET_PIPE will send a Clear-Feature Endpoint Stall to
    // reset the data toggle of non-Iso pipes as part of a RESET_PIPE
    // request.  It does not do this for Iso pipes as Iso pipes do not use
    // the data toggle (all Iso packets are Data0).  However, we also use
    // the Clear-Feature Endpoint Stall request in our device firmware to
    // reset data buffer points inside the device so we explicitly send
    // this request to the device for Iso pipes if desired.
    //
    if (NT_SUCCESS(ntStatus) && IsoClearStall &&
    (Pipe->PipeType == UsbdPipeTypeIsochronous)) {
    
    urb = ExAllocatePoolWithTag(NonPagedPool,sizeof(struct _URB_CONTROL_FEATURE_REQUEST), USBP_TAG);

    if (urb) {

        UsbBuildFeatureRequest(urb,
                   URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
                   USB_FEATURE_ENDPOINT_STALL,
                   Pipe->EndpointAddress,
                   NULL);

        ntStatus = USBPRINT_CallUSBD(DeviceObject, urb, &timeOut);
            

        ExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    }

    return ntStatus;
}


LONG
USBPRINT_DecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;
    LONG ioCount=0;

    deviceExtension = DeviceObject->DeviceExtension;
    if(!(deviceExtension->IsChildDevice))
    {
      ioCount = InterlockedDecrement(&deviceExtension->PendingIoCount);

#ifdef  MYDEBUG
    DbgPrint("USBPRINT_DecrementIoCount -- IoCount %d\n", deviceExtension->PendingIoCount);
#endif
      USBPRINT_KdPrint3 (("USBPRINT.SYS: Pending io count = %x\n", ioCount));

      if (ioCount==0) {
      KeSetEvent(&deviceExtension->RemoveEvent,
           1,
           FALSE);
      }
    } /*end if ! child device*/

    return ioCount;
}


VOID
USBPRINT_IncrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    if(!(deviceExtension->IsChildDevice))
    {
      InterlockedIncrement(&deviceExtension->PendingIoCount);
#ifdef  MYDEBUG
    DbgPrint("USBPRINT_IncrementIoCount -- IoCount %d\n", deviceExtension->PendingIoCount);
#endif
      //
      // Everytime iocount goes to 0 we set this event
      // so we must cleat it when we have a new io
      //
      KeClearEvent(&deviceExtension->RemoveEvent);
    }
}


NTSTATUS
USBPRINT_ReconfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB and selects the
    configuration.

Arguments:

    DeviceObject - pointer to the device object for this printer
            


Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_INTERFACE_INFORMATION InterfaceDescriptor;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: enter USBPRINT_ReconfigureDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(ntStatus)) {
    ntStatus = USBPRINT_ConfigureDevice(DeviceObject);
    }

    //
    // new InterfaceDescriptor structure is now set up
    //

    InterfaceDescriptor = deviceExtension->Interface;

    //
    // set up the pipe handles again
    //


    return ntStatus;
}


NTSTATUS LoadPortsUsed(GUID *pPrinterGuid,PFREE_PORTS * pPortList,WCHAR *wcBaseName)
{
    NTSTATUS ReturnStatus=STATUS_SUCCESS,Result=STATUS_SUCCESS;
    PWSTR pDeviceList;
    PWSTR pWalk;
    UNICODE_STRING wNumberValueName,wBaseValueName,wLinkName;
    ULONG ulPortNum;
    ULONG ulBaseNameSizeIn,ulBaseNameSizeOut,ulPortNumSizeIn,ulPortNumSizeOut;
    PKEY_VALUE_PARTIAL_INFORMATION pBaseValueStruct,pNumberValueStruct;
    HANDLE hInterfaceKey;
    BOOL bFoundUsbPort;
    
    
    
    Result=IoGetDeviceInterfaces(pPrinterGuid,NULL,DEVICE_INTERFACE_INCLUDE_NONACTIVE,&pDeviceList);
    if(Result==STATUS_SUCCESS)
    {
        RtlInitUnicodeString(&wNumberValueName,PORT_NUM_VALUE_NAME);
        RtlInitUnicodeString(&wBaseValueName,PORT_BASE_NAME);
        pWalk=pDeviceList;
        ulBaseNameSizeIn=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+((wcslen(wcBaseName)+1)*sizeof(WCHAR)); //this is a byte to much.  Oh well
        ulPortNumSizeIn=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG);
        pBaseValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulBaseNameSizeIn, USBP_TAG);
        pNumberValueStruct=ExAllocatePoolWithTag(NonPagedPool,ulPortNumSizeIn, USBP_TAG);
        if((pBaseValueStruct!=NULL)&&(pNumberValueStruct!=NULL))
        {
            while( *pWalk!=0 && NT_SUCCESS(ReturnStatus) )
            {
                RtlInitUnicodeString(&wLinkName,pWalk);
                Result=IoOpenDeviceInterfaceRegistryKey(&wLinkName,KEY_ALL_ACCESS,&hInterfaceKey);
                if(NT_SUCCESS(Result))
                {
                    
                    //The following is:  If there is not a value, or there is a value that matches what we expect, then set bFoundUsbPort to true
                    bFoundUsbPort=TRUE;
                    Result=ZwQueryValueKey(hInterfaceKey,&wBaseValueName,KeyValuePartialInformation,pBaseValueStruct,ulBaseNameSizeIn,&ulBaseNameSizeOut);
                    if(NT_SUCCESS(Result))
                    {
                        if(wcscmp(wcBaseName,(WCHAR *)(pBaseValueStruct->Data))!=0)
                            bFoundUsbPort=FALSE;
                    }//end if Query OK 
                    else if(STATUS_OBJECT_NAME_NOT_FOUND!=Result)
                    {
                        bFoundUsbPort=FALSE;
                    }
                    if(bFoundUsbPort)
                    {
                        Result=ZwQueryValueKey(hInterfaceKey,&wNumberValueName,KeyValuePartialInformation,pNumberValueStruct,ulPortNumSizeIn,&ulPortNumSizeOut);
                        if(NT_SUCCESS(Result))
                        {
                            ulPortNum=*((ULONG *)(pNumberValueStruct->Data));
                            if(!bDeleteIfRecyclable(hInterfaceKey))
                            {
                                USBPRINT_KdPrint2(("USBPRINT.SYS:  Adding port number\n"));
                                ReturnStatus=bAddPortInUseItem(pPortList,ulPortNum);
                                if(!NT_SUCCESS(ReturnStatus))
                                {
                                    USBPRINT_KdPrint1(("USBPRINT.SYS:  Unable to add port %u to port list\n",ulPortNum));
                                    USBPRINT_KdPrint1(("USBPRINT.SYS:  Failing out of LoadPortsUsed due to ntstatus failure %d\n",ReturnStatus));
                                } //end if AddPortInUse failed
                            } //end if port not deleted
                            else
                            {
//                                ReturnStatus=STATUS_INVALID_PARAMETER;
                                USBPRINT_KdPrint1(("USBPRINT.SYS:  Invalid port number %u\n",ulPortNum));
                            }
                        } //end if Query Port Number OK
                        //no else.  If there's no port number, we ignore this interface
                    } //End if bFoundUSbPort
                    ZwClose(hInterfaceKey);
                } //end if OpenReg ok
                pWalk=pWalk+wcslen(pWalk)+1;
            } //end while
        } //end ExAllocatePool OK
        else
        {
            USBPRINT_KdPrint1(("USBPRINT.SYS:  Unable to allocate memory"));
            ReturnStatus=STATUS_INSUFFICIENT_RESOURCES;
        }   /*end else ExAllocatePool failed*/
        if(pBaseValueStruct!=NULL)
            ExFreePool(pBaseValueStruct);
        if(pNumberValueStruct!=NULL)
            ExFreePool(pNumberValueStruct);
        ExFreePool(pDeviceList);
    } /*end if IoGetDeviceInterfaces success*/
    else
    {
        USBPRINT_KdPrint1(("USBPRINT.SYS:  IoGetDeviceInterfaces failed"));
        ReturnStatus=Result; //do some error translation here?
    }
    return ReturnStatus;
} /*end function LoadPortsUsed*/
                                

NTSTATUS GetPortNumber(HANDLE hInterfaceKey,
                       ULONG *ulReturnNumber)
{
  ULONG ulPortNumber,ulSizeUsed;
  NTSTATUS ntStatus=STATUS_SUCCESS;
  UNICODE_STRING uncValueName;
  PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;


  ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
  pValueStruct=ExAllocatePoolWithTag(PagedPool,ulSizeUsed, USBP_TAG);
  if(pValueStruct==NULL)
      return STATUS_INSUFFICIENT_RESOURCES;
  RtlInitUnicodeString(&uncValueName,PORT_NUM_VALUE_NAME);
  ntStatus=ZwQueryValueKey(hInterfaceKey,&uncValueName,KeyValuePartialInformation,(PVOID)pValueStruct,ulSizeUsed,&ulSizeUsed);
  if(!NT_SUCCESS(ntStatus))
  {
    USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber; ZwQueryValueKey failed\n"));
    switch(ntStatus)
    {
    case STATUS_BUFFER_OVERFLOW:          
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_BUFFER_OVERFLOW\n"));
    break;
    
    case STATUS_INVALID_PARAMETER:
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_INVALID_PARAMETER\n"));
    break;


    case STATUS_OBJECT_NAME_NOT_FOUND:
      USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned STATUS_OBJECT_NAME_NOT_FOUND\n"));
    break;

    default:
          USBPRINT_KdPrint2(("USBPRINT.SYS: GetPortNumber zwQueryValueKey returned unkown error\n"));
    }
    ntStatus=GetNewPortNumber(&pGPortList,&ulPortNumber);

  }
  else
  { 
    ulPortNumber=*((ULONG *)&(pValueStruct->Data));
    if(ulPortNumber==0) //zero is a placeholder for "not there" which we use because win9x is missing the zwDeleteValueKey api
      ntStatus=GetNewPortNumber(&pGPortList,&ulPortNumber);
    else
      vClaimPortNumber(ulPortNumber,hInterfaceKey,&pGPortList);
  }
  if(!NT_SUCCESS(ntStatus))
  {
    USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber; failed to allocate new port number\n"));
  }
  else
  {
    
      *ulReturnNumber=ulPortNumber;
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Inside \"write back to reg\" case, ulPortNumber==%d\n",ulPortNumber));
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Before ntstatys=success\n"));
      ntStatus=STATUS_SUCCESS;
      USBPRINT_KdPrint3(("USBPRINT.SYS: GetPortNumber; Before ZwSetValueKey\n"));
      ntStatus=ZwSetValueKey(hInterfaceKey,&uncValueName,0,REG_DWORD,&ulPortNumber,sizeof(ulPortNumber));
      if(!NT_SUCCESS(ntStatus))
      {
        USBPRINT_KdPrint1(("USBPRINT.SYS: GetPortNumber; Unable to set value key\n"));
      }
      else
      {
        *ulReturnNumber=ulPortNumber;
      }
  }
  ExFreePool(pValueStruct);
  return ntStatus;
} /*end function GetPortNumber*/


USBPRINT_GetDeviceID(PDEVICE_OBJECT ParentDeviceObject)
{
    UCHAR *p1284Id;
    NTSTATUS ntStatus;
    int iReturnSize;
    PDEVICE_EXTENSION pParentExtension;
    

    pParentExtension=ParentDeviceObject->DeviceExtension;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: GetDeviceID enter\n")); 


    p1284Id=ExAllocatePoolWithTag(NonPagedPool,MAX_ID_SIZE, USBP_TAG);
    if(p1284Id==NULL)
    {
        ntStatus=STATUS_NO_MEMORY;
    }
    else
    {
        
        iReturnSize=USBPRINT_Get1284Id(ParentDeviceObject,p1284Id,MAX_ID_SIZE-ID_OVERHEAD); //
        
        if(iReturnSize==-1)
        {
            pParentExtension->bBadDeviceID=TRUE;
            USBPRINT_KdPrint1 (("USBPRINT.SYS: Get1284Id Failed\n"));
            ntStatus=STATUS_NOT_SUPPORTED;
            pParentExtension->DeviceIdString[0]=0;
        } /*end if Get1284 failed*/
        else
        {
            USBPRINT_KdPrint3 (("USBPRINT.SYS: Get1284Id Succeeded\n"));
            USBPRINT_KdPrint2 (("USBPRINT.SYS: 1284 ID == %s\n",(p1284Id+2)));
            ntStatus=ParPnpGetId(p1284Id+2,BusQueryDeviceID,pParentExtension->DeviceIdString);
            

            USBPRINT_KdPrint3 (("USBPRINT.SYS: After call to ParPnpGetId"));
            if(!NT_SUCCESS(ntStatus))
            {
                iReturnSize=-1;
                USBPRINT_KdPrint1 (("USBPRINT.SYS: ParPnpGetId failed, error==%d, %u\n",ntStatus,ntStatus));
                pParentExtension->bBadDeviceID=TRUE;
            }
            else
            {
                USBPRINT_KdPrint3 (("USBPRINT.SYS: After ParPnpGetID\n"));
                USBPRINT_KdPrint2 (("USBPRINT.SYS: DeviceIdString=%s\n",pParentExtension->DeviceIdString));
            }
        } /*end if the request didn't fail*/
        ExFreePool(p1284Id);
    }
    USBPRINT_KdPrint2 (("USBPRINT.SYS: GetDeviceID exit\n"));
} /*end function USBPRINT_GetDeviceID*/


NTSTATUS ProduceQueriedID(PDEVICE_EXTENSION deviceExtension,PIO_STACK_LOCATION irpStack,PIRP Irp,PDEVICE_OBJECT DeviceObject)
{

    PDEVICE_EXTENSION pParentExtension;
    NTSTATUS ntStatus=STATUS_SUCCESS;
    WCHAR wTempString1[30];
    PWSTR pWalk;
    HANDLE hChildRegKey;
    UCHAR *pRawString,*pTempString;
    UNICODE_STRING UnicodeDeviceId;
    UNICODE_STRING uncPortValueName;
    ANSI_STRING AnsiIdString;
    PCHILD_DEVICE_EXTENSION pChildExtension;
    int iReturnSize;
    int iFirstLen,iSecondLen, iTotalLen;
    
    pChildExtension=(PCHILD_DEVICE_EXTENSION)deviceExtension;
     pParentExtension=pChildExtension->ParentDeviceObject->DeviceExtension;
    
    if(pParentExtension->bBadDeviceID==TRUE)
    {
        USBPRINT_KdPrint2(("USBPRINT.SYS:  About to error out of ProduceQueriedID with STATUS_NOT_FOUND\n"));
        
        return STATUS_NOT_FOUND;
    }
  
    pRawString=ExAllocatePool(NonPagedPool,MAX_ID_SIZE);
    pTempString=ExAllocatePool(NonPagedPool,MAX_ID_SIZE);
    if((pTempString==NULL)||(pRawString==NULL))
    {
        USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; No memory.  Failing\n"));
        ntStatus=STATUS_NO_MEMORY;
        iReturnSize=-1;
    }
    else
    {
        if(pParentExtension->DeviceIdString[0]!=0)
        {
            switch(irpStack->Parameters.QueryId.IdType)
            { 
            case BusQueryDeviceID:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryDeviceID message\n"));
                sprintf(pRawString,"USBPRINT\\%s",pParentExtension->DeviceIdString); //this sprintf safe.. DeviceIDString guaranteed to be 15 less than RawString
                USBPRINT_KdPrint2 (("USBPRINT.SYS: ID before fixup=%s\n",pRawString));
                FixupDeviceId((PUCHAR)pRawString);
                USBPRINT_KdPrint2 (("USBPRINT.SYS: ID after fixup=%s\n",pRawString));
                RtlInitAnsiString(&AnsiIdString,pRawString);
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }
                ntStatus=STATUS_SUCCESS;
                Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceId.Buffer;
                USBPRINT_KdPrint2(("USBPRINT.SYS: __________________________________returing DeviceID\n"));
                break;
                
            case BusQueryInstanceID:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryInstanceID message\n"));
                USBPRINT_KdPrint2 (("USBPRINT.SYS: returning instance %u\n",pChildExtension->ulInstanceNumber));
                sprintf(pRawString,"USB%03u",pChildExtension->ulInstanceNumber);
                USBPRINT_KdPrint2 (("USBPRINT.SYS: RawString=%s\n",pRawString));
                RtlInitAnsiString(&AnsiIdString,pRawString);
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }

                ntStatus=STATUS_SUCCESS;
                Irp->IoStatus.Information=(ULONG_PTR)UnicodeDeviceId.Buffer;
                break;
                
            case BusQueryHardwareIDs:
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Received BusQueryHardwareIDs message\n")); 
#ifndef WIN9XBUILD
                USBPRINT_KdPrint2 (("USBPRINT.SYS: inside IF NT\n"));
                ntStatus=IoOpenDeviceRegistryKey(DeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_ALL_ACCESS,&hChildRegKey);
#else
                USBPRINT_KdPrint2 (("USBPRINT.SYS: inside not NT\n")); 
               
                ntStatus=IoOpenDeviceRegistryKey(pParentExtension->PhysicalDeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_ALL_ACCESS,&hChildRegKey);
#endif
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryHardwareIDs; IoOpenDeviceRegistryKey failed\n"));
                    break;
                }
                swprintf(wTempString1,L"USB%03u",pChildExtension->ulInstanceNumber);
                RtlInitUnicodeString(&uncPortValueName,L"PortName");
                ntStatus=ZwSetValueKey(hChildRegKey,&uncPortValueName,0,REG_SZ,wTempString1,(wcslen(wTempString1)+1)*sizeof(WCHAR));
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryHardwareIDs; ZwSetValueKey failed\n"));
                }
                else
                {
                    USBPRINT_KdPrint3 (("USBPRINT.SYS: BusQueryHardwareIDs; ZwSetValueKey worked, wcslen(wTempString1)==%u\n",wcslen(wTempString1)));
                    ntStatus=STATUS_SUCCESS;
                }
                ZwClose(hChildRegKey);
                
                if(pParentExtension->DeviceIdString[0]==0)
                {
                    ntStatus=STATUS_NOT_FOUND;
                    USBPRINT_KdPrint2 (("USBPRINT.SYS: BusQueryCompatibleIDs; DeviceIdString is null.  Can't continue\n"));
                    break;
                }
                ntStatus=ParPnpGetId(pParentExtension->DeviceIdString,irpStack->Parameters.QueryId.IdType,pRawString); 
                if(!NT_SUCCESS(ntStatus))
                {
                    USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; ParPnpGetID failed\n"));
                    break;
                } 
                
                if((strlen(pRawString)+ID_OVERHEAD)*2>MAX_ID_SIZE)
                {
                  ntStatus=STATUS_NO_MEMORY;
                  USBPRINT_KdPrint1 (("USBPRINT.SYS: BusQueryDeviceIDs; ID's to long.  Failing\n"));
                  iReturnSize=-1;
                  break;
                }
                FixupDeviceId((PUCHAR)pRawString);
                sprintf(pTempString,"USBPRINT\\%s",pRawString);
                iFirstLen=strlen(pTempString);
                *(pTempString+iFirstLen)=' ';  //make the old null be a space so that RtlInitAnsiString will step past it
                *(pTempString+iFirstLen+1)='\0'; //add an extra null at the end of the string
                strcat(pTempString,pRawString);
                iTotalLen=strlen(pTempString);
#ifdef USBPRINT_LIE_ABOUT_LPT
                *(pTempString+iTotalLen)=' ';
                *(pTempString+iTotalLen+1)='\0';
                iSecondLen=iTotalLen;
                strcat(pTempString,"LPTENUM\\");
                strcat(pTempString,pRawString);
                iTotalLen=strlen(pTempString);
#endif
                *(pTempString+iTotalLen)=' ';
                *(pTempString+iTotalLen+1)='\0';
                USBPRINT_KdPrint2 (("USBPRINT.SYS: Hardware ID before fixup=%s\n",pRawString));


                USBPRINT_KdPrint2 (("USBPRINT.SYS: Hardware ID after fixup=%s\n",pRawString));

                
                RtlInitAnsiString(&AnsiIdString,pTempString);  //make a counted ansi string
                if(!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE))) //Make a unicode string out of this
                {
                  ntStatus=STATUS_NO_MEMORY;
                  iReturnSize=-1;
                  Irp->IoStatus.Information=0;
                  break;
                }
                pWalk = UnicodeDeviceId.Buffer+iFirstLen; //Set a pointer to the beginning of the string
                *pWalk=L'\0'; //set the space to be a unicode null

#ifdef USBPRINT_LIE_ABOUT_LPT
                pWalk = UnicodeDeviceId.Buffer+iSecondLen; //Set a pointer to the beginning of the string
                *pWalk=L'\0'; //set the space to be a unicode null
#endif

                pWalk = UnicodeDeviceId.Buffer+iTotalLen; //set a pointer to the space at the end of the total string
                *pWalk=L'\0';   //set the space to be a unicode null, so that we now have a double unicode null.
                Irp->IoStatus.Information = (ULONG_PTR)UnicodeDeviceId.Buffer;
                break;
                
            case BusQueryCompatibleIDs:
                Irp->IoStatus.Information = (ULONG_PTR) NULL; //(ULONG_PTR)UnicodeDeviceId.Buffer;
                break;

            default:
                ntStatus = Irp->IoStatus.Status;
            } /*end switch ID type*/
            
        }  /*end no 1284 ID*/
        else
        {
            ntStatus=STATUS_NOT_FOUND;
        }
    }
    if(pTempString!=NULL)
        ExFreePool(pTempString);
    if(pRawString!=NULL)
        ExFreePool(pRawString);
    return ntStatus;
} /*End function QueryID*/


//
//  Function: bAddPortInUseItem
// 
//  Description : iPortNumber is removed from the free ports list structure.
//  
//  Parameters: IN\OUT pFreePorts - is the beginning of the list and on return will contain the beginning of the list.
//                                  pFreePorts may change during the call.
//              IN iPortNumber - the port number that is in use.
//
//  Returns: NTSTATUS value - STATUS_NO_MEMORY
//                          - STATUS_SUCCESS
//
NTSTATUS bAddPortInUseItem(PFREE_PORTS * pFreePorts,ULONG iPortNumber )
{
    NTSTATUS ntstatus     = STATUS_SUCCESS;
    PFREE_PORTS pBefore   = *pFreePorts;
    PFREE_PORTS pHead     = *pFreePorts;
    PFREE_PORTS pNewBlock = NULL;

    USBPRINT_KdPrint2 (("  USBPRINT.SYS:  Head of bAddPortInUseItem\n"));  
    
    //
    // Traverse the FREE_PORT structure to remove the port number from the list.
    // Note - This function will not be needed to be called by anyone else other than LoadPortsUsed
    // as the GetNewPortNumber will do this functionality automatically.
    //
    while( *pFreePorts )
    {
        if( iPortNumber >= (*pFreePorts)->iBottomOfRange && iPortNumber <= (*pFreePorts)->iTopOfRange )
        {
            // We're where we want to be - so decide what to do...
            if( iPortNumber == (*pFreePorts)->iBottomOfRange )
            {
                if( (++((*pFreePorts)->iBottomOfRange)) > (*pFreePorts)->iTopOfRange )
                {
                    // Case of the Port Number being the first and only element in the first block.
                    if( *pFreePorts == pHead )
                    {
                        pHead = (*pFreePorts)->pNextBlock;
                    }
                    else    // Case of the Port Number being the first element in another block.
                    {
                        pBefore->pNextBlock = (*pFreePorts)->pNextBlock;
                    }
                    ExFreePool( *pFreePorts );
                }
            }
            else 
            {
                if( iPortNumber == (*pFreePorts)->iTopOfRange )
                {   // Deletion case handled in the above case, so just need to decrement.
                    ((*pFreePorts)->iTopOfRange)--;
                }
                else    // Otherwise we're in the middle of the block and we need to split it.
                {
                    pNewBlock = ExAllocatePoolWithTag( NonPagedPool, sizeof(FREE_PORTS), USBP_TAG);
                    if( !pNewBlock )
                    {
                        ntstatus = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    pNewBlock->iTopOfRange    = (*pFreePorts)->iTopOfRange;
                    (*pFreePorts)->iTopOfRange   = iPortNumber - 1;
                    pNewBlock->iBottomOfRange = iPortNumber + 1;
                    pNewBlock->pNextBlock     = (*pFreePorts)->pNextBlock;
                    (*pFreePorts)->pNextBlock    = pNewBlock;
                }
            }
            break;
        }
        else
        {
            if( iPortNumber < (*pFreePorts)->iBottomOfRange )
            {   // The port number has already been used - not in the free list.
                USBPRINT_KdPrint2 (("  USBPRINT.SYS:  Port number %n is allocated already from free list.\n", iPortNumber));
                break;
            }
            pBefore = *pFreePorts;
            *pFreePorts = (*pFreePorts)->pNextBlock;
        }
    }

    if( NULL == *pFreePorts )
    {
        ntstatus = STATUS_INVALID_PARAMETER;
        // Assert this as we could never allocate a port number that is not in the initial ranges 1-999 
        //     - but if we assert here, we have run off the end of the port allocation numbers.
        ASSERT( *pFreePorts );
    }

Cleanup:
    *pFreePorts = pHead;

    return ntstatus;

} /*end function bAddPortInUseItem*/


void vClaimPortNumber(ULONG ulPortNumber,HANDLE hInterfaceKey,PFREE_PORTS * pPortsUsed)
{
    UNICODE_STRING wRecycle;
    WCHAR *pName;

    pName=L"RECYCLABLE";
    RtlInitUnicodeString(&wRecycle,pName);
    #if WIN95_BUILD==1
    SetValueToZero(hInterfaceKey,&wRecycle);
    #else
    ZwDeleteValueKey(hInterfaceKey,&wRecycle);
    #endif

    // Do we need to fail out gracefully from the below?  
    // The func doesn't have a return, but we could fail a mem alloc inside the below call!!
//    bAddPortInUseItem(pPortsUsed,ulPortNumber);
} /*end function vClaimPortNumber*/


NTSTATUS GetNewPortNumber(PFREE_PORTS * pFreePorts, ULONG *pulPortNumber)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PFREE_PORTS pTemp  = *pFreePorts;

    USBPRINT_KdPrint2 (("USBPRINT.SYS: Head of GetNewPortNumber\n"));

    if( NULL == *pFreePorts )
    {
        // If the pFreePorts list is empty - try to reconstruct it.
        ntstatus=InitFreePorts(pFreePorts);
        if(NT_SUCCESS(ntstatus))
            ntstatus=LoadPortsUsed((GUID *)&USBPRINT_GUID,pFreePorts,USB_BASE_NAME);
        if( NULL == *pFreePorts && NT_SUCCESS(ntstatus))
        {
            ntstatus=STATUS_INVALID_PORT_HANDLE;    
        }

        if(!NT_SUCCESS(ntstatus)) 
        {
            *pulPortNumber = 0;
            goto Cleanup;
        }
    }

    *pulPortNumber = (*pFreePorts)->iBottomOfRange;

    if( (++((*pFreePorts)->iBottomOfRange)) > (*pFreePorts)->iTopOfRange )
    {
        // Case of the Port Number being the first and only element in the first block.
        *pFreePorts = (*pFreePorts)->pNextBlock;
        ExFreePool( pTemp );
    }

Cleanup:

    return ntstatus;

} /*end function GetNewPortNumber*/


BOOL bDeleteIfRecyclable(HANDLE hRegKey)
{
    BOOL bReturn=FALSE;
    UNICODE_STRING wcValueName;
    NTSTATUS ntStatus;
    USBPRINT_KdPrint2 (("USBPRINT.SYS:  Head of bDeleteifRecyclable\n"));
    RtlInitUnicodeString(&wcValueName,L"recyclable");
    #if WIN95_BUILD==1
    ntStatus=SetValueToZero(hRegKey,&wcValueName);
    #else
    ntStatus=ZwDeleteValueKey(hRegKey,&wcValueName);
    #endif
    if(NT_SUCCESS(ntStatus))
    {
        RtlInitUnicodeString(&wcValueName,L"Port Number");
        #if WIN95_BUILD==1
        ntStatus=SetValueToZero(hRegKey,&wcValueName);
        #else
        ntStatus=ZwDeleteValueKey(hRegKey,&wcValueName);
        #endif
        if(NT_SUCCESS(ntStatus)) 
            bReturn=TRUE;
    } // end function bDeleteIfRecyclable
    if(bReturn)
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeleteIfRecyclable, returning TRUE\n"));
    }
    else
    {
        USBPRINT_KdPrint3 (("USBPRINT.SYS: bDeleteIfRecyclable, returning FALSE\n"));
    }
    return bReturn;
} //End function bDeleteIfRecycable
   
//
// Initialises the free ports structure list.
// pHead must be NULL or a valid pointer to a FREE_PORTS structure.
//
NTSTATUS InitFreePorts( PFREE_PORTS * pHead )
{
    PFREE_PORTS pNext = *pHead;
    NTSTATUS ntstatus = STATUS_SUCCESS;

    while(pNext)
    {
        pNext = (*pHead)->pNextBlock;
        ExFreePool(*pHead);
        *pHead = pNext;
    }

    //
    // Any old list will be cleared from memory and pHead will be NULL
    //

    *pHead = ExAllocatePoolWithTag(NonPagedPool, sizeof(FREE_PORTS), USBP_TAG);
    if( *pHead )
    {
        (*pHead)->iBottomOfRange = MIN_PORT_NUMBER;
        (*pHead)->iTopOfRange = MAX_PORT_NUMBER;
        (*pHead)->pNextBlock = NULL;
    }
    else
        ntstatus = STATUS_NO_MEMORY;

    return ntstatus;
}

void ClearFreePorts( PFREE_PORTS * pHead )
{
    PFREE_PORTS pTemp = *pHead;

    while( *pHead )
    {
        *pHead = (*pHead)->pNextBlock;
        ExFreePool( pTemp );
        pTemp = *pHead;
    }
}


/********************************************************
 * SetValueToZero.  Sets and interger reg key to zero.    
 * Returns failure if reg key does not exist, or if     
 * The key already is set to zero.  Mimics ZwDeleteValueKey
 * (which is not currently avaiable on Milinium) by 
 * useing the value 0 to mean deleted
 **************************************************************/
NTSTATUS SetValueToZero(HANDLE hRegKey,PUNICODE_STRING ValueName)
{
    PKEY_VALUE_PARTIAL_INFORMATION pValueStruct;
    NTSTATUS ReturnCode;
    ULONG dwZero=0;
    ULONG ulSizeUsed;
    NTSTATUS ntStatus;
    int iValue;

    ulSizeUsed=sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG); //this is a byte to much.  Oh well
    pValueStruct=ExAllocatePool(NonPagedPool,ulSizeUsed); 
    if(pValueStruct==NULL)
    {
      USBPRINT_KdPrint1(("USBPRINT.SYS: SetValueToZero; Unable to allocate memory\n"));
      return STATUS_NO_MEMORY;
     
    }
    ntStatus=ZwQueryValueKey(hRegKey,ValueName,KeyValuePartialInformation,pValueStruct,ulSizeUsed,&ulSizeUsed);
    if(!NT_SUCCESS(ntStatus))
    {
	  USBPRINT_KdPrint3(("Failed to Query value Key\n"));
      ExFreePool(pValueStruct);
      return STATUS_OBJECT_NAME_NOT_FOUND;
    }
    iValue=(int)*((ULONG *)(pValueStruct->Data));
    ExFreePool(pValueStruct);
    if(iValue==0)
        return STATUS_OBJECT_NAME_NOT_FOUND;

    //if we make it to here, the value exists, and is nonzero
    ReturnCode=ZwSetValueKey(hRegKey,ValueName,0,REG_DWORD,&dwZero,sizeof(dwZero));
    return ReturnCode;
} /*end function SetValueToZero*/

VOID
USBPRINT_FdoIdleNotificationCallback(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when it is time to idle out USB printer


--*/
{
    POWER_STATE 	powerState;
    NTSTATUS 		ntStatus;

    USBPRINT_KdPrint1(("USB Printer (%08X) going idle\n", DevExt));

    if(!DevExt->AcceptingRequests ||  DevExt->OpenCnt) 
    {

        // Don't idle this printer if the printer is not accepting requests

        USBPRINT_KdPrint1(("USB Printer (%08X) not accepting requests, abort idle\n", DevExt));
        return;
    }


    powerState.DeviceState = DevExt->DeviceWake;

	// request new device power state, wait wake Irp will be posted on request
    PoRequestPowerIrp(DevExt->PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // USBPRINT_FdoIdleNotificationCallback


NTSTATUS
USBPRINT_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION DevExt
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the USB printer device

--*/
{
    NTSTATUS 					ntStatus;
    PUSB_IDLE_CALLBACK_INFO 	idleCallbackInfo;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    USBPRINT_KdPrint1(("Idle notification IRP for USB Printer (%08X) completed (%08X)\n",
            DevExt, Irp->IoStatus.Status));

	// save completion status in device extension
    idleCallbackInfo 			= DevExt->IdleCallbackInfo;
    DevExt->IdleCallbackInfo 	= NULL;
    DevExt->PendingIdleIrp 		= NULL;

	// free up callback info
    if(idleCallbackInfo) 
    {
        ExFreePool(idleCallbackInfo);
    }

    ntStatus = Irp->IoStatus.Status;

    return ntStatus;
} // USBPRINT_FdoIdleNotificationRequestComplete


NTSTATUS
USBPRINT_FdoSubmitIdleRequestIrp(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

    Called when all handles to the USB printer are closed. This function allocates 
    an idle request IOCTL IRP and passes it to the parent's PDO.

--*/
{
    PIRP 					irp = NULL;
    NTSTATUS 				ntStatus = STATUS_SUCCESS;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo = NULL;

    USBPRINT_KdPrint1(("USBPRINT_FdoSubmitIdleRequestIrp (%08X)\n", DevExt));

    // if we have an Irp pending, don't bother to send another
    if(DevExt->PendingIdleIrp || DevExt->CurrentDevicePowerState == DevExt->DeviceWake)
        return ntStatus;

    idleCallbackInfo = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(struct _USB_IDLE_CALLBACK_INFO), USBP_TAG);

    if (idleCallbackInfo) 
    {

        idleCallbackInfo->IdleCallback 	= USBPRINT_FdoIdleNotificationCallback;
        idleCallbackInfo->IdleContext 	= (PVOID)DevExt;

        DevExt->IdleCallbackInfo = idleCallbackInfo;

        irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION,
                DevExt->PhysicalDeviceObject,
                idleCallbackInfo,
                sizeof(struct _USB_IDLE_CALLBACK_INFO),
                NULL,
                0,
                TRUE, /* INTERNAL */
                NULL,
                NULL);

        if (irp == NULL) 
        {
        
            ExFreePool(idleCallbackInfo);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoSetCompletionRoutine(irp,
                               USBPRINT_FdoIdleNotificationRequestComplete,
                               DevExt,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(DevExt->PhysicalDeviceObject, irp);

        if(ntStatus == STATUS_PENDING) 
        {
            // Successfully posted an Idle IRP.

            DevExt->PendingIdleIrp 	= irp;
        }
    }

    return ntStatus;
} // USBPRINT_FdoSubmitIdleRequestIrp

VOID
USBPRINT_FdoRequestWake(IN PDEVICE_EXTENSION DevExt)
/*++

Routine Description:

	Called when we want to wake up the device after an idle request

--*/
{
    POWER_STATE 	powerState;
    KIRQL OldIrql;
    BOOL bExit=FALSE;

    USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) waking up\n", DevExt));

    KeAcquireSpinLock(&(DevExt->WakeSpinLock),&OldIrql);
    if(!DevExt->AcceptingRequests || DevExt->CurrentDevicePowerState == PowerDeviceD0 || DevExt->bD0IrpPending) 
    {

        // Don't wake this printer if it's not accepting requests or we're already at power state D0
        if(!DevExt->AcceptingRequests)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) not accepting requests, abort wake\n", DevExt));
        if(DevExt->CurrentDevicePowerState == PowerDeviceD0)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) already at D0, abort wake\n", DevExt));
        if(DevExt->bD0IrpPending == TRUE)
          USBPRINT_KdPrint1(("USBPRINT: USB Printer (%08X) already has D0 irp pending, abort wake\n", DevExt));
        bExit=TRUE;
    }
    else
      DevExt->bD0IrpPending=TRUE;  
    KeReleaseSpinLock(&(DevExt->WakeSpinLock),OldIrql);
    if(bExit)
        return;



    
    powerState.DeviceState = PowerDeviceD0;

	// request new device power state, wake up the device

 
    PoRequestPowerIrp(DevExt->PhysicalDeviceObject,
                      IRP_MN_SET_POWER,
                      powerState,
                      NULL,
                      NULL,
                      NULL);

} // USBPRINT_FdoRequestWake


void vOpenLogFile(HANDLE *pHandle)
{
    NTSTATUS ntStatus;
    OBJECT_ATTRIBUTES FileAttributes;
    IO_STATUS_BLOCK StatusBlock;
    UNICODE_STRING PathName;

    RtlInitUnicodeString(&PathName,L"\\??\\C:\\USBPRINT.LOG");

    InitializeObjectAttributes(&FileAttributes,&PathName,0,NULL,NULL);
    ntStatus=ZwCreateFile(pHandle,
                          GENERIC_WRITE,
                          &FileAttributes,
                          &StatusBlock,
                          0,
                          0,
                          FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE|FILE_WRITE_THROUGH|FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);
    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1(("USBPRINT: Unable to open C:\\USBPRINT.LOG"));
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT: Opened logfile C:\\USBPRINT.LOG")); /*dd*/
    }
}


void vWriteToLogFile(HANDLE *pHandle,IN CHAR *pszString)
{
    HANDLE hFileHandle;
    ULONG BufferSize;
    NTSTATUS ntStatus;
    IO_STATUS_BLOCK StatusBlock;
    LARGE_INTEGER WriteOffset;

    WriteOffset.LowPart=FILE_WRITE_TO_END_OF_FILE;
    WriteOffset.HighPart=-1;
    
    BufferSize=strlen(pszString);
    ntStatus=ZwWriteFile(*pHandle,
                         NULL,
                         NULL,
                         NULL,
                         &StatusBlock,
                         pszString,
                         BufferSize,
                         &WriteOffset,
                         NULL);

    if(!NT_SUCCESS(ntStatus))
    {
        USBPRINT_KdPrint1(("USBPRINT: Unable to write to log file C:\\USBPRINT.LOG"));
    }
    else
    {
        USBPRINT_KdPrint1(("USBPRINT: write to log file C:\\USBPRINT.LOG")); /*dd*/
    }
} /*end function vWriteToLog*/


void vCloseLogFile(IN HANDLE *pHandle)
{
  ZwClose(*pHandle);
} /*end function vCloseLogFile*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
            VERBOSE(DLLTEXT("pOEMDevOut before setting default values:\r\n"));
            Dump(pOEMDevOut);
			
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;
	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\intrface.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\intrface.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemUI:No Interface. Return NULL.\r\n")); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//(Implamentation is required) Supplies a pointer to UNIDRIVE /PScript IPrintOemDriverUI
//
HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

//
//(Implamentation is required) Returns the UI Plugin's identification information
//
HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}


//
//Performs operation on UI Plugins Private DevMode Members.
//
HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}


//
//Allows UI Plugin to Modifiy Existing printer porp sheet and document property sheet page..
//
HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


//
//Adds a New page to the device Documment property sheet.
//

HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

//
//Adds a New page to the device printer property page.
//
HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}


//
//Allows the UI plugin to spec Customized device capabilaties (TODO)
//
HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));
	
    return E_NOTIMPL;
}


//
//Allows the UI plugin to help determine if a print Job is printable.
//
HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}


//
//Allows the UI Plugin to upgrade its dev options stored in the registry.
//
HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                lstrcpynW((LPWSTR)pvProfileData, PROFILE_NAME, *pcbProfileData);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                Result = S_OK;
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 95, Windows NT
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static BOOL AddCustomUIHelp (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, POPTITEM pOptItem, DWORD HelpIndex, DWORD HelpFile);
static POIEXT CreateOIExt(HANDLE hHeap);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetHelpFile (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, UINT uResource);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);
LPBYTE WrapGetPrinterDriver (HANDLE hHeap, HANDLE hPrinter, DWORD dwLevel);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
// Called via IOemUI::CommonUIProp
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;
        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);
		
		//
		//Setup the Optional Item
		//
        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;

		
		//
		//Allows You to apply Customised help to this Control.
		//
		//Notes:
		//	You must use a fully qualified path for pHelpFile
		//	OPTITEM Flags member must have OPTIF_HAS_POIEXT flag set. This indicates that the data in OIEXT is valid.
		//	OPTITEM is allocated on the Heap see (AddCustomUIHelp, GetHelpFile, CreateOIExt)
		//
		AddCustomUIHelp (pOEMUIParam->hPrinter,
						 pOEMUIParam->hOEMHeap,
						 pOEMUIParam->hModule,
						 &(pOEMUIParam->pOEMOptItems[0]),
						 CUSDRV_HELPTOPIC_2, IDS_HELPFILE);
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
		//
		//This is the second time we are called Now setup the optional items.
		//
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

		//
		//Setup the Optional Item
		//
	    pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;	
		
		//
		//Allows You to apply Customised help to this Control
		//
		AddCustomUIHelp (pOEMUIParam->hPrinter,
						 pOEMUIParam->hOEMHeap, 
						 pOEMUIParam->hModule, 
						 &(pOEMUIParam->pOEMOptItems[0]), 
						 CUSDRV_HELPTOPIC_1, 
						 IDS_HELPFILE);
    }
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet. Called via IOemUI::DocumentPropertySheets
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap = pOEMUIParam->hOEMHeap;
				HANDLE          hModule = pOEMUIParam->hModule;
                POEMDEV         pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize = sizeof(COMPROPSHEETUI);
                Sheet.Flags = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller = ghInstance;
                Sheet.pCallerName = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile = NULL;
                Sheet.pfnCallBack = OEMDocUICallBack;
                Sheet.pDlgPage = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem = 1;
                Sheet.IconID = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion = 0x100;
                Sheet.OptItemVersion = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam = pOEMUIParam;
                Sheet.UserData = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel = pOEMDev->dwDriverData;
								
                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);
				
				//
				//Set the UI prop of this OPTYPE item.
				//
				Sheet.pOptItem[0].pOptType->Type = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;

				//
				//Allows You to apply Customised help to this Control.
				//See Function : AddCustomUIHelp, For more details on implamentation.
				//
				AddCustomUIHelp (pOEMUIParam->hPrinter,
								 hHeap, 
								 hModule, 
								 &(Sheet.pOptItem[0]), 
								 CUSDRV_HELPTOPIC_1, 
								 IDS_HELPFILE);
                
                // Adds the  property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet. Called via IOemUI::DevicePropertySheets
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;
            pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
            pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
// Adds Custom help top a OPTTYPE UI item.
//
// Note :
//	The OPTITEM member HelpIndex must be set the the correct HELP ID number.
//		HelpIndex is the index that you assigned in the hlp file to this item of help.	
//	The OPTITEM, pOIExt member must point to a valid OIEXT structure.
//	The phelpfile is member of OIEXT must have the fully qualified path to the driver file.
//
//
//  It is also possible to overide common help items in UNIDRIVE via the HelpIndex in the GPD.
//  For further information on using HelpIndex in the GPD see the relavent section in the DDK
//  It is not possible to custimse help however via the PPD. The OPTITEM must be modified in the OEM Plugin.
//
static BOOL AddCustomUIHelp (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, 
							 POPTITEM pOptItem, DWORD HelpIndex, DWORD HelpFile)
{
	
	VERBOSE(DLLTEXT("AddCustomUIHelp() entry.\r\n"));
	POIEXT pOIExt = NULL;

	//
	//Allocate a new OIEXT structure on the heap
	//
	if (pOptItem->pOIExt == NULL)
	{
		pOptItem->pOIExt = CreateOIExt(hHeap);
	}

	if ( pOptItem->pOIExt == NULL )
	{
		ERR(ERRORTEXT("AddCustomUIHelp() Error Allocation Failed.\r\n"));
		return FALSE;
	}

	pOIExt = pOptItem->pOIExt;

	//
	//Set to the full absolute path of the driver file. 
	//(It should be in the Printer Driver Directrory in most cases)
	//This String needs to be allocated on the heap (The Driver will clean it up).
	//
	pOIExt->pHelpFile = GetHelpFile (hPrinter, hHeap, hModule, HelpFile);
			
	//
	//Set to show tha there is a valid OIEXT structure and data
	//
	pOptItem->Flags |= OPTIF_HAS_POIEXT;

	//
	//This needs to be set if you have ansi strings in your help file. (NOTE!)
	//
	//pOiExt->Flags |= OIEXTF_ANSI_STRING;

	//
	//Add the help this the index in the .hlp file.
	//
	pOptItem->HelpIndex = HelpIndex;

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OIEXT for OptItem.
//
static POIEXT CreateOIExt(HANDLE hHeap)
{

	POIEXT pOiExt = NULL;
	
	VERBOSE(DLLTEXT("CreateOIExt() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOiExt = (POIEXT) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OIEXT));
    if(NULL != pOiExt)
    {
		//
		// Initialize OPTTYPE. (These members are setup by AddCustomUIHelp)
		//
        pOiExt->cbSize = sizeof(OIEXT);
		pOiExt->Flags = 0;
        pOiExt->hInstCaller = NULL;
		pOiExt->pHelpFile = NULL;
	}

	return pOiExt;
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates space on the heap and gets the help file name from the resource file.
// Note you need to allocate this on the heap so that it stays allocated as long as the driver UI is loaded.
// The OPTITEM->pOIExt ref this data.
//
static PTSTR GetHelpFile (HANDLE hPrinter, HANDLE hHeap, HANDLE hModule, UINT uResource)
{	
	
	DWORD   nResult = 0;
    DWORD   dwSize = MAX_PATH;
	PTSTR   pszString  = NULL;
	PTSTR   pszTemp    = NULL;
	PDRIVER_INFO_2 pDriverInfo = NULL;
	
	VERBOSE(DLLTEXT("GetHelpFile (%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);
	
	//
	// Allocate buffer for string resource from heap;
	//
    pszTemp = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
	pDriverInfo = (PDRIVER_INFO_2)WrapGetPrinterDriver (hHeap, hPrinter, 2);

	//
	//Get the Full Driver Dir from pDriverPath it must include the \version\ 
	//
    if(NULL != pszTemp && pDriverInfo && pDriverInfo->pDriverPath)
	{	
		_tcsncpy (pszTemp, pDriverInfo->pDriverPath, dwSize);
		pszString = _tcsrchr (pszTemp, _T('\\') ) + 1;
	}

	//
	//The Help file is installed with the driver in the version drictory.
	//
	if(NULL != pszString)
    {
		//
		//The Buffer size is in characters for the unicode version of LoadString
		//
		nResult = LoadString((HMODULE)hModule, uResource, pszString, (dwSize - _tcslen(pszString)) );
	}
	else
	{
		ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
	}

	if(nResult > 0)
	{
		//
		//Reallocate this so that we don't waist space on the heap (free any non used heap in MAX_PATH)
		//
		pszString = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszTemp, (_tcslen(pszTemp) + 1) * sizeof(TCHAR));
		if(NULL == pszString)
		{
			pszTemp = pszString;
			ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
		}
	}
	else
	{
		ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
		ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);
		pszString = NULL;
	}
	
	//
	//Clean up the Driverinfo that was allocated. It is not needed. (Always free this it is only temp data)
	//
	if (pDriverInfo)
	{
		HeapFree(hHeap, 0, pDriverInfo);
	}
	
	return pszString;
}	

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Wrapper to help retrive the PrinterDriverInfo, 
//  Note the MEM is orphaned by this call on success
//

LPBYTE WrapGetPrinterDriver (HANDLE hHeap, HANDLE hPrinter, DWORD dwLevel)
{
	//
	//Get the PrinterINFO so that we know where the driver help file is.
	//
	BOOL    bGet        = TRUE;
    DWORD   dwSize      = 0;
    DWORD   dwNeeded    = 0;
    DWORD   dwError     = ERROR_SUCCESS;
    DWORD   dwLoop      = 0;
	LPBYTE  pBuffer		= NULL;

    do
    {
        if(!bGet && (dwError == ERROR_INSUFFICIENT_BUFFER ) )
        {
            dwSize += dwNeeded;

			if (pBuffer)
			{
				pBuffer = (LPBYTE)HeapReAlloc (hHeap, HEAP_ZERO_MEMORY, (LPVOID)pBuffer, dwNeeded);
			}
			else
			{
				pBuffer = (LPBYTE)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, dwNeeded);
			}
		}

        bGet = GetPrinterDriver(hPrinter, NULL, dwLevel, pBuffer, dwSize, &dwNeeded);
        dwError = GetLastError();

    } while (!bGet && (dwLoop++ < 4));

    if(!bGet)
    {
        if (pBuffer)
		{
			HeapFree(hHeap, 0, pBuffer);
			pBuffer = NULL;
		}
		ERR(ERRORTEXT("GetPrinterDriver(%p, %d, %p, %d) failed with error %d."), 
               hPrinter, dwLevel, pBuffer, dwError);
    }

	return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by customui.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_HELPFILE                    4
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"

////////////////////////////////////////////////////////
//		Custom Help Defines
////////////////////////////////////////////////////////
#define CUSDRV_HELPTOPIC_1 15001
#define CUSDRV_HELPTOPIC_2 15002


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")


////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\custhlp\customhelp\customdrv.h ===
//
//
//
//
//////////////////////////////////////////////////////////////////

#define CUSDRV_HELPTOPIC_1 = 15001
#define CUSDRV_HELPTOPIC_2 = 15002
#define CUSDRV_HELPTOPIC_3 = 15003
#define CUSDRV_HELPTOPIC_4 = 15004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\ddint5.h ===
/*++

Copyright (c) 1996 - 2000  Microsoft Corporation

Module Name:

    ddint5.h

Abstract:

    Common header file for NT 4.0 specific declarations for porting unidrv to
    NT 4.0.

Environment:

    Windows NT printer drivers


--*/

#ifndef _DDINT5_H_
#define _DDINT5_H_

#ifdef WINNT_40

typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;

#define GCAPS_ARBRUSHTEXT       0x10000000
#define GCAPS_SCREENPRECISION   0x20000000
#define GCAPS_FONT_RASTERIZER   0x40000000

#if defined(_X86_) && !defined(USERMODE_DRIVER)

//
// x86 does not support floating-point instruction in the kernel mode,
// the floating-point data would like be handled 32bits value as double words.
//
typedef DWORD FLOATL;
#else
//
// Any platform that has support for floats in the kernel
//
typedef FLOAT FLOATL;
#endif // _X86_

#define atoi        iDrvAtoi
#define strncpy     pchDrvStrncpy

int    __cdecl  iDrvAtoi(const char *);
char *  __cdecl pchDrvStrncpy(char *, const char *, size_t);

#endif //WINNT_40

#endif // _DDINT5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\minidrv.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    minidrv.h

Abstract:

    Common header file for Plug-in minidrivers.

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MINIDRV_H_
#define _MINIDRV_H_

#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

//
// defined(KERNEL_MODE) Rendering module DLL in either kernel mode or user mode.
// defined(KERNEL_MODE) & defined(USERMODE_DRIVER) User mode rendering DLL
// !defined(KERNEL_MODE) UI module
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
// Kernel mode rendering DLL
#include "winsplkm.h"
#else
// User mode DLL
#include <winspool.h>
#endif

#if !defined(KERNEL_MODE)
// UI DLL
#include <windows.h>
#include <compstui.h>
#include <winddiui.h>
#endif

#if defined(USERMODE_DRIVER) || !defined(KERNEL_MODE)
// UI DLL or User mode rendering DLL
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef WINNT_40
//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef int INT_PTR, *PINT_PTR;
typedef unsigned int UINT_PTR, *PUINT_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;


#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p )    ((ULONG) (p) )
#define PtrToLong( p )     ((LONG) (p) )
#define PtrToUshort( p )   ((unsigned short) (p) )
#define PtrToShort( p )    ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define DWLP_MSGRESULT      0
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#endif // WINNT_40

#include <printoem.h>
#include <prntfont.h>

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__                 // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG


//
// Memory allocation function macros
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// DBCS CharSet handling macros
//
//
// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
    ((j) == HANGEUL_CHARSET)     || \
    ((j) == JOHAB_CHARSET)       || \
    ((j) == GB2312_CHARSET)      || \
    ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (Taiwan, Hong Kong S.A.R.)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
    ((j) == 936)   || \
    ((j) == 949)   || \
    ((j) == 950)   || \
    ((j) == 1361))


//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262

#ifdef __cplusplus
}
#endif

#endif //_MINIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\p64_nt4.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    p64_nt4.h

Abstract:

    P64 Type Definitions for NT4. (This header file is
    used so our NT5 source tree can be compiled for NT4.)

--*/

#ifndef _P64_NT4_H_
#define _P64_NT4_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
// the unsigned variation.
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

typedef int INT_PTR, *PINT_PTR;

#define HandleToUlong( h ) ((ULONG) (h) )
#define PtrToUlong( p ) ((ULONG) (p) )
#define PtrToLong( p ) ((LONG) (p) )
#define PtrToUshort( p ) ((unsigned short) (p) )
#define PtrToShort( p ) ((short) (p) )

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#ifdef __cplusplus
}
#endif

#endif // _P64_NT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\prcomoem.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/


#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_


//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;


};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helpder function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//


#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};


//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{

    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // Unidrv specific XMoveTo and YMoveTo. Returns E_NOT_IMPL in Pscript
    //

    STDMETHOD(DrvXMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         x,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;

    STDMETHOD(DrvYMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         y,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;
    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHOD(DrvGetStandardVariable)(THIS_     PDEVOBJ     pdevobj,
                                                DWORD       dwIndex,
                                                PVOID       pBuffer,
                                                DWORD       cbSize,
                                                PDWORD      pcbNeeded) PURE;

//
// Unidrv specific.  To Provide OEM plugins access to GPD data.
//


    STDMETHOD (DrvGetGPDData)(THIS_  PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    ) PURE;


    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHOD(DrvUniTextOut)(THIS_    SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlBrushOrg,
                                            MIX         mix) PURE;

    //
    //   Warning!!!  new method!!  must place at end of
    //   interface - else major incompatibility with previous oem plugins
    //

    STDMETHOD(DrvWriteAbortBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            DWORD       dwWait  //  pause data transmission for this many millisecs.
                                            ) PURE;


};

#endif  // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRCOMOEM_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\printoem.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    printoem.h

Abstract:

    Declarations for Windows NT printer driver OEM plugins

--*/


#ifndef _PRINTOEM_
#define _PRINTOEM_

#ifdef __cplusplus
extern "C" {
#endif

//
// Current OEM plugin interface version number
//

#define PRINTER_OEMINTF_VERSION 0x00010000

#define OEM_MODE_PUBLISHER     0x00000001

typedef struct _PUBLISHERINFO {

    DWORD dwMode;           // flags for publisher
    WORD  wMinoutlinePPEM;  // min size to download as Type1
    WORD  wMaxbitmapPPEM;   // max size to download as Type3

} PUBLISHERINFO, *PPUBLISHERINFO;

#define OEMGI_GETSIGNATURE        1
#define OEMGI_GETINTERFACEVERSION 2
#define OEMGI_GETVERSION          3
#define OEMGI_GETPUBLISHERINFO    4

//
// OEMGetInfo
//
BOOL APIENTRY
OEMGetInfo(
    IN  DWORD  dwMode,
    OUT PVOID  pBuffer,
    IN  DWORD  cbSize,
    OUT PDWORD pcbNeeded
    );

BOOL APIENTRY
OEMDriverDMS(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );


//
// OEMDevMode
//

#define OEMDM_SIZE     1
#define OEMDM_DEFAULT  2
#define OEMDM_CONVERT  3
#define OEMDM_MERGE    4

typedef struct _OEMDMPARAM {

    DWORD    cbSize;        // size of OEM_DEVMODEPARAM
    PVOID    pdriverobj;    // reference to driver data structure
    HANDLE   hPrinter;      // PRINTER handle
    HANDLE   hModule;       // OEM module handle
    PDEVMODE pPublicDMIn;   // public devmode in
    PDEVMODE pPublicDMOut;  // public devmode out
    PVOID    pOEMDMIn;      // OEM private devmode in
    PVOID    pOEMDMOut;     // OEM private devmode out
    DWORD    cbBufSize;     // output size of pOEMDMOut buffer

} OEMDMPARAM, *POEMDMPARAM;

typedef struct _OEM_DMEXTRAHEADER {

    DWORD   dwSize;         // size of OEM extra data
    DWORD   dwSignature;    // Unique OEM signature
    DWORD   dwVersion;      // OEM DLL version number

} OEM_DMEXTRAHEADER, *POEM_DMEXTRAHEADER;

//
// USERDATA for OPTITEM.UserData
//

typedef struct _USERDATA {

    DWORD       dwSize;                 // Size of this structure
    ULONG_PTR    dwItemID;               // XXX_ITEM or pointer to FEATURE
    PSTR        pKeyWordName;           // Keyword name
    DWORD       dwReserved[8];
} USERDATA, *PUSERDATA;


BOOL APIENTRY
OEMDevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// Callback function provided by the driver to
// allow OEM plugins access/set/update to driver private settings
//

typedef BOOL (APIENTRY *PFN_DrvGetDriverSetting)(
        PVOID   pdriverobj,
        PCSTR   Feature,
        PVOID   pOutput,
        DWORD   cbSize,
        PDWORD  pcbNeeded,
        PDWORD  pdwOptionsReturned
        );

//
// Callback function provided by the driver to
// allow OEM plugins upgrade private registry settings. This
// function is called only at OEMDrvUpgradeDriver
//

typedef BOOL (APIENTRY *PFN_DrvUpgradeRegistrySetting)(
        HANDLE   hPrinter,
        PCSTR    pFeature,
        PCSTR    pOption
        );

//
// Callback function provided by the driver UI to
// allow OEM plugins to update the driver UI settings and
// shows constraint. This function is called only when the UI is present.
//

typedef BOOL (APIENTRY *PFN_DrvUpdateUISetting)(
        PVOID    pdriverobj,
        PVOID    pOptItem,
        DWORD    dwPreviousSelection,
        DWORD    dwMode
        );



// Predefined feature indices used for accessing driver private settings

#define OEMGDS_MIN_DOCSTICKY        1
#define OEMGDS_PSDM_FLAGS           1       // DWORD - misc. flag bits
#define OEMGDS_PSDM_DIALECT         2       // INT - PS output option
#define OEMGDS_PSDM_TTDLFMT         3       // INT - TrueType font downloading option
#define OEMGDS_PSDM_NUP             4       // INT - N-up option
#define OEMGDS_PSDM_PSLEVEL         5       // INT - target language level
#define OEMGDS_PSDM_CUSTOMSIZE      6       // 5*DWORD - custom page size parameters

#define OEMGDS_UNIDM_GPDVER         0x4000  // WORD - GPD Version
#define OEMGDS_UNIDM_FLAGS          0x4001  // DWORD - misc flag bits

// Indices for private devmode fields - start at 0x4000

#define OEMGDS_MIN_PRINTERSTICKY    0x8000
#define OEMGDS_PRINTFLAGS           0x8000  // DWORD - misc. flag bits
#define OEMGDS_FREEMEM              0x8001  // DWORD - amount of VM, ps only
#define OEMGDS_JOBTIMEOUT           0x8002  // DWORD - job timeout, ps only
#define OEMGDS_WAITTIMEOUT          0x8003  // DWORD - wait timeout, ps only
#define OEMGDS_PROTOCOL             0x8004  // WORD - output protocol, ps only
#define OEMGDS_MINOUTLINE           0x8005  // WORD - min outline font size, ps only
#define OEMGDS_MAXBITMAP            0x8006  // WORD - max bitmap font size, ps only

#define OEMGDS_MAX                  0x10000


//   dwType  flags for use with     STDMETHOD (DrvGetGPDData)
#define         GPD_OEMCUSTOMDATA       1


/*******************************************************************************
 *
 * Definitions used by kernel-mode rendering module only:
 *  Make sure the macro KERNEL_MODE is defined and
 *  the header file winddi.h is included before this file.
 */

#ifdef KERNEL_MODE

//
// OEMEnableDriver
//

BOOL APIENTRY
OEMEnableDriver(
    DWORD           dwOemIntfVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef struct _DEVOBJ *PDEVOBJ;
typedef PVOID PDEVOEM;

typedef DWORD (APIENTRY *PFN_DrvWriteSpoolBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize
    );

typedef DWORD (APIENTRY *PFN_DrvWriteAbortBuf)(
    PDEVOBJ pdevobj,
    PVOID   pBuffer,
    DWORD   cbSize,
    DWORD       dwWait

    );

typedef INT (APIENTRY *PFN_DrvXMoveTo)(
    PDEVOBJ pdevobj,
    INT     x,
    DWORD   dwFlags
    );

typedef INT (APIENTRY *PFN_DrvYMoveTo)(
    PDEVOBJ pdevobj,
    INT     y,
    DWORD   dwFlags
    );

typedef BOOL (APIENTRY *PFN_DrvGetStandardVariable)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );

typedef enum _STDVARIABLEINDEX{

        SVI_NUMDATABYTES,          // "NumOfDataBytes"
        SVI_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SVI_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SVI_COPIES,                // "NumOfCopies"
        SVI_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SVI_DESTX,                 // "DestX"
        SVI_DESTY,                 // "DestY"
        SVI_DESTXREL,              // "DestXRel"
        SVI_DESTYREL,              // "DestYRel"
        SVI_LINEFEEDSPACING,       // "LinefeedSpacing"
        SVI_RECTXSIZE,             // "RectXSize"
        SVI_RECTYSIZE,             // "RectYSize"
        SVI_GRAYPERCENT,           // "GrayPercentage"
        SVI_NEXTFONTID,            // "NextFontID"
        SVI_NEXTGLYPH,             // "NextGlyph"
        SVI_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SVI_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SVI_FONTHEIGHT,            // "FontHeight"
        SVI_FONTWIDTH,             // "FontWidth"
        SVI_FONTMAXWIDTH,             // "FontMaxWidth"
        SVI_FONTBOLD,              // "FontBold"
        SVI_FONTITALIC,            // "FontItalic"
        SVI_FONTUNDERLINE,         // "FontUnderline"
        SVI_FONTSTRIKETHRU,        // "FontStrikeThru"
        SVI_CURRENTFONTID,         // "CurrentFontID"
        SVI_TEXTYRES,              // "TextYRes"
        SVI_TEXTXRES,              // "TextXRes"
// #ifdef  BETA2
        SVI_GRAPHICSYRES,              // "GraphicsYRes"
        SVI_GRAPHICSXRES,              // "GraphicsXRes"
// #endif
        SVI_ROP3,                  // "Rop3"
        SVI_REDVALUE,              // "RedValue"
        SVI_GREENVALUE,            // "GreenValue"
        SVI_BLUEVALUE,             // "BlueValue"
        SVI_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SVI_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SVI_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SVI_PATTERNBRUSH_ID,       // "PatternBrushID"
        SVI_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SVI_CURSORORIGINX,           //  "CursorOriginX"
        SVI_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin

        SVI_MAX             //  Just a placeholder do not use.
}STDVARIABLEINDEX;






typedef BOOL (APIENTRY *PFN_DrvUnidriverTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

//
// bit fields defined for dwFlags
//
// Note:  The following Bit values are reserved for an internal use!
//  0x4000
//  0x8000 
// 
//
#define MV_UPDATE       0x0001
#define MV_RELATIVE     0x0002
#define MV_GRAPHICS     0x0004
#define MV_PHYSICAL     0x0008
#define MV_SENDXMOVECMD     0x0010
#define MV_SENDYMOVECMD     0x0020

typedef struct _DRVPROCS {

    PFN_DrvWriteSpoolBuf    DrvWriteSpoolBuf;   // common to both pscript and unidrv
    PFN_DrvXMoveTo          DrvXMoveTo;         // unidrv specific
    PFN_DrvYMoveTo          DrvYMoveTo;         // unidrv specific
    PFN_DrvGetDriverSetting DrvGetDriverSetting;// common to both pscript and unidrv
    PFN_DrvGetStandardVariable BGetStandardVariable; // unidrv specific
    PFN_DrvUnidriverTextOut    DrvUnidriverTextOut;  // unidrv specific
    PFN_DrvWriteAbortBuf    DrvWriteAbortBuf;   // unidrv specific

} DRVPROCS, *PDRVPROCS;

typedef struct _DEVOBJ {

    DWORD       dwSize;       // size of DEVOBJ structure
    PDEVOEM     pdevOEM;      // pointer to OEM's device data
    HANDLE      hEngine;      // GDI handle for current printer
    HANDLE      hPrinter;     // spooler handle for current printer
    HANDLE      hOEM;         // handle to OEM dll
    PDEVMODE    pPublicDM;    // public devmode
    PVOID       pOEMDM;       // OEM private devmode
    PDRVPROCS   pDrvProcs;    // pointer to kernel mode helper function table

} DEVOBJ;

//
// OEMDisableDriver
//

VOID APIENTRY
OEMDisableDriver(
    VOID
    );

//
// OEMEnablePDEV
//

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

//
// OEMDisablePDEV
//

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj
    );

//
// OEMResetPDEV
//

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

//
// OEMCommand - PSCRIPT only
//

DWORD APIENTRY
OEMCommand(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

//
// OEMImageProcessing - UNIDRV only
//

typedef struct {
    DWORD dwSize;
    POINT ptOffset;
    PSTR  pHalftoneOption;
    BOOL  bBanding;
    BOOL  bBlankBand;
} IPPARAMS, *PIPPARAMS;

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

//
// OEMFilterGraphics - UNIDRV only
//

BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

//
// OEMCompression - UNIDRV only
//
INT APIENTRY
OEMCompression(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

//
// OEMHalftone - UNIDRV only
//

BOOL APIENTRY
OEMHalftonePattern(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

//
// OEMMemoryUsage - UNIDRV only
//

typedef struct {
    DWORD   dwFixedMemoryUsage;
    DWORD   dwPercentMemoryUsage;
    DWORD   dwMaxBandSize;
} OEMMEMORYUSAGE, *POEMMEMORYUSAGE;

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//
INT APIENTRY
OEMTTYGetInfo(
    PDEVOBJ pdevobj,
    DWORD   dwInfoIndex,
    PVOID   pOutputBuf,
    DWORD   dwSize,
    DWORD   *pcbcNeeded
    );

#define OEMTTY_INFO_MARGINS     1
#define OEMTTY_INFO_CODEPAGE    2
#define OEMTTY_INFO_NUM_UFMS    3
#define OEMTTY_INFO_UFM_IDS     4

//
// UNIDRV font callback
//

typedef BOOL (*PFNGETINFO)(struct _UNIFONTOBJ*, DWORD, PVOID, DWORD, PDWORD);

typedef struct _UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;     // General flags
    IFIMETRICS *pIFIMetrics; // Pointer to IFIMETRICS
    PFNGETINFO  pfnGetInfo;  // Pointer to UNIFONTOBJ_GetInfo callback
} UNIFONTOBJ, *PUNIFONTOBJ;

//
// UNIFONTOBJ.dwFlags
//

#define UFOFLAG_TTFONT               0x00000001
#define UFOFLAG_TTDOWNLOAD_BITMAP    0x00000002
#define UFOFLAG_TTDOWNLOAD_TTOUTLINE 0x00000004

//
// UNIFONTOBJ callback ID
//

#define UFO_GETINFO_FONTOBJ     1
#define UFO_GETINFO_GLYPHSTRING 2
#define UFO_GETINFO_GLYPHBITMAP 3
#define UFO_GETINFO_GLYPHWIDTH  4
#define UFO_GETINFO_MEMORY      5
#define UFO_GETINFO_STDVARIABLE 6

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_FONTOBJ {
    DWORD    dwSize;   // Size of this structure
    FONTOBJ *pFontObj; // Pointer to the FONTOBJ
} GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;

//
// UFO_GETINFO_FONTOBJ callback structure
//

typedef struct _GETINFO_GLYPHSTRING {
    DWORD dwSize;    // Size of this structure
    DWORD dwCount;   // Count of glyphs in pGlyphIn
    DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
    PVOID pGlyphIn;  // Pointer to the input glyph string
    DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
    PVOID pGlyphOut; // Pointer to the output glyph string
    DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
} GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;

//
// UFO_GETINFO_GLYPHBITMAP
//

typedef struct _GETINFO_GLYPHBITMAP {
    DWORD       dwSize;    // Size of this structure
    HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
    GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
} GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;

//
// UFO_GETINFO_GLYPHWIDTH
//

typedef struct _GETINFO_GLYPHWIDTH {
    DWORD dwSize;  // Size of this structure
    DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
    DWORD dwCount; // Count of glyph in pGlyph
    PVOID pGlyph;  // Pointer to a glyph string
    PLONG plWidth; // Pointer to the buffer of width table.
                   // Minidriver has to prepare this.
} GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;

//
// UFO_GETINFO_MEMORY
//

typedef struct _GETINFO_MEMORY {
    DWORD dwSize;
    DWORD dwRemainingMemory;
} GETINFO_MEMORY, PGETINFO_MEMROY;

//
// UFO_GETINFO_STDVARIABLE
//
// OEM DLL has to prepare all StdVar buffer and set ID in dwStdVarID.
//

typedef struct _GETINFO_STDVAR {
    DWORD dwSize;
    DWORD dwNumOfVariable;
    struct {
        DWORD dwStdVarID;
        LONG  lStdVariable;
    } StdVar[1];
} GETINFO_STDVAR, *PGETINFO_STDVAR;


#define FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
#define FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
#define FNT_INFO_NEXTFONTID           2 // NextfontID
#define FNT_INFO_NEXTGLYPH            3 // NextGlyph
#define FNT_INFO_FONTHEIGHT           4 // FontHeight
#define FNT_INFO_FONTWIDTH            5 // FontWidth
#define FNT_INFO_FONTBOLD             6 // FontBold
#define FNT_INFO_FONTITALIC           7 // FontItalic
#define FNT_INFO_FONTUNDERLINE        8 // FontUnderline
#define FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
#define FNT_INFO_CURRENTFONTID       10 // Current
#define FNT_INFO_TEXTYRES            11 // TextYRes
#define FNT_INFO_TEXTXRES            12 // TextXRes
#define FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
#define FNT_INFO_MAX                 14

//
// OEMDownloadFontheader - UNIDRV only
//

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    );

//
// OEMTTDownloadMethod - UNIDRV only
//

DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

#define TTDOWNLOAD_DONTCARE  0
#define TTDOWNLOAD_GRAPHICS  1
#define TTDOWNLOAD_BITMAP    2
#define TTDOWNLOAD_TTOUTLINE 3

//
// OEMOutputCharStr - UNIDRV only
//

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

#define TYPE_UNICODE      1
#define TYPE_TRANSDATA    2
#define TYPE_GLYPHHANDLE  3
#define TYPE_GLYPHID      4

//
// OEMSendFontCmd - UNIDRV only
//

typedef struct _FINVOCATION {
    DWORD dwCount;    // Size of command
    PBYTE pubCommand; // Pointer to font selection command
} FINVOCATION, *PFINVOCATION;

VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//
BOOL APIENTRY
OEMTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    );

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    );

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    );

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG      *pid
    );

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG       iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

//
// OEMIcmCreateTransform
//

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

//
// OEMIcmDeleteTransform
//

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

//
// OEMQueryDeviceSupport
//

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

//
// OEMTransparentBlt
//

BOOL APIENTRY
OEMTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40

//
// Function prototype define's for the driver hooks.
//
// NOTE: These are only needed for NT4. For NT5, they are defined in winddi.h.
//

#ifdef WINNT_40

typedef BOOL (APIENTRY  *LPFNDLLINITIALIZE)(
    ULONG           ulReason
    );

typedef BOOL (APIENTRY *PFN_DrvBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_DrvStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_DrvCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_DrvTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_DrvFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_DrvRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_DrvStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_DrvSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_DrvEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_DrvStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_DrvEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_DrvQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG      *pid
    );

typedef PVOID (APIENTRY *PFN_DrvQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG      *pid
    );

typedef LONG (APIENTRY *PFN_DrvQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_DrvQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_DrvFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_DrvGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_DrvNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_DrvStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_DrvDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_DrvPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_DrvLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#endif // WINNT_40

#endif // KERNEL_MODE


/*******************************************************************************
 *
 * Definitions used by user-mode UI module only:
 *  Make sure the macro KERNEL_MODE is NOT defined and
 *  the header file winddiui.h is included before this file.
 *
 */

#ifndef KERNEL_MODE

//
// Reference to driver data structure. This is passed to
// most of the OEM UI DLL entrypoints.
//

typedef struct _OEMUIPROCS {

    PFN_DrvGetDriverSetting DrvGetDriverSetting;
    PFN_DrvUpdateUISetting  DrvUpdateUISetting;

} OEMUIPROCS, *POEMUIPROCS;

typedef struct _OEMUIOBJ {

    DWORD       cbSize;             // size of this structure
    POEMUIPROCS pOemUIProcs;        // pointer to user mode helper function table

} OEMUIOBJ, *POEMUIOBJ;


//
// OEMCommonUIProp
//

typedef struct _OEMCUIPPARAM *POEMCUIPPARAM;
typedef LONG (APIENTRY *OEMCUIPCALLBACK)(PCPSUICBPARAM, POEMCUIPPARAM);

typedef struct _OEMCUIPPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    DWORD           dwFlags;        // misc. flag bits
    POPTITEM        pDrvOptItems;   // pointer to driver items
    DWORD           cDrvOptItems;   // number of driver items
    POPTITEM        pOEMOptItems;   // pointer to OEM items
    DWORD           cOEMOptItems;   // number of OEM items
    PVOID           pOEMUserData;   // pointer to OEM private data
    OEMCUIPCALLBACK  OEMCUIPCallback; // address of callback function

} OEMCUIPPARAM;

BOOL APIENTRY
OEMCommonUIProp(
    DWORD           dwMode,
    POEMCUIPPARAM   pOemCUIPParam
    );

//
// OEMCommonUIProp dwMode parameter value
//
#define OEMCUIP_DOCPROP       1
#define OEMCUIP_PRNPROP       2

//
// OEMDocumentPropertySheets
//

LRESULT APIENTRY
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// OEMDevicePropertySheets
//

LRESULT APIENTRY
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

//
// pPSUIInfo->lParamInit is a pointer to _OEMUIPSPARAM structure defined below.
//
typedef struct _OEMUIPSPARAM {

    DWORD           cbSize;         // size of this structure
    POEMUIOBJ       poemuiobj;      // reference to driver data structure
    HANDLE          hPrinter;       // handle to the current printer
    PWSTR           pPrinterName;   // name of current printer
    HANDLE          hModule;        // instance handle to OEM DLL
    HANDLE          hOEMHeap;       // handle to the OEM memory heap
    PDEVMODE        pPublicDM;      // public devmode
    PVOID           pOEMDM;         // OEM private devmode
    PVOID           pOEMUserData;   // pointer to OEM private data
    DWORD           dwFlags;        // misc. flag bits
    PVOID           pOemEntry;

} OEMUIPSPARAM, *POEMUIPSPARAM;

//
// OEMDevQueryPrintEx
//

BOOL APIENTRY
OEMDevQueryPrintEx(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

//
// OEMDeviceCapabilities
//

DWORD APIENTRY
OEMDeviceCapabilities(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwLastResult
    );

//
// OEMUpgradePrinter
//

BOOL APIENTRY
OEMUpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

//
// OEMUpgradeRegistry
//

BOOL APIENTRY
OEMUpgradeRegistry(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgrade
    );


//
// OEMPrinterEvent
//

BOOL APIENTRY
OEMPrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

//
// OEMDriverEvent
//

BOOL APIENTRY
OEMPDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


//
// OEMQueryColorProfile
//

BOOL APIENTRY
OEMQueryColorProfile(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

//
// Font Installer dialog proc
//

INT_PTR CALLBACK
OEMFontInstallerDlgProc(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );


BOOL CALLBACK
OEMUpdateExternalFonts(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
   );


#endif // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRINTOEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\prntfont.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    prntfont.h

Abstract:

    Declarations for Windows NT printer driver font metrics and glyphset data
    *.UFF, *.UFM and *.GTT file data structure definition

--*/

#ifndef _PRNTFONT_H_
#define _PRNTFONT_H_



//
//
// F O N T  M E T R I C S  ( U F M )
//
//

//
// NOTE: To include this header file, it is necessary to include 
//       winddi.h, that has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _INVOC {
        DWORD  dwCount;     // the number of bytes in the invocation string
        DWORD  loOffset;    // byte-offset to the beginning of the array
} INVOC, *PINVOC;

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData; 
    short   sShift; 
    INVOC   SelectFont;
    INVOC   UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading 
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via 
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec 
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font. 
// All the measurements are given in the specified units, 
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table. 
// This width table is a continuous GLYPHHANDLE base, 
// not Unicode nor codepage/character code base. 
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width 
// for a single glyph. The first width corresponds to glyph index wStartGlyph 
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all 
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;



//
//
// G L Y P H  S E T D A T A  ( G T T )
//
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information 
// of printer device font. 
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values 
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD dwCodePage;
    INVOC SelectSymbolSet;
    INVOC UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to 
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number 
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system 
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//
#define CC_DEFAULT  0 // Default Character Conversion
#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.


//
//
// U N I V E R S A L  F O N T  F O R M A T  ( U F F )
//
//

//
// Font file header
//

typedef struct _UFF_FILEHEADER {
    DWORD       dwSignature;            // File magic number
    DWORD       dwVersion;              // UFF file format version number
    DWORD       dwSize;                 // Size of this structure

    DWORD       nFonts;                 // Count of fonts in directory
    DWORD       nGlyphSets;             // Count of glyph set data
    DWORD       nVarData;               // Count of variable data

    DWORD       offFontDir;             // Offset of font directory
    DWORD       dwFlags;                // Miscellaneous flags
    DWORD       dwReserved[4];          // Reserved, set to zero
} UFF_FILEHEADER, *PUFF_FILEHEADER;

//
// Values used in the file header
//

#define UFF_FILE_MAGIC      '1FFU'
#define UFF_VERSION_NUMBER  0x00010001

#define FONT_DIR_SORTED     0x00000001

//
// Font directory structure
//

typedef struct _UFF_FONTDIRECTORY {
    DWORD       dwSignature;            // Signature of font metrics record
    WORD        wSize;                  // Size of this structure
    WORD        wFontID;                // Unique font ID
    SHORT       sGlyphID;               // Associated glyph ID. 0 is default.
                                        // -ve values are predefined IDs
    WORD        wFlags;                 // Miscellaneous flags
    DWORD       dwInstallerSig;         // Signature of installer that installed this font
    DWORD       offFontName;            // Offset to name of font
    DWORD       offCartridgeName;       // Offset to name of font cartridge
    DWORD       offFontData;            // Offset to font data record
    DWORD       offGlyphData;           // Offset to glyph set data
    DWORD       offVarData;             // Offset to softfont data
} UFF_FONTDIRECTORY, *PUFF_FONTDIRECTORY;

#define FONT_REC_SIG            'CERF'  // font metrics record signature

#define WINNT_INSTALLER_SIG     'IFTN'  // NT font installer

//
// Flags used in font directory
//

#define FONT_FL_UFM             0x0001
#define FONT_FL_IFI             0x0002
#define FONT_FL_SOFTFONT        0x0004
#define FONT_FL_PERMANENT_SF    0x0008
#define FONT_FL_DEVICEFONT      0x0010
#define FONT_FL_GLYPHSET_GTT    0x0020
#define FONT_FL_GLYPHSET_RLE    0x0040
#define FONT_FL_RESERVED        0x8000

//
// Data header
//

typedef struct _DATA_HEADER {
    DWORD       dwSignature;            // Signature of data type
    WORD        wSize;                  // Size of this structure
    WORD        wDataID;                // Identifier number for data
    DWORD       dwDataSize;             // Size of data excluding structure
    DWORD       dwReserved;             // Reserved, set to zero
} DATA_HEADER, *PDATA_HEADER;

//
// Data signatures
//

#define DATA_UFM_SIG        'MFUD'
#define DATA_IFI_SIG        'IFID'
#define DATA_GTT_SIG        'TTGD'
#define DATA_CTT_SIG        'TTCD'
#define DATA_VAR_SIG        'RAVD'

//
// Structure passed to font installer dialog proc through LPARAM
//

typedef struct _OEMFONTINSTPARAM {
    DWORD   cbSize;
    HANDLE  hPrinter;
    HANDLE  hModule;
    HANDLE  hHeap;
    DWORD   dwFlags;
    PWSTR   pFontInstallerName;
} OEMFONTINSTPARAM, *POEMFONTINSTPARAM;

#define FG_CANCHANGE        0x00080    // Have access to change data

#define WM_FI_FILENAME      900        // To get the font installer name.



#endif //_PRNTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\printisv.h ===
/*++

Copyright (c) 1996 - 2000  Microsoft Corporation

Module Name:

    printisv.h

Abstract:

    Declaration  PSINJECT_constants

Environment:

    Windows NT PostScript driver

Revision History:


--*/

#ifndef _PRINTISV_H_
#define _PRINTISV_H_

//
// These definitions are only necessary for NT4.
// On NT5, they're defined in wingdi.h.
//

#ifdef WINNT_40

#define POSTSCRIPT_IDENTIFY     4117
#define POSTSCRIPT_INJECTION    4118

//
// Parameters for POSTSCRIPT_IDENTIFY escape
//

#define PSIDENT_GDICENTRIC    0
#define PSIDENT_PSCENTRIC     1

//
// Header structure for the input buffer to POSTSCRIPT_INJECTION escape
//

typedef struct _PSINJECTDATA {

    DWORD   DataBytes;          // number of raw data bytes (NOT including this header)
    WORD    InjectionPoint;     // injection point
    WORD    PageNumber;         // page number to apply the injection

    //
    // Followed by raw data to be injected
    //

} PSINJECTDATA, *PPSINJECTDATA;

//
// Constants for PSINJECTDATA.InjectionPoint field
//

#define PSINJECT_BEGINSTREAM                1   // before the first byte of job stream
#define PSINJECT_PSADOBE                    2   // before %!PS-Adobe-x.y
#define PSINJECT_PAGESATEND                 3   // replaces driver's %%Pages: (atend)
#define PSINJECT_PAGES                      4   // replaces driver's %%Pages: nnn

#define PSINJECT_DOCNEEDEDRES               5   // resources needed by the application
#define PSINJECT_DOCSUPPLIEDRES             6   // resources supplied by the application
#define PSINJECT_PAGEORDER                  7   // replaces driver's %%PageOrder:
#define PSINJECT_ORIENTATION                8   // replaces driver's %%Orientation:
#define PSINJECT_BOUNDINGBOX                9   // replaces driver's %%BoundingBox:
#define PSINJECT_DOCUMENTPROCESSCOLORS      10  // replaces driver's %%DocumentProcessColors: <color>

#define PSINJECT_COMMENTS                   11  // before %%EndComments
#define PSINJECT_BEGINDEFAULTS              12  // after %%BeginDefaults
#define PSINJECT_ENDDEFAULTS                13  // before %%EndDefaults
#define PSINJECT_BEGINPROLOG                14  // after %%BeginProlog
#define PSINJECT_ENDPROLOG                  15  // before %%EndProlog
#define PSINJECT_BEGINSETUP                 16  // after %%BeginSetup
#define PSINJECT_ENDSETUP                   17  // before %%EndSetup
#define PSINJECT_TRAILER                    18  // after %%Trailer
#define PSINJECT_EOF                        19  // after %%EOF
#define PSINJECT_ENDSTREAM                  20  // after the last byte of job stream
#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21  // replaces driver's %%DocumentProcessColors: (atend)

#define PSINJECT_PAGENUMBER                 100 // replaces driver's %%Page:
#define PSINJECT_BEGINPAGESETUP             101 // after %%BeginPageSetup
#define PSINJECT_ENDPAGESETUP               102 // before %%EndPageSetup
#define PSINJECT_PAGETRAILER                103 // after %%PageTrailer
#define PSINJECT_PLATECOLOR                 104 // replace driver's %%PlateColor: <color>

#define PSINJECT_SHOWPAGE                   105 // before showpage operator
#define PSINJECT_PAGEBBOX                   106 // replaces driver's %%PageBoundingBox:
#define PSINJECT_ENDPAGECOMMENTS            107 // before %%EndPageComments

#define PSINJECT_VMSAVE                     200 // before save operator
#define PSINJECT_VMRESTORE                  201 // after restore operator

//
// Escape for app to get PostScript driver's settings
//

#define GET_PS_FEATURESETTING      4121

//
// Escape for pre-StartDoc passthrough
//

#define SPCLPASSTHROUGH2        4568

//
// Parameter for GET_PS_FEATURESETTING escape
//

#define FEATURESETTING_NUP         0
#define FEATURESETTING_OUTPUT      1
#define FEATURESETTING_PSLEVEL     2
#define FEATURESETTING_CUSTPAPER   3
#define FEATURESETTING_MIRROR      4
#define FEATURESETTING_NEGATIVE    5
#define FEATURESETTING_PROTOCOL    6

//
// Information about output options
//

typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;

//
// Information about custom paper size
//

typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

//
// Value returned for FEATURESETTING_PROTOCOL
//

#define PSPROTOCOL_ASCII           0
#define PSPROTOCOL_BCP             1
#define PSPROTOCOL_TBCP            2
#define PSPROTOCOL_BINARY          3

#endif // WINNT_40

#endif // !_PRINTISV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\command.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:  Command.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEM Command function(s).
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _COMMAND_H
#define _COMMAND_H




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL PSCommand(PDEVOBJ, DWORD, PVOID, DWORD, IPrintOemDriverPS*);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\command.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	command.cpp
//    
//
//  PURPOSE:  Source module for OEM customized Command(s).
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "oemps.h"
#include "debug.h"
#include "command.h"
#include "resource.h"


////////////////////////////////////////////////////////
//      Internal String Literals
////////////////////////////////////////////////////////

#define TEST_BEGINSTREAM     "%%Test: Before begin stream\r\n"
#define TEST_PSADOBE         "%%Test: Before %!PS-Adobe\r\n"
#define TEST_COMMENTS        "%%Test: Before %%EndComments\r\n"
#define TEST_DEFAULTS        "%%Test: Before %%BeginDefaults and %%EndDefaults\r\n"
#define TEST_BEGINPROLOG     "%%Test: After %%BeginProlog\r\n"
#define TEST_ENDPROLOG       "%%Test: Before %%EndProlog\r\n"
#define TEST_BEGINSETUP      "%%Test: After %%BeginSetup\r\n"
#define TEST_ENDSETUP        "%%Test: Before %%EndSetup\r\n"
#define TEST_BEGINPAGESETUP  "%%Test: After %%BeginPageSetup\r\n"
#define TEST_ENDPAGESETUP    "%%Test: Before %%EndpageSetup\r\n"
#define TEST_PAGETRAILER     "%%Test: After %%PageTrailer\r\n"
#define TEST_TRAILER         "%%Test: After %%Trailer\r\n"
#define TEST_PAGES           "%%Test: Replace driver's %%Pages: (atend)\r\n"
#define TEST_PAGENUMBER      "%%Test: Replace driver's %%Page:\r\n"
#define TEST_PAGEORDER       "%%Test: Replace driver's %%PageOrder:\r\n"
#define TEST_ORIENTATION     "%%Test: Replace driver's %%Orientation:\r\n"
#define TEST_BOUNDINGBOX     "%%Test: Replace driver's %%BoundingBox:\r\n"
#define TEST_DOCNEEDEDRES    "%%Test: Append to driver's %%DocumentNeededResourc\r\n"
#define TEST_DOCSUPPLIEDRES  "%%Test: Append to driver's %%DocumentSuppliedResou\r\n"
#define TEST_EOF             "%%Test: After %%EOF\r\n"
#define TEST_ENDSTREAM       "%%Test: After the last byte of job stream\r\n"
#define TEST_VMSAVE          "%%Test: VMSave\r\n"
#define TEST_VMRESTORE       "%%Test: VMRestore\n"



////////////////////////////////////////////////////////////////////////////////////
//    The PSCRIPT driver calls this OEM function at specific points during output
//    generation. This gives the OEM DLL an opportunity to insert code fragments
//    at specific injection points in the driver's code. It should use
//    DrvWriteSpoolBuf for generating any output it requires.

BOOL PSCommand(PDEVOBJ pdevobj, DWORD dwIndex, PVOID pData, DWORD cbSize, IPrintOemDriverPS* pOEMHelp)
{
    PSTR    pProcedure = NULL;
    DWORD   dwLen = 0;
    DWORD   dwSize = 0;


    VERBOSE(DLLTEXT("Entering OEMCommand...\r\n"));

    switch (dwIndex)
    {
        case PSINJECT_BEGINSTREAM:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINSTREAM\n"));
            pProcedure = TEST_BEGINSTREAM;
            break;

        case PSINJECT_PSADOBE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PSADOBE\n"));
            pProcedure = TEST_PSADOBE;
            break;

        case PSINJECT_COMMENTS:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_COMMENTS\n"));
            pProcedure = TEST_COMMENTS;
            break;

        case PSINJECT_BEGINPROLOG:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPROLOG\n"));
            pProcedure = TEST_BEGINPROLOG;
            break;

        case PSINJECT_ENDPROLOG:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDPROLOG\n"));
            pProcedure = TEST_ENDPROLOG;
            break;

        case PSINJECT_BEGINSETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINSETUP\n"));
            pProcedure = TEST_BEGINSETUP;
            break;

        case PSINJECT_ENDSETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDSETUP\n"));
            pProcedure = TEST_ENDSETUP;
            break;

        case PSINJECT_BEGINPAGESETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPAGESETUP\n"));
            pProcedure = TEST_BEGINPAGESETUP;
            break;

        case PSINJECT_ENDPAGESETUP:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDPAGESETUP\n"));
            pProcedure = TEST_ENDPAGESETUP;
            break;

        case PSINJECT_PAGETRAILER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGETRAILER\n"));
            pProcedure = TEST_PAGETRAILER;
            break;

        case PSINJECT_TRAILER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_TRAILER\n"));
            pProcedure = TEST_TRAILER;
            break;

        case PSINJECT_PAGES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGES\n"));
            pProcedure = TEST_PAGES;
            break;

        case PSINJECT_PAGENUMBER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGENUMBER\n"));
            pProcedure = TEST_PAGENUMBER;
            break;

        case PSINJECT_PAGEORDER:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_PAGEORDER\n"));
            pProcedure = TEST_PAGEORDER;
            break;

        case PSINJECT_ORIENTATION:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ORIENTATION\n"));
            pProcedure = TEST_ORIENTATION;
            break;

        case PSINJECT_BOUNDINGBOX:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_BOUNDINGBOX\n"));
            pProcedure = TEST_BOUNDINGBOX;
            break;

        case PSINJECT_DOCNEEDEDRES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCNEEDEDRES\n"));
            pProcedure = TEST_DOCNEEDEDRES;
            break;

        case PSINJECT_DOCSUPPLIEDRES:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_DOCSUPPLIEDRES\n"));
            pProcedure = TEST_DOCSUPPLIEDRES;
            break;

        case PSINJECT_EOF:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_EOF\n"));
            pProcedure = TEST_EOF;
            break;

        case PSINJECT_ENDSTREAM:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_ENDSTREAM\n"));
            pProcedure = TEST_ENDSTREAM;
            break;

        case PSINJECT_VMSAVE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_VMSAVE\n"));
            pProcedure = TEST_VMSAVE;
            break;

        case PSINJECT_VMRESTORE:
            VERBOSE(DLLTEXT("OEMCommand PSINJECT_VMRESTORE\n"));
            pProcedure = TEST_VMRESTORE;
            break;

        default:
            ERR(DLLTEXT("Undefined PSCommand %d!\r\n"), dwIndex);
            return TRUE;
    }

    if(NULL != pProcedure)
    {
        // Write PostScript to spool file.
        dwLen = strlen(pProcedure);
        pOEMHelp->DrvWriteSpoolBuf(pdevobj, pProcedure, dwLen, &dwSize);

        // Dump DrvWriteSpoolBuf parameters.
        VERBOSE(DLLTEXT("dwLen  = %d\r\n"), dwLen);
        VERBOSE(DLLTEXT("dwSize = %d\r\n"), dwSize);
        //VERBOSE(DLLTEXT("pProcedure is:\r\n\t%hs\r\n"), pProcedure);
    }
    else
    {
        RIP(DLLTEXT("PSCommand pProcedure is NULL!\r\n"));
    }

    // dwLen should always equal dwSize.
    ASSERTMSG(dwLen == dwSize, DLLTEXT("number of bytes wrote should equal number of bytes written!"));

    return (dwLen == dwSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\winsplkm.h ===
/*++

Copyright (c) 1996 - 2000  Microsoft Corporation

Module Name:

    winsplkm.h

Abstract:

    Duplicate definitions for some of the stuff in winspool.h.
    They are duplicated here because kernel mode components cannot include winspool.h

Environment:

    Windows NT printer driver

Revision History:


--*/


#ifndef _WINSPLKM_H_
#define _WINSPLKM_H_

typedef struct _FORM_INFO_1 {
    DWORD   Flags;
    PWSTR   pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1, *PFORM_INFO_1;

#define FORM_USER    0x0000
#define FORM_BUILTIN 0x0001
#define FORM_PRINTER 0x0002

typedef struct _DRIVER_INFO_2 {
    DWORD   cVersion;
    PWSTR   pName;
    PWSTR   pEnvironment;
    PWSTR   pDriverPath;
    PWSTR   pDataFile;
    PWSTR   pConfigFile;
} DRIVER_INFO_2, *PDRIVER_INFO_2;

typedef struct _DRIVER_INFO_3 {
    DWORD   cVersion;
    PWSTR   pName;
    PWSTR   pEnvironment;
    PWSTR   pDriverPath;
    PWSTR   pDataFile;
    PWSTR   pConfigFile;
    PWSTR   pHelpFile;
    PWSTR   pDependentFiles;
    PWSTR   pMonitorName;
    PWSTR   pDefaultDataType;
} DRIVER_INFO_3, *PDRIVER_INFO_3;

typedef struct _PRINTER_INFO_2 {
    PWSTR    pServerName;
    PWSTR    pPrinterName;
    PWSTR    pShareName;
    PWSTR    pPortName;
    PWSTR    pDriverName;
    PWSTR    pComment;
    PWSTR    pLocation;
    PDEVMODE pDevMode;
    PWSTR    pSepFile;
    PWSTR    pPrintProcessor;
    PWSTR    pDatatype;
    PWSTR    pParameters;
    PVOID    pSecurityDescriptor;
    DWORD    Attributes;
    DWORD    Priority;
    DWORD    DefaultPriority;
    DWORD    StartTime;
    DWORD    UntilTime;
    DWORD    Status;
    DWORD    cJobs;
    DWORD    AveragePPM;
} PRINTER_INFO_2, *PPRINTER_INFO_2;

#endif  // !_WINSPLKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\nt4\inc\winddiui.h ===
/********************************************************************

    WinDDiUi.h -- Header file for the UI portion of printer drivers.

    Copyright (c) 1995 1996, Microsoft Corp.
    All rights reserved.

********************************************************************/

#ifndef _WINDDIUI_
#define _WINDDIUI_

#include <compstui.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// DrvDevicePropertySheets replace previous version of PrinterProperties
//

LONG WINAPI
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    );

typedef struct _DEVICEPROPERTYHEADER {
    WORD    cbSize;
    WORD    Flags;
    HANDLE  hPrinter;
    LPTSTR  pszPrinterName;
} DEVICEPROPERTYHEADER, *PDEVICEPROPERTYHEADER;

#define DPS_NOPERMISSION    0x0001


//
// For document properties replace DocumentProperties.
//
// Note: if pPSUIInfo is NULL then the call need not to display any dialog
//       boxes (Ignored the DC_PROMPT bit in the fMode, the lParam in this case
//       is a pointer to DOCUMENTPROPERTYHEADER
//

LONG WINAPI
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    );

typedef struct _DOCUMENTPROPERTYHEADER {
    WORD        cbSize;
    WORD        Reserved;
    HANDLE      hPrinter;
    LPTSTR      pszPrinterName;
    PDEVMODE    pdmIn;
    PDEVMODE    pdmOut;
    DWORD       cbOut;
    DWORD       fMode;
} DOCUMENTPROPERTYHEADER, *PDOCUMENTPROPERTYHEADER;

#define DM_ADVANCED         0x10
#define DM_NOPERMISSION     0x20
#define DM_USER_DEFAULT     0x40


// Devmode conversion function used by GetPrinter and SetPrinter

BOOL WINAPI
DrvConvertDevMode(
    LPTSTR   pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode
    );

#define CDM_CONVERT         0x01
#define CDM_CONVERT351      0x02
#define CDM_DRIVER_DEFAULT  0x04


//
// This is for DevQueryPrintEx()
//

typedef struct _DEVQUERYPRINT_INFO {
    WORD    cbSize;         // size of this structure in bytes
    WORD    Level;          // Level of this info, 1 for this version
    HANDLE  hPrinter;       // handle to the printer for the query
    DEVMODE *pDevMode;      // pointer to the DEVMODE for this job.
    LPTSTR  pszErrorStr;    // pointer to the error string buffer.
    DWORD   cchErrorStr;    // count characters of pwErrorStr passed.
    DWORD   cchNeeded;      // count characters of pwErrorStr needed.
    } DEVQUERYPRINT_INFO, *PDEVQUERYPRINT_INFO;

BOOL WINAPI
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    );

//
// This for the DrvUpgradePrinter
//

typedef struct _DRIVER_UPGRADE_INFO_1 {
    LPTSTR  pPrinterName;
    LPTSTR  pOldDriverDirectory;
} DRIVER_UPGRADE_INFO_1, *PDRIVER_UPGRADE_INFO_1;

typedef struct _DRIVER_UPGRADE_INFO_2 {
    LPTSTR   pPrinterName;
    LPTSTR   pOldDriverDirectory;
    DWORD    cVersion;
    LPTSTR   pName;
    LPTSTR   pEnvironment;
    LPTSTR   pDriverPath;
    LPTSTR   pDataFile;
    LPTSTR   pConfigFile;
    LPTSTR   pHelpFile;
    LPTSTR   pDependentFiles;
    LPTSTR   pMonitorName;
    LPTSTR   pDefaultDataType;
    LPTSTR   pszzPreviousNames;
} DRIVER_UPGRADE_INFO_2, *PDRIVER_UPGRADE_INFO_2;

BOOL WINAPI
DrvUpgradePrinter(
    DWORD   Level,
    LPBYTE  pDriverUpgradeInfo
    );

//
// DrvDocumentEvent
//
//
//  Defines and proto-types for hooking GDI printer management functions
//
//  return values: -1 means error, 0 means not supported function
//
//  CreateDCPre must return > 0 or none of the others will be called.
//
//
//  CREATEDCPRE
//      return failure from CreateDC if this fails, CREATEDCPOST not called
//      bIC - TRUE if came from CreateIC
//      output devmode - this is the devmode that actualy gets passed to the
//      server side driver.  Any data needed in EnablePDEV should be passed
//      as part of the DriverExtra.
//
//  CREATEDCPOST
//      return value is ignored
//      the hdc will be 0 if something failed since CREATEDCPRE
//      The input buffer contains a pointer to the devmode returned in the
//      CREATEDCPRE output buffer
//
//  RESETDCPRE
//      return failure from ResetDC if this fails, CREATEDCPOST not called
//
//  RESETDCPOST
//      return value is ignored
//
//  STARTDOCPRE
//      return failure form StartDoc if this fails, driver not called
//
//  STARTDOCPOST
//      return failure form StartDoc if this fails, driver already called.
//      AbortDoc() called.
//
//  STARTPAGE
//      return failure form EndPage if this fails, driver not called
//
//  ENDPAGE
//      return value is ignored, DrvEndPage always called
//
//  ENDDOCPRE
//      return value is ignored, DrvEndDoc always called
//
//  ENDDOCPOST
//      return value is ignored, DrvEndDoc has alreadybeen called
//
//  ABORTDOC
//      return value is ignored
//
//  DELETEDC
//      return value is ignored
//
//  EXTESCAPE
//      return value is ignored
//      The input buffer includes the ExtEscape escape value, size of input
//      buffer to ExtEscape and the input buffer passed in.
//      The output buffer is just the buffer that was passed to ExtEscape
//
//  DOCUMENTEVENT_SPOOLED
//      This flag is added to the iEsc value if the document is being spooled
//      to a metafile rather than going direct.  Note that if this bit is set
//
//

#define DOCUMENTEVENT_EVENT(iEsc) (LOWORD(iEsc))
#define DOCUMENTEVENT_FLAGS(iEsc) (HIWORD(iEsc))

typedef struct _DOCEVENT_FILTER {
    UINT    cbSize;
    UINT    cElementsAllocated;
    UINT    cElementsNeeded;
    UINT    cElementsReturned;
    DWORD   aDocEventCall[ANYSIZE_ARRAY];
} DOCEVENT_FILTER, *PDOCEVENT_FILTER;

//
// Add structures usded for each DocumentEvent calls
//

typedef struct _DOCEVENT_CREATEDCPRE {
    PWSTR       pszDriver;
    PWSTR       pszDevice;
    PDEVMODEW   pdm;
    BOOL        bIC;
} DOCEVENT_CREATEDCPRE, *PDCEVENT_CREATEDCPRE;

typedef struct _DOCEVENT_ESCAPE {
    int    iEscape;
    int    cjInput;
    PVOID  pvInData;
} DOCEVENT_ESCAPE, *PDOCEVENT_ESCAPE;

//
// Escape codes for DrvDocumentEvent
//

#define DOCUMENTEVENT_FIRST         1   // Inclusive lower bound
#define DOCUMENTEVENT_CREATEDCPRE   1   // in-pszDriver, pszDevice, pdm, bIC, out-ppdm
#define DOCUMENTEVENT_CREATEDCPOST  2   // in-ppdm
#define DOCUMENTEVENT_RESETDCPRE    3   // in-pszDriver, pszDevice, pdm, out-ppdm
#define DOCUMENTEVENT_RESETDCPOST   4   // in-ppdm
#define DOCUMENTEVENT_STARTDOC      5   // none
#define DOCUMENTEVENT_STARTDOCPRE   5   // none
#define DOCUMENTEVENT_STARTPAGE     6   // none
#define DOCUMENTEVENT_ENDPAGE       7   // none
#define DOCUMENTEVENT_ENDDOC        8   // none
#define DOCUMENTEVENT_ENDDOCPRE     8   // none
#define DOCUMENTEVENT_ABORTDOC      9   // none
#define DOCUMENTEVENT_DELETEDC     10   // none
#define DOCUMENTEVENT_ESCAPE       11   // in-iEsc, cjInBuf, inBuf, out-outBuf
#define DOCUMENTEVENT_ENDDOCPOST   12   // none
#define DOCUMENTEVENT_STARTDOCPOST 13   // none
#define DOCUMENTEVENT_QUERYFILTER  14   // none
#define DOCUMENTEVENT_LAST         15   // Non-inclusive upper bound

#define DOCUMENTEVENT_SPOOLED   0x10000

//
// Return values for DrvDocumentEvent
//

#define DOCUMENTEVENT_SUCCESS     1
#define DOCUMENTEVENT_UNSUPPORTED 0
#define DOCUMENTEVENT_FAILURE     -1

int WINAPI
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PVOID   pvIn,
    ULONG   cbOut,
    PVOID   pvOut
);


//
// DrvPrinterEvent
//
        //
//    DrvPrinterEvent are called by the print subsystem when events
//    happen that might be of interest to a printer driver
//    The only event which should be implemented in the driver
//    is PRITNER_EVENT_INITIALIZE so that default settings are created
//    for the printer.
//
// PRINTER_EVENT_CONFIGURATION_CHANGE
//        Reserve it for future use.Xerox is already using it.
//
// PRINTER_EVENT_ADD_CONNECTION
//        return value ignored
//        Called after a successful AddPrinterConnection API
//        in the context of the calling app
//        lParam NULL
//
// PRINTER_EVENT_DELETE_CONNECTION
//        return value ignored
//        Called Before DeletePrinterConnect API
//        in the context of the calling app
//        lParam NULL
//
// PRINTER_EVENT_INITIALIZE
//        Called when a printer is created for the driver to
//        initialize its registry settings
//        Called in the spooler process
//        lParam NULL
//
// PRINTER_EVENT_DELETE
//        Called when a printer is about to be deleted
//        Called in the spooler process
//        lParam NULL
//
// PRINTER_EVENT_CACHE_REFRESH
//        return value ignored
//        called in spooler process
//        No UI
//        called when spooler detects that something has
//        changed in the workstaion cache or when establishing
//        the cache.
//        allows driver to update any private cache data
//        ( such as font files etc. )
//
// PRINTER_EVENT_CACHE_DELETE
//        return value ignored
//        called in spooler process
//        No UI
//        called when spooler is deleting a cached printer
//        allows printer driver to delete anything it has
//        cached
//
// PRINTER_EVENT_FLAG_NO_UI
//        Do not bring up UI when this flag it ON
//

//
// DrvPrinterEvent DriverEvent code
//
#define PRINTER_EVENT_CONFIGURATION_CHANGE      0
#define PRINTER_EVENT_ADD_CONNECTION            1
#define PRINTER_EVENT_DELETE_CONNECTION         2
#define PRINTER_EVENT_INITIALIZE                3
#define PRINTER_EVENT_DELETE                    4
#define PRINTER_EVENT_CACHE_REFRESH             5
#define PRINTER_EVENT_CACHE_DELETE              6

//
// DrvPrinterEvent Flags
//

#define PRINTER_EVENT_FLAG_NO_UI        0x00000001


BOOL WINAPI
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    int     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
);

//
// DrvDriverEvent is called when any version of the printer driver is deleted.
//
#define DRIVER_EVENT_INITIALIZE        0x00000001
#define DRIVER_EVENT_DELETE            0x00000002

BOOL WINAPI
DrvDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
);

// Print processor capabilities for the driver.
#define BORDER_PRINT                   0x00000000        // default
#define NO_BORDER_PRINT                0x00000001

#define BOOKLET_PRINT                  0x00000002

#define NO_COLOR_OPTIMIZATION          0x00000000        // default
#define COLOR_OPTIMIZATION             0x00000001

typedef struct _ATTRIBUTE_INFO_1 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
} ATTRIBUTE_INFO_1, *PATTRIBUTE_INFO_1;

typedef struct _ATTRIBUTE_INFO_2 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
    DWORD    dwColorOptimization;           // Added for monochrome optimization
} ATTRIBUTE_INFO_2, *PATTRIBUTE_INFO_2;

typedef struct _ATTRIBUTE_INFO_3 {
    DWORD    dwJobNumberOfPagesPerSide;
    DWORD    dwDrvNumberOfPagesPerSide;
    DWORD    dwNupBorderFlags;
    DWORD    dwJobPageOrderFlags;
    DWORD    dwDrvPageOrderFlags;
    DWORD    dwJobNumberOfCopies;
    DWORD    dwDrvNumberOfCopies;
    DWORD    dwColorOptimization;           // Added for monochrome optimization
    short    dmPrintQuality;                // Added for monochrome optimization
    short    dmYResolution;                 // Added for monochrome optimization
} ATTRIBUTE_INFO_3, *PATTRIBUTE_INFO_3;


//
// DrvQueryJobAttributes is called by the spooler(print processor) to get information
// about the printing options used with the job. These options include N-up and reverse
// order printing.
//
BOOL WINAPI
DrvQueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevMode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo
);

//
// DrvQueryColorProfile is called by the GDI (graphics device interface) to get information
// about the default color profile for the given DEVMODE, used with ICM (image color
// management).
//
BOOL WINAPI
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdevmode,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
);

// The value for ulQueryMode
#define QCP_DEVICEPROFILE   0x0000
#define QCP_SOURCEPROFILE   0x0001

// The flags for pflProfileData.
#define QCP_PROFILEMEMORY  0x0001 // The pvProfileData points the color profile data itself.
#define QCP_PROFILEDISK    0x0002 // The pvProfileData points the color profile file name in Unicode.

//
//  User Mode Printer Driver DLL,
//
//  Note on hPrinter passed into DrvSplStartDoc() and subsequent
//  DrvSplxxx calls
//
//
//  A. If you have DrvSplxxxx calls in separate DLL and link it with
//     spoolss.lib.
//
//      * The hPrinter will be valid for any call to the spooler, such as
//        WritePrinter(), GetPrinterData()
//
//      * To do this you must
//
//          1. Have separate DLL for all DrvSplxxx functions.
//          2. Put this DLL name into your dependency files (inf).
//          3. link to spoolss.lib rather than winspool.lib
//          4. Use SetPrinterData() with SPLPRINTER_USER_MODE_PRINTER_DRIVER
//             as key name, and this DLL name as data.
//          5. Call any spooler functions linked from spoolss.lib
//
//
//
//  B. If you have DrvSplxxx calls located in your printer driver UI DLL and
//     linked with winspool.lib
//
//      * The hPrinter is NOT valid for any spooler calls, such as
//        WritePrinter(), GetPrinterData() from within the DrvSplxxx driver
//        functions.
//
//      * To do any spooler call from inside of DrvSplxxxx function you must
//        do the following
//
//          1. hSpoolSS = LoadLibrary("spoolss.dll");
//          2. pfn = GetProcAddress("WritePrinter") or whatever the spooler
//             functions you wish to call
//          3. Call the pfn function pointer returned from GetProcAddress()
//          4. FreeLibrary(hSpoolSS);
//
//
//  The A method is recommended.
//
//
//  If a UserModePrinterDriver DLL is created the following routines are
//  required or optional
//
//  Required Routines
//      DrvSplStartDoc
//      DrvSplWritePrinter
//      DrvSplEndDoc
//      DrvSplClose
//
//
//  Optional Routines
//      DrvSplStart
//      DrvSplEndPage
//      DrvSplAbort
//
//


HANDLE WINAPI
DrvSplStartDoc(
    HANDLE  hPrinter,
    DWORD   JobId
);


BOOL WINAPI
DrvSplWritePrinter(
    HANDLE  hDriver,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

VOID WINAPI
DrvSplEndDoc(
    HANDLE  hDriver
);


VOID WINAPI
DrvSplClose(
    HANDLE  hDriver
);


BOOL WINAPI
DrvSplStartPage(
    HANDLE  hDriver
);

BOOL WINAPI
DrvSplEndPage(
    HANDLE  hDriver
);

VOID WINAPI
DrvSplAbort(
    HANDLE  hDriver
);



//
//  Printer Attribute
//  Use with SetPrinterData to define UMPD.DLL
//

#define SPLPRINTER_USER_MODE_PRINTER_DRIVER     TEXT("SPLUserModePrinterDriver")


#ifdef __cplusplus
}
#endif

#endif  /* !_WINDDIUI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "oemps.h"
#include "debug.h"
#include "devmode.h"
#include "kmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data.
    pOEMDevmode->dwDriverData = 0;

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(_TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(_TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(_TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(_TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\ddihook.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	 DDIHook.cpp
//    
//
//  PURPOSE:  DDI Hook routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "debug.h"
#include "oemps.h"




//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnPS[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


    //
    // turn around to call PS
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnPS[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}


//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnPS[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvTextOut)(poempdev->pfnPS[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnPS[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvFillPath)(poempdev->pfnPS[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnPS[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMRealizeBrush() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into PS since PS doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStartPage)(poempdev->pfnPS[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMSendPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call PS
    //

    return (((PFN_DrvSendPage)(poempdev->pfnPS[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvEscape)(poempdev->pfnPS[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnPS[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnPS[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnPS[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnPS[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnPS[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnPS[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that PS will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnPS[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnPS[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}




#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnPS[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));


}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnPS[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnPS[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj
            ));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
        SURFOBJ    *psoDest,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        TRIVERTEX  *pVertex,
        ULONG       nVertex,
        PVOID       pMesh,
        ULONG       nMesh,
        RECTL      *prclExtents,
        POINTL     *pptlDitherOrg,
        ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnPS[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

BOOL APIENTRY
OEMTransparentBlt(
        SURFOBJ    *psoDst,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclDst,
        RECTL      *prclSrc,
        ULONG      iTransColor,
        ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnPS[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}

HANDLE APIENTRY
OEMIcmCreateColorTransform(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCreateColorTransform() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvIcmCreateColorTransform)(poempdev->pfnPS[UD_DrvIcmCreateColorTransform])) (
            dhpdev,
            pLogColorSpace,
            pvSourceProfile,
            cjSourceProfile,
            pvDestProfile,
            cjDestProfile,
            pvTargetProfile,
            cjTargetProfile,
            dwReserved
            ));

}

BOOL APIENTRY
OEMIcmDeleteColorTransform(
    DHPDEV dhpdev,
    HANDLE hcmXform
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMDeleteColorTransform() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvIcmDeleteColorTransform)(poempdev->pfnPS[UD_DrvIcmDeleteColorTransform])) (
            dhpdev,
            hcmXform
            ));

}

BOOL APIENTRY
OEMQueryDeviceSupport(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryDeviceSupport() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call PS
    //

    return (((PFN_DrvQueryDeviceSupport)(poempdev->pfnPS[UD_DrvQueryDeviceSupport])) (
            pso,
            pxlo,
            pxo,
            iType,
            cjIn,
            pvIn,
            cjOut,
            pvOut
            ));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "oemps.h"
#include "debug.h"
#include "kmode.h"


// Used in kernel mode implementation to declare a critical section.
// Need to similate InterlockedIncrement and InterlockedDecrement
// by using a semaphore, since these functions don't
// exist in kernel mode.
DECLARE_CRITICAL_SECTION;



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
    BOOL    bRet = TRUE;

	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            INIT_CRITICAL_SECTION();
            bRet = IS_VALID_CRITICAL_SECTION();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DELETE_CRITICAL_SECTION();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return bRet;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H

#include "kmode.h"


////////////////////////////////////////////////////////////////////////////////
//
//  IOemPS
//
//  Interface for PostScript OEM sample rendering module
//
class IOemPS : public IPrintOemPS
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);


    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);
    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommand - PSCRIPT only, return E_NOTIMPL on Unidrv
    //

    STDMETHOD(Command) (THIS_ PDEVOBJ     pdevobj,
                              DWORD       dwIndex,
                              PVOID       pData,
                              DWORD       cbSize,
                              OUT DWORD   *pdwResult);

    //

    IOemPS();
    ~IOemPS();

protected:
    long                m_cRef;
    IPrintOemDriverPS*  m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemps.h"
#include "debug.h"
#include "command.h"
#include "intrface.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents;     // Count of active components
static long g_cServerLocks;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IOemPS body
//
IOemPS::IOemPS() 
{ 
    VERBOSE(DLLTEXT("IOemPS::IOemPS() entered.\r\n"));

    // Increment COM component count.
    InterlockedIncrement(&g_cComponents);

    InterlockedIncrement(&m_cRef);
    m_pOEMHelp = NULL; 

    VERBOSE(DLLTEXT("IOemPS::IOemPS() leaving.\r\n"));
}


IOemPS::~IOemPS()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);

    // Decrement COM compontent count.
    InterlockedDecrement(&g_cComponents);
}


HRESULT __stdcall IOemPS::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemPS::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemPS)
    {
        *ppv = static_cast<IPrintOemPS*>(this);
        VERBOSE(DLLTEXT("IOemPS::QueryInterface IPrintOemPs.\r\n")); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemPS::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemPS::AddRef()
{
    VERBOSE(DLLTEXT("IOemPS::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemPS::Release() 
{
    VERBOSE(DLLTEXT("IOemPS::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT __stdcall IOemPS::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemPS::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        ERR(DLLTEXT("IOemPS::GetInfo() exit pcbNeeded is NULL!\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        ERR(DLLTEXT("IOemPS::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            ERR(DLLTEXT("IOemPS::GetInfo() exit, mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemPS::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IOemPS::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemPS::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverPS, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IOemPS::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemPS::EnableDriver() entry.\r\n"));

    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Even if nothing is done, need to return S_OK so 
    // that DisableDriver() will be called, which releases
    // the reference to the Printer Driver's interface.
    return S_OK;
}

HRESULT __stdcall IOemPS::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemPS::DisaleDriver() entry.\r\n"));

    OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IOemPS::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemPS::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj);

    return S_OK;
};

HRESULT __stdcall IOemPS::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IOemPS::EnablePDEV() entry.\r\n"));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    return (NULL != *pDevOem ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemPS::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IOemPS::ResetPDEV() entry.\r\n"));

    bResult = OEMResetPDEV(pdevobjOld, pdevobjNew);

    return (bResult ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemPS::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemPS:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemPS::Command(
    PDEVOBJ     pdevobj,
    DWORD       dwIndex,
    PVOID       pData,
    DWORD       cbSize,
    OUT DWORD   *pdwResult)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IOemPS::Command() entry.\r\n"));
    bResult = PSCommand(pdevobj, dwIndex, pData, cbSize, m_pOEMHelp);

    if(bResult)
    {
        *pdwResult = ERROR_SUCCESS;
        return S_OK;
    }

#ifdef USERMODE_DRIVER
    *pdwResult = GetLastError();
#else
    // Don't know what the error is in KMODE.
    *pdwResult = ERROR_SUCCESS;
#endif
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF();
    ~IOemCF();

protected:
    long    m_cRef;
};

///////////////////////////////////////////////////////////
//
// Class factory body
//
IOemCF::IOemCF()
{ 
    VERBOSE(DLLTEXT("IOemCF::IOemCF() entered.\r\n"));

    InterlockedIncrement(&m_cRef);
}

IOemCF::~IOemCF() 
{ 
    VERBOSE(DLLTEXT("IOemCF::~IOemCF() entered.\r\n"));

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemCF::QueryInterface entered.\r\n"));

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    VERBOSE(DLLTEXT("IOemCF::QueryInterface leaving.\r\n"));

    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    VERBOSE(DLLTEXT("IOemCF::AddRef() called.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
    VERBOSE(DLLTEXT("IOemCF::Release() called.\r\n"));

    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    VERBOSE(DLLTEXT("Class factory:  Create component.\r\n"));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        WARNING(DLLTEXT("Class factory:  non-Null pUnknownOuter.\r\n"));

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemPS* pOemCP = new IOemPS;
    if (pOemCP == NULL)
    {
        ERR(ERRORTEXT("Class factory:  failed to allocate IOemPS.\r\n"));

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    VERBOSE(DLLTEXT("IOemCF::LockServer(%d) entered.\r\n"), bLock);

    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }

    VERBOSE(DLLTEXT("IOemCF::LockServer() leaving.\r\n"));
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:  Create class factory entered.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        ERR(ERRORTEXT("DllGetClassObject:  doesn't support clsid %#x!\r\n"), clsid);
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        ERR(ERRORTEXT("DllGetClassObject:  memory allocation failed!\r\n"));
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();


    VERBOSE(DLLTEXT("DllGetClassObject:  Create class factory leaving.\r\n"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.
